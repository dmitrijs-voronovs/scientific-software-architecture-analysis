quality_attribute,sentence,source,author,repo,version,id,keyword,matched_word,match_idx,filename,wiki,url,total_similar,target_keywords,target_matched_words
Testability,"l voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooAbsMoment*RooAbsReal::mean(RooRealVar& obs); RooAbsMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooNumRunningInt&operator=(const RooNumRunningInt&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueO",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooNumRunningInt.html:19119,test,testArg,19119,root/html602/RooNumRunningInt.html,https://root.cern,https://root.cern/root/html602/RooNumRunningInt.html,2,['test'],['testArg']
Testability,"l voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooAbsMoment*RooAbsReal::mean(RooRealVar& obs); RooAbsMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooParamHistFunc&operator=(const RooParamHistFunc&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueO",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooParamHistFunc.html:18422,test,testArg,18422,root/html602/RooParamHistFunc.html,https://root.cern,https://root.cern/root/html602/RooParamHistFunc.html,2,['test'],['testArg']
Testability,"l voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooAbsMoment*RooAbsReal::mean(RooRealVar& obs); RooAbsMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooPolyVar&operator=(const RooPolyVar&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooPolyVar.html:18546,test,testArg,18546,root/html602/RooPolyVar.html,https://root.cern,https://root.cern/root/html602/RooPolyVar.html,2,['test'],['testArg']
Testability,"l voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooAbsMoment*RooAbsReal::mean(RooRealVar& obs); RooAbsMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooProduct&operator=(const RooProduct&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooProduct.html:18424,test,testArg,18424,root/html602/RooProduct.html,https://root.cern,https://root.cern/root/html602/RooProduct.html,2,['test'],['testArg']
Testability,"l voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooAbsMoment*RooAbsReal::mean(RooRealVar& obs); RooAbsMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooPullVar&operator=(const RooPullVar&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooPullVar.html:18686,test,testArg,18686,root/html602/RooPullVar.html,https://root.cern,https://root.cern/root/html602/RooPullVar.html,2,['test'],['testArg']
Testability,"l voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooAbsMoment*RooAbsReal::mean(RooRealVar& obs); RooAbsMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooRangeBoolean&operator=(const RooRangeBoolean&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooRangeBoolean.html:18389,test,testArg,18389,root/html602/RooRangeBoolean.html,https://root.cern,https://root.cern/root/html602/RooRangeBoolean.html,2,['test'],['testArg']
Testability,"l voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooAbsMoment*RooAbsReal::mean(RooRealVar& obs); RooAbsMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooRealMPFE&operator=(const RooRealMPFE&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFAL",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooRealMPFE.html:19282,test,testArg,19282,root/html602/RooRealMPFE.html,https://root.cern,https://root.cern/root/html602/RooRealMPFE.html,2,['test'],['testArg']
Testability,"l voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooAbsMoment*RooAbsReal::mean(RooRealVar& obs); RooAbsMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooRecursiveFraction&operator=(const RooRecursiveFraction&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooRecursiveFraction.html:18630,test,testArg,18630,root/html602/RooRecursiveFraction.html,https://root.cern,https://root.cern/root/html602/RooRecursiveFraction.html,2,['test'],['testArg']
Testability,"l voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooAbsMoment*RooAbsReal::mean(RooRealVar& obs); RooAbsMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooStats::Heaviside&operator=(const RooStats::Heaviside&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooStats__Heaviside.html:18591,test,testArg,18591,root/html602/RooStats__Heaviside.html,https://root.cern,https://root.cern/root/html602/RooStats__Heaviside.html,2,['test'],['testArg']
Testability,"l voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooAbsMoment*RooAbsReal::mean(RooRealVar& obs); RooAbsMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooStats::HistFactory::FlexibleInterpVar&operator=(const RooStats::HistFactory::FlexibleInterpVar&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooStats__HistFactory__FlexibleInterpVar.html:19409,test,testArg,19409,root/html602/RooStats__HistFactory__FlexibleInterpVar.html,https://root.cern,https://root.cern/root/html602/RooStats__HistFactory__FlexibleInterpVar.html,2,['test'],['testArg']
Testability,"l voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooAbsMoment*RooAbsReal::mean(RooRealVar& obs); RooAbsMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooStats::HistFactory::LinInterpVar&operator=(const RooStats::HistFactory::LinInterpVar&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooStats__HistFactory__LinInterpVar.html:18937,test,testArg,18937,root/html602/RooStats__HistFactory__LinInterpVar.html,https://root.cern,https://root.cern/root/html602/RooStats__HistFactory__LinInterpVar.html,2,['test'],['testArg']
Testability,"l voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooAbsMoment*RooAbsReal::mean(RooRealVar& obs); RooAbsMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooStepFunction&operator=(const RooStepFunction&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooStepFunction.html:18871,test,testArg,18871,root/html602/RooStepFunction.html,https://root.cern,https://root.cern/root/html602/RooStepFunction.html,2,['test'],['testArg']
Testability,"l voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooAbsMoment*RooAbsReal::mean(RooRealVar& obs); RooAbsMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooTFnBinding&operator=(const RooTFnBinding&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooTFnBinding.html:18358,test,testArg,18358,root/html602/RooTFnBinding.html,https://root.cern,https://root.cern/root/html602/RooTFnBinding.html,2,['test'],['testArg']
Testability,"l voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooAbsMoment*RooAbsReal::mean(RooRealVar& obs); RooAbsMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooUnblindCPAsymVar&operator=(const RooUnblindCPAsymVar&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooUnblindCPAsymVar.html:18976,test,testArg,18976,root/html602/RooUnblindCPAsymVar.html,https://root.cern,https://root.cern/root/html602/RooUnblindCPAsymVar.html,2,['test'],['testArg']
Testability,"l voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooAbsMoment*RooAbsReal::mean(RooRealVar& obs); RooAbsMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooUnblindOffset&operator=(const RooUnblindOffset&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueO",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooUnblindOffset.html:18955,test,testArg,18955,root/html602/RooUnblindOffset.html,https://root.cern,https://root.cern/root/html602/RooUnblindOffset.html,2,['test'],['testArg']
Testability,"l voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooAbsMoment*RooAbsReal::mean(RooRealVar& obs); RooAbsMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooUnblindPrecision&operator=(const RooUnblindPrecision&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooUnblindPrecision.html:18973,test,testArg,18973,root/html602/RooUnblindPrecision.html,https://root.cern,https://root.cern/root/html602/RooUnblindPrecision.html,2,['test'],['testArg']
Testability,"l voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooAbsMoment*RooAbsReal::mean(RooRealVar& obs); RooAbsMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooUnblindUniform&operator=(const RooUnblindUniform&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooUnblindUniform.html:18426,test,testArg,18426,root/html602/RooUnblindUniform.html,https://root.cern,https://root.cern/root/html602/RooUnblindUniform.html,2,['test'],['testArg']
Testability,"l voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooAbsMoment*RooAbsReal::mean(RooRealVar& obs); RooAbsMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsTestStatistic::offset() const; virtual Double_tRooAbsTestStatistic::offsetCarry() const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TNamed&TNamed::operator=(const TNamed& rhs); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAbsOptTestStatistic.html:19810,test,testArg,19810,root/html534/RooAbsOptTestStatistic.html,https://root.cern,https://root.cern/root/html534/RooAbsOptTestStatistic.html,5,['test'],['testArg']
Testability,"l voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooAbsMoment*RooAbsReal::mean(RooRealVar& obs); RooAbsMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsTestStatistic::offset() const; virtual Double_tRooAbsTestStatistic::offsetCarry() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooAbsOptTestStatistic&operator=(const RooAbsOptTestStatistic&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const Ro",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooAbsOptTestStatistic.html:19805,test,testArg,19805,root/html602/RooAbsOptTestStatistic.html,https://root.cern,https://root.cern/root/html602/RooAbsOptTestStatistic.html,2,['test'],['testArg']
Testability,"l voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooAbsMoment*RooAbsReal::mean(RooRealVar& obs); RooAbsMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsTestStatistic::offset() const; virtual Double_tRooAbsTestStatistic::offsetCarry() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooChi2Var&operator=(const RooChi2Var&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooChi2Var.html:19386,test,testArg,19386,root/html602/RooChi2Var.html,https://root.cern,https://root.cern/root/html602/RooChi2Var.html,2,['test'],['testArg']
Testability,"l voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooAbsMoment*RooAbsReal::mean(RooRealVar& obs); RooAbsMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsTestStatistic::offset() const; virtual Double_tRooAbsTestStatistic::offsetCarry() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooDataWeightedAverage&operator=(const RooDataWeightedAverage&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const Ro",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooDataWeightedAverage.html:19495,test,testArg,19495,root/html602/RooDataWeightedAverage.html,https://root.cern,https://root.cern/root/html602/RooDataWeightedAverage.html,2,['test'],['testArg']
Testability,"l voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooAbsMoment*RooAbsReal::mean(RooRealVar& obs); RooAbsMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsTestStatistic::offset() const; virtual Double_tRooAbsTestStatistic::offsetCarry() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooNLLVar&operator=(const RooNLLVar&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t v",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooNLLVar.html:19290,test,testArg,19290,root/html602/RooNLLVar.html,https://root.cern,https://root.cern/root/html602/RooNLLVar.html,2,['test'],['testArg']
Testability,"l voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooAbsMoment*RooAbsReal::mean(RooRealVar& obs); RooAbsMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsTestStatistic::offset() const; virtual Double_tRooAbsTestStatistic::offsetCarry() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooXYChi2Var&operator=(const RooXYChi2Var&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooXYChi2Var.html:19423,test,testArg,19423,root/html602/RooXYChi2Var.html,https://root.cern,https://root.cern/root/html602/RooXYChi2Var.html,2,['test'],['testArg']
Testability,"l voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooAbsMoment*RooAbsReal::mean(RooRealVar& obs); RooAbsMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_toffset() const; virtual Double_toffsetCarry() const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TNamed&TNamed::operator=(const TNamed& rhs); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAbsTestStatistic.html:19665,test,testArg,19665,root/html534/RooAbsTestStatistic.html,https://root.cern,https://root.cern/root/html534/RooAbsTestStatistic.html,1,['test'],['testArg']
Testability,"l voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooAbsMoment*RooAbsReal::mean(RooRealVar& obs); RooAbsMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_toffset() const; virtual Double_toffsetCarry() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooAbsTestStatistic&operator=(const RooAbsTestStatistic&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) con",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooAbsTestStatistic.html:19660,test,testArg,19660,root/html602/RooAbsTestStatistic.html,https://root.cern,https://root.cern/root/html602/RooAbsTestStatistic.html,2,['test'],['testArg']
Testability,"l voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; Int_tGetNClasses() const; UInt_tGetNSpectators() const; UInt_tGetNTargets() const; UInt_tGetNVariables() const; voidTObject::MakeZombie(); voidSetCreated(Bool_t c = kTRUE); voidSetName(const TString& c); voidSetNVariables(UInt_t i); vector<TMVA::VariableInfo>&Spectators(); vector<TMVA::VariableInfo>&Targets(); vector<TMVA::VariableInfo>&Variables(). private:. voidUpdateNorm(Int_t ivar, Double_t x). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TMVA::Event*fBackTransformedEventholds the current back-transformed event; TMVA::DataSetInfo&fDsi; TMVA::DataSetInfo*fDsiOutput; TMVA::VariableTransformBase::VectorOfCharAndIntfGetget variables/targets/spectators; TMVA::MsgLogger*fLogger! message logger; TMVA::VariableTransformBase::VectorOfCharAndIntfPutput variables/targets/spectators; TMVA::TMVAVersion_tfTMVAVersion; TMVA::Event*fTransformedEventholds the current transformed event. private:. Bool_tfCreatedhas been created; Bool_tfEnabledhas been enabled; UInt_tfNSpectatorsnumber of spectators to be transformed; UInt_tfNTargetsnumber of targets to be transformed; UInt_tfNVariablesnumber of variables to be transformed; UInt_tfNVarsnumber of variables; Bool_tfNormalisenormalise input variables; Bool_tfSortGetif true, sort the variables into the order as defined by the user at the var definition; vector<TMVA::VariableInfo>fSpectatorsevent spectators [saved to weight file --> TODO ]; vector<TMVA::VariableInfo>fTargetsevent targets [saved to weight file --> TODO ]; TStringfTransformNamename of transformation; Bool_tfUseSignalTransformtrue if transformation bases on signal data; TMVA::Types::EVariableTransformfVariableTransformDecorrelation, PCA, etc.; B",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TMVA__VariableTransformBase.html:7714,log,logger,7714,root/html530/TMVA__VariableTransformBase.html,https://root.cern,https://root.cern/root/html530/TMVA__VariableTransformBase.html,3,['log'],['logger']
Testability,"l voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTObject::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); Int_tRegularizeBins(int start, int step, int nbin, TUnfold::ERegMode regmode); Int_tRegularizeBins2D(int start_bin, int step1, int nbin1, int step2, int nbin2, TUnfold::ERegMode regmode); Int_tRegularizeCurvature(int left_bin, int center_bin, int right_bin, Double_t scale_left = 1.0, Double_t scale_right = 1.0); Int_tRegularizeDerivative(int left_bin, int right_bin, Double_t scale = 1.0); Int_tRegularizeSize(int bin, Double_t scale = 1.0); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual Int_tScanLcurve(Int_t nPoint, Double_t tauMin, Double_t tauMax, TGraph** lCurve, TSpline** logTauX = 0, TSpline** logTauY = 0); voidSetBias(const TH1* bias); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidSetConstraint(TUnfold::EConstraint constraint); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual Int_tSetInput(const TH1* hist_y, Double_t scaleBias = 0.0, Double_t oneOverZeroError = 0.0); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t opt",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TUnfold.html:16303,log,logTauX,16303,root/html530/TUnfold.html,https://root.cern,https://root.cern/root/html530/TUnfold.html,4,['log'],"['logTauX', 'logTauY']"
Testability,"l voidTObject::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); Int_tTUnfold::RegularizeBins(int start, int step, int nbin, TUnfold::ERegMode regmode); Int_tTUnfold::RegularizeBins2D(int start_bin, int step1, int nbin1, int step2, int nbin2, TUnfold::ERegMode regmode); Int_tTUnfold::RegularizeCurvature(int left_bin, int center_bin, int right_bin, Double_t scale_left = 1.0, Double_t scale_right = 1.0); Int_tTUnfold::RegularizeDerivative(int left_bin, int right_bin, Double_t scale = 1.0); Int_tTUnfold::RegularizeSize(int bin, Double_t scale = 1.0); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual Int_tTUnfold::ScanLcurve(Int_t nPoint, Double_t tauMin, Double_t tauMax, TGraph** lCurve, TSpline** logTauX = 0, TSpline** logTauY = 0); voidTUnfold::SetBias(const TH1* bias); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTUnfold::SetConstraint(TUnfold::EConstraint constraint); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTUnfold::SetEpsMatrix(Double_t eps); virtual Int_tSetInput(const TH1* hist_y, Double_t scaleBias = 0.0, Double_t oneOverZeroError = 0.0, const TH2* hist_vyy = 0, const TH2* hist_vyy_inv = 0); static voidTObject::SetObjectStat(Bool_t stat); voidSetTauError(Double_t delta_tau); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector&); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); voidSubtractBackground(const TH1* hist_bgr, const char* name, Double_t scale = 1.0, Double_t scale_error = 0.0); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtua",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TUnfoldSys.html:10259,log,logTauX,10259,root/html534/TUnfoldSys.html,https://root.cern,https://root.cern/root/html534/TUnfoldSys.html,2,['log'],"['logTauX', 'logTauY']"
Testability,"l voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector&); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TMVA::MsgLogger*TMVA::PDEFoamKernelBase::fLogger! message logger. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; PDEFoamKernelTrivial(); Default constructor for streamer. PDEFoamKernelTrivial(const TMVA::PDEFoamKernelTrivial& ); Copy constructor. Float_t Estimate(TMVA::PDEFoam* , vector<Float_t>& , TMVA::ECellValue ); Simple kernel estimator. It returns the cell value 'cv',; corresponding to the event vector 'txvec' (in foam coordinates). Parameters:. - foam - the pdefoam to search in. - txvec - event vector in foam coordinates [0,1]. - cv - cell value to estimate. virtual ~PDEFoamKernelTrivial(); {}.  Author: Dominik Dannheim, Alexander Voigt  Copyright (c) 2010: *;  Last changed: root/tmva $Id$  Last generated: 2015-03-14 16:44; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TMVA__PDEFoamKernelTrivial.html:5604,log,logger,5604,root/html534/TMVA__PDEFoamKernelTrivial.html,https://root.cern,https://root.cern/root/html534/TMVA__PDEFoamKernelTrivial.html,1,['log'],['logger']
Testability,"l which implements the interface should provide two modes for tree pruning:. automatically find the ""best"" prune strength by minimizing the error rate on a test sample if SetAutomatic() is called, or if automatic = kTRUE argument is set in CalculatePruningInfo() In this case, the PruningInfo object returned contains the error rate of the optimally pruned tree, the optimal prune strength, and the sequence of nodes to prune to obtain the optimal pruned tree from the original DecisionTree; a user-provided pruning strength parameter is used to prune the tree, in which case the returned PruningInfo object has QualityIndex = -1, PruneStrength = user prune strength, and PruneSequence is the list of nodes to prune . Definition at line 70 of file IPruneTool.h. Public Types; typedef std::vector< const Event * >EventSample; . Public Member Functions; IPruneTool (); ; virtual~IPruneTool (); ; virtual PruningInfo *CalculatePruningInfo (DecisionTree *dt, const EventSample *testEvents=nullptr, Bool_t isAutomatic=kFALSE)=0; ; Double_tGetPruneStrength () const; ; Bool_tIsAutomatic () const; ; voidSetAutomatic (); ; voidSetPruneStrength (Double_t alpha); . Protected Attributes; Double_tB; ; Double_tfPruneStrength; ! regularization parameter in pruning ; ; Double_tS; . #include <TMVA/IPruneTool.h>. Inheritance diagram for TMVA::IPruneTool:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Member Typedef Documentation. EventSample. typedef std::vector<const Event*> TMVA::IPruneTool::EventSample. Definition at line 74 of file IPruneTool.h. Constructor & Destructor Documentation. IPruneTool(). TMVA::IPruneTool::IPruneTool ; (; ). inline . Definition at line 107 of file IPruneTool.h. ~IPruneTool(). TMVA::IPruneTool::~IPruneTool ; (; ). virtual . Definition at line 58 of file ExpectedErrorPruneTool.cxx. Member Function Documentation. CalculatePruningInfo(). virtual PruningInfo * TMVA::IPruneTool::CalculatePruning",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1IPruneTool.html:1337,test,testEvents,1337,doc/master/classTMVA_1_1IPruneTool.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1IPruneTool.html,1,['test'],['testEvents']
Testability,"l(""zexpo"",""expo[z]"");; 1125 formula.ReplaceAll(""xylandau"",""landau[x,y]"");; 1126 formula.ReplaceAll(""xyexpo"",""expo[x,y]"");; 1127 // at the moment pre-defined functions have no more than 3 dimensions; 1128 const char * defaultVariableNames[] = { ""x"",""y"",""z""};; 1129 ; 1130 for (map<pair<TString, Int_t>, pair<TString, TString>>::iterator it = functions.begin(); it != functions.end();; 1131 ++it) {; 1132 ; 1133 TString funName = it->first.first;; 1134 Int_t funDim = it->first.second;; 1135 Int_t funPos = formula.Index(funName);; 1136 ; 1137 // std::cout << formula << "" ---- "" << funName << "" "" << funPos << std::endl;; 1138 while (funPos != kNPOS && !IsAParameterName(formula, funPos)) {; 1139 ; 1140 // should also check that function is not something else (e.g. exponential - parse the expo); 1141 Int_t lastFunPos = funPos + funName.Length();; 1142 ; 1143 // check that first and last character is not a special character; 1144 Int_t iposBefore = funPos - 1;; 1145 // std::cout << ""looping on funpos is "" << funPos << "" formula is "" << formula << "" function "" << funName <<; 1146 // std::endl;; 1147 if (iposBefore >= 0) {; 1148 assert(iposBefore < formula.Length());; 1149 //if (isalpha(formula[iposBefore])) {; 1150 if (IsFunctionNameChar(formula[iposBefore])) {; 1151 // std::cout << ""previous character for function "" << funName << "" is "" << formula[iposBefore] << ""- skip; 1152 // "" << std::endl;; 1153 funPos = formula.Index(funName, lastFunPos);; 1154 continue;; 1155 }; 1156 }; 1157 ; 1158 Bool_t isNormalized = false;; 1159 if (lastFunPos < formula.Length()) {; 1160 // check if function is normalized by looking at ""n"" character after function name (e.g. gausn); 1161 isNormalized = (formula[lastFunPos] == 'n');; 1162 if (isNormalized); 1163 lastFunPos += 1;; 1164 if (lastFunPos < formula.Length()) {; 1165 char c = formula[lastFunPos];; 1166 // check if also last character is not alphanumeric or is not an operator and not a parenthesis ( or [.; 1167 // Parenthesis [] are used to ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TFormula_8cxx_source.html:42797,assert,assert,42797,doc/master/TFormula_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TFormula_8cxx_source.html,1,['assert'],['assert']
Testability,"l() const; virtual Bool_tRooAbsReal::isIdentical(const RooAbsArg& other, Bool_t assumeSameType = kFALSE); virtual Bool_tRooAbsArg::isLValue() const; virtual Bool_tisOffsetting() const; Bool_tTObject::IsOnHeap() const; Bool_tRooAbsArg::isShapeDirty() const; Bool_tRooAbsArg::isShapeServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isShapeServer(const char* name) const; virtual Bool_tRooAbsArg::IsSortable() const; Bool_tRooAbsArg::isValueDirty() const; Bool_tRooAbsArg::isValueDirtyAndClear() const; Bool_tRooAbsArg::isValueOrShapeDirtyAndClear() const; Bool_tRooAbsArg::isValueServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isValueServer(const char* name) const; Bool_tTObject::IsZombie() const; voidRooAbsArg::leafNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; Bool_tRooAbsArg::localNoDirtyInhibit() const; voidRooAbsReal::logEvalError(const char* message, const char* serverValueString = 0) const; static voidRooAbsReal::logEvalError(const RooAbsReal* originator, const char* origName, const char* message, const char* serverValueString = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooAbsMoment*RooAbsReal::mean(RooRealVar& obs); RooAbsMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* d",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAbsTestStatistic.html:18541,log,logEvalError,18541,root/html534/RooAbsTestStatistic.html,https://root.cern,https://root.cern/root/html534/RooAbsTestStatistic.html,3,['log'],['logEvalError']
Testability,"l(); virtual voidUpdateBoundingBox(); voidUpdateBoundingBoxesOfPhysicals(). protected:. voidPurgeDLRange(UInt_t base, Int_t size) const. private:. TGLLogicalShape&operator=(const TGLLogicalShape&). Data Members; public:. enum ELODAxes { kLODAxesNone; kLODAxesX; kLODAxesY; kLODAxesZ; kLODAxesAll; };. protected:. TGLBoundingBoxfBoundingBox! Shape's bounding box.; UInt_tfDLBase! display-list id base; Bool_tfDLCache! use display list caching; Int_tfDLSize! display-list size for different LODs; UShort_tfDLValid! display-list validity bit-field; TObject*fExternalObj! Also plays the role of ID.; TGLPhysicalShape*fFirstPhysical! first replica; Bool_tfOwnExtObj! External object is a fake; UInt_tfRef! physical instance ref counting; Bool_tfRefStrong! Strong ref (delete on 0 ref); not in scene; TGLScene*fScene! scene where object is stored (can be zero!); static Bool_tfgIgnoreSizeForCameraInterest. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~TGLLogicalShape(); Destroy logical shape. void AddRef(TGLPhysicalShape* phys) const; Add reference to given physical shape. void SubRef(TGLPhysicalShape* phys) const; Remove reference to given physical shape, potentially deleting; *this* object when hitting zero ref-count (if fRefStrong is; true). void DestroyPhysicals(); Destroy all physicals attached to this logical. UInt_t UnrefFirstPhysical(); Unreference first physical in the list, returning its id and; making it fit for destruction somewhere else.; Returns 0 if there are no replicas attached. void UpdateBoundingBoxesOfPhysicals(); Update bounding-boxed of all dependent physicals. Bool_t SetDLCache(Bool_t cached); Modify capture of draws into display list cache kTRUE - capture,; kFALSE direct draw. Return kTRUE is state changed, kFALSE if not. Bool_t ShouldDLCache(const TGLRnrCtx& rnrCtx) const; Returns kTRUE if draws should be display list cached; kFALSE otherwise. Here we check that:; a) fScene is set (Scene manages link to GL-context);",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGLLogicalShape.html:4784,log,logical,4784,root/html534/TGLLogicalShape.html,https://root.cern,https://root.cern/root/html534/TGLLogicalShape.html,1,['log'],['logical']
Testability,"l(Double_t rlam, Double_t *AC, Double_t *HC, Int_t itype)Internal function, called by Vavilov and VavilovSet.Definition TMath.cxx:3155; TMath::ACosDouble_t ACos(Double_t)Returns the principal value of the arc cosine of x, expressed in radians.Definition TMath.h:632; TMath::BesselIDouble_t BesselI(Int_t n, Double_t x)Computes the Integer Order Modified Bessel function I_n(x) for n=0,1,2,... and any real x.Definition TMath.cxx:1590; TMath::KOrdStatElement KOrdStat(Size n, const Element *a, Size k, Size *work=0)Returns k_th order statistic of the array a of size n (k_th smallest element out of n elements).Definition TMath.h:1359; TMath::GausDouble_t Gaus(Double_t x, Double_t mean=0, Double_t sigma=1, Bool_t norm=kFALSE)Calculates a gaussian function with mean and sigma.Definition TMath.cxx:471; TMath::FactorialDouble_t Factorial(Int_t i)Computes factorial(n).Definition TMath.cxx:252; TMath::KolmogorovTestDouble_t KolmogorovTest(Int_t na, const Double_t *a, Int_t nb, const Double_t *b, Option_t *option)Statistical test whether two one-dimensional sets of points are compatible with coming from the same ...Definition TMath.cxx:805; TMath::NintInt_t Nint(T x)Round to nearest integer. Rounds half integers to the nearest even integer.Definition TMath.h:693; TMath::BinomialIDouble_t BinomialI(Double_t p, Int_t n, Int_t k)Suppose an event occurs with probability p per trial Then the probability P of its occurring k or mor...Definition TMath.cxx:2141; TMath::MaxShort_t Max(Short_t a, Short_t b)Returns the largest of a and b.Definition TMathBase.h:250; TMath::VavilovDouble_t Vavilov(Double_t x, Double_t kappa, Double_t beta2)Returns the value of the Vavilov probability density function.Definition TMath.cxx:2778; TMath::BinomialDouble_t Binomial(Int_t n, Int_t k)Calculates the binomial coefficient n over k.Definition TMath.cxx:2111; TMath::NormalizeFloat_t Normalize(Float_t v[3])Normalize a vector v in place.Definition TMath.cxx:518; TMath::ProbDouble_t Prob(Double_t chi2, Int_t n",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMath_8cxx_source.html:120368,test,test,120368,doc/master/TMath_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TMath_8cxx_source.html,1,['test'],['test']
Testability,"l(const RooAbsArg& other, Bool_t assumeSameType = kFALSE); virtual Bool_tRooAbsArg::isLValue() const; virtual Bool_tRooAbsReal::isOffsetting() const; Bool_tTObject::IsOnHeap() const; Bool_tRooAbsArg::isShapeDirty() const; Bool_tRooAbsArg::isShapeServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isShapeServer(const char* name) const; virtual Bool_tRooAbsArg::IsSortable() const; Bool_tRooAbsArg::isValueDirty() const; Bool_tRooAbsArg::isValueDirtyAndClear() const; Bool_tRooAbsArg::isValueOrShapeDirtyAndClear() const; Bool_tRooAbsArg::isValueServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isValueServer(const char* name) const; Bool_tTObject::IsZombie() const; voidRooAbsArg::leafNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; voidLoadDataSet(RooDataSet& data); Bool_tRooAbsArg::localNoDirtyInhibit() const; voidRooAbsReal::logEvalError(const char* message, const char* serverValueString = 0) const; static voidRooAbsReal::logEvalError(const RooAbsReal* originator, const char* origName, const char* message, const char* serverValueString = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tmaxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooAbsMoment*RooAbsReal::mean(RooRealVar& obs); RooAbsMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tRooAbsPdf::mustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; const char*RooAbsPdf::normRange() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::nu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooKeysPdf.html:21964,log,logEvalError,21964,root/html534/RooKeysPdf.html,https://root.cern,https://root.cern/root/html534/RooKeysPdf.html,3,['log'],['logEvalError']
Testability,"l) or right (r) daughter; Float_tfPuritythe node purity; Float_tfRMSresponse RMS of the regression node; Float_tfResponseresponse value in case of regression; TMVA::Node*TMVA::Node::fRightpointers to the two ""daughter"" nodes; Short_tfSelectorindex of variable used in node selection (decision tree); TMVA::DTNodeTrainingInfo*fTrainInfo. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; DecisionTreeNode(); constructor of an essentially ""empty"" node floating in space. DecisionTreeNode(TMVA::Node* p, char pos); constructor of a daughter node as a daughter of 'p'. DecisionTreeNode(const TMVA::DecisionTreeNode& n, TMVA::DecisionTreeNode* parent = __null); copy constructor of a node. It will result in an explicit copy of; the node and recursively all it's daughters. ~DecisionTreeNode(); destructor. Bool_t GoesRight(const TMVA::Event& ) const; test event if it decends the tree at this node to the right. Bool_t GoesLeft(const TMVA::Event& ) const; test event if it decends the tree at this node to the left. void SetPurity( void ); return the S/(S+B) (purity) for the node; REM: even if nodes with purity 0.01 are very PURE background nodes, they still; get a small value of the purity. void Print(ostream& os) const; print the node. void PrintRec(ostream& os) const; recursively print the node and its daughters (--> print the 'tree'). Bool_t ReadDataRecord(istream& is, UInt_t tmva_Version_Code = 262656); Read the data block. void ClearNodeAndAllDaughters(); clear the nodes (their S/N, Nevents etc), just keep the structure of the tree. void ResetValidationData(); temporary stored node values (number of events, etc.) that originate; not from the training but from the validation data (used in pruning). void PrintPrune(ostream& os) const; printout of the node (can be read in with ReadDataRecord). void PrintRecPrune(ostream& os) const; recursive printout of the node and its daughters. void SetCC(Double_t cc). Float_t GetSampleMin(UInt_t ivar) con",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TMVA__DecisionTreeNode.html:7008,test,test,7008,root/html602/TMVA__DecisionTreeNode.html,https://root.cern,https://root.cern/root/html602/TMVA__DecisionTreeNode.html,1,['test'],['test']
Testability,"l) or right (r) daughter; Float_tfPuritythe node purity; Float_tfRMSresponse RMS of the regression node; Float_tfResponseresponse value in case of regression; TMVA::Node*TMVA::Node::fRightpointers to the two ""daughter"" nodes; Short_tfSelectorindex of variable used in node selection (decision tree); TMVA::DTNodeTrainingInfo*fTrainInfo. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; DecisionTreeNode(); constructor of an essentially ""empty"" node floating in space. DecisionTreeNode(TMVA::Node* p, char pos); constructor of a daughter node as a daughter of 'p'. DecisionTreeNode(const TMVA::DecisionTreeNode& n, TMVA::DecisionTreeNode* parent = __null); copy constructor of a node. It will result in an explicit copy of; the node and recursively all it's daughters. ~DecisionTreeNode(); destructor. Bool_t GoesRight(const TMVA::Event& ) const; test event if it decends the tree at this node to the right. Bool_t GoesLeft(const TMVA::Event& ) const; test event if it decends the tree at this node to the left. void SetPurity( void ); return the S/(S+B) (purity) for the node; REM: even if nodes with purity 0.01 are very PURE background nodes, they still; get a small value of the purity. void Print(ostream& os) const; print the node. void PrintRec(ostream& os) const; recursively print the node and its daughters (--> print the 'tree'). Bool_t ReadDataRecord(istream& is, UInt_t tmva_Version_Code = 262657); Read the data block. void ClearNodeAndAllDaughters(); clear the nodes (their S/N, Nevents etc), just keep the structure of the tree. void ResetValidationData(); temporary stored node values (number of events, etc.) that originate; not from the training but from the validation data (used in pruning). void PrintPrune(ostream& os) const; printout of the node (can be read in with ReadDataRecord). void PrintRecPrune(ostream& os) const; recursive printout of the node and its daughters. void SetCC(Double_t cc). Float_t GetSampleMin(UInt_t ivar) con",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TMVA__DecisionTreeNode.html:7016,test,test,7016,root/html604/TMVA__DecisionTreeNode.html,https://root.cern,https://root.cern/root/html604/TMVA__DecisionTreeNode.html,1,['test'],['test']
Testability,"l* originator, const char* origName, const char* message, const char* serverValueString = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooAbsReal*mean(); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TNamed&TNamed::operator=(const TNamed& rhs); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Int_torder() const; Bool_tRooAbsArg::overlaps",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAbsMoment.html:18596,test,testArg,18596,root/html534/RooAbsMoment.html,https://root.cern,https://root.cern/root/html534/RooAbsMoment.html,1,['test'],['testArg']
Testability,"l* originator, const char* origName, const char* message, const char* serverValueString = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooAbsReal*mean(); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooAbsMoment&operator=(const RooAbsMoment&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Int_torder() const; Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, B",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooAbsMoment.html:18591,test,testArg,18591,root/html602/RooAbsMoment.html,https://root.cern,https://root.cern/root/html602/RooAbsMoment.html,2,['test'],['testArg']
Testability,"l*RooAbsReal::createPlotProjection(const RooArgSet& dependentVars, const RooArgSet* projectedVars, RooArgSet*& cloneSet, const char* rangeName = 0, const RooArgSet* condObs = 0) const; virtual RooAbsReal*RooAbsReal::createProfile(const RooArgSet& paramsOfInterest); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); RooAbsReal*RooAbsReal::createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); virtual Double_tRooAbsReal::defaultErrorLevel() const; static RooNumIntConfig*RooAbsReal::defaultIntegratorConfig(); virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; RooDerivative*RooAbsReal::derivative(RooRealVar& obs, Int_t order = 1, Double_t eps = 0.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/PiecewiseInterpolation.html:8626,test,testArg,8626,root/html528/PiecewiseInterpolation.html,https://root.cern,https://root.cern/root/html528/PiecewiseInterpolation.html,646,['test'],['testArg']
Testability,l256.cxx; ParameterSettings.cxx; PdfFuncMathCore.cxx; ProbFuncMathCore.cxx; QuantFuncMathCore.cxx; RandomFunctions.cxx; RichardsonDerivator.cxx; RootFinder.cxx; SparseData.cxx; SpecFuncCephes.cxx; SpecFuncCephes.h; SpecFuncCephesInv.cxx; SpecFuncMathCore.cxx; StdEngine.cxx; TComplex.cxx; TKDTree.cxx; TKDTreeBinning.cxx; TMath.cxx; TRandom.cxx; TRandom1.cxx; TRandom2.cxx; TRandom3.cxx; TRandomGen.cxx; triangle.c; triangle.h; TStatistic.cxx; UnBinData.cxx; test; fit; GaussFunction.h; MinimizerTypes.h; SparseDataComparer.cxx; SparseFit3.cxx; SparseFit4.cxx; testFit.cxx; testFitPerf.cxx; testGraphFit.cxx; testMinim.cxx; testRooFit.cxx; WrapperRooPdf.h; binarySearchTime.cxx; kDTreeTest.cxx; newKDTreeTest.cxx; stdsort.cxx; stressGoFTest.cxx; stressTF1.cxx; stressTMath.cxx; testAnalyticalIntegrals.cxx; testBinarySearch.cxx; testDistSampler.cxx; testIntegration.cxx; testIntegrationMultiDim.cxx; testKahan.cxx; testkdTreeBinning.cxx; testMathRandom.cxx; testRootFinder.cxx; testSampleQuantiles.cxx; testSortOrder.cxx; testSpecFuncBeta.cxx; testSpecFuncBetaI.cxx; testSpecFuncErf.cxx; testSpecFuncGamma.cxx; testSpecFuncSiCi.cxx; testTMath.cxx; testTStatistic.cxx; v7; inc; ROOT; TFit.hxx; mathmore; inc; Math; ChebyshevApprox.h; Derivator.h; DistFuncMathMore.h; GSLFunctionAdapter.h; GSLIntegrator.h; GSLMCIntegrator.h; GSLMinimizer.h; GSLMinimizer1D.h; GSLMultiRootFinder.h; GSLNLSMinimizer.h; GSLQuasiRandom.h; GSLRandom.h; GSLRandomFunctions.h; GSLRndmEngines.h; GSLRootFinder.h; GSLRootFinderDeriv.h; GSLRootHelper.h; GSLSimAnMinimizer.h; GSLSimAnnealing.h; IntegrationTypes.h; InterpolationTypes.h; Interpolator.h; KelvinFunctions.h; LinkDef_Func.h; LinkDef_RootFinding.h; MCIntegrationTypes.h; MCParameters.h; MultiNumGradFunction.h; MultiRootFinder.h; ParamFunction.h; PdfFuncMathMore.h; Polynomial.h; QuantFuncMathMore.h; QuasiRandom.h; RootFinderAlgorithms.h; SpecF,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v610/files.html:45202,test,testMathRandom,45202,doc/v610/files.html,https://root.cern,https://root.cern/doc/v610/files.html,1,['test'],['testMathRandom']
Testability,"l::createPlotProjection(const RooArgSet& dependentVars, const RooArgSet* projectedVars, RooArgSet*& cloneSet, const char* rangeName = 0, const RooArgSet* condObs = 0) const; virtual RooAbsReal*RooAbsReal::createProfile(const RooArgSet& paramsOfInterest); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooCmdArg arg1, const RooCmdArg arg2 = RooCmdArg::none(), const RooCmdArg arg3 = RooCmdArg::none(), const RooCmdArg arg4 = RooCmdArg::none(), const RooCmdArg arg5 = RooCmdArg::none(), const RooCmdArg arg6 = RooCmdArg::none(), const RooCmdArg arg7 = RooCmdArg::none(), const RooCmdArg arg8 = RooCmdArg::none()); RooAbsReal*RooAbsReal::createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); virtual Double_tRooAbsReal::defaultErrorLevel() const; static RooNumIntConfig*RooAbsReal::defaultIntegratorConfig(); virtual Int_tdefaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; voiddeleteSharedProperties(); Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; RooDerivative*RooAbsReal::derivative(RooRealVar& obs, Int_t order = 1, Double_t eps = 0.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooRealVar.html:9658,test,testArg,9658,root/html526/RooRealVar.html,https://root.cern,https://root.cern/root/html526/RooRealVar.html,2,['test'],['testArg']
Testability,"l::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tmustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; const char*normRange() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TNamed&TNamed::operator=(const TNamed& rhs); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*paramOn(RooPlot* frame, const RooAbsData* data, const char* label = """", Int_t sigDigits = 2, Option_t* options = ""NELU"", Double_t xmin = 0.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAbsPdf.html:27206,test,testArg,27206,root/html534/RooAbsPdf.html,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html,1,['test'],['testArg']
Testability,"l::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tRooAbsPdf::mustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); virtual voidnormLeafServerList(RooArgSet& list) const; const char*RooAbsPdf::normRange() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TNamed&TNamed::operator=(const TNamed& rhs); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsPdf::paramOn(RooPlot* frame, const RooAbsData* data, const char* label = """", Int_t sigDigits = 2, Option_t* options = ""NELU"", Double_t xmin = 0.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooResolutionModel.html:23855,test,testArg,23855,root/html530/RooResolutionModel.html,https://root.cern,https://root.cern/root/html530/RooResolutionModel.html,1,['test'],['testArg']
Testability,"l; Interval for the computation of the test error. ; ; Scalar_tfTrainingError; Holds the most recently computed training loss. ; . #include <TMVA/DNN/Minimizers.h>; Member Typedef Documentation. Matrix_t. template<typename Architecture_t > . using TMVA::DNN::TGradientDescent< Architecture_t >::Matrix_t = typename Architecture_t::Matrix_t. Definition at line 59 of file Minimizers.h. Scalar_t. template<typename Architecture_t > . using TMVA::DNN::TGradientDescent< Architecture_t >::Scalar_t = typename Architecture_t::Scalar_t. Definition at line 58 of file Minimizers.h. Constructor & Destructor Documentation. TGradientDescent() [1/2]. template<typename Architecture_t > . TMVA::DNN::TGradientDescent< Architecture_t >::TGradientDescent. Definition at line 175 of file Minimizers.h. TGradientDescent() [2/2]. template<typename Architecture_t > . TMVA::DNN::TGradientDescent< Architecture_t >::TGradientDescent ; (; Scalar_t; learningRate, . size_t; convergenceSteps, . size_t; testInterval. ). Definition at line 185 of file Minimizers.h. Member Function Documentation. GetConvergenceCount(). template<typename Architecture_t > . size_t TMVA::DNN::TGradientDescent< Architecture_t >::GetConvergenceCount ; (; ); const. inline . Definition at line 159 of file Minimizers.h. GetConvergenceSteps(). template<typename Architecture_t > . size_t TMVA::DNN::TGradientDescent< Architecture_t >::GetConvergenceSteps ; (; ); const. inline . Definition at line 160 of file Minimizers.h. GetTestError(). template<typename Architecture_t > . Scalar_t TMVA::DNN::TGradientDescent< Architecture_t >::GetTestError ; (; ); const. inline . Definition at line 162 of file Minimizers.h. GetTestInterval(). template<typename Architecture_t > . size_t TMVA::DNN::TGradientDescent< Architecture_t >::GetTestInterval ; (; ); const. inline . Definition at line 163 of file Minimizers.h. GetTrainingError(). template<typename Architecture_t > . Scalar_t TMVA::DNN::TGradientDescent< Architectur",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1DNN_1_1TGradientDescent.html:5971,test,testInterval,5971,doc/master/classTMVA_1_1DNN_1_1TGradientDescent.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1DNN_1_1TGradientDescent.html,1,['test'],['testInterval']
Testability,"l;; 382 }; 383 else if ( kCoordError == fErrorType ); 384 {; 385 fDataError[i]/= val;; 386 }; 387 else if ( kAsymError == fErrorType ); 388 {; 389 fDataErrorHigh[i]/= val;; 390 fDataErrorLow[i]/= val;; 391 }; 392 else; 393 assert(false);; 394 }; 395 ; 396 if ( kNoError == fErrorType ); 397 {; 398 fErrorType = kValueError;; 399 }; 400 ; 401 return *this;; 402 }; 403 ; 404 ; 405 /**; 406 add one dim data with only coordinate and values; 407 */; 408 void BinData::Add( double x, double y ); 409 {; 410 assert( kNoError == fErrorType );; 411 ; 412 assert( !fData.empty() && fDataPtr );; 413 assert( fDataErrorHigh.empty() && !fDataErrorHighPtr );; 414 assert( fDataErrorLow.empty() && !fDataErrorLowPtr );; 415 assert( fDataError.empty() && !fDataErrorPtr );; 416 assert( fCoordErrors.empty() && fCoordErrorsPtr.empty() );; 417 ; 418 fData[ fNPoints ] = y;; 419 ; 420 FitData::Add( x );; 421 fSumContent += y;; 422 }; 423 ; 424 /**; 425 add one dim data with no error in the coordinate (x); 426 in this case store the inverse of the error in the value (y); 427 */; 428 void BinData::Add( double x, double y, double ey ); 429 {; 430 assert( kValueError == fErrorType );; 431 assert( !fData.empty() && fDataPtr );; 432 assert( fDataErrorHigh.empty() && !fDataErrorHighPtr );; 433 assert( fDataErrorLow.empty() && !fDataErrorLowPtr );; 434 assert( !fDataError.empty() && fDataErrorPtr );; 435 assert( fCoordErrors.empty() && fCoordErrorsPtr.empty() );; 436 ; 437 fData[ fNPoints ] = y;; 438 fDataError[ fNPoints ] = (ey != 0.0) ? 1.0/ey : 0.0;; 439 ; 440 FitData::Add( x );; 441 fSumContent += y;; 442 if (y != 0 || ey != 1.0) fSumError2 += ey*ey;; 443 // set the weight flag checking if error^2 != y; 444 if (!fIsWeighted); 445 if (y != 0 && std::abs( ey*ey/y - 1.0) > 1.E-12) fIsWeighted = true;; 446 }; 447 ; 448 /**; 449 add one dim data with error in the coordinate (x); 450 in this case store the value (y) error and not the inverse; 451 */; 452 void BinData::Add( double x, double y, double ex, do",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/BinData_8cxx_source.html:12440,assert,assert,12440,doc/master/BinData_8cxx_source.html,https://root.cern,https://root.cern/doc/master/BinData_8cxx_source.html,2,['assert'],['assert']
Testability,"lContext &) const override; Compute addition of PDFs in batches. ; ; doubleevaluate () const override; Evaluate this PDF / function / constant. Needs to be overridden by all derived classes. ; ; RooAbsGenContext *genContext (const RooArgSet &vars, const RooDataSet *prototype=nullptr, const RooArgSet *auxProto=nullptr, bool verbose=false) const override; Return specialized context to efficiently generate toy events from RooAddPdfs return RooAbsPdf::genContext(vars,prototype,auxProto,verbose) ; // WVE DEBUG. ; ; AddCacheElem *getProjCache (const RooArgSet *nset, const RooArgSet *iset=nullptr) const; Manager of cache with coefficient projections and transformations. ; ; doublegetValV (const RooArgSet *set=nullptr) const override; Calculate and return the current value. ; ; boolredirectServersHook (const RooAbsCollection &, bool, bool, bool) override; The cache manager. ; ; voidselectNormalization (const RooArgSet *depSet=nullptr, bool force=false) override; Interface function used by test statistics to freeze choice of observables for interpretation of fraction coefficients. ; ; voidselectNormalizationRange (const char *rangeName=nullptr, bool force=false) override; Interface function used by test statistics to freeze choice of range for interpretation of fraction coefficients. ; ; voidupdateCoefficients (AddCacheElem &cache, const RooArgSet *nset, bool syncCoefValues=true) const; Update the coefficient values in the given cache element: calculate new remainder fraction, normalize fractions obtained from extended ML terms to unity, and multiply the various range and dimensional corrections needed in the current use context. ; ; Protected Member Functions inherited from RooAbsPdf; RooAbsPdf (const RooAbsPdf &other, const char *name=nullptr); Copy constructor. ; ; virtual std::unique_ptr< RooAbsReal >createNLLImpl (RooAbsData &data, const RooLinkedList &cmdList); Protected implementation of the NLL creation routine. ; ; virtual std::unique",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classRooAddPdf.html:63667,test,test,63667,doc/v632/classRooAddPdf.html,https://root.cern,https://root.cern/doc/v632/classRooAddPdf.html,2,['test'],['test']
Testability,"lError("" << ""<STATIC>"" << "") evaluation error, "" << std::endl; 3435 << "" origin : "" << origName << std::endl; 3436 << "" message : "" << ee._msg << std::endl; 3437 << "" server values: "" << ee._srvval << std::endl ;; 3438 } else if (evalErrorData().mode == CollectErrors) {; 3439 auto &evalErrorList = evalErrorData().errorList[originator];; 3440 evalErrorList.first = origName ;; 3441 evalErrorList.second.push_back(ee) ;; 3442 }; 3443 ; 3444 ; 3445 inLogEvalError = false ;; 3446}; 3447 ; 3448 ; 3449 ; 3450////////////////////////////////////////////////////////////////////////////////; 3451/// Log evaluation error message. Evaluation errors may be routed through a different; 3452/// protocol than generic RooFit warning message (which go straight through RooMsgService); 3453/// because evaluation errors can occur in very large numbers in the use of likelihood; 3454/// evaluations. In logEvalError mode, controlled by global method enableEvalErrorLogging(); 3455/// messages reported through this function are not printed but all stored in a list,; 3456/// along with server values at the time of reporting. Error messages logged in this; 3457/// way can be printed in a structured way, eliminating duplicates and with the ability; 3458/// to truncate the list by printEvalErrors. This is the standard mode of error logging; 3459/// during MINUIT operations. If enableEvalErrorLogging() is false, all errors; 3460/// reported through this method are passed for immediate printing through RooMsgService.; 3461/// A string with server names and values is constructed automatically for error logging; 3462/// purposes, unless a custom string with similar information is passed as argument.; 3463 ; 3464void RooAbsReal::logEvalError(const char* message, const char* serverValueString) const; 3465{; 3466 if (evalErrorData().mode == Ignore) {; 3467 return ;; 3468 }; 3469 ; 3470 if (evalErrorData().mode == CountErrors) {; 3471 evalErrorData().count++ ;; 3472 return ;; 3473 }; 3474 ; 3475 static bo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RooAbsReal_8cxx_source.html:147956,log,logEvalError,147956,doc/master/RooAbsReal_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html,1,['log'],['logEvalError']
Testability,"lError(const RooAbsReal* originator, const char* origName, const char* message, const char* serverValueString = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooMoment*RooAbsReal::mean(RooRealVar& obs); RooMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooAbsReal&model() const; RooMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); static voidRooPrintable::nameFieldLength(Int_t newLen); virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TNamed&TNamed::operator=(const TNamed& rhs); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const Ro",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooNumConvolution.html:19224,test,testArg,19224,root/html526/RooNumConvolution.html,https://root.cern,https://root.cern/root/html526/RooNumConvolution.html,2,['test'],['testArg']
Testability,"lError(const RooAbsReal* originator, const char* origName, const char* message, const char* serverValueString = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooMoment*RooAbsReal::mean(RooRealVar& obs); RooMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooAbsReal&model() const; RooMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); static voidRooPrintable::nameFieldLength(Int_t newLen); virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TNamed&TNamed::operator=(const TNamed& rhs); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooNumConvolution.html:19591,test,testArg,19591,root/html530/RooNumConvolution.html,https://root.cern,https://root.cern/root/html530/RooNumConvolution.html,2,['test'],['testArg']
Testability,"lFileName (); ; Static Public Member Functions inherited from RooNumRunningInt; static TClass *Class (); ; static const char *Class_Name (); ; static constexpr Version_tClass_Version (); ; static const char *DeclFileName (); ; Static Public Member Functions inherited from RooAbsCachedReal; static TClass *Class (); ; static const char *Class_Name (); ; static constexpr Version_tClass_Version (); ; static const char *DeclFileName (); ; Static Public Member Functions inherited from RooAbsReal; static TClass *Class (); ; static const char *Class_Name (); ; static constexpr Version_tClass_Version (); ; static voidclearEvalErrorLog (); Clear the stack of evaluation error messages. ; ; static const char *DeclFileName (); ; static RooNumIntConfig *defaultIntegratorConfig (); Returns the default numeric integration configuration for all RooAbsReals. ; ; static std::map< constRooAbsArg *, std::pair< std::string, std::list< RooAbsReal::EvalError > > >::iteratorevalErrorIter (); ; static ErrorLoggingModeevalErrorLoggingMode (); Return current evaluation error logging mode. ; ; static boolhideOffset (); ; static voidlogEvalError (const RooAbsReal *originator, const char *origName, const char *message, const char *serverValueString=nullptr); Interface to insert remote error logging messages received by RooRealMPFE into current error logging stream. ; ; static Int_tnumEvalErrorItems (); ; static Int_tnumEvalErrors (); Return the number of logged evaluation errors since the last clearing. ; ; static voidprintEvalErrors (std::ostream &os=std::cout, Int_t maxPerNode=10000000); Print all outstanding logged evaluation error on the given ostream. ; ; static voidsetEvalErrorLoggingMode (ErrorLoggingMode m); Set evaluation error logging mode. ; ; static voidsetHideOffset (bool flag); ; Static Public Member Functions inherited from RooAbsArg; static voidsetDirtyInhibit (bool flag); Control global dirty inhibit mode. ; ; static vo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooNumCdf.html:47414,log,logging,47414,doc/master/classRooNumCdf.html,https://root.cern,https://root.cern/doc/master/classRooNumCdf.html,1,['log'],['logging']
Testability,"lFraction = -1 or call the method SetShortestInterval(); NOTE: The BayesianCaluclator covers only the case with one; single parameter of interest. double GetMode() const; Returns the value of the parameter for the point in; parameter-space that is the most likely.; How do we do if there are points that are equi-probable?; use approximate posterior; t.b.d use real function to find the mode. void ComputeIntervalUsingRooFit(double c1, double c2) const; compute the interval using RooFit. void ComputeIntervalFromCdf(double c1, double c2) const; compute the interval using Cdf integration. void ApproximatePosterior() const; approximate posterior in nbins using a TF1 and; scan the values. void ComputeIntervalFromApproxPosterior(double c1, double c2) const; compute the interval using the approximate posterior function. void ComputeShortestInterval() const; compute the shortest interval. BayesianCalculator(); constructor. void SetData(RooAbsData& data). void SetTestSize(Double_t size); set the size of the test (rate of Type I error) ( Eg. 0.05 for a 95% Confidence Interval). void SetConfidenceLevel(Double_t cl); set the confidence level for the interval (eg. 0.95 for a 95% Confidence Interval). { SetTestSize(1.-cl); }. Double_t Size() const; Get the size of the test (eg. rate of Type I error). { return fSize; }. Double_t ConfidenceLevel() const; Get the Confidence level for the test. { return 1.-fSize; }. void SetLeftSideTailFraction(Double_t leftSideFraction); set the fraction of probability content on the left tail; Central limits use 0.5 (default case); for upper limits it is 0 and 1 for lower limit; For shortest intervals a negative value (i.e. -1) must be given. {fLeftSideFraction = leftSideFraction;}. void SetShortestInterval(); set the Bayesian calculator to compute the shorest interval (default is central interval); to switch off SetLeftSideTailFraction to the rght value. { fLeftSideFraction = -1; }. void SetBrfPrecision(double precision); set the precision of the Root",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooStats__BayesianCalculator.html:10901,test,test,10901,root/html528/RooStats__BayesianCalculator.html,https://root.cern,https://root.cern/root/html528/RooStats__BayesianCalculator.html,1,['test'],['test']
Testability,"lLinN Class Reference. ; ROOT ; . master. Reference Guide ; . . Loading...; Searching...; No Matches. List of all members |; Public Member Functions |; Static Public Member Functions |; Protected Member Functions |; List of all members ; TMVA::PDEFoamKernelLinN Class ReferenceTMVA. ; This PDEFoam kernel estimates a cell value for a given event by weighting with cell values of the nearest neighbor cells. ; Definition at line 39 of file PDEFoamKernelLinN.h. Public Member Functions; PDEFoamKernelLinN (); Default constructor for streamer. ; ; PDEFoamKernelLinN (const PDEFoamKernelLinN &); Copy constructor. ; ; virtual~PDEFoamKernelLinN (); ; virtual Float_tEstimate (PDEFoam *, std::vector< Float_t > &, ECellValue); Linear neighbors kernel estimator. ; ; virtual TClass *IsA () const; ; virtual voidStreamer (TBuffer &); Stream an object of class TObject. ; ; voidStreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b); ; Public Member Functions inherited from TMVA::PDEFoamKernelBase; PDEFoamKernelBase (); message logger ; ; PDEFoamKernelBase (const PDEFoamKernelBase &); Copy constructor. ; ; virtual~PDEFoamKernelBase (); Destructor. ; ; MsgLogger &Log () const; ; voidStreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b); ; Public Member Functions inherited from TObject; TObject (); TObject constructor. ; ; TObject (const TObject &object); TObject copy ctor. ; ; virtual~TObject (); TObject destructor. ; ; voidAbstractMethod (const char *method) const; Use this method to implement an ""abstract"" method that you don't want to leave purely abstract. ; ; virtual voidAppendPad (Option_t *option=""""); Append graphics object to current pad. ; ; virtual voidBrowse (TBrowser *b); Browse object. May be overridden for another default action. ; ; ULong_tCheckedHash (); Check and record whether this class has a consistent Hash/RecursiveRemove setup (*) and then return the regular Hash value for this object. ; ; virtual const char *",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1PDEFoamKernelLinN.html:1071,log,logger,1071,doc/master/classTMVA_1_1PDEFoamKernelLinN.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1PDEFoamKernelLinN.html,1,['log'],['logger']
Testability,"lMaster should contain an identity matrix. This is set by default, and can be reset using SetLocalMasterIdentity() function.; Logical & Physical Objects. There are two cases of object addition:. Add this object as a single independent entity in the world reference frame.; Add a physical placement (copy) of this logical object (described in local reference frame). The second case is very typical in geometry packages, GEANT4, where we have very large number repeated placements of relatively few logical (unique) shapes. Some viewers (OpenGL only at present) are able to take advantage of this by identifying unique logical shapes from the fID logical ID member of TBuffer3D. If repeated addition of the same fID is found, the shape is cached already - and the costly tessellation does not need to be sent again. The viewer can also perform internal GL specific caching with considerable performance gains in these cases.; For this to work correctly the logical object in must be described in TBuffer3D in the local reference frame, complete with the local/master translation. The viewer indicates this through the interface method; PreferLocalFrame(); If this returns kTRUE you can make repeated calls to AddObject(), with TBuffer3D containing the same fID, and different fLocalMaster placements.; For viewers supporting logical/physical objects, the TBuffer3D content refers to the properties of logical object, with the fLocalMaster transform and the fColor and fTransparency attributes, which can be varied for each physical object.; As a minimum requirement all clients must be capable of filling the raw tessellation of the object buffer, in the master reference frame. Conversely viewers must always be capable of displaying the object described by this buffer. Scene Rebuilds; It should be understood that AddObject is not an explicit command to the viewer; it may for various reasons decide to ignore it:; It already has the object internally cached .; The object falls outside some 'intere",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTBuffer3D.html:5914,log,logical,5914,doc/master/classTBuffer3D.html,https://root.cern,https://root.cern/doc/master/classTBuffer3D.html,1,['log'],['logical']
Testability,"lPOI); virtual RooAbsData*GenerateToyData(RooArgSet&) const; virtual Int_tGetNToys(); stringGetSamplingDistName(); virtual RooStats::SamplingDistribution*GetSamplingDistribution(RooArgSet& paramPoint); virtual RooStats::SamplingDistribution*GetSamplingDistributionSingleWorker(RooArgSet& paramPoint); virtual RooStats::TestStatistic*GetTestStatistic() const; virtual voidInitialize(RooAbsArg&, RooArgSet&, RooArgSet&); virtual TClass*IsA() const; RooStats::TestStatSampler&RooStats::TestStatSampler::operator=(const RooStats::TestStatSampler&); virtual voidSetAsimovNuisancePar(Bool_t i = kTRUE); virtual voidSetConfidenceLevel(Double_t cl); virtual voidSetExpectedNuisancePar(Bool_t i = kTRUE); voidSetGenerateBinned(bool binned = true); virtual voidSetGlobalObservables(const RooArgSet& o); voidSetImportanceDensity(RooAbsPdf* p); voidSetImportanceSnapshot(const RooArgSet& s); voidSetMaxToys(Double_t t); virtual voidSetNEventsPerToy(const Int_t nevents); virtual voidSetNToys(const Int_t ntoy); virtual voidSetNuisanceParameters(const RooArgSet& np); virtual voidSetObservables(const RooArgSet& o); virtual voidSetParametersForTestStat(const RooArgSet& nullpoi); virtual voidSetPdf(RooAbsPdf& pdf); virtual voidSetPriorNuisance(RooAbsPdf* pdf); voidSetProofConfig(RooStats::ProofConfig* pc = NULL); voidSetProtoData(const RooDataSet* d); virtual voidSetSamplingDistName(const char* name); virtual voidSetTestSize(Double_t size); virtual voidSetTestStatistic(RooStats::TestStatistic* testStatistic); voidSetToysBothTails(Double_t toys, Double_t low_threshold, Double_t high_threshold); voidSetToysLeftTail(Double_t toys, Double_t threshold); voidSetToysRightTail(Double_t toys, Double_t threshold); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); RooStats::ToyMCSamplerToyMCSampler(); RooStats::ToyMCSamplerToyMCSampler(const RooStats::ToyMCSampler&); RooStats::ToyMCSamplerToyMCSampler(RooStats::TestStatistic& ts, Int_t ntoys).",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooStats__ToyMCSampler.html:2205,test,testStatistic,2205,root/html528/RooStats__ToyMCSampler.html,https://root.cern,https://root.cern/root/html528/RooStats__ToyMCSampler.html,1,['test'],['testStatistic']
Testability,"l_t deactonfail = kFALSE); static Bool_tTQObject::ConnectToClass(TQObject* sender, const char* signal, TClass* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::ConnectToClass(const char* sender_class, const char* signal, TClass* receiver_class, void* receiver, const char* slot); TSlave*TProof::CreateSlave(const char* url, const char* ord, Int_t perf, const char* image, const char* workdir); TSlave*TProof::CreateSubmaster(const char* url, const char* ord, const char* image, const char* msd); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; TList*TProof::GetEnabledPackages() const; static Bool_tTProof::GetFileInCmd(const char* cmd, TString& fn); static Int_tTProof::GetInputData(TList* input, const char* cachedir, TString& emsg); TList*TProof::GetListOfActiveSlaves() const; TVirtualProofPlayer*TProof::GetPlayer() const; TPluginHandler*TProof::GetProgressDialog() const; Int_tTProof::GetSandbox(TString& sb, Bool_t assert = kFALSE, const char* rc = 0); virtual void*TQObject::GetSender(); virtual const char*TQObject::GetSenderClassName() const; voidTProof::HandleLibIncPath(const char* what, Bool_t add, const char* dirs); Int_tTProof::HandleOutputOptions(TString& opt, TString& target, Int_t action); Int_tTProof::Init(const char* masterurl, const char* conffile, const char* confdir, Int_t loglevel, const char* alias = 0); voidTProof::InitMembers(); virtual TVirtualProofPlayer*MakePlayer(const char* player = 0, TSocket* s = 0); voidTObject::MakeZombie(); virtual Int_tTProof::PollForNewWorkers(); voidTProof::PrepareInputDataFile(TString& dataFile); Int_tTProof::RemoveWorkers(TList* wrks); static Int_tTProof::SaveInputData(TQueryResult* qr, const char* cachedir, TString& emsg); virtual voidTProof::SaveWorkerInfo(); Int_tTProof::SendFile(const char* file, Int_t opt = (kBinary|kForward|kCp|kCpBin), const char* rfile = 0, TSlave* sl = 0); static Int_tTProof::SendInputData(TQueryResult* qr, TProof* p, TString&",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TProofSuperMaster.html:21746,assert,assert,21746,root/html534/TProofSuperMaster.html,https://root.cern,https://root.cern/root/html534/TProofSuperMaster.html,1,['assert'],['assert']
Testability,"l_t fCandleScaledCandle plot, shall the box-width be scaled to each other by the integral of a box?Definition TStyle.h:143; TStyle::GetTitleHFloat_t GetTitleH() constDefinition TStyle.h:283; TStyle::GetStatStyleStyle_t GetStatStyle() constDefinition TStyle.h:262; TStyle::SetTitleYvoid SetTitleY(Float_t y=0.985)Definition TStyle.h:414; TStyle::SetHistFillStylevoid SetHistFillStyle(Style_t styl=0)Definition TStyle.h:381; TStyle::fStatFontSizeFloat_t fStatFontSizeFont size in pixels for fonts with precision type 3.Definition TStyle.h:110; TStyle::fCanvasPreferGLBool_t fCanvasPreferGLIf true, rendering in canvas is with GL.Definition TStyle.h:84; TStyle::fLegoInnerRFloat_t fLegoInnerRInner radius for cylindrical legos.Definition TStyle.h:129; TStyle::GetHistLineWidthWidth_t GetHistLineWidth() constDefinition TStyle.h:236; TStyle::EPaperSizeEPaperSizeDefinition TStyle.h:153; TStyle::kA4@ kA4Definition TStyle.h:153; TStyle::kUSLetter@ kUSLetterDefinition TStyle.h:153; TStyle::fOptLogyInt_t fOptLogyTrue if log scale in y.Definition TStyle.h:40; TStyle::fAxisMaxDigitsInt_t fAxisMaxDigitsNumber of digits above which the 10^N notation is used for axis.Definition TStyle.h:149; TStyle::GetFrameLineStyleStyle_t GetFrameLineStyle() constDefinition TStyle.h:228; TStyle::SetIsReadingvoid SetIsReading(Bool_t reading=kTRUE)Sets the fIsReading member to reading (default=kTRUE).Definition TStyle.cxx:1374; TStyle::GetStatWFloat_t GetStatW() constDefinition TStyle.h:266; TStyle::fGridStyleStyle_t fGridStyleGrid line style.Definition TStyle.h:61; TStyle::fHistFillColorColor_t fHistFillColorHistogram fill color.Definition TStyle.h:77; TStyle::GetDateYFloat_t GetDateY() constDefinition TStyle.h:198; TStyle::GetFitFormatconst char * GetFitFormat() constDefinition TStyle.h:199; TStyle::SetScreenFactorvoid SetScreenFactor(Float_t factor=1)Definition TStyle.h:317; TStyle::fCanvasDefHInt_t fCanvasDefHDefault canvas height.Definition TStyle.h:88; TStyle::SetHatchesLineWidthvoid SetHatchesLineWidt",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TStyle_8h_source.html:62092,log,log,62092,doc/master/TStyle_8h_source.html,https://root.cern,https://root.cern/doc/master/TStyle_8h_source.html,1,['log'],['log']
Testability,"l_t logx = false) const; Returns the X value corresponding to the minimum value of the function; on the (xmin, xmax) interval; Method:; First, the grid search is used to bracket the maximum; with the step size = (xmax-xmin)/fNpx. This way, the step size; can be controlled via the SetNpx() function. If the function is; unimodal or if its extrema are far apart, setting the fNpx to; a small value speeds the algorithm up many times.; Then, Brent's method is applied on the bracketed interval; epsilon (default = 1.E-10) controls the relative accuracy (if |x| > 1 ); and absolute (if |x| < 1) and maxiter (default = 100) controls the maximum number; of iteration of the Brent algorithm; If the flag logx is set the grid search is done in log step size; This is done automatically if the log scale is set in the current Pad. NOTE: see also TF1::GetX. Double_t GetX(Double_t y, Double_t xmin = 0, Double_t xmax = 0, Double_t epsilon = 1.0E-10, Int_t maxiter = 100, Bool_t logx = false) const; Returns the X value corresponding to the function value fy for (xmin<x<xmax).; in other words it can find the roots of the function when fy=0 and successive calls; by changing the next call to [xmin+eps,xmax] where xmin is the previous root.; Method:; First, the grid search is used to bracket the maximum; with the step size = (xmax-xmin)/fNpx. This way, the step size; can be controlled via the SetNpx() function. If the function is; unimodal or if its extrema are far apart, setting the fNpx to; a small value speeds the algorithm up many times.; Then, Brent's method is applied on the bracketed interval; epsilon (default = 1.E-10) controls the relative accuracy (if |x| > 1 ); and absolute (if |x| < 1) and maxiter (default = 100) controls the maximum number; of iteration of the Brent algorithm; If the flag logx is set the grid search is done in log step size; This is done automatically if the log scale is set in the current Pad. NOTE: see also TF1::GetMaximumX, TF1::GetMinimumX. Int_t GetNDF() const;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TF1.html:46393,log,logx,46393,root/html602/TF1.html,https://root.cern,https://root.cern/root/html602/TF1.html,2,['log'],['logx']
Testability,"l_t logx = false) const; Returns the X value corresponding to the minimum value of the function; on the (xmin, xmax) interval; Method:; First, the grid search is used to bracket the maximum; with the step size = (xmax-xmin)/fNpx. This way, the step size; can be controlled via the SetNpx() function. If the function is; unimodal or if its extrema are far apart, setting the fNpx to; a small value speeds the algorithm up many times.; Then, Brent's method is applied on the bracketed interval; epsilon (default = 1.E-10) controls the relative accuracy (if |x| > 1 ); and absolute (if |x| < 1) and maxiter (default = 100) controls the maximum number; of iteration of the Brent algorithm; If the flag logx is set the grid search is done in log step size; This is done automatically if the log scale is set in the current Pad. NOTE: see also TF1::GetX. Double_t GetX(Double_t y, Double_t xmin = 0, Double_t xmax = 0, Double_t epsilon = 1.E-10, Int_t maxiter = 100, Bool_t logx = false) const; Returns the X value corresponding to the function value fy for (xmin<x<xmax).; in other words it can find the roots of the function when fy=0 and successive calls; by changing the next call to [xmin+eps,xmax] where xmin is the previous root.; Method:; First, the grid search is used to bracket the maximum; with the step size = (xmax-xmin)/fNpx. This way, the step size; can be controlled via the SetNpx() function. If the function is; unimodal or if its extrema are far apart, setting the fNpx to; a small value speeds the algorithm up many times.; Then, Brent's method is applied on the bracketed interval; epsilon (default = 1.E-10) controls the relative accuracy (if |x| > 1 ); and absolute (if |x| < 1) and maxiter (default = 100) controls the maximum number; of iteration of the Brent algorithm; If the flag logx is set the grid search is done in log step size; This is done automatically if the log scale is set in the current Pad. NOTE: see also TF1::GetMaximumX, TF1::GetMinimumX. Int_t GetNDF() const;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TF1.html:42911,log,logx,42911,root/html528/TF1.html,https://root.cern,https://root.cern/root/html528/TF1.html,4,['log'],['logx']
Testability,"l_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tRooAbsPdf::mustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; const char*RooAbsPdf::normRange() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooCFunction2PdfBinding<double,int,int>&operator=(const RooCFunction2PdfBinding<double,int,int>&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsPdf::paramOn(RooPlot* frame, const RooAbsData* data, const char* label = """", Int_t sigDigits = 2, Option_t* options = ""NELU"", Double_t xmin = 0.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooCFunction2PdfBinding_double_int_int_.html:23722,test,testArg,23722,root/html602/RooCFunction2PdfBinding_double_int_int_.html,https://root.cern,https://root.cern/root/html602/RooCFunction2PdfBinding_double_int_int_.html,2,['test'],['testArg']
Testability,"l_tObjectProxy_CheckExact(PyObject* pyobject); static PyObject*ObjectProxy_FromVoidPtr(void* addr, const char* classname, Bool_t python_owns = kFALSE); TPython&operator=(const TPython&); static voidPrompt(); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); TPython(); TPython(const TPython&). private:. static Bool_tInitialize(). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Bool_t Initialize(); Private initialization method: setup the python interpreter and load the; ROOT module. void LoadMacro(const char* name); Execute the give python script as if it were a macro (effectively an; execfile in __main__), and create Cling equivalents for any newly available; python classes. void ExecScript(const char* name, int argc = 0, const char** argv = 0); Execute a python stand-alone script, with argv CLI arguments. example of use:; const char* argv[] = { ""1"", ""2"", ""3"" };; TPython::ExecScript( ""test.py"", sizeof(argv)/sizeof(argv[0]), argv );. Bool_t Exec(const char* cmd); Execute a python statement (e.g. ""import ROOT""). const TPyReturn Eval(const char* expr); Evaluate a python expression (e.g. ""ROOT.TBrowser()""). Caution: do not hold on to the return value: either store it in a builtin; type (implicit casting will work), or in a pointer to a ROOT object (explicit; casting to a void* is required). Bool_t Bind(TObject* object, const char* label); Bind a ROOT object with, at the python side, the name ""label"". void Prompt(); Enter an interactive python session (exit with ^D). State is preserved; between successive calls. Bool_t ObjectProxy_Check(PyObject* pyobject); Test whether the type of the given pyobject is of ObjectProxy type or any; derived type. Bool_t ObjectProxy_CheckExact(PyObject* pyobject); Test whether the type of the given pyobject is ObjectProxy type. Bool_t MethodProxy_Check(PyObject* pyobject); Test whether the type of the g",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TPython.html:3851,test,test,3851,root/html602/TPython.html,https://root.cern,https://root.cern/root/html602/TPython.html,1,['test'],['test']
Testability,l_tRooAbsArg::_deleteWatch! Delete watch flag ; Bool_t_doOffsetApply interval value offset to control numeric precision?; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Double_t_evalCarry! carry of Kahan sum in evaluatePartition; Int_t_extSet! Number of designated set to calculated extended term; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; RooAbsReal*_funcPointer to original input function; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; RooAbsTestStatistic**_gofArray! Array of sub-contexts representing part of the combined test statistic; RooAbsTestStatistic::GOFOpMode_gofOpModeOperation mode of test statistic instance ; vector<RooFit::MPSplit>_gofSplitMode! GOF MP Split mode specified by component (when Auto is active); static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Bool_t_init! Is object initialized ; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Bool_tRooAbsArg::_isConstant! Cached isConstant status ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; RooRealMPFE**_mpfeArray! Array of parallel execution frond ends; RooFit::MPSplit_mpinterlUse interleaving strategy rather than N-wise split for partioning of dataset for multiprocessor-split; Int_t_nCPUNumber of processors to use in parallel calculation mode; Int_t_nEventsTotal number of events in test statistic calculation; Int_t_nGofNumber of sub-contexts ; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist.,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAbsTestStatistic.html:36727,test,test,36727,root/html534/RooAbsTestStatistic.html,https://root.cern,https://root.cern/root/html534/RooAbsTestStatistic.html,1,['test'],['test']
Testability,"l_tRooAbsArg::isCloneOf(const RooAbsArg& other) const; Bool_tRooAbsArg::isConstant() const; virtual Bool_tRooAbsArg::isDerived() const; virtual Bool_tRooAbsPdf::isDirectGenSafe(const RooAbsArg& arg) const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; virtual Bool_tRooAbsArg::isFundamental() const; virtual Bool_tRooAbsArg::isLValue() const; Bool_tTObject::IsOnHeap() const; Bool_tRooAbsArg::isShapeDirty() const; Bool_tRooAbsArg::isShapeServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isShapeServer(const char* name) const; virtual Bool_tRooAbsArg::IsSortable() const; Bool_tRooAbsArg::isValueDirty() const; Bool_tRooAbsArg::isValueServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isValueServer(const char* name) const; Bool_tTObject::IsZombie() const; voidRooAbsArg::leafNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; voidLoadDataSet(RooDataSet& data); voidRooAbsReal::logEvalError(const char* message, const char* serverValueString = 0) const; static voidRooAbsReal::logEvalError(const RooAbsReal* originator, const char* origName, const char* message, const char* serverValueString = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooMoment*RooAbsReal::mean(RooRealVar& obs); RooMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); Int_tRooAbsPdf::minDimNormValueCaching() const; virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tRooAbsPdf::mustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); const char*RooAbsPdf::normRange() const; virtual Bool_tTObject::Notify(); ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooKeysPdf.html:20251,log,logEvalError,20251,root/html528/RooKeysPdf.html,https://root.cern,https://root.cern/root/html528/RooKeysPdf.html,2,['log'],['logEvalError']
Testability,"l_tRooAbsArg::isCloneOf(const RooAbsArg& other) const; Bool_tRooAbsArg::isConstant() const; virtual Bool_tRooAbsArg::isDerived() const; virtual Bool_tRooAbsPdf::isDirectGenSafe(const RooAbsArg& arg) const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; virtual Bool_tRooAbsArg::isFundamental() const; virtual Bool_tRooAbsArg::isLValue() const; Bool_tTObject::IsOnHeap() const; Bool_tRooAbsArg::isShapeDirty() const; Bool_tRooAbsArg::isShapeServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isShapeServer(const char* name) const; virtual Bool_tRooAbsArg::IsSortable() const; Bool_tRooAbsArg::isValueDirty() const; Bool_tRooAbsArg::isValueServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isValueServer(const char* name) const; Bool_tTObject::IsZombie() const; voidRooAbsArg::leafNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; voidLoadDataSet(RooDataSet& data); voidRooAbsReal::logEvalError(const char* message, const char* serverValueString = 0) const; static voidRooAbsReal::logEvalError(const RooAbsReal* originator, const char* origName, const char* message, const char* serverValueString = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooMoment*RooAbsReal::mean(RooRealVar& obs); RooMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); Int_tRooAbsPdf::minDimNormValueCaching() const; virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tRooAbsPdf::mustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooKeysPdf.html:19936,log,logEvalError,19936,root/html526/RooKeysPdf.html,https://root.cern,https://root.cern/root/html526/RooKeysPdf.html,1,['log'],['logEvalError']
Testability,"l_tRooAbsArg::isConstant() const; virtual Bool_tRooAbsArg::isDerived() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; virtual Bool_tRooAbsArg::isFundamental() const; virtual Bool_tRooAbsArg::isLValue() const; Bool_tTObject::IsOnHeap() const; Bool_tRooAbsArg::isShapeDirty() const; Bool_tRooAbsArg::isShapeServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isShapeServer(const char* name) const; virtual Bool_tRooAbsArg::IsSortable() const; Bool_tRooAbsArg::isValueDirty() const; Bool_tRooAbsArg::isValueServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isValueServer(const char* name) const; Bool_tTObject::IsZombie() const; voidRooAbsArg::leafNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; const RooArgList&list1() const; const RooArgList&list2() const; voidRooAbsReal::logEvalError(const char* message, const char* serverValueString = 0) const; static voidRooAbsReal::logEvalError(const RooAbsReal* originator, const char* origName, const char* message, const char* serverValueString = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooMoment*RooAbsReal::mean(RooRealVar& obs); RooMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); static voidRooPrintable::nameFieldLength(Int_t newLen); virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAddition.html:16320,log,logEvalError,16320,root/html526/RooAddition.html,https://root.cern,https://root.cern/root/html526/RooAddition.html,1,['log'],['logEvalError']
Testability,"l_tRooAbsArg::isValueServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isValueServer(const char* name) const; Bool_tTObject::IsZombie() const; voidRooAbsArg::leafNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; const RooCatType*RooAbsCategory::lookupType(Int_t index, Bool_t printError = kFALSE) const; const RooCatType*RooAbsCategory::lookupType(const char* label, Bool_t printError = kFALSE) const; const RooCatType*RooAbsCategory::lookupType(const RooCatType& type, Bool_t printError = kFALSE) const; virtual voidTNamed::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; static voidRooPrintable::nameFieldLength(Int_t newLen); virtual Bool_tTObject::Notify(); virtual Int_tRooAbsCategoryLValue::numBins(const char* rangeName) const; Int_tRooAbsArg::numCaches() const; Int_tRooAbsCategory::numTypes(const char* = 0) const; Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); Bool_tRooAbsCategory::operator!=(Int_t index); Bool_tRooAbsCategory::operator!=(const char* label); Bool_tRooAbsCategory::operator!=(const RooAbsArg& other); RooAbsArg&RooAbsCategoryLValue::operator=(int index); RooAbsArg&RooAbsCategoryLValue::operator=(const char* label); RooAbsArg&RooAbsCategoryLValue::operator=(const RooAbsCategory& other); Bool_tRooAbsCategory::operator==(Int_t index) const; Bool_tRooAbsCategory::operator==(const char* label) const; virtual Bool_tRooAbsCategory::operator=",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooCategory.html:9947,test,testArg,9947,root/html526/RooCategory.html,https://root.cern,https://root.cern/root/html526/RooCategory.html,2,['test'],['testArg']
Testability,"l_tRooAbsArg::isValueServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isValueServer(const char* name) const; Bool_tTObject::IsZombie() const; voidRooAbsArg::leafNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; const RooCatType*RooAbsCategory::lookupType(Int_t index, Bool_t printError = kFALSE) const; const RooCatType*RooAbsCategory::lookupType(const char* label, Bool_t printError = kFALSE) const; const RooCatType*RooAbsCategory::lookupType(const RooCatType& type, Bool_t printError = kFALSE) const; virtual voidTNamed::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; static voidRooPrintable::nameFieldLength(Int_t newLen); virtual Bool_tTObject::Notify(); virtual Int_tRooAbsCategoryLValue::numBins(const char* rangeName) const; Int_tRooAbsArg::numCaches() const; Int_tRooAbsCategory::numTypes(const char* = 0) const; Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); Bool_tRooAbsCategory::operator!=(Int_t index); Bool_tRooAbsCategory::operator!=(const char* label); Bool_tRooAbsCategory::operator!=(const RooAbsArg& other); RooAbsArg&RooAbsCategoryLValue::operator=(int index); RooAbsArg&RooAbsCategoryLValue::operator=(const char* label); RooAbsArg&RooAbsCategoryLValue::operator=(const RooAbsCategory& other); Bool_tRooAbsCategory::operator==(Int_t index) const",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooCategory.html:10115,test,testArg,10115,root/html530/RooCategory.html,https://root.cern,https://root.cern/root/html530/RooCategory.html,2,['test'],['testArg']
Testability,"l_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TProofProgressMemoryPlot(TProofProgressDialog* d, Int_t w = 700, Int_t h = 300); Main constructor. ~TProofProgressMemoryPlot(); Destructor. TGListBox* BuildLogList(TGFrame* parent); Build the list of workers. For this, extract the logs and take the names; of TProofLogElements. void Clear(Option_t* = 0); Clear the canvases. void DoPlot(); Draw the plot from the logs. TGraph * DoAveragePlot(Int_t& max_el, Int_t& min_el); Create the average plots. Int_t ParseLine(TString l, Long64_t& v, Long64_t& r, Long64_t& e); Extract from line 'l' the virtual memory 'v', the resident memory 'r' and the; number of events 'e'.; The line is assumed to be in the form; ""... Memory 130868 virtual 31540 ... event 5550""; The fields are only filled if >= 0 .; Return 0 on success, -1 if any of the values coudl not be filled (the output; fields are not touched in such a case). TGraph * DoWorkerPlot(TProofLogElem* ple); Make a memory consumption graph for a worker. TGraph * DoMasterPlot(TProofLogElem* ple); a master or submaster log; display without meaningful labels for now. void Select(Int_t id); actions of select all/clear all button. TGraph* DoAveragePlotOld(Int_t& max_el, Int_t& min_el).  Author: Anna Kreshuk 18/07/2008  Copyright (C) 1995-2003",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TProofProgressMemoryPlot.html:22768,log,logs,22768,root/html528/TProofProgressMemoryPlot.html,https://root.cern,https://root.cern/root/html528/TProofProgressMemoryPlot.html,4,['log'],['logs']
Testability,"l_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tok() const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TNamed&TNamed::operator=(const TNamed& rhs); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg(), const RooCmdArg& arg9 = RooCmdArg(), const RooCmdArg& arg10 = RooCmdArg()) const; virtual list<Double_t>*RooAbsReal::plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; virtual RooPlot*RooAbsReal::plotSliceOn(RooPlot* frame, const RooArgSet& sliceSet, Option_t* drawOptions = ""L"", Double_t scaleFactor = 1.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooFormulaVar.html:18789,test,testArg,18789,root/html526/RooFormulaVar.html,https://root.cern,https://root.cern/root/html526/RooFormulaVar.html,2,['test'],['testArg']
Testability,"l_tWriteLx(); Bool_tWriteProgram(); Bool_tWriteRealParms(); Bool_tWriteRealVarImp(); Bool_tWriteRfOut(); Bool_tWriteRfStatus(); Bool_tWriteRuleFitMod(); Bool_tWriteRuleFitSum(); Bool_tWriteTest(); Bool_tWriteTrain(); Bool_tWriteVarImp(); Bool_tWriteVarNames(); Bool_tWriteYhat(). private:. TMVA::RuleFitAPIRuleFitAPI(). Data Members; protected:. static TMVA::RuleFitAPI::EModelkRfBoth; static TMVA::RuleFitAPI::ERFModekRfClass; static TMVA::RuleFitAPI::EModelkRfLinear; static TMVA::RuleFitAPI::ERFProgramkRfPredict; static TMVA::RuleFitAPI::ERFModekRfRegress; static TMVA::RuleFitAPI::EModelkRfRules; static TMVA::RuleFitAPI::ERFProgramkRfTrain; static TMVA::RuleFitAPI::ERFProgramkRfVarimp. private:. TMVA::MsgLoggerfLoggermessage logger; const TMVA::MethodRuleFit*fMethodRuleFitparent method - set in constructor; TStringfModelTypemodel type string; TMVA::RuleFitAPI::IntParmsfRFIntParmsinteger parameters; vector<int>fRFLxvariable selector; TMVA::RuleFitAPI::ERFProgramfRFProgramwhat to run; TMVA::RuleFitAPI::RealParmsfRFRealParmsreal parameters; vector<Float_t>fRFVarImpvariable importances; vector<Int_t>fRFVarImpIndvariable index; TStringfRFWorkDirworking directory; vector<Float_t>fRFYhatscore results from test sample; TMVA::RuleFit*fRuleFitnon const ptr to RuleFit class in MethodRuleFit. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RuleFitAPI(const TMVA::MethodRuleFit* rfbase, TMVA::RuleFit* rulefit, TMVA::EMsgType minType); standard constructor. ~RuleFitAPI(); destructor. void WelcomeMessage(); welcome message. void HowtoSetupRF(); howto message. void InitRuleFit(); default initialisation; SetRFWorkDir(""./rulefit"");. void ImportSetup(); import setup from MethodRuleFit. void SetRFWorkDir(const char* wdir); set the directory containing rf_go.exe. void CheckRFWorkDir(); check if the rulefit work dir is properly setup.; it aborts (kFATAL) if not. Check existance of directory. void SetTrainParms(); set the training parameters. void Se",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TMVA__RuleFitAPI.html:2660,log,logger,2660,root/html602/TMVA__RuleFitAPI.html,https://root.cern,https://root.cern/root/html602/TMVA__RuleFitAPI.html,4,"['log', 'test']","['logger', 'test']"
Testability,"lace distribution; at point x, with location parameter alpha and shape parameter beta.; By default, alpha=0, beta=1; This distribution is known under different names, most common is; double exponential distribution, but it also appears as; the two-tailed exponential or the bilateral exponential distribution. Double_t LaplaceDistI(Double_t x, Double_t alpha = 0, Double_t beta = 1); Computes the distribution function of Laplace distribution; at point x, with location parameter alpha and shape parameter beta.; By default, alpha=0, beta=1; This distribution is known under different names, most common is; double exponential distribution, but it also appears as; the two-tailed exponential or the bilateral exponential distribution. Double_t LogNormal(Double_t x, Double_t sigma, Double_t theta = 0, Double_t m = 1); Computes the density of LogNormal distribution at point x.; Variable X has lognormal distribution if Y=Ln(X) has normal distribution; sigma is the shape parameter; theta is the location parameter; m is the scale parameter; The formula was taken from ""Engineering Statistics Handbook"" on site; http://www.itl.nist.gov/div898/handbook/eda/section3/eda3669.htm; Implementation using ROOT::Math::lognormal_pdf. /*; ; */. Double_t NormQuantile(Double_t p); Computes quantiles for standard normal distribution N(0, 1); at probability p; ALGORITHM AS241 APPL. STATIST. (1988) VOL. 37, NO. 3, 477-484. Bool_t Permute(Int_t n, Int_t* a); Simple recursive algorithm to find the permutations of; n natural numbers, not necessarily all distinct; adapted from CERNLIB routine PERMU.; The input array has to be initialised with a non descending; sequence. The method returns kFALSE when; all combinations are exhausted. Double_t Student(Double_t T, Double_t ndf); Computes density function for Student's t- distribution; (the probability function (integral of density) is computed in StudentI). First parameter stands for x - the actual variable of the; density function p(x) and the point at wh",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMath.html:32958,log,lognormal,32958,root/html528/TMath.html,https://root.cern,https://root.cern/root/html528/TMath.html,6,['log'],['lognormal']
Testability,"laceAll(""*"","""");; 2278 leaflist.ReplaceAll(""*"","""");; 2279 // Add the branch to the tree and indicate that the address; 2280 // is that of a pointer to be dereferenced before using.; 2281 branch1 = new TBranch(branch, bname, *((void**) pointer), leaflist, bufsize);; 2282 TLeaf* leaf = (TLeaf*) branch1->GetListOfLeaves()->At(0);; 2283 leaf->SetBit(TLeaf::kIndirectAddress);; 2284 leaf->SetAddress((void**) pointer);; 2285 blist->Add(branch1);; 2286 }; 2287 } else if (dm->IsBasic()) {; 2288 // We have a basic type.; 2289 ; 2290 char vcode = DataTypeToChar((EDataType)code);; 2291 if (vcode) {; 2292 leaflist.Form(""%s/%c"", rdname, vcode);; 2293 } else {; 2294 Error(""BranchOld"", ""Cannot create branch for rdname: %s code: %d"", branchname.Data(), code);; 2295 leaflist = """";; 2296 }; 2297 branch1 = new TBranch(branch, branchname, pointer, leaflist, bufsize);; 2298 branch1->SetTitle(rdname);; 2299 blist->Add(branch1);; 2300 } else {; 2301 // We have a class type.; 2302 // Note: This cannot happen due to the rd->IsObject() test above.; 2303 // FIXME: Put an error message here just in case.; 2304 }; 2305 if (branch1) {; 2306 branch1->SetOffset(offset);; 2307 } else {; 2308 Warning(""BranchOld"", ""Cannot process member: '%s'"", rdname);; 2309 }; 2310 }; 2311 if (delobj) {; 2312 delete obj;; 2313 obj = nullptr;; 2314 }; 2315 return branch;; 2316}; 2317 ; 2318////////////////////////////////////////////////////////////////////////////////; 2319/// Build the optional branch supporting the TRefTable.; 2320/// This branch will keep all the information to find the branches; 2321/// containing referenced objects.; 2322///; 2323/// At each Tree::Fill, the branch numbers containing the; 2324/// referenced objects are saved to the TBranchRef basket.; 2325/// When the Tree header is saved (via TTree::Write), the branch; 2326/// is saved keeping the information with the pointers to the branches; 2327/// having referenced objects.; 2328 ; 2329TBranch* TTree::BranchRef(); 2330{; 2331 if (!fBranchRe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTree_8cxx_source.html:91185,test,test,91185,doc/master/TTree_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html,1,['test'],['test']
Testability,"lag = 1); boolSetLogStream(); voidSetRandom(TRandom* r); voidSetSeed(unsigned int seed); TUnuran(TRandom* r = 0, unsigned int log = 0). protected:. boolSetContDistribution(const TUnuranContDist& dist); boolSetDiscreteDistribution(const TUnuranDiscrDist& dist); boolSetEmpiricalDistribution(const TUnuranEmpDist& dist); boolSetMethodAndInit(); boolSetMultiDistribution(const TUnuranMultiContDist& dist); boolSetRandomGenerator(). private:. TUnuran&operator=(const TUnuran& rhs); TUnuran(const TUnuran&). Data Members; protected:. auto_ptr<TUnuranBaseDist>fDistpointer for distribution wrapper; UNUR_GEN*fGenpointer to the UnuRan C generator struct; stringfMethodstring representing the method; TRandom*fRngpointer to ROOT random number generator; UNUR_DISTR*fUdistrpointer to the UnuRan C distribution struct; UNUR_URNG*fUrngpointer to Unuran C random generator struct. Class Charts. Inheritance Chart:. TUnuran. Function documentation; TUnuran(TRandom* r = 0, unsigned int log = 0); constructor implementation with a ROOT random generator; if no generator is given the ROOT default is used. ~TUnuran(); Destructor implementation. TUnuran(const TUnuran& ); Implementation of copy constructor. bool Init(const std::string & dist, const std::string & method); initialize with a string. bool Init(const TUnuranContDist& distr, const string& method = ""auto""); initialization with a distribution and and generator; the distribution object is copied in and managed by this class; use auto_ptr to manage previously existing distribution objects. bool Init(const TUnuranMultiContDist& distr, const string& method = ""hitro""); initialization with a distribution and method; the distribution object is copied in and managed by this class; use auto_ptr to manage previously existing distribution objects. bool Init(const TUnuranDiscrDist& distr, const string& method = ""auto""); initialization with a distribution and and generator; the distribution object is copied in and managed by this class; use auto_ptr to ma",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TUnuran.html:2000,log,log,2000,root/html602/TUnuran.html,https://root.cern,https://root.cern/root/html602/TUnuran.html,1,['log'],['log']
Testability,lag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; RooAbsReal*RooAbsTestStatistic::_funcPointer to original input function; RooAbsReal*_funcClonePointer to internal clone of input function; RooArgSet*_funcCloneSetSet owning all components of internal clone of input function; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; static Int_tRooPrintable::_nameLength; RooArgSet*_normSetPointer to set with observables used for normalization; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; Bool_t_ownDataDo we own the dataset; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; RooArgSet_ownedDataObs! Dataset observables we've agreed to own; RooSetProxyRooAbsTestStatistic::_paramSetParameters of the test statistic (=parameters of the input function); Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooArgSet*_projDepsSet of projected observable; const RooArgSet*RooAbsTestStatistic::_projDepsPointer to set with projected observables; TListRooAbsArg::_proxyListlist of proxies; stringRooAbsTestStatistic::_rangeNameName of range in which to calculate test statistic; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; TString_sealNoticeUser-defined notice shown when reading a sealed likelihood ; Bool_t_sealedIs test statistic sealed -- i.,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooAbsOptTestStatistic.html:34344,test,test,34344,root/html530/RooAbsOptTestStatistic.html,https://root.cern,https://root.cern/root/html530/RooAbsOptTestStatistic.html,3,['test'],['test']
Testability,"lag); { fgAlwaysUseMultiGen = flag ; }. void SetUseMultiGen(Bool_t flag); { fUseMultiGen = flag ; }. RooAbsData* GenerateToyData(RooArgSet& paramPoint) const; generates toy data; without weight. SamplingDistribution* AppendSamplingDistribution(RooArgSet& allParameters, RooStats::SamplingDistribution* last, Int_t additionalMC); Extended interface to append to sampling distribution more samples. Double_t EvaluateTestStatistic(RooAbsData& data, RooArgSet& nullPOI); Main interface to evaluate the test statistic on a dataset. TestStatistic* GetTestStatistic() const; { return fTestStat; }. Double_t ConfidenceLevel() const; { return 1. - fSize; }. void Initialize(RooAbsArg& , RooArgSet& , RooArgSet& ); { return fNToys; }. void SetNToys(const Int_t ntoy); { fNToys = ntoy; }. void SetNEventsPerToy(const Int_t nevents); Forces n events even for extended PDFs. Set NEvents=0 to; use the Poisson distributed events from the extended PDF. void SetParametersForTestStat(const RooArgSet& nullpoi); specify the values of parameters used when evaluating test statistic. void SetPdf(RooAbsPdf& pdf); Set the Pdf, add to the the workspace if not already there. { fPdf = &pdf; ClearCache(); }. void SetPriorNuisance(RooAbsPdf* pdf); How to randomize the prior. Set to NULL to deactivate randomization. { fPriorNuisance = pdf; }. void SetNuisanceParameters(const RooArgSet& np); specify the nuisance parameters (eg. the rest of the parameters). { fNuisancePars = &np; }. void SetObservables(const RooArgSet& o); specify the observables in the dataset (needed to evaluate the test statistic). { fObservables = &o; }. void SetGlobalObservables(const RooArgSet& o); specify the conditional observables. { fGlobalObservables = &o; }. void SetTestSize(Double_t size); set the size of the test (rate of Type I error) ( Eg. 0.05 for a 95% Confidence Interval). { fSize = size; }. void SetConfidenceLevel(Double_t cl); set the confidence level for the interval (eg. 0.95 for a 95% Confidence Interval). { fSize = 1. - ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooStats__ToyMCSampler.html:8005,test,test,8005,root/html532/RooStats__ToyMCSampler.html,https://root.cern,https://root.cern/root/html532/RooStats__ToyMCSampler.html,1,['test'],['test']
Testability,"lag); { fgAlwaysUseMultiGen = flag ; }. void SetUseMultiGen(Bool_t flag); { fUseMultiGen = flag ; }. RooAbsData* GenerateToyData(RooArgSet& paramPoint) const; generates toy data; without weight. SamplingDistribution* AppendSamplingDistribution(RooArgSet& allParameters, RooStats::SamplingDistribution* last, Int_t additionalMC); Extended interface to append to sampling distribution more samples. Double_t EvaluateTestStatistic(RooAbsData& data, RooArgSet& nullPOI); Main interface to evaluate the test statistic on a dataset. TestStatistic* GetTestStatistic() const; { return fTestStat; }. Double_t ConfidenceLevel() const; { return 1. - fSize; }. void Initialize(RooAbsArg& , RooArgSet& , RooArgSet& ); { return fNToys; }. void SetNToys(const Int_t ntoy); { fNToys = ntoy; }. void SetNEventsPerToy(const Int_t nevents); Forces n events even for extended PDFs. Set NEvents=0 to; use the Poisson distributed events from the extended PDF. void SetParametersForTestStat(const RooArgSet& nullpoi); specify the values of parameters used when evaluating test statistic. void SetPdf(RooAbsPdf& pdf); Set the Pdf, add to the the workspace if not already there. { fPdf = &pdf; }. void SetPriorNuisance(RooAbsPdf* pdf); How to randomize the prior. Set to NULL to deactivate randomization. { fPriorNuisance = pdf; }. void SetNuisanceParameters(const RooArgSet& np); specify the nuisance parameters (eg. the rest of the parameters). { fNuisancePars = &np; }. void SetObservables(const RooArgSet& o); specify the observables in the dataset (needed to evaluate the test statistic). { fObservables = &o; }. void SetGlobalObservables(const RooArgSet& o); specify the conditional observables. { fGlobalObservables = &o; }. void SetTestSize(Double_t size); set the size of the test (rate of Type I error) ( Eg. 0.05 for a 95% Confidence Interval). { fSize = size; }. void SetConfidenceLevel(Double_t cl); set the confidence level for the interval (eg. 0.95 for a 95% Confidence Interval). { fSize = 1. - cl; }. void Se",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooStats__ToyMCSampler.html:7647,test,test,7647,root/html530/RooStats__ToyMCSampler.html,https://root.cern,https://root.cern/root/html530/RooStats__ToyMCSampler.html,1,['test'],['test']
Testability,"lag. ; ; static voidSetObjectStat (Bool_t stat); Turn on/off tracking of objects in the TObjectTable. ; ; Static Public Member Functions inherited from RooPrintable; static TClass *Class (); ; static const char *Class_Name (); ; static constexpr Version_tClass_Version (); ; static const char *DeclFileName (); ; static std::ostream &defaultPrintStream (std::ostream *os=nullptr); Return a reference to the current default stream to use in Print(). ; ; static voidnameFieldLength (Int_t newLen); Set length of field reserved from printing name of RooAbsArgs in multi-line collection printing to given amount. ; ; Public Attributes inherited from RooAbsArg; R__DEPRECATED(6, 36, ""Use getObservables()."") RooFit R__DEPRECATED(6, 36, ""Use getObservables()."") RooFit R__DEPRECATED(6, 36, ""Use getObservables()."") RooFit const RooAbsArg &testArgconst { return observableOverlaps(dset,testArg); ; const RooAbsArg &testArgconst { return observableOverlaps(depList, testArg); ; Static Protected Member Functions inherited from RooAbsReal; static voidglobalSelectComp (bool flag); Global switch controlling the activation of the selectComp() functionality. ; ; Static Protected Member Functions inherited from RooAbsArg; static voidioStreamerPass2Finalize (); Method called by workspace container to finalize schema evolution issues that cannot be handled in a single ioStreamer pass. ; ; Static Protected Attributes inherited from RooAbsReal; static bool_globalSelectComp = false; ; static bool_hideOffset = true; Offset hiding flag. ; ; Static Protected Attributes inherited from RooAbsArg; static bool_inhibitDirty; ; static bool_verboseDirty; cache of the list of proxies. Avoids type casting. ; ; Static Protected Attributes inherited from RooPrintable; static Int_t_nameLength; . #include </home/sftnight/build/workspace/root-makedoc-master/rootspi/rdoc/src/master/roofit/roofitcore/src/RooRealMPFE.h>. Inheritance diagram for RooRealMPFE:. This browser is",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooRealMPFE.html:62049,test,testArg,62049,doc/master/classRooRealMPFE.html,https://root.cern,https://root.cern/doc/master/classRooRealMPFE.html,4,['test'],['testArg']
Testability,"lag.; A typical example from TGeoBBox::FillBuffer3D:; if (reqSections & TBuffer3D::kBoundingBox) {; Double_t halfLengths[3] = { fDX, fDY, fDZ };; buffer.SetAABoundingBox(fOrigin, halfLengths);; if (!buffer.fLocalFrame) {; TransformPoints(buffer.fBBVertex[0], 8);; }; buffer.SetSectionsValid(TBuffer3D::kBoundingBox);; }; 9.13.4.7 Logical and Physical Objects; Some viewers can support two types of object placement:. Add object as a single independent entity in the world reference frame - e.g.a sphere, radius r, at x, y, z.; Repeated placement (copying) in world frame of this locally unique piece of geometry (described in local reference frame) e.g.define a sphere S (radius r), place copy at x1, y1, z1, another copy at x2, y2, z2 etc. The second case is very typical in geometry packages, e.g.ROOTs TGeo package, GEANT4 etc, where we have very large number repeated placements of relatively few unique shapes.; Some viewers (GL Viewer only at present) are able to take advantage of this by identifying unique logical shapes from the fID logical ID member of TBuffer3D. If repeated addition of the same fID is found, the shape is cached already - and the costly tessellation does not need to be sent again. The viewer can also perform internal GL specific caching (display lists) with considerable performance gains in these cases. For this to work correctly the logical object in must be described in TBuffer3D in the local reference frame, complete with the local/master translation. In some cases you will not have a real object you can reasonably set TBuffer3D::fID to, or the object is recycled or temporary. To suppress internal caching in the GL Viewer in these cases, set TBuffer3D::fID to 0 (null).; The viewer indicates it can support local frame objects through the TVirtualViewer3D interface method: PreferLocalFrame(). If this returns kTRUE you can make repeated calls to AddObject(), with TBuffer3D containing the same fID, and different fLocalMaster placements.; For viewers ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:413905,log,logical,413905,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,['log'],['logical']
Testability,"lanobis approach); TMVA::MethodHMatrix H-Matrix method, a simple comparison of chi-squared estimators for signal and background; TMVA::MethodInfo ; TMVA::MethodKNN k Nearest Neighbour classifier; TMVA::MethodLD Linear discriminant analysis; TMVA::MethodLikelihood Likelihood analysis (""non-parametric approach""); TMVA::MethodMLP Multi-layer perceptron implemented specifically for TMVA; TMVA::MethodPDEFoam Multi-dimensional probability density estimator using TFoam (PDE-Foam); TMVA::MethodPDERS Multi-dimensional probability density estimator range search (PDERS) method; TMVA::MethodRuleFit Friedman's RuleFit method; TMVA::MethodSVM Support Vector Machine; TMVA::MethodTMlpANN Implementation of interface for TMultiLayerPerceptron; TMVA::MinuitFitter Fitter using a Genetic Algorithm; TMVA::MinuitWrapper Wrapper around TMinuit; TMVA::MisClassificationError Implementation of the MisClassificationError as separation criterion; TMVA::MsgLogger Ostringstream derivative to redirect and format logging output; TMVA::Node Node for the BinarySearch or Decision Trees; TMVA::OptimizeConfigParameters Interface to different separation critiera used in training algorithms; TMVA::PDEFoam Tree of PDEFoamCells; TMVA::PDEFoamCell Single cell of FOAM; TMVA::PDEFoamDecisionTree Decision tree like PDEFoam; TMVA::PDEFoamDecisionTreeDensity Class for decision tree like PDEFoam density; TMVA::PDEFoamDensityBase PDEFoam event density interface; TMVA::PDEFoamDiscriminant Tree of PDEFoamCells; TMVA::PDEFoamDiscriminantDensity Class for Discriminant density; TMVA::PDEFoamEvent Tree of PDEFoamCells; TMVA::PDEFoamEventDensity Class for Event density; TMVA::PDEFoamKernelBase PDEFoam kernel interface; TMVA::PDEFoamKernelGauss Gaussian PDEFoam kernel estimator; TMVA::PDEFoamKernelLinN next neighbor PDEFoam kernel estimator; TMVA::PDEFoamKernelTrivial trivial PDEFoam kernel estimator; TMVA::PDEFoamMultiTarget Tree of PDEFoamCells; TMVA::PDEFoamTarget Tree of PDEFoamCells; TMVA::PDEFoamTargetDensity Class f",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/ClassIndex.html:103752,log,logging,103752,root/html604/ClassIndex.html,https://root.cern,https://root.cern/root/html604/ClassIndex.html,1,['log'],['logging']
Testability,"laps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooNumCdf&operator=(const RooNumCdf&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, RooLinkedList& cmdList) const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg(), const RooCmdArg& arg9 = RooCmdArg(), const RooCmdArg& arg10 = RooCmdArg()) const; virtual list<Double_t>*RooAbsReal::plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; virtual RooPlot*RooAbsReal::plotSliceOn(RooPlot* frame, const RooArgSet& sliceSet, Option_t* drawOptions = ""L"", Double_t scaleFactor = 1.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooNumCdf.html:19895,test,testArg,19895,root/html602/RooNumCdf.html,https://root.cern,https://root.cern/root/html602/RooNumCdf.html,2,['test'],['testArg']
Testability,"lapsBySampling(TGeoVolume* vol, Double_t ovlp = 0.10000000000000001, Int_t npoints = 1000000) const; Check illegal overlaps for volume VOL within a limit OVLP by sampling npoints; inside the volume shape. Int_t NChecksPerVolume(TGeoVolume* vol); Compute number of overlaps combinations to check per volume. void CheckOverlaps(const TGeoVolume* vol, Double_t ovlp = 0.10000000000000001, Option_t* option = """"); Check illegal overlaps for volume VOL within a limit OVLP. void PrintOverlaps() const; Print the current list of overlaps held by the manager class. void CheckPoint(Double_t x = 0, Double_t y = 0, Double_t z = 0, Option_t* option = """"); --- Draw point (x,y,z) over the picture of the daughers of the volume containing this point.; Generates a report regarding the path to the node containing this point and the distance to; the closest boundary. void CheckShape(TGeoShape* shape, Int_t testNo, Int_t nsamples, Option_t* option); Test for shape navigation methods. Summary for test numbers:; 1: DistFromInside/Outside. Sample points inside the shape. Generate; directions randomly in cos(theta). Compute DistFromInside and move the; point with bigger distance. Compute DistFromOutside back from new point.; Plot d-(d1+d2); 2: Safety test. Sample points inside the bounding and compute safety. Generate; directions randomly in cos(theta) and compute distance to boundary. Check if; Distance to boundary is bigger than safety. void ShapeDistances(TGeoShape* shape, Int_t nsamples, Option_t* option); Test TGeoShape::DistFromInside/Outside. Sample points inside the shape. Generate; directions randomly in cos(theta). Compute d1 = DistFromInside and move the; point on the boundary. Compute DistFromOutside and propagate with d2 making sure that; the shape is not re-entered. Swap direction and call DistFromOutside that; should fall back on the same point on the boundary (at d2). Propagate back on boundary; then compute DistFromInside that should be bigger than d1.; Plot d-(d1+d2). void Sha",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGeoChecker.html:15258,test,test,15258,root/html602/TGeoChecker.html,https://root.cern,https://root.cern/root/html602/TGeoChecker.html,2,['test'],['test']
Testability,lar_t TMVA::DNN::TGradientDescent< Architecture_t >::GetTestError ; (; ); const. inline . Definition at line 162 of file Minimizers.h. GetTestInterval(). template<typename Architecture_t > . size_t TMVA::DNN::TGradientDescent< Architecture_t >::GetTestInterval ; (; ); const. inline . Definition at line 163 of file Minimizers.h. GetTrainingError(). template<typename Architecture_t > . Scalar_t TMVA::DNN::TGradientDescent< Architecture_t >::GetTrainingError ; (; ); const. inline . Definition at line 161 of file Minimizers.h. HasConverged() [1/2]. template<typename Architecture_t > . bool TMVA::DNN::TGradientDescent< Architecture_t >::HasConverged. inline . Increases the minimization step counter by the test error evaluation period and uses the current internal value of the test error to determine if the minimization has converged. ; Definition at line 667 of file Minimizers.h. HasConverged() [2/2]. template<typename Architecture_t > . bool TMVA::DNN::TGradientDescent< Architecture_t >::HasConverged ; (; Scalar_t; testError). inline . Increases the minimization step counter by the test error evaluation period and uses the provided test error value to determine if the minimization has converged. ; Definition at line 681 of file Minimizers.h. Reset(). template<typename Architecture_t > . void TMVA::DNN::TGradientDescent< Architecture_t >::Reset ; (; ). inline . Reset minimizer object to default state. ; Definition at line 81 of file Minimizers.h. SetBatchSize(). template<typename Architecture_t > . void TMVA::DNN::TGradientDescent< Architecture_t >::SetBatchSize ; (; Scalar_t; rate). inline . Definition at line 168 of file Minimizers.h. SetConvergenceSteps(). template<typename Architecture_t > . void TMVA::DNN::TGradientDescent< Architecture_t >::SetConvergenceSteps ; (; size_t; steps). inline . Definition at line 165 of file Minimizers.h. SetLearningRate(). template<typename Architecture_t > . void TMVA::DNN::TGradientDescent< Architecture_t >::SetLear,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1DNN_1_1TGradientDescent.html:7569,test,testError,7569,doc/master/classTMVA_1_1DNN_1_1TGradientDescent.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1DNN_1_1TGradientDescent.html,1,['test'],['testError']
Testability,"lass Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Event(); Create an Event object.; When the constructor is invoked for the first time, the class static; variable fgTracks is 0 and the TClonesArray fgTracks is created. ~Event(). void Build(Int_t ev, Int_t arg5 = 600, Float_t ptmin = 1). Track * AddTrack(Float_t random, Float_t ptmin = 1); Add a new track to the list of tracks for this event.; To avoid calling the very time consuming operator new for each track,; the standard but not well know C++ operator ""new with placement""; is called. If tracks[i] is 0, a new Track object will be created; otherwise the previous Track[i] will be overwritten. void Clear(Option_t* option = """"). void Reset(Option_t* option = """"); Static function to reset all static objects for this event; fgTracks->Delete(option);. void SetHeader(Int_t i, Int_t run, Int_t date, Float_t random). void SetMeasure(UChar_t which, Int_t what). void SetRandomVertex(); This delete is to test the relocation of variable length array. TBits& GetTriggerBits(); { return fTriggerBits; }. Event(). Bool_t IsValid() const; { return fIsValid; }. void ResetHistogramPointer(); {fH=0;}. void SetNseg(Int_t n); { fNseg = n; }. void SetNtrack(Int_t n); { fNtrack = n; }. void SetNvertex(Int_t n); { fNvertex = n; SetRandomVertex(); }. void SetFlag(UInt_t f); { fFlag = f; }. void SetTemperature(Double32_t t); { fTemperature = t; }. void SetType(char* type); {strcpy(fType,type);}. void SetMatrix(UChar_t x, UChar_t y, Double32_t what); { if (x<3&&y<3) fMatrix[x][y]=what;}. Float_t GetClosestDistance(Int_t i); {return fClosestDistance[i];}. char * GetType(); {return fType;}. Int_t GetNtrack() const; { return fNtrack; }. Int_t GetNseg() const; { return fNseg; }. Int_t GetNvertex() const; { return fNvertex; }. UInt_t GetFlag() const; { return fFlag; }. Double32_t GetTemperature() const; { return fTemperature; }. EventHeader * GetHeader(); { return &fEvtHdr; }. TClonesArray * GetTracks() const",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/Event.html:10494,test,test,10494,root/html528/Event.html,https://root.cern,https://root.cern/root/html528/Event.html,1,['test'],['test']
Testability,"lass Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGCompositeFrame(const TGWindow* p = 0, UInt_t w = 1, UInt_t h = 1, UInt_t options = 0, Pixel_t back = GetDefaultFrameBackground()); Create a composite frame. A composite frame has in addition to a TGFrame; also a layout manager and a list of child frames. TGCompositeFrame(TGClient* c, Window_t id, const TGWindow* parent = 0); Create a frame using an externally created window. For example; to register the root window (called by TGClient), or a window; created via TVirtualX::InitWindow() (id is obtained with TVirtualX::GetWindowID()). ~TGCompositeFrame(); Delete a composite frame. Bool_t IsEditable() const; Return kTRUE if frame is being edited. void SetEditable(Bool_t on = kTRUE); Switch ON/OFF edit mode.; If edit mode is ON it is possible:. 1. embed other ROOT GUI application (a la ActiveX). For example:; TGMainFrame *m = new TGMainFrame(gClient->GetRoot(), 500, 500);; m->SetEditable();; gSystem->Load(""$ROOTSYS/test/Aclock""); // load Aclock demo; Aclock a;; gROOT->Macro(""$ROOTSYS/tutorials/gui/guitest.C"");; m->SetEditable(0);; m->MapWindow();. void Cleanup(); Cleanup and delete all objects contained in this composite frame.; This will delete all objects added via AddFrame().; CAUTION: all objects (frames and layout hints) must be unique, i.e.; cannot be shared. void SetLayoutManager(TGLayoutManager* l); Set the layout manager for the composite frame.; The layout manager is adopted by the frame and will be deleted; by the frame. void SetLayoutBroken(Bool_t on = kTRUE); Set broken layout. No Layout method is called. void SetEditDisabled(UInt_t on = 1); Set edit disable flag for this frame and subframes. - if (on & kEditDisable) - disable edit for this frame and all subframes. void ChangeOptions(UInt_t options); Change composite frame options. Options is an OR of the EFrameTypes. void SetCleanup(Int_t mode = kLocalCleanup); Turn on automatic cleanup of child frames in dtor. if mod",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGCompositeFrame.html:19702,test,test,19702,root/html528/TGCompositeFrame.html,https://root.cern,https://root.cern/root/html528/TGCompositeFrame.html,6,['test'],['test']
Testability,"lass Element > ; TMatrixT< Element >operator- (const TMatrixTSym< Element > &source1, const TMatrixT< Element > &source2); operation this = source1-source2 ; ; template<class Element > ; TVectorT< Element >operator- (const TVectorT< Element > &source1, const TVectorT< Element > &source2); Return source1-source2. ; ; template<class Element > ; TMatrixT< Element >operator- (Element val, const TMatrixT< Element > &source); operation this = val-source ; ; template<class Element > ; TMatrixT< Element >operator< (const TMatrixT< Element > &source1, const TMatrixT< Element > &source2); logical operation source1 < source2 ; ; template<class Element > ; TMatrixT< Element >operator< (const TMatrixT< Element > &source1, const TMatrixTSym< Element > &source2); logical operation source1 < source2 ; ; template<class Element > ; TMatrixT< Element >operator< (const TMatrixTSym< Element > &source1, const TMatrixT< Element > &source2); logical operation source1 < source2 ; ; template<class Element > ; TMatrixT< Element >operator<= (const TMatrixT< Element > &source1, const TMatrixT< Element > &source2); logical operation source1 <= source2 ; ; template<class Element > ; TMatrixT< Element >operator<= (const TMatrixT< Element > &source1, const TMatrixTSym< Element > &source2); logical operation source1 <= source2 ; ; template<class Element > ; TMatrixT< Element >operator<= (const TMatrixTSym< Element > &source1, const TMatrixT< Element > &source2); logical operation source1 <= source2 ; ; template<class Element > ; Bool_toperator== (const TMatrixTBase< Element > &m1, const TMatrixTBase< Element > &m2); Check to see if two matrices are identical. ; ; template<class Element > ; Bool_toperator== (const TVectorT< Element > &source1, const TVectorT< Element > &source2); Check to see if two vectors are identical. ; ; template<class Element > ; TMatrixT< Element >operator> (const TMatrixT< Element > &source1, const TMatrixT< Element > &source2); logical oper",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/namespaceTMatrixTAutoloadOps.html:11490,log,logical,11490,doc/master/namespaceTMatrixTAutoloadOps.html,https://root.cern,https://root.cern/doc/master/namespaceTMatrixTAutoloadOps.html,6,['log'],['logical']
Testability,"lass Hierarchy. Search. Source:; header file. viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  ROOFIT;  ROOSTATS;  RooStats::DebuggingTestStat. class RooStats::DebuggingTestStat: public RooStats::TestStatistic. DebuggingTestStat is a simple implementation of the DistributionCreator interface used for debugging.; The sampling distribution is uniformly random between [0,1] and is INDEPENDENT of the data. So it is not useful; for true statistical tests, but it is useful for debugging. Function Members (Methods); This is an abstract class, constructors will not be documented.; Look at the header to check for available constructors.; public:. virtual~DebuggingTestStat(); static TClass*Class(); virtual Double_tEvaluate(RooAbsData&, RooArgSet&); virtual const RooAbsArg*GetTestStatistic() const; virtual const TStringRooStats::TestStatistic::GetVarName() const; virtual TClass*IsA() const; RooStats::DebuggingTestStat&operator=(const RooStats::DebuggingTestStat&); virtual voidShowMembers(TMemberInspector& insp, char* parent); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Data Members; private:. TRandom*fRand; RooRealVar*fTestStatistic. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~DebuggingTestStat(); delete fRand;; delete fTestStatistic;. Double_t Evaluate(RooAbsData& , RooArgSet& ); Main interface to evaluate the test statistic on a dataset. const RooAbsArg* GetTestStatistic() const; Get the TestStatistic. {return fTestStatistic;}.  Author: Kyle Cranmer, Lorenzo Moneta, Gregory Schott, Wouter Verkerke  Copyright (C) 1995-2008, Rene Brun and Fons Rademakers. *;  Last changed: root/roostats:$Id: DebuggingTestStat.h 31276 2009-11-18 15:06:42Z moneta $  Last generated: 2009-12-07 13:49; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooStats__DebuggingTestStat.html:1538,test,test,1538,root/html526/RooStats__DebuggingTestStat.html,https://root.cern,https://root.cern/root/html526/RooStats__DebuggingTestStat.html,1,['test'],['test']
Testability,"lass description; function members; data members; class charts. ROOT;  GUI;  GUI;  TGPasswdDialog. class TGPasswdDialog. TGPasswdDialog. Graphic dialog to enter passwords. Usage:. {; Buffer for the passwd; char pwdbuf[128]. Open the dialog box; TGPasswdDialog dialog(""My prompt"", pwdbuf, 128);. Wait until the user is done; while (gROOT->IsInterrupted()); gSystem->DispatchOneEvent(kFALSE);. Password is now in pwdbuf. }. Function Members (Methods); public:. virtual~TGPasswdDialog(); static TClass*Class(); voidCloseWindow(); voidDoClose(); virtual TClass*IsA() const; TGPasswdDialog&operator=(const TGPasswdDialog&); voidReturnPressed(); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); TGPasswdDialog(const TGPasswdDialog&); TGPasswdDialog(const char* prompt, char* pwdbuf, Int_t pwdlenmax, UInt_t w = 400, UInt_t h = 400). Data Members; private:. TGTransientFrame*fDialogmain frame of this widget; TGTextButton*fOkOk button; TGTextEntry*fPasswdPassword TextEntry; TGTextBuffer*fPasswdTextPasswd Buffer; char*fPwdBufbuffer where to store the passwd; Int_tfPwdLenMaxpasswd buffer length. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGPasswdDialog(const char* prompt, char* pwdbuf, Int_t pwdlenmax, UInt_t w = 400, UInt_t h = 400); Create an editor in a dialog. ~TGPasswdDialog(); Delete log window. void DoClose(); Handle close button. void CloseWindow(); Called when closed via window manager action. void ReturnPressed(); Handle return. TGPasswdDialog(const char* prompt, char* pwdbuf, Int_t pwdlenmax, UInt_t w = 400, UInt_t h = 400).  Author: G. Ganis 10/10/2005  Copyright (C) 1995-2005, Rene Brun and Fons Rademakers. *;  Last changed: root/gui:$Id$  Last generated: 2015-06-02 15:56; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TGPasswdDialog.html:1598,log,log,1598,root/html604/TGPasswdDialog.html,https://root.cern,https://root.cern/root/html604/TGPasswdDialog.html,1,['log'],['log']
Testability,"lass description; function members; data members; class charts. ROOT;  GUI;  GUI;  TGPasswdDialog. class TGPasswdDialog. TGPasswdDialog. Graphic dialog to enter passwords. Usage:. {; Buffer for the passwd; char pwdbuf[128]. Open the dialog box; TGPasswdDialog dialog(""My prompt"", pwdbuf, 128);. Wait until the user is done; while (gROOT->IsInterrupted()); gSystem->DispatchOneEvent(kFALSE);. Password is now in pwdbuf. }. Function Members (Methods); public:. virtual~TGPasswdDialog(); static TClass*Class(); voidCloseWindow(); voidDoClose(); virtual TClass*IsA() const; TGPasswdDialog&operator=(const TGPasswdDialog&); voidReturnPressed(); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); TGPasswdDialog(const TGPasswdDialog&); TGPasswdDialog(const char* prompt, char* pwdbuf, Int_t pwdlenmax, UInt_t w = 400, UInt_t h = 400). Data Members; private:. TGTransientFrame*fDialogmain frame of this widget; TGTextButton*fOkOk button; TGTextEntry*fPasswdPassword TextEntry; TGTextBuffer*fPasswdTextPasswd Buffer; char*fPwdBufbuffer where to store the passwd; Int_tfPwdLenMaxpasswd buffer length. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGPasswdDialog(const char* prompt, char* pwdbuf, Int_t pwdlenmax, UInt_t w = 400, UInt_t h = 400); Create an editor in a dialog. ~TGPasswdDialog(); Delete log window. void DoClose(); Handle close button. void CloseWindow(); Called when closed via window manager action. void ReturnPressed(); Handle return. TGPasswdDialog(const char* prompt, char* pwdbuf, Int_t pwdlenmax, UInt_t w = 400, UInt_t h = 400).  Author: G. Ganis 10/10/2005  Copyright (C) 1995-2005, Rene Brun and Fons Rademakers. *;  Last changed: root/gui:$Id$  Last generated: 2015-06-30 14:56; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGPasswdDialog.html:1598,log,log,1598,root/html602/TGPasswdDialog.html,https://root.cern,https://root.cern/root/html602/TGPasswdDialog.html,1,['log'],['log']
Testability,"lass's unary functions performing the gif test according to the ETestType provided. ; ; Double_toperator() (ETestType test=kAD, const Char_t *option=""p"") const; Returns default Anderson Darling 1-Sample Test and default p-value; option ""t"" returns the test statistic value specific to the test type. ; ; voidSetDistribution (EDistribution dist, const std::vector< double > &distParams={}); Sets the distribution for the predefined distribution types and optionally its parameters for 1-sample tests. ; ; voidSetUserCDF (const IGenFunction &cdf, Double_t xmin=1, Double_t xmax=0); Specialization to set the user input distribution as a cumulative distribution function for 1-sample tests. ; ; template<class Dist > ; voidSetUserCDF (Dist &cdf, Double_t xmin=1, Double_t xmax=0); Sets the user input distribution as a cumulative distribution function for 1-sample tests. ; ; voidSetUserDistribution (const IGenFunction &dist, GoFTest::EUserDistribution userDist=kPDF, Double_t xmin=1, Double_t xmax=0); Sets the user input distribution function for 1-sample test using the ROOT::Math::IGenFunction interface. ; ; template<class Dist > ; voidSetUserDistribution (Dist &dist, EUserDistribution userDist=kPDF, Double_t xmin=1, Double_t xmax=0); Sets the user input distribution function for 1-sample test as a generic functor object. ; ; voidSetUserPDF (const IGenFunction &pdf, Double_t xmin=1, Double_t xmax=0); Specialization to set the user input distribution as a probability density function for 1-sample tests using the ROOT::Math::IGenFunction interface. ; ; template<class Dist > ; voidSetUserPDF (Dist &pdf, Double_t xmin=1, Double_t xmax=0); Sets the user input distribution as a probability density function for 1-sample tests. ; . Static Public Member Functions; static voidAndersonDarling2SamplesTest (const ROOT::Fit::BinData &data1, const ROOT::Fit::BinData &data2, Double_t &pvalue, Double_t &testStat); Compute the 2-Sample Anderson Darling test for binned data",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1GoFTest.html:5001,test,test,5001,doc/master/classROOT_1_1Math_1_1GoFTest.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1GoFTest.html,1,['test'],['test']
Testability,"lass(). static TClass * THistPainter::Class ; (; ). static . ReturnsTClass describing this class . Class_Name(). static const char * THistPainter::Class_Name ; (; ). static . ReturnsName of this class . Class_Version(). static constexpr Version_t THistPainter::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 159 of file THistPainter.h. ComputeRenderingRegions(). std::vector< THistRenderingRegion > THistPainter::ComputeRenderingRegions ; (; TAxis *; pAxis, . Int_t; nPixels, . bool; isLog. ). virtual . Returns the rendering regions for an axis to use in the COL2 option. ; The algorithm analyses the size of the axis compared to the size of the rendering region. It figures out the boundaries to use for each color of the rendering region. Only one axis is computed here.; This allows for a single computation of the boundaries before iterating through all of the bins.; Parameters. pAxisthe axis to consider ; nPixelsthe number of pixels to render axis into ; isLogwhether the axis is log scale . Definition at line 5472 of file THistPainter.cxx. DeclFileName(). static const char * THistPainter::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 159 of file THistPainter.h. DefineColorLevels(). void THistPainter::DefineColorLevels ; (; Int_t; ndivz). virtual . Define the color levels used to paint legos, surfaces etc.. ; Definition at line 9603 of file THistPainter.cxx. DistancetoPrimitive(). Int_t THistPainter::DistancetoPrimitive ; (; Int_t; px, . Int_t; py. ). overridevirtual . Compute the distance from the point px,py to a line. ; Compute the closest distance of approach from point px,py to elements of an histogram. The distance is computed in pixels units.; Algorithm: Currently, this simple model computes the distance from the mouse to the histogram contour only. ; Implements TVirtualHistPainter.; Definition at line 3255 of file THistPainter.cxx.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTHistPainter.html:152428,log,log,152428,doc/master/classTHistPainter.html,https://root.cern,https://root.cern/doc/master/classTHistPainter.html,1,['log'],['log']
Testability,"lass*IsA() const; voidMakeChildren(); voidMakeCopies(int number); voidMutate(Double_t probability = 20, Int_t startIndex = 0, Bool_t near = kFALSE, Double_t spread = 0.1, Bool_t mirror = kFALSE); voidNextGeneration(); TMVA::GeneticPopulation&operator=(const TMVA::GeneticPopulation&); voidPrint(Int_t untilIndex = -1); voidPrint(ostream& out, Int_t utilIndex = -1); voidSetRandomSeed(UInt_t seed = 0); virtual voidShowMembers(TMemberInspector& insp); voidSort(); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); voidTrimPopulation(); vector<Double_t>VariableDistribution(Int_t varNumber); TH1F*VariableDistribution(Int_t varNumber, Int_t bins, Int_t min, Int_t max). private:. TMVA::MsgLogger&Log() const; TMVA::GeneticGenesMakeSex(TMVA::GeneticGenes male, TMVA::GeneticGenes female). Data Members; private:. vector<TMVA::GeneticGenes>fGenePoolthe ""genePool"" where the individuals of the current generation are stored; TMVA::MsgLogger*fLoggermessage logger; Int_tfPopulationSizeLimit; TRandom3*fRandomGeneratorrandom Generator for this population; vector<TMVA::GeneticRange*>fRangescontains the ranges inbetween the values of the coefficients have to be. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; GeneticPopulation(const vector<TMVA::Interval*>& ranges, Int_t size, UInt_t seed = 0); Constructor. ~GeneticPopulation(); destructor. void SetRandomSeed(UInt_t seed = 0); the random seed of the random generator. void MakeCopies(int number); produces offspring which is are copies of their parents; Parameters:; int number : the number of the last individual to be copied. void MakeChildren(); does what the name says,... it creates children out of members of the; current generation; children have a combination of the coefficients of their parents. TMVA::GeneticGenes MakeSex(TMVA::GeneticGenes male, TMVA::GeneticGenes female); this function takes two individuals and produces offspring by mixing (recombining) their; coefficients. v",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMVA__GeneticPopulation.html:2065,log,logger,2065,root/html528/TMVA__GeneticPopulation.html,https://root.cern,https://root.cern/root/html528/TMVA__GeneticPopulation.html,3,['log'],['logger']
Testability,lass; TProfile3D Profile3D histogram class; TProof PROOF control class; TProofChain TChain proxy for running chains on PROOF; TProofCondor PROOF control class for slaves allocated by condor; TProofDebug ; TProofDesc Small class describing a proof session; TProofDraw Tree drawing selector for PROOF; TProofDrawEntryList A Selectoor to fill a TEntryList from TTree::Draw; TProofDrawEventList Tree drawing selector for PROOF; TProofDrawGraph Tree drawing selector for PROOF; TProofDrawHist Tree drawing selector for PROOF; TProofDrawListOfGraphs Tree drawing selector for PROOF; TProofDrawListOfGraphs::Point3D_t ; TProofDrawListOfPolyMarkers3D Tree drawing selector for PROOF; TProofDrawListOfPolyMarkers3D::Point4D_t ; TProofDrawPolyMarker3D Tree drawing selector for PROOF; TProofDrawProfile Tree drawing selector for PROOF; TProofDrawProfile2D Tree drawing selector for PROOF; TProofLimitsFinder Find and communicate best axis limits; TProofLite PROOF-Lite control class; TProofLog PROOF session log handler; TProofLogElem PROOF session log element; TProofMgr Abstract PROOF manager interface; TProofMgrLite XrdProofd PROOF manager interface; TProofNodeInfo Class describing a PROOF node; TProofOutputFile Wrapper class to steer the merging of files produced on workers; TProofPlayer Basic PROOF player; TProofPlayerLite PROOF player running in PROOF-Lite; TProofPlayerLocal PROOF player running on client; TProofPlayerRemote PROOF player running on master server; TProofPlayerSlave PROOF player running on slave server; TProofPlayerSuperMaster PROOF player running on super master; TProofProgressDialog PROOF progress dialog; TProofProgressInfo Progress information; TProofProgressLog Class implementing a log graphic box; TProofProgressMemoryPlot PROOF progress memory plots; TProofProgressStatus Proof progress status class; TProofQueryResult Class describing a PROOF query; TProofResources Abstract class describing PROOF resources; TProofResourcesStatic Class to handle PROOF static config; TP,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/ClassIndex.html:113783,log,log,113783,root/html528/ClassIndex.html,https://root.cern,https://root.cern/root/html528/ClassIndex.html,1,['log'],['log']
Testability,"lassDef_StreamerNVirtual_b). Data Members; private:. TRandom*fRand; Double_tfSize; RooRealVar*fTestStatistic. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~DebuggingSampler(). SamplingDistribution* GetSamplingDistribution(RooArgSet& paramsOfInterest); Main interface to get a ConfInterval, pure virtual. Double_t EvaluateTestStatistic(RooAbsData& , RooArgSet& ); Main interface to evaluate the test statistic on a dataset. TestStatistic* GetTestStatistic() const; Get the TestStatistic. Double_t ConfidenceLevel() const; Get the Confidence level for the test. {return 1.-fSize;}. void Initialize(RooAbsArg& , RooArgSet& , RooArgSet& ); Common Initialization. void SetPdf(RooAbsPdf& ); Set the Pdf, add to the the workspace if not already there. {}. void SetParameters(RooArgSet& ); specify the parameters of interest in the interval. {}. void SetNuisanceParameters(const RooArgSet& ); specify the nuisance parameters (eg. the rest of the parameters). {}. void SetParametersForTestStat(const RooArgSet& ); specify the values of parameters used when evaluating test statistic. {}. void SetGlobalObservables(const RooArgSet& ); specify the conditional observables. {}. void SetTestSize(Double_t size); set the size of the test (rate of Type I error) ( Eg. 0.05 for a 95% Confidence Interval). {fSize = size;}. void SetConfidenceLevel(Double_t cl); set the confidence level for the interval (eg. 0.95 for a 95% Confidence Interval). {fSize = 1.-cl;}. void SetTestStatistic(RooStats::TestStatistic* ); Set the TestStatistic (want the argument to be a function of the data & parameter points.  Author: Kyle Cranmer, Lorenzo Moneta, Gregory Schott, Wouter Verkerke  Copyright (C) 1995-2008, Rene Brun and Fons Rademakers. *;  Last changed: root/roostats:$Id$  Last generated: 2015-09-08 17:03; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooStats__DebuggingSampler.html:3063,test,test,3063,root/html534/RooStats__DebuggingSampler.html,https://root.cern,https://root.cern/root/html534/RooStats__DebuggingSampler.html,2,['test'],['test']
Testability,"lassHints(const char* className, const char* resourceName); virtual voidTGCompositeFrame::SetCleanup(Int_t mode = kLocalCleanup); voidTGFrame::SetDNDSource(Bool_t onoff); voidTGFrame::SetDNDTarget(Bool_t onoff); virtual voidTGFrame::SetDragType(Int_t type); virtual voidTGFrame::SetDrawOption(Option_t* = """"); virtual voidTGFrame::SetDropType(Int_t type); static voidTObject::SetDtorOnly(void* obj); virtual voidTGCompositeFrame::SetEditable(Bool_t on = kTRUE); virtual voidTGCompositeFrame::SetEditDisabled(UInt_t on = 1); virtual voidTGFrame::SetForegroundColor(Pixel_t); voidTGFrame::SetFrameElement(TGFrameElement* fe); virtual voidTGFrame::SetHeight(UInt_t h); voidTGMainFrame::SetIconName(const char* name); const TGPicture*TGMainFrame::SetIconPixmap(const char* iconName); voidTGMainFrame::SetIconPixmap(char** xpm_array); virtual voidTGCompositeFrame::SetLayoutBroken(Bool_t on = kTRUE); virtual voidTGCompositeFrame::SetLayoutManager(TGLayoutManager* l); voidSetLogWindow(TSessionLogView* log); virtual voidTGCompositeFrame::SetMapSubwindows(Bool_t on); virtual voidTGFrame::SetMaxHeight(UInt_t h); virtual voidTGFrame::SetMaxWidth(UInt_t w); virtual voidTGFrame::SetMinHeight(UInt_t h); virtual voidTGFrame::SetMinWidth(UInt_t w); voidTGMainFrame::SetMWMHints(UInt_t value, UInt_t funcs, UInt_t input); virtual voidTGWindow::SetName(const char* name); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTGFrame::SetSize(const TGDimension& s); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidTGFrame::SetWidth(UInt_t w); virtual voidTGMainFrame::SetWindowName(const char* name = 0); voidTGMainFrame::SetWMPosition(Int_t x, Int_t y); voidTGMainFrame::SetWMSize(UInt_t w, UInt_t h); voidTGMainFrame::SetWMSizeHints(UInt_t wmin, UInt_t hmin, UInt_t wmax, UInt_t hmax, UInt_t winc, UInt_t hinc); voidTGMainFrame::SetWMState(EInitialState state); virtual voidTGFrame::SetX(Int_t x); virtual voidTGFrame::SetY(Int_t y); voidShowEnabledPackages(); virtual voidTGCompositeFrame::S",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TSessionViewer.html:16060,log,log,16060,root/html528/TSessionViewer.html,https://root.cern,https://root.cern/root/html528/TSessionViewer.html,6,['log'],['log']
Testability,"lassUInt_t GetClass() constDefinition Event.h:86; TMVA::MsgLoggerostringstream derivative to redirect and format outputDefinition MsgLogger.h:57; TMVA::PDFPDF wrapper for histograms; uses user-defined spline interpolation.Definition PDF.h:63; TMVA::PDF::GetXminDouble_t GetXmin() constDefinition PDF.h:104; TMVA::PDF::GetXmaxDouble_t GetXmax() constDefinition PDF.h:105; TMVA::PDF::GetValDouble_t GetVal(Double_t x) constreturns value PDF(x)Definition PDF.cxx:701; TMVA::ToolsGlobal auxiliary applications and data treatment routines.Definition Tools.h:76; TMVA::Tools::ComputeStatvoid ComputeStat(const std::vector< TMVA::Event * > &, std::vector< Float_t > *, Double_t &, Double_t &, Double_t &, Double_t &, Double_t &, Double_t &, Int_t signalClass, Bool_t norm=kFALSE)sanity checkDefinition Tools.cxx:202; TMVA::Tools::GetParentvoid * GetParent(void *child)get parent nodeDefinition Tools.cxx:1140; TMVA::Tools::FormattedOutputvoid FormattedOutput(const std::vector< Double_t > &, const std::vector< TString > &, const TString titleVars, const TString titleValues, MsgLogger &logger, TString format=""%+1.3f"")formatted output of simple tableDefinition Tools.cxx:887; TMVA::Tools::HistoHasEquidistantBinsBool_t HistoHasEquidistantBins(const TH1 &h)Definition Tools.cxx:1486; TMVA::Tools::ParseFormatLineTList * ParseFormatLine(TString theString, const char *sep="":"")Parse the string and cut into labels separated by "":"".Definition Tools.cxx:401; TMVA::Tools::NormVariableDouble_t NormVariable(Double_t x, Double_t xmin, Double_t xmax)normalise to output range: [-1, 1]Definition Tools.cxx:110; TMVA::Tools::WriteFloatArbitraryPrecisionvoid WriteFloatArbitraryPrecision(Float_t val, std::ostream &os)writes a float value with the available precision to a streamDefinition Tools.cxx:1058; TMVA::Tools::GetYTitleWithUnitTString GetYTitleWithUnit(const TH1 &h, const TString &unit, Bool_t normalised)histogramming utilityDefinition Tools.cxx:1048; TMVA::Tools::GetSeparationDouble_t GetSeparation(TH1 *S",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/Tools_8cxx_source.html:72754,log,logger,72754,doc/master/Tools_8cxx_source.html,https://root.cern,https://root.cern/doc/master/Tools_8cxx_source.html,1,['log'],['logger']
Testability,"lass_example.root; DataSetInfo : [dataset] : Added class ""Signal""; : Add Tree TreeS of type Signal with 2000 events; DataSetInfo : [dataset] : Added class ""bg0""; : Add Tree TreeB0 of type bg0 with 2000 events; DataSetInfo : [dataset] : Added class ""bg1""; : Add Tree TreeB1 of type bg1 with 2000 events; DataSetInfo : [dataset] : Added class ""bg2""; : Add Tree TreeB2 of type bg2 with 2000 events; : Dataset[dataset] : Class index : 0 name : Signal; : Dataset[dataset] : Class index : 1 name : bg0; : Dataset[dataset] : Class index : 2 name : bg1; : Dataset[dataset] : Class index : 3 name : bg2; Factory : Booking method: [1mBDTG[0m; : ; : the option NegWeightTreatment=InverseBoostNegWeights does not exist for BoostType=Grad; : --> change to new default NegWeightTreatment=Pray; : Rebuilding Dataset dataset; : Building event vectors for type 2 Signal; : Dataset[dataset] : create input formulas for tree TreeS; : Building event vectors for type 2 bg0; : Dataset[dataset] : create input formulas for tree TreeB0; : Building event vectors for type 2 bg1; : Dataset[dataset] : create input formulas for tree TreeB1; : Building event vectors for type 2 bg2; : Dataset[dataset] : create input formulas for tree TreeB2; DataSetFactory : [dataset] : Number of events in input trees; : ; : ; : ; : ; : Number of training and testing events; : ---------------------------------------------------------------------------; : Signal -- training events : 1000; : Signal -- testing events : 1000; : Signal -- training and testing events: 2000; : bg0 -- training events : 1000; : bg0 -- testing events : 1000; : bg0 -- training and testing events: 2000; : bg1 -- training events : 1000; : bg1 -- testing events : 1000; : bg1 -- training and testing events: 2000; : bg2 -- training events : 1000; : bg2 -- testing events : 1000; : bg2 -- training and testing events: 2000; : ; DataSetInfo : Correlation matrix (Signal):; : ----------------------------------------; : var1 var2 var3 var4; : var1: +1.000 +0.397 +0",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVAMulticlass_8C.html:1851,test,testing,1851,doc/master/TMVAMulticlass_8C.html,https://root.cern,https://root.cern/doc/master/TMVAMulticlass_8C.html,9,['test'],['testing']
Testability,"last AutoSave. if option contains ""SaveSelf"", gDirectory->SaveSelf() is called.; This allows another process to analyze the Tree while the Tree is being filled. if option contains ""FlushBaskets"", TTree::FlushBaskets is called and all; the current basket are closed-out and written to disk individually. By default the previous header is deleted after having written the new header.; if option contains ""Overwrite"", the previous Tree header is deleted; before written the new header. This option is slightly faster, but; the default option is safer in case of a problem (disk quota exceeded); when writing the new header. The function returns the number of bytes written to the file.; if the number of bytes is null, an error has occurred while writing; the header to the file. How to write a Tree in one process and view it from another process. The following two scripts illustrate how to do this.; The script treew.C is executed by process1, treer.C by process2. ----- script treew.C; void treew() {; TFile f(""test.root"",""recreate"");; TNtuple *ntuple = new TNtuple(""ntuple"",""Demo"",""px:py:pz:random:i"");; Float_t px, py, pz;; for ( Int_t i=0; i<10000000; i++) {; gRandom->Rannor(px,py);; pz = px*px + py*py;; Float_t random = gRandom->Rndm(1);; ntuple->Fill(px,py,pz,random,i);; if (i%1000 == 1) ntuple->AutoSave(""SaveSelf"");; }; }. ----- script treer.C; void treer() {; TFile f(""test.root"");; TTree *ntuple = (TTree*)f.Get(""ntuple"");; TCanvas c1;; Int_t first = 0;; while(1) {; if (first == 0) ntuple->Draw(""px>>hpx"", """","""",10000000,first);; else ntuple->Draw(""px>>+hpx"","""","""",10000000,first);; first = (Int_t)ntuple->GetEntries();; c1.Update();; gSystem->Sleep(1000); //sleep 1 second; ntuple->Refresh();; }; }. TBranch* BranchImp(const char* branchname, const char* classname, TClass* ptrClass, void* addobj, Int_t bufsize, Int_t splitlevel); Same as TTree::Branch() with added check that addobj matches className. See TTree::Branch() for other details. TBranch* BranchImp(const char* branchname, ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TTree.html:41820,test,test,41820,root/html532/TTree.html,https://root.cern,https://root.cern/root/html532/TTree.html,4,['test'],['test']
Testability,"lastxbin],[firstybin,lastybin] for a 2-D histogram By default the integral is computed as the sum of bin contents in the range. ; ; virtual Double_tIntegral (Int_t, Int_t, Int_t, Int_t, Int_t, Int_t, Option_t *="""") const; ; Double_tIntegral (Option_t *option="""") const override; Return integral of bin contents. ; ; virtual Double_tIntegralAndError (Int_t binx1, Int_t binx2, Int_t biny1, Int_t biny2, Double_t &err, Option_t *option="""") const; Return integral of bin contents in range [firstxbin,lastxbin],[firstybin,lastybin] for a 2-D histogram. ; ; Double_tInterpolate (Double_t x, Double_t y) const override; Given a point P(x,y), Interpolate approximates the value via bilinear interpolation based on the four nearest bin centers see Wikipedia, Bilinear Interpolation Andy Mastbaum 10/8/2008 vaguely based on R.Raja 6-Sep-2008. ; ; Double_tInterpolate (Double_t x, Double_t y, Double_t z) const override; illegal for a TH2 ; ; TClass *IsA () const override; ; Double_tKolmogorovTest (const TH1 *h2, Option_t *option="""") const override; Statistical test of compatibility in shape between THIS histogram and h2, using Kolmogorov test. ; ; TProfile *ProfileX (const char *name=""_pfx"", Int_t firstybin=1, Int_t lastybin=-1, Option_t *option="""") const; Project a 2-D histogram into a profile histogram along X. ; ; TProfile *ProfileY (const char *name=""_pfy"", Int_t firstxbin=1, Int_t lastxbin=-1, Option_t *option="""") const; Project a 2-D histogram into a profile histogram along Y. ; ; TH1D *ProjectionX (const char *name=""_px"", Int_t firstybin=0, Int_t lastybin=-1, Option_t *option="""") const; Project a 2-D histogram into a 1-D histogram along X. ; ; TH1D *ProjectionY (const char *name=""_py"", Int_t firstxbin=0, Int_t lastxbin=-1, Option_t *option="""") const; Project a 2-D histogram into a 1-D histogram along Y. ; ; voidPutStats (Double_t *stats) override; Replace current statistics with the values in array stats. ; ; TH1D *QuantilesX (Double_t prob=0.5, c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTH2.html:6982,test,test,6982,doc/master/classTH2.html,https://root.cern,https://root.cern/doc/master/classTH2.html,2,['test'],['test']
Testability,"late<typename Architecture_t , typename Layer_t = VGeneralLayer<Architecture_t>> . size_t TMVA::DNN::TDeepNet< Architecture_t, Layer_t >::fBatchDepth. private . The depth of the batch used for training/testing. ; Definition at line 93 of file DeepNet.h. fBatchHeight. template<typename Architecture_t , typename Layer_t = VGeneralLayer<Architecture_t>> . size_t TMVA::DNN::TDeepNet< Architecture_t, Layer_t >::fBatchHeight. private . The height of the batch used for training/testing. ; Definition at line 94 of file DeepNet.h. fBatchSize. template<typename Architecture_t , typename Layer_t = VGeneralLayer<Architecture_t>> . size_t TMVA::DNN::TDeepNet< Architecture_t, Layer_t >::fBatchSize. private . Batch size used for training and evaluation. ; Definition at line 88 of file DeepNet.h. fBatchWidth. template<typename Architecture_t , typename Layer_t = VGeneralLayer<Architecture_t>> . size_t TMVA::DNN::TDeepNet< Architecture_t, Layer_t >::fBatchWidth. private . The width of the batch used for training/testing. ; Definition at line 95 of file DeepNet.h. fI. template<typename Architecture_t , typename Layer_t = VGeneralLayer<Architecture_t>> . EInitialization TMVA::DNN::TDeepNet< Architecture_t, Layer_t >::fI. private . The initialization method of the network. ; Definition at line 100 of file DeepNet.h. fInputDepth. template<typename Architecture_t , typename Layer_t = VGeneralLayer<Architecture_t>> . size_t TMVA::DNN::TDeepNet< Architecture_t, Layer_t >::fInputDepth. private . The depth of the input. ; Definition at line 89 of file DeepNet.h. fInputHeight. template<typename Architecture_t , typename Layer_t = VGeneralLayer<Architecture_t>> . size_t TMVA::DNN::TDeepNet< Architecture_t, Layer_t >::fInputHeight. private . The height of the input. ; Definition at line 90 of file DeepNet.h. fInputWidth. template<typename Architecture_t , typename Layer_t = VGeneralLayer<Architecture_t>> . size_t TMVA::DNN::TDeepNet< Architecture_t, Layer_t >::fInputWidth. private",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1DNN_1_1TDeepNet.html:30231,test,testing,30231,doc/master/classTMVA_1_1DNN_1_1TDeepNet.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1DNN_1_1TDeepNet.html,1,['test'],['testing']
Testability,late<typename Architecture_t > . size_t TMVA::DNN::TDLGradientDescent< Architecture_t >::GetConvergenceSteps ; (; ); const. inline . Definition at line 147 of file DLMinimizers.h. GetTestError(). template<typename Architecture_t > . Scalar_t TMVA::DNN::TDLGradientDescent< Architecture_t >::GetTestError ; (; ); const. inline . Definition at line 149 of file DLMinimizers.h. GetTestInterval(). template<typename Architecture_t > . size_t TMVA::DNN::TDLGradientDescent< Architecture_t >::GetTestInterval ; (; ); const. inline . Definition at line 150 of file DLMinimizers.h. GetTrainingError(). template<typename Architecture_t > . Scalar_t TMVA::DNN::TDLGradientDescent< Architecture_t >::GetTrainingError ; (; ); const. inline . Definition at line 148 of file DLMinimizers.h. HasConverged() [1/2]. template<typename Architecture_t > . bool TMVA::DNN::TDLGradientDescent< Architecture_t >::HasConverged. Increases the minimization step counter by the test error evaluation period and uses the current internal value of the test error to determine if the minimization has converged. ; Definition at line 276 of file DLMinimizers.h. HasConverged() [2/2]. template<typename Architecture_t > . bool TMVA::DNN::TDLGradientDescent< Architecture_t >::HasConverged ; (; Scalar_t; testError). Increases the minimization step counter by the test error evaluation period and uses the provided test error value to determine if the minimization has converged. ; Definition at line 290 of file DLMinimizers.h. Reset(). template<typename Architecture_t > . void TMVA::DNN::TDLGradientDescent< Architecture_t >::Reset ; (; ). inline . Reset minimizer object to default state. ; Definition at line 89 of file DLMinimizers.h. SetBatchSize(). template<typename Architecture_t > . void TMVA::DNN::TDLGradientDescent< Architecture_t >::SetBatchSize ; (; Scalar_t; rate). inline . Definition at line 156 of file DLMinimizers.h. SetConvergenceSteps(). template<typename Architecture_t > . void TMVA::DNN::,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1DNN_1_1TDLGradientDescent.html:6190,test,test,6190,doc/master/classTMVA_1_1DNN_1_1TDLGradientDescent.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1DNN_1_1TDLGradientDescent.html,2,['test'],['test']
Testability,"lation will be paralellized over multiple processes. By default the data; is split with 'bulk' partitioning (each process calculates a contigious block of fraction 1/nCPU; of the data). For binned data this approach may be suboptimal as the number of bins with >0 entries; in each processing block many vary greatly thereby distributing the workload rather unevenly.; If interleave is set to true, the interleave partitioning strategy is used where each partition; i takes all bins for which (ibin % ncpu == i) which is more likely to result in an even workload.; If splitCutRange is true, a different rangeName constructed as rangeName_{catName} will be used; as range definition for each index state of a RooSimultaneous. RooAbsTestStatistic(const RooAbsTestStatistic& other, const char* name = 0); Copy constructor. ~RooAbsTestStatistic(); Destructor. Double_t evaluate() const; Calculates and return value of test statistic. If the test statistic; is calculated from on a RooSimultaneous, the test statistic calculation; is performed separately on each simultaneous p.d.f component and associated; data and then combined. If the test statistic calculation is parallelized; partitions are calculated in nCPU processes and a posteriori combined. Bool_t initialize(); One-time initialization of the test statistic. Setup; infrastructure for simultaneous p.d.f processing and/or; parallelized processing if requested. Bool_t redirectServersHook(const RooAbsCollection& newServerList, Bool_t mustReplaceAll, Bool_t nameChange, Bool_t isRecursive); Forward server redirect calls to component test statistics. void printCompactTreeHook(ostream& os, const char* indent = """"); Add extra information on component test statistics when printing; itself as part of a tree structure. void constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); Forward constant term optimization management calls to component; test statistics. void setMPSet(Int_t setNum, Int_t numSets); S",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooAbsTestStatistic.html:42820,test,test,42820,root/html602/RooAbsTestStatistic.html,https://root.cern,https://root.cern/root/html602/RooAbsTestStatistic.html,4,['test'],['test']
Testability,"lation. NeymanConstruction(). void SetTestStatSampler(RooStats::TestStatSampler& distCreator); in addition to interface we also need:; Set the TestStatSampler (eg. ToyMC or FFT, includes choice of TestStatistic). {fTestStatSampler = &distCreator;}. void SetLeftSideTailFraction(Double_t leftSideFraction = 0.); fLeftSideTailFraction*fSize defines lower edge of acceptance region.; Unified limits use 0, central limits use 0.5,; for upper/lower limits it is 0/1 depends on sign of test statistic w.r.t. parameter. {fLeftSideFraction = leftSideFraction;}. void SetParameterPointsToTest(RooAbsData& pointsToTest); User-defined set of points to test. Double_t Size() const; This class can make regularly spaced scans based on range stored in RooRealVars.; Choose number of steps for a rastor scan (common for each dimension); void SetNumSteps(Int_t);; This class can make regularly spaced scans based on range stored in RooRealVars.; Choose number of steps for a rastor scan (specific for each dimension); void SetNumSteps(map<RooAbsArg, Int_t>); Get the size of the test (eg. rate of Type I error). {return fSize;}. Double_t ConfidenceLevel() const; Get the Confidence level for the test. {return 1.-fSize;}. void SetData(RooAbsData& data); Set the DataSet. { fData = &data; }. void SetPdf(RooAbsPdf& pdf); Set the Pdf, add to the the workspace if not already there. { 	fPdf = &pdf; }. void SetParameters(const RooArgSet& set); specify the parameters of interest in the interval. { fPOI.removeAll(); fPOI.add(set); }. void SetNuisanceParameters(const RooArgSet& set); specify the nuisance parameters (eg. the rest of the parameters). {fNuisParams.removeAll(); fNuisParams.add(set);}. void SetTestSize(Double_t size); set the size of the test (rate of Type I error) ( Eg. 0.05 for a 95% Confidence Interval). {fSize = size;}. void SetConfidenceLevel(Double_t cl); set the confidence level for the interval (eg. 0.95 for a 95% Confidence Interval). {fSize = 1.-cl;}. ConfidenceBelt* GetConfidenceBelt(); {",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooStats__NeymanConstruction.html:11608,test,test,11608,root/html526/RooStats__NeymanConstruction.html,https://root.cern,https://root.cern/root/html526/RooStats__NeymanConstruction.html,1,['test'],['test']
Testability,"lation_matrix"") constReturn TH2D of correlation matrix.Definition RooFitResult.cxx:1086; RooGaussianPlain Gaussian p.d.f.Definition RooGaussian.h:24; RooMCStudyHelper class to facilitate Monte Carlo studies such as 'goodness-of-fit' studies, that involve fittin...Definition RooMCStudy.h:32; RooMCStudy::plotPullRooPlot * plotPull(const RooRealVar &param, const RooCmdArg &arg1, const RooCmdArg &arg2={}, const RooCmdArg &arg3={}, const RooCmdArg &arg4={}, const RooCmdArg &arg5={}, const RooCmdArg &arg6={}, const RooCmdArg &arg7={}, const RooCmdArg &arg8={})Plot the distribution of pull values for the specified parameter on a newly created frame.Definition RooMCStudy.cxx:1087; RooMCStudy::fitResultconst RooFitResult * fitResult(Int_t sampleNum) constReturn the RooFitResult of the fit with the given run number.Definition RooMCStudy.cxx:831; RooMCStudy::plotNLLRooPlot * plotNLL(const RooCmdArg &arg1={}, const RooCmdArg &arg2={}, const RooCmdArg &arg3={}, const RooCmdArg &arg4={}, const RooCmdArg &arg5={}, const RooCmdArg &arg6={}, const RooCmdArg &arg7={}, const RooCmdArg &arg8={})Plot the distribution of the -log(L) values on a newly created frame.Definition RooMCStudy.cxx:962; RooMCStudy::fitParDataSetconst RooDataSet & fitParDataSet()Return a RooDataSet containing the post-fit parameters of each toy cycle.Definition RooMCStudy.cxx:793; RooMCStudy::generateAndFitbool generateAndFit(Int_t nSamples, Int_t nEvtPerSample=0, bool keepGenData=false, const char *asciiFilePat=nullptr)Generate and fit 'nSamples' samples of 'nEvtPerSample' events.Definition RooMCStudy.cxx:503; RooMCStudy::plotParamRooPlot * plotParam(const RooRealVar &param, const RooCmdArg &arg1={}, const RooCmdArg &arg2={}, const RooCmdArg &arg3={}, const RooCmdArg &arg4={}, const RooCmdArg &arg5={}, const RooCmdArg &arg6={}, const RooCmdArg &arg7={}, const RooCmdArg &arg8={})Plot the distribution of the fitted value of the given parameter on a newly created frame.Definition RooMCStudy.cxx:928; RooMCStudy::plot",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf801__mcstudy_8C.html:7627,log,log,7627,doc/master/rf801__mcstudy_8C.html,https://root.cern,https://root.cern/doc/master/rf801__mcstudy_8C.html,1,['log'],['log']
Testability,"lator type) and a RooRealVar for the variable. ~HypoTestInverterOriginal(); destructor. void CreateResults(); create a new HypoTestInverterResult to hold all computed results. bool RunAutoScan(double xMin, double xMax, double target, double epsilon = 0.0050000000000000001, unsigned int numAlgorithm = 0); Search for the value of the parameter of interest (vary the; hypothesis being tested) in the specified range [xMin,xMax]; until the confidence level is compatible with the target value; within one time the estimated error (and the estimated error; should also become smaller than the specified parameter epsilon). bool RunFixedScan(int nBins, double xMin, double xMax); Run a Fixed scan in npoints between min and max. bool RunOnePoint(double thisX); run only one point. HypoTestInverterOriginal(); default constructor (used only for I/O). HypoTestInverterResult* GetInterval() const; { return fResults; }. void UseCLs(bool on = true); { fUseCLs = on; if (fResults) fResults->UseCLs(on); }. void SetData(RooAbsData& ); { }. void SetModel(const RooStats::ModelConfig& ); { }. void SetTestSize(Double_t size); set the size of the test (rate of Type I error) ( Eg. 0.05 for a 95% Confidence Interval). {fSize = size; if (fResults) fResults->SetTestSize(size); }. void SetConfidenceLevel(Double_t cl); set the confidence level for the interval (eg. 0.95 for a 95% Confidence Interval). {fSize = 1.-cl; if (fResults) fResults->SetConfidenceLevel(cl); }. Double_t Size() const; Get the size of the test (eg. rate of Type I error). {return fSize;}. Double_t ConfidenceLevel() const; Get the Confidence level for the test. {return 1.-fSize;}.  Author: Kyle Cranmer, Lorenzo Moneta, Gregory Schott, Wouter Verkerke  Copyright (C) 1995-2008, Rene Brun and Fons Rademakers. *;  Last changed: root/roostats:$Id$  Last generated: 2015-06-02 15:35; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/RooStats__HypoTestInverterOriginal.html:10059,test,test,10059,root/html604/RooStats__HypoTestInverterOriginal.html,https://root.cern,https://root.cern/root/html604/RooStats__HypoTestInverterOriginal.html,3,['test'],['test']
Testability,"lator type) and a RooRealVar for the variable. ~HypoTestInverterOriginal(); destructor. void CreateResults(); create a new HypoTestInverterResult to hold all computed results. bool RunAutoScan(double xMin, double xMax, double target, double epsilon = 0.0050000000000000001, unsigned int numAlgorithm = 0); Search for the value of the parameter of interest (vary the; hypothesis being tested) in the specified range [xMin,xMax]; until the confidence level is compatible with the target value; within one time the estimated error (and the estimated error; should also become smaller than the specified parameter epsilon). bool RunFixedScan(int nBins, double xMin, double xMax); Run a Fixed scan in npoints between min and max. bool RunOnePoint(double thisX); run only one point. HypoTestInverterOriginal(); default constructor (used only for I/O). HypoTestInverterResult* GetInterval() const; { return fResults; }. void UseCLs(bool on = true); { fUseCLs = on; if (fResults) fResults->UseCLs(on); }. void SetData(RooAbsData& ); { }. void SetModel(const RooStats::ModelConfig& ); { }. void SetTestSize(Double_t size); set the size of the test (rate of Type I error) ( Eg. 0.05 for a 95% Confidence Interval). {fSize = size; if (fResults) fResults->SetTestSize(size); }. void SetConfidenceLevel(Double_t cl); set the confidence level for the interval (eg. 0.95 for a 95% Confidence Interval). {fSize = 1.-cl; if (fResults) fResults->SetConfidenceLevel(cl); }. Double_t Size() const; Get the size of the test (eg. rate of Type I error). {return fSize;}. Double_t ConfidenceLevel() const; Get the Confidence level for the test. {return 1.-fSize;}.  Author: Kyle Cranmer, Lorenzo Moneta, Gregory Schott, Wouter Verkerke  Copyright (C) 1995-2008, Rene Brun and Fons Rademakers. *;  Last changed: root/roostats:$Id$  Last generated: 2015-06-30 14:36; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooStats__HypoTestInverterOriginal.html:10059,test,test,10059,root/html602/RooStats__HypoTestInverterOriginal.html,https://root.cern,https://root.cern/root/html602/RooStats__HypoTestInverterOriginal.html,3,['test'],['test']
Testability,"lators and IntervalCalculators; RooStats::ConfInterval Interface for Confidence Intervals; RooStats::ConfidenceBelt A confidence belt for the Neyman Construction; RooStats::DebuggingSampler A simple implementation of the DistributionCreator interface; RooStats::DebuggingTestStat A concrete implementation of the TestStatistic interface, useful for debugging.; RooStats::FeldmanCousins Interface for tools setting limits (producing confidence intervals); RooStats::HybridCalculator Hypothesis test calculator using a Bayesian-frequentist hybrid method; RooStats::HybridPlot Provides the plots for an HybridResult; RooStats::HybridResult Class containing the results of the HybridCalculator; RooStats::HypoTestCalculator Interface for tools doing hypothesis tests; RooStats::HypoTestResult Base class to represent results of a hypothesis test; RooStats::IntervalCalculator Interface for tools setting limits (producing confidence intervals); RooStats::LikelihoodInterval Concrete implementation of a ConfInterval based on a likelihood ratio; RooStats::LikelihoodIntervalPlot Class containing the results of the IntervalCalculator; RooStats::MCMCCalculator Markov Chain Monte Carlo calculator for Bayesian credible intervals; RooStats::MCMCInterval Concrete implementation of a ConfInterval based on MCMC calculation; RooStats::ModelConfig A class that holds configuration information for a model using a workspace as a store; RooStats::NeymanConstruction Interface for tools setting limits (producing confidence intervals); RooStats::NumEventsTestStat ; RooStats::NumberCountingPdfFactory A factory specific to common number counting problems.; RooStats::NumberCountingUtils ; RooStats::PointSetInterval Concrete implementation of ConfInterval for simple 1-D intervals in the form [a,b]; RooStats::ProfileLikelihoodCalculator A concrete implementation of CombinedCalculator that uses the ProfileLikelihood ratio.; RooStats::ProfileLikelihoodTestStat implements the profile likelihood ratio as a test st",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html524/ClassIndex.html:42329,test,test,42329,root/html524/ClassIndex.html,https://root.cern,https://root.cern/root/html524/ClassIndex.html,3,['test'],"['test', 'tests']"
Testability,"layout, const char* weight, TTree* data, TEventList* training, TEventList* test, TNeuron::ENeuronType type = TNeuron::kSigmoid, const char* extF = """", const char* extD = """"); virtual~TMultiLayerPerceptron(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; voidComputeDEDw() const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; voidDrawResult(Int_t index = 0, Option_t* option = ""test"") const; virtual voidTObject::Dump() constMENU ; Bool_tDumpWeights(Option_t* filename = ""-"") const; virtual voidTObject::Error(const char* method, const char* msgfmt) const; Double_tEvaluate(Int_t index, Double_t* params) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); voidExport(Option_t* filename = ""NNfunction"", Option_t* language = ""C++"") const; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Double_tGetDelta() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Double_tGetEpsilon() const; Double_tGetError(Int_t event) const; Double_tGetError(TMultiLayerPerceptron::EDataSet set) const; Double_tGetE",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TMultiLayerPerceptron.html:10778,test,test,10778,root/html534/TMultiLayerPerceptron.html,https://root.cern,https://root.cern/root/html534/TMultiLayerPerceptron.html,1,['test'],['test']
Testability,"layout, const char* weight, TTree* data, TEventList* training, TEventList* test, TNeuron::ENeuronType type = TNeuron::kSigmoid, const char* extF = """", const char* extD = """"); virtual~TMultiLayerPerceptron(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; voidComputeDEDw() const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; voidDrawResult(Int_t index = 0, Option_t* option = ""test"") const; virtual voidTObject::Dump() constMENU ; voidDumpWeights(Option_t* filename = ""-"") const; virtual voidTObject::Error(const char* method, const char* msgfmt) const; Double_tEvaluate(Int_t index, Double_t* params) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); voidExport(Option_t* filename = ""NNfunction"", Option_t* language = ""C++"") const; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Double_tGetDelta() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Double_tGetEpsilon() const; Double_tGetError(Int_t event) const; Double_tGetError(TMultiLayerPerceptron::EDataSet set) const; Double_tGetEta",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMultiLayerPerceptron.html:10782,test,test,10782,root/html528/TMultiLayerPerceptron.html,https://root.cern,https://root.cern/root/html528/TMultiLayerPerceptron.html,3,['test'],['test']
Testability,"lbDist = 0, const char* outputfile = ""HypoTestInverterRebuiltDist.root""); rebuild the sampling distributions by; generating some toys and find for each of theam a new upper limit; Return the upper limit distribution and optionally also the pValue distributions for Cls, Clsb and Clbxs; as a TList for each scanned point; The method uses the present parameter value. It is user responsability to give the current parameters to rebuild the distributions; It returns a upper or lower limit distribution depending on the isUpper flag, however it computes also the lower limit distribution and it is saved in the; output file as an histogram. void SetFixedScan(int nBins, double xMin = 1, double xMax = -1, bool scanLog = false); set for a fixed scan in nbins. void SetAutoScan(); set auto scan (default). { SetFixedScan(0); }. void UseCLs(bool on = true); { fUseCLs = on; if (fResults) fResults->UseCLs(on); }. void SetModel(const RooStats::ModelConfig& ); { }. void SetTestSize(Double_t size); set the size of the test (rate of Type I error) ( Eg. 0.05 for a 95% Confidence Interval). {fSize = size; if (fResults) fResults->SetTestSize(size); }. void SetConfidenceLevel(Double_t cl); set the confidence level for the interval (eg. 0.95 for a 95% Confidence Interval). {fSize = 1.-cl; if (fResults) fResults->SetConfidenceLevel(cl); }. Double_t Size() const; Get the size of the test (eg. rate of Type I error). {return fSize;}. Double_t ConfidenceLevel() const; Get the Confidence level for the test. {return 1.-fSize;}. HypoTestCalculatorGeneric * GetHypoTestCalculator() const; retrieved a reference to the internally used HypoTestCalculator; it might be invalid when the class is deleted. { return fCalculator0; }. void SetVerbose(int level = 1); set verbose level (0,1,2). { fVerbose = level; }. void SetMaximumToys(int ntoys); set maximum number of toys. { fMaxToys = ntoys;}. void SetNumErr(double err); set numerical error in test statistic evaluation (default is zero). { fNumErr = err; }.  Auth",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooStats__HypoTestInverter.html:12033,test,test,12033,root/html534/RooStats__HypoTestInverter.html,https://root.cern,https://root.cern/root/html534/RooStats__HypoTestInverter.html,3,['test'],['test']
Testability,"lball_integral"",""CrystalBall function not defined at alpha=0"");; 111 return 0.;; 112 }; 113 bool useLog = (n == 1.0); ; 114 if (n<=0) MATH_WARN_MSG(""crystalball_integral"",""No physical meaning when n<=0"");; 115 ; 116 double z = (x-mean)/sigma;; 117 if (alpha < 0 ) z = -z;; 118 ; 119 double abs_alpha = std::abs(alpha);; 120 ; 121 //double D = *(1.+ROOT::Math::erf(abs_alpha/std::sqrt(2.)));; 122 //double N = 1./(sigma*(C+D));; 123 double intgaus = 0.;; 124 double intpow = 0.;; 125 ; 126 const double sqrtpiover2 = std::sqrt(M_PI/2.);; 127 const double sqrt2pi = std::sqrt( 2.*M_PI); ; 128 const double oneoversqrt2 = 1./sqrt(2.);; 129 if (z <= -abs_alpha); 130 {; 131 double A = std::pow(n/abs_alpha,n) * std::exp(-0.5 * alpha*alpha);; 132 double B = n/abs_alpha - abs_alpha;; 133 ; 134 if (!useLog) {; 135 double C = (n/abs_alpha) * (1./(n-1)) * std::exp(-alpha*alpha/2.);; 136 intpow = C - A /(n-1.) * std::pow(B-z,-n+1) ;; 137 }; 138 else {; 139 // for n=1 the primitive of 1/x is log(x); 140 intpow = -A * std::log( n / abs_alpha ) + A * std::log( B -z );; 141 }; 142 intgaus = sqrtpiover2*(1.+ROOT::Math::erf(abs_alpha*oneoversqrt2));; 143 }; 144 else; 145 {; 146 intgaus = ROOT::Math::gaussian_cdf_c(z, 1);; 147 intgaus *= sqrt2pi;; 148 intpow = 0; ; 149 }; 150 return sigma * (intgaus + intpow);; 151 }; 152 ; 153 ; 154 double exponential_cdf_c(double x, double lambda, double x0); 155 {; 156 if ((x-x0) < 0) return 1.0;; 157 else return std::exp(- lambda * (x-x0));; 158 }; 159 ; 160 ; 161 double exponential_cdf(double x, double lambda, double x0); 162 {; 163 if ((x-x0) < 0) return 0.0;; 164 else // use expm1 function to avoid errors at small x; 165 return - ROOT::Math::expm1( - lambda * (x-x0) ) ;; 166 }; 167 ; 168 ; 169 double fdistribution_cdf_c(double x, double n, double m, double x0); 170 {; 171 // f distribution is defined only for both n and m > 0; 172 if (n < 0 || m < 0) return std::numeric_limits<double>::quiet_NaN();; 173 ; 174 double z = m/(m + n*(x-x0));; 175 // fox z->",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/ProbFuncMathCore_8cxx_source.html:4642,log,log,4642,doc/master/ProbFuncMathCore_8cxx_source.html,https://root.cern,https://root.cern/doc/master/ProbFuncMathCore_8cxx_source.html,3,['log'],['log']
Testability,"lculated values of; // fitted amplitudes of 2D peaks, output parameters; double amp_err[MAX_NUMBER_OF_PEAKS2]; // amplitude errors of 2D peaks; bool fix_amp[MAX_NUMBER_OF_PEAKS2]; // logical vector which allows; // to fix appropriate amplitudes of 2D peaks (not fit).; // However they are present in the estimated functional; double amp_init_x1[MAX_NUMBER_OF_PEAKS2]; // initial values of 1D; // ridges amplitudes, input parameters; double amp_calc_x1[MAX_NUMBER_OF_PEAKS2]; // calculated values of; // fitted amplitudes of 1D ridges, output parameters; double amp_err_x1[MAX_NUMBER_OF_PEAKS2]; // amplitude errors of 1D ridges; bool fix_amp_x1[MAX_NUMBER_OF_PEAKS2]; // logical vector which alloes to fix; // appropriate amplitudes of 1D ridges (not fit).; // However they are present in the estimated functional; double amp_init_y1[MAX_NUMBER_OF_PEAKS2]; // initial values of 1D; // ridges amplitudes, input parameters; double amp_calc_y1[MAX_NUMBER_OF_PEAKS2]; // calculated values of; // fitted amplitudes of 1D ridges, output parameters; double amp_err_y1[MAX_NUMBER_OF_PEAKS2]; // amplitude errors of 1D ridges; bool fix_amp_y1[MAX_NUMBER_OF_PEAKS2]; // logical vector which allows to fix; // appropriate amplitudes of 1D ridges (not fit).; // However they are present in the estimated functional; double volume[MAX_NUMBER_OF_PEAKS1]; // calculated volumes of peaks; double volume_err[MAX_NUMBER_OF_PEAKS1]; // errors of peak volumes; double sigma_init_x; // sigma x parameter; double sigma_calc_x;; double sigma_err_x;; bool fix_sigma_x;; double sigma_init_y; // sigma y parameter; double sigma_calc_y;; double sigma_err_y;; bool fix_sigma_y;; double ro_init; // correlation coefficient; double ro_calc;; double ro_err;; bool fix_ro;; double txy_init; // t parameter for 2D peaks; double txy_calc;; double txy_err;; bool fix_txy;; double sxy_init; // s parameter for 2D peaks; double sxy_calc;; double sxy_err;; bool fix_sxy;; double tx_init; // t parameter for 1D ridges (x direction); double ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/guides/spectrum/Spectrum.html:49965,log,logical,49965,root/html534/guides/spectrum/Spectrum.html,https://root.cern,https://root.cern/root/html534/guides/spectrum/Spectrum.html,1,['log'],['logical']
Testability,"lculator. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  ROOSTATS;  RooStats::ProfileLikelihoodCalculator. class RooStats::ProfileLikelihoodCalculator: public RooStats::CombinedCalculator. ProfileLikelihoodCalculator is a concrete implementation of CombinedCalculator ; (the interface class for a tools which can produce both RooStats HypoTestResults and ConfIntervals). ; The tool uses the profile likelihood ratio as a test statistic, and assumes that Wilks' theorem is valid. ; Wilks' theorem states that -2* log (profile likelihood ratio) is asymptotically distributed as a chi^2 distribution ; with N-dof, where N is the number of degrees of freedom. Thus, p-values can be constructed and the profile likelihood ratio; can be used to construct a LikelihoodInterval.; (In the future, this class could be extended to use toy Monte Carlo to calibrate the distribution of the test statistic). Usage: It uses the interface of the CombinedCalculator, so that it can be configured by specifying:. a model common model (eg. a family of specific models which includes both the null and alternate),; a data set, ; a set of parameters of interest. The nuisance parameters will be all other parameters of the model ; a set of parameters of which specify the null hypothesis (including values and const/non-const status) . The interface allows one to pass the model, data, and parameters either directly or via a ModelConfig class.; The alternate hypothesis leaves the parameter free to take any value other than those specified by the null hypotesis. There is therefore no need to ; specify the alternate parameters. . After configuring the calculator, one only needs to ask GetHypoTest() (which will return a HypoTestResult pointer) or GetInterval() (which will return an ConfInterval pointer). The concrete implementations of this interf",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooStats__ProfileLikelihoodCalculator.html:1077,test,test,1077,root/html528/RooStats__ProfileLikelihoodCalculator.html,https://root.cern,https://root.cern/root/html528/RooStats__ProfileLikelihoodCalculator.html,1,['test'],['test']
Testability,"lculator. class RooStats::HypoTestCalculator. HypoTestCalculator is an interface class for a tools which produce RooStats HypoTestResults. ; The interface currently assumes that any hypothesis test calculator can be configured by specifying:. a model for the null,; a model for the alternate,; a data set, ; a set of parameters of which specify the null (including values and const/non-const status), and ; a set of parameters of which specify the alternate (including values and const/non-const status). The interface allows one to pass the model, data, and parameters via a workspace and then specify them with names.; The interface will be extended so that one does not need to use a workspace. After configuring the calculator, one only needs to ask GetHypoTest, which will return a HypoTestResult pointer. The concrete implementations of this interface should deal with the details of how the nuisance parameters are; dealt with (eg. integration vs. profiling) and which test-statistic is used (perhaps this should be added to the interface). The motivation for this interface is that we hope to be able to specify the problem in a common way for several concrete calculators. Function Members (Methods); This is an abstract class, constructors will not be documented.; Look at the header to check for available constructors.; public:. virtual~HypoTestCalculator(); static TClass*Class(); virtual RooStats::HypoTestResult*GetHypoTest() const; RooStats::HypoTestCalculatorHypoTestCalculator(); RooStats::HypoTestCalculatorHypoTestCalculator(const RooStats::HypoTestCalculator&); virtual TClass*IsA() const; RooStats::HypoTestCalculator&operator=(const RooStats::HypoTestCalculator&); virtual voidSetAlternateModel(const RooStats::ModelConfig& model); virtual voidSetCommonModel(const RooStats::ModelConfig& model); virtual voidSetData(RooAbsData& data); virtual voidSetNullModel(const RooStats::ModelConfig& model); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStrea",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooStats__HypoTestCalculator.html:1241,test,test-statistic,1241,root/html602/RooStats__HypoTestCalculator.html,https://root.cern,https://root.cern/root/html602/RooStats__HypoTestCalculator.html,2,['test'],['test-statistic']
Testability,"lculator. class RooStats::HypoTestCalculator. HypoTestCalculator is an interface class for a tools which produce RooStats HypoTestResults. ; The interface currently assumes that any hypothesis test calculator can be configured by specifying:. a model for the null,; a model for the alternate,; a data set, ; a set of parameters of which specify the null (including values and const/non-const status), and ; a set of parameters of which specify the alternate (including values and const/non-const status). The interface allows one to pass the model, data, and parameters via a workspace and then specify them with names.; The interface will be extended so that one does not need to use a workspace. After configuring the calculator, one only needs to ask GetHypoTest, which will return a HypoTestResult pointer. The concrete implementations of this interface should deal with the details of how the nuisance parameters are; dealt with (eg. integration vs. profiling) and which test-statistic is used (perhaps this should be added to the interface). The motivation for this interface is that we hope to be able to specify the problem in a common way for several concrete calculators. Function Members (Methods); This is an abstract class, constructors will not be documented.; Look at the header to check for available constructors.; public:. virtual~HypoTestCalculator(); static TClass*Class(); virtual RooStats::HypoTestResult*GetHypoTest() const; virtual TClass*IsA() const; RooStats::HypoTestCalculator&operator=(const RooStats::HypoTestCalculator&); virtual voidSetAlternateModel(const RooStats::ModelConfig& model); virtual voidSetCommonModel(const RooStats::ModelConfig& model); virtual voidSetData(RooAbsData& data); virtual voidSetNullModel(const RooStats::ModelConfig& model); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooStats__HypoTestCalculator.html:1239,test,test-statistic,1239,root/html528/RooStats__HypoTestCalculator.html,https://root.cern,https://root.cern/root/html528/RooStats__HypoTestCalculator.html,3,['test'],['test-statistic']
Testability,"lculator. class RooStats::HypoTestCalculator. HypoTestCalculator is an interface class for a tools which produce RooStats HypoTestResults. ; The interface currently assumes that any hypothesis test calculator can be configured by specifying:. a model for the null,; a model for the alternate,; a data set, ; a set of parameters of which specify the null (including values and const/non-const status), and ; a set of parameters of which specify the alternate (including values and const/non-const status). The interface allows one to pass the model, data, and parameters via a workspace and then specify them with names.; The interface will be extended so that one does not need to use a workspace. After configuring the calculator, one only needs to ask GetHypoTest, which will return a HypoTestResult pointer. The concrete implementations of this interface should deal with the details of how the nuisance parameters are; dealt with (eg. integration vs. profiling) and which test-statistic is used (perhaps this should be added to the interface). The motivation for this interface is that we hope to be able to specify the problem in a common way for several concrete calculators. Function Members (Methods); This is an abstract class, constructors will not be documented.; Look at the header to check for available constructors.; public:. virtual~HypoTestCalculator(); static TClass*Class(); virtual RooStats::HypoTestResult*GetHypoTest() const; virtual TClass*IsA() const; RooStats::HypoTestCalculator&operator=(const RooStats::HypoTestCalculator&); virtual voidSetAlternateModel(const RooStats::ModelConfig& model); virtual voidSetCommonModel(const RooStats::ModelConfig& model); virtual voidSetData(RooAbsData& data); virtual voidSetNullModel(const RooStats::ModelConfig& model); virtual voidShowMembers(TMemberInspector& insp, char* parent); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooStats__HypoTestCalculator.html:1239,test,test-statistic,1239,root/html526/RooStats__HypoTestCalculator.html,https://root.cern,https://root.cern/root/html526/RooStats__HypoTestCalculator.html,1,['test'],['test-statistic']
Testability,"lculator. class RooStats::HypoTestCalculator. HypoTestCalculator is an interface class for a tools which produce RooStats HypoTestResults. ; The interface currently assumes that any hypothesis test calculator can be configured by specifying:. a model for the null,; a model for the alternate,; a data set, ; a set of parameters of which specify the null (including values and const/non-const status), and ; a set of parameters of which specify the alternate (including values and const/non-const status). The interface allows one to pass the model, data, and parameters via a workspace and then specify them with names.; The interface will be extended so that one does not need to use a workspace. After configuring the calculator, one only needs to ask GetHypoTest, which will return a HypoTestResult pointer. The concrete implementations of this interface should deal with the details of how the nuisance parameters are; dealt with (eg. integration vs. profiling) and which test-statistic is used (perhaps this should be added to the interface). The motivation for this interface is that we hope to be able to specify the problem in a common way for several concrete calculators. Function Members (Methods); This is an abstract class, constructors will not be documented.; Look at the header to check for available constructors.; public:. virtual~HypoTestCalculator(); static TClass*Class(); virtual RooStats::HypoTestResult*GetHypoTest() const; virtual TClass*IsA() const; RooStats::HypoTestCalculator&operator=(const RooStats::HypoTestCalculator&); virtual voidSetAlternateModel(const RooStats::ModelConfig& model); virtual voidSetCommonModel(const RooStats::ModelConfig& model); virtual voidSetData(RooAbsData& data); virtual voidSetNullModel(const RooStats::ModelConfig& model); virtual voidShowMembers(TMemberInspector&); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Func",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooStats__HypoTestCalculator.html:1241,test,test-statistic,1241,root/html534/RooStats__HypoTestCalculator.html,https://root.cern,https://root.cern/root/html534/RooStats__HypoTestCalculator.html,1,['test'],['test-statistic']
Testability,"ld be added to the list of the options used to paint the histogram.; 2855 ; 2856 ; 2857\anchor HP29; 2858### Drawing using OpenGL; 2859 ; 2860 ; 2861The class `TGLHistPainter` allows to paint data set using the OpenGL 3D; 2862graphics library. The plotting options start with `GL` keyword.; 2863In addition, in order to inform canvases that OpenGL should be used to render; 28643D representations, the following option should be set:; 2865 ; 2866 gStyle->SetCanvasPreferGL(true);; 2867 ; 2868 ; 2869\anchor HP29a; 2870#### General information: plot types and supported options; 2871 ; 2872The following types of plots are provided:; 2873 ; 2874For lego plots the supported options are:; 2875 ; 2876| Option | Description |; 2877|----------|-------------------------------------------------------------------|; 2878| ""GLLEGO"" | Draw a lego plot. It works also for `TH2Poly`.|; 2879| ""GLLEGO2""| Bins with color levels.|; 2880| ""GLLEGO3""| Cylindrical bars.|; 2881 ; 2882 ; 2883 ; 2884Lego painter in cartesian supports logarithmic scales for X, Y, Z.; 2885In polar only Z axis can be logarithmic, in cylindrical only Y.; 2886 ; 2887For surface plots (`TF2` and `TH2`) the supported options are:; 2888 ; 2889| Option | Description |; 2890|-----------|------------------------------------------------------------------|; 2891| ""GLSURF"" | Draw a surface.|; 2892| ""GLSURF1"" | Surface with color levels|; 2893| ""GLSURF2"" | The same as ""GLSURF1"" but without polygon outlines.|; 2894| ""GLSURF3"" | Color level projection on top of plot (works only in cartesian coordinate system).|; 2895| ""GLSURF4"" | Same as ""GLSURF"" but without polygon outlines.|; 2896 ; 2897 ; 2898 ; 2899The surface painting in cartesian coordinates supports logarithmic scales along; 2900X, Y, Z axis. In polar coordinates only the Z axis can be logarithmic,; 2901in cylindrical coordinates only the Y axis.; 2902 ; 2903Additional options to SURF and LEGO - Coordinate systems:; 2904 ; 2905| Option | Description |; 2906|----------|-------",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/THistPainter_8cxx_source.html:114623,log,logarithmic,114623,doc/master/THistPainter_8cxx_source.html,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html,1,['log'],['logarithmic']
Testability,"ld not be provided at build time, otherwise the; drawing package will be loaded. There is also a list of specific rules :; positioned daughters should not extrude their mother or intersect with sisters; unless this is specified (see TGeoVolume::AddNodeOverlap()), the top volume; (containing all geometry tree) must be specified before closing the geometry; and must not be positioned - it represents the global reference frame. After; building the full geometry tree, the geometry must be closed; (see TGeoManager::CloseGeometry()). Voxelization can be redone per volume after; this process. Below is the general scheme of the manager class. /*. */. An interactive session. Provided that a geometry was successfully built and closed (for instance the; previous example $ROOTSYS/tutorials/geom/rootgeom.C ), the manager class will register; itself to ROOT and the logical/physical structures will become immediately browsable.; The ROOT browser will display starting from the geometry folder : the list of; transformations and media, the top volume and the top logical node. These last; two can be fully expanded, any intermediate volume/node in the browser being subject; of direct access context menu operations (right mouse button click). All user; utilities of classes TGeoManager, TGeoVolume and TGeoNode can be called via the; context menu. /*. */. --- Drawing the geometry. Any logical volume can be drawn via TGeoVolume::Draw() member function.; This can be direcly accessed from the context menu of the volume object; directly from the browser.; There are several drawing options that can be set with; TGeoManager::SetVisOption(Int_t opt) method :; opt=0 - only the content of the volume is drawn, N levels down (default N=3).; This is the default behavior. The number of levels to be drawn can be changed; via TGeoManager::SetVisLevel(Int_t level) method. /*. */. opt=1 - the final leaves (e.g. daughters with no containment) of the branch; starting from volume are drawn down to the curren",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoManager.html:7564,log,logical,7564,root/html528/TGeoManager.html,https://root.cern,https://root.cern/root/html528/TGeoManager.html,6,['log'],['logical']
Testability,"ld not use data computed distribution parameters, otherwise the test will be biased. The 1-sample KS test using data computed quantities is called Lilliefors test (see https://en.wikipedia.org/wiki/Lilliefors_test) . Definition at line 65 of file GoFTest.h. Public Types; enum EDistribution { ; kUndefined; , kUserDefined; , kGaussian; , kLogNormal; , ; kExponential. }; H0 distributions for using only with 1-sample tests. More...; ; enum ETestType { kAD; , kAD2s; , kKS; , kKS2s; }; Goodness of Fit test types for using with the class's unary functions as a shorthand for the in-built methods. More...; ; enum EUserDistribution { kCDF; , kPDF; }; User input distribution option. More...; . Public Member Functions; GoFTest (size_t sample1Size, const Double_t *sample1, size_t sample2Size, const Double_t *sample2); Constructor for 2-samples tests. ; ; GoFTest (size_t sampleSize, const Double_t *sample, const IGenFunction &dist, EUserDistribution userDist=kPDF, Double_t xmin=1, Double_t xmax=0); Constructor for 1-sample tests with a user specified distribution implementing the ROOT::Math::IGenFunction interface. ; ; template<class Dist > ; GoFTest (size_t sampleSize, const Double_t *sample, Dist &dist, EUserDistribution userDist=kPDF, Double_t xmin=1, Double_t xmax=0); Templated constructor for 1-sample tests with a user specified distribution as a functor object implementing double operator()(double x). ; ; GoFTest (size_t sampleSize, const Double_t *sample, EDistribution dist=kUndefined, const std::vector< double > &distParams={}); Constructor for 1-sample tests with a specified distribution. ; ; virtual~GoFTest (); ; Double_tAndersonDarling2SamplesTest (const Char_t *option=""p"") const; Anderson-Darling 2-Sample Test. ; ; voidAndersonDarling2SamplesTest (Double_t &pvalue, Double_t &testStat) const; Performs the Anderson-Darling 2-Sample Test. ; ; Double_tAndersonDarlingTest (const Char_t *option=""p"") const; Anderson-Darling 2-Sample Test. ;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1GoFTest.html:2309,test,tests,2309,doc/master/classROOT_1_1Math_1_1GoFTest.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1GoFTest.html,1,['test'],['tests']
Testability,"ldDensity. Function documentation; TUnfoldDensity(const TUnfoldDensity& ); empty constructor, for derived classes. ~TUnfoldDensity(void); clean up. TString GetOutputBinName(Int_t iBinX) const. TUnfoldDensity(const TUnfoldDensity& ). Double_t GetDensityFactor(TUnfoldDensity::EDensityMode densityMode, Int_t iBin) const. TUnfoldDensity(const TH2* hist_A, TUnfold::EHistMap histmap, TUnfold::ERegMode regmode = kRegModeCurvature, TUnfold::EConstraint constraint = kEConstraintArea, TUnfoldDensity::EDensityMode densityMode = kDensityModeBinWidthAndUser, const TUnfoldBinning* outputBins = 0, const TUnfoldBinning* inputBins = 0, const char* regularisationDistribution = 0, const char* regularisationAxisSteering = ""*[UOB]""). void RegularizeDistribution(TUnfold::ERegMode regmode, TUnfoldDensity::EDensityMode densityMode, const char* distribution, const char* axisSteering). Int_t ScanTau(Int_t nPoint, Double_t tauMin, Double_t tauMax, TSpline** scanResult, Int_t mode = kEScanTauRhoAvg, const char* distribution = 0, const char* projectionMode = 0, TGraph** lCurvePlot = 0, TSpline** logTauXPlot = 0, TSpline** logTauYPlot = 0). TH1 * GetOutput(const char* histogramName, const char* histogramTitle = 0, const char* distributionName = 0, const char* projectionMode = 0, Bool_t useAxisBinning = kTRUE) const. TH1 * GetFoldedOutput(const char* histogramName, const char* histogramTitle = 0, const char* distributionName = 0, const char* projectionMode = 0, Bool_t useAxisBinning = kTRUE, Bool_t addBgr = kFALSE) const. TH1 * GetInput(const char* histogramName, const char* histogramTitle = 0, const char* distributionName = 0, const char* projectionMode = 0, Bool_t useAxisBinning = kTRUE) const. TH1 * GetDeltaSysBackgroundScale(const char* bgrSource, const char* histogramName, const char* histogramTitle = 0, const char* distributionName = 0, const char* projectionMode = 0, Bool_t useAxisBinning = kTRUE). TH2 * GetEmatrixSysUncorr(const char* histogramName, const char* histogramTitle = 0, const c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TUnfoldDensity.html:24715,log,logTauXPlot,24715,root/html602/TUnfoldDensity.html,https://root.cern,https://root.cern/root/html602/TUnfoldDensity.html,4,['log'],"['logTauXPlot', 'logTauYPlot']"
Testability,"ldMemsize += oldBsize;; 7103 oldBaskets += 1+Int_t(totBytes/oldBsize);; 7104 Int_t nb = branch->GetListOfBranches()->GetEntries();; 7105 if (nb > 0) {; 7106 newBaskets += 1+Int_t(totBytes/oldBsize);; 7107 continue;; 7108 }; 7109 Double_t bsize = oldBsize*idealFactor*memFactor; //bsize can be very large !; 7110 if (bsize < 0) bsize = bmax;; 7111 if (bsize > bmax) bsize = bmax;; 7112 UInt_t newBsize = UInt_t(bsize);; 7113 if (pass) { // only on the second pass so that it doesn't interfere with scaling; 7114 // If there is an entry offset, it will be stored in the same buffer as the object data; hence,; 7115 // we must bump up the size of the branch to account for this extra footprint.; 7116 // If fAutoFlush is not set yet, let's assume that it is 'in the process of being set' to; 7117 // the value of GetEntries().; 7118 Long64_t clusterSize = (fAutoFlush > 0) ? fAutoFlush : branch->GetEntries();; 7119 if (branch->GetEntryOffsetLen()) {; 7120 newBsize = newBsize + (clusterSize * sizeof(Int_t) * 2);; 7121 }; 7122 // We used ATLAS fully-split xAOD for testing, which is a rather unbalanced TTree, 10K branches,; 7123 // with 8K having baskets smaller than 512 bytes. To achieve good I/O performance ATLAS uses auto-flush 100,; 7124 // resulting in the smallest baskets being ~300-400 bytes, so this change increases their memory by about 8k*150B =~ 1MB,; 7125 // at the same time it significantly reduces the number of total baskets because it ensures that all 100 entries can be; 7126 // stored in a single basket (the old optimization tended to make baskets too small). In a toy example with fixed sized; 7127 // structures we found a factor of 2 fewer baskets needed in the new scheme.; 7128 // rounds up, increases basket size to ensure all entries fit into single basket as intended; 7129 newBsize = newBsize - newBsize%512 + 512;; 7130 }; 7131 if (newBsize < sizeOfOneEntry) newBsize = sizeOfOneEntry;; 7132 if (newBsize < bmin) newBsize = bmin;; 7133 if (newBsize > 10000000) newBsi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTree_8cxx_source.html:279020,test,testing,279020,doc/master/TTree_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html,1,['test'],['testing']
Testability,"ldNetwork(); Instanciates the network from the description. void BuildFirstLayer(TString& ); Instanciates the neurons in input; Inputs are normalised and the type is set to kOff; (simple forward of the formula value). void BuildHiddenLayers(TString& ); Builds hidden layers. void BuildOneHiddenLayer(const TString& sNumNodes, Int_t& layer, Int_t& prevStart, Int_t& prevStop, Bool_t lastLayer); Builds a hidden layer, updates the number of layers. void BuildLastLayer(TString& , Int_t ); Builds the output layer; Neurons are linear combinations of input, by defaul.; If the structure ends with ""!"", neurons are set up for classification,; ie. with a sigmoid (1 neuron) or softmax (more neurons) activation function. void DrawResult(Int_t index = 0, Option_t* option = ""test"") const; Draws the neural net output; It produces an histogram with the output for the two datasets.; Index is the number of the desired output neuron.; ""option"" can contain:; - test or train to select a dataset; - comp to produce a X-Y comparison plot; - nocanv to not create a new TCanvas for the plot. Bool_t DumpWeights(Option_t* filename = ""-"") const; Dumps the weights to a text file.; Set filename to ""-"" (default) to dump to the standard output. Bool_t LoadWeights(Option_t* filename = """"); Loads the weights from a text file conforming to the format; defined by DumpWeights. Double_t Evaluate(Int_t index, Double_t* params) const; Returns the Neural Net for a given set of input parameters; #parameters must equal #input neurons. void Export(Option_t* filename = ""NNfunction"", Option_t* language = ""C++"") const; Exports the NN as a function for any non-ROOT-dependant code; Supported languages are: only C++ , FORTRAN and Python (yet); This feature is also usefull if you want to plot the NN as; a function (TF1 or TF2). void Shuffle(Int_t* , Int_t ) const; Shuffle the Int_t index[n] in input.; Input:; index: the array to shuffle; n: the size of the array; Output:; index: the shuffled indexes; This method is used fo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TMultiLayerPerceptron.html:27553,test,test,27553,root/html534/TMultiLayerPerceptron.html,https://root.cern,https://root.cern/root/html534/TMultiLayerPerceptron.html,3,['test'],['test']
Testability,"ldNetwork(); Instanciates the network from the description. void BuildFirstLayer(TString& ); Instanciates the neurons in input; Inputs are normalised and the type is set to kOff; (simple forward of the formula value). void BuildHiddenLayers(TString& ); Builds hidden layers. void BuildOneHiddenLayer(const TString& sNumNodes, Int_t& layer, Int_t& prevStart, Int_t& prevStop, Bool_t lastLayer); Builds a hidden layer, updates the number of layers. void BuildLastLayer(TString& , Int_t ); Builds the output layer; Neurons are linear combinations of input, by defaul.; If the structure ends with ""!"", neurons are set up for classification,; ie. with a sigmoid (1 neuron) or softmax (more neurons) activation function. void DrawResult(Int_t index = 0, Option_t* option = ""test"") const; Draws the neural net output; It produces an histogram with the output for the two datasets.; Index is the number of the desired output neuron.; ""option"" can contain:; - test or train to select a dataset; - comp to produce a X-Y comparison plot; - nocanv to not create a new TCanvas for the plot. void DumpWeights(Option_t* filename = ""-"") const; Dumps the weights to a text file.; Set filename to ""-"" (default) to dump to the standard output. void LoadWeights(Option_t* filename = """"); Loads the weights from a text file conforming to the format; defined by DumpWeights. Double_t Evaluate(Int_t index, Double_t* params) const; Returns the Neural Net for a given set of input parameters; #parameters must equal #input neurons. void Export(Option_t* filename = ""NNfunction"", Option_t* language = ""C++"") const; Exports the NN as a function for any non-ROOT-dependant code; Supported languages are: only C++ , FORTRAN and Python (yet); This feature is also usefull if you want to plot the NN as; a function (TF1 or TF2). void Shuffle(Int_t* , Int_t ) const; Shuffle the Int_t index[n] in input.; Input:; index: the array to shuffle; n: the size of the array; Output:; index: the shuffled indexes; This method is used for st",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMultiLayerPerceptron.html:27465,test,test,27465,root/html528/TMultiLayerPerceptron.html,https://root.cern,https://root.cern/root/html528/TMultiLayerPerceptron.html,3,['test'],['test']
Testability,"lding ROOT . ; Tutorials . ; Javascript Root . ; ROOT and Spark . ; Publications . ; FAQ . ; News . ; Blog . ; Workshops . ; Support . ; Forum . ; Bug submission guidelines . ; Submit a Bug . ; RootTalk Digest . ; Discourse Mailing List Mode . ; About . ; Licence . ; Contact Us . ; Project Founders . ; Team . ; Previous Developers . ; Development . ; Program of Work . ; Code Owners . ; Release Checklist . ; Coding Conventions . ; Shifter's Instructions . ; Git Primer . ; Creating a Pull Request . ; Github ssh key . ; Git Tips and Tricks . ; Git How Tos . ; A suggested work flow for distributed projects: NoSY . ; Browse Sources . ; Meetings . ; ROOT 7 . ; Run the tests . ; Setup externals from AFS/CVMFS . ; Jenkins . ; Doxygen . ; Benchmarks . ; Contribute . ; Collaborate with Us . You are hereHome  Documentation Tutorials. ROOT offers a rich set of code examples that allow you to see ROOT's building blocks ""in action"", as part of more complex programs. They are separated in two categories: C++ or python scripts and Jupyter notebooks.; The tutorials are available for all major ROOT releases. These are the links for the latest git snapshot. All scripts are available also in the form of a ROOTBook which can be visualized in NBViewer or tried out interactively in SWAN. Just look for these badges:. Sitemap. DownloadDownload ROOT; All Releases. DocumentationReference Manual; User's Guides; HowTo; Courses; Building ROOT; Tutorials; Javascript Root; ROOT and Spark; Publications; FAQ. NewsBlog; Workshops. SupportForum; Bug submission guidelines; Submit a Bug; Discourse Mailing List Mode; RootTalk Digest. AboutLicence; Contact Us; Project Founders; Team; Previous Developers. DevelopmentProgram of Work; Code Owners; Release Checklist; Coding Conventions; Shifter's Instructions; Git Primer; Browse Sources; Meetings; ROOT 7; Run the tests; Jenkins; Setup externals from AFS/CVMFS; Doxygen; Benchmarks. ContributeCollaborate with Us.  Copyright CERN 2014-18. All rights reserved. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/tutorials.html:2888,test,tests,2888,d/tutorials.html,https://root.cern,https://root.cern/d/tutorials.html,1,['test'],['tests']
Testability,"le (400 events); : Elapsed time for evaluation of 400 events: 0.12 sec ; Factory : [1mEvaluate all methods[0m; Factory : Evaluate classifier: BDT; : ; BDT : [dataset] : Loop over test events and fill histograms with classifier response...; : ; : Dataset[dataset] : variable plots are not produces ! The number of variables is 256 , it is larger than 200; Factory : Evaluate classifier: TMVA_DNN_CPU; : ; TMVA_DNN_CPU : [dataset] : Loop over test events and fill histograms with classifier response...; : ; : Evaluate deep neural network on CPU using batches with size = 1000; : ; : Dataset[dataset] : variable plots are not produces ! The number of variables is 256 , it is larger than 200; Factory : Evaluate classifier: TMVA_CNN_CPU; : ; TMVA_CNN_CPU : [dataset] : Loop over test events and fill histograms with classifier response...; : ; : Evaluate deep neural network on CPU using batches with size = 1000; : ; : Dataset[dataset] : variable plots are not produces ! The number of variables is 256 , it is larger than 200; Factory : Evaluate classifier: PyKeras; : ; PyKeras : [dataset] : Loop over test events and fill histograms with classifier response...; : ; : Dataset[dataset] : variable plots are not produces ! The number of variables is 256 , it is larger than 200; Factory : Evaluate classifier: PyTorch; : ; PyTorch : [dataset] : Loop over test events and fill histograms with classifier response...; : ; : Dataset[dataset] : variable plots are not produces ! The number of variables is 256 , it is larger than 200; : ; : Evaluation results ranked by best signal efficiency and purity (area); : -------------------------------------------------------------------------------------------------------------------; : DataSet MVA ; : Name: Method: ROC-integ; : dataset PyTorch : 0.790; : dataset TMVA_CNN_CPU : 0.751; : dataset BDT : 0.750; : dataset TMVA_DNN_CPU : 0.688; : dataset PyKeras : 0.666; : -------------------------------------------------------------------------------------",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVA__CNN__Classification_8C.html:42513,test,test,42513,doc/master/TMVA__CNN__Classification_8C.html,https://root.cern,https://root.cern/doc/master/TMVA__CNN__Classification_8C.html,1,['test'],['test']
Testability,"le *) ; ; TF2 (const TF2 &f2); Copy constructor. ; ; ~TF2 () override; F2 default destructor. ; ; virtual Double_tCentralMoment2 (Double_t nx, Double_t ax, Double_t bx, Double_t ny, Double_t ay, Double_t by, Double_t epsilon=0.000001); Return x^nx * y^ny central moment of a 2d function in range [ax,bx],[ay,by]. ; ; virtual Double_tCovariance2XY (Double_t ax, Double_t bx, Double_t ay, Double_t by, Double_t epsilon=0.000001); ; TF1 *DrawCopy (Option_t *option="""") const override; Draw a copy of this function with its current attributes-*. ; ; virtual Int_tGetContour (Double_t *levels=nullptr); Return contour values into array levels. ; ; virtual Double_tGetContourLevel (Int_t level) const; Return the number of contour levels. ; ; virtual Double_tGetMaximum (Double_t *x) const; Return maximum value of the function See TF2::GetMinimum. ; ; virtual Double_tGetMaximum (Double_t xmin=0, Double_t xmax=0, Double_t epsilon=1.E-10, Int_t maxiter=100, Bool_t logx=false) const; Returns the maximum value of the function. ; ; virtual Double_tGetMaximumXY (Double_t &x, Double_t &y) const; Compute the X and Y values corresponding to the maximum value of the function. ; ; virtual Double_tGetMinimum (Double_t *x) const; Return minimum/maximum value of the function. ; ; virtual Double_tGetMinimum (Double_t xmin=0, Double_t xmax=0, Double_t epsilon=1.E-10, Int_t maxiter=100, Bool_t logx=false) const; Returns the minimum value of the function on the (xmin, xmax) interval. ; ; virtual Double_tGetMinimumXY (Double_t &x, Double_t &y) const; Compute the X and Y values corresponding to the minimum value of the function. ; ; Int_tGetNpy () const; ; char *GetObjectInfo (Int_t px, Int_t py) const override; Redefines TObject::GetObjectInfo. ; ; Double_tGetRandom (Double_t xmin, Double_t xmax, TRandom *rng=nullptr, Option_t *opt=nullptr) override; Return a random number following this function shape. ; ; Double_tGetRandom (TRandom *rng=nullptr, Option",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTF3.html:11819,log,logx,11819,doc/master/classTF3.html,https://root.cern,https://root.cern/doc/master/classTF3.html,1,['log'],['logx']
Testability,"le *hprof = nullptr;; T->SetBranchAddress(""hpx"",&hpx);; T->SetBranchAddress(""hpxpy"",&hpxpy);; T->SetBranchAddress(""hprof"",&hprof);; T->GetEntry(12345);; auto c1 = new TCanvas(""c1"",""test"",10,10,600,1000);; c1->Divide(1,3);; c1->cd(1);; hpx->Draw();; c1->cd(2);; hpxpy->Draw();; c1->cd(3);; hprof->Draw();; c1->Print(""htr1.png"");; }; ; void htr2() {; // Connect Tree generated by htw and show histograms for entry 12345; // a variant of htr1; auto f = new TFile(""ht.root"");; auto T = (TTree*)f->Get(""T"");; auto c1 = new TCanvas(""c1"",""test"",10,10,600,1000);; c1->Divide(1,3);; c1->cd(1);; T->Draw(""hpx.Draw()"","""",""goff"",1,12345);; c1->cd(2);; T->Draw(""hpxpy.Draw()"","""",""goff"",1,12345);; c1->cd(3);; T->Draw(""hprof.Draw()"","""",""goff"",1,12345);; c1->Print(""htr2.png"");; }; ; void htr3() {; // Connect Tree generated by htw; // read all histograms and plot the RMS of hpx versus the Mean of hprof; // for each of the 25000 entries; auto f = new TFile(""ht.root"");; auto T = (TTree*)f->Get(""T"");; auto c1 = new TCanvas(""c1"",""test"",10,10,600,400);; T->Draw(""hpx.GetRMS():hprof.GetMean()"");; c1->Print(""htr3.png"");; }; ; void htest() {; htw();; htr1();; htr2();; htr3();; }; f#define f(i)Definition RSha256.hxx:104; Int_tint Int_tDefinition RtypesCore.h:45; Float_tfloat Float_tDefinition RtypesCore.h:57; gBenchmarkR__EXTERN TBenchmark * gBenchmarkDefinition TBenchmark.h:59; gRandomR__EXTERN TRandom * gRandomDefinition TRandom.h:62; TBenchmark::Startvirtual void Start(const char *name)Starts Benchmark with the specified name.Definition TBenchmark.cxx:172; TBenchmark::Showvirtual void Show(const char *name)Stops Benchmark name and Prints results.Definition TBenchmark.cxx:155; TCanvasThe Canvas class.Definition TCanvas.h:23; TFileA ROOT file is an on-disk file, usually with extension .root, that stores objects in a file-system-li...Definition TFile.h:53; TH1F1-D histogram with a float per channel (see TH1 documentation)Definition TH1.h:622; TH1::Drawvoid Draw(Option_t *option="""") overrideDraw this h",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/htest_8C.html:2484,test,test,2484,doc/master/htest_8C.html,https://root.cern,https://root.cern/doc/master/htest_8C.html,1,['test'],['test']
Testability,"le > &globalCC, const TMatrixDSym &corrs, const TMatrixDSym &covs); Function called by RooMinimizer. ; ; const RooArgList &floatParsFinal () const; Return list of floating parameters after fit. ; ; const RooArgList &floatParsInit () const; Return list of floating parameters before fit. ; ; const RooArgList *globalCorr (); Return the list of all global correlations. ; ; doubleglobalCorr (const char *parname); Return the global correlation of the named parameter. ; ; doubleglobalCorr (const RooAbsArg &par); ; TClass *IsA () const override; ; boolisIdentical (const RooFitResult &other, double tol=1e-6, double tolCorr=1e-4, bool verbose=true) const; Return true if this fit result is identical to other within tolerances. ; ; boolisIdenticalNoCov (const RooFitResult &other, double tol=1e-6, double tolErr=1e-3, bool verbose=true) const; Return true if this fit result is identical to other within tolerances, ignoring the correlation matrix. ; ; doubleminNll () const; Return minimized -log(L) value. ; ; Int_tnumInvalidNLL () const; Return number of NLL evaluations with problems. ; ; UInt_tnumStatusHistory () const; ; RooPlot *plotOn (RooPlot *frame, const RooAbsArg &par1, const RooAbsArg &par2, const char *options=""ME"") const; Add objects to a 2D plot. ; ; RooPlot *plotOn (RooPlot *plot, const char *parName1, const char *parName2, const char *options=""ME"") const; Add objects to a 2D plot that represent the fit results for the two named parameters. ; ; voidPrint (Option_t *options=nullptr) const override; This method must be overridden when a class wants to print itself. ; ; voidprintArgs (std::ostream &os) const override; Print arguments of fit result, i.e. the parameters of the fit. ; ; voidprintClassName (std::ostream &os) const override; Print class name of fit result. ; ; voidprintMultiline (std::ostream &os, Int_t contents, bool verbose=false, TString indent="""") const override; Print fit result to stream 'os'. ; ; voidp",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooFitResult.html:3818,log,log,3818,doc/master/classRooFitResult.html,https://root.cern,https://root.cern/doc/master/classRooFitResult.html,1,['log'],['log']
Testability,"le Size = 34493 *; *Baskets : 1 : Basket Size= 1500672 bytes Compression= 1.16 *; *............................................................................*; *Br 28 :m_wwbb : m_wwbb/F *; *Entries : 10000 : Total Size= 40566 bytes File Size = 34410 *; *Baskets : 1 : Basket Size= 1500672 bytes Compression= 1.16 *; *............................................................................*; DataSetInfo : [dataset] : Added class ""Signal""; : Add Tree sig_tree of type Signal with 10000 events; DataSetInfo : [dataset] : Added class ""Background""; : Add Tree bkg_tree of type Background with 10000 events; Factory : Booking method: [1mLikelihood[0m; : ; Factory : Booking method: [1mFisher[0m; : ; Factory : Booking method: [1mBDT[0m; : ; : Rebuilding Dataset dataset; : Building event vectors for type 2 Signal; : Dataset[dataset] : create input formulas for tree sig_tree; : Building event vectors for type 2 Background; : Dataset[dataset] : create input formulas for tree bkg_tree; DataSetFactory : [dataset] : Number of events in input trees; : ; : ; : Number of training and testing events; : ---------------------------------------------------------------------------; : Signal -- training events : 7000; : Signal -- testing events : 3000; : Signal -- training and testing events: 10000; : Background -- training events : 7000; : Background -- testing events : 3000; : Background -- training and testing events: 10000; : ; DataSetInfo : Correlation matrix (Signal):; : ----------------------------------------------------------------; : m_jj m_jjj m_lv m_jlv m_bb m_wbb m_wwbb; : m_jj: +1.000 +0.774 -0.004 +0.096 +0.024 +0.512 +0.533; : m_jjj: +0.774 +1.000 -0.010 +0.073 +0.152 +0.674 +0.668; : m_lv: -0.004 -0.010 +1.000 +0.121 -0.027 +0.009 +0.021; : m_jlv: +0.096 +0.073 +0.121 +1.000 +0.313 +0.544 +0.552; : m_bb: +0.024 +0.152 -0.027 +0.313 +1.000 +0.445 +0.333; : m_wbb: +0.512 +0.674 +0.009 +0.544 +0.445 +1.000 +0.915; : m_wwbb: +0.533 +0.668 +0.021 +0.552 +0.333 +0.915 +1.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVA__Higgs__Classification_8C.html:8524,test,testing,8524,doc/master/TMVA__Higgs__Classification_8C.html,https://root.cern,https://root.cern/doc/master/TMVA__Higgs__Classification_8C.html,10,['test'],['testing']
Testability,"le TGLOrthoCamera.h. Constructor & Destructor Documentation. TGLOrthoCamera() [1/2]. TGLOrthoCamera::TGLOrthoCamera ; (; ). Construct kXOY orthographic camera. ; Definition at line 38 of file TGLOrthoCamera.cxx. TGLOrthoCamera() [2/2]. TGLOrthoCamera::TGLOrthoCamera ; (; EType; type, . const TGLVector3 &; hAxis, . const TGLVector3 &; vAxis. ). Construct orthographic camera. ; Definition at line 52 of file TGLOrthoCamera.cxx. ~TGLOrthoCamera(). TGLOrthoCamera::~TGLOrthoCamera ; (; ). override . Destroy orthographic camera. ; Definition at line 66 of file TGLOrthoCamera.cxx. Member Function Documentation. Apply(). void TGLOrthoCamera::Apply ; (; const TGLBoundingBox &; sceneBox, . const TGLRect *; pickRect = nullptr. ); const. overridevirtual . Apply the camera to the current GL context, setting the viewport, projection and modelview matrices. ; After this vertices etc can be directly entered in the world frame. This also updates the cached frustum values, enabling all the projection, overlap tests etc defined in TGLCamera to be used.; Arguments are:; 'box' - view volume box - ignored for ortho camera. Assumed to be same as one passed to Setup().; 'pickRect' - optional picking rect. If non-null, restrict drawing to this viewport rect. . Implements TGLCamera.; Definition at line 246 of file TGLOrthoCamera.cxx. Class(). static TClass * TGLOrthoCamera::Class ; (; ). static . ReturnsTClass describing this class . Class_Name(). static const char * TGLOrthoCamera::Class_Name ; (; ). static . ReturnsName of this class . Class_Version(). static constexpr Version_t TGLOrthoCamera::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 95 of file TGLOrthoCamera.h. Configure(). void TGLOrthoCamera::Configure ; (; Double_t; zoom, . Double_t; dolly, . Double_t; center[3], . Double_t; hRotate, . Double_t; vRotate. ). overridevirtual . Configure the camera state. . zoom - set directly (default = 0.78);; dolly - add",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGLOrthoCamera.html:22147,test,tests,22147,doc/master/classTGLOrthoCamera.html,https://root.cern,https://root.cern/doc/master/classTGLOrthoCamera.html,1,['test'],['tests']
Testability,"le alpha, double n, double sigma, double mean=0); pdf definition of the crystal_ball which is defined only for n > 1 otherwise integral is diverging ; ; doubleexponential_pdf (double x, double lambda, double x0=0); Probability density function of the exponential distribution. ; ; doublefdistribution_pdf (double x, double n, double m, double x0=0); Probability density function of the F-distribution. ; ; doublegamma_pdf (double x, double alpha, double theta, double x0=0); Probability density function of the gamma distribution. ; ; doublegaussian_pdf (double x, double sigma=1, double x0=0); Probability density function of the normal (Gaussian) distribution. ; ; doublebigaussian_pdf (double x, double y, double sigmax=1, double sigmay=1, double rho=0, double x0=0, double y0=0); Probability density function of the bi-dimensional (Gaussian) distribution. ; ; doublelandau_pdf (double x, double xi=1, double x0=0); Probability density function of the Landau distribution: ; ; doublelognormal_pdf (double x, double m, double s, double x0=0); Probability density function of the lognormal distribution. ; ; doublenormal_pdf (double x, double sigma=1, double x0=0); Probability density function of the normal (Gaussian) distribution. ; ; doublepoisson_pdf (unsigned int n, double mu); Probability density function of the Poisson distribution. ; ; doubletdistribution_pdf (double x, double r, double x0=0); Probability density function of Student's t-distribution. ; ; doubleuniform_pdf (double x, double a, double b, double x0=0); Probability density function of the uniform (flat) distribution. ; ; Quantile Functions from MathCore; The implementation is provided in MathCore and for the majority of the function comes from Cephes. . doublebeta_quantile (double x, double a, double b); Inverse ( \(D^{-1}(z)\)) of the cumulative distribution function of the upper tail of the beta distribution (beta_cdf_c). ; ; doublebeta_quantile_c (double x, double a, doubl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/namespaceROOT_1_1Math.html:104550,log,lognormal,104550,doc/master/namespaceROOT_1_1Math.html,https://root.cern,https://root.cern/doc/master/namespaceROOT_1_1Math.html,2,['log'],['lognormal']
Testability,"le el = fDataErrorLowPtr[ ipoint ];; 299 ; 300 return (el+eh) / 2.0;; 301 }; 302 ; 303 assert( fErrorType == kCoordError );; 304 return fDataErrorPtr[ ipoint ];; 305 }; 306 ; 307 void GetAsymError( unsigned int ipoint, double& lowError, double& highError ) const; 308 {; 309 assert( fErrorType == kAsymError );; 310 assert( !fDataErrorPtr && fDataErrorHighPtr && fDataErrorLowPtr );; 311 assert( fDataError.empty() );; 312 assert( fDataErrorHigh.empty() || &fDataErrorHigh.front() == fDataErrorHighPtr );; 313 assert( fDataErrorLow.empty() || &fDataErrorLow.front() == fDataErrorLowPtr );; 314 assert( fDataErrorLow.empty() == fDataErrorHigh.empty() );; 315 ; 316 lowError = fDataErrorLowPtr[ ipoint ];; 317 highError = fDataErrorHighPtr[ ipoint ];; 318 }; 319 ; 320 /**; 321 Return the inverse of error on the value for the given fit point; 322 useful when error in the coordinates are not stored and then this is used directly this as the weight in; 323 the least square function; 324 */; 325 double InvError( unsigned int ipoint ) const; 326 {; 327 assert( ipoint < fMaxPoints );; 328 assert( kValueError == fErrorType || kCoordError == fErrorType ||; 329 kAsymError == fErrorType || kNoError == fErrorType );; 330 ; 331 if ( fErrorType == kNoError ); 332 {; 333 assert( !fDataErrorPtr && !fDataErrorHighPtr && !fDataErrorLowPtr );; 334 assert( fDataError.empty() && fDataErrorHigh.empty() && fDataErrorLow.empty() );; 335 return 1.0;; 336 }; 337 ; 338 if ( fErrorType == kValueError ) // need to invert (inverror is stored); 339 {; 340 assert( fDataErrorPtr && !fDataErrorHighPtr && !fDataErrorLowPtr );; 341 assert( fDataErrorHigh.empty() && fDataErrorLow.empty() );; 342 assert( fDataError.empty() || &fDataError.front() == fDataErrorPtr );; 343 ; 344 double eval = fDataErrorPtr[ ipoint ];; 345 ; 346 // in case of wrapped data the pointer stores the error and; 347 // not the inverse; 348 if (fWrapped); 349 return 1.0 / eval;; 350 else; 351 return (eval != 0.0) ? eval : 0.0;; 352 }; 353 ; 35",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/BinData_8h_source.html:11385,assert,assert,11385,doc/master/BinData_8h_source.html,https://root.cern,https://root.cern/doc/master/BinData_8h_source.html,4,['assert'],['assert']
Testability,"le example on how to use the trained multiclass; 5/// classifiers within an analysis module; 6/// - Project : TMVA - a Root-integrated toolkit for multivariate data analysis; 7/// - Package : TMVA; 8/// - Root Macro: TMVAMulticlassApplication; 9///; 10/// \macro_output; 11/// \macro_code; 12/// \author Andreas Hoecker; 13 ; 14 ; 15#include <cstdlib>; 16#include <iostream>; 17#include <map>; 18#include <string>; 19#include <vector>; 20 ; 21#include ""TFile.h""; 22#include ""TTree.h""; 23#include ""TString.h""; 24#include ""TSystem.h""; 25#include ""TROOT.h""; 26#include ""TStopwatch.h""; 27#include ""TH1F.h""; 28 ; 29#include ""TMVA/Tools.h""; 30#include ""TMVA/Reader.h""; 31 ; 32using namespace TMVA;; 33 ; 34void TMVAMulticlassApplication( TString myMethodList = """" ); 35{; 36 ; 37 TMVA::Tools::Instance();; 38 ; 39 //---------------------------------------------------------------; 40 // Default MVA methods to be trained + tested; 41 std::map<std::string,int> Use;; 42 Use[""MLP""] = 1;; 43 Use[""BDTG""] = 1;; 44 Use[""DL_CPU""] = 1;; 45 Use[""DL_GPU""] = 1;; 46 Use[""FDA_GA""] = 1;; 47 Use[""PDEFoam""] = 1;; 48 //---------------------------------------------------------------; 49 ; 50 std::cout << std::endl;; 51 std::cout << ""==> Start TMVAMulticlassApp"" << std::endl;; 52 if (myMethodList != """") {; 53 for (std::map<std::string,int>::iterator it = Use.begin(); it != Use.end(); it++) it->second = 0;; 54 ; 55 std::vector<TString> mlist = gTools().SplitString( myMethodList, ',' );; 56 for (UInt_t i=0; i<mlist.size(); i++) {; 57 std::string regMethod(mlist[i]);; 58 ; 59 if (Use.find(regMethod) == Use.end()) {; 60 std::cout << ""Method \"""" << regMethod << ""\"" not known in TMVA under this name. Choose among the following:"" << std::endl;; 61 for (std::map<std::string,int>::iterator it = Use.begin(); it != Use.end(); it++) std::cout << it->first << "" "" << std::endl;; 62 std::cout << std::endl;; 63 return;; 64 }; 65 Use[regMethod] = 1;; 66 }; 67 }; 68 ; 69 ; 70 // create the Reader object; 71 TMVA::Reader *r",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVAMulticlassApplication_8C_source.html:1225,test,tested,1225,doc/master/TMVAMulticlassApplication_8C_source.html,https://root.cern,https://root.cern/doc/master/TMVAMulticlassApplication_8C_source.html,1,['test'],['tested']
Testability,"le is requested but maximum is less or equal 0 (%f)"", xmax);; 7430 return 0;; 7431 }; 7432 }; 7433 else {; 7434 if (xmin > 0) {; 7435 xmin = 0;; 7436 xmax *= 2;; 7437 } else if (xmin < 0) {; 7438 xmax = 0;; 7439 xmin *= 2;; 7440 } else {; 7441 xmin = 0;; 7442 xmax = 1;; 7443 }; 7444 }; 7445 }; 7446 ; 7447 // take into account normalization factor; 7448 Hparam.allchan = allchan;; 7449 Double_t factor = allchan;; 7450 if (fH->GetNormFactor() > 0) factor = fH->GetNormFactor();; 7451 if (allchan) factor /= allchan;; 7452 if (factor == 0) factor = 1;; 7453 Hparam.factor = factor;; 7454 xmax = factor*xmax;; 7455 xmin = factor*xmin;; 7456 ; 7457 // For log scales, histogram coordinates are LOG10(ymin) and; 7458 // LOG10(ymax). Final adjustment (if not option ""Same""; 7459 // or ""+"" for ymax) of ymax and ymin for logarithmic scale, if; 7460 // Maximum and Minimum are not defined.; 7461 if (Hoption.Logx) {; 7462 if (xmin <=0 || xmax <=0) {; 7463 Error(where, ""Cannot set Y axis to log scale"");; 7464 return 0;; 7465 }; 7466 xmin = TMath::Log10(xmin);; 7467 if (!minimum) xmin += TMath::Log10(0.5);; 7468 xmax = TMath::Log10(xmax);; 7469 if (!maximum) xmax += TMath::Log10(2*(0.9/0.95));; 7470 if (!Hoption.Same) {; 7471 Hparam.xmin = xmin;; 7472 Hparam.xmax = xmax;; 7473 }; 7474 return 1;; 7475 }; 7476 ; 7477 // final adjustment of ymin for linear scale.; 7478 // if minimum is not set , then ymin is set to zero if >0; 7479 // or to ymin - margin if <0.; 7480 if (!minimum) {; 7481 if (xmin >= 0) xmin = 0;; 7482 else xmin -= yMARGIN*(xmax-xmin);; 7483 }; 7484 ; 7485 // final adjustment of YMAXI for linear scale (if not option ""Same""):; 7486 // decrease histogram height to MAX% of allowed height if HMAXIM; 7487 // has not been called.; 7488 if (!maximum) {; 7489 xmax += yMARGIN*(xmax-xmin);; 7490 }; 7491 Hparam.xmin = xmin;; 7492 Hparam.xmax = xmax;; 7493 return 1;; 7494}; 7495 ; 7496////////////////////////////////////////////////////////////////////////////////; 7497/// [Control fun",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/THistPainter_8cxx_source.html:268992,log,log,268992,doc/master/THistPainter_8cxx_source.html,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html,1,['log'],['log']
Testability,"le should override this method. ; Implements TVirtualPad.; Definition at line 261 of file TPad.h. GetUxmax(). Double_t TPad::GetUxmax ; (; ); const. inlineoverridevirtual . Returns the maximum x-coordinate value visible on the pad. If log axis the returned value is in decades. ; Implements TVirtualPad.; Definition at line 232 of file TPad.h. GetUxmin(). Double_t TPad::GetUxmin ; (; ); const. inlineoverridevirtual . Returns the minimum x-coordinate value visible on the pad. If log axis the returned value is in decades. ; Implements TVirtualPad.; Definition at line 228 of file TPad.h. GetUymax(). Double_t TPad::GetUymax ; (; ); const. inlineoverridevirtual . Returns the maximum y-coordinate value visible on the pad. If log axis the returned value is in decades. ; Implements TVirtualPad.; Definition at line 234 of file TPad.h. GetUymin(). Double_t TPad::GetUymin ; (; ); const. inlineoverridevirtual . Returns the minimum y-coordinate value visible on the pad. If log axis the returned value is in decades. ; Implements TVirtualPad.; Definition at line 230 of file TPad.h. GetView(). TView * TPad::GetView ; (; ); const. inlineoverridevirtual . Implements TVirtualPad.; Definition at line 254 of file TPad.h. GetView3D(). TObject * TPad::GetView3D ; (; ); const. inlineoverridevirtual . Implements TVirtualPad.; Definition at line 255 of file TPad.h. GetViewer3D(). TVirtualViewer3D * TPad::GetViewer3D ; (; Option_t *; type = """"). overridevirtual . Create/obtain handle to 3D viewer. ; Valid types are:; 'pad' - pad drawing via TViewer3DPad any others registered with plugin manager supporting TVirtualViewer3D If an invalid/null type is requested then the current viewer is returned (if any), otherwise a default 'pad' type is returned . Implements TVirtualPad.; Definition at line 7151 of file TPad.cxx. GetVirtCanvas(). TVirtualPad * TPad::GetVirtCanvas ; (; ); const. overridevirtual . Get virtual canvas. ; Implements TVirtualPad.; Definition at line 2778 of file TPad",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTPad.html:83749,log,log,83749,doc/master/classTPad.html,https://root.cern,https://root.cern/doc/master/classTPad.html,1,['log'],['log']
Testability,"le sigma, double threshold,; bool backgroundRemove,int deconIterations,; bool markov,; int averWindow); ; ; This; function searches for peaks in source spectrum. It is based on deconvolution; method. First the background is removed (if desired), then Markov smoothed; spectrum is calculated (if desired), then the response function is generated; according to given sigma and deconvolution is carried out. The order of peaks; is arranged according to their heights in the spectrum after background; elimination. The highest peak is the first in the list. On success it returns; number of found peaks.; ; Parameters:;  source-pointer to the matrix of source; spectrum ;  dest-resulting spectrum after deconvolution;  ssizex, ssizey-lengths of the source and; destination spectra ;  sigma-sigma of searched peaks; threshold- threshold; value in % for selected peaks, peaks with amplitude less than; threshold*highest_peak/100 are ignored; backgroundRemove- background_remove-logical variable, true if the removal of; background before deconvolution is desired ; deconIterations-number of iterations in; deconvolution operation; markov-logical variable, if it is true,; first the source spectrum is replaced by new spectrum calculated using Markov; chains method ; averWindow-width of; averaging smoothing window ; ; References:; [1]; M.A. Mariscotti: A method for identification of peaks in the presence of; background and its application to spectrum analysis. NIM 50 (1967), 309-320.; [2]; M. Morh, J. Kliman, V.; Matouek, M. Veselsk, I. Turzo.:Identification; of peaks in multidimensional coincidence gamma-ray spectra. NIM, A443 (2000); 108-125.; [3]; Z.K. Silagadze, A new algorithm for automatic photopeak searches. NIM A 376; (1996), 451. . Examples of peak searching; method; ; SearchHighRes function provides users with the possibility; to vary the input parameters and with the access to the output deconvolved data; in the",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TSpectrum2.html:38457,log,logical,38457,root/html602/TSpectrum2.html,https://root.cern,https://root.cern/root/html602/TSpectrum2.html,4,['log'],['logical']
Testability,le to illustrate deconvolution function (class TSpectrum) ; DeconvolutionRL_wide_boost.C Example to illustrate deconvolution function (class TSpectrum) ; FitAwmi.C ; peaks.C Illustrates how to find peaks in histograms ; peaks2.C Example to illustrate the 2-d peak finder (class TSpectrum2) ; SearchHR1.C Example to illustrate high resolution peak searching function (class TSpectrum) ; SearchHR3.C Example to illustrate the influence of number of iterations in deconvolution in high resolution peak searching function (class TSpectrum) ; Smoothing.C Example to illustrate smoothing using Markov algorithm (class TSpectrum) ; spectrumpainter.C Examples showing how to use TSpectrum2Painter (the SPEC option) ; splot; TestSPlot.CThis tutorial illustrates the use of class TSPlot and of the sPlots method ; sql; sqlcanvas.CThis is slight modification of ntuple1.C example ; sqlcreatedb.CCreate a runcatalog table in a MySQL test database ; sqlcreatedb.py Create a runcatalog table in a MySQL test database ; sqlfilldb.CFill run catalog with nfiles entries ; sqlfilldb.py Fill run catalog with nfiles entries ; SQLiteIPLocation.C ; SQLitePlatformDistribution.C ; SQLiteTimeVersionOfRoot.C ; SQLiteVersionsOfRoot.C ; sqlselect.CQuery example to MySQL test database ; sqlselect.py Query example to MySQL test database ; sqltables.CThis is an example illustrating how the TSQLFile class can be used ; thread; stressThreadPool.CUsage: ; threadPool.CUsage: ; threads.CExample of a simple script creating 3 threads ; threadsh1.CExample of a simple script creating 3 threads ; threadsh2.CExample of a simple script creating 2 threads each with one canvas ; tmva; envelope; classification.C; keras; ApplicationClassificationKeras.py; ApplicationRegressionKeras.py; ClassificationKeras.py; GenerateModel.py; MulticlassKeras.py; RegressionKeras.py; createData.CPlot the variables ; TMVAClassification.C This macro provides examples for the training and testing o,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v616/files.html:163857,test,test,163857,doc/v616/files.html,https://root.cern,https://root.cern/doc/v616/files.html,1,['test'],['test']
Testability,le to illustrate deconvolution function (class TSpectrum) ; DeconvolutionRL_wide_boost.C Example to illustrate deconvolution function (class TSpectrum) ; FitAwmi.C ; peaks.C Illustrates how to find peaks in histograms ; peaks2.C Example to illustrate the 2-d peak finder (class TSpectrum2) ; SearchHR1.C Example to illustrate high resolution peak searching function (class TSpectrum) ; SearchHR3.C Example to illustrate the influence of number of iterations in deconvolution in high resolution peak searching function (class TSpectrum) ; Smoothing.C Example to illustrate smoothing using Markov algorithm (class TSpectrum) ; spectrumpainter.C Examples showing how to use TSpectrum2Painter (the SPEC option) ; splot; TestSPlot.CThis tutorial illustrates the use of class TSPlot and of the sPlots method ; sql; sqlcanvas.CThis is slight modification of ntuple1.C example ; sqlcreatedb.CCreate a runcatalog table in a MySQL test database ; sqlcreatedb.py Create a runcatalog table in a MySQL test database ; sqlfilldb.CFill run catalog with nfiles entries ; sqlfilldb.py Fill run catalog with nfiles entries ; sqlselect.CQuery example to MySQL test database ; sqlselect.py Query example to MySQL test database ; sqltables.CThis is an example illustrating how the TSQLFile class can be used ; thread; stressThreadPool.CUsage: ; threadPool.CUsage: ; threads.CExample of a simple script creating 3 threads ; threadsh1.CExample of a simple script creating 3 threads ; threadsh2.CExample of a simple script creating 2 threads each with one canvas ; tmva; envelope; classification.C; keras; ApplicationClassificationKeras.py; ApplicationRegressionKeras.py; ClassificationKeras.py; GenerateModel.py; MulticlassKeras.py; RegressionKeras.py; createData.CPlot the variables ; TMVAClassification.C This macro provides examples for the training and testing of the TMVA classifiers ; TMVAClassificationApplication.C This macro provides a simple example on how to use ,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v614/files.html:157551,test,test,157551,doc/v614/files.html,https://root.cern,https://root.cern/doc/v614/files.html,1,['test'],['test']
Testability,"le. private:. RooStats::HypoTestCalculator*fCalculator0pointer to the calculator passed in the constructor; RooStats::HypoTestInverterResult*fResults; RooRealVar*fScannedVariablepointer to the constrained variable; doublefSize; boolfUseCLs. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; HypoTestInverter(); default constructor (doesn't do anything). HypoTestInverter(RooStats::HypoTestCalculator& myhc0, RooRealVar& scannedVariable, double size = 0.05); constructor from a reference to an HypoTestCalculator; (it must be an HybridCalculator type) and a RooRealVar for the variable. ~HypoTestInverter(); destructor. void CreateResults(); create a new HypoTestInverterResult to hold all computed results. bool RunAutoScan(double xMin, double xMax, double target, double epsilon = 0.005, unsigned int numAlgorithm = 0); Search for the value of the parameter of interest (vary the; hypothesis being tested) in the specified range [xMin,xMax]; until the confidence level is compatible with the target value; within one time the estimated error (and the estimated error; should also become smaller than the specified parameter epsilon). bool RunFixedScan(int nBins, double xMin, double xMax); Run a Fixed scan in npoints between min and max. bool RunOnePoint(double thisX); run only one point. HypoTestInverter(); default constructor (used only for I/O). HypoTestInverterResult* GetInterval() const; { return fResults; }. void UseCLs(bool on = true); { fUseCLs = on; if (fResults) fResults->UseCLs(on); }. void SetData(RooAbsData& ); { }. void SetModel(const RooStats::ModelConfig& ); { }. void SetTestSize(Double_t size); set the size of the test (rate of Type I error) ( Eg. 0.05 for a 95% Confidence Interval). {fSize = size; if (fResults) fResults->SetTestSize(size); }. void SetConfidenceLevel(Double_t cl); set the confidence level for the interval (eg. 0.95 for a 95% Confidence Interval). {fSize = 1.-cl; if (fResults) fResults->SetConfidenceLevel(cl); ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooStats__HypoTestInverter.html:8339,test,tested,8339,root/html526/RooStats__HypoTestInverter.html,https://root.cern,https://root.cern/root/html526/RooStats__HypoTestInverter.html,2,['test'],['tested']
Testability,"le.h. TSQLStructure. friend class TSQLStructure. friend . Definition at line 34 of file TSQLFile.h. TSQLTableData. friend class TSQLTableData. friend . Definition at line 35 of file TSQLFile.h. Member Data Documentation. fArrayLimit. Int_t TSQLFile::fArrayLimit. protected . ! limit for array size. when array bigger, its content converted to raw format ; Definition at line 152 of file TSQLFile.h. fBasicTypes. const char** TSQLFile::fBasicTypes. protected . ! pointer on list of basic types specific for currently connected SQL server ; Definition at line 160 of file TSQLFile.h. fCanChangeConfig. Bool_t TSQLFile::fCanChangeConfig. protected . ! variable indicates can be basic configuration changed or not ; Definition at line 153 of file TSQLFile.h. fIdsTableExists. Bool_t TSQLFile::fIdsTableExists. protected . ! indicate if IdsTable exists ; Definition at line 167 of file TSQLFile.h. fLogFile. std::ofstream* TSQLFile::fLogFile. protected . ! log file with SQL statements ; Definition at line 165 of file TSQLFile.h. fModifyCounter. Int_t TSQLFile::fModifyCounter. protected . ! indicates how many changes was done with database tables ; Definition at line 157 of file TSQLFile.h. fOtherTypes. const char** TSQLFile::fOtherTypes. protected . ! pointer on list of other SQL types like TEXT or blob ; Definition at line 161 of file TSQLFile.h. fQuerisCounter. Int_t TSQLFile::fQuerisCounter. protected . ! how many query was applied ; Definition at line 158 of file TSQLFile.h. fSQL. TSQLServer* TSQLFile::fSQL. protected . ! interface to SQL database ; Definition at line 146 of file TSQLFile.h. fSQLClassInfos. TList* TSQLFile::fSQLClassInfos. protected . ! list of SQL class infos ; Definition at line 148 of file TSQLFile.h. fSQLIOversion. Int_t TSQLFile::fSQLIOversion. protected . ! version of SQL I/O which is stored in configurations ; Definition at line 151 of file TSQLFile.h. fStmtCounter. Int_t TSQLFile::fStmtCounter. protected . ! count numbers of act",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSQLFile.html:104570,log,log,104570,doc/master/classTSQLFile.html,https://root.cern,https://root.cern/doc/master/classTSQLFile.html,1,['log'],['log']
Testability,"le.h:53; TFile::Openstatic TFile * Open(const char *name, Option_t *option="""", const char *ftitle="""", Int_t compress=ROOT::RCompressionSetting::EDefaults::kUseCompiledDefault, Int_t netopt=0)Create / open a file.Definition TFile.cxx:4089; TFile::SetCacheFileDirstatic Bool_t SetCacheFileDir(std::string_view cacheDir, Bool_t operateDisconnected=kTRUE, Bool_t forceCacheread=kFALSE)Sets the directory where to locally stage/cache remote files.Definition TFile.cxx:4626; TFile::Closevoid Close(Option_t *option="""") overrideClose a file.Definition TFile.cxx:950; TMVA::CrossValidationClass to perform cross validation, splitting the dataloader into folds.Definition CrossValidation.h:124; TMVA::DataLoaderDefinition DataLoader.h:50; TMVA::DataLoader::AddRegressionTreevoid AddRegressionTree(TTree *tree, Double_t weight=1.0, Types::ETreeType treetype=Types::kMaxTreeType)Definition DataLoader.h:103; TMVA::DataLoader::PrepareTrainingAndTestTreevoid PrepareTrainingAndTestTree(const TCut &cut, const TString &splitOpt)prepare the training and test trees -> same cuts for signal and backgroundDefinition DataLoader.cxx:632; TMVA::DataLoader::AddTargetvoid AddTarget(const TString &expression, const TString &title="""", const TString &unit="""", Double_t min=0, Double_t max=0)user inserts target in data set infoDefinition DataLoader.cxx:512; TMVA::DataLoader::AddVariablevoid AddVariable(const TString &expression, const TString &title, const TString &unit, char type='F', Double_t min=0, Double_t max=0)user inserts discriminating variable in data set infoDefinition DataLoader.cxx:485; TMVA::Tools::Instancestatic Tools & Instance()Definition Tools.cxx:71; TMVA::Types::kBDT@ kBDTDefinition Types.h:86; TNamed::GetNameconst char * GetName() const overrideReturns name of object.Definition TNamed.h:47; TStringBasic string class.Definition TString.h:139; TString::Dataconst char * Data() constDefinition TString.h:376; TSystem::AccessPathNamevirtual Bool_t AccessPathName(const char *path, EAccessMode mode",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVACrossValidationRegression_8C.html:21455,test,test,21455,doc/master/TMVACrossValidationRegression_8C.html,https://root.cern,https://root.cern/doc/master/TMVACrossValidationRegression_8C.html,1,['test'],['test']
Testability,"le::RElement::GetTitlevirtual std::string GetTitle() constTitle of browsable (optional)Definition RElement.hxx:71; ROOT::Browsable::RElement::ComparePathsstatic int ComparePaths(const RElementPath_t &path1, const RElementPath_t &path2)Compare two paths, Returns number of elements matches in both paths.Definition RElement.cxx:145; ROOT::Browsable::RElement::GetPathAsStringstatic std::string GetPathAsString(const RElementPath_t &path)Converts element path back to string.Definition RElement.cxx:160; ROOT::Browsable::RElement::GetSubElementstatic std::shared_ptr< RElement > GetSubElement(std::shared_ptr< RElement > &elem, const RElementPath_t &path)Returns sub element.Definition RElement.cxx:69; ROOT::Browsable::RElement::CreateItemvirtual std::unique_ptr< RItem > CreateItem() constReturns item with element description.Definition RElement.cxx:105; ROOT::Browsable::RElement::ParsePathstatic RElementPath_t ParsePath(const std::string &str)Parse string path to produce RElementPath_t One should avoid to use string pathes as much as possible...Definition RElement.cxx:116; ROOT::Experimental::RLogChannelA log configuration for a channel, e.g.Definition RLogger.hxx:101; TBufferJSON::ConvertToJSONstatic TString ConvertToJSON(const TObject *obj, Int_t compact=0, const char *member_name=nullptr)Converts object, inherited from TObject class, to JSON string Lower digit of compact parameter define...Definition TBufferJSON.cxx:522; TString::Dataconst char * Data() constDefinition TString.h:376; nconst Int_t nDefinition legend1.C:16; ROOT::BrowsableDefinition RAnyObjectHolder.hxx:15; ROOT::Browsable::RElementPath_tstd::vector< std::string > RElementPath_tDefinition RElement.hxx:20; ROOT::BrowsableLogROOT::Experimental::RLogChannel & BrowsableLog()Log channel for Browsable diagnostics.Definition RElement.cxx:20; slashTCanvas * slash()Definition slash.C:1. guibrowsablesrcRElement.cxx. ROOT v6-32 - Reference Guide Generated on Fri Nov 1 2024 15:07:53 (GVA Time) using Doxygen 1.9.8 ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/RElement_8cxx_source.html:9082,log,log,9082,doc/v632/RElement_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/RElement_8cxx_source.html,1,['log'],['log']
Testability,"le::physics""));; ; // Plot ""physics"" slice of simultaneous pdf.; // NBL You _must_ project the sample index category with data using ProjWData; // as a RooSimultaneous makes no prediction on the shape in the index category; // and can thus not be integrated.; // In other words: Since the PDF doesn't know the number of events in the different; // category states, it doesn't know how much of each component it has to project out.; // This information is read from the data.; simPdf.plotOn(frame1, Slice(sample, ""physics""), ProjWData(sample, combData));; simPdf.plotOn(frame1, Slice(sample, ""physics""), Components(""px""), ProjWData(sample, combData), LineStyle(kDashed));; ; // The same plot for the control sample slice. We do this with a different; // approach this time, for illustration purposes. Here, we are slicing the; // dataset and then use the data slice for the projection, because then the; // RooFit::Slice() becomes unnecessary. This approach is more general,; // because you can plot sums of slices by using logical or in the Cut(); // command.; RooPlot *frame2 = x.frame(Bins(30), Title(""Control sample""));; std::unique_ptr<RooAbsData> slicedData{combData.reduce(Cut(""sample==sample::control""))};; slicedData->plotOn(frame2);; simPdf.plotOn(frame2, ProjWData(sample, *slicedData));; simPdf.plotOn(frame2, Components(""px_ctl""), ProjWData(sample, *slicedData), LineStyle(kDashed));; ; // The same plot for all the phase space. Here, we can just use the original; // combined dataset.; RooPlot *frame3 = x.frame(Title(""Both samples""));; combData.plotOn(frame3);; simPdf.plotOn(frame3, ProjWData(sample, combData));; simPdf.plotOn(frame3, Components(""px,px_ctl""), ProjWData(sample, combData),; LineStyle(kDashed));; ; TCanvas *c = new TCanvas(""rf501_simultaneouspdf"", ""rf403_simultaneouspdf"", 1200, 400);; c->Divide(3);; auto draw = [&](int i, RooPlot & frame) {; c->cd(i);; gPad->SetLeftMargin(0.15);; frame.GetYaxis()->SetTitleOffset(1.4);; frame.Draw();; };; draw(1, *frame1);; draw(2, ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf501__simultaneouspdf_8C.html:4901,log,logical,4901,doc/master/rf501__simultaneouspdf_8C.html,https://root.cern,https://root.cern/doc/master/rf501__simultaneouspdf_8C.html,1,['log'],['logical']
Testability,"le; nsig = 0 (default value) returns the expected value; nsig = -1 returns the lower band value at -1 sigma; nsig + 1 return the upper value. double GetExpectedUpperLimit(double nsig = 0) const; Get the expected upper limit; nsig is used to specify which expected value of the UpperLimitDistribution; For example; nsig = 0 (default value) returns the expected value; nsig = -1 returns the lower band value at -1 sigma; nsig + 1 return the upper value. double GetExpectedLimit(double nsig, bool lower) const; get expected limit (lower/upper) depending on the flag. double GetLastYValue() const; { return GetYValue( fXValues.size()-1); }. double GetLastXValue() const; { return GetXValue( fXValues.size()-1); }. double GetLastYError() const; { return GetYError( fXValues.size()-1); }. HypoTestResult * GetLastResult() const; { return GetResult( fXValues.size()-1); }. int ArraySize() const; number of entries in the results array. { return fXValues.size(); }. void SetTestSize(Double_t size); set the size of the test (rate of Type I error) (eg. 0.05 for a 95% Confidence Interval). { fConfidenceLevel = 1.-size; }. void SetConfidenceLevel(Double_t cl); set the confidence level for the interval (eg. 0.95 for a 95% Confidence Interval). { fConfidenceLevel = cl; }. void UseCLs(bool on = true); flag to switch between using CLsb (default) or CLs as confidence level. { fUseCLs = on; }. SamplingDistribution * GetNullTestStatDist(int index) const; same in terms of alt and null. SamplingDistribution * GetAltTestStatDist(int index) const. SamplingDistribution* GetLowerLimitDistribution() const; get expected lower limit distributions; implemented using interpolation. { return GetLimitDistribution(true); }. SamplingDistribution* GetUpperLimitDistribution() const; get expected upper limit distributions; implemented using interpolation. { return GetLimitDistribution(false); }. void SetInterpolationOption(RooStats::HypoTestInverterResult::InterpolOption_t opt); set the interpolation option, linear (",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooStats__HypoTestInverterResult.html:14376,test,test,14376,root/html530/RooStats__HypoTestInverterResult.html,https://root.cern,https://root.cern/root/html530/RooStats__HypoTestInverterResult.html,1,['test'],['test']
Testability,"le; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  SQL;  MYSQL;  TMySQLServer. class TMySQLServer: public TSQLServer. TMySQLServer. MySQL server plugin implementing the TSQLServer interface. To open a connection to a server use the static method Connect().; The db argument of Connect() is of the form:; mysql://<host>[:<port>][/<database>], e.g.; mysql://pcroot.cern.ch:3456/test. As an example of connecting to mysql we assume that the server is; running on the local host and that you have access to a database; named ""test"" by connecting using an account that has a username and; password of ""tuser"" and ""tpass"". You can set up this account; by using the ""mysql"" program to connect to the server as the MySQL; root user and issuing the following statement:. mysql> GRANT ALL ON test.* TO 'tuser'@'localhost' IDENTIFIED BY 'tpass';. If the test database does not exist, create it with this statement:. mysql> CREATE DATABASE test;. If you want to use a different server host, username, password,; or database name, just substitute the appropriate values.; To connect do:. TSQLServer *db = TSQLServer::Connect(""mysql://localhost/test"", ""tuser"", ""tpass"");. Function Members (Methods); public:. TMySQLServer(const TMySQLServer&); TMySQLServer(const char* db, const char* uid, const char* pw); virtual~TMySQLServer(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual voidClose(Option_t* opt = """"); virtual Bool_tCommit(); virtual Int_tTObject::Compare(const TObject* obj) const; static TSQLServer*TSQLServer::Connect(const char* db, const char* uid, const char* pw); virtual voidTObject::Copy(TObject& object) const; virtual Int_tC",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMySQLServer.html:1110,test,test,1110,root/html528/TMySQLServer.html,https://root.cern,https://root.cern/root/html528/TMySQLServer.html,4,['test'],['test']
Testability,"le; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  SQL;  MYSQL;  TMySQLServer. class TMySQLServer: public TSQLServer. TMySQLServer. MySQL server plugin implementing the TSQLServer interface. To open a connection to a server use the static method Connect().; The db argument of Connect() is of the form:; mysql://<host>[:<port>][/<database>], e.g.; mysql://pcroot.cern.ch:3456/test. As an example of connecting to mysql we assume that the server is; running on the local host and that you have access to a database; named ""test"" by connecting using an account that has a username and; password of ""tuser"" and ""tpass"". You can set up this account; by using the ""mysql"" program to connect to the server as the MySQL; root user and issuing the following statement:. mysql> GRANT ALL ON test.* TO 'tuser'@'localhost' IDENTIFIED BY 'tpass';. If the test database does not exist, create it with this statement:. mysql> CREATE DATABASE test;. If you want to use a different server host, username, password,; or database name, just substitute the appropriate values.; To connect do:. TSQLServer *db = TSQLServer::Connect(""mysql://localhost/test"", ""tuser"", ""tpass"");. Function Members (Methods); public:. virtual~TMySQLServer(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual voidClose(Option_t* opt = """"); virtual Bool_tCommit(); virtual Int_tTObject::Compare(const TObject* obj) const; static TSQLServer*TSQLServer::Connect(const char* db, const char* uid, const char* pw); virtual voidTObject::Copy(TObject& object) const; virtual Int_tCreateDataBase(const char* dbname); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtua",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TMySQLServer.html:1110,test,test,1110,root/html602/TMySQLServer.html,https://root.cern,https://root.cern/root/html602/TMySQLServer.html,2,['test'],['test']
Testability,"le; static Int_t_nameLength; . #include <RooGenContext.h>. Inheritance diagram for RooGenContext:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. RooGenContext(). RooGenContext::RooGenContext ; (; const RooAbsPdf &; model, . const RooArgSet &; vars, . const RooDataSet *; prototype = nullptr, . const RooArgSet *; auxProto = nullptr, . bool; verbose = false, . const RooArgSet *; forceDirect = nullptr. ). Initialize a new context for generating events with the specified variables, using the specified PDF model. ; A prototype dataset (if provided) is not cloned and still belongs to the caller. The contents and shape of this dataset can be changed between calls to generate() as long as the expected columns to be copied to the generated dataset are present. Any argument supplied in the forceDirect RooArgSet are always offered for internal generation to the p.d.f., even if this is deemed unsafe by the logic of RooGenContext. ; Definition at line 62 of file RooGenContext.cxx. ~RooGenContext(). RooGenContext::~RooGenContext ; (; ). overridedefault . Member Function Documentation. attach(). void RooGenContext::attach ; (; const RooArgSet &; params). overridevirtual . Attach the cloned model to the event buffer we will be filling. ; Reimplemented from RooAbsGenContext.; Definition at line 305 of file RooGenContext.cxx. Class(). static TClass * RooGenContext::Class ; (; ). static . ReturnsTClass describing this class . Class_Name(). static const char * RooGenContext::Class_Name ; (; ). static . ReturnsName of this class . Class_Version(). static constexpr Version_t RooGenContext::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 54 of file RooGenContext.h. DeclFileName(). static const char * RooGenContext::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 54 ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooGenContext.html:18721,log,logic,18721,doc/master/classRooGenContext.html,https://root.cern,https://root.cern/doc/master/classRooGenContext.html,1,['log'],['logic']
Testability,leApply.hxx; TDirectory.hxx; TDirectoryEntry.hxx; TDrawable.hxx; TIndexIter.hxx; TLogger.hxx; src; TDrawable.cxx; TLogger.cxx; cont; inc; ROOT; TSeq.hxx; TArray.h; TArrayC.h; TArrayD.h; TArrayF.h; TArrayI.h; TArrayL.h; TArrayL64.h; TArrayS.h; TBits.h; TBtree.h; TClassTable.h; TClonesArray.h; TCollection.h; TCollectionProxyInfo.h; TExMap.h; THashList.h; THashTable.h; TIterator.h; TList.h; TMap.h; TObjArray.h; TObjectTable.h; TOrdCollection.h; TRefArray.h; TRefTable.h; TSeqCollection.h; TSortedList.h; TVirtualCollectionProxy.h; src; TArray.cxx; TArrayC.cxx; TArrayD.cxx; TArrayF.cxx; TArrayI.cxx; TArrayL.cxx; TArrayL64.cxx; TArrayS.cxx; TBits.cxx; TBtree.cxx; TClassTable.cxx; TClonesArray.cxx; TCollection.cxx; TExMap.cxx; THashList.cxx; THashTable.cxx; TIterator.cxx; TList.cxx; TMap.cxx; TObjArray.cxx; TObjectTable.cxx; TOrdCollection.cxx; TRefArray.cxx; TRefTable.cxx; TSeqCollection.cxx; TSortedList.cxx; test; TSeqTests.cxx; imt; inc; ROOT; TPoolManager.hxx; TThreadExecutor.hxx; src; base.cxx; TImplicitMT.cxx; TPoolManager.cxx; TThreadExecutor.cxx; macosx; inc; CocoaUtils.h; TMacOSXSystem.h; src; CocoaUtils.mm; TMacOSXSystem.mm; meta; inc; RootMetaSelection.h; TBaseClass.h; TClass.h; TClassGenerator.h; TClassMenuItem.h; TClassRef.h; TClassStreamer.h; TDataMember.h; TDataType.h; TDictAttributeMap.h; TDictionary.h; TEnum.h; TEnumConstant.h; TFileMergeInfo.h; TFunction.h; TFunctionTemplate.h; TGenericClassInfo.h; TGlobal.h; TInterpreter.h; TInterpreterValue.h; TIsAProxy.h; TListOfDataMembers.h; TListOfEnums.h; TListOfEnumsWithLock.h; TListOfFunctions.h; TListOfFunctionTemplates.h; TMemberStreamer.h; TMethod.h; TMethodArg.h; TMethodCall.h; TProtoClass.h; TRealData.h; TSchemaHelper.h; TSchemaRule.h; TSchemaRuleSet.h; TStreamer.h; TStreamerElement.h; TToggle.h; TToggleGroup.h; TVirtualIsAProxy.h; TVirtualRefProxy.h; T,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v610/files.html:6479,test,test,6479,doc/v610/files.html,https://root.cern,https://root.cern/doc/v610/files.html,1,['test'],['test']
Testability,"leCacheRead *)fCacheReadMap->GetValue(next());; 1269 }; 1270 return fCacheRead;; 1271 }; 1272 TFileCacheRead *cache = (TFileCacheRead *)fCacheReadMap->GetValue(tree);; 1273 if (!cache) return fCacheRead;; 1274 return cache;; 1275}; 1276 ; 1277////////////////////////////////////////////////////////////////////////////////; 1278/// Return a pointer to the current write cache.; 1279 ; 1280TFileCacheWrite *TFile::GetCacheWrite() const; 1281{; 1282 return fCacheWrite;; 1283}; 1284 ; 1285////////////////////////////////////////////////////////////////////////////////; 1286/// Read the logical record header starting at a certain postion.; 1287///; 1288/// \param[in] buf pointer to buffer; 1289/// \param[in] first read offset; 1290/// \param[in] maxbytes Bytes which are read into buf.; 1291/// \param[out] nbytes Number of bytes in record if negative, this is a deleted; 1292/// record if 0, cannot read record, wrong value of argument first; 1293/// \param[out] objlen Uncompressed object size; 1294/// \param[out] keylen Length of logical record header; 1295///; 1296/// The function reads nread bytes; 1297/// where nread is the minimum of maxbytes and the number of bytes; 1298/// before the end of file. The function returns nread.; 1299/// Note that the arguments objlen and keylen are returned only; 1300/// if maxbytes >=16; 1301 ; 1302Int_t TFile::GetRecordHeader(char *buf, Long64_t first, Int_t maxbytes, Int_t &nbytes, Int_t &objlen, Int_t &keylen); 1303{; 1304 nbytes = 0;; 1305 objlen = 0;; 1306 keylen = 0;; 1307 if (first < fBEGIN) return 0;; 1308 if (first > fEND) return 0;; 1309 Seek(first);; 1310 Int_t nread = maxbytes;; 1311 if (first+maxbytes > fEND) nread = fEND-maxbytes;; 1312 if (nread < 4) {; 1313 Warning(""GetRecordHeader"",""%s: parameter maxbytes = %d must be >= 4"",; 1314 GetName(), nread);; 1315 return nread;; 1316 }; 1317 if (ReadBuffer(buf,nread)) {; 1318 // ReadBuffer return kTRUE in case of failure.; 1319 Warning(""GetRecordHeader"",""%s: failed to read header ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TFile_8cxx_source.html:45975,log,logical,45975,doc/master/TFile_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html,1,['log'],['logical']
Testability,"leFitParams.h. fGDTauVec. std::vector< Double_t > TMVA::RuleFitParams::fGDTauVec. protected . the tau's ; Definition at line 220 of file RuleFitParams.h. fGradVec. std::vector<Double_t> TMVA::RuleFitParams::fGradVec. protected . gradient vector - dimension = number of rules in ensemble ; Definition at line 209 of file RuleFitParams.h. fGradVecLin. std::vector<Double_t> TMVA::RuleFitParams::fGradVecLin. protected . gradient vector - dimension = number of variables ; Definition at line 210 of file RuleFitParams.h. fGradVecLinTst. std::vector< std::vector<Double_t> > TMVA::RuleFitParams::fGradVecLinTst. protected . gradient vector, linear terms - one per tau ; Definition at line 213 of file RuleFitParams.h. fGradVecTst. std::vector< std::vector<Double_t> > TMVA::RuleFitParams::fGradVecTst. protected . gradient vector - one per tau ; Definition at line 212 of file RuleFitParams.h. fLogger. MsgLogger* TMVA::RuleFitParams::fLogger. mutableprivate . ! message logger ; Definition at line 253 of file RuleFitParams.h. fNEveEffPath. Double_t TMVA::RuleFitParams::fNEveEffPath. protected . sum of weights for Path events ; Definition at line 201 of file RuleFitParams.h. fNEveEffPerf. Double_t TMVA::RuleFitParams::fNEveEffPerf. protected . idem for Perf events ; Definition at line 202 of file RuleFitParams.h. fNLinear. UInt_t TMVA::RuleFitParams::fNLinear. protected . number of linear terms ; Definition at line 192 of file RuleFitParams.h. fNRules. UInt_t TMVA::RuleFitParams::fNRules. protected . number of rules ; Definition at line 191 of file RuleFitParams.h. fNTCoeff. Double_t* TMVA::RuleFitParams::fNTCoeff. protected . GD path: rule coefficients. ; Definition at line 243 of file RuleFitParams.h. fNTCoefRad. Double_t TMVA::RuleFitParams::fNTCoefRad. protected . GD path: 'radius' of all rulecoeffs. ; Definition at line 241 of file RuleFitParams.h. fNTErrorRate. Double_t TMVA::RuleFitParams::fNTErrorRate. protected . GD path: error rate (or performance) ;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1RuleFitParams.html:24342,log,logger,24342,doc/master/classTMVA_1_1RuleFitParams.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1RuleFitParams.html,1,['log'],['logger']
Testability,"leName, const char *delimiter=""\n"", bool useTitle=false, bool useLatex=false); Create a GraphViz .dot file visualizing the expression tree headed by this RooAbsArg object. ; ; voidgraphVizTree (std::ostream &os, const char *delimiter=""\n"", bool useTitle=false, bool useLatex=false); Write the GraphViz representation of the expression tree headed by this RooAbsArg object to the given ostream. ; ; boolhasClients () const; ; boolhasDataToken () const; ; virtual boolimportWorkspaceHook (RooWorkspace &ws); ; virtual boolisCategory () const; ; boolisConstant () const; Check if the ""Constant"" attribute is set. ; ; virtual boolisReducerNode () const; ; boolIsSortable () const override; ; boollocalNoDirtyInhibit () const; ; const TNamed *namePtr () const; De-duplicated pointer to this object's name. ; ; Int_tnumProxies () const; Return the number of registered proxies. ; ; boolobservableOverlaps (const RooAbsData *dset, const RooAbsArg &testArg) const; Test if any of the dependents of the arg tree (as determined by getObservables) overlaps with those of the testArg. ; ; boolobservableOverlaps (const RooArgSet *depList, const RooAbsArg &testArg) const; Test if any of the dependents of the arg tree (as determined by getObservables) overlaps with those of the testArg. ; ; RooAbsArg &operator= (const RooAbsArg &other)=delete; ; booloverlaps (const RooAbsArg &testArg, bool valueOnly=false) const; Test if any of the nodes of tree are shared with that of the given tree. ; ; const RooArgSet *ownedComponents () const; ; voidPrint (Option_t *options=nullptr) const override; Print the object to the defaultPrintStream(). ; ; voidprintAddress (std::ostream &os) const override; Print address of this RooAbsArg. ; ; voidprintArgs (std::ostream &os) const override; Print object arguments, ie its proxies. ; ; voidprintClassName (std::ostream &os) const override; Print object class name. ; ; voidprintCompactTree (const char *indent="""", const",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooRealVar.html:35675,test,testArg,35675,doc/master/classRooRealVar.html,https://root.cern,https://root.cern/doc/master/classRooRealVar.html,2,['test'],['testArg']
Testability,leServer.h; TOracleStatement.h; src; TOracleResult.cxx; TOracleRow.cxx; TOracleServer.cxx; TOracleStatement.cxx; pgsql; inc; TPgSQLResult.h; TPgSQLRow.h; TPgSQLServer.h; TPgSQLStatement.h; src; TPgSQLResult.cxx; TPgSQLRow.cxx; TPgSQLServer.cxx; TPgSQLStatement.cxx; sapdb; inc; TSapDBResult.h; TSapDBRow.h; TSapDBServer.h; src; TSapDBResult.cxx; TSapDBRow.cxx; TSapDBServer.cxx; sqlite; inc; TSQLiteResult.h; TSQLiteRow.h; TSQLiteServer.h; TSQLiteStatement.h; src; TSQLiteResult.cxx; TSQLiteRow.cxx; TSQLiteServer.cxx; TSQLiteStatement.cxx; tmva; pymva; inc; TMVA; MethodPyAdaBoost.h; MethodPyGTB.h; MethodPyKeras.h; MethodPyRandomForest.h; PyMethodBase.h; src; MethodPyAdaBoost.cxx; MethodPyGTB.cxx; MethodPyKeras.cxx; MethodPyRandomForest.cxx; PyMethodBase.cxx; test; Classification.C; testPyAdaBoostClassification.C; testPyAdaBoostMulticlass.C; testPyGTBClassification.C; testPyGTBMulticlass.C; testPyKerasClassification.C; testPyKerasMulticlass.C; testPyKerasRegression.C; testPyRandomForestClassification.C; testPyRandomForestMulticlass.C; rmva; inc; TMVA; MethodC50.h; MethodRSNNS.h; MethodRSVM.h; MethodRXGB.h; RMethodBase.h; src; MethodC50.cxx; MethodRSNNS.cxx; MethodRSVM.cxx; MethodRXGB.cxx; RMethodBase.cxx; test; Classification.C; tmva; inc; TMVA; DNN; Architectures; Cpu; Blas.h; CpuBuffer.h; CpuMatrix.h; Cuda; CudaBuffers.h; CudaMatrix.h; Device.h; Cpu.h; Cuda.h; Reference.h; DataLoader.h; Functions.h; Layer.h; Minimizers.h; Net.h; BDTEventWrapper.h; BinarySearchTree.h; BinarySearchTreeNode.h; BinaryTree.h; CCPruner.h; CCTreeWrapper.h; ClassifierFactory.h; ClassInfo.h; Config.h; Configurable.h; ConvergenceTest.h; CostComplexityPruneTool.h; CrossEntropy.h; CrossValidation.h; DataInputHandler.h; DataLoader.h; DataSet.h; DataSetFactory.h; DataSetInfo.h; DataSetManager.h; DecisionTree.h; DecisionTreeNo,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v610/files.html:85214,test,testPyKerasClassification,85214,doc/v610/files.html,https://root.cern,https://root.cern/doc/v610/files.html,1,['test'],['testPyKerasClassification']
Testability,"leYOffset() const; {return GetTitleOffset(""Y"");}. Float_t GetTitleYSize() const; {return GetTitleSize(""Y"");}. Float_t GetTitleX() const; {return fTitleX;}. Float_t GetTitleY() const; {return fTitleY;}. Float_t GetTitleW() const; {return fTitleW;}. Float_t GetTitleH() const; {return fTitleH;}. const char * GetHeaderPS() const; {return fHeaderPS.Data();}. const char * GetTitlePS() const; {return fTitlePS.Data();}. Float_t GetLineScalePS() const; {return fLineScalePS;}. Bool_t IsReading() const; {return fIsReading;}. void SetFitFormat(const char* format = ""5.4g""); {fFitFormat = format;}. void SetHatchesLineWidth(Int_t l); {fHatchesLineWidth = l;}. void SetHatchesSpacing(Double_t h); {fHatchesSpacing = TMath::Max(0.1,h);}. void SetLineScalePS(Float_t scale = 3); {fLineScalePS=scale;}. void SetLegoInnerR(Float_t rad = 0.5); {fLegoInnerR = rad;}. void SetScreenFactor(Float_t factor = 1); {fScreenFactor = factor;}. void SetOptFile(Int_t file = 1); {fOptFile = file;}. void SetOptLogx(Int_t logx = 1); {fOptLogx = logx;}. void SetOptLogy(Int_t logy = 1); {fOptLogy = logy;}. void SetOptLogz(Int_t logz = 1); {fOptLogz = logz;}. void SetOptTitle(Int_t tit = 1); {fOptTitle = tit;}. void SetBarOffset(Float_t baroff = 0.5); {fBarOffset = baroff;}. void SetBarWidth(Float_t barwidth = 0.5); {fBarWidth = barwidth;}. void SetDateX(Float_t x = 0.01); {fDateX = x;}. void SetDateY(Float_t y = 0.01); {fDateY = y;}. void SetErrorX(Float_t errorx = 0.5); {fErrorX = errorx;}. void SetCanvasPreferGL(Bool_t prefer = kTRUE); {fCanvasPreferGL=prefer;}. void SetDrawBorder(Int_t drawborder = 1); {fDrawBorder = drawborder;}. void SetCanvasColor(Color_t color = 19); {fCanvasColor = color;}. void SetCanvasBorderSize(Width_t size = 1); {fCanvasBorderSize = size;}. void SetCanvasBorderMode(Int_t mode = 1); {fCanvasBorderMode = mode;}. void SetCanvasDefH(Int_t h = 500); {fCanvasDefH = h;}. void SetCanvasDefW(Int_t w = 700); {fCanvasDefW = w;}. void SetCanvasDefX(Int_t topx = 10); {fCanvasDefX = topx;}. vo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TStyle.html:43468,log,logx,43468,root/html528/TStyle.html,https://root.cern,https://root.cern/root/html528/TStyle.html,12,['log'],['logx']
Testability,"le_t *dir) const override; ; virtual Double_tGetDX () const; ; virtual Double_tGetDY () const; ; virtual Double_tGetDZ () const; ; virtual Double_tGetFacetArea (Int_t index=0) const; ; Int_tGetFittingBox (const TGeoBBox *parambox, TGeoMatrix *mat, Double_t &dx, Double_t &dy, Double_t &dz) const override; ; virtual const Double_t *GetOrigin () const; ; virtual Bool_tGetPointsOnFacet (Int_t index, Int_t npoints, Double_t *array) const; ; virtual Bool_tIsNullBox () const; ; Bool_tIsValidBox () const override; ; voidSetBoxDimensions (Double_t dx, Double_t dy, Double_t dz, Double_t *origin=nullptr); ; voidSetBoxPoints (Double_t *points) const; ; voidStreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b); ; Public Member Functions inherited from TGeoShape; TGeoShape (); Default constructor. ; ; TGeoShape (const char *name); Default constructor. ; ; ~TGeoShape () override; Destructor. ; ; virtual voidAfterStreamer (); ; voidCheckShape (Int_t testNo, Int_t nsamples=10000, Option_t *option=""""); Test for shape navigation methods. ; ; virtual voidClearThreadData () const; ; virtual voidCreateThreadData (Int_t); ; voidDraw (Option_t *option="""") override; Draw this shape. ; ; voidExecuteEvent (Int_t event, Int_t px, Int_t py) override; Execute mouse actions on this shape. ; ; Int_tGetId () const; ; const char *GetName () const override; Get the shape name. ; ; const char *GetPointerName () const; Provide a pointer name containing uid. ; ; voidInvertShapeBit (UInt_t f); ; TClass *IsA () const override; ; virtual Bool_tIsAssembly () const; ; virtual Bool_tIsComposite () const; ; virtual Bool_tIsReflected () const; ; Bool_tIsRunTimeShape () const; ; Bool_tIsValid () const; ; virtual Bool_tIsVecGeom () const; ; voidPaint (Option_t *option="""") override; Paint this shape. ; ; voidResetShapeBit (UInt_t f); ; voidSetId (Int_t id); ; voidSetRuntime (Bool_t flag=kTRUE); ; voidSetShapeBit (UInt_t f); ; vo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoCone.html:5136,test,testNo,5136,doc/master/classTGeoCone.html,https://root.cern,https://root.cern/doc/master/classTGeoCone.html,2,['test'],['testNo']
Testability,"le_t *dir) const override; ; virtual Double_tGetDX () const; ; virtual Double_tGetDY () const; ; virtual Double_tGetDZ () const; ; virtual Double_tGetFacetArea (Int_t index=0) const; ; Int_tGetFittingBox (const TGeoBBox *parambox, TGeoMatrix *mat, Double_t &dx, Double_t &dy, Double_t &dz) const override; ; virtual const Double_t *GetOrigin () const; ; virtual Bool_tGetPointsOnFacet (Int_t index, Int_t npoints, Double_t *array) const; ; virtual Bool_tIsNullBox () const; ; Bool_tIsValidBox () const override; ; voidSetBoxDimensions (Double_t dx, Double_t dy, Double_t dz, Double_t *origin=nullptr); ; voidSetBoxPoints (Double_t *points) const; ; voidStreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b); ; Public Member Functions inherited from TGeoShape; TGeoShape (); Default constructor. ; ; TGeoShape (const char *name); Default constructor. ; ; ~TGeoShape () override; Destructor. ; ; virtual voidAfterStreamer (); ; voidCheckShape (Int_t testNo, Int_t nsamples=10000, Option_t *option=""""); Test for shape navigation methods. ; ; virtual voidClearThreadData () const; ; virtual voidCreateThreadData (Int_t); ; voidDraw (Option_t *option="""") override; Draw this shape. ; ; voidExecuteEvent (Int_t event, Int_t px, Int_t py) override; Execute mouse actions on this shape. ; ; Int_tGetId () const; ; const char *GetName () const override; Get the shape name. ; ; const char *GetPointerName () const; Provide a pointer name containing uid. ; ; voidInvertShapeBit (UInt_t f); ; virtual Bool_tIsAssembly () const; ; virtual Bool_tIsComposite () const; ; virtual Bool_tIsReflected () const; ; Bool_tIsRunTimeShape () const; ; Bool_tIsValid () const; ; virtual Bool_tIsVecGeom () const; ; voidPaint (Option_t *option="""") override; Paint this shape. ; ; voidResetShapeBit (UInt_t f); ; voidSetId (Int_t id); ; voidSetRuntime (Bool_t flag=kTRUE); ; voidSetShapeBit (UInt_t f); ; voidSetShapeBit (UInt_t f, Bool_t se",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoEltu.html:7841,test,testNo,7841,doc/master/classTGeoEltu.html,https://root.cern,https://root.cern/doc/master/classTGeoEltu.html,5,['test'],['testNo']
Testability,"le_t *dir) const override; ; virtual Double_tGetDX () const; ; virtual Double_tGetDY () const; ; virtual Double_tGetDZ () const; ; virtual Double_tGetFacetArea (Int_t index=0) const; ; Int_tGetFittingBox (const TGeoBBox *parambox, TGeoMatrix *mat, Double_t &dx, Double_t &dy, Double_t &dz) const override; ; virtual const Double_t *GetOrigin () const; ; virtual Bool_tGetPointsOnFacet (Int_t index, Int_t npoints, Double_t *array) const; ; virtual Bool_tIsNullBox () const; ; Bool_tIsValidBox () const override; ; voidSetBoxDimensions (Double_t dx, Double_t dy, Double_t dz, Double_t *origin=nullptr); ; voidSetBoxPoints (Double_t *points) const; ; voidStreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b); ; Public Member Functions inherited from TGeoShape; TGeoShape (); Default constructor. ; ; TGeoShape (const char *name); Default constructor. ; ; ~TGeoShape () override; Destructor. ; ; virtual voidAfterStreamer (); ; voidCheckShape (Int_t testNo, Int_t nsamples=10000, Option_t *option=""""); Test for shape navigation methods. ; ; voidDraw (Option_t *option="""") override; Draw this shape. ; ; voidExecuteEvent (Int_t event, Int_t px, Int_t py) override; Execute mouse actions on this shape. ; ; Int_tGetId () const; ; const char *GetName () const override; Get the shape name. ; ; const char *GetPointerName () const; Provide a pointer name containing uid. ; ; voidInvertShapeBit (UInt_t f); ; TClass *IsA () const override; ; virtual Bool_tIsAssembly () const; ; virtual Bool_tIsComposite () const; ; virtual Bool_tIsReflected () const; ; Bool_tIsRunTimeShape () const; ; Bool_tIsValid () const; ; virtual Bool_tIsVecGeom () const; ; voidPaint (Option_t *option="""") override; Paint this shape. ; ; voidResetShapeBit (UInt_t f); ; voidSetId (Int_t id); ; voidSetRuntime (Bool_t flag=kTRUE); ; voidSetShapeBit (UInt_t f); ; voidSetShapeBit (UInt_t f, Bool_t set); Equivalent of TObject::SetBit. ; ; Int_tSh",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoPgon.html:6281,test,testNo,6281,doc/master/classTGeoPgon.html,https://root.cern,https://root.cern/doc/master/classTGeoPgon.html,1,['test'],['testNo']
Testability,"le_t A2) const; voidSetCDF(); voidSetDistributionFunction(const ROOT::Math::IGenFunction& cdf, Bool_t isPDF, Double_t xmin, Double_t xmax); voidSetParameters(); voidSetSamples(vector<const Double_t*> samples, const vector<UInt_t> samplesSizes). Data Members; public:. enum EDistribution { kUndefined; kUserDefined; kGaussian; kLogNormal; kExponential; };; enum EUserDistribution { kCDF; kPDF; };; enum ETestType { kAD; kAD2s; kKS; kKS2s; };. private:. auto_ptr<ROOT::Math::IBaseFunctionOneDim>fCDF; vector<Double_t>fCombinedSamples; ROOT::Math::GoFTest::EDistributionfDist; Double_tfMean; vector<std::vector<Double_t> >fSamples; Double_tfSigma; Bool_tfTestSampleFromH0. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; GoFTest(UInt_t sample1Size, const Double_t* sample1, UInt_t sample2Size, const Double_t* sample2); Constructor for using only with 2-samples tests. GoFTest(UInt_t sampleSize, const Double_t* sample, ROOT::Math::GoFTest::EDistribution dist = kUndefined); Constructor for using only with 1-sample tests with a specified distribution. GoFTest(UInt_t sampleSize, const Double_t* sample, const ROOT::Math::IGenFunction& dist, ROOT::Math::GoFTest::EUserDistribution userDist = kPDF, Double_t xmin = 1, Double_t xmax = 0); Templated constructor for using only with 1-sample tests with a user specified distribution. Instantiate(const Double_t* sample, UInt_t sampleSize). GoFTest(UInt_t sampleSize, const Double_t* sample, const ROOT::Math::IGenFunction& dist, ROOT::Math::GoFTest::EUserDistribution userDist = kPDF, Double_t xmin = 1, Double_t xmax = 0); Specialization using IGenFunction interface. SetUserDistribution(const ROOT::Math::IGenFunction& dist, ROOT::Math::GoFTest::EUserDistribution userDist = kPDF, Double_t xmin = 1, Double_t xmax = 0). SetDistributionFunction(const ROOT::Math::IGenFunction& cdf, Bool_t isPDF, Double_t xmin, Double_t xmax). void SetUserPDF(const ROOT::Math::IGenFunction& pdf, Double_t xmin = 1, Double_t xmax ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/ROOT__Math__GoFTest.html:3710,test,tests,3710,root/html534/ROOT__Math__GoFTest.html,https://root.cern,https://root.cern/root/html534/ROOT__Math__GoFTest.html,1,['test'],['tests']
Testability,"le_t fac = -2.*gamma[bin] * rr / beta[bin] / beta[bin];; 2064 if (fac != 0 && fac <= 1); 2065 xx = (-beta[bin] + TMath::Sqrt(beta[bin] * beta[bin] + 2 * gamma[bin] * rr)) / gamma[bin];; 2066 else if (beta[bin] != 0.); 2067 xx = rr / beta[bin];; 2068 xp[i] = alpha[bin] + xx;; 2069 } else {; 2070 xp[i] = alpha[bin];; 2071 if (integral[bin + 1] == r) xp[i] += dx;; 2072 }; 2073 }; 2074 ; 2075 return n;; 2076}; 2077////////////////////////////////////////////////////////////////////////////////; 2078///; 2079/// Compute the cumulative function at fNpx points between fXmin and fXmax.; 2080/// Option can be used to force a log scale (option = ""log""), linear (option = ""lin"") or automatic if empty.; 2081Bool_t TF1::ComputeCdfTable(Option_t * option) {; 2082 ; 2083 fIntegral.resize(fNpx + 1);; 2084 fAlpha.resize(fNpx + 1);; 2085 fBeta.resize(fNpx);; 2086 fGamma.resize(fNpx);; 2087 fIntegral[0] = 0;; 2088 fAlpha[fNpx] = 0;; 2089 Double_t integ;; 2090 Int_t intNegative = 0;; 2091 Int_t i;; 2092 Bool_t logbin = kFALSE;; 2093 Double_t dx;; 2094 Double_t xmin = fXmin;; 2095 Double_t xmax = fXmax;; 2096 TString opt(option);; 2097 opt.ToUpper();; 2098 // perform a log binning if specified by user (option=""Log"") or if some conditions are met; 2099 // and the user explicitly does not specify a Linear binning option; 2100 if (opt.Contains(""LOG"") || ((xmin > 0 && xmax / xmin > fNpx) && !opt.Contains(""LIN""))) {; 2101 logbin = kTRUE;; 2102 fAlpha[fNpx] = 1;; 2103 xmin = TMath::Log10(fXmin);; 2104 xmax = TMath::Log10(fXmax);; 2105 if (gDebug); 2106 Info(""GetRandom"", ""Use log scale for tabulating the integral in [%f,%f] with %d points"", fXmin, fXmax, fNpx);; 2107 }; 2108 dx = (xmax - xmin) / fNpx;; 2109 ; 2110 std::vector<Double_t> xx(fNpx + 1);; 2111 for (i = 0; i < fNpx; i++) {; 2112 xx[i] = xmin + i * dx;; 2113 }; 2114 xx[fNpx] = xmax;; 2115 for (i = 0; i < fNpx; i++) {; 2116 if (logbin) {; 2117 integ = Integral(TMath::Power(10, xx[i]), TMath::Power(10, xx[i + 1]), 0.0);; 2118 } else {; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TF1_8cxx_source.html:76781,log,logbin,76781,doc/master/TF1_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html,1,['log'],['logbin']
Testability,"le_t getPdfParamErr(Int_t index); Access PDF parameter error by ordinal index (needed by MINUIT). Bool_t setPdfParamVal(Int_t index, Double_t value, Bool_t verbose = kFALSE); Modify PDF parameter value by ordinal index (needed by MINUIT). void setPdfParamErr(Int_t index, Double_t value); Modify PDF parameter error by ordinal index (needed by MINUIT). void clearPdfParamAsymErr(Int_t index); Modify PDF parameter error by ordinal index (needed by MINUIT). void setPdfParamErr(Int_t index, Double_t loVal, Double_t hiVal); Modify PDF parameter error by ordinal index (needed by MINUIT). void profileStart(); Start profiling timer. void profileStop(); Stop profiling timer and report results of last session. void backProp(); Transfer MINUIT fit results back into RooFit objects. void updateFloatVec(). void applyCovarianceMatrix(TMatrixDSym& V); Apply results of given external covariance matrix. i.e. propagate its errors; to all RRV parameter representations and give this matrix instead of the; HESSE matrix at the next save() call. RooMinuit(RooAbsReal& function). void setEvalErrorWall(Bool_t flag); { _doEvalErrorWall = flag ; }. void setPrintEvalErrors(Int_t numEvalErrors); { _printEvalErrors = numEvalErrors ; }. void setVerbose(Bool_t flag = kTRUE); { _verbose = flag ; }. void setProfile(Bool_t flag = kTRUE); { _profile = flag ; }. void setMaxEvalMultiplier(Int_t n); { _maxEvalMult = n ; }. Int_t evalCounter() const; { return _evalCounter ; }. void zeroEvalCount(); { _evalCounter = 0 ; }. Int_t getNPar() const; { return _nPar ; }. std::ofstream* logfile() const; { return _logfile ; }. Double_t& maxFCN(); { return _maxFCN ; }. void saveStatus(const char* label, Int_t status); { _statusHistory.push_back(std::pair<std::string,int>(label,status)) ; }.  Last changed: Tue Jun 30 14:34:01 2015  Last generated: 2015-06-30 14:34; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooMinuit.html:15326,log,logfile,15326,root/html602/RooMinuit.html,https://root.cern,https://root.cern/root/html602/RooMinuit.html,1,['log'],['logfile']
Testability,"le_t getPdfParamErr(Int_t index); Access PDF parameter error by ordinal index (needed by MINUIT). Bool_t setPdfParamVal(Int_t index, Double_t value, Bool_t verbose = kFALSE); Modify PDF parameter value by ordinal index (needed by MINUIT). void setPdfParamErr(Int_t index, Double_t value); Modify PDF parameter error by ordinal index (needed by MINUIT). void clearPdfParamAsymErr(Int_t index); Modify PDF parameter error by ordinal index (needed by MINUIT). void setPdfParamErr(Int_t index, Double_t loVal, Double_t hiVal); Modify PDF parameter error by ordinal index (needed by MINUIT). void profileStart(); Start profiling timer. void profileStop(); Stop profiling timer and report results of last session. void backProp(); Transfer MINUIT fit results back into RooFit objects. void updateFloatVec(). void applyCovarianceMatrix(TMatrixDSym& V); Apply results of given external covariance matrix. i.e. propagate its errors; to all RRV parameter representations and give this matrix instead of the; HESSE matrix at the next save() call. RooMinuit(RooAbsReal& function). void setEvalErrorWall(Bool_t flag); { _doEvalErrorWall = flag ; }. void setPrintEvalErrors(Int_t numEvalErrors); { _printEvalErrors = numEvalErrors ; }. void setVerbose(Bool_t flag = kTRUE); { _verbose = flag ; }. void setProfile(Bool_t flag = kTRUE); { _profile = flag ; }. void setMaxEvalMultiplier(Int_t n); { _maxEvalMult = n ; }. Int_t evalCounter() const; { return _evalCounter ; }. void zeroEvalCount(); { _evalCounter = 0 ; }. Int_t getNPar() const; { return _nPar ; }. std::ofstream* logfile() const; { return _logfile ; }. Double_t& maxFCN(); { return _maxFCN ; }. void saveStatus(const char* label, Int_t status); { _statusHistory.push_back(std::pair<std::string,int>(label,status)) ; }.  Last changed: Tue Mar 10 17:17:50 2015  Last generated: 2015-03-10 17:17; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooMinuit.html:14699,log,logfile,14699,root/html534/RooMinuit.html,https://root.cern,https://root.cern/root/html534/RooMinuit.html,1,['log'],['logfile']
Testability,"le_tfAquadratic coeff.; Double_tfBZ value of parabola at x=y=0; Double_tfDzrange on Z axis [-dz, dz]; Double_tfRhiradius at z=+dz; Double_tfRloradius at z=-dz. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoParaboloid(); Dummy constructor. TGeoParaboloid(Double_t rlo, Double_t rhi, Double_t dz); Default constructor specifying X and Y semiaxis length. TGeoParaboloid(const char* name, Double_t rlo, Double_t rhi, Double_t dz); Default constructor specifying X and Y semiaxis length. TGeoParaboloid(Double_t* params); Default constructor specifying minimum and maximum radius; param[0] = rlo; param[1] = rhi; param[2] = dz. ~TGeoParaboloid(); destructor. Double_t Capacity() const; Computes capacity of the shape in [length^3]. void ComputeBBox(); compute bounding box of the tube. void ComputeNormal(const Double_t* point, const Double_t* dir, Double_t* norm); Compute normal to closest surface from POINT. Bool_t Contains(const Double_t* point) const; test if point is inside the elliptical tube. Int_t DistancetoPrimitive(Int_t px, Int_t py); compute closest distance from point px,py to each vertex. Double_t DistToParaboloid(const Double_t* point, const Double_t* dir, Bool_t in) const; Compute distance from a point to the parabola given by:; z = a*rsq + b; rsq = x*x+y*y. Double_t DistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from inside point to surface of the paraboloid. Double_t DistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from outside point to surface of the paraboloid and safe distance. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); Divide the paraboloid along one axis. void GetBoundingCylinder(Double_t* param) const; --- Fill vector param[4] with",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoParaboloid.html:13763,test,test,13763,root/html534/TGeoParaboloid.html,https://root.cern,https://root.cern/root/html534/TGeoParaboloid.html,3,['test'],['test']
Testability,"leanup enum valueTObject; kNoContextMenu enum valueTObject; kNoStats enum valueTGraph; kNotDeleted enum valueTObject; kNotEditable enum valueTGraph; kObjInCanvas enum valueTObject; kOnlyPrepStep enum valueTObjectprotected; kOverwrite enum valueTObject; kResetHisto enum valueTGraph; kSingleKey enum valueTObject; kWriteDelete enum valueTObject; kZombie enum valueTObject; LeastSquareFit(Int_t m, Double_t *a, Double_t xmin=0, Double_t xmax=0)TGraphvirtual; LeastSquareLinearFit(Int_t n, Double_t &a0, Double_t &a1, Int_t &ifail, Double_t xmin=0, Double_t xmax=0)TGraphvirtual; ls(Option_t *option="""") const overrideTNamedvirtual; MakeFunctionQuantiles()TGraphQQprotected; MakeQuantiles()TGraphQQprotected; MakeZombie()TObjectinlineprotected; MayNotUse(const char *method) constTObject; Merge(TCollection *list)TGraphvirtual; TAttLine::Modify()TAttLinevirtual; TAttFill::Modify()TAttFillvirtual; TAttMarker::Modify()TAttMarkervirtual; MovePoints(Double_t dx, Double_t dy, Bool_t logx=kFALSE, Bool_t logy=kFALSE)TGraphvirtual; Notify()TObjectvirtual; Obsolete(const char *method, const char *asOfVers, const char *removedFromVers) constTObject; operator delete(void *ptr)TObject; operator delete(void *ptr, void *vp)TObject; operator delete[](void *ptr)TObject; operator delete[](void *ptr, void *vp)TObject; operator new(size_t sz)TObjectinline; operator new(size_t sz, void *vp)TObjectinline; operator new[](size_t sz)TObjectinline; operator new[](size_t sz, void *vp)TObjectinline; operator=(const TGraph &)TGraph; TNamed::operator=(const TNamed &rhs)TNamed; TObject::operator=(const TObject &rhs)TObjectinline; Paint(Option_t *chopt="""") overrideTGraphvirtual; PaintGraph(Int_t npoints, const Double_t *x, const Double_t *y, Option_t *chopt)TGraph; PaintGrapHist(Int_t npoints, const Double_t *x, const Double_t *y, Option_t *chopt)TGraph; PaintStats(TF1 *fit)TGraphvirtual; Pop()TObjectvirtual; Print(Option_t *chopt="""") const overrideTGraphvirtual; Quartiles()TGraphQQprotected; Read(const char *na",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGraphQQ-members.html:9335,log,logy,9335,doc/master/classTGraphQQ-members.html,https://root.cern,https://root.cern/doc/master/classTGraphQQ-members.html,1,['log'],['logy']
Testability,"leanup in this composite frame and all child composite frames (hierarchical); Attention! Hierarchical cleaning is dangerous and must be used with caution. There are many GUI components (in ROOT and in user code) which do not use Clean method in destructor (""custom deallocation""). Adding such component to GUI container which is using hierarchical cleaning will produce seg. violation when container is deleted. The reason is double deletion: first when Clean method is invoked, then at ""custom deallocation"". We are going to correct all ROOT code to make it to be consistent with hierarchical cleaning scheme. ; Reimplemented from TGFrame.; Definition at line 1072 of file TGFrame.cxx. SetEditable(). void TGCompositeFrame::SetEditable ; (; Bool_t; on = kTRUE). overridevirtual . Switch ON/OFF edit mode. ; If edit mode is ON it is possible:. embed other ROOT GUI application (a la ActiveX). For example: TGMainFrame *m = new TGMainFrame(gClient->GetRoot(), 500, 500); m->SetEditable(); gSystem->Load(""$ROOTSYS/test/Aclock""); // load Aclock demo Aclock a; gROOT->Macro(""$ROOTSYS/tutorials/gui/guitest.C""); m->SetEditable(0); m->MapWindow(); ; Reimplemented from TGWindow.; Reimplemented in TRootContainer, and TRootEmbeddedContainer.; Definition at line 948 of file TGFrame.cxx. SetEditDisabled(). void TGCompositeFrame::SetEditDisabled ; (; UInt_t; on = 1). overridevirtual . Set edit disable flag for this frame and subframes. . if (on & kEditDisable) - disable edit for this frame and all subframes. . Reimplemented from TGWindow.; Definition at line 1022 of file TGFrame.cxx. SetLayoutBroken(). void TGCompositeFrame::SetLayoutBroken ; (; Bool_t; on = kTRUE). overridevirtual . Set broken layout. No Layout method is called. ; Reimplemented from TGFrame.; Definition at line 1012 of file TGFrame.cxx. SetLayoutManager(). void TGCompositeFrame::SetLayoutManager ; (; TGLayoutManager *; l). virtual . Set the layout manager for the composite frame. ; The layout manager is adopted by t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGCompositeFrame.html:46096,test,test,46096,doc/master/classTGCompositeFrame.html,https://root.cern,https://root.cern/doc/master/classTGCompositeFrame.html,1,['test'],['test']
Testability,"lear();; 348 ; 349 // need to check for both exact and derived (differences exist between older and newer; 350 // versions of python ... bug?); 351 if ((pyModName && pyClName) && ((PyUnicode_CheckExact(pyModName) && PyUnicode_CheckExact(pyClName)) ||; 352 (PyUnicode_Check(pyModName) && PyUnicode_Check(pyClName)))) {; 353 // build full, qualified name; 354 std::string fullname = PyUnicode_AsUTF8(pyModName);; 355 fullname += '.';; 356 fullname += PyUnicode_AsUTF8(pyClName);; 357 ; 358 // force class creation (this will eventually call TPyClassGenerator); 359 TClass::GetClass(fullname.c_str(), kTRUE);; 360 }; 361 ; 362 Py_XDECREF(pyClName);; 363 Py_XDECREF(pyModName);; 364 }; 365 }; 366 ; 367 Py_DECREF(value);; 368 }; 369 ; 370 Py_DECREF(current);; 371 Py_DECREF(old);; 372}; 373 ; 374////////////////////////////////////////////////////////////////////////////////; 375/// Execute a python stand-alone script, with argv CLI arguments.; 376///; 377/// example of use:; 378/// const char* argv[] = { ""1"", ""2"", ""3"" };; 379/// TPython::ExecScript( ""test.py"", sizeof(argv)/sizeof(argv[0]), argv );; 380 ; 381void TPython::ExecScript(const char *name, int argc, const char **argv); 382{; 383 ; 384 // setup; 385 if (!Initialize()); 386 return;; 387 ; 388 PyGILRAII gilRaii;; 389 ; 390 // verify arguments; 391 if (!name) {; 392 std::cerr << ""Error: no file name specified."" << std::endl;; 393 return;; 394 }; 395 ; 396 std::vector<std::string> args(argc);; 397 for (int i = 0; i < argc; ++i) {; 398 args[i] = argv[i];; 399 }; 400 CPyCppyy::ExecScript(name, args);; 401}; 402 ; 403////////////////////////////////////////////////////////////////////////////////; 404/// Executes a Python command within the current Python environment.; 405///; 406/// This function initializes the Python environment if it is not already; 407/// initialized. It then executes the specified Python command string using the; 408/// Python C API.; 409///; 410/// In the Python command, you can change the value of a spe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TPython_8cxx_source.html:12559,test,test,12559,doc/master/TPython_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TPython_8cxx_source.html,1,['test'],['test']
Testability,"learValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual voidTNamed::Copy(TObject& named) const; static voidRooAbsArg::copyList(TList& dest, const TList& source); static UInt_tRooAbsArg::crc32(const char* data); virtual RooAbsArg*RooAbsString::createFundamental(const char* newname = 0) const; virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTO",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooStringVar.html:2818,test,testArg,2818,root/html526/RooStringVar.html,https://root.cern,https://root.cern/root/html526/RooStringVar.html,3,['test'],['testArg']
Testability,"lease. ; . Protected Types; typedef std::pair< UInt_t, RootCsg::TBaseMesh * >CSPart_t; ; Protected Types inherited from TObject; enum { kOnlyPrepStep = (1ULL << ( 3 )); }; ; Protected Types inherited from TGLSceneBase; typedef std::list< TGLViewerBase * >::iteratorViewerList_i; ; typedef std::list< TGLViewerBase * >ViewerList_t; . Protected Member Functions; TGLLogicalShape *AttemptDirectRenderer (TObject *id); Try to construct an appropriate logical-shape sub-class based on id'class, following convention that SomeClassGL is a suitable renderer for class SomeClass. ; ; RootCsg::TBaseMesh *BuildComposite (); Build and return composite shape mesh. ; ; voidComposePolymarker (const TList *padPrimitives); ; TGLLogicalShape *CreateNewLogical (const TBuffer3D &buffer) const; Create and return a new TGLLogicalShape from the supplied buffer. ; ; TGLPhysicalShape *CreateNewPhysical (UInt_t physicalID, const TBuffer3D &buffer, const TGLLogicalShape &logical) const; Create and return a new TGLPhysicalShape with id 'ID', using 'buffer' placement information (translation etc), and bound to suppled 'logical'. ; ; Int_tValidateObjectBuffer (const TBuffer3D &buffer, Bool_t includeRaw) const; Validate if the passed 'buffer' contains all sections we require to add object. ; ; Protected Member Functions inherited from TObject; virtual voidDoError (int level, const char *location, const char *fmt, va_list va) const; Interface to ErrorHandler (protected). ; ; voidMakeZombie (); ; Protected Member Functions inherited from TGLScene; virtual voidDestroyPhysicalInternal (PhysicalShapeMapIt_t pit); Virtual function to destroy a physical. ; ; voidReleaseGLCtxIdentity (); Release all GL resources for current context identity. ; . Protected Attributes; Int_tfAcceptedPhysicals; last physical ID that was processed in AddObject() ; ; TGLFaceSet *fComposite; ; UInt_tfCSLevel; Paritally created composite. ; ; std::vector< CSPart_t >fCSTokens; ; Bool_",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGLScenePad.html:20808,log,logical,20808,doc/master/classTGLScenePad.html,https://root.cern,https://root.cern/doc/master/classTGLScenePad.html,2,['log'],['logical']
Testability,"lection::kInitHashTableCapacity; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. Bool_tTList::fAscending! sorting order (when calling Sort() or for TSortedList); TObjLink*TList::fCache! cache to speedup sequential calling of Before() and After() functions; TQCommand*fCurrentthe latest executed command; TObjLink*fCursorcurrent position in history stack; TObjLink*TList::fFirst! pointer to first entry in linked list; TObjLink*TList::fLast! pointer to last entry in linked list; UInt_tfLimitmaximum number of commands can be located in stack; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; TList*fLogBooklisting of all actions during execution; Bool_tfLoggingkTRUE if logging is ON; Int_tTQCommand::fNRargsnumber of redo arguments; Int_tTQCommand::fNUargsnumber of undo arguments; TStringTQCommand::fNamecommand name. Default is ""ClassName::RedoName(args)""; TStringTCollection::fNamename of the collection; Bool_tTQCommand::fNewDeletekTRUE if Redo/Undo methods are new/delete; void*TQCommand::fObjectobject to which undo/redo actions applied; TQConnection*TQCommand::fRedodo/redo action; Long_t*TQCommand::fRedoArgsredo values; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; Int_tTCollection::fSizenumber of elements in collection; Bool_tTSeqCollection::fSortedtrue if collection has been sorted; Int_tTQCommand::fState-1 undoing on, 1 redoing on, 0 nothing in progress; Int_tTQC",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TQUndoManager.html:18240,log,logging,18240,root/html602/TQUndoManager.html,https://root.cern,https://root.cern/root/html602/TQUndoManager.html,2,['log'],['logging']
Testability,"led automatically; from inside GetSamplingDistribution when no ProofConfig is given.; You should not call this function yourself. This function should; be used by ToyMCStudy on the workers (ie. when you explicitly want; a serial run although ProofConfig is present). void GenerateGlobalObservables() const. RooAbsData* GenerateToyData(RooArgSet& paramPoint, double& weight) const; This method generates a toy data set for the given parameter point taking; global observables into account.; The values of the generated global observables remain in the pdf's variables.; They have to have those values for the subsequent evaluation of the; test statistics. RooAbsData* GenerateToyDataImportanceSampling(RooArgSet& paramPoint, double& weight) const; This method generates a toy data set for importance sampling for the given parameter point taking; global observables into account.; The values of the generated global observables remain in the pdf's variables.; They have to have those values for the subsequent evaluation of the; test statistics. RooAbsData* Generate(RooAbsPdf& pdf, RooArgSet& observables, const RooDataSet* protoData = NULL, int forceEvents = 0) const; This is the generate function to use in the context of the ToyMCSampler; instead of the standard RooAbsPdf::generate(...).; It takes into account whether the number of events is given explicitly; or whether it should use the expected number of events. It also takes; into account the option to generate a binned data set (ie RooDataHist). ToyMCSampler(); Proof constructor. Do not use. ToyMCSampler(RooStats::TestStatistic& ts, Int_t ntoys). void SetAlwaysUseMultiGen(Bool_t flag); { fgAlwaysUseMultiGen = flag ; }. void SetUseMultiGen(Bool_t flag); { fUseMultiGen = flag ; }. RooAbsData* GenerateToyData(RooArgSet& paramPoint) const; generates toy data; without weight. SamplingDistribution* AppendSamplingDistribution(RooArgSet& allParameters, RooStats::SamplingDistribution* last, Int_t additionalMC); Extended interface to appe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooStats__ToyMCSampler.html:5980,test,test,5980,root/html530/RooStats__ToyMCSampler.html,https://root.cern,https://root.cern/root/html530/RooStats__ToyMCSampler.html,1,['test'],['test']
Testability,"led automatically; from inside GetSamplingDistribution when no ProofConfig is given.; You should not call this function yourself. This function should; be used by ToyMCStudy on the workers (ie. when you explicitly want; a serial run although ProofConfig is present). void GenerateGlobalObservables() const. RooAbsData* GenerateToyData(RooArgSet& paramPoint, double& weight) const; This method generates a toy data set for the given parameter point taking; global observables into account.; The values of the generated global observables remain in the pdf's variables.; They have to have those values for the subsequent evaluation of the; test statistics. RooAbsData* GenerateToyDataImportanceSampling(RooArgSet& paramPoint, double& weight) const; This method generates a toy data set for importance sampling for the given parameter point taking; global observables into account.; The values of the generated global observables remain in the pdf's variables.; They have to have those values for the subsequent evaluation of the; test statistics. RooAbsData* Generate(RooAbsPdf& pdf, RooArgSet& observables, const RooDataSet* protoData = NULL, int forceEvents = 0) const; This is the generate function to use in the context of the ToyMCSampler; instead of the standard RooAbsPdf::generate(...).; It takes into account whether the number of events is given explicitly; or whether it should use the expected number of events. It also takes; into account the option to generate a binned data set (ie RooDataHist). void ClearCache(); clear the cache obtained from the pdf used for speeding the toy and global observables generation; needs to be called every time the model pdf (fPdf) changes. ToyMCSampler(); Proof constructor. Do not use. ToyMCSampler(RooStats::TestStatistic& ts, Int_t ntoys). void SetAlwaysUseMultiGen(Bool_t flag); { fgAlwaysUseMultiGen = flag ; }. void SetUseMultiGen(Bool_t flag); { fUseMultiGen = flag ; }. RooAbsData* GenerateToyData(RooArgSet& paramPoint) const; generates toy data",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooStats__ToyMCSampler.html:6160,test,test,6160,root/html532/RooStats__ToyMCSampler.html,https://root.cern,https://root.cern/root/html532/RooStats__ToyMCSampler.html,1,['test'],['test']
Testability,"led from TH1::Fit)Definition HFitImpl.cxx:972; ROOT::Fit::Chisquaredouble Chisquare(const TH1 &h1, TF1 &f1, bool useRange, EChisquareType type)compute the chi2 value for an histogram given a function (see TH1::Chisquare for the documentation)Definition HFitImpl.cxx:1027; ROOT::Fit::FitOptionsMakevoid FitOptionsMake(EFitObjectType type, const char *option, Foption_t &fitOption)Decode list of options into fitOption.Definition HFitImpl.cxx:685; ROOT::Fit::EFitObjectType::kGraph@ kGraph; TMath::IsInsideBool_t IsInside(T xp, T yp, Int_t np, T *x, T *y)Function which returns kTRUE if point xp,yp lies inside the polygon defined by the np points in array...Definition TMath.h:1233; TMath::ExpDouble_t Exp(Double_t x)Returns the base-e exponential function of x, which is e raised to the power x.Definition TMath.h:709; TMath::ATan2Double_t ATan2(Double_t y, Double_t x)Returns the principal value of the arc tangent of y/x, expressed in radians.Definition TMath.h:646; TMath::LogDouble_t Log(Double_t x)Returns the natural logarithm of x.Definition TMath.h:756; TMath::SqrtDouble_t Sqrt(Double_t x)Returns the square root of x.Definition TMath.h:662; TMath::MinShort_t Min(Short_t a, Short_t b)Returns the smallest of a and b.Definition TMathBase.h:198; TMath::Sortvoid Sort(Index n, const Element *a, Index *index, Bool_t down=kTRUE)Sort the n elements of the array a of generic templated type Element.Definition TMathBase.h:431; TMath::BinarySearchLong64_t BinarySearch(Long64_t n, const T *array, T value)Binary search in an array of n values to locate value.Definition TMathBase.h:347; TMath::AbsShort_t Abs(Short_t d)Returns the absolute value of parameter Short_t d.Definition TMathBase.h:123; Foption_tDefinition Foption.h:24; Drawth1 Draw(); mTMarker mDefinition textangle.C:8; lTLine lDefinition textangle.C:4; sumstatic uint64_t sum(uint64_t i)Definition Factory.cxx:2345. histhistsrcTGraph.cxx. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:40:33 (GVA Time) using Doxygen 1.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGraph_8cxx_source.html:139448,log,logarithm,139448,doc/master/TGraph_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGraph_8cxx_source.html,1,['log'],['logarithm']
Testability,"left|; \begin{array}{ccc}; xx & xy & xz \\; yx & yy & yz \\; zx & zy & zz; \end{array}; \right|\]; It describes a so-called active rotation, i.e.a rotation of objects inside a static system of coordinates. In case you want to rotate the frame and want to know the coordinates of objects in the rotated system, you should apply the inverse rotation to the objects. If you want to transform coordinates from the rotated frame to the original frame you have to apply the direct transformation. A rotation around a specified axis means counterclockwise rotation around the positive direction of the axis.; 17.3.1 Declaration, Access, Comparisons; TRotation r; // r initialized as identity; TRotation m(r); // m = r; There is no direct way to set the matrix elements - to ensure that a TRotation always describes a real rotation. But you can get the values by with the methods XX()..ZZ() or the (,) operator:; Double_t xx = r.XX(); // the same as xx=r(0,0); xx = r(0,0);; if (r==m) {...} // test for equality; if (r!=m) {..} // test for inequality; if (r.IsIdentity()) {...} // test for identity; 17.3.2 Rotation around Axes; The following matrices describe counter-clockwise rotations around the coordinate axes and are implemented in: RotateX(),RotateY() and RotateZ():; \[; Rx(a) = \left|; \begin{array}{ccc}; 1 & 0 & 0 \\; 0 & cos(a) & -sin(a) \\; 0 & sin(a) & cos(a); \end{array}; \right|; Ry(a) = \left|; \begin{array}{ccc}; cos(a) & 0 & sin(a) \\; 0 & 1 & 0 \\; -sin(a) & 0 & cos(a); \end{array}; \right|; Rz(a) = \left|; \begin{array}{ccc}; cos(a) & -sin(a) & 0 \\; sin(a) & cos(a) & 0 \\; 0 & 0 & 1; \end{array}; \right|; \]; r.RotateX(TMath::Pi()); // rotation around the x-axis; 17.3.3 Rotation around Arbitrary Axis; The Rotate() method allows you to rotate around an arbitrary vector (not necessary a unit one) and returns the result.; r.Rotate(TMath::Pi()/3,TVector3(3,4,5));; It is possible to find a unit vector and an angle, which describe the same rotation as the current one:; Double_t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:863749,test,test,863749,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['test'],['test']
Testability,"lel() const; Bool_tTProof::IsProofd() const; virtual Bool_tTNamed::IsSortable() const; Bool_tTProof::IsValid() const; Bool_tTProof::IsWaiting() const; Bool_tTObject::IsZombie() const; virtual Int_tLoad(const char* macro, Bool_t notOnClient = kFALSE, Bool_t uniqueOnly = kTRUE, TList* wrks = 0); static voidTQObject::LoadRQ_OBJECT(); voidTProof::LogMessage(const char* msg, Bool_t all)SIGNAL ; static voidTProof::LogViewer(const char* url = 0, Int_t sessionidx = 0); virtual voidTQObject::LowPriority(const char* signal_name, const char* slot_name = 0); virtual voidTNamed::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual voidTQObject::Message(const char* msg)SIGNAL ; static TProofMgr*TProof::Mgr(const char* url); virtual Bool_tTObject::Notify(); virtual Int_tTQObject::NumberOfConnections() const; virtual Int_tTQObject::NumberOfSignals() const; static TProof*TProof::Open(const char* url = 0, const char* conffile = 0, const char* confdir = 0, Int_t loglevel = 0); static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); virtual voidTObject::Paint(Option_t* option = """"); Int_tTProof::Ping(); virtual voidTObject::Pop(); virtual voidPrint(Option_t* option = """") const; virtual Long64_tProcess(const char* sel, Long64_t nent, Option_t* o = """"); virtual Long64_tProcess(TDSet* dset, const char* sel, Option_t* o = """", Long64_t nent = -1, Long64_t fst = 0); virtual Long64_tProcess(TFileCollection* fc, const char* sel, Option_t* o = """", Long64_t nent = -1, Long64_t fst = 0); virtual Long64_tProcess(const char* dsname, const char* sel, Option_t* o = """", Long64_t nent = -1, Long64_t fst = 0, TObject* enl = 0); voidT",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TProofLite.html:11554,log,loglevel,11554,root/html528/TProofLite.html,https://root.cern,https://root.cern/root/html528/TProofLite.html,1,['log'],['loglevel']
Testability,"lelization. The second argument determines whether to split the task batches per event or per likelihood component. And the third argument how many events or respectively components to include in each batch. . TimingAnalysis(bool flag) Experimental - Log timings. This feature logs timings with NewStyle likelihoods on multiple processes simultaneously and outputs the timings at the end of a run to json log files, which can be analyzed with the RooFit::MultiProcess::HeatmapAnalyzer. Only works with simultaneous likelihoods. . PyROOT; The RooAbsPdf::fitTo() function is pythonized with the command argument pythonization. The keywords must correspond to the CmdArgs of the function. . Definition at line 157 of file RooAbsPdf.h. fitToImpl(). std::unique_ptr< RooFitResult > RooAbsPdf::fitToImpl ; (; RooAbsData &; data, . const RooLinkedList &; cmdList. ). protectedvirtual . Protected implementation of the likelihood fitting routine. ; This virtual function can be overridden in case you want to change the likelihood fitting logic for custom PDFs.; NoteNever call this function directly. Instead, call RooAbsPdf::fitTo(). ; Definition at line 1072 of file RooAbsPdf.cxx. genContext(). RooAbsGenContext * RooAbsPdf::genContext ; (; const RooArgSet &; vars, . const RooDataSet *; prototype = nullptr, . const RooArgSet *; auxProto = nullptr, . bool; verbose = false. ); const. virtual . Interface function to create a generator context from a p.d.f. ; This default implementation returns a 'standard' context that works for any p.d.f ; Reimplemented in RooEffProd, RooAbsAnaConvPdf, RooAddModel, RooAddPdf, RooFFTConvPdf, RooNumConvPdf, RooProdPdf, and RooSimultaneous.; Definition at line 1127 of file RooAbsPdf.cxx. generate() [1/6]. RooAbsPdf::generate ; (; const RooArgSet &; whatVars, . const RooCmdArg &; arg1 = {}, . const RooCmdArg &; arg2 = {}, . const RooCmdArg &; arg3 = {}, . const RooCmdArg &; arg4 = {}, . const RooCmdArg &; arg5 = {}, . const RooCmdArg &; arg6 ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsPdf.html:112227,log,logic,112227,doc/master/classRooAbsPdf.html,https://root.cern,https://root.cern/doc/master/classRooAbsPdf.html,1,['log'],['logic']
Testability,"lementPath_t &path1, const RElementPath_t &path2)Compare two paths, Returns number of elements matches in both paths.Definition RElement.cxx:145; ROOT::Browsable::RElement::ParsePathstatic RElementPath_t ParsePath(const std::string &str)Parse string path to produce RElementPath_t One should avoid to use string pathes as much as possible...Definition RElement.cxx:116; ROOT::Browsable::RItemRepresentation of single item in the browser.Definition RItem.hxx:23; ROOT::Browsable::RProvider::Browsestatic std::shared_ptr< RElement > Browse(std::unique_ptr< RHolder > &obj)Create browsable element for the object Created element may take ownership over the object.Definition RProvider.cxx:273; ROOT::Browsable::RSysFile::ProvideTopEntriesstatic RElementPath_t ProvideTopEntries(std::shared_ptr< RGroup > &comp, const std::string &workdir="""")Provide top entries for file system On windows it is list of existing drivers, on Linux it is ""File s...Definition RSysFile.cxx:533; ROOT::Experimental::RLogChannelA log configuration for a channel, e.g.Definition RLogger.hxx:101; ROOT::RBrowserDataCleanupDefinition RBrowserData.cxx:43; ROOT::RBrowserDataCleanup::fDataRBrowserData & fDataDefinition RBrowserData.cxx:45; ROOT::RBrowserDataCleanup::RBrowserDataCleanupRBrowserDataCleanup(RBrowserData &_data)Definition RBrowserData.cxx:48; ROOT::RBrowserDataCleanup::RecursiveRemovevoid RecursiveRemove(TObject *obj) overrideRecursively remove this object from a list.Definition RBrowserData.cxx:50; ROOT::RBrowserDataWay to browse (hopefully) everything in ROOT.Definition RBrowserData.hxx:37; ROOT::RBrowserData::SetTopElementvoid SetTopElement(std::shared_ptr< Browsable::RElement > elem)set top element for browsingDefinition RBrowserData.cxx:88; ROOT::RBrowserData::fLastSortedItemsstd::vector< const Browsable::RItem * > fLastSortedItems! sorted child items, used in requestsDefinition RBrowserData.hxx:51; ROOT::RBrowserData::fWorkingPathBrowsable::RElementPath_t fWorkingPath! path showed in BreadcrumbDef",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RBrowserData_8cxx_source.html:14837,log,log,14837,doc/master/RBrowserData_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RBrowserData_8cxx_source.html,2,['log'],['log']
Testability,"lementation (NO_ALTERNATIVE_QUEUE) as well. The new configuration value; 138 * ""CONNECTION_QUEUE_SIZE"" is only available for the previous queue; 139 * implementation, since the queue length is independent from the number of; 140 * worker threads there, while the new queue is one element per worker thread.; 141 *; 142 */; 143#if defined(NO_ALTERNATIVE_QUEUE) && defined(ALTERNATIVE_QUEUE); 144/* The queues are exclusive or - only one can be used. */; 145#error \; 146 ""Define ALTERNATIVE_QUEUE or NO_ALTERNATIVE_QUEUE (or none of them), but not both""; 147#endif; 148#if !defined(NO_ALTERNATIVE_QUEUE) && !defined(ALTERNATIVE_QUEUE); 149/* Use a default implementation */; 150#define NO_ALTERNATIVE_QUEUE; 151#endif; 152 ; 153#if defined(NO_FILESYSTEMS) && !defined(NO_FILES); 154/* File system access:; 155 * NO_FILES = do not serve any files from the file system automatically.; 156 * However, with NO_FILES CivetWeb may still write log files, read access; 157 * control files, default error page files or use API functions like; 158 * mg_send_file in callbacks to send files from the server local; 159 * file system.; 160 * NO_FILES only disables the automatic mapping between URLs and local; 161 * file names.; 162 * NO_FILESYSTEM = do not access any file at all. Useful for embedded; 163 * devices without file system. Logging to files in not available; 164 * (use callbacks instead) and API functions like mg_send_file are not; 165 * available.; 166 * If NO_FILESYSTEM is set, NO_FILES must be set as well.; 167 */; 168#error ""Inconsistent build flags, NO_FILESYSTEMS requires NO_FILES""; 169#endif; 170 ; 171/* DTL -- including winsock2.h works better if lean and mean */; 172#if !defined(WIN32_LEAN_AND_MEAN); 173#define WIN32_LEAN_AND_MEAN; 174#endif; 175 ; 176#if defined(__SYMBIAN32__); 177/* According to https://en.wikipedia.org/wiki/Symbian#History,; 178 * Symbian is no longer maintained since 2014-01-01.; 179 * Support for Symbian has been removed from CivetWeb; 180 */; 181#error ""S",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:6575,log,log,6575,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,2,['log'],['log']
Testability,"lerInstance->createOutputFile(fileName, /*Binary=*/true,; 2011 /*RemoveFileOnSignal=*/false,; 2012 /*useTemporary=*/false,; 2013 /*CreateMissingDirectories*/ false);; 2014 if (!out) {; 2015 ROOT::TMetaUtils::Error(""WriteAST"", ""Couldn't open output stream to '%s'!\n"", fileName.data());; 2016 return false;; 2017 }; 2018 ; 2019 compilerInstance->getFrontendOpts().RelocatablePCH = true;; 2020 ; 2021 writer.WriteAST(compilerInstance->getSema(), fileName.str(), module, iSysRoot);; 2022 ; 2023 // Write the generated bitstream to ""Out"".; 2024 out->write(&buffer.front(), buffer.size());; 2025 ; 2026 // Make sure it hits disk now.; 2027 out->flush();; 2028 ; 2029 return true;; 2030}; 2031 ; 2032////////////////////////////////////////////////////////////////////////////////; 2033/// Generates a PCH from the given ModuleGenerator and CompilerInstance.; 2034/// Returns true iff the PCH was successfully generated.; 2035static bool GenerateAllDict(TModuleGenerator &modGen, clang::CompilerInstance *compilerInstance,; 2036 const std::string &currentDirectory); 2037{; 2038 assert(modGen.IsPCH() && ""modGen must be in PCH mode"");; 2039 ; 2040 std::string iSysRoot(""/DUMMY_SYSROOT/include/"");; 2041 if (gBuildingROOT) iSysRoot = (currentDirectory + ""/"");; 2042 return WriteAST(modGen.GetModuleFileName(), compilerInstance, iSysRoot);; 2043}; 2044 ; 2045////////////////////////////////////////////////////////////////////////////////; 2046/// Includes all given headers in the interpreter. Returns true when we could; 2047/// include the headers and otherwise false on an error when including.; 2048static bool IncludeHeaders(const std::vector<std::string> &headers, cling::Interpreter &interpreter); 2049{; 2050 // If no headers are given, this is a no-op.; 2051 if (headers.empty()); 2052 return true;; 2053 ; 2054 // Turn every header name into an include and parse it in the interpreter.; 2055 std::stringstream includes;; 2056 for (const std::string &header : headers) {; 2057 includes << ""#include",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rootcling__impl_8cxx_source.html:80634,assert,assert,80634,doc/master/rootcling__impl_8cxx_source.html,https://root.cern,https://root.cern/doc/master/rootcling__impl_8cxx_source.html,1,['assert'],['assert']
Testability,"lete = (1ULL << ( 2 )); }; ; enum EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); }; ; enum EStatusBits { ; kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ; kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). }; ; Protected Types inherited from TObject; enum { kOnlyPrepStep = (1ULL << ( 3 )); }; ; Protected Member Functions inherited from TMVA::PDEFoamDensityBase; Double_tGetBoxVolume (); Returns the volume of range searching box fBox. ; ; MsgLogger &Log () const; ; Protected Member Functions inherited from TObject; virtual voidDoError (int level, const char *location, const char *fmt, va_list va) const; Interface to ErrorHandler (protected). ; ; voidMakeZombie (); ; Protected Attributes inherited from TMVA::PDEFoamDensityBase; BinarySearchTree *fBst; Binary tree to find events within a volume. ; ; MsgLogger *fLogger; ! message logger ; . #include <TMVA/PDEFoamEventDensity.h>. Inheritance diagram for TMVA::PDEFoamEventDensity:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. PDEFoamEventDensity() [1/3]. TMVA::PDEFoamEventDensity::PDEFoamEventDensity ; (; ). Definition at line 60 of file PDEFoamEventDensity.cxx. PDEFoamEventDensity() [2/3]. TMVA::PDEFoamEventDensity::PDEFoamEventDensity ; (; std::vector< Double_t >; box). User constructor. ; Parameters:. box - size of sampling box . Definition at line 71 of file PDEFoamEventDensity.cxx. PDEFoamEventDensity() [3/3]. TMVA::PDEFoamEventDensity::PDEFoamEventDensity ; (; const PDEFoamEventDensity &; distr). Copy constructor. ; Definition at line 79 of file PDEFoamEventDensity.cxx. ~PDEFoamEventDensity(). virtual TMVA::PDEFoamEventDensity::~PDEFoamEventDensity ; (; ). inlinevirtual . Definition at line 49 of file PDEFoamEventDensity.h. Member Function Docu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1PDEFoamEventDensity.html:11424,log,logger,11424,doc/master/classTMVA_1_1PDEFoamEventDensity.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1PDEFoamEventDensity.html,1,['log'],['logger']
Testability,"level = 2, one top level branch is created for each array element.; if, in turn, one of the array elements is a TCollection, one top level; branch will be created for each element of this collection. In case a collection element is a TClonesArray, the special Tree constructor; for TClonesArray is called.; The collection itself cannot be a TClonesArray. The function returns the total number of branches created. If name is given, all branch names will be prefixed with name_. IMPORTANT NOTE1: This function should not be called with splitlevel < 1. IMPORTANT NOTE2: The branches created by this function will have names; corresponding to the collection or object names. It is important; to give names to collections to avoid misleading branch names or; identical branch names. By default collections have a name equal to; the corresponding class name, e.g. the default name for a TList is ""TList"". Example--------------------------------------------------------------:. {; TTree T(""T"",""test list"");; TList *list = new TList();. TObjArray *a1 = new TObjArray();; a1->SetName(""a1"");; list->Add(a1);; TH1F *ha1a = new TH1F(""ha1a"",""ha1"",100,0,1);; TH1F *ha1b = new TH1F(""ha1b"",""ha1"",100,0,1);; a1->Add(ha1a);; a1->Add(ha1b);; TObjArray *b1 = new TObjArray();; b1->SetName(""b1"");; list->Add(b1);; TH1F *hb1a = new TH1F(""hb1a"",""hb1"",100,0,1);; TH1F *hb1b = new TH1F(""hb1b"",""hb1"",100,0,1);; b1->Add(hb1a);; b1->Add(hb1b);. TObjArray *a2 = new TObjArray();; a2->SetName(""a2"");; list->Add(a2);; TH1S *ha2a = new TH1S(""ha2a"",""ha2"",100,0,1);; TH1S *ha2b = new TH1S(""ha2b"",""ha2"",100,0,1);; a2->Add(ha2a);; a2->Add(ha2b);. T.Branch(list,16000,2);; T.Print();; }. Int_t Branch(const char* folder, Int_t bufsize = 32000, Int_t splitlevel = 99); Create one branch for each element in the folder.; Returns the total number of branches created. TBranch* Branch(const char* name, void* address, const char* leaflist, Int_t bufsize = 32000); Create a new TTree Branch. This Branch constructor is provided to support no",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TTree.html:45124,test,test,45124,root/html532/TTree.html,https://root.cern,https://root.cern/root/html532/TTree.html,1,['test'],['test']
Testability,"level"" of the null hypothesis. ; ; doubleCLsError () const; The error on the ratio \(CL_{s+b}/CL_{b}\). ; ; doubleCLsplusbError () const; The error on the ""confidence level"" of the alternative hypothesis. ; ; HybridPlot *GetPlot (const char *name, const char *title, int n_bins); prepare a plot showing a result and return a pointer to a HybridPlot object the needed arguments are: an object name, a title and the number of bins in the plot ; ; std::vector< double >GetTestStat_b (); Get test statistics values for the b model. ; ; doubleGetTestStat_data (); Get test statistics value for data. ; ; std::vector< double >GetTestStat_sb (); Get test statistics values for the sb model. ; ; TClass *IsA () const override; ; doubleNullPValue () const override; Returns \(1 - CL_{b}\) : the B p-value. ; ; voidPrintMore (const char *options); Print out some information about the results. ; ; voidSetDataTestStatistics (double testStat_data_val); set the value of the test statistics on data ; ; voidStreamer (TBuffer &) override; Stream an object of class TObject. ; ; voidStreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b); ; Public Member Functions inherited from RooStats::HypoTestResult; HypoTestResult (const char *name, double nullp, double altp); constructor from name, null and alternate p values ; ; HypoTestResult (const char *name=nullptr); default constructor ; ; HypoTestResult (const HypoTestResult &other); copy constructor ; ; ~HypoTestResult () override; destructor ; ; virtual voidAppend (const HypoTestResult *other); add values from another HypoTestResult ; ; virtual doubleCLb () const; Convert NullPValue into a ""confidence level"". ; ; doubleCLbError () const; The error on the ""confidence level"" of the null hypothesis. ; ; TObject *Clone (const char *newname=nullptr) const override; clone method, required since some data members cannot rely on the streamers to copy them ; ; virtual doubleCLs () const; \(CL_{s}\",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooStats_1_1HybridResult.html:2567,test,test,2567,doc/master/classRooStats_1_1HybridResult.html,https://root.cern,https://root.cern/doc/master/classRooStats_1_1HybridResult.html,1,['test'],['test']
Testability,"lgorithm as MakeGradientVector() ; ; Double_tOptimism (); implementation of eq. ; ; voidUpdateCoefficients (); Establish maximum gradient for rules, linear terms and the offset. ; ; voidUpdateTstCoefficients (); Establish maximum gradient for rules, linear terms and the offset for all taus TODO: do not need index range! ; . Protected Attributes; std::vector< Double_t >fAverageRulePath; average of each rule, same range ; ; std::vector< Double_t >fAverageRulePerf; average of each rule, same range ; ; std::vector< Double_t >fAverageSelectorPath; average of each variable over the range fPathIdx1,2 ; ; std::vector< Double_t >fAverageSelectorPerf; average of each variable over the range fPerfIdx1,2 ; ; Double_tfAverageTruth; average truth, ie sum(y)/N, y=+-1 ; ; Double_tfbkgave; Average of F(bkg) ; ; Double_tfbkgrms; Rms of F(bkg) ; ; std::vector< Double_t >fFstar; vector of F*() - filled in CalcFStar() ; ; Double_tfFstarMedian; median value of F*() using ; ; std::vector< std::vector< Double_t > >fGDCoefLinTst; linear coeffs - one per tau ; ; std::vector< std::vector< Double_t > >fGDCoefTst; rule coeffs - one per tau ; ; Double_tfGDErrScale; stop scan at error = scale*errmin ; ; std::vector< Double_t >fGDErrTst; error rates per tau ; ; std::vector< Char_t >fGDErrTstOK; error rate is sufficiently low < stores boolean ; ; Int_tfGDNPathSteps; number of path steps ; ; UInt_tfGDNTau; number of tau-paths - calculated in SetGDTauPrec ; ; UInt_tfGDNTauTstOK; number of tau in the test-phase that are ok ; ; TTree *fGDNtuple; Gradient path ntuple, contains params for each step along the path. ; ; std::vector< Double_t >fGDOfsTst; offset per tau ; ; Double_tfGDPathStep; step size along path (delta nu in eq 22, ref 1) ; ; Double_tfGDTau; selected threshold parameter (tau in eq 26, ref 1) ; ; Double_tfGDTauMax; max threshold parameter (tau in eq 26, ref 1) ; ; Double_tfGDTauMin; min threshold parameter (tau i",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1RuleFitParams.html:5922,test,test-phase,5922,doc/master/classTMVA_1_1RuleFitParams.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1RuleFitParams.html,1,['test'],['test-phase']
Testability,"lic FCNBase {. public:. GaussFcn(const std::vector<double>& meas,; const std::vector<double>& pos,; const std::vector<double>& mvar) : theMeasurements(meas),; thePositions(pos),; theMVariances(mvar),; theErrorDef(1.) {}. ~GaussFcn() {}. virtual double up() const {return theErrorDef;}; virtual double operator()(const std::vector<double>&) const;. std::vector<double> measurements() const {return theMeasurements;}; std::vector<double> positions() const {return thePositions;}; std::vector<double> variances() const {return theMVariances;}. void setErrorDef(double def) {theErrorDef = def;}. private:. std::vector<double> theMeasurements;; std::vector<double> thePositions;; std::vector<double> theMVariances;; double theErrorDef;; };. #endif //MN_GaussFcn_H_; 7.1.3 GaussFcn.cpp; The actual implementation of the FCNBase::operator() (called by Minuit):; #include ""GaussFcn.h""; #include ""GaussFunction.h"". #include <cassert>. double GaussFcn::operator()(const std::vector<double>& par) const {. assert(par.size() == 3);; GaussFunction gauss(par[0], par[1], par[2]);. double chi2 = 0.;; for(unsigned int n = 0; n < theMeasurements.size(); n++) {; chi2 += ((gauss(thePositions[n]) - theMeasurements[n]) *; (gauss(thePositions[n]) - theMeasurements[n]) /; theMVariances[n]);; }. return chi2;; }; 7.2 The users main program; [example:main]; This is the main program DemoGaussSim.cpp:; #include ""GaussFcn.h""; #include ""GaussDataGen.h""; #include ""Minuit/FunctionMinimum.h""; #include ""Minuit/MnUserParameterState.h""; #include ""Minuit/MinimumPrint.h""; #include ""Minuit/MnMigrad.h""; #include ""Minuit/MnMinos.h""; #include ""Minuit/MnContours.h""; #include ""Minuit/MnPlot.h"". #include <iostream>. int main() {. // generate the data (100 data points); GaussDataGen gdg(100);. std::vector<double> pos = gdg.positions();; std::vector<double> meas = gdg.measurements();; std::vector<double> var = gdg.variances();. // create FCN function; GaussFcn theFCN(meas, pos, var);. // create initial starting values for param",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/guides/minuit2/Minuit2.html:82369,assert,assert,82369,root/html534/guides/minuit2/Minuit2.html,https://root.cern,https://root.cern/root/html534/guides/minuit2/Minuit2.html,2,['assert'],['assert']
Testability,"lic:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. private:. Int_tfBestBest Edge for division; TReffDaught0Pointer to daughter 1; TReffDaught1Pointer to daughter 2; Short_tfDimDimension of the vector space; Double_tfDriveDriver integral, only for cell build-up; Double_tfIntegralIntegral over cell (estimate from exploration); TReffParentPointer to parent cell; Double_tfPrimaryPrimary integral, only for MC generation; Int_tfSerialSerial number; Int_tfStatusStatus (active, inactive); Double_tfVolumeCartesian Volume of cell; Double_tfXdivFactor for division. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFoamCell(); Default constructor for streamer. TFoamCell(Int_t ); User constructor allocating single empty Cell. TFoamCell(TFoamCell& ); Copy constructor (not tested!). ~TFoamCell(); Destructor. TFoamCell& operator=(const TFoamCell& ); Substitution operator = (never used). void Fill(Int_t , TFoamCell* , TFoamCell* , TFoamCell* ); Fills in certain data into newly allocated cell. void GetHcub(TFoamVect& , TFoamVect& ) const; Provides size and position of the cell; These parameter are calculated by analyzing information in all parents; cells up to the root cell. It takes time but saves memory. void GetHSize(TFoamVect& ) const; Provides size of the cell; Size parameters are calculated by analyzing information in all parents; cells up to the root cell. It takes time but saves memory. void CalcVolume(void); Calculates volume of the cell using size params which are calculated. void Print(Option_t* option) const; Printout of the cell geometry parameters for the debug purpose. Double_t GetXdiv() const; Geometry. { return fXdiv;}. Int_t GetBest() const; { return fBest;}. void SetBest(Int_t Best); { fBest =Best;}. void SetXdiv(Double",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TFoamCell.html:6654,test,tested,6654,root/html528/TFoamCell.html,https://root.cern,https://root.cern/root/html528/TFoamCell.html,4,['test'],['tested']
Testability,"lidObject = (1ULL << ( 13 )). }; ; Protected Types inherited from TObject; enum { kOnlyPrepStep = (1ULL << ( 3 )); }; ; Protected Attributes inherited from TApplication; TApplication *fAppRemote; ; Protected Attributes inherited from TQObject; TList *fListOfConnections; list of signals from this object ; ; TList *fListOfSignals; ; Bool_tfSignalsBlocked; list of connections to this object ; ; Static Protected Attributes inherited from TApplication; static TList *fgApplications = nullptr; ; Static Protected Attributes inherited from TQObject; static Bool_tfgAllSignalsBlocked = kFALSE; flag used for suppression of signals ; . #include <TApplicationServer.h>. Inheritance diagram for TApplicationServer:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. TApplicationServer(). TApplicationServer::TApplicationServer ; (; Int_t *; argc, . char **; argv, . FILE *; flog, . const char *; logfile. ). Main constructor. ; Create an application environment. The TApplicationServer environment provides an eventloop via inheritance of TApplication. ; Definition at line 283 of file TApplicationServer.cxx. ~TApplicationServer(). TApplicationServer::~TApplicationServer ; (; ). virtual . Cleanup. ; Not really necessary since after this dtor there is no live anyway. ; Definition at line 437 of file TApplicationServer.cxx. Member Function Documentation. BrowseDirectory(). Int_t TApplicationServer::BrowseDirectory ; (; const char *; dirname). Browse directory and send back its content to client. ; Definition at line 918 of file TApplicationServer.cxx. BrowseFile(). Int_t TApplicationServer::BrowseFile ; (; const char *; fname). Browse root file and send back its content; if fname is null, send the full list of files. ; Definition at line 951 of file TApplicationServer.cxx. BrowseKey(). Int_t TApplicationServer::BrowseKey ; (; const char *; keyname). Read key object an",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTApplicationServer.html:23121,log,logfile,23121,doc/master/classTApplicationServer.html,https://root.cern,https://root.cern/doc/master/classTApplicationServer.html,1,['log'],['logfile']
Testability,"lidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TAuthenticate::ESecuritykKrb5; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TAuthenticate::ESecuritykRfio; static TAuthenticate::ESecuritykSRP; static TAuthenticate::ESecuritykSSH; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. private:. TStringfDetailslogon details (method dependent ...); THostAuth*fHostAuthpointer to relevant authentication info; TStringfPasswduser's password; TStringfProtocolremote service (rootd, proofd); Bool_tfPwHashkTRUE if fPasswd is a passwd hash; Int_tfRSAKeyType of RSA key used; TStringfRemoteremote host to which we want to connect; Bool_tfSRPPwdkTRUE if fPasswd is a SRP passwd; TRootSecContext*fSecContextpointer to relevant sec context; TAuthenticate::ESecurityfSecurityactual logon security level; TSocket*fSocketconnection to remote daemon; Int_tfTimeOuttimeout flag; TStringfUseruser to be authenticated; Int_tfVersion0,1,2, ... accordingly to remote daemon version; static TList*fgAuthInfo; static TStringfgAuthMeth[6]; static Bool_tfgAuthReUsekTRUE is ReUse required; static Int_tfgAuthTOif > 0, timeout in sec; static TStringfgDefaultUserDefault user information; static TDatimefgExpDateExpiring date for new security contexts; static GlobusAuth_tfgGlobusAuthHook; static Krb5Auth_tfgKrb5AuthHook; static TStringfgKrb5PrincipalPrincipal for Krb5 ticket; static TDatimefgLastAuthrcTime of last reading of fgRootAuthrc; static Int_tfgLastErrorLast error code processed by AuthError(); static TStringfgPasswd; static TPluginHandler*fgPasswdDialogPasswd dialog GUI plugin; static Int_tfgProcessIDID of the main thread as unique identifier",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TAuthenticate.html:10172,log,logon,10172,root/html602/TAuthenticate.html,https://root.cern,https://root.cern/root/html602/TAuthenticate.html,2,['log'],['logon']
Testability,"lientIterator() const; virtual TObject*RooAbsArg::clone(const char* newname = 0) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); virtual RooAbsArg*createFundamental(const char* newname = 0) const; virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTO",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAbsString.html:3196,test,testArg,3196,root/html534/RooAbsString.html,https://root.cern,https://root.cern/root/html534/RooAbsString.html,3,['test'],['testArg']
Testability,"lientIterator() const; virtual TObject*RooAbsArg::clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual voidTNamed::Copy(TObject& named) const; static voidRooAbsArg::copyList(TList& dest, const TList& source); static UInt_tRooAbsArg::crc32(const char* data); virtual RooAbsArg*createFundamental(const char* newname = 0) const; Roo1DTable*createTable(const char* label) const; virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTO",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAbsCategory.html:3141,test,testArg,3141,root/html526/RooAbsCategory.html,https://root.cern,https://root.cern/root/html526/RooAbsCategory.html,3,['test'],['testArg']
Testability,"lightMode() && gPad->GetSelected() != fH); 6843 return;; 6844 ; 6845 static char chopth[17];; 6846 ; 6847 Int_t htype, oldhtype;; 6848 Int_t i, j, first, last, nbins, fixbin;; 6849 Double_t c1, yb;; 6850 yb = 0;; 6851 ; 6852 strlcpy(chopth, "" "",17);; 6853 ; 6854 Double_t ymin = Hparam.ymin;; 6855 Double_t ymax = Hparam.ymax;; 6856 Double_t baroffset = fH->GetBarOffset();; 6857 Double_t barwidth = fH->GetBarWidth();; 6858 Double_t baroffsetsave = gStyle->GetBarOffset();; 6859 Double_t barwidthsave = gStyle->GetBarWidth();; 6860 gStyle->SetBarOffset(baroffset);; 6861 gStyle->SetBarWidth(barwidth);; 6862 ; 6863 // Create ""LIFE"" structure to keep current histogram status; 6864 ; 6865 first = Hparam.xfirst;; 6866 last = Hparam.xlast;; 6867 nbins = last - first + 1;; 6868 ; 6869 std::vector<Double_t> keepx, keepy;; 6870 if (fXaxis->GetXbins()->fN) fixbin = 0;; 6871 else fixbin = 1;; 6872 if (fixbin) keepx.resize(2);; 6873 else keepx.resize(nbins+1);; 6874 keepy.resize(nbins);; 6875 Double_t logymin = 0;; 6876 if (Hoption.Logy) logymin = TMath::Power(10,ymin);; 6877 ; 6878 // Loop on histogram bins; 6879 ; 6880 for (j=first; j<=last;j++) {; 6881 c1 = Hparam.factor*fH->GetBinContent(j);; 6882 if (TMath::Abs(ymax-ymin) > 0) {; 6883 if (Hoption.Logy) yb = TMath::Log10(TMath::Max(c1,.1*logymin));; 6884 else yb = c1;; 6885 }; 6886 if (!Hoption.Line) {; 6887 yb = TMath::Max(yb, ymin);; 6888 yb = TMath::Min(yb, ymax);; 6889 }; 6890 keepy[j-first] = yb;; 6891 }; 6892 ; 6893 // Draw histogram according to value of FillStyle and FillColor; 6894 ; 6895 if (fixbin) { keepx[0] = Hparam.xmin; keepx[1] = Hparam.xmax; }; 6896 else {; 6897 for (i=0; i<nbins; i++) keepx[i] = fXaxis->GetBinLowEdge(i+first);; 6898 keepx[nbins] = fXaxis->GetBinUpEdge(nbins-1+first);; 6899 }; 6900 ; 6901 // Prepare Fill area (systematic with option ""Bar"").; 6902 ; 6903 oldhtype = fH->GetFillStyle();; 6904 htype = oldhtype;; 6905 if (Hoption.Bar) {; 6906 if (htype == 0 || htype == 1000) htype = 1001;; 6907 }; 690",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/THistPainter_8cxx_source.html:250814,log,logymin,250814,doc/master/THistPainter_8cxx_source.html,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html,1,['log'],['logymin']
Testability,lihood for Classification performance; : ; <HEADER> Likelihood : [dataset] : Evaluation of Likelihood on testing sample (10000 events); : Elapsed time for evaluation of 10000 events: 0.00959 sec ; <HEADER> Factory : Test method: FisherCat for Classification performance; : ; <HEADER> Category_Fisher_1 : [Category_Fisher_1_dsi] : Evaluation of Category_Fisher_1 on testing sample (10000 events); : Elapsed time for evaluation of 10000 events: 0.00192 sec ; <HEADER> Category_Fisher_2 : [Category_Fisher_2_dsi] : Evaluation of Category_Fisher_2 on testing sample (10000 events); : Elapsed time for evaluation of 10000 events: 0.00196 sec ; <HEADER> Factory : Test method: LikelihoodCat for Classification performance; : ; <HEADER> Category_Likelihood_1 : [Category_Likelihood_1_dsi] : Evaluation of Category_Likelihood_1 on testing sample (10000 events); : Elapsed time for evaluation of 10000 events: 0.00948 sec ; <HEADER> Category_Likelihood_2 : [Category_Likelihood_2_dsi] : Evaluation of Category_Likelihood_2 on testing sample (10000 events); : Elapsed time for evaluation of 10000 events: 0.00932 sec ; <HEADER> Factory : Evaluate all methods; <HEADER> Factory : Evaluate classifier: Fisher; : ; <HEADER> Fisher : [dataset] : Loop over test events and fill histograms with classifier response...; : ; <HEADER> TFHandler_Fisher : Variable Mean RMS [ Min Max ]; : -----------------------------------------------------------; : var1: -0.014081 1.2910 [ -5.3119 4.5609 ]; : var2: -0.014399 1.3299 [ -4.7537 4.6723 ]; : var3: -0.027971 1.3779 [ -5.2892 4.7007 ]; : var4: 0.12966 1.4883 [ -5.1002 4.9767 ]; : -----------------------------------------------------------; <HEADER> Factory : Evaluate classifier: Likelihood; : ; <HEADER> Likelihood : [dataset] : Loop over test events and fill histograms with classifier response...; : ; <HEADER> TFHandler_Likelihood : Variable Mean RMS [ Min Max ]; : -----------------------------------------------------------; : var1: -0.014081 1.2910 [ -5.3119 4.56,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVAClassificationCategory_8C.html:23876,test,testing,23876,doc/master/TMVAClassificationCategory_8C.html,https://root.cern,https://root.cern/doc/master/TMVAClassificationCategory_8C.html,1,['test'],['testing']
Testability,"lihood of Maximum Likelihood estimate is returned.; what = 3: Profile Likelihood of Test hypothesis is returned; otherwise parameters as described in the beginning of the class). Double_t LikeMod6(Double_t mu, Double_t b, Double_t e, Int_t x, Int_t z, Int_t m); Profile Likelihood function for MODEL 6:; background known/ Efficiency binomial. Double_t EvalLikeMod7(Double_t mu, Int_t x, Double_t em, Double_t sde, Double_t b, Int_t what); Calculates the Profile Likelihood for MODEL 7:; background known/Efficiency Gauss; what = 1: Maximum likelihood estimate is returned; what = 2: Profile Likelihood of Maximum Likelihood estimate is returned.; what = 3: Profile Likelihood of Test hypothesis is returned; otherwise parameters as described in the beginning of the class). Double_t LikeMod7(Double_t mu, Double_t b, Double_t e, Int_t x, Double_t em, Double_t v); Profile Likelihood function for MODEL 6:; background known/ Efficiency gaussian. Double_t EvalPolynomial(Double_t x, const Int_t[] coef, Int_t N); evaluate polynomial. Double_t EvalMonomial(Double_t x, const Int_t[] coef, Int_t N); evaluate mononomial. Double_t LogFactorial(Int_t n); LogFactorial function (use the logGamma function via the relation Gamma(n+1) = n!. TRolke(Double_t CL = 0.90000000000000002, Option_t* option = """"); Constructor. Double_t GetCL() const; Get and set the Confidence Level. void SetCL(Double_t CL). void SetCLSigmas(Double_t CLsigmas); Set the Confidence Level in terms of Sigmas. bool GetBounding() const; Get the bounding mode flag. True activates bounded mode. Read; TRolke.cxx and the references therein for details. . void SetBounding(const bool bnd); Get the bounding mode flag. True activates bounded mode. Read; TRolke.cxx and the references therein for details. .  Last changed: Tue Jun 30 15:29:35 2015  Last generated: 2015-06-30 15:29; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TRolke.html:27256,log,logGamma,27256,root/html602/TRolke.html,https://root.cern,https://root.cern/root/html602/TRolke.html,1,['log'],['logGamma']
Testability,"like this should appear:. Figure 2: Example of TBrowser at start-up time; On the left, in the ""ROOT Files"" folder, you can find the ROOT file you have opened and our EventTree. If you see EventTree;1 and EventTree: they are identical. The first one is the tree on disk, the second the one in memory. Click your way through the tree.; Draw the ""fPosZ"" values from the browser. You should obtain a result looking like this:. Figure 3: Distribution of ""fPosZ"" values; This graph is called a histogram: it counts occurrences, combining neighboring values into ""bins"". In this case we have 100 equally sized bins (the ""steps""), ranging from x=-74 to x=102. You can tell that there were about 500 particles with a fPosZ value around -11. Histograms are a very common way to visualize data, e.g. in high energy physics.; Now close the browser, quit and restart ROOT (to make sure everybody starts from the same point).; .  Meet a TTree; up; Using TTree::Draw() to access a TTree . Navigate through this book; Meet a TTree; Accessing a TTree With a TBrowser; Using TTree::Draw() to access a TTree; TTree and Its Data; Using a Macro to Read a TTree; Histogramming; Fit Panel; Compiling Your Code (also known as ACLiC); Accessing a TTree With a TSelector; Histogramming in a Selector; Using a TSelector with PROOF; The End. Sitemap. DownloadDownload ROOT; All Releases. DocumentationReference Manual; User's Guides; HowTo; Courses; Building ROOT; Tutorials; Javascript Root; ROOT and Spark; Publications; FAQ. NewsBlog; Workshops. SupportForum; Bug submission guidelines; Submit a Bug; Discourse Mailing List Mode; RootTalk Digest. AboutLicence; Contact Us; Project Founders; Team; Previous Developers. DevelopmentProgram of Work; Code Owners; Release Checklist; Coding Conventions; Shifter's Instructions; Git Primer; Browse Sources; Meetings; ROOT 7; Run the tests; Jenkins; Setup externals from AFS/CVMFS; Doxygen; Benchmarks. ContributeCollaborate with Us.  Copyright CERN 2014-18. All rights reserved. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/accessing-ttree-tbrowser.html:3940,test,tests,3940,d/accessing-ttree-tbrowser.html,https://root.cern,https://root.cern/d/accessing-ttree-tbrowser.html,1,['test'],['tests']
Testability,"line 218 of file DataSetFactory.h. fCurrentEvtIdx. UInt_t TMVA::DataSetFactory::fCurrentEvtIdx. protected . the current event (to avoid reading of the same event) ; Definition at line 225 of file DataSetFactory.h. fCurrentTree. TTree* TMVA::DataSetFactory::fCurrentTree. protected . the tree, events are currently read from ; Definition at line 224 of file DataSetFactory.h. fCutFormulas. std::vector<TTreeFormula*> TMVA::DataSetFactory::fCutFormulas. protected . cuts ; Definition at line 231 of file DataSetFactory.h. fInputFormulas. std::vector<TTreeFormula*> TMVA::DataSetFactory::fInputFormulas. protected . input variables ; Definition at line 228 of file DataSetFactory.h. fInputTableFormulas. std::vector<std::pair<TTreeFormula*, Int_t> > TMVA::DataSetFactory::fInputTableFormulas. protected . ! input variables expression for arrays ; Definition at line 229 of file DataSetFactory.h. fLogger. MsgLogger* TMVA::DataSetFactory::fLogger. protected . ! message logger ; Definition at line 235 of file DataSetFactory.h. fScaleWithPreselEff. Bool_t TMVA::DataSetFactory::fScaleWithPreselEff. protected . how to deal with requested #events in connection with preselection cuts ; Definition at line 221 of file DataSetFactory.h. fSpectatorFormulas. std::vector<TTreeFormula*> TMVA::DataSetFactory::fSpectatorFormulas. protected . spectators ; Definition at line 233 of file DataSetFactory.h. fTargetFormulas. std::vector<TTreeFormula *> TMVA::DataSetFactory::fTargetFormulas. protected . targets ; Definition at line 230 of file DataSetFactory.h. fVerbose. Bool_t TMVA::DataSetFactory::fVerbose. protected . Verbosity. ; Definition at line 214 of file DataSetFactory.h. fVerboseLevel. TString TMVA::DataSetFactory::fVerboseLevel. protected . VerboseLevel. ; Definition at line 215 of file DataSetFactory.h. fWeightFormula. std::vector<TTreeFormula*> TMVA::DataSetFactory::fWeightFormula. protected . weights ; Definition at line 232 of file DataSetFactory.h. Libraries for TM",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1DataSetFactory.html:22605,log,logger,22605,doc/master/classTMVA_1_1DataSetFactory.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1DataSetFactory.html,1,['log'],['logger']
Testability,"line 57 of file CvSplit.h. DeclFileName(). static const char * TMVA::CvSplit::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 57 of file CvSplit.h. GetNumFolds(). UInt_t TMVA::CvSplit::GetNumFolds ; (; ). inline . Definition at line 46 of file CvSplit.h. IsA(). virtual TClass * TMVA::CvSplit::IsA ; (; ); const. inlinevirtual . ReturnsTClass describing current object ; Reimplemented from TMVA::Configurable.; Reimplemented in TMVA::CvSplitKFolds.; Definition at line 57 of file CvSplit.h. MakeKFoldDataSet(). virtual void TMVA::CvSplit::MakeKFoldDataSet ; (; DataSetInfo &; dsi). pure virtual . Implemented in TMVA::CvSplitKFolds. NeedsRebuild(). Bool_t TMVA::CvSplit::NeedsRebuild ; (; ). inline . Definition at line 47 of file CvSplit.h. PrepareFoldDataSet(). void TMVA::CvSplit::PrepareFoldDataSet ; (; DataSetInfo &; dsi, . UInt_t; foldNumber, . Types::ETreeType; tt. ). virtual . Set training and test set vectors of dataset described by dsi. ; Parameters. [in]dsiDataSetInfo for data set to be split ; [in]foldNumberOrdinal of fold to prepare ; [in]ttThe set used to prepare fold. If equal to Types::kTraining splitting will be based off the original train set. If instead equal to Types::kTesting the test set will be used. The original training/test set is the set as defined by DataLoader::PrepareTrainingAndTestSet. Sets the training and test set vectors of the DataSet described by dsi as defined by the split. If tt is eqal to Types::kTraining the split will be based off of the original training set.; Note: Requires MakeKFoldDataSet to have been called first. ; Definition at line 57 of file CvSplit.cxx. RecombineKFoldDataSet(). void TMVA::CvSplit::RecombineKFoldDataSet ; (; DataSetInfo &; dsi, . Types::ETreeType; tt = Types::kTraining. ). virtual . Definition at line 114 of file CvSplit.cxx. Streamer(). virtual void TMVA::CvSplit::Streamer ; (; TBuffer &; R__b). virtual . Stream an objec",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1CvSplit.html:15893,test,test,15893,doc/master/classTMVA_1_1CvSplit.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1CvSplit.html,1,['test'],['test']
Testability,"line 586 of file TMultiDimFit.cxx. Member Function Documentation. AddRow(). void TMultiDimFit::AddRow ; (; const Double_t *; x, . Double_t; D, . Double_t; E = 0. ). virtual . Add a row consisting of fNVariables independent variables, the known, dependent quantity, and optionally, the square error in the dependent quantity, to the training sample to be used for the parameterization. ; The mean of the variables and quantity is calculated on the fly, as outlined in TPrincipal::AddRow. This sample should be representative of the problem at hand. Please note, that if no error is given Poisson statistics is assumed and the square error is set to the value of dependent quantity. See also the class description ; Definition at line 611 of file TMultiDimFit.cxx. AddTestRow(). void TMultiDimFit::AddTestRow ; (; const Double_t *; x, . Double_t; D, . Double_t; E = 0. ). virtual . Add a row consisting of fNVariables independent variables, the known, dependent quantity, and optionally, the square error in the dependent quantity, to the test sample to be used for the test of the parameterization. ; This sample needn't be representative of the problem at hand. Please note, that if no error is given Poisson statistics is assumed and the square error is set to the value of dependent quantity. See also the class description ; Definition at line 690 of file TMultiDimFit.cxx. Browse(). void TMultiDimFit::Browse ; (; TBrowser *; b). overridevirtual . Browse the TMultiDimFit object in the TBrowser. ; Reimplemented from TObject.; Definition at line 737 of file TMultiDimFit.cxx. Class(). static TClass * TMultiDimFit::Class ; (; ). static . ReturnsTClass describing this class . Class_Name(). static const char * TMultiDimFit::Class_Name ; (; ). static . ReturnsName of this class . Class_Version(). static constexpr Version_t TMultiDimFit::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 207 of file TMultiDimFit.h. Clear(). vo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMultiDimFit.html:40746,test,test,40746,doc/master/classTMultiDimFit.html,https://root.cern,https://root.cern/doc/master/classTMultiDimFit.html,2,['test'],['test']
Testability,"line 59 of file RooLinkedList.h. GetName(). const char * RooLinkedList::GetName ; (; ); const. inlineoverridevirtual . Returns name of object. ; This default method returns the class name. Classes that give objects a name should override this method. ; Reimplemented from TObject.; Definition at line 104 of file RooLinkedList.h. GetSize(). Int_t RooLinkedList::GetSize ; (; ); const. inline . Definition at line 69 of file RooLinkedList.h. Hash(). ULong_t RooLinkedList::Hash ; (; ); const. inlineoverridevirtual . Return hash value for this object. ; Note: If this routine is overloaded in a derived class, this derived class should also add ROOT::CallRecursiveRemoveIfNeeded(*this); ROOT::CallRecursiveRemoveIfNeededvoid CallRecursiveRemoveIfNeeded(TObject &obj)call RecursiveRemove for obj if gROOT is valid and obj.TestBit(kMustCleanup) is true.Definition TROOT.h:395; Otherwise, when RecursiveRemove is called (by ~TObject or example) for this type of object, the transversal of THashList and THashTable containers will will have to be done without call Hash (and hence be linear rather than logarithmic complexity). You will also see warnings like Error in <ROOT::Internal::TCheckHashRecursiveRemoveConsistency::CheckRecursiveRemove>: The class SomeName overrides TObject::Hash but does not call TROOT::RecursiveRemove in its destructor.; RooLinkedList::HashULong_t Hash() const overrideReturn hash value for this object.Definition RooLinkedList.h:110; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TROOT::RecursiveRemovevoid RecursiveRemove(TObject *obj) overrideRecursively remove this object from the list of Cleanups.Definition TROOT.cxx:2498. Reimplemented from TObject.; Definition at line 110 of file RooLinkedList.h. IndexOf() [1/2]. Int_t RooLinkedList::IndexOf ; (; const char *; name); const. Return position of given object in lis",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooLinkedList.html:21150,log,logarithmic,21150,doc/master/classRooLinkedList.html,https://root.cern,https://root.cern/doc/master/classRooLinkedList.html,1,['log'],['logarithmic']
Testability,"line::RooSpline ; (; ). default . RooSpline() [2/4]. RooSpline::RooSpline ; (; const char *; name, . const char *; title, . RooAbsReal &; x, . std::span< const double >; x0, . std::span< const double >; y0, . int; order = 3, . bool; logx = false, . bool; logy = false. ). Constructor for creating a spline from raw data. ; Parameters. [in]nameThe name of the spline. ; [in]titleThe title of the spline. ; [in]xThe independent variable. ; [in]x0The array of x values for the spline points. ; [in]y0The array of y values for the spline points. ; [in]orderThe order of the spline (3 or 5). ; [in]logxIf true, the x values are logarithmically scaled before spline creation. ; [in]logyIf true, the y values are logarithmically scaled before spline creation. . Definition at line 74 of file RooSpline.cxx. RooSpline() [3/4]. RooSpline::RooSpline ; (; const char *; name, . const char *; title, . RooAbsReal &; x, . const TGraph &; gr, . int; order = 3, . bool; logy = false, . bool; logx = false. ). Constructor for creating a spline from a TGraph. ; Parameters. [in]nameThe name of the spline. ; [in]titleThe title of the spline. ; [in]xThe independent variable. ; [in]grThe input TGraph containing the data points. ; [in]orderThe order of the spline (3 or 5). ; [in]logxIf true, the x values are logarithmically scaled before spline creation. ; [in]logyIf true, the y values are logarithmically scaled before spline creation. . Definition at line 58 of file RooSpline.cxx. RooSpline() [4/4]. RooSpline::RooSpline ; (; const RooSpline &; other, . const char *; name = nullptr. ). Copy constructor. ; Parameters. [in]otherThe RooSpline object to copy from. ; [in]nameThe name of the new RooSpline object (optional). . Definition at line 118 of file RooSpline.cxx. Member Function Documentation. Class(). static TClass * RooSpline::Class ; (; ). static . ReturnsTClass describing this class . Class_Name(). static const char * RooSpline::Class_Name ; (; ). static . ReturnsName",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooSpline.html:62628,log,logx,62628,doc/master/classRooSpline.html,https://root.cern,https://root.cern/doc/master/classRooSpline.html,1,['log'],['logx']
Testability,"ling -- observable: pTV; [#0] PROGRESS:ObjectHandling -- binWidth: binWidth_pTV; [#1] INFO:DataHandling -- RooDataHist::adjustBinning(pseudo_dh): fit range of variable pTV expanded to nearest bin boundaries: [10,600] --> [0,600]; [#0] PROGRESS:Caching -- creating cache from getCache function for 0x5559dfeef700; [#0] PROGRESS:Caching -- current storage has size 10; [#0] PROGRESS:ObjectHandling -- observable: pTV; [#0] PROGRESS:ObjectHandling -- binWidth: binWidth_pTV; ; [#1] INFO:Fitting -- RooAbsPdf::fitTo(wrap_pdf_over_wrap_pdf_Int[pTV]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_wrap_pdf_over_wrap_pdf_Int[pTV]_pseudo_dh) Summation contains a RooNLLVar, using its error level; RooAbsMinimizerFcn: Minimized function has error status.; Returning maximum FCN so far (86348.3) to force MIGRAD to back out of this region. Error log follows.; Parameter values: cHDD=0 cHl3=0 cHq3=-0.0202918; RooAbsPdf::wrap_pdf_over_wrap_pdf_Int[pTV][ numerator=wrap_pdf denominator=wrap_pdf_Int[pTV] ]; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=0.0376648, denominator=wrap_pdf_Int[pTV]=10358.6; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=0.0376648, denominator=wrap_pdf_Int[pTV]=10358.6; getLogVal() top-level p.d.f evaluates to NaN @ numerator=wrap_pdf=0.0376648, denominator=wrap_pdf_Int[pTV]=10358.6; getLogVal() top-level p.d.f evaluates to NaN @ numerator=wrap_pdf=0.0376648, denominator=wrap_pdf_Int[pTV]=10358.6; ; RooAbsMinimizerFcn: Minimized function has error status.; Returning maximum FCN so far (86348.3) to force MIGRAD to back out of this region. Error log follows.; Parameter values: cHDD=0.213672 cHl3=1.97898 cHq3=0.00773174; RooAbsPdf::wrap_pdf_over_wrap_pdf_Int[pTV][ numerator=wrap_pdf denominator=wrap_pdf_Int[pTV] ]; p.d.f value is less than zero, trying to recover @ ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf712__lagrangianmorphfit_8C.html:8420,log,log,8420,doc/master/rf712__lagrangianmorphfit_8C.html,https://root.cern,https://root.cern/doc/master/rf712__lagrangianmorphfit_8C.html,1,['log'],['log']
Testability,"lised(Bool_t norm); voidTMVA::MethodBase::SetWeightFileDir(TString fileDir); voidTMVA::MethodBase::SetWeightFileName(TString); voidTMVA::MethodBase::Statistics(TMVA::Types::ETreeType treeType, const TString& theVarName, Double_t&, Double_t&, Double_t&, Double_t&, Double_t&, Double_t&); Bool_tTMVA::MethodBase::TxtWeightsOnly() const; Bool_tTMVA::MethodBase::Verbose() const; voidTMVA::Configurable::WriteOptionsReferenceToFile(). private:. virtual voidInit(). Data Members; public:. Bool_tTMVA::MethodBase::fSetupCompletedis method setup; const TMVA::Event*TMVA::MethodBase::fTmpEvent! temporary event when testing on a different DataSet than the own one; static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TMVA::MethodBase::EWeightFileTypeTMVA::MethodBase::kROOT; static TObject::(anonymous)TObject::kSingleKey; static TMVA::MethodBase::EWeightFileTypeTMVA::MethodBase::kTEXT; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TMVA::Types::EAnalysisTypeTMVA::MethodBase::fAnalysisTypemethod-mode : true --> regression, false --> classification; UInt_tTMVA::MethodBase::fBackgroundClassindex of the Background-class; vector<TString>*TMVA::MethodBase::fInputVarsvector of input variables used in MVA; vector<Float_t>*TMVA::MethodBase::fMulticlassReturnValholds the return-values for the multiclass classification; Int_tTMVA::MethodBase::fNbinsnumber of bins in input variable histograms; Int_tTMVA::",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TMVA__MethodDT.html:18600,test,testing,18600,root/html602/TMVA__MethodDT.html,https://root.cern,https://root.cern/root/html602/TMVA__MethodDT.html,2,['test'],['testing']
Testability,"list of specific rules :; 125positioned daughters should not extrude their mother or intersect with sisters; 126unless this is specified (see TGeoVolume::AddNodeOverlap()), the top volume; 127(containing all geometry tree) must be specified before closing the geometry; 128and must not be positioned - it represents the global reference frame. After; 129building the full geometry tree, the geometry must be closed; 130(see TGeoManager::CloseGeometry()). Voxelization can be redone per volume after; 131this process.; 132 ; 133 ; 134 Below is the general scheme of the manager class.; 135 ; 136\image html geom_mgr.jpg; 137 ; 138## An interactive session; 139 ; 140 Provided that a geometry was successfully built and closed (for instance the; 141previous example $ROOTSYS/tutorials/geom/rootgeom.C ), the manager class will register; 142itself to ROOT and the logical/physical structures will become immediately browsable.; 143The ROOT browser will display starting from the geometry folder : the list of; 144transformations and media, the top volume and the top logical node. These last; 145two can be fully expanded, any intermediate volume/node in the browser being subject; 146of direct access context menu operations (right mouse button click). All user; 147utilities of classes TGeoManager, TGeoVolume and TGeoNode can be called via the; 148context menu.; 149 ; 150\image html geom_browser.jpg; 151 ; 152### Drawing the geometry; 153 ; 154 Any logical volume can be drawn via TGeoVolume::Draw() member function.; 155This can be directly accessed from the context menu of the volume object; 156directly from the browser.; 157 There are several drawing options that can be set with; 158TGeoManager::SetVisOption(Int_t opt) method :; 159 ; 160#### opt=0; 161 only the content of the volume is drawn, N levels down (default N=3).; 162 This is the default behavior. The number of levels to be drawn can be changed; 163 via TGeoManager::SetVisLevel(Int_t level) method.; 164 ; 165\image html geom_fr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGeoManager_8cxx_source.html:8620,log,logical,8620,doc/master/TGeoManager_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGeoManager_8cxx_source.html,1,['log'],['logical']
Testability,"lit = -1;; 6264}; 6265 ; 6266////////////////////////////////////////////////////////////////////////////////; 6267/// Change (i.e. set) the title of the TNamed.; 6268 ; 6269void TClass::SetContextMenuTitle(const char *title); 6270{; 6271 fContextMenuTitle = title;; 6272}; 6273 ; 6274////////////////////////////////////////////////////////////////////////////////; 6275/// This function installs a global IsA function for this class.; 6276/// The global IsA function will be used if there is no local IsA function (fIsA); 6277///; 6278/// A global IsA function has the signature:; 6279///; 6280/// ~~~ {.cpp}; 6281/// TClass *func( TClass *cl, const void *obj);; 6282/// ~~~; 6283///; 6284/// 'cl' is a pointer to the TClass object that corresponds to the; 6285/// 'pointer type' used to retrieve the value 'obj'; 6286///; 6287/// For example with:; 6288/// ~~~ {.cpp}; 6289/// TNamed * m = new TNamed(""example"",""test"");; 6290/// TObject* o = m; 6291/// ~~~; 6292/// and; 6293/// the global IsA function would be called with TObject::Class() as; 6294/// the first parameter and the exact numerical value in the pointer; 6295/// 'o'.; 6296///; 6297/// In other word, inside the global IsA function. it is safe to C-style; 6298/// cast the value of 'obj' into a pointer to the class described by 'cl'.; 6299 ; 6300void TClass::SetGlobalIsA(IsAGlobalFunc_t func); 6301{; 6302 fGlobalIsA = func;; 6303}; 6304 ; 6305////////////////////////////////////////////////////////////////////////////////; 6306/// Call this method to indicate that the shared library containing this; 6307/// class's code has been removed (unloaded) from the process's memory; 6308 ; 6309void TClass::SetUnloaded(); 6310{; 6311 if (TestBit(kUnloaded) && !TestBit(kUnloading)) {; 6312 // Don't redo the work.; 6313 return;; 6314 }; 6315 SetBit(kUnloading);; 6316 ; 6317 //R__ASSERT(fState == kLoaded);; 6318 if (fState != kLoaded) {; 6319 Fatal(""SetUnloaded"",""The TClass for %s is being unloaded when in state %d\n"",; 6320 GetNam",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/TClass_8cxx_source.html:242207,test,test,242207,doc/v632/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html,1,['test'],['test']
Testability,"lit = -1;; 6331}; 6332 ; 6333////////////////////////////////////////////////////////////////////////////////; 6334/// Change (i.e. set) the title of the TNamed.; 6335 ; 6336void TClass::SetContextMenuTitle(const char *title); 6337{; 6338 fContextMenuTitle = title;; 6339}; 6340 ; 6341////////////////////////////////////////////////////////////////////////////////; 6342/// This function installs a global IsA function for this class.; 6343/// The global IsA function will be used if there is no local IsA function (fIsA); 6344///; 6345/// A global IsA function has the signature:; 6346///; 6347/// ~~~ {.cpp}; 6348/// TClass *func( TClass *cl, const void *obj);; 6349/// ~~~; 6350///; 6351/// 'cl' is a pointer to the TClass object that corresponds to the; 6352/// 'pointer type' used to retrieve the value 'obj'; 6353///; 6354/// For example with:; 6355/// ~~~ {.cpp}; 6356/// TNamed * m = new TNamed(""example"",""test"");; 6357/// TObject* o = m; 6358/// ~~~; 6359/// and; 6360/// the global IsA function would be called with TObject::Class() as; 6361/// the first parameter and the exact numerical value in the pointer; 6362/// 'o'.; 6363///; 6364/// In other word, inside the global IsA function. it is safe to C-style; 6365/// cast the value of 'obj' into a pointer to the class described by 'cl'.; 6366 ; 6367void TClass::SetGlobalIsA(IsAGlobalFunc_t func); 6368{; 6369 fGlobalIsA = func;; 6370}; 6371 ; 6372////////////////////////////////////////////////////////////////////////////////; 6373/// Call this method to indicate that the shared library containing this; 6374/// class's code has been removed (unloaded) from the process's memory; 6375 ; 6376void TClass::SetUnloaded(); 6377{; 6378 if (TestBit(kUnloaded) && !TestBit(kUnloading)) {; 6379 // Don't redo the work.; 6380 return;; 6381 }; 6382 SetBit(kUnloading);; 6383 ; 6384 //R__ASSERT(fState == kLoaded);; 6385 if (fState != kLoaded) {; 6386 Fatal(""SetUnloaded"",""The TClass for %s is being unloaded when in state %d\n"",; 6387 GetNam",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TClass_8cxx_source.html:244958,test,test,244958,doc/master/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TClass_8cxx_source.html,1,['test'],['test']
Testability,"litudes of 2D peaks (not fit). However they are; present in the estimated functional;  Bool_t; *fFixAmpX1; //[fNPeaks] array of logical values which; allow to fix appropriate amplitudes of 1D ridges in x direction (not fit).; However they are present in the estimated functional;  Bool_t; *fFixAmpY1; //[fNPeaks] array of logical values which; allow to fix appropriate amplitudes of 1D ridges in y direction (not fit).; However they are present in the estimated functional;  Bool_t; fFixSigmaX; //logical value of sigma x parameter, which; allows to fix the parameter (not to fit).;  Bool_t; fFixSigmaY; //logical value of sigma y parameter, which; allows to fix the parameter (not to fit).;  Bool_t fFixRo; //logical; value of correlation coefficient, which allows to fix the parameter (not to; fit).;  Bool_t; fFixTxy; //logical value of t parameter for 2D peaks,; which allows to fix the parameter (not to fit).;  Bool_t; fFixSxy; //logical value of s parameter for 2D peaks,; which allows to fix the parameter (not to fit).;  Bool_t; fFixTx; //logical value of t parameter for 1D ridges in; x direction, which allows to fix the parameter (not to fit).;  Bool_t; fFixTy; //logical value of t parameter for 1D ridges in; y direction, which allows to fix the parameter (not to fit).;  Bool_t; fFixSx; //logical value of s parameter for 1D ridges in; x direction, which allows to fix the parameter (not to fit).;  Bool_t; fFixSy; //logical value of s parameter for 1D ridges in; y direction, which allows to fix the parameter (not to fit).;  Bool_t fFixBx; //logical; value of b parameter for 1D ridges in x direction, which allows to fix the; parameter (not to fit).; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TSpectrum2Fit.html:49209,log,logical,49209,root/html528/TSpectrum2Fit.html,https://root.cern,https://root.cern/root/html528/TSpectrum2Fit.html,6,['log'],['logical']
Testability,"lize (const char *queryref, Bool_t force=kFALSE); Finalize query with reference ref. ; ; Long64_tFinalize (Int_t query=-1, Bool_t force=kFALSE); Finalize the qry-th query in fQueries. ; ; TList *FindDataSets (const char *searchString, const char *optStr=""""); Find datasets, returns in a TList all found datasets. ; ; Long64_tGetBytesRead () const; ; Int_tGetClientProtocol () const; ; const char *GetConfDir () const; ; const char *GetConfFile () const; ; Float_tGetCpuTime () const; ; const char *GetDataPoolUrl () const; ; TMap *GetDataSetQuota (const char *optStr=""""); returns a map of the quotas of all groups ; ; TStringGetenv (const char *env, const char *ord=""0""); Get value of environment variable 'env' on node 'ord'. ; ; TList *GetFeedbackList () const; Return feedback list. ; ; const char *GetGroup () const; ; const char *GetImage () const; ; TList *GetInputList (); Get input list. ; ; TMacro *GetLastLog (); Fill a TMacro with the log lines since the last reading (fLogFileR) Return (TMacro *)0 if no line was logged. ; ; TList *GetListOfEnabledPackages (); Get from the master the list of names of the packages enabled. ; ; TList *GetListOfPackages (); Get from the master the list of names of the packages available. ; ; TList *GetListOfSlaveInfos (); Returns list of TSlaveInfo's. In case of error return 0. ; ; TList *GetLoadedMacros () const; ; voidGetLog (Int_t start=-1, Int_t end=-1); Ask for remote logs in the range [start, end]. ; ; Int_tGetLogLevel () const; ; TMacro *GetMacroLog (); ; TProofMgr *GetManager (); ; const char *GetMaster () const; ; voidGetMaxQueries (); Get max number of queries whose full results are kept in the remote sandbox. ; ; TFileCollection *GetMissingFiles (TQueryResult *qr=0); Get a TFileCollection with the files missing in the query described by 'qr' or the last query if qr is null (default). ; ; Int_tGetNumberOfDrawQueries (); ; Int_tGetNumberOfQueries (); Number of ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProofLite.html:11082,log,log,11082,doc/master/classTProofLite.html,https://root.cern,https://root.cern/doc/master/classTProofLite.html,2,['log'],"['log', 'logged']"
Testability,"lize points or compute distances. The geometry manager holds a list of active navigators accessible via:; TObjArray *navigators = gGeoManager->GetListOfNavigators();; Upon closing the geometry a default navigator is provided as first one in this list, but one may add its own via:; TGeoNavigator *navig = new TGeoNavigator(gGeoManager);; // Store the index of the user navigator; Int_t inav = gGeoManager->AddNavigator(navig);; // Make its own navigator the active one; gGeoManager->SetCurrentNavigator(inav);; // Switch between navigators; gGeoManager->SetCurrentNavigator(0);; A navigator holds several variables describing the current navigation state: current point position, current direction distance to next boundary, isotropic safety, pointer to current and next nods as well as several tracking flags related to volume boundary conditions or other properties required for track propagation in geometry. Each geometry query affects these variables, so the only way in testing several navigation alternatives and remembering the active navigation state is to use parallel navigation. The following paragraphs will describe the usage of a single navigator. All setters/getters for navigation state parameters as well as navigation queries provided by TGeoNavigator are interfaced by TGeoManager and will act on the current navigator.; 18.5.2 Initializing the Starting Point; The current point (x,y,z) known by the modeller is stored as Double_t fCurrentPoint[3] by the navigator class. This array of the three coordinates is defined in the current global reference system and can be retrieved any time:; Const Double_t *cpoint = gGeoManager->GetCurrentPoint();; Initializing this point can be done like:; gGeoManager->SetCurrentPoint(x,y,z);; // or:; gGeoManager->SetCurrentPoint(Double_t *point[3]);; 18.5.3 Initializing the Direction; In order to move inside geometry starting with the current point, the modeller needs to know the current direction (nx,ny,nz). This direction is stored as Dou",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:973032,test,testing,973032,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['test'],['testing']
Testability,"ll are:; fGid and fGroup; If group = 0, returns current user's group. The returned structure; must be deleted by the user. In case of error 0 is returned. void Setenv(const char* name, const char* value); Set environment variable. const char * Getenv(const char* name); Get environment variable. void Unsetenv(const char* name); Unset environment variable. int Exec(const char* shellcmd); Execute a command. FILE * OpenPipe(const char* shellcmd, const char* mode); Open a pipe. int ClosePipe(FILE* pipe); Close the pipe. int GetPid(); Get process id. void Exit(int code, Bool_t mode = kTRUE); Exit the application. void Abort(int code = 0); Abort the application. void StackTrace(); Print a stack trace. void Openlog(const char* name, Int_t options, ELogFacility facility); Open connection to system log daemon. For the use of the options and; facility see the Unix openlog man page. void Syslog(ELogLevel level, const char* mess); Send mess to syslog daemon. Level is the logging level and mess the; message that will be written on the log. void Closelog(); Close connection to system log daemon. Int_t RedirectOutput(const char* name, const char* mode = ""a"", RedirectHandle_t* h = 0); Redirect standard output (stdout, stderr) to the specified file.; If the file argument is 0 the output is set again to stderr, stdout.; The second argument specifies whether the output should be added to the; file (""a"", default) or the file be truncated before (""w"").; This function saves internally the current state into a static structure.; The call can be made reentrant by specifying the opaque structure pointed; by 'h', which is filled with the relevant information. The handle 'h'; obtained on the first call must then be used in any subsequent call,; included ShowOutput, to display the redirected output.; Returns 0 on success, -1 in case of error. Func_t DynFindSymbol(const char* module, const char* entry); dynamic linking of module. int Load(const char* module, const char* entry = """", Bool_t system",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TUnixSystem.html:30626,log,logging,30626,root/html534/TUnixSystem.html,https://root.cern,https://root.cern/root/html534/TUnixSystem.html,6,['log'],"['log', 'logging']"
Testability,"ll are:; fGid and fGroup; The returned structure must be deleted by the user. In case of; error 0 is returned. UserGroup_t * GetGroupInfo(const char* group = 0); Returns all group info in the UserGroup_t structure. The only active; fields in the UserGroup_t structure for this call are:; fGid and fGroup; If group = 0, returns current user's group. The returned structure; must be deleted by the user. In case of error 0 is returned. void Setenv(const char* name, const char* value); Set environment variable. void Unsetenv(const char* name); Unset environment variable. const char * Getenv(const char* env); Get environment variable. void Openlog(const char* name, Int_t options, ELogFacility facility); Open connection to system log daemon. For the use of the options and; facility see the Unix openlog man page. void Syslog(ELogLevel level, const char* mess); Send mess to syslog daemon. Level is the logging level and mess the; message that will be written on the log. void Closelog(); Close connection to system log daemon. Int_t RedirectOutput(const char* name, const char* mode = ""a"", RedirectHandle_t* h = 0); Redirect standard output (stdout, stderr) to the specified file.; If the file argument is 0 the output is set again to stderr, stdout.; The second argument specifies whether the output should be added to the; file (""a"", default) or the file be truncated before (""w"").; The implementations of this function save internally the current state into; a static structure.; The call can be made reentrant by specifying the opaque structure pointed; by 'h', which is filled with the relevant information. The handle 'h'; obtained on the first call must then be used in any subsequent call,; included ShowOutput, to display the redirected output.; Returns 0 on success, -1 in case of error. void ShowOutput(RedirectHandle_t* h); Display the content associated with the redirection described by the; opaque handle 'h'. void AddDynamicPath(const char* pathname); Add a new directory to the dyn",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TSystem.html:31804,log,log,31804,root/html528/TSystem.html,https://root.cern,https://root.cern/root/html528/TSystem.html,6,['log'],['log']
Testability,"ll as usual Pearson's test for; comparison two usual (unweighted) histograms. Overview:. Comparison of two histograms expect hypotheses that two histograms; represent identical distributions. To make a decision p-value should; be calculated. The hypotheses of identity is rejected if the p-value is; lower then some significance level. Traditionally significance levels; 0.1, 0.05 and 0.01 are used. The comparison procedure should include an; analysis of the residuals which is often helpful in identifying the; bins of histograms responsible for a significant overall value.; Residuals are the difference between bin contents and expected bin; contents. Most convenient for analysis are the normalized residuals. If; hypotheses of identity are valid then normalized residuals are; approximately independent and identically distributed random variables; having N(0,1) distribution. Analysis of residuals expect test of above; mentioned properties of residuals. Notice that indirectly the analysis; of residuals increase the power of test. Methods of comparison:. test for comparison two (unweighted) histograms:; Let us consider two histograms with the same binning and the number; of bins equal to r. Let us denote the number of events in the ith bin; in the first histogram as ni and as mi in the second one. The total; number of events in the first histogram is equal to:. and. in the second histogram. The hypothesis of identity (homogeneity) [3]; is that the two histograms represent random values with identical; distributions. It is equivalent that there exist r constants p1,...,pr,; such that. and the probability of belonging to the ith bin for some measured value; in both experiments is equal to pi. The number of events in the ith; bin is a random variable with a distribution approximated by a Poisson; probability distribution. for the first histogram and with distribution. for the second histogram. If the hypothesis of homogeneity is valid,; then the maximum likelihood estimator o",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TH1.html:46037,test,test,46037,root/html528/TH1.html,https://root.cern,https://root.cern/root/html528/TH1.html,6,['test'],['test']
Testability,"ll function for visible; 652 ; 653int RGeomDescription::ScanNodes(bool only_visible, int maxlvl, RGeomScanFunc_t func); 654{; 655 if (fDesc.empty()); 656 return 0;; 657 ; 658 std::vector<int> stack;; 659 stack.reserve(25); // reserve enough space for most use-cases; 660 int counter = 0;; 661 auto viter = fVisibility.begin();; 662 ; 663 using ScanFunc_t = std::function<int(int, int, bool)>;; 664 ; 665 ScanFunc_t scan_func = [&, this](int nodeid, int lvl, bool is_inside) {; 666 if (!is_inside && (fSelectedStack == stack)); 667 is_inside = true;; 668 ; 669 auto &desc = fDesc[nodeid];; 670 auto desc_vis = desc.vis;; 671 int res = 0;; 672 ; 673 if (desc.nochlds && (lvl > 0)); 674 lvl = 0;; 675 ; 676 bool can_display = desc.CanDisplay(), scan_childs = true;; 677 ; 678 if ((viter != fVisibility.end()) && (compare_stacks(viter->stack, stack) == 0)) {; 679 can_display = scan_childs = viter->visible;; 680 desc_vis = !viter->visible ? 0 : (!desc.chlds.empty() ? 1 : 99);; 681 viter++;; 682 }; 683 ; 684 // same logic as in JSROOT ClonedNodes.scanVisible; 685 bool is_visible = (lvl >= 0) && (desc_vis > lvl) && can_display && is_inside;; 686 ; 687 if (is_visible || !only_visible); 688 if (func(desc, stack, is_visible, counter)); 689 res++;; 690 ; 691 counter++; // count sequence id of current position in scan, will be used later for merging drawing lists; 692 ; 693 if ((!desc.chlds.empty()) && (((lvl > 0) && scan_childs) || !only_visible)) {; 694 auto pos = stack.size();; 695 stack.emplace_back(0);; 696 for (unsigned k = 0; k < desc.chlds.size(); ++k) {; 697 stack[pos] = k; // stack provides index in list of childs; 698 res += scan_func(desc.chlds[k], is_inside ? lvl - 1 : lvl, is_inside);; 699 }; 700 stack.pop_back();; 701 } else {; 702 counter += desc.idshift;; 703 }; 704 ; 705 return res;; 706 };; 707 ; 708 if (!maxlvl && (GetVisLevel() > 0)); 709 maxlvl = GetVisLevel();; 710 if (!maxlvl); 711 maxlvl = 4;; 712 if (maxlvl > 97); 713 maxlvl = 97; // check while vis property of no",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RGeomData_8cxx_source.html:18381,log,logic,18381,doc/master/RGeomData_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RGeomData_8cxx_source.html,2,['log'],['logic']
Testability,"ll functionalities of the modeller will behave in this case as if only the corresponding branch starting from this volume is the active geometry. A geometry hierarchy in memory. Nodes are never instantiated directly by users, but created as a result of volume operations. Adding a volume named A with a given user id inside a volume B will create a node named A_id. This will be added to the list of nodes stored by B. In addition, when applying a division operation in N slices to a volume A, a list of nodes B_1, B_2,  , B_N is also created. A node B_i does not represent a unique object in the geometry because its container A might be at its turn positioned as node inside several other volumes. Only when a complete branch of nodes is fully defined up to the top node in the geometry, a given path:/TOP_1//A_3/B_7 will represent a unique object. Its global transformation matrix can be computed as the pile-up of all local transformations in its branch. We will therefore call logical graph the hierarchy defined by nodes and volumes. The expansion of the logical graph by all possible paths defines a tree structure where all nodes are unique touchable objects. We will call this the physical tree. Unlike the logical graph, the physical tree can become a huge structure with several millions of nodes in case of complex geometries; therefore, it is not always a good idea to keep it transient in memory. Since the logical and physical structures are correlated, the modeller rather keeps track only of the current branch, updating the current global matrix at each change of the level in geometry. The current physical node is not an object that can be asked for at a given moment, but rather represented by the combination: current node/current global matrix. However, physical nodes have unique IDs that can be retrieved for a given modeller state. These can be fed back to the modeller in order to force a physical node to become current. The advantage of this comes from the fact tha",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:932327,log,logical,932327,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['log'],['logical']
Testability,"llHistosAndFit.C Read n-tuples in distinct workers, fill histograms, merge them and fit ; mt103_fillNtupleFromMultipleThreads.C Fill the same TNtuple from different threads ; mt201_parallelHistoFill.C Parallel fill of a histogram ; mt301_TTaskGroupSimple.C Shows how to run items of work asynchronously with a TTaskGroup ; mt302_TTaskGroupNested.C Calculate Fibonacci numbers exploiting nested parallelism through TTaskGroup ; mt304_fillHistos.CFill histograms in parallel with automatic binning ; mtbb001_fillHistos.C Fill histograms in parallel and write them on file ; mtbb101_fillNtuples.C Fill n-tuples in distinct workers ; mtbb201_parallelHistoFill.C Parallel fill of a histogram ; net; alien.C Example of use of the TAlien class (an implementation of TGrid) ; authclient.CThis macro should be run together with authserv.C to test authentication between two remote ROOT sessions ; authserv.CThis macro should be run together with authclient.C to test authentication between two remote ROOT sessions ; fastMergeServer.CThis script shows how to make a simple iterative server that can receive TMemFile from multiple clients and merge them into a single file without block ; hclient.CClient program which creates and fills a histogram ; hclientbonj.CClient program which creates and fills a histogram ; hcons.CHistogram consumer script ; hprod.CHistogram producer script ; hserv.CServer program which waits for two clients to connect ; hserv2.CThis script shows how to make a simple iterative server that can accept connections while handling currently open connections ; hserv2bonj.CThis script shows how to make a simple iterative server that can accept connections while handling currently open connections ; LDAPExample.C; parallelMergeClient.CClient program which creates and fills 2 histograms and a TTree ; parallelMergeServer.CThis script shows how to make a simple iterative server that can accept connections while handling currently open connections ; parallel",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v614/files.html:138496,test,test,138496,doc/v614/files.html,https://root.cern,https://root.cern/doc/v614/files.html,1,['test'],['test']
Testability,"llLinesdisplay all lines button; TGSplitButton*fAllWorkersdisplay all workers button; TGTextButton*fCloseclose button; TProofProgressDialog*fDialogowner dialog; TGTextEntry*fFileNamefile to save to; Bool_tfFullText0 - when grep was called; TGTextButton*fGrepButtongrep button; TGTextEntry*fGrepTexttext to grep for in the logs; TGNumberEntry*fLinesFromstarting line; TGNumberEntry*fLinesToending line; TGListBox*fLogListlist of workers; TGTextButton*fLogNewdisplay logs button; TProofLog*fProofLogthe log; TGCheckButton*fRawLinesdisplay raw lines button; TGTextButton*fSavesave button; TGNumberEntry*fSessNumrelative index of the session to get; Int_tfSessionIdx; TStringfSessionUrl; TGTextView*fTexttext widget; Int_tfTextTypeType of retrieval; TGTextButton*fUrlButtonrebuild button; TGTextEntry*fUrlTexturl to connect to; TGVerticalFrame*fVworkersVertical frame. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TProofProgressLog(TProofProgressDialog* d, Int_t w = 700, Int_t h = 600); Create a window frame for log messages. TProofProgressLog(const char* url = 0, Int_t sessionidx = 0, Int_t w = 700, Int_t h = 600); Create a window frame for log messages. void Init(Int_t w = 700, Int_t h = 600); Init window frame for log messages. ~TProofProgressLog(); Destructor. void Popup(); Show log window. void Clear(Option_t* = 0); Clear log window. void LoadBuffer(const char* buffer); Load a text buffer in the window. void LoadFile(const char* file); Load a file in the window. void AddBuffer(const char* buffer); Add text to the window. void CloseWindow(); Handle close button or when closed via window manager action. void BuildLogList(Bool_t create = kFALSE); Build the list of workers. For this, extract the logs and take the names; of TProofLogElements. void DoLog(Bool_t grep = kFALSE); Display the logs. void LogMessage(const char* msg, Bool_t all); Load/append a log msg in the log frame, if open. void SaveToFile(); Save the logs to a file; Only the",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TProofProgressLog.html:23263,log,log,23263,root/html528/TProofProgressLog.html,https://root.cern,https://root.cern/root/html528/TProofProgressLog.html,3,['log'],['log']
Testability,"lled in parallel with a multiprocess approach ; mp_H1_lambdas.C Lambdas used to check and fit the result of the H1 analysis ; mt001_fillHistos.CFill histograms in parallel and write them on file ; mt101_fillNtuples.CFill n-tuples in distinct workers ; mt102_readNtuplesFillHistosAndFit.CRead n-tuples in distinct workers, fill histograms, merge them and fit ; mt103_fillNtupleFromMultipleThreads.CFill the same TNtuple from different threads ; mt201_parallelHistoFill.CParallel fill of a histogram ; mtbb001_fillHistos.CFill histograms in parallel and write them on file ; mtbb101_fillNtuples.CFill n-tuples in distinct workers ; mtbb201_parallelHistoFill.CParallel fill of a histogram ; net; alien.C Example of use of the TAlien class (an implementation of TGrid) ; authclient.CThis macro should be run together with authserv.C to test authentication between two remote ROOT sessions ; authserv.CThis macro should be run together with authclient.C to test authentication between two remote ROOT sessions ; fastMergeServer.CThis script shows how to make a simple iterative server that can receive TMemFile from multiple clients and merge them into a single file without block ; hclient.CClient program which creates and fills a histogram ; hclientbonj.CClient program which creates and fills a histogram ; hcons.CHistogram consumer script ; hprod.CHistogram producer script ; hserv.CServer program which waits for two clients to connect ; hserv2.CThis script shows how to make a simple iterative server that can accept connections while handling currently open connections ; hserv2bonj.CThis script shows how to make a simple iterative server that can accept connections while handling currently open connections ; LDAPExample.C; parallelMergeClient.CClient program which creates and fills 2 histograms and a TTree ; parallelMergeServer.CThis script shows how to make a simple iterative server that can accept connections while handling currently open connections ; parallel",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v610/files.html:135406,test,test,135406,doc/v610/files.html,https://root.cern,https://root.cern/doc/v610/files.html,1,['test'],['test']
Testability,"llipseTGraphDLSF.cxx; fitEllipseTGraphRMM.cxx; fitExclude.C Illustrates how to fit excluding points in a given range ; fithist.C Example of fit where the model is histogram + function ; fitLinear.C Example of fitting with a linear function, using TLinearFitter This example is for a TGraphErrors, but it can also be used when fitting a histogram, a TGraph2D or a TMultiGraph ; fitLinear2.C Fit a 5d hyperplane by n points, using the linear fitter directly ; fitLinearRobust.C This tutorial shows how the least trimmed squares regression, included in the TLinearFitter class, can be used for fitting in cases when the data contains outliers ; fitMultiGraph.C fitting a parabola to a multigraph of 3 partly overlapping graphs with different errors ; fitNormSum.C Tutorial for normalized sum of two functions Here: a background exponential and a crystalball function Parameters can be set: ; fitpanel_playback.CThis file will test all the transient frames (aka Dialog windows) displayed in the fitpanel, as the rest of the functionality is tried automatically with the UnitTest.C unit ; fitslicesy.C Illustrates how to use the TH1::FitSlicesY function It uses the TH2F histogram generated in macro hsimple.C It invokes FitSlicesY and draw the fitted ""mean"" and ""sigma"" in 2 sepate pads ; FittingDemo.C Example for fitting signal/background ; graph2dfit.C Fitting a TGraph2D ; Ifit.C Example of a program to fit non-equidistant data points ; langaus.C Convoluted Landau and Gaussian Fitting Function (using ROOT's Landau and Gauss functions) ; line3Dfit.C Fitting of a TGraph2D with a 3D straight line ; minuit2FitBench.C Demonstrate performance and usage of Minuit2 and Fumili2 for monodimensional fits ; minuit2FitBench2D.C ; minuit2GausFit.C Perform fits with different configurations using Minuit2 ; multidimfit.C Multi-Dimensional Parametrisation and Fitting ; multifit.C Fitting multiple functions to different ranges of a 1-D histogram Example showing how to fit in a sub-range",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v608/files.html:105917,test,test,105917,doc/v608/files.html,https://root.cern,https://root.cern/doc/v608/files.html,5,['test'],['test']
Testability,"llocate.; 5338 SetBit(kDeleteObject);; 5339 fObject = (char*) new TClonesArray(fClonesClass);; 5340 fAddress = (char*) &fObject;; 5341 } else {; 5342 // -- We are a sub-branch which is a pointer to a TClonesArray.; 5343 Error(""SetAddress"", ""Embedded pointer to a TClonesArray given a zero address for branch '%s'"", GetName());; 5344 }; 5345 }; 5346 }; 5347 } else if (fType == 4) {; 5348 // -- We are an STL container master branch.; 5349 //; 5350 // Initialize fCollProxy.; 5351 TVirtualCollectionProxy* proxy = GetCollectionProxy();; 5352 if (fAddress) {; 5353 // -- We have been given a non-zero address, allocate if necessary.; 5354 if ((fStreamerType == TVirtualStreamerInfo::kObject) ||; 5355 (fStreamerType == TVirtualStreamerInfo::kAny) ||; 5356 (fStreamerType == TVirtualStreamerInfo::kSTL)) {; 5357 // We are *not* a top-level branch and we are *not* a pointer to an STL container.; 5358 // Case of an embedded STL container.; 5359 // Note: We test for the kObject and kAny types to support; 5360 // the (unwise) choice of inheriting from an STL container.; 5361 fObject = fAddress;; 5362 } else {; 5363 // We are either a top-level branch or subbranch which is a pointer to an STL container.; 5364 // Streamer type should be -1 (for a top-level branch) or kSTLp here.; 5365 if ((fStreamerType != -1) && (fStreamerType != TVirtualStreamerInfo::kSTLp)) {; 5366 Error(""SetAddress"",; 5367 ""Branch %s is a split STL container (fStreamerType is: %d), the address can not be set directly."",; 5368 GetName(), fStreamerType);; 5369 } else if (fStreamerType == -1) {; 5370 // -- We are a top-level branch.; 5371 void** pp = (void**) fAddress;; 5372 if (!*pp) {; 5373 // -- Caller wants us to allocate the STL container, but they will own it.; 5374 *pp = proxy->New();; 5375 if (!(*pp)) {; 5376 Error(""SetAddress"", ""Failed to allocate STL container for branch '%s'"", GetName());; 5377 // FIXME: Should we do this? Lots of other code wants; 5378 // fAddress to be zero if no fObject, but is; 5379 // th",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TBranchElement_8cxx_source.html:198643,test,test,198643,doc/master/TBranchElement_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TBranchElement_8cxx_source.html,1,['test'],['test']
Testability,"lobal event weights per tree (see below for setting event-wise weights); 198 Double_t regWeight = 1.0;; 199 ; 200 // You can add an arbitrary number of regression trees; 201 dataloader->AddRegressionTree( regTree, regWeight );; 202 ; 203 // This would set individual event weights (the variables defined in the; 204 // expression need to exist in the original TTree); 205 dataloader->SetWeightExpression( ""var1"", ""Regression"" );; 206 ; 207 // Apply additional cuts on the signal and background samples (can be different); 208 TCut mycut = """"; // for example: TCut mycut = ""abs(var1)<0.5 && abs(var2-0.5)<1"";; 209 ; 210 // tell the DataLoader to use all remaining events in the trees after training for testing:; 211 dataloader->PrepareTrainingAndTestTree( mycut,; 212 ""nTrain_Regression=1000:nTest_Regression=0:SplitMode=Random:NormMode=NumEvents:!V"" );; 213 //; 214 // dataloader->PrepareTrainingAndTestTree( mycut,; 215 // ""nTrain_Regression=0:nTest_Regression=0:SplitMode=Random:NormMode=NumEvents:!V"" );; 216 ; 217 // If no numbers of events are given, half of the events in the tree are used; 218 // for training, and the other half for testing:; 219 //; 220 // dataloader->PrepareTrainingAndTestTree( mycut, ""SplitMode=random:!V"" );; 221 ; 222 // Book MVA methods; 223 //; 224 // Please lookup the various method configuration options in the corresponding cxx files, eg:; 225 // src/MethoCuts.cxx, etc, or here: http://tmva.sourceforge.net/old_site/optionRef.html; 226 // it is possible to preset ranges in the option string in which the cut optimisation should be done:; 227 // ""...:CutRangeMin[2]=-1:CutRangeMax[2]=1""..."", where [2] is the third input variable; 228 ; 229 // PDE - RS method; 230 if (Use[""PDERS""]); 231 factory->BookMethod( dataloader, TMVA::Types::kPDERS, ""PDERS"",; 232 ""!H:!V:NormTree=T:VolumeRangeMode=Adaptive:KernelEstimator=Gauss:GaussSigma=0.3:NEventsMin=40:NEventsMax=60:VarTransform=None"" );; 233 // And the options strings for the MinMax and RMS methods, respectivel",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVARegression_8C_source.html:8097,test,testing,8097,doc/master/TMVARegression_8C_source.html,https://root.cern,https://root.cern/doc/master/TMVARegression_8C_source.html,2,['test'],['testing']
Testability,"locate some ; vo002_VectorCalculations.C In this tutorial we learn how the RVec class can be used to express easily mathematical operations involving arrays and scalars ; vo003_LogicalOperations.C In this tutorial we learn how the RVec class can be used to express logical operations ; xml; DOMParsePerson.C ROOT implementation of a XML DOM Parser ; DOMRecursive.C ROOT implementation of a XML DOM Parser ; SAXHandler.C ROOT implementation of a simple SAX Handler ; xmlmodifyfile.C Example to read, modify and store xml file, using TXMLEngine class The input file, produced by xmlnewfile.C macro is used If you need full xml syntax support, use TXMLParser instead ; xmlnewfile.C Example to create a new xml file with the TXMLEngine class ; xmlreadfile.C Example to read and parse any xml file, supported by TXMLEngine class The input file, produced by xmlnewfile.C macro is used If you need full xml syntax support, use TXMLParser instead ; benchmarks.CThis macro run several tests and produces an benchmark report ; demos.CThis macro shows a control bar to run some of the ROOT tutorials ; demoshelp.CThis macro shows help on running the Demos ; geant3tasks.CThis script is a representation using TTasks of the Geant3 simulation program This example uses directly TTask objects ; hsimple.C This program creates : ; htmlex.CThis file demonstrates how THtml can document sources ; MyTasks.cxxA set of classes deriving from TTask ; regexp.CA regular expression, often called a pattern, is an expression that describes a set of strings ; regexp_pme.CClass TPMERegexp - API similar to PME - PCRE Made Easy Tries to be as close as possible to PERL syntax and functionality ; rootalias.CDefines aliases: ; rootenv.CProduce a picture of the ROOT environment ; rootlogoff.CExample of rootlogoff.C ; rootlogon.CExample of rootlogon.C ; rootmarks.CPrints a summary of all ROOT benchmarks (must be run before) ; tasks.CExample of TTasks . ROOT 6.14/05 - Reference Guide Generated on Fr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v614/files.html:166323,test,tests,166323,doc/v614/files.html,https://root.cern,https://root.cern/doc/v614/files.html,2,"['benchmark', 'test']","['benchmark', 'tests']"
Testability,"located so far. Same as Capacity. Use GetEntries to get the number of elements currently in the collection. ; Reimplemented in THashTable, TListOfEnumsWithLock, TListOfFunctions, TViewPubDataMembers, and TViewPubFunctions.; Definition at line 184 of file TCollection.h. GrowBy(). Int_t TCollection::GrowBy ; (; Int_t; delta); const. virtual . Increase the collection's capacity by delta slots. ; Definition at line 360 of file TCollection.cxx. Hash(). ULong_t TCollection::Hash ; (; ); const. inlineoverridevirtual . Return hash value for this object. ; Note: If this routine is overloaded in a derived class, this derived class should also add ROOT::CallRecursiveRemoveIfNeeded(*this); ROOT::CallRecursiveRemoveIfNeededvoid CallRecursiveRemoveIfNeeded(TObject &obj)call RecursiveRemove for obj if gROOT is valid and obj.TestBit(kMustCleanup) is true.Definition TROOT.h:395; Otherwise, when RecursiveRemove is called (by ~TObject or example) for this type of object, the transversal of THashList and THashTable containers will will have to be done without call Hash (and hence be linear rather than logarithmic complexity). You will also see warnings like Error in <ROOT::Internal::TCheckHashRecursiveRemoveConsistency::CheckRecursiveRemove>: The class SomeName overrides TObject::Hash but does not call TROOT::RecursiveRemove in its destructor.; TCollection::HashULong_t Hash() const overrideReturn hash value for this object.Definition TCollection.h:186; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:987; TROOT::RecursiveRemovevoid RecursiveRemove(TObject *obj) overrideRecursively remove this object from the list of Cleanups.Definition TROOT.cxx:2498. Reimplemented from TObject.; Definition at line 186 of file TCollection.h. IsA(). TClass * TCollection::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemen",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTCollection.html:23895,log,logarithmic,23895,doc/v632/classTCollection.html,https://root.cern,https://root.cern/doc/v632/classTCollection.html,1,['log'],['logarithmic']
Testability,"located so far. Same as Capacity. Use GetEntries to get the number of elements currently in the collection. ; Reimplemented in THashTable, TListOfEnumsWithLock, TListOfFunctions, TViewPubDataMembers, and TViewPubFunctions.; Definition at line 184 of file TCollection.h. GrowBy(). Int_t TCollection::GrowBy ; (; Int_t; delta); const. virtual . Increase the collection's capacity by delta slots. ; Definition at line 360 of file TCollection.cxx. Hash(). ULong_t TCollection::Hash ; (; ); const. inlineoverridevirtual . Return hash value for this object. ; Note: If this routine is overloaded in a derived class, this derived class should also add ROOT::CallRecursiveRemoveIfNeeded(*this); ROOT::CallRecursiveRemoveIfNeededvoid CallRecursiveRemoveIfNeeded(TObject &obj)call RecursiveRemove for obj if gROOT is valid and obj.TestBit(kMustCleanup) is true.Definition TROOT.h:395; Otherwise, when RecursiveRemove is called (by ~TObject or example) for this type of object, the transversal of THashList and THashTable containers will will have to be done without call Hash (and hence be linear rather than logarithmic complexity). You will also see warnings like Error in <ROOT::Internal::TCheckHashRecursiveRemoveConsistency::CheckRecursiveRemove>: The class SomeName overrides TObject::Hash but does not call TROOT::RecursiveRemove in its destructor.; TCollection::HashULong_t Hash() const overrideReturn hash value for this object.Definition TCollection.h:186; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TROOT::RecursiveRemovevoid RecursiveRemove(TObject *obj) overrideRecursively remove this object from the list of Cleanups.Definition TROOT.cxx:2498. Reimplemented from TObject.; Definition at line 186 of file TCollection.h. IsA(). TClass * TCollection::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemen",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTCollection.html:23896,log,logarithmic,23896,doc/master/classTCollection.html,https://root.cern,https://root.cern/doc/master/classTCollection.html,1,['log'],['logarithmic']
Testability,"lock::now();; 1233 ; 1234 // Compute training error.; 1235 Double_t trainingError = 0.0;; 1236 for (auto batch : trainingData) {; 1237 auto inputMatrix = batch.GetInput();; 1238 auto outputMatrix = batch.GetOutput();; 1239 auto weightMatrix = batch.GetWeights();; 1240 trainingError += net.Loss(inputMatrix, outputMatrix, weightMatrix);; 1241 }; 1242 trainingError /= (Double_t) (nTrainingSamples / settings.batchSize);; 1243 ; 1244 //Log the loss value; 1245 fTrainHistory.AddValue(""trainingError"",stepCount,trainingError);; 1246 ; 1247 if (fInteractive){; 1248 fInteractive->AddPoint(stepCount, trainingError, testError);; 1249 fIPyCurrentIter = 100*(double)minimizer.GetConvergenceCount() /(double)settings.convergenceSteps;; 1250 if (fExitFromTraining) break;; 1251 }; 1252 ; 1253 // Compute numerical throughput.; 1254 std::chrono::duration<double> elapsed_seconds = end - start;; 1255 double seconds = elapsed_seconds.count();; 1256 double nFlops = (double) (settings.testInterval * batchesInEpoch);; 1257 nFlops *= net.GetNFlops() * 1e-9;; 1258 ; 1259 converged = minimizer.HasConverged(testError);; 1260 start = std::chrono::system_clock::now();; 1261 ; 1262 if (fInteractive) {; 1263 fInteractive->AddPoint(stepCount, trainingError, testError);; 1264 fIPyCurrentIter = 100.0 * minimizer.GetConvergenceCount(); 1265 / minimizer.GetConvergenceSteps ();; 1266 if (fExitFromTraining) break;; 1267 } else {; 1268 Log() << std::setw(10) << stepCount << "" | ""; 1269 << std::setw(12) << trainingError; 1270 << std::setw(12) << testError; 1271 << std::setw(12) << nFlops / seconds; 1272 << std::setw(12) << minimizer.GetConvergenceCount() << Endl;; 1273 if (converged) {; 1274 Log() << Endl;; 1275 }; 1276 }; 1277 }; 1278 }; 1279 ; 1280 ; 1281 for (size_t l = 0; l < net.GetDepth(); l++) {; 1282 auto & layer = fNet.GetLayer(l);; 1283 layer.GetWeights() = (TMatrixT<Scalar_t>) net.GetLayer(l).GetWeights();; 1284 layer.GetBiases() = (TMatrixT<Scalar_t>) net.GetLayer(l).GetBiases();; 1285 }; 1286 }; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/MethodDNN_8cxx_source.html:45342,test,testInterval,45342,doc/master/MethodDNN_8cxx_source.html,https://root.cern,https://root.cern/doc/master/MethodDNN_8cxx_source.html,1,['test'],['testInterval']
Testability,"log */; 15329 pthread_mutex_unlock(&ctx->lua_bg_mutex);; 15330 return;; 15331 }; 15332 /* Copy test from Lua into log_buf */; 15333 if (len >= sizeof(log_buf)) {; 15334 len = sizeof(log_buf) - 1;; 15335 }; 15336 memcpy(log_buf, txt, len);; 15337 log_buf[len] = 0;; 15338 }; 15339 } else {; 15340 lua_cry(conn, ret, lstate, ""lua_background_script"", ""log"");; 15341 }; 15342 pthread_mutex_unlock(&ctx->lua_bg_mutex);; 15343 }; 15344#endif; 15345 ; 15346 if (conn->dom_ctx->config[ACCESS_LOG_FILE] != NULL) {; 15347 if (mg_fopen(conn,; 15348 conn->dom_ctx->config[ACCESS_LOG_FILE],; 15349 MG_FOPEN_MODE_APPEND,; 15350 &fi); 15351 == 0) {; 15352 fi.access.fp = NULL;; 15353 }; 15354 } else {; 15355 fi.access.fp = NULL;; 15356 }; 15357 ; 15358 /* Log is written to a file and/or a callback. If both are not set,; 15359 * executing the rest of the function is pointless. */; 15360 if ((fi.access.fp == NULL); 15361 && (conn->phys_ctx->callbacks.log_access == NULL)) {; 15362 return;; 15363 }; 15364 ; 15365 /* If we did not get a log message from Lua, create it here. */; 15366 if (!log_buf[0]) {; 15367 tm = localtime(&conn->conn_birth_time);; 15368 if (tm != NULL) {; 15369 strftime(date, sizeof(date), ""%d/%b/%Y:%H:%M:%S %z"", tm);; 15370 } else {; 15371 mg_strlcpy(date, ""01/Jan/1970:00:00:00 +0000"", sizeof(date));; 15372 date[sizeof(date) - 1] = '\0';; 15373 }; 15374 ; 15375 ri = &conn->request_info;; 15376 ; 15377 sockaddr_to_string(src_addr, sizeof(src_addr), &conn->client.rsa);; 15378 referer = header_val(conn, ""Referer"");; 15379 user_agent = header_val(conn, ""User-Agent"");; 15380 ; 15381 mg_snprintf(conn,; 15382 NULL, /* Ignore truncation in access log */; 15383 log_buf,; 15384 sizeof(log_buf),; 15385 ""%s - %s [%s] \""%s %s%s%s HTTP/%s\"" %d %"" INT64_FMT; 15386 "" %s %s"",; 15387 src_addr,; 15388 (ri->remote_user == NULL) ? ""-"" : ri->remote_user,; 15389 date,; 15390 ri->request_method ? ri->request_method : ""-"",; 15391 ri->request_uri ? ri->request_uri : ""-"",; 15392 ri->query_string ? ""?""",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:454190,log,log,454190,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,1,['log'],['log']
Testability,"log */; 15330 pthread_mutex_unlock(&ctx->lua_bg_mutex);; 15331 return;; 15332 }; 15333 /* Copy test from Lua into log_buf */; 15334 if (len >= sizeof(log_buf)) {; 15335 len = sizeof(log_buf) - 1;; 15336 }; 15337 memcpy(log_buf, txt, len);; 15338 log_buf[len] = 0;; 15339 }; 15340 } else {; 15341 lua_cry(conn, ret, lstate, ""lua_background_script"", ""log"");; 15342 }; 15343 pthread_mutex_unlock(&ctx->lua_bg_mutex);; 15344 }; 15345#endif; 15346 ; 15347 if (conn->dom_ctx->config[ACCESS_LOG_FILE] != NULL) {; 15348 if (mg_fopen(conn,; 15349 conn->dom_ctx->config[ACCESS_LOG_FILE],; 15350 MG_FOPEN_MODE_APPEND,; 15351 &fi); 15352 == 0) {; 15353 fi.access.fp = NULL;; 15354 }; 15355 } else {; 15356 fi.access.fp = NULL;; 15357 }; 15358 ; 15359 /* Log is written to a file and/or a callback. If both are not set,; 15360 * executing the rest of the function is pointless. */; 15361 if ((fi.access.fp == NULL); 15362 && (conn->phys_ctx->callbacks.log_access == NULL)) {; 15363 return;; 15364 }; 15365 ; 15366 /* If we did not get a log message from Lua, create it here. */; 15367 if (!log_buf[0]) {; 15368 tm = localtime(&conn->conn_birth_time);; 15369 if (tm != NULL) {; 15370 strftime(date, sizeof(date), ""%d/%b/%Y:%H:%M:%S %z"", tm);; 15371 } else {; 15372 mg_strlcpy(date, ""01/Jan/1970:00:00:00 +0000"", sizeof(date));; 15373 date[sizeof(date) - 1] = '\0';; 15374 }; 15375 ; 15376 ri = &conn->request_info;; 15377 ; 15378 sockaddr_to_string(src_addr, sizeof(src_addr), &conn->client.rsa);; 15379 referer = header_val(conn, ""Referer"");; 15380 user_agent = header_val(conn, ""User-Agent"");; 15381 ; 15382 mg_snprintf(conn,; 15383 NULL, /* Ignore truncation in access log */; 15384 log_buf,; 15385 sizeof(log_buf),; 15386 ""%s - %s [%s] \""%s %s%s%s HTTP/%s\"" %d %"" INT64_FMT; 15387 "" %s %s"",; 15388 src_addr,; 15389 (ri->remote_user == NULL) ? ""-"" : ri->remote_user,; 15390 date,; 15391 ri->request_method ? ri->request_method : ""-"",; 15392 ri->request_uri ? ri->request_uri : ""-"",; 15393 ri->query_string ? ""?""",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:454223,log,log,454223,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,1,['log'],['log']
Testability,"logEvalError(const char* message, const char* serverValueString = 0) const; Log evaluation error message. Evaluation errors may be routed through a different; protocol than generic RooFit warning message (which go straight through RooMsgService); because evaluation errors can occur in very large numbers in the use of likelihood; evaluations. In logEvalError mode, controlled by global method enableEvalErrorLogging(); messages reported through this function are not printed but all stored in a list,; along with server values at the time of reporting. Error messages logged in this; way can be printed in a structured way, eliminating duplicates and with the ability; to truncate the list by printEvalErrors. This is the standard mode of error logging; during MINUIT operations. If enableEvalErrorLogging() is false, all errors; reported through this method are passed for immediate printing through RooMsgService.; A string with server names and values is constructed automatically for error logging; purposes, unless a custom string with similar information is passed as argument. void clearEvalErrorLog(); Clear the stack of evaluation error messages. void printEvalErrors(ostream& os = std::cout, Int_t maxPerNode = 10000000); Print all outstanding logged evaluation error on the given ostream. If maxPerNode; is zero, only the number of errors for each source (object with unique name) is listed.; If maxPerNode is greater than zero, up to maxPerNode detailed error messages are shown; per source of errors. A truncation message is shown if there were more errors logged; than shown. Int_t numEvalErrors(); Return the number of logged evaluation errors since the last clearing. void fixAddCoefNormalization(const RooArgSet& addNormSet = RooArgSet(), Bool_t force = kTRUE); Fix the interpretation of the coefficient of any RooAddPdf component in; the expression tree headed by this object to the given set of observables. If the force flag is false, the normalization choice is only fixed for t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAbsReal.html:62458,log,logging,62458,root/html526/RooAbsReal.html,https://root.cern,https://root.cern/root/html526/RooAbsReal.html,7,['log'],['logging']
Testability,"logx = false) const; Return the maximum value of the function; Method:; First, the grid search is used to bracket the maximum; with the step size = (xmax-xmin)/fNpx.; This way, the step size can be controlled via the SetNpx() function.; If the function is unimodal or if its extrema are far apart, setting; the fNpx to a small value speeds the algorithm up many times.; Then, Brent's method is applied on the bracketed interval; epsilon (default = 1.E-10) controls the relative accuracy (if |x| > 1 ); and absolute (if |x| < 1) and maxiter (default = 100) controls the maximum number; of iteration of the Brent algorithm; If the flag logx is set the grid search is done in log step size; This is done automatically if the log scale is set in the current Pad. NOTE: see also TF1::GetMaximumX and TF1::GetX. Double_t GetMaximumX(Double_t xmin = 0, Double_t xmax = 0, Double_t epsilon = 1.0E-10, Int_t maxiter = 100, Bool_t logx = false) const; Return the X value corresponding to the maximum value of the function; Method:; First, the grid search is used to bracket the maximum; with the step size = (xmax-xmin)/fNpx.; This way, the step size can be controlled via the SetNpx() function.; If the function is unimodal or if its extrema are far apart, setting; the fNpx to a small value speeds the algorithm up many times.; Then, Brent's method is applied on the bracketed interval; epsilon (default = 1.E-10) controls the relative accuracy (if |x| > 1 ); and absolute (if |x| < 1) and maxiter (default = 100) controls the maximum number; of iteration of the Brent algorithm; If the flag logx is set the grid search is done in log step size; This is done automatically if the log scale is set in the current Pad. NOTE: see also TF1::GetX. Double_t GetMinimum(Double_t xmin = 0, Double_t xmax = 0, Double_t epsilon = 1.0E-10, Int_t maxiter = 100, Bool_t logx = false) const; Returns the minimum value of the function on the (xmin, xmax) interval; Method:; First, the grid search is used to bracket the maxi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TF1.html:43179,log,logx,43179,root/html602/TF1.html,https://root.cern,https://root.cern/root/html602/TF1.html,2,['log'],['logx']
Testability,"logx = false) const; Return the maximum value of the function; Method:; First, the grid search is used to bracket the maximum; with the step size = (xmax-xmin)/fNpx.; This way, the step size can be controlled via the SetNpx() function.; If the function is unimodal or if its extrema are far apart, setting; the fNpx to a small value speeds the algorithm up many times.; Then, Brent's method is applied on the bracketed interval; epsilon (default = 1.E-10) controls the relative accuracy (if |x| > 1 ); and absolute (if |x| < 1) and maxiter (default = 100) controls the maximum number; of iteration of the Brent algorithm; If the flag logx is set the grid search is done in log step size; This is done automatically if the log scale is set in the current Pad. NOTE: see also TF1::GetMaximumX and TF1::GetX. Double_t GetMaximumX(Double_t xmin = 0, Double_t xmax = 0, Double_t epsilon = 1.E-10, Int_t maxiter = 100, Bool_t logx = false) const; Return the X value corresponding to the maximum value of the function; Method:; First, the grid search is used to bracket the maximum; with the step size = (xmax-xmin)/fNpx.; This way, the step size can be controlled via the SetNpx() function.; If the function is unimodal or if its extrema are far apart, setting; the fNpx to a small value speeds the algorithm up many times.; Then, Brent's method is applied on the bracketed interval; epsilon (default = 1.E-10) controls the relative accuracy (if |x| > 1 ); and absolute (if |x| < 1) and maxiter (default = 100) controls the maximum number; of iteration of the Brent algorithm; If the flag logx is set the grid search is done in log step size; This is done automatically if the log scale is set in the current Pad. NOTE: see also TF1::GetX. Double_t GetMinimum(Double_t xmin = 0, Double_t xmax = 0, Double_t epsilon = 1.E-10, Int_t maxiter = 100, Bool_t logx = false) const; Returns the minimum value of the function on the (xmin, xmax) interval; Method:; First, the grid search is used to bracket the maxim",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TF1.html:40070,log,logx,40070,root/html528/TF1.html,https://root.cern,https://root.cern/root/html528/TF1.html,4,['log'],['logx']
Testability,"lor(""reset"") << Endl;; 1274 ; 1275 // don't do anything if no method booked; 1276 if (fMethodsMap.empty()) {; 1277 Log() << kINFO << ""...nothing found to test"" << Endl;; 1278 return;; 1279 }; 1280 std::map<TString, MVector *>::iterator itrMap;; 1281 ; 1282 for (itrMap = fMethodsMap.begin(); itrMap != fMethodsMap.end(); ++itrMap) {; 1283 MVector *methods = itrMap->second;; 1284 MVector::iterator itrMethod;; 1285 ; 1286 // iterate over methods and test; 1287 for (itrMethod = methods->begin(); itrMethod != methods->end(); ++itrMethod) {; 1288 Event::SetIsTraining(kFALSE);; 1289 MethodBase *mva = dynamic_cast<MethodBase *>(*itrMethod);; 1290 if (mva == 0); 1291 continue;; 1292 Types::EAnalysisType analysisType = mva->GetAnalysisType();; 1293 Log() << kHEADER << ""Test method: "" << mva->GetMethodName() << "" for ""; 1294 << (analysisType == Types::kRegression; 1295 ? ""Regression""; 1296 : (analysisType == Types::kMulticlass ? ""Multiclass classification"" : ""Classification"")); 1297 << "" performance"" << Endl << Endl;; 1298 mva->AddOutput(Types::kTesting, analysisType);; 1299 }; 1300 }; 1301}; 1302 ; 1303////////////////////////////////////////////////////////////////////////////////; 1304 ; 1305void TMVA::Factory::MakeClass(const TString &datasetname, const TString &methodTitle) const; 1306{; 1307 if (methodTitle != """") {; 1308 IMethod *method = GetMethod(datasetname, methodTitle);; 1309 if (method); 1310 method->MakeClass();; 1311 else {; 1312 Log() << kWARNING << ""<MakeClass> Could not find classifier \"""" << methodTitle << ""\"" in list"" << Endl;; 1313 }; 1314 } else {; 1315 ; 1316 // no classifier specified, print all help messages; 1317 MVector *methods = fMethodsMap.find(datasetname)->second;; 1318 MVector::const_iterator itrMethod;; 1319 for (itrMethod = methods->begin(); itrMethod != methods->end(); ++itrMethod) {; 1320 MethodBase *method = dynamic_cast<MethodBase *>(*itrMethod);; 1321 if (method == 0); 1322 continue;; 1323 Log() << kINFO << ""Make response class for classi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/tmva_2tmva_2src_2Factory_8cxx_source.html:52522,test,test,52522,doc/master/tmva_2tmva_2src_2Factory_8cxx_source.html,https://root.cern,https://root.cern/doc/master/tmva_2tmva_2src_2Factory_8cxx_source.html,1,['test'],['test']
Testability,"lor[17]! GL color array; TGLPShapeRef*fFirstPSRef! pointer to first reference; UInt_tfID! unique physical ID within containing scene; Bool_tfInvertedWind! face winding TODO: can get directly from fTransform?; Bool_tfIsScaleForRnr! cache ; const TGLLogicalShape*fLogicalShape! the associated logical shape; TGLPhysicalShape::EManipfManip! permitted manipulation bitflags - see EManip; Bool_tfModified! has been modified - retain across scene rebuilds; TGLPhysicalShape*fNextPhysical! pointer to next replica; UChar_tfSelected! selected state; TGLMatrixfTransform! transform (placement) of physical instance. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGLPhysicalShape(UInt_t ID, const TGLLogicalShape& logicalShape, const TGLMatrix& transform, Bool_t invertedWind, const Float_t* rgba); Construct a physical shape using arguments:; ID - unique drawable id.; logicalShape - bound logical shape; transform - transform for placement of logical drawing; invertedWind - use inverted face polygon winding?; rgba - basic four component (RGBA) diffuse color. TGLPhysicalShape(UInt_t ID, const TGLLogicalShape& logicalShape, const double* transform, Bool_t invertedWind, const Float_t* rgba); Construct a physical shape using arguments:; id - unique drawable id.; logicalShape - bound logical shape; transform - 16 Double_t component transform for placement of logical drawing; invertedWind - use inverted face polygon winding?; rgba - basic four component (RGBA) diffuse color. ~TGLPhysicalShape(); Destroy the physical shape. void AddReference(TGLPShapeRef* ref); Add reference ref. void RemoveReference(TGLPShapeRef* ref); Remove reference ref. void Modified(); Call this after modifying the physical so that the information; can be propagated to the object referencing it. void UpdateBoundingBox(); Update our internal bounding box (in global frame). void InitColor(const Float_t* rgba); Initialise the colors, using basic RGBA diffuse material color supplie",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGLPhysicalShape.html:4645,log,logicalShape,4645,root/html534/TGLPhysicalShape.html,https://root.cern,https://root.cern/root/html534/TGLPhysicalShape.html,3,['log'],"['logical', 'logicalShape']"
Testability,"lor_t cidx = -1, UChar_t transp = 0); Reposition/recolor physical shape. void UpdatePhysioLogical(TObject* logid, Double_t* trans, UChar_t* col); Reposition/recolor physical for given logical (assume TGLObject and; a single physical). void UpdatePhysioLogical(TObject* logid, Double_t* trans, Color_t cidx, UChar_t transp); Reposition/recolor physical for given logical (assume TGLObject and; a single physical). UInt_t BeginSmartRefresh(); Moves logicals that support smart-refresh to intermediate cache.; Destroys the others and returns the number of destroyed ones. void EndSmartRefresh(); Wipes logicals in refresh-cache. TGLLogicalShape * FindLogicalSmartRefresh(TObject* ID) const; Find and return logical shape identified by unqiue 'ID' in refresh-cache.; Returns 0 if not found. UInt_t SizeOfScene() const; Return memory cost of scene.; Warning: NOT CORRECT at present - doesn't correctly calculate size.; of logical shapes with dynamic internal contents. void DumpMapSizes() const; Print sizes of logical nad physical-shape maps. void RGBAFromColorIdx(Float_t* rgba, Color_t ci, Char_t transp = 0); Fill rgba color from ROOT color-index ci and transparency (0->100). Bool_t IsOutside(const TGLBoundingBox& box, const TGLPlaneSet_t& planes); Check if box is outside of all planes. TGLScene(const TGLScene& ). TGLScene& operator=(const TGLScene& ). TSceneInfo* CreateSceneInfo(TGLViewerBase* view). LogicalShapeMap_t& RefLogicalShapes(); Temporary export for setting selected-state of physical shapes. { return fLogicalShapes; }. TGLContextIdentity* GetGLCtxIdentity() const. GL-context holding display-list definitions. { return fGLCtxIdentity; }.  Author: Matevz Tadel, Feb 2007  Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *;  Last changed: root/gl:$Id: TGLScene.h 32334 2010-02-12 11:52:13Z matevz $  Last generated: 2010-12-08 16:56; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGLScene.html:14067,log,logical,14067,root/html528/TGLScene.html,https://root.cern,https://root.cern/root/html528/TGLScene.html,1,['log'],['logical']
Testability,"lor_t cidx = -1, UChar_t transp = 0); Reposition/recolor physical shape. void UpdatePhysioLogical(TObject* logid, Double_t* trans, UChar_t* col); Reposition/recolor physical for given logical (assume TGLObject and; a single physical). void UpdatePhysioLogical(TObject* logid, Double_t* trans, Color_t cidx, UChar_t transp); Reposition/recolor physical for given logical (assume TGLObject and; a single physical). UInt_t BeginSmartRefresh(); Moves logicals that support smart-refresh to intermediate cache.; Destroys the others and returns the number of destroyed ones. void EndSmartRefresh(); Wipes logicals in refresh-cache. TGLLogicalShape * FindLogicalSmartRefresh(TObject* ID) const; Find and return logical shape identified by unqiue 'ID' in refresh-cache.; Returns 0 if not found. UInt_t SizeOfScene() const; Return memory cost of scene.; Warning: NOT CORRECT at present - doesn't correctly calculate size.; of logical shapes with dynamic internal contents. void DumpMapSizes() const; Print sizes of logical nad physical-shape maps. void RGBAFromColorIdx(Float_t* rgba, Color_t ci, Char_t transp = 0); Fill rgba color from ROOT color-index ci and transparency (0->100). Bool_t IsOutside(const TGLBoundingBox& box, const TGLPlaneSet_t& planes); Check if box is outside of all planes. TGLScene(const TGLScene& ). TGLScene& operator=(const TGLScene& ). TSceneInfo* CreateSceneInfo(TGLViewerBase* view). LogicalShapeMap_t& RefLogicalShapes(); Temporary export for setting selected-state of physical shapes. { return fLogicalShapes; }. TGLContextIdentity* GetGLCtxIdentity() const. GL-context holding display-list definitions. { return fGLCtxIdentity; }.  Author: Matevz Tadel, Feb 2007  Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *;  Last changed: root/gl:$Id: TGLScene.h 32334 2010-02-12 11:52:13Z matevz $  Last generated: 2011-07-04 15:29; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TGLScene.html:14067,log,logical,14067,root/html530/TGLScene.html,https://root.cern,https://root.cern/root/html530/TGLScene.html,1,['log'],['logical']
Testability,"lor_t cidx = -1, UChar_t transp = 0); Reposition/recolor physical shape. void UpdatePhysioLogical(TObject* logid, Double_t* trans, UChar_t* col); Reposition/recolor physical for given logical (assume TGLObject and; a single physical). void UpdatePhysioLogical(TObject* logid, Double_t* trans, Color_t cidx, UChar_t transp); Reposition/recolor physical for given logical (assume TGLObject and; a single physical). UInt_t BeginSmartRefresh(); Moves logicals that support smart-refresh to intermediate cache.; Destroys the others and returns the number of destroyed ones. void EndSmartRefresh(); Wipes logicals in refresh-cache. TGLLogicalShape * FindLogicalSmartRefresh(TObject* ID) const; Find and return logical shape identified by unqiue 'ID' in refresh-cache.; Returns 0 if not found. UInt_t SizeOfScene() const; Return memory cost of scene.; Warning: NOT CORRECT at present - doesn't correctly calculate size.; of logical shapes with dynamic internal contents. void DumpMapSizes() const; Print sizes of logical nad physical-shape maps. void RGBAFromColorIdx(Float_t* rgba, Color_t ci, Char_t transp = 0); Fill rgba color from ROOT color-index ci and transparency (0->100). Bool_t IsOutside(const TGLBoundingBox& box, const TGLPlaneSet_t& planes); Check if box is outside of all planes. TGLScene(const TGLScene& ). TGLScene& operator=(const TGLScene& ). TSceneInfo* CreateSceneInfo(TGLViewerBase* view). LogicalShapeMap_t& RefLogicalShapes(); Temporary export for setting selected-state of physical shapes. { return fLogicalShapes; }. TGLContextIdentity* GetGLCtxIdentity() const. GL-context holding display-list definitions. { return fGLCtxIdentity; }.  Author: Matevz Tadel, Feb 2007  Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *;  Last changed: root/gl:$Id: TGLScene.h 32334 2010-02-12 11:52:13Z matevz $  Last generated: 2011-11-03 20:14; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGLScene.html:14067,log,logical,14067,root/html532/TGLScene.html,https://root.cern,https://root.cern/root/html532/TGLScene.html,1,['log'],['logical']
Testability,"lor_t color=0); ; voidSetLegendFillStyle (Style_t style=1001); ; voidSetLegendFont (Style_t font=62); ; voidSetLegendTextSize (Double_t size=0.); ; voidSetLegoInnerR (Float_t rad=0.5); ; voidSetLineScalePS (Float_t scale=3); ; voidSetLineStyleString (Int_t i, const char *text); Set line style string using the PostScript convention. ; ; voidSetNdivisions (Int_t n=510, Option_t *axis=""X""); Set the number of divisions to draw an axis. ; ; voidSetNumberContours (Int_t number=20); Set the default number of contour levels when drawing 2-d plots. ; ; voidSetOptDate (Int_t datefl=1); If optdate is non null, the current date/time will be printed in the canvas. ; ; voidSetOptFile (Int_t file=1); ; voidSetOptFit (Int_t fit=1); The type of information about fit parameters printed in the histogram statistics box can be selected via the parameter mode. ; ; voidSetOptLogx (Int_t logx=1); ; voidSetOptLogy (Int_t logy=1); ; voidSetOptLogz (Int_t logz=1); ; voidSetOptStat (Int_t stat=1); The type of information printed in the histogram statistics box can be selected via the parameter mode. ; ; voidSetOptStat (Option_t *stat); The parameter mode can be any combination of kKsSiourRmMen. ; ; voidSetOptTitle (Int_t tit=1); ; voidSetOrthoCamera (Bool_t on=kTRUE); ; voidSetPadBorderMode (Int_t mode=1); ; voidSetPadBorderSize (Width_t size=1); ; voidSetPadBottomMargin (Float_t margin=0.1); ; voidSetPadColor (Color_t color=19); ; voidSetPadGridX (Bool_t gridx); ; voidSetPadGridY (Bool_t gridy); ; voidSetPadLeftMargin (Float_t margin=0.1); ; voidSetPadRightMargin (Float_t margin=0.1); ; voidSetPadTickX (Int_t tickx); ; voidSetPadTickY (Int_t ticky); ; voidSetPadTopMargin (Float_t margin=0.1); ; voidSetPaintTextFormat (const char *format=""g""); ; voidSetPalette (Int_t ncolors=kBird, Int_t *colors=nullptr, Float_t alpha=1.); See TColor::SetPalette. ; ; voidSetPalette (TString fileName, Float_t alpha=1.); ; voidSetPaperSize ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTStyle.html:16054,log,logx,16054,doc/master/classTStyle.html,https://root.cern,https://root.cern/doc/master/classTStyle.html,3,['log'],"['logx', 'logy', 'logz']"
Testability,"lotting options provided by TGLHistPainter start with GL keyword. General information: plot types and supported options; The following types of plots are provided:; Lego - (TGLLegoPainter); The supported options are:. ""GLLEGO"" : Draw a lego plot.; ""GLLEGO2"" : Bins with color levels.; ""GLLEGO3"" : Cylindrical bars. Lego painter in cartesian supports logarithmic scales for X, Y, Z. In polar only Z axis can be logarithmic, in cylindrical only Y (if you see what it means).; Surfaces (TF2 and TH2 with ""GLSURF"" options) - (TGLSurfacePainter); The supported options are:. ""GLSURF"" : Draw a surface.; ""GLSURF1"" : Surface with color levels; ""GLSURF2"" : The same as ""GLSURF1"" but without polygon outlines.; ""GLSURF3"" : Color level projection on top of plot (works only in cartesian coordinate system).; ""GLSURF4"" : Same as ""GLSURF"" but without polygon outlines. The surface painting in cartesian coordinates supports logarithmic scales along X, Y, Z axis. In polar coordinates only the Z axis can be logarithmic, in cylindrical coordinates only the Y axis.; Additional options to SURF and LEGO - Coordinate systems:; The supported options are:. "" "" : Default, cartesian coordinates system.; ""POL"" : Polar coordinates system.; ""CYL"" : Cylindrical coordinates system.; ""SPH"" : Spherical coordinates system. TH3 as boxes (spheres) - (TGLBoxPainter); The supported options are:. ""GLBOX"" : TH3 as a set of boxes, size of box is proportional to bin content.; ""GLBOX1"": the same as ""glbox"", but spheres are drawn instead of boxes. TH3 as iso-surface(s) - (TGLIsoPainter); The supported option is:. ""GLISO"" : TH3 is drawn using iso-surfaces. TH3 as color boxes - (TGLVoxelPainter); The supported option is:. ""GLCOL"" : TH3 is drawn using semi-transparent colored boxes. See $ROOTSYS/tutorials/gl/glvox1.C. TF3 (implicit function) - (TGLTF3Painter); The supported option is:. ""GLTF3"" : Draw a TF3. Parametric surfaces - (TGLParametricPlot); $ROOTSYS/tutorials/gl/glparametric.C shows how to create parametric equatio",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGLHistPainter.html:1543,log,logarithmic,1543,doc/master/classTGLHistPainter.html,https://root.cern,https://root.cern/doc/master/classTGLHistPainter.html,1,['log'],['logarithmic']
Testability,"low);; 260 }; 261 ; 262 // interpolate 6th degree; 263 double t = x / boundary;; 264 double eps_plus = high - nominal;; 265 double eps_minus = nominal - low;; 266 double S = 0.5 * (eps_plus + eps_minus);; 267 double A = 0.0625 * (eps_plus - eps_minus);; 268 ; 269 return x * (S + t * A * (15 + t * t * (-10 + t * t * 3)));; 270 } else if (code == 5) {; 271 double x = paramVal;; 272 double mod = 1.0;; 273 if (x >= boundary) {; 274 mod = std::pow(high / nominal, +paramVal);; 275 } else if (x <= -boundary) {; 276 mod = std::pow(low / nominal, -paramVal);; 277 } else {; 278 // interpolate 6th degree exp; 279 double x0 = boundary;; 280 ; 281 high /= nominal;; 282 low /= nominal;; 283 ; 284 // GHL: Swagato's suggestions; 285 double powUp = std::pow(high, x0);; 286 double powDown = std::pow(low, x0);; 287 double logHi = std::log(high);; 288 double logLo = std::log(low);; 289 double powUpLog = high <= 0.0 ? 0.0 : powUp * logHi;; 290 double powDownLog = low <= 0.0 ? 0.0 : -powDown * logLo;; 291 double powUpLog2 = high <= 0.0 ? 0.0 : powUpLog * logHi;; 292 double powDownLog2 = low <= 0.0 ? 0.0 : -powDownLog * logLo;; 293 ; 294 double S0 = 0.5 * (powUp + powDown);; 295 double A0 = 0.5 * (powUp - powDown);; 296 double S1 = 0.5 * (powUpLog + powDownLog);; 297 double A1 = 0.5 * (powUpLog - powDownLog);; 298 double S2 = 0.5 * (powUpLog2 + powDownLog2);; 299 double A2 = 0.5 * (powUpLog2 - powDownLog2);; 300 ; 301 // fcns+der+2nd_der are eq at bd; 302 ; 303 double a = 1. / (8 * x0) * (15 * A0 - 7 * x0 * S1 + x0 * x0 * A2);; 304 double b = 1. / (8 * x0 * x0) * (-24 + 24 * S0 - 9 * x0 * A1 + x0 * x0 * S2);; 305 double c = 1. / (4 * std::pow(x0, 3)) * (-5 * A0 + 5 * x0 * S1 - x0 * x0 * A2);; 306 double d = 1. / (4 * std::pow(x0, 4)) * (12 - 12 * S0 + 7 * x0 * A1 - x0 * x0 * S2);; 307 double e = 1. / (8 * std::pow(x0, 5)) * (+3 * A0 - 3 * x0 * S1 + x0 * x0 * A2);; 308 double f = 1. / (8 * std::pow(x0, 6)) * (-8 + 8 * S0 - 5 * x0 * A1 + x0 * x0 * S2);; 309 ; 310 // evaluate the 6-th degree",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/MathFuncs_8h_source.html:8826,log,logLo,8826,doc/master/MathFuncs_8h_source.html,https://root.cern,https://root.cern/doc/master/MathFuncs_8h_source.html,1,['log'],['logLo']
Testability,"low, double & errhigh) const; 481 {; 482 assert( ipoint < fMaxPoints );; 483 assert( fErrorType == kAsymError );; 484 assert( !fDataErrorPtr && fDataErrorHighPtr && fDataErrorLowPtr );; 485 assert( fDataError.empty() );; 486 assert( fDataErrorHigh.empty() || &fDataErrorHigh.front() == fDataErrorHighPtr );; 487 assert( fDataErrorLow.empty() || &fDataErrorLow.front() == fDataErrorLowPtr );; 488 assert( fDataErrorLow.empty() == fDataErrorHigh.empty() );; 489 ; 490 errhigh = fDataErrorHighPtr[ ipoint ];; 491 errlow = fDataErrorLowPtr[ ipoint ];; 492 ; 493 return CoordErrors( ipoint );; 494 }; 495 ; 496 /**; 497 returns a single coordinate error component of a point.; 498 This function is threadsafe in contrast to Coords(...); 499 and can easily get vectorized by the compiler in loops; 500 running over the ipoint-index.; 501 */; 502 double GetBinUpEdgeComponent( unsigned int ipoint, unsigned int icoord ) const; 503 {; 504 assert( icoord < fDim );; 505 assert( !fBinEdge.empty() );; 506 assert( ipoint < fBinEdge.front().size() );; 507 ; 508 return fBinEdge[icoord][ipoint];; 509 }; 510 ; 511 /**; 512 return an array containing the upper edge of the bin for coordinate i; 513 In case of empty bin they could be merged in a single larger bin; 514 Return a NULL pointer if the bin width is not stored; 515 */; 516 // not threadsafe, to be replaced with never constructs!; 517 // for example: just return std::array or std::vector, there's; 518 // is going to be only minor overhead in c++11.; 519 const double* BinUpEdge( unsigned int ipoint ) const; 520 {; 521 if ( fBinEdge.empty() || ipoint > fBinEdge.front().size() ); 522 return nullptr;; 523 ; 524 GetBinUpEdgeCoordinates(ipoint, fpTmpBinEdgeVector);; 525 ; 526 return fpTmpBinEdgeVector;; 527 }; 528 ; 529 /**; 530 * Thread save version of function retrieving the bin up-edge in case of multidimensions; 531 */; 532 void GetBinUpEdgeCoordinates(unsigned int ipoint, double * x) const; 533 {; 534 if (fBinEdge.empty() || ipoint > fBinEdg",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/BinData_8h_source.html:18050,assert,assert,18050,doc/master/BinData_8h_source.html,https://root.cern,https://root.cern/doc/master/BinData_8h_source.html,1,['assert'],['assert']
Testability,"lower plot, specified by a vector of floats ; ratioplot4.py Example that shows custom dashed lines on the lower plot, specified by a vector of floats ; ratioplot5.C Example that shows how you can set the colors of the confidence interval bands by using the method TRatioPlot::SetConfidenceIntervalColors ; ratioplot5.py Example that shows how you can set the colors of the confidence interval bands by using the method TRatioPlot::SetConfidenceIntervalColors ; ratioplot6.C Example showing a fit residual plot, where the separation margin has been set to 0 ; ratioplot6.py Example showing a fit residual plot, where the separation margin has been set to 0 ; ratioplotOld.CExample displaying two histograms and their ratio ; rebin.C Rebin a variable bin-width histogram ; reverseaxis.C Example showing an histogram with reverse axis ; sparsehist.CEvaluate the performance of THnSparse vs TH1/2/3/nF for different numbers of dimensions and bins per dimension ; statsEditing.C Edit statistics box ; testSmooth.C Histogram smoothing ; th2polyBoxes.C This tutorial illustrates how to create an histogram with polygonal bins (TH2Poly) ; th2polyEurope.C This tutorial illustrates how to create an histogram with polygonal bins (TH2Poly), fill it and draw it ; th2polyHoneycomb.C This tutorial illustrates how to create an histogram with hexagonal bins (TH2Poly) ; th2polyUSA.C This tutorial illustrates how to create an histogram with polygonal bins (TH2Poly), fill it and draw it using the col option ; thstack2palettecolor.C Palette coloring for 2D histograms' stack is activated thanks to the option PFC (Palette Fill Color) ; thstackpalettecolor.C Palette coloring for histograms' stack is activated thanks to the options PFC (Palette Fill Color), PLC (Palette Line Color) and AMC (Palette Marker Color) ; tprofile2polyRealistic.C Different charges depending on region ; tprofile2polyRealisticModuleError.C Simulate faulty detector panel w.r.t ; transpad.C Example of a canvas showin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v612/files.html:124721,test,testSmooth,124721,doc/v612/files.html,https://root.cern,https://root.cern/doc/v612/files.html,3,['test'],['testSmooth']
Testability,"lowing table shows the first 50 default colors. Picture; Source. {; TCanvas *c = new TCanvas(""c"",""Line colors"",0,0,500,200);; c.DrawColorTable();; return c;; }. Color transparency; SetLineColorAlpha(), allows to set a transparent color.; In the following example the line color of the histogram histo; is set to blue with a transparency of 35%. The color kBlue; itself remains fully opaque. . histo->SetLineColorAlpha(kBlue, 0.35);. ; The transparency is available on all platforms when the flagOpenGL.CanvasPreferGL is set to 1; in $ROOTSYS/etc/system.rootrc, or on Mac with the Cocoa backend. On the file output; it is visible with PDF, PNG, Gif, JPEG, SVG ... but not PostScript.; Line Width; The line width is expressed in pixel units.; The line width of any class inheriting from TAttLine can; be changed using the method SetLineWidth and retrieved using the; method GetLineWidth.; The following picture shows the line widths from 1 to 10 pixels. Picture; Source. {; TCanvas *Lw = new TCanvas(""Lw"",""test"",500,200);; TText t;; t.SetTextAlign(32);; t.SetTextSize(0.08);; Int_t i=1;; for (float s=0.1; s<1.0 ; s+=0.092) {; TLine *lh = new TLine(0.15,s,.85,s);; lh->SetLineWidth(i);; t.DrawText(0.1,s,Form(""%d"",i++));; lh->Draw();; }; return Lw;; }. Line Style; Line styles are identified via integer numbers. The line style of any class; inheriting from TAttLine can be changed using the method; SetLineStyle and retrieved using the method GetLineStyle. The first 10 line styles are predefined as shown on the following picture:. Picture; Source. {; TCanvas *Ls = new TCanvas(""Ls"",""test"",500,200);; TText t;; t.SetTextAlign(32);; t.SetTextSize(0.08);; Int_t i=1;; for (float s=0.1; s<1.0 ; s+=0.092) {; TLine *lh = new TLine(0.15,s,.85,s);; lh->SetLineStyle(i);; t.DrawText(0.1,s,Form(""%d"",i++));; lh->Draw();; }; return Ls;; }. Additional line styles can be defined using TStyle::SetLineStyleString.; For example the line style number 11 can be defined as follow:. gStyle->SetLineStyleString(11,""40",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TAttLine.html:1755,test,test,1755,root/html534/TAttLine.html,https://root.cern,https://root.cern/root/html534/TAttLine.html,1,['test'],['test']
Testability,"lptr;; 3663 ; 3664 if (fTopVolume); 3665 fTopVolume->SetTitle("""");; 3666 fTopVolume = vol;; 3667 vol->SetTitle(""Top volume"");; 3668 if (fTopNode) {; 3669 TGeoNode *topn = fTopNode;; 3670 fTopNode = nullptr;; 3671 while ((browser = (TBrowser *)next())); 3672 browser->RecursiveRemove(topn);; 3673 delete topn;; 3674 } else {; 3675 fMasterVolume = vol;; 3676 fMasterVolume->Grab();; 3677 fUniqueVolumes->AddAtAndExpand(vol, 0);; 3678 if (fgVerboseLevel > 0); 3679 Info(""SetTopVolume"", ""Top volume is %s. Master volume is %s"", fTopVolume->GetName(), fMasterVolume->GetName());; 3680 }; 3681 // fMasterVolume->FindMatrixOfDaughterVolume(vol);; 3682 // fCurrentMatrix->Print();; 3683 fTopNode = new TGeoNodeMatrix(vol, gGeoIdentity);; 3684 fTopNode->SetName(TString::Format(""%s_1"", vol->GetName()));; 3685 fTopNode->SetNumber(1);; 3686 fTopNode->SetTitle(""Top logical node"");; 3687 fNodes->AddAt(fTopNode, 0);; 3688 if (!GetCurrentNavigator()) {; 3689 fCurrentNavigator = AddNavigator();; 3690 return;; 3691 }; 3692 Int_t nnavigators = 0;; 3693 TGeoNavigatorArray *arr = GetListOfNavigators();; 3694 if (!arr); 3695 return;; 3696 nnavigators = arr->GetEntriesFast();; 3697 for (Int_t i = 0; i < nnavigators; i++) {; 3698 TGeoNavigator *nav = (TGeoNavigator *)arr->At(i);; 3699 nav->ResetAll();; 3700 if (fClosed); 3701 nav->GetCache()->BuildInfoBranch();; 3702 }; 3703}; 3704 ; 3705////////////////////////////////////////////////////////////////////////////////; 3706/// Define different tracking media.; 3707 ; 3708void TGeoManager::SelectTrackingMedia(); 3709{; 3710 /*; 3711 Int_t nmat = fMaterials->GetSize();; 3712 if (!nmat) {printf("" No materials !\n""); return;}; 3713 Int_t *media = new Int_t[nmat];; 3714 memset(media, 0, nmat*sizeof(Int_t));; 3715 Int_t imedia = 1;; 3716 TGeoMaterial *mat, *matref;; 3717 mat = (TGeoMaterial*)fMaterials->At(0);; 3718 if (mat->GetMedia()) {; 3719 for (Int_t i=0; i<nmat; i++) {; 3720 mat = (TGeoMaterial*)fMaterials->At(i);; 3721 mat->Print();; 3722 }; 3723 re",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGeoManager_8cxx_source.html:134733,log,logical,134733,doc/master/TGeoManager_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGeoManager_8cxx_source.html,1,['log'],['logical']
Testability,"ls = min->NCalls();; 111 fStatus = min->Status();; 112 fCovStatus= min->CovMatrixStatus();; 113 fVal = min->MinValue();; 114 fEdm = min->Edm();; 115 ; 116 fMinimizer= min;; 117 fFitFunc = func;; 118 ; 119 fMinimType = fconfig.MinimizerName();; 120 ; 121 // replace ncalls if minimizer does not support it (they are taken then from the FitMethodFunction); 122 if (fNCalls == 0) fNCalls = ncalls;; 123 ; 124 const unsigned int npar = min->NDim();; 125 if (npar == 0) return;; 126 ; 127 if (min->X() ); 128 fParams = std::vector<double>(min->X(), min->X() + npar);; 129 else {; 130 // case minimizer does not provide minimum values (it failed) take from configuration; 131 fParams.resize(npar);; 132 for (unsigned int i = 0; i < npar; ++i ) {; 133 fParams[i] = ( fconfig.ParSettings(i).Value() );; 134 }; 135 }; 136 ; 137 if (sizeOfData > min->NFree() ) fNdf = sizeOfData - min->NFree();; 138 ; 139 ; 140 // set right parameters in function (in case minimizer did not do before); 141 // do also when fit is not valid; 142 if (func ) {; 143 // I think we can avoid cloning the model function; 144 //fFitFunc = dynamic_cast<IModelFunction *>( func->Clone() );; 145 //assert(fFitFunc);; 146 fFitFunc->SetParameters(&fParams.front());; 147 }; 148 else {; 149 // when no fFitFunc is present take parameters from FitConfig; 150 fParNames.resize( npar );; 151 for (unsigned int i = 0; i < npar; ++i ) {; 152 fParNames[i] = fconfig.ParSettings(i).Name();; 153 }; 154 }; 155 ; 156 ; 157 // check for fixed or limited parameters; 158 unsigned int nfree = 0;; 159 if (!fParamBounds.empty()) fParamBounds.clear();; 160 for (unsigned int ipar = 0; ipar < npar; ++ipar) {; 161 const ParameterSettings & par = fconfig.ParSettings(ipar);; 162 if (par.IsFixed() ) fFixedParams[ipar] = true;; 163 else nfree++;; 164 if (par.IsBound() ) {; 165 double lower = (par.HasLowerLimit()) ? par.LowerLimit() : - std::numeric_limits<double>::infinity() ;; 166 double upper = (par.HasUpperLimit()) ? par.UpperLimit() : std::numeric_l",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/FitResult_8cxx_source.html:4882,assert,assert,4882,doc/master/FitResult_8cxx_source.html,https://root.cern,https://root.cern/doc/master/FitResult_8cxx_source.html,1,['assert'],['assert']
Testability,"ls of Mathematical Statistics, Distribution of the Anderson-Darling Statistic, Volume 32, Number 4, 1118-1124.; */ void AndersonDarlingTest(Double_t& pvalue, Double_t& testStat) const;. Double_t KolmogorovSmirnov2SamplesTest(const Char_t* option = ""p"") const. The Kolmogorov-Smirnov 2-Samples Test algorithm is described at; http://www.itl.nist.gov/div898/software/dataplot/refman1/auxillar/ks2samp.htm; and described and taken from; http://root.cern.ch/root/html/TMath.html#TMath:KolmogorovTest; */ void KolmogorovSmirnov2SamplesTest(Double_t& pvalue, Double_t& testStat) const;. Double_t KolmogorovSmirnovTest(const Char_t* option = ""p"") const. The Kolmogorov-Smirnov 1-Sample Test algorithm for a specific distribution is described at; http://www.itl.nist.gov/div898/software/dataplot/refman1/auxillar/kstest.htm; and described and taken from (4); Press W. H., Teukolsky S.A., Vetterling W.T., Flannery B.P. (2007), Numerical Recipes - The Art of Scientific Computing (Third Edition), Cambridge Univerdity Press; */ void KolmogorovSmirnovTest(Double_t& pvalue, Double_t& testStat) const;. void operator()(ROOT::Math::GoFTest::ETestType test, Double_t& pvalue, Double_t& testStat) const; The class's unary functions. Double_t operator()(ROOT::Math::GoFTest::ETestType test = kAD, const Char_t* option = ""p"") const. GoFTest(). GoFTest operator=(ROOT::Math::GoFTest& gof). void SetCDF(). Double_t LogNormalCDF(Double_t x) const. Double_t GaussianCDF(Double_t x) const. Double_t ExponentialCDF(Double_t x) const. Double_t GetSigmaN(UInt_t N) const. Double_t InterpolatePValues(Double_t dA2, Int_t bin) const. Double_t PValueAD2Samples(Double_t& A2, UInt_t N) const. Double_t PValueAD1Sample(Double_t A2) const. void LogSample(). void SetSamples(vector<const Double_t*> samples, const vector<UInt_t> samplesSizes). void SetParameters().  Last changed: root/mathcore:$Id: GoFTest.h 36911 2010-11-24 17:08:43Z moneta $  Last generated: 2010-11-25 07:08; This page has been automatically generated. For c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/ROOT__Math__GoFTest.html:6968,test,testStat,6968,root/html528/ROOT__Math__GoFTest.html,https://root.cern,https://root.cern/root/html528/ROOT__Math__GoFTest.html,1,['test'],['testStat']
Testability,"ls of Mathematical Statistics, Distribution of the Anderson-Darling Statistic, Volume 32, Number 4, 1118-1124.; */ void AndersonDarlingTest(Double_t& pvalue, Double_t& testStat) const;. Double_t KolmogorovSmirnov2SamplesTest(const Char_t* option = ""p"") const. The Kolmogorov-Smirnov 2-Samples Test algorithm is described at; http://www.itl.nist.gov/div898/software/dataplot/refman1/auxillar/ks2samp.htm; and described and taken from; http://root.cern.ch/root/html/TMath.html#TMath:KolmogorovTest; */ void KolmogorovSmirnov2SamplesTest(Double_t& pvalue, Double_t& testStat) const;. Double_t KolmogorovSmirnovTest(const Char_t* option = ""p"") const. The Kolmogorov-Smirnov 1-Sample Test algorithm for a specific distribution is described at; http://www.itl.nist.gov/div898/software/dataplot/refman1/auxillar/kstest.htm; and described and taken from (4); Press W. H., Teukolsky S.A., Vetterling W.T., Flannery B.P. (2007), Numerical Recipes - The Art of Scientific Computing (Third Edition), Cambridge Univerdity Press; */ void KolmogorovSmirnovTest(Double_t& pvalue, Double_t& testStat) const;. void operator()(ROOT::Math::GoFTest::ETestType test, Double_t& pvalue, Double_t& testStat) const; The class's unary functions. Double_t operator()(ROOT::Math::GoFTest::ETestType test = kAD, const Char_t* option = ""p"") const. GoFTest(). GoFTest operator=(ROOT::Math::GoFTest& gof). void SetCDF(). Double_t LogNormalCDF(Double_t x) const. Double_t GaussianCDF(Double_t x) const. Double_t ExponentialCDF(Double_t x) const. Double_t GetSigmaN(UInt_t N) const. Double_t InterpolatePValues(Double_t dA2, Int_t bin) const. Double_t PValueAD2Samples(Double_t& A2, UInt_t N) const. Double_t PValueAD1Sample(Double_t A2) const. void LogSample(). void SetSamples(vector<const Double_t*> samples, const vector<UInt_t> samplesSizes). void SetParameters().  Last changed: root/mathcore:$Id: GoFTest.h 36911 2010-11-24 17:08:43Z moneta $  Last generated: 2011-07-04 15:19; This page has been automatically generated. For c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/ROOT__Math__GoFTest.html:6970,test,testStat,6970,root/html530/ROOT__Math__GoFTest.html,https://root.cern,https://root.cern/root/html530/ROOT__Math__GoFTest.html,1,['test'],['testStat']
Testability,"ls of Mathematical Statistics, Distribution of the Anderson-Darling Statistic, Volume 32, Number 4, 1118-1124.; */ void AndersonDarlingTest(Double_t& pvalue, Double_t& testStat) const;. Double_t KolmogorovSmirnov2SamplesTest(const Char_t* option = ""p"") const. The Kolmogorov-Smirnov 2-Samples Test algorithm is described at; http://www.itl.nist.gov/div898/software/dataplot/refman1/auxillar/ks2samp.htm; and described and taken from; http://root.cern.ch/root/html/TMath.html#TMath:KolmogorovTest; */ void KolmogorovSmirnov2SamplesTest(Double_t& pvalue, Double_t& testStat) const;. Double_t KolmogorovSmirnovTest(const Char_t* option = ""p"") const. The Kolmogorov-Smirnov 1-Sample Test algorithm for a specific distribution is described at; http://www.itl.nist.gov/div898/software/dataplot/refman1/auxillar/kstest.htm; and described and taken from (4); Press W. H., Teukolsky S.A., Vetterling W.T., Flannery B.P. (2007), Numerical Recipes - The Art of Scientific Computing (Third Edition), Cambridge Univerdity Press; */ void KolmogorovSmirnovTest(Double_t& pvalue, Double_t& testStat) const;. void operator()(ROOT::Math::GoFTest::ETestType test, Double_t& pvalue, Double_t& testStat) const; The class's unary functions. Double_t operator()(ROOT::Math::GoFTest::ETestType test = kAD, const Char_t* option = ""p"") const. GoFTest(). GoFTest operator=(ROOT::Math::GoFTest& gof). void SetCDF(). Double_t LogNormalCDF(Double_t x) const. Double_t GaussianCDF(Double_t x) const. Double_t ExponentialCDF(Double_t x) const. Double_t GetSigmaN(UInt_t N) const. Double_t InterpolatePValues(Double_t dA2, Int_t bin) const. Double_t PValueAD2Samples(Double_t& A2, UInt_t N) const. Double_t PValueAD1Sample(Double_t A2) const. void LogSample(). void SetSamples(vector<const Double_t*> samples, const vector<UInt_t> samplesSizes). void SetParameters().  Last changed: root/mathcore:$Id: GoFTest.h 36911 2010-11-24 17:08:43Z moneta $  Last generated: 2011-11-03 20:04; This page has been automatically generated. For c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/ROOT__Math__GoFTest.html:6970,test,testStat,6970,root/html532/ROOT__Math__GoFTest.html,https://root.cern,https://root.cern/root/html532/ROOT__Math__GoFTest.html,1,['test'],['testStat']
Testability,"ls of Mathematical Statistics, Distribution of the Anderson-Darling Statistic, Volume 32, Number 4, 1118-1124.; */ void AndersonDarlingTest(Double_t& pvalue, Double_t& testStat) const;. Double_t KolmogorovSmirnov2SamplesTest(const Char_t* option = ""p"") const. The Kolmogorov-Smirnov 2-Samples Test algorithm is described at; http://www.itl.nist.gov/div898/software/dataplot/refman1/auxillar/ks2samp.htm; and described and taken from; http://root.cern.ch/root/html/TMath.html#TMath:KolmogorovTest; */ void KolmogorovSmirnov2SamplesTest(Double_t& pvalue, Double_t& testStat) const;. Double_t KolmogorovSmirnovTest(const Char_t* option = ""p"") const. The Kolmogorov-Smirnov 1-Sample Test algorithm for a specific distribution is described at; http://www.itl.nist.gov/div898/software/dataplot/refman1/auxillar/kstest.htm; and described and taken from (4); Press W. H., Teukolsky S.A., Vetterling W.T., Flannery B.P. (2007), Numerical Recipes - The Art of Scientific Computing (Third Edition), Cambridge Univerdity Press; */ void KolmogorovSmirnovTest(Double_t& pvalue, Double_t& testStat) const;. void operator()(ROOT::Math::GoFTest::ETestType test, Double_t& pvalue, Double_t& testStat) const; The class's unary functions. Double_t operator()(ROOT::Math::GoFTest::ETestType test = kAD, const Char_t* option = ""p"") const; Returns default Anderson Darling 1-Sample Test and default p-value; option ""t"" returns the test statistic value; specific to the test type. Double_t PValueADKSamples(UInt_t nsamples, Double_t A2); Computation of the K-Sample Anderson-Darling Test's p-value as described in (1); given a normalized test statistic. The first variant described in the paper is used. void AndersonDarling2SamplesTest(const ROOT::Fit::BinData& data1, const ROOT::Fit::BinData& data2, Double_t& pvalue, Double_t& testStat); Compute The 2-Sample Anderson Darling test for binned data. GoFTest(). GoFTest operator=(ROOT::Math::GoFTest& gof). void SetCDF(). Double_t LogNormalCDF(Double_t x) const. Double_t Ga",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/ROOT__Math__GoFTest.html:7151,test,testStat,7151,root/html534/ROOT__Math__GoFTest.html,https://root.cern,https://root.cern/root/html534/ROOT__Math__GoFTest.html,3,['test'],['testStat']
Testability,"ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooMoment*RooAbsReal::mean(RooRealVar& obs); RooMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); Int_tminDimNormValueCaching() const; virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tmustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TNamed&TNamed::operator=(const TNamed& rhs); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAbsPdf.html:23891,test,testArg,23891,root/html526/RooAbsPdf.html,https://root.cern,https://root.cern/root/html526/RooAbsPdf.html,1,['test'],['testArg']
Testability,"ls);; 1100 ; 1101 Int_t availableTraining = eventVectorTraining.size();; 1102 Int_t availableTesting = eventVectorTesting.size();; 1103 Int_t availableUndefined = eventVectorUndefined.size();; 1104 ; 1105 Float_t presel_scale;; 1106 if (fScaleWithPreselEff) {; 1107 presel_scale = eventCounts[cls].cutScaling();; 1108 if (presel_scale < 1); 1109 Log() << kINFO << Form(""Dataset[%s] : "",dsi.GetName()) << "" you have opted for scaling the number of requested training/testing events\n to be scaled by the preselection efficiency""<< Endl;; 1110 }else{; 1111 presel_scale = 1.; // this scaling was too confusing to most people, including me! Sorry... (Helge); 1112 if (eventCounts[cls].cutScaling() < 1); 1113 Log() << kINFO << Form(""Dataset[%s] : "",dsi.GetName()) << "" you have opted for interpreting the requested number of training/testing events\n to be the number of events AFTER your preselection cuts"" << Endl;; 1114 ; 1115 }; 1116 ; 1117 // If TrainTestSplit_<class> is set, set number of requested training events to split*num_all_events; 1118 // Requested number of testing events is set to zero and therefore takes all other events; 1119 // The option TrainTestSplit_<class> overrides nTrain_<class> or nTest_<class>; 1120 if(eventCounts[cls].TrainTestSplitRequested < 1.0 && eventCounts[cls].TrainTestSplitRequested > 0.0){; 1121 eventCounts[cls].nTrainingEventsRequested = Int_t(eventCounts[cls].TrainTestSplitRequested*(availableTraining+availableTesting+availableUndefined));; 1122 eventCounts[cls].nTestingEventsRequested = Int_t(0);; 1123 }; 1124 else if(eventCounts[cls].TrainTestSplitRequested != 0.0) Log() << kFATAL << Form(""The option TrainTestSplit_<class> has to be in range (0, 1] but is set to %f."",eventCounts[cls].TrainTestSplitRequested) << Endl;; 1125 Int_t requestedTraining = Int_t(eventCounts[cls].nTrainingEventsRequested * presel_scale);; 1126 Int_t requestedTesting = Int_t(eventCounts[cls].nTestingEventsRequested * presel_scale);; 1127 ; 1128 Log() << kDEBUG << Form",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/DataSetFactory_8cxx_source.html:48343,test,testing,48343,doc/master/DataSetFactory_8cxx_source.html,https://root.cern,https://root.cern/doc/master/DataSetFactory_8cxx_source.html,2,['test'],['testing']
Testability,"ls. ; ; static intverboseEval (); Return global level of verbosity for p.d.f. evaluations. ; ; static voidverboseEval (Int_t stat); Change global level of verbosity for p.d.f. evaluations. ; ; Static Public Member Functions inherited from RooAbsReal; static TClass *Class (); ; static const char *Class_Name (); ; static constexpr Version_tClass_Version (); ; static voidclearEvalErrorLog (); Clear the stack of evaluation error messages. ; ; static const char *DeclFileName (); ; static RooNumIntConfig *defaultIntegratorConfig (); Returns the default numeric integration configuration for all RooAbsReals. ; ; static std::map< constRooAbsArg *, std::pair< std::string, std::list< RooAbsReal::EvalError > > >::iteratorevalErrorIter (); ; static ErrorLoggingModeevalErrorLoggingMode (); Return current evaluation error logging mode. ; ; static boolhideOffset (); ; static voidlogEvalError (const RooAbsReal *originator, const char *origName, const char *message, const char *serverValueString=nullptr); Interface to insert remote error logging messages received by RooRealMPFE into current error logging stream. ; ; static Int_tnumEvalErrorItems (); ; static Int_tnumEvalErrors (); Return the number of logged evaluation errors since the last clearing. ; ; static voidprintEvalErrors (std::ostream &os=std::cout, Int_t maxPerNode=10000000); Print all outstanding logged evaluation error on the given ostream. ; ; static voidsetEvalErrorLoggingMode (ErrorLoggingMode m); Set evaluation error logging mode. ; ; static voidsetHideOffset (bool flag); ; Static Public Member Functions inherited from RooAbsArg; static voidsetDirtyInhibit (bool flag); Control global dirty inhibit mode. ; ; static voidverboseDirty (bool flag); Activate verbose messaging related to dirty flag propagation. ; ; Static Public Member Functions inherited from TNamed; static TClass *Class (); ; static const char *Class_Name (); ; static constexpr Version_tClass_Versi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooBMixDecay.html:61386,log,logEvalError,61386,doc/master/classRooBMixDecay.html,https://root.cern,https://root.cern/doc/master/classRooBMixDecay.html,222,['log'],"['logEvalError', 'logging']"
Testability,"lse {; 1785 // This will replace the existing TClass.; 1786 TClass *ncl = (*dict)();; 1787 if (ncl); 1788 ncl->PostLoadCheck();; 1789 }; 1790 }; 1791 }; 1792 }; 1793 ; 1794 protoClasses->Clear(); // Ownership was transfered to TClassTable.; 1795 delete protoClasses;; 1796 }; 1797 ; 1798 TObjArray *dataTypes;; 1799 pcmFile.GetObject(""__Typedefs"", dataTypes);; 1800 if (dataTypes) {; 1801 for (auto typedf : *dataTypes); 1802 gROOT->GetListOfTypes()->Add(typedf);; 1803 dataTypes->Clear(); // Ownership was transfered to TListOfTypes.; 1804 delete dataTypes;; 1805 }; 1806}; 1807 ; 1808////////////////////////////////////////////////////////////////////////////////; 1809/// Tries to load a rdict PCM, issues diagnostics if it fails.; 1810 ; 1811void TCling::LoadPCM(std::string pcmFileNameFullPath); 1812{; 1813 SuspendAutoLoadingRAII autoloadOff(this);; 1814 SuspendAutoParsing autoparseOff(this);; 1815 assert(!pcmFileNameFullPath.empty());; 1816 assert(llvm::sys::path::is_absolute(pcmFileNameFullPath));; 1817 ; 1818 // Easier to work with the ROOT interfaces.; 1819 TString pcmFileName = pcmFileNameFullPath;; 1820 ; 1821 // Prevent the ROOT-PCMs hitting this during auto-load during; 1822 // JITting - which will cause recursive compilation.; 1823 // Avoid to call the plugin manager at all.; 1824 R__InitStreamerInfoFactory();; 1825 ; 1826 TDirectory::TContext ctxt;; 1827 llvm::SaveAndRestore<Int_t> SaveGDebug(gDebug);; 1828 if (gDebug > 5) {; 1829 gDebug -= 5;; 1830 ::Info(""TCling::LoadPCM"", ""Loading ROOT PCM %s"", pcmFileName.Data());; 1831 } else {; 1832 gDebug = 0;; 1833 }; 1834 ; 1835 if (llvm::sys::fs::is_symlink_file(pcmFileNameFullPath)); 1836 pcmFileNameFullPath = ROOT::TMetaUtils::GetRealPath(pcmFileNameFullPath);; 1837 ; 1838 auto pendingRdict = fPendingRdicts.find(pcmFileNameFullPath);; 1839 if (pendingRdict != fPendingRdicts.end()) {; 1840 llvm::StringRef pcmContent = pendingRdict->second;; 1841 TMemFile::ZeroCopyView_t range{pcmContent.data(), pcmContent.size()};; 18",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCling_8cxx_source.html:68264,assert,assert,68264,doc/master/TCling_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html,1,['assert'],['assert']
Testability,"lse; 393 assert(false);; 394 }; 395 ; 396 if ( kNoError == fErrorType ); 397 {; 398 fErrorType = kValueError;; 399 }; 400 ; 401 return *this;; 402 }; 403 ; 404 ; 405 /**; 406 add one dim data with only coordinate and values; 407 */; 408 void BinData::Add( double x, double y ); 409 {; 410 assert( kNoError == fErrorType );; 411 ; 412 assert( !fData.empty() && fDataPtr );; 413 assert( fDataErrorHigh.empty() && !fDataErrorHighPtr );; 414 assert( fDataErrorLow.empty() && !fDataErrorLowPtr );; 415 assert( fDataError.empty() && !fDataErrorPtr );; 416 assert( fCoordErrors.empty() && fCoordErrorsPtr.empty() );; 417 ; 418 fData[ fNPoints ] = y;; 419 ; 420 FitData::Add( x );; 421 fSumContent += y;; 422 }; 423 ; 424 /**; 425 add one dim data with no error in the coordinate (x); 426 in this case store the inverse of the error in the value (y); 427 */; 428 void BinData::Add( double x, double y, double ey ); 429 {; 430 assert( kValueError == fErrorType );; 431 assert( !fData.empty() && fDataPtr );; 432 assert( fDataErrorHigh.empty() && !fDataErrorHighPtr );; 433 assert( fDataErrorLow.empty() && !fDataErrorLowPtr );; 434 assert( !fDataError.empty() && fDataErrorPtr );; 435 assert( fCoordErrors.empty() && fCoordErrorsPtr.empty() );; 436 ; 437 fData[ fNPoints ] = y;; 438 fDataError[ fNPoints ] = (ey != 0.0) ? 1.0/ey : 0.0;; 439 ; 440 FitData::Add( x );; 441 fSumContent += y;; 442 if (y != 0 || ey != 1.0) fSumError2 += ey*ey;; 443 // set the weight flag checking if error^2 != y; 444 if (!fIsWeighted); 445 if (y != 0 && std::abs( ey*ey/y - 1.0) > 1.E-12) fIsWeighted = true;; 446 }; 447 ; 448 /**; 449 add one dim data with error in the coordinate (x); 450 in this case store the value (y) error and not the inverse; 451 */; 452 void BinData::Add( double x, double y, double ex, double ey ); 453 {; 454 assert( kCoordError == fErrorType );; 455 assert( !fData.empty() && fDataPtr );; 456 assert( !fDataError.empty() && fDataErrorPtr );; 457 assert( fDataErrorHigh.empty() && !fDataErrorHighPtr )",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/BinData_8cxx_source.html:12525,assert,assert,12525,doc/master/BinData_8cxx_source.html,https://root.cern,https://root.cern/doc/master/BinData_8cxx_source.html,1,['assert'],['assert']
Testability,"lt*Get() const; virtual TClass*IsA() const; intoperator int() const; TFitResult&operator*() const; TFitResult*operator->() const; TFitResultPtr&operator=(const TFitResultPtr& rhs); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); TFitResultPtr(int status = -1); TFitResultPtr(const shared_ptr<TFitResult>& p); TFitResultPtr(TFitResult* p); TFitResultPtr(const TFitResultPtr& rhs). Data Members; private:. shared_ptr<TFitResult>fPointer! Smart Pointer to TFitResult class; intfStatusfit status code. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFitResultPtr(const std::shared_ptr<TFitResult> & p); constructor from a TFitResult pointer. TFitResultPtr(TFitResult* p); constructor from a TFitResult pointer. TFitResultPtr(const TFitResultPtr& rhs). ~TFitResultPtr(); destructor - delete the contained TFitResult pointer if needed; if ( fPointer != 0); delete fPointer;. TFitResult& operator*() const; implement the de-reference operator to make the class acts as a pointer to a TFitResult; assert in case the class does not contain a pointer to TFitResult. TFitResult* operator->() const; implement the -> operator to make the class acts as a pointer to a TFitResult; assert in case the class does not contain a pointer to TFitResult. TFitResult * Get() const; return contained pointer. TFitResultPtr & operator=(const TFitResultPtr& rhs); assignment operator; if needed copy the TFitResult object and delete previous one if existing. TFitResultPtr(int status = -1); {}. operator int() const; { return fStatus; }.  Author: David Gonzalez Maline Tue Nov 10 15:01:24 2009  Copyright (C) 1995-2009, Rene Brun and Fons Rademakers. *;  Last changed: root/mathcore:$Id$  Last generated: 2015-06-02 15:48; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TFitResultPtr.html:1509,assert,assert,1509,root/html604/TFitResultPtr.html,https://root.cern,https://root.cern/root/html604/TFitResultPtr.html,2,['assert'],['assert']
Testability,lt.h; TOracleRow.h; TOracleServer.h; TOracleStatement.h; src; TOracleResult.cxx; TOracleRow.cxx; TOracleServer.cxx; TOracleStatement.cxx; pgsql; inc; TPgSQLResult.h; TPgSQLRow.h; TPgSQLServer.h; TPgSQLStatement.h; src; TPgSQLResult.cxx; TPgSQLRow.cxx; TPgSQLServer.cxx; TPgSQLStatement.cxx; sapdb; inc; TSapDBResult.h; TSapDBRow.h; TSapDBServer.h; src; TSapDBResult.cxx; TSapDBRow.cxx; TSapDBServer.cxx; sqlite; inc; TSQLiteResult.h; TSQLiteRow.h; TSQLiteServer.h; TSQLiteStatement.h; src; TSQLiteResult.cxx; TSQLiteRow.cxx; TSQLiteServer.cxx; TSQLiteStatement.cxx; tmva; pymva; inc; TMVA; MethodPyAdaBoost.h; MethodPyGTB.h; MethodPyKeras.h; MethodPyRandomForest.h; PyMethodBase.h; src; MethodPyAdaBoost.cxx; MethodPyGTB.cxx; MethodPyKeras.cxx; MethodPyRandomForest.cxx; PyMethodBase.cxx; test; Classification.C; testPyAdaBoostClassification.C; testPyAdaBoostMulticlass.C; testPyGTBClassification.C; testPyGTBMulticlass.C; testPyKerasClassification.C; testPyKerasMulticlass.C; testPyKerasRegression.C; testPyRandomForestClassification.C; testPyRandomForestMulticlass.C; rmva; inc; TMVA; MethodC50.h; MethodRSNNS.h; MethodRSVM.h; MethodRXGB.h; RMethodBase.h; src; MethodC50.cxx; MethodRSNNS.cxx; MethodRSVM.cxx; MethodRXGB.cxx; RMethodBase.cxx; test; Classification.C; tmva; inc; TMVA; DNN; Architectures; Cpu; Blas.h; CpuBuffer.h; CpuMatrix.h; Cuda; CudaBuffers.h; CudaMatrix.h; Device.h; Cpu.h; Cuda.h; Reference.h; DataLoader.h; Functions.h; Layer.h; Minimizers.h; Net.h; BDTEventWrapper.h; BinarySearchTree.h; BinarySearchTreeNode.h; BinaryTree.h; CCPruner.h; CCTreeWrapper.h; ClassifierFactory.h; ClassInfo.h; Config.h; Configurable.h; ConvergenceTest.h; CostComplexityPruneTool.h; CrossEntropy.h; CrossValidation.h; DataInputHandler.h; DataLoader.h; DataSet.h; DataSetFactory.h; DataSetInfo.h; DataSetManager.h; Deci,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v610/files.html:85190,test,testPyGTBMulticlass,85190,doc/v610/files.html,https://root.cern,https://root.cern/doc/v610/files.html,1,['test'],['testPyGTBMulticlass']
Testability,"lt; At the end of the loop, print the sum of all event sizes. This sum shows you the real power of a TTree: even though you can analyze large amounts of data (our example tree with 22MB is tiny!) ROOT needs just a few MB of your RAM, no matter how many events you analyze. Imagine what it would be like if you had to load all data into memory, e.g. using a simple vector!; ... Int_t sizeInMB = totalSize/1024/1024;; printf(""Total size of all events: %d MB\n"", sizeInMB);; }. Running the Macro; To run this macro, simply type .x AnalyzeTree.C and ROOT will execute it. If it finds an error it might be wise to quit ROOT (.q) and try again!; If, for any reason, you don't manage to get it working, you can download a working macro file here: CountEvents.C; Here again, if you are using ROOT via ssh, you have to download the file with wget from your remote directory:; wget http://root-mirror.github.io/training/intro/CountEvents.C; .  TTree and Its Data; up; Histogramming . Navigate through this book; Meet a TTree; Accessing a TTree With a TBrowser; Using TTree::Draw() to access a TTree; TTree and Its Data; Using a Macro to Read a TTree; Histogramming; Fit Panel; Compiling Your Code (also known as ACLiC); Accessing a TTree With a TSelector; Histogramming in a Selector; Using a TSelector with PROOF; The End. Sitemap. DownloadDownload ROOT; All Releases. DocumentationReference Manual; User's Guides; HowTo; Courses; Building ROOT; Tutorials; Javascript Root; ROOT and Spark; Publications; FAQ. NewsBlog; Workshops. SupportForum; Bug submission guidelines; Submit a Bug; Discourse Mailing List Mode; RootTalk Digest. AboutLicence; Contact Us; Project Founders; Team; Previous Developers. DevelopmentProgram of Work; Code Owners; Release Checklist; Coding Conventions; Shifter's Instructions; Git Primer; Browse Sources; Meetings; ROOT 7; Run the tests; Jenkins; Setup externals from AFS/CVMFS; Doxygen; Benchmarks. ContributeCollaborate with Us.  Copyright CERN 2014-18. All rights reserved. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/using-macro-read-ttree.html:6620,test,tests,6620,d/using-macro-read-ttree.html,https://root.cern,https://root.cern/d/using-macro-read-ttree.html,1,['test'],['tests']
Testability,"ltMinimizerType("".."") Other option for the minimizer can be set using the static method of the MinimizerOptions class ; Definition at line 465 of file TF2.cxx. GetMinimum() [2/2]. Double_t TF1::GetMinimum ; (; Double_t; xmin = 0, . Double_t; xmax = 0, . Double_t; epsilon = 1.E-10, . Int_t; maxiter = 100, . Bool_t; logx = false. ); const. virtual . Returns the minimum value of the function on the (xmin, xmax) interval. ; Method: First, the grid search is used to bracket the maximum with the step size = (xmax-xmin)/fNpx. This way, the step size can be controlled via the SetNpx() function. If the function is unimodal or if its extrema are far apart, setting the fNpx to a small value speeds the algorithm up many times. Then, Brent's method is applied on the bracketed interval epsilon (default = 1.E-10) controls the relative accuracy (if |x| > 1 ) and absolute (if |x| < 1) and maxiter (default = 100) controls the maximum number of iteration of the Brent algorithm If the flag logx is set the grid search is done in log step size This is done automatically if the log scale is set in the current Pad; NOTE: see also TF1::GetMaximumX and TF1::GetX ; Reimplemented from TF1.; Definition at line 498 of file TF1.cxx. GetMinimumXY(). Double_t TF2::GetMinimumXY ; (; Double_t &; x, . Double_t &; y. ); const. virtual . Compute the X and Y values corresponding to the minimum value of the function. ; Return the minimum value of the function To find the minimum on a range, first set this range via the SetRange function; Method: First, a grid search is performed to find the initial estimate of the minimum location. The range of the function is divided into fNpx and fNpy sub-ranges. If the function is ""good"" (or ""bad""), these values can be changed by SetNpx and SetNpy functions Then, a minimization is used with starting values found by the grid search The minimizer algorithm used (by default Minuit) can be changed by callinga ROOT::Math::Minimizer::SetDefaultMinimizerType(""..""",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTF2.html:59798,log,logx,59798,doc/master/classTF2.html,https://root.cern,https://root.cern/doc/master/classTF2.html,3,['log'],"['log', 'logx']"
Testability,"ltiClass(). void TMVA::correlationsMultiClass ; (; TString; dataset, . TString; fin = ""TMVA.root"", . Bool_t; isRegression = kFALSE, . Bool_t; greyScale = kFALSE, . Bool_t; useTMVAStyle = kTRUE. ). CorrGui(). void TMVA::CorrGui ; (; TString; dataset, . TString; fin = ""TMVA.root"", . TString; dirName = ""InputVariables_Id"", . TString; title = ""TMVAInputVariable"", . Bool_t; isRegression = kFALSE. ). CorrGui_DeleteTBar(). void TMVA::CorrGui_DeleteTBar ; (; ). CorrGuiMultiClass(). void TMVA::CorrGuiMultiClass ; (; TString; dataset, . TString; fin = ""TMVA.root"", . TString; dirName = ""InputVariables_Id"", . TString; title = ""TMVAInputVariable"", . Bool_t; isRegression = kFALSE. ). CorrGuiMultiClass_DeleteTBar(). void TMVA::CorrGuiMultiClass_DeleteTBar ; (; ). CreateVariableTransforms(). void TMVA::CreateVariableTransforms ; (; const TString &; trafoDefinition, . TMVA::DataSetInfo &; dataInfo, . TMVA::TransformationHandler &; transformationHandler, . TMVA::MsgLogger &; log. ). Definition at line 59 of file VariableTransform.cxx. DataLoaderCopy(). void TMVA::DataLoaderCopy ; (; TMVA::DataLoader *; des, . TMVA::DataLoader *; src. ). DeleteFunctor(). template<class T > . DeleteFunctor_t< const T > TMVA::DeleteFunctor ; (; ). Definition at line 78 of file DataSetFactory.h. deviations(). void TMVA::deviations ; (; TString; dataset, . TString; fin = ""TMVAReg.root"", . HistType; htype = kMVAType, . Bool_t; showTarget = kTRUE, . Bool_t; useTMVAStyle = kTRUE. ). draw_activation(). void TMVA::draw_activation ; (; TCanvas *; c, . Double_t; cx, . Double_t; cy, . Double_t; radx, . Double_t; rady, . Int_t; whichActivation. ). draw_input_labels(). void TMVA::draw_input_labels ; (; TString; dataset, . Int_t; nInputs, . Double_t *; cy, . Double_t; rad, . Double_t; layerWidth. ). draw_layer(). void TMVA::draw_layer ; (; TString; dataset, . TCanvas *; c, . TH2F *; h, . Int_t; iHist, . Int_t; nLayers, . Double_t; maxWeight",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/namespaceTMVA.html:29940,log,log,29940,doc/master/namespaceTMVA.html,https://root.cern,https://root.cern/doc/master/namespaceTMVA.html,2,['log'],['log']
Testability,ltiRootSolver.h; GSLNLSMinimizer.cxx; GSLQRngWrapper.h; GSLQuasiRandom.cxx; GSLRndmEngines.cxx; GSLRngROOTWrapper.h; GSLRngWrapper.h; GSLRootFdFSolver.h; GSLRootFinder.cxx; GSLRootFinderDeriv.cxx; GSLRootFSolver.h; GSLRootHelper.cxx; GSLSimAnMinimizer.cxx; GSLSimAnnealing.cxx; Interpolator.cxx; KelvinFunctions.cxx; MCParameters.cxx; MultiNumGradFunction.cxx; PdfFuncMathMore.cxx; Polynomial.cxx; QuantFuncMathMore.cxx; RootFinderAlgorithms.cxx; SpecFuncMathMore.cxx; Vavilov.cxx; VavilovAccurate.cxx; VavilovAccurateCdf.cxx; VavilovAccuratePdf.cxx; VavilovAccurateQuantile.cxx; VavilovFast.cxx; zsolve_cubic.cxx; test; piRandom.C; pirndm.C; simanTSP.cxx; testChebyshev.cxx; testDerivation.cxx; testFunctor.cxx; testGSLIntegration.cxx; testGSLRootFinder.cxx; testInterpolation.cxx; testMCIntegration.cxx; testMinimization1D.cxx; testMultiRootFinder.cxx; testPermute.cxx; testQuasiRandom.cxx; testRandom.cxx; testRandomDist.cxx; testSpecFunc.cxx; testStatFunc.cxx; testVavilov.cxx; UnuRanDist.h; VavilovTest.cxx; VavilovTest.h; matrix; inc; LinkDef.h; TDecompBase.h; TDecompBK.h; TDecompChol.h; TDecompLU.h; TDecompQRH.h; TDecompSparse.h; TDecompSVD.h; TMatrix.h; TMatrixD.h; TMatrixDBase.h; TMatrixDBasefwd.h; TMatrixDEigen.h; TMatrixDfwd.h; TMatrixDLazy.h; TMatrixDSparse.h; TMatrixDSparsefwd.h; TMatrixDSym.h; TMatrixDSymEigen.h; TMatrixDSymfwd.h; TMatrixDUtils.h; TMatrixDUtilsfwd.h; TMatrixF.h; TMatrixFBase.h; TMatrixFBasefwd.h; TMatrixFfwd.h; TMatrixFLazy.h; TMatrixFSparse.h; TMatrixFSparsefwd.h; TMatrixFSym.h; TMatrixFSymfwd.h; TMatrixFUtils.h; TMatrixFUtilsfwd.h; TMatrixT.h; TMatrixTBase.h; TMatrixTCramerInv.h; TMatrixTLazy.h; TMatrixTSparse.h; TMatrixTSym.h; TMatrixTSymCramerInv.h; TMatrixTUtils.h; TVector.h; TVectorD.h; TVectorDfwd.h; TVectorF.h; TVectorFfwd.h; TVectorfwd.h; TVectorT.h; src; TDecompBase.cxx; TDecompBK.cxx; TDecompChol.cxx; TDecompLU.cxx; TDecompQRH.,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v608/files.html:49452,test,testStatFunc,49452,doc/v608/files.html,https://root.cern,https://root.cern/doc/v608/files.html,1,['test'],['testStatFunc']
Testability,ltiRootSolver.h; GSLNLSMinimizer.cxx; GSLQRngWrapper.h; GSLQuasiRandom.cxx; GSLRndmEngines.cxx; GSLRngROOTWrapper.h; GSLRngWrapper.h; GSLRootFdFSolver.h; GSLRootFinder.cxx; GSLRootFinderDeriv.cxx; GSLRootFSolver.h; GSLRootHelper.cxx; GSLSimAnMinimizer.cxx; GSLSimAnnealing.cxx; Interpolator.cxx; KelvinFunctions.cxx; MCParameters.cxx; MultiNumGradFunction.cxx; PdfFuncMathMore.cxx; Polynomial.cxx; QuantFuncMathMore.cxx; RootFinderAlgorithms.cxx; SpecFuncMathMore.cxx; Vavilov.cxx; VavilovAccurate.cxx; VavilovAccurateCdf.cxx; VavilovAccuratePdf.cxx; VavilovAccurateQuantile.cxx; VavilovFast.cxx; zsolve_cubic.cxx; test; piRandom.C; pirndm.C; simanTSP.cxx; testChebyshev.cxx; testDerivation.cxx; testFunctor.cxx; testGSLIntegration.cxx; testGSLRootFinder.cxx; testInterpolation.cxx; testMCIntegration.cxx; testMinimization1D.cxx; testMultiRootFinder.cxx; testPermute.cxx; testQuasiRandom.cxx; testRandom.cxx; testRandomDist.cxx; testSpecFunc.cxx; testStatFunc.cxx; testVavilov.cxx; UnuRanDist.h; VavilovTest.cxx; VavilovTest.h; matrix; inc; TDecompBase.h; TDecompBK.h; TDecompChol.h; TDecompLU.h; TDecompQRH.h; TDecompSparse.h; TDecompSVD.h; TMatrix.h; TMatrixD.h; TMatrixDBase.h; TMatrixDBasefwd.h; TMatrixDEigen.h; TMatrixDfwd.h; TMatrixDLazy.h; TMatrixDSparse.h; TMatrixDSparsefwd.h; TMatrixDSym.h; TMatrixDSymEigen.h; TMatrixDSymfwd.h; TMatrixDUtils.h; TMatrixDUtilsfwd.h; TMatrixF.h; TMatrixFBase.h; TMatrixFBasefwd.h; TMatrixFfwd.h; TMatrixFLazy.h; TMatrixFSparse.h; TMatrixFSparsefwd.h; TMatrixFSym.h; TMatrixFSymfwd.h; TMatrixFUtils.h; TMatrixFUtilsfwd.h; TMatrixT.h; TMatrixTBase.h; TMatrixTCramerInv.h; TMatrixTLazy.h; TMatrixTSparse.h; TMatrixTSym.h; TMatrixTSymCramerInv.h; TMatrixTUtils.h; TVector.h; TVectorD.h; TVectorDfwd.h; TVectorF.h; TVectorFfwd.h; TVectorfwd.h; TVectorT.h; src; TDecompBase.cxx; TDecompBK.cxx; TDecompChol.cxx; TDecompLU.cxx; TDecompQRH.cxx; TDecom,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v610/files.html:48030,test,testStatFunc,48030,doc/v610/files.html,https://root.cern,https://root.cern/doc/v610/files.html,1,['test'],['testStatFunc']
Testability,"ltype(opPtr); Internal class used by TF1 to get the right operator() signature from a Functor with several ones. ; ; template<typename T , typename F > ; autoGetTheRightOp (T(F::*opPtr)(T *, double *)) -> decltype(opPtr); ; static TVersionCheckgVersionCheck (ROOT_VERSION_CODE); ; template<typename > ; constexpr boolhasBeginEnd (...); ; template<typename T > ; constexpr autohasBeginEnd (int) -> decltype(std::begin(std::declval< T >()), std::end(std::declval< T >()), true); ; Bool_tHasConsistentHashMember (const char *clName); Return true is the Hash/RecursiveRemove setup is consistent, i.e. ; ; Bool_tHasConsistentHashMember (TClass &clRef); Return true is the Hash/RecursiveRemove setup is consistent, i.e. ; ; static Bool_t &IsImplicitMTEnabledImpl (); Keeps track of the status of ImplicitMT w/o resorting to the load of libImt. ; ; Bool_tIsParBranchProcessingEnabled (); Returns true if parallel branch processing is enabled. ; ; intLogicalCPUBandwidthControl (); Returns the available number of logical cores. ; ; voidMinimalErrorHandler (Int_t level, Bool_t abort_bool, const char *location, const char *msg); A very simple error handler that is usually replaced by the TROOT default error handler. ; ; voidNotifyDirected (Detail::TBranchProxy *x); ; std::ostream &operator<< (std::ostream &os, const RConcurrentHashColl::HashValue &h); ; booloperator== (const RConcurrentHashColl::HashValue &lhs, const RConcurrentHashColl::HashValue &rhs); ; template<typename T > ; static TParallelReduceHelper (const std::vector< T > &objs, const std::function< T(T a, T b)> &redfunc); A helper function to implement the TThreadExecutor::ParallelReduce methods. ; ; static boolR__AddPragmaForClass (TTreeProxyGenerator *gen, const char *classname); Add the ""pragma C++ class"" if needed and return true if it has been added or if it is known to not be needed. ; ; static boolR__AddPragmaForClass (TTreeProxyGenerator *gen, TClass *cl); Add the ""pragma C++ clas",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/namespaceROOT_1_1Internal.html:15643,log,logical,15643,doc/master/namespaceROOT_1_1Internal.html,https://root.cern,https://root.cern/doc/master/namespaceROOT_1_1Internal.html,2,['log'],['logical']
Testability,luate classifier: PDERS; : ; PDERS : [dataset] : Loop over test events and fill histograms with classifier response...; : ; TFHandler_PDERS : Variable Mean RMS [ Min Max ]; : -----------------------------------------------------------; : myvar1: 0.21781 1.7248 [ -9.8605 7.9024 ]; : myvar2: -0.062175 1.1106 [ -4.0854 4.0259 ]; : var3: 0.16451 1.0589 [ -5.3563 4.6422 ]; : var4: 0.43566 1.2253 [ -6.9675 5.0307 ]; : -----------------------------------------------------------; Factory : Evaluate classifier: PDEFoam; : ; PDEFoam : [dataset] : Loop over test events and fill histograms with classifier response...; : ; TFHandler_PDEFoam : Variable Mean RMS [ Min Max ]; : -----------------------------------------------------------; : myvar1: 0.21781 1.7248 [ -9.8605 7.9024 ]; : myvar2: -0.062175 1.1106 [ -4.0854 4.0259 ]; : var3: 0.16451 1.0589 [ -5.3563 4.6422 ]; : var4: 0.43566 1.2253 [ -6.9675 5.0307 ]; : -----------------------------------------------------------; Factory : Evaluate classifier: KNN; : ; KNN : [dataset] : Loop over test events and fill histograms with classifier response...; : ; TFHandler_KNN : Variable Mean RMS [ Min Max ]; : -----------------------------------------------------------; : myvar1: 0.21781 1.7248 [ -9.8605 7.9024 ]; : myvar2: -0.062175 1.1106 [ -4.0854 4.0259 ]; : var3: 0.16451 1.0589 [ -5.3563 4.6422 ]; : var4: 0.43566 1.2253 [ -6.9675 5.0307 ]; : -----------------------------------------------------------; Factory : Evaluate classifier: LD; : ; LD : [dataset] : Loop over test events and fill histograms with classifier response...; : ; : Also filling probability and rarity histograms (on request)...; TFHandler_LD : Variable Mean RMS [ Min Max ]; : -----------------------------------------------------------; : myvar1: 0.21781 1.7248 [ -9.8605 7.9024 ]; : myvar2: -0.062175 1.1106 [ -4.0854 4.0259 ]; : var3: 0.16451 1.0589 [ -5.3563 4.6422 ]; : var4: 0.43566 1.2253 [ -6.9675 5.0307 ]; : ---------------------------------------------------------,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVAClassification_8C.html:73041,test,test,73041,doc/master/TMVAClassification_8C.html,https://root.cern,https://root.cern/doc/master/TMVAClassification_8C.html,1,['test'],['test']
Testability,"luate() const =0Evaluate this PDF / function / constant. Needs to be overridden by all derived classes.; RooAbsReal::getTitleTString getTitle(bool appendUnit=false) constReturn this variable's title string.Definition RooAbsReal.cxx:285; RooAbsReal::logEvalErrorvoid logEvalError(const char *message, const char *serverValueString=nullptr) constLog evaluation error message.Definition RooAbsReal.cxx:3464; RooAbsReal::analyticalIntegralWNvirtual double analyticalIntegralWN(Int_t code, const RooArgSet *normSet, const char *rangeName=nullptr) constImplements the actual analytical integral(s) advertised by getAnalyticalIntegral.Definition RooAbsReal.cxx:380; RooAbsReal::getUnitconst Text_t * getUnit() constDefinition RooAbsReal.h:143; RooAbsReal::getIntegratorConfigconst RooNumIntConfig * getIntegratorConfig() constReturn the numeric integration configuration used for this object.Definition RooAbsReal.cxx:3309; RooAbsReal::printEvalErrorsstatic void printEvalErrors(std::ostream &os=std::cout, Int_t maxPerNode=10000000)Print all outstanding logged evaluation error on the given ostream.Definition RooAbsReal.cxx:3582; RooAbsReal::createIntRIRooFit::OwningPtr< RooAbsReal > createIntRI(const RooArgSet &iset, const RooArgSet &nset={})Utility function for createRunningIntegral.Definition RooAbsReal.cxx:3827; RooAbsReal::enableOffsettingvirtual void enableOffsetting(bool)Definition RooAbsReal.cxx:4484; RooAbsReal::clearEvalErrorLogstatic void clearEvalErrorLog()Clear the stack of evaluation error messages.Definition RooAbsReal.cxx:3542; RooAbsReal::createIntObjRooFit::OwningPtr< RooAbsReal > createIntObj(const RooArgSet &iset, const RooArgSet *nset, const RooNumIntConfig *cfg, const char *rangeName) constInternal utility function for createIntegral() that creates the actual integral object.Definition RooAbsReal.cxx:590; RooAbsReal::functorRooFunctor * functor(const RooArgList &obs, const RooArgList &pars=RooArgList(), const RooArgSet &nset=RooArgSet()) constReturn a RooFunctor obje",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RooAbsReal_8cxx_source.html:231747,log,logged,231747,doc/master/RooAbsReal_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html,1,['log'],['logged']
Testability,luatePartition; Int_tRooAbsTestStatistic::_extSet! Number of designated set to calculated extended term; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; RooAbsReal*RooAbsTestStatistic::_funcPointer to original input function; RooAbsReal*RooAbsOptTestStatistic::_funcClonePointer to internal clone of input function; RooArgSet*RooAbsOptTestStatistic::_funcCloneSetSet owning all components of internal clone of input function; RooArgSet*RooAbsOptTestStatistic::_funcObsSetList of observables in the pdf expression; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; RooAbsTestStatistic**RooAbsTestStatistic::_gofArray! Array of sub-contexts representing part of the combined test statistic; RooAbsTestStatistic::GOFOpModeRooAbsTestStatistic::_gofOpModeOperation mode of test statistic instance ; vector<RooFit::MPSplit>RooAbsTestStatistic::_gofSplitMode! GOF MP Split mode specified by component (when Auto is active); static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Bool_tRooAbsTestStatistic::_init! Is object initialized ; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Bool_tRooAbsArg::_isConstant! Cached isConstant status ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; RooRealMPFE**RooAbsTestStatistic::_mpfeArray! Array of parallel execution frond ends; RooFit::MPSplitRooAbsTestStatistic::_mpinterlUse interleaving strategy rather than N-wise split for partioning of dataset for multiprocessor-split; Int_tRooAbsTestStatistic::_nCPUNumber of processors to use in parallel calculation mode; In,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooDataWeightedAverage.html:37723,test,test,37723,root/html534/RooDataWeightedAverage.html,https://root.cern,https://root.cern/root/html534/RooDataWeightedAverage.html,1,['test'],['test']
Testability,"lue c0.; the new volume created will be medium number numed. void Gsdvt(const char* name, const char* mother, Double_t step, Int_t iaxis, Int_t numed, Int_t ndvmx). Create a new volume by dividing an existing one. Divides MOTHER into divisions called NAME along; axis IAXIS in steps of STEP. If not exactly divisible; will make as many as possible and will centre them; with respect to the mother. Divisions will have medium; number NUMED. If NUMED is 0, NUMED of MOTHER is taken.; NDVMX is the expected maximum number of divisions; (If 0, no protection tests are performed). void Gsdvt2(const char* name, const char* mother, Double_t step, Int_t iaxis, Double_t c0, Int_t numed, Int_t ndvmx). Create a new volume by dividing an existing one. Divides MOTHER into divisions called NAME along; axis IAXIS starting at coordinate value C0 with step; size STEP.; The new volume created will have medium number NUMED.; If NUMED is 0, NUMED of mother is taken.; NDVMX is the expected maximum number of divisions; (If 0, no protection tests are performed). void Gsord(const char* name, Int_t iax). Flags volume CHNAME whose contents will have to be ordered; along axis IAX, by setting the search flag to -IAX; IAX = 1 X axis; IAX = 2 Y axis; IAX = 3 Z axis; IAX = 4 Rxy (static ordering only -> GTMEDI); IAX = 14 Rxy (also dynamic ordering -> GTNEXT); IAX = 5 Rxyz (static ordering only -> GTMEDI); IAX = 15 Rxyz (also dynamic ordering -> GTNEXT); IAX = 6 PHI (PHI=0 => X axis); IAX = 7 THETA (THETA=0 => Z axis). void Gspos(const char* name, Int_t nr, const char* mother, Double_t x, Double_t y, Double_t z, Int_t irot, const char* konly). Position a volume into an existing one. NAME Volume name; NUMBER Copy number of the volume; MOTHER Mother volume name; X X coord. of the volume in mother ref. sys.; Y Y coord. of the volume in mother ref. sys.; Z Z coord. of the volume in mother ref. sys.; IROT Rotation matrix number w.r.t. mother ref. sys.; ONLY ONLY/MANY flag. It positions a previously defined vol",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoMCGeometry.html:15999,test,tests,15999,root/html528/TGeoMCGeometry.html,https://root.cern,https://root.cern/root/html528/TGeoMCGeometry.html,6,['test'],['tests']
Testability,"lue of the confidence level for the i^th entry in the results ; ; TClass *IsA () const override; ; boolIsOneSided () const; query if one sided result ; ; boolIsTwoSided () const; query if two sided result ; ; doubleLowerLimit () override; lower and upper bound of the confidence interval (to get upper/lower limits, multiply the size( = 1-confidence level ) by 2 ; ; doubleLowerLimitEstimatedError (); rough estimation of the error on the computed bound of the confidence interval Estimate of lower limit error function evaluates only a rough error on the lower limit. ; ; HypoTestInverterResult &operator= (const HypoTestInverterResult &other); operator = ; ; voidSetCLsCleanupThreshold (double th); set CLs threshold for exclusion cleanup function ; ; voidSetConfidenceLevel (double cl) override; set the confidence level for the interval (eg. 0.95 for a 95% Confidence Interval) ; ; voidSetInterpolationOption (InterpolOption_t opt); set the interpolation option, linear (kLinear ) or spline (kSpline) ; ; virtual voidSetTestSize (double size); set the size of the test (rate of Type I error) (eg. 0.05 for a 95% Confidence Interval) ; ; voidStreamer (TBuffer &) override; Stream an object of class TObject. ; ; voidStreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b); ; doubleUpperLimit () override; return the interval upper limit ; ; doubleUpperLimitEstimatedError (); Estimate of lower limit error function evaluates only a rough error on the lower limit. ; ; voidUseCLs (bool on=true); flag to switch between using CLsb (default) or CLs as confidence level ; ; Public Member Functions inherited from RooStats::SimpleInterval; SimpleInterval (const char *name, const RooRealVar &var, double lower, double upper, double cl); constructor from name, the Parameter of interest and lower/upper bound values ; ; SimpleInterval (const char *name=nullptr); default constructor ; ; SimpleInterval (const SimpleInterval &other, const char *name); ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooStats_1_1HypoTestInverterResult.html:6253,test,test,6253,doc/master/classRooStats_1_1HypoTestInverterResult.html,https://root.cern,https://root.cern/doc/master/classRooStats_1_1HypoTestInverterResult.html,1,['test'],['test']
Testability,"lue via trilinear interpolation; based on the 8 nearest bin center points ( corner of the cube surronding the points); The Algorithm is described in http://en.wikipedia.org/wiki/Trilinear_interpolation; The given values (x,y,z) must be between first bin center and last bin center for each coordinate:. fXAxis.GetBinCenter(1) < x < fXaxis.GetBinCenter(nbinX) AND; fYAxis.GetBinCenter(1) < y < fYaxis.GetBinCenter(nbinY) AND; fZAxis.GetBinCenter(1) < z < fZaxis.GetBinCenter(nbinZ). Double_t KolmogorovTest(const TH1* h2, Option_t* option = """") const; Statistical test of compatibility in shape between; THIS histogram and h2, using Kolmogorov test.; Default: Ignore under- and overflow bins in comparison. option is a character string to specify options; ""U"" include Underflows in test; ""O"" include Overflows; ""N"" include comparison of normalizations; ""D"" Put out a line of ""Debug"" printout; ""M"" Return the Maximum Kolmogorov distance instead of prob. The returned function value is the probability of test; (much less than one means NOT compatible). The KS test uses the distance between the pseudo-CDF's obtained; from the histogram. Since in more than 1D the order for generating the pseudo-CDF is; arbitrary, we use the pseudo-CDF's obtained from all the possible 6 combinatons of the 3 axis.; The average of all the maximum distances obtained is used in the tests. Long64_t Merge(TCollection* list); Add all histograms in the collection to this histogram.; This function computes the min/max for the axes,; compute a new number of bins, if necessary,; add bin contents, errors and statistics.; If overflows are present and limits are different the function will fail.; The function returns the total number of entries in the result histogram; if the merge is successfull, -1 otherwise. IMPORTANT remark. The 2 axis x and y may have different number; of bins and different limits, BUT the largest bin width must be; a multiple of the smallest bin width and the upper limit must also; be a multiple",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TH3.html:37043,test,test,37043,root/html528/TH3.html,https://root.cern,https://root.cern/root/html528/TH3.html,6,['test'],['test']
Testability,"lue;; 313 }; 314 return res * (mod - 1.0);; 315 }; 316 ; 317 return 0.0;; 318}; 319 ; 320inline double flexibleInterp(unsigned int code, double const *params, unsigned int n, double const *low,; 321 double const *high, double boundary, double nominal, int doCutoff); 322{; 323 double total = nominal;; 324 for (std::size_t i = 0; i < n; ++i) {; 325 total += flexibleInterpSingle(code, low[i], high[i], boundary, nominal, params[i], total);; 326 }; 327 ; 328 return doCutoff && total <= 0 ? TMath::Limits<double>::Min() : total;; 329}; 330 ; 331inline double landau(double x, double mu, double sigma); 332{; 333 if (sigma <= 0.); 334 return 0.;; 335 return ROOT::Math::landau_pdf((x - mu) / sigma);; 336}; 337 ; 338inline double logNormal(double x, double k, double m0); 339{; 340 return ROOT::Math::lognormal_pdf(x, std::log(m0), std::abs(std::log(k)));; 341}; 342 ; 343inline double logNormalStandard(double x, double sigma, double mu); 344{; 345 return ROOT::Math::lognormal_pdf(x, mu, std::abs(sigma));; 346}; 347 ; 348inline double effProd(double eff, double pdf); 349{; 350 return eff * pdf;; 351}; 352 ; 353inline double nll(double pdf, double weight, int binnedL, int doBinOffset); 354{; 355 if (binnedL) {; 356 // Special handling of this case since std::log(Poisson(0,0)=0 but can't be; 357 // calculated with usual log-formula since std::log(mu)=0. No update of result; 358 // is required since term=0.; 359 if (std::abs(pdf) < 1e-10 && std::abs(weight) < 1e-10) {; 360 return 0.0;; 361 }; 362 if (doBinOffset) {; 363 return pdf - weight - weight * (std::log(pdf) - std::log(weight));; 364 }; 365 return pdf - weight * std::log(pdf) + TMath::LnGamma(weight + 1);; 366 } else {; 367 return -weight * std::log(pdf);; 368 }; 369}; 370 ; 371inline double recursiveFraction(double *a, unsigned int n); 372{; 373 double prod = a[0];; 374 ; 375 for (unsigned int i = 1; i < n; ++i) {; 376 prod *= 1.0 - a[i];; 377 }; 378 ; 379 return prod;; 380}; 381 ; 382inline double cbShape(double m, double m0",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/MathFuncs_8h_source.html:10696,log,logNormal,10696,doc/master/MathFuncs_8h_source.html,https://root.cern,https://root.cern/doc/master/MathFuncs_8h_source.html,7,['log'],"['log', 'log-formula', 'logNormal', 'logNormalStandard']"
Testability,"lueRooPrintable; kInvalidObject enum valueTObject; kIsOnHeap enum valueTObject; kIsReferenced enum valueTObject; kMustCleanup enum valueTObject; kName enum valueRooPrintable; kNoContextMenu enum valueTObject; kNotDeleted enum valueTObject; kObjInCanvas enum valueTObject; kOnlyPrepStep enum valueTObjectprotected; kOverwrite enum valueTObject; kSingleKey enum valueTObject; kSingleLine enum valueRooPrintable; kStandard enum valueRooPrintable; kTitle enum valueRooPrintable; kTreeStructure enum valueRooPrintable; kValue enum valueRooPrintable; kVerbose enum valueRooPrintable; kWriteDelete enum valueTObject; kZombie enum valueTObject; leafNodeServerList(RooAbsCollection *list, const RooAbsArg *arg=nullptr, bool recurseNonDerived=false) constRooAbsArg; localNoDirtyInhibit() constRooAbsArginline; logBatchComputationErrors(std::span< const double > &outputs, std::size_t begin) constRooAbsPdfprivate; logEvalError(const char *message, const char *serverValueString=nullptr) constRooAbsReal; logEvalError(const RooAbsReal *originator, const char *origName, const char *message, const char *serverValueString=nullptr)RooAbsRealstatic; ls(Option_t *option="""") const overrideTNamedvirtual; makeLegacyIterator(const RefCountList_t &list) constRooAbsArgprivate; makeProjectionSet(const RooAbsArg *plotVar, const RooArgSet *allVars, RooArgSet &projectedVars, bool silent) constRooAbsRealprotected; MakeZombie()TObjectinlineprotected; matchArgs(const RooArgSet &allDeps, RooArgSet &numDeps, const RooArgProxy &a) constRooAbsRealprotected; matchArgs(const RooArgSet &allDeps, RooArgSet &numDeps, const RooArgProxy &a, const RooArgProxy &b) constRooAbsRealprotected; matchArgs(const RooArgSet &allDeps, RooArgSet &numDeps, const RooArgProxy &a, const RooArgProxy &b, const RooArgProxy &c) constRooAbsRealprotected; matchArgs(const RooArgSet &allDeps, RooArgSet &numDeps, const RooArgProxy &a, const RooArgProxy &b, const RooArgProxy &c, const RooArgProxy &d) constRooAbsRealprotected; matchArgs(const RooArgS",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsPdf-members.html:25066,log,logEvalError,25066,doc/master/classRooAbsPdf-members.html,https://root.cern,https://root.cern/doc/master/classRooAbsPdf-members.html,1,['log'],['logEvalError']
Testability,"lues kFitPower2,4,6,8,10,12, for details see references. It applies only for Awmi fitting function.; fitTaylor - order of Taylor expansion, possible values kFitTaylorOrderFirst, kFitTaylorOrderSecond. It applies only for Awmi fitting function. . Definition at line 2610 of file TSpectrumFit.cxx. SetPeakParameters(). void TSpectrumFit::SetPeakParameters ; (; Double_t; sigma, . Bool_t; fixSigma, . const Double_t *; positionInit, . const Bool_t *; fixPosition, . const Double_t *; ampInit, . const Bool_t *; fixAmp. ). This function sets the following fitting parameters of peaks: . sigma - initial value of sigma parameter; fixSigma - logical value of sigma parameter, which allows to fix the parameter (not to fit); positionInit - array of initial values of peaks positions; fixPosition - array of logical values which allow to fix appropriate positions (not fit). However they are present in the estimated functional.; ampInit - array of initial values of peaks amplitudes; fixAmp - array of logical values which allow to fix appropriate amplitudes (not fit). However they are present in the estimated functional . Definition at line 2658 of file TSpectrumFit.cxx. SetTailParameters(). void TSpectrumFit::SetTailParameters ; (; Double_t; tInit, . Bool_t; fixT, . Double_t; bInit, . Bool_t; fixB, . Double_t; sInit, . Bool_t; fixS. ). This function sets the following fitting parameters of tails of peaks. . tInit - initial value of t parameter; fixT - logical value of t parameter, which allows to fix the parameter (not to fit); bInit - initial value of b parameter; fixB - logical value of b parameter, which allows to fix the parameter (not to fit); sInit - initial value of s parameter; fixS - logical value of s parameter, which allows to fix the parameter (not to fit) . Definition at line 2712 of file TSpectrumFit.cxx. Shape(). Double_t TSpectrumFit::Shape ; (; Int_t; num_of_fitted_peaks, . Double_t; i, . const Double_t *; parameter, . Double_t; sigma, . Double_t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSpectrumFit.html:47111,log,logical,47111,doc/master/classTSpectrumFit.html,https://root.cern,https://root.cern/doc/master/classTSpectrumFit.html,1,['log'],['logical']
Testability,"lues which allow to fix appropriate amplitudes of 1D ridges in y direction (not fit). However they are present in the estimated functional ; ; Bool_tfFixAx; logical value of ax parameter, which allows to fix the parameter (not to fit). ; ; Bool_tfFixAy; logical value of ay parameter, which allows to fix the parameter (not to fit). ; ; Bool_tfFixBx; logical value of b parameter for 1D ridges in x direction, which allows to fix the parameter (not to fit). ; ; Bool_tfFixBy; logical value of b parameter for 1D ridges in y direction, which allows to fix the parameter (not to fit). ; ; Bool_t *fFixPositionX; [fNPeaks] array of logical values which allow to fix appropriate x positions of 2D peaks (not fit). However they are present in the estimated functional ; ; Bool_t *fFixPositionX1; [fNPeaks] array of logical values which allow to fix appropriate x positions of 1D ridges (not fit). However they are present in the estimated functional ; ; Bool_t *fFixPositionY; [fNPeaks] array of logical values which allow to fix appropriate y positions of 2D peaks (not fit). However they are present in the estimated functional ; ; Bool_t *fFixPositionY1; [fNPeaks] array of logical values which allow to fix appropriate y positions of 1D ridges (not fit). However they are present in the estimated functional ; ; Bool_tfFixRo; logical value of correlation coefficient, which allows to fix the parameter (not to fit). ; ; Bool_tfFixSigmaX; logical value of sigma x parameter, which allows to fix the parameter (not to fit). ; ; Bool_tfFixSigmaY; logical value of sigma y parameter, which allows to fix the parameter (not to fit). ; ; Bool_tfFixSx; logical value of s parameter for 1D ridges in x direction, which allows to fix the parameter (not to fit). ; ; Bool_tfFixSxy; logical value of s parameter for 2D peaks, which allows to fix the parameter (not to fit). ; ; Bool_tfFixSy; logical value of s parameter for 1D ridges in y direction, which allows to fix ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSpectrum2Fit.html:27372,log,logical,27372,doc/master/classTSpectrum2Fit.html,https://root.cern,https://root.cern/doc/master/classTSpectrum2Fit.html,1,['log'],['logical']
Testability,"lume *; vol, . Double_t; ovlp = 0.1, . Option_t *; option = """". ). Check illegal overlaps for volume VOL within a limit OVLP. ; Definition at line 1427 of file TGeoChecker.cxx. CheckOverlapsBySampling(). void TGeoChecker::CheckOverlapsBySampling ; (; TGeoVolume *; vol, . Double_t; ovlp = 0.1, . Int_t; npoints = 1000000. ); const. Check illegal overlaps for volume VOL within a limit OVLP by sampling npoints inside the volume shape. ; Definition at line 1196 of file TGeoChecker.cxx. CheckPoint(). void TGeoChecker::CheckPoint ; (; Double_t; x = 0, . Double_t; y = 0, . Double_t; z = 0, . Option_t *; option = """", . Double_t; safety = 0.. ). Draw point (x,y,z) over the picture of the daughters of the volume containing this point. ; Generates a report regarding the path to the node containing this point and the distance to the closest boundary. ; Definition at line 1692 of file TGeoChecker.cxx. CheckShape(). void TGeoChecker::CheckShape ; (; TGeoShape *; shape, . Int_t; testNo, . Int_t; nsamples, . Option_t *; option. ). Test for shape navigation methods. ; Summary for test numbers:; 1: DistFromInside/Outside. Sample points inside the shape. Generate directions randomly in cos(theta). Compute DistFromInside and move the point with bigger distance. Compute DistFromOutside back from new point. Plot d-(d1+d2); 2: Safety test. Sample points inside the bounding and compute safety. Generate directions randomly in cos(theta) and compute distance to boundary. Check if distance to boundary is bigger than safety . Definition at line 1752 of file TGeoChecker.cxx. CheckVoxels(). Double_t TGeoChecker::CheckVoxels ; (; TGeoVolume *; vol, . TGeoVoxelFinder *; voxels, . Double_t *; xyz, . Int_t; npoints. ). count voxel timing ; Definition at line 2967 of file TGeoChecker.cxx. Class(). static TClass * TGeoChecker::Class ; (; ). static . ReturnsTClass describing this class . Class_Name(). static const char * TGeoChecker::Class_Name ; (; ). static . Return",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoChecker.html:21436,test,testNo,21436,doc/master/classTGeoChecker.html,https://root.cern,https://root.cern/doc/master/classTGeoChecker.html,1,['test'],['testNo']
Testability,"lume();; // or:; cvol = cnode->GetVolume(); // (*); // then:; TGeoMaterial *cmat = cvol->GetMedium()->GetMaterial();; (*) Note: If the current point is in fact outside the geometry, the current node pointer will not be NULL, but pointing to the top node.; In order to take decisions in such case one needs always to test:; if (gGeoManager->IsOutside()) {; // current point is actually outside; ... // corresponding action; }; Specific information related to the current volume/node like IDs or shape can be then retrieved from the corresponding objects. Current state index. The number of possible different states of the modeller corresponds to the number of different objects/paths in the geometry. This has nothing to do with the number of nodes, since the same node can be found on different branches. In other words, the number of states corresponds to the number of nodes in the expanded geometry tree. Since unfortunately this expansion from logical to physical hierarchy cannot be stored on regular basis due to the large size of the latter, one cannot directly assign state numbers. If the size of the expansion proves however to be small enough (less than about 50 million objects), a parallel structure storing these state indices is built and stored in memory. In such case each state automatically gets an index that can be retrieved after any state initialization. These indices can prove to be quite useful for being able to keep track of the navigation history and force certain states. Lets illustrate how this works with a simple example:; Suppose we have a simple geometry with a volume B positioned twice inside a container A. Then A is positioned twice in a top container T. The complete list of logical nodes is: T_1, A_1, A_2, B_1, B_2. On the other hand we will have more states than logical nodes:; /T_1- 1 state at level = 0; /T_1/A_1,/T_1/A_2- 2 states at level = 1; /T_1/A_1/B_1,/T_1/A_1/B_2,/T_1/A_2/B_1,/T_1/A_2/B_2 - 4 states at level = 2; All these states will get au",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:978663,log,logical,978663,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['log'],['logical']
Testability,"lumns selection can be made using ""var1:var2:var3"". ; selectiona text formula selecting which entries to scan ; firstentryfirst entry to scan ; nentriestotal number of entries to scan (starting from firstentry). Defaults to all entries. . ReturnsThe function returns the number of entries passing the selection.; By default 50 lines are shown and you are asked for <CR> or q to see the next 50 lines. Depending on the Tree structure, one entry might be printed across several lines, distinguished by the Instance column. You can change the default number of lines to be shown before <CR> or q via mytree->SetScanField(maxlines) where maxlines is 50 by default. If maxlines is set to 0 all entries of the Tree are shown, and you are not prompted to press <CR> or q to end the loop.; This option is interesting when dumping the contents of a Tree to an ascii file, eg from the command line. . with ROOT 5; root [0] tree->SetScanField(0);; root [1] tree->Scan(""*""); >tree.log; ; with ROOT 6; root [0] tree->SetScanField(0);; root [1] .> tree.log; tree->Scan(""*"");; .>; will create a file tree.log; Arrays (within an entry) are printed in their linear forms. If several arrays with multiple dimensions are printed together, they will NOT be synchronized. For example print arr1[4][2] and arr2[2][3] will results in a printing similar to: ***********************************************; * Row * Instance * arr1 * arr2 *; ***********************************************; * x * 0 * arr1[0][0]* arr2[0][0]*; * x * 1 * arr1[0][1]* arr2[0][1]*; * x * 2 * arr1[1][0]* arr2[0][2]*; * x * 3 * arr1[1][1]* arr2[1][0]*; * x * 4 * arr1[2][0]* arr2[1][1]*; * x * 5 * arr1[2][1]* arr2[1][2]*; * x * 6 * arr1[3][0]* *; * x * 7 * arr1[3][1]* *; However, if there is a selection criterion which is an array, then all the formulas will be synchronized with the selection criterion (see TTreePlayer::DrawSelect for more information).; Parameters. optionThe options string can contains the following parameters:. lenmax=dd W",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTTreePlayer.html:46497,log,log,46497,doc/master/classTTreePlayer.html,https://root.cern,https://root.cern/doc/master/classTTreePlayer.html,1,['log'],['log']
Testability,"lutionModel, RooSimultaneous, RooTruthModel, RooWrapperPdf, and RooNonCentralChiSquare.; Definition at line 351 of file RooAbsPdf.h. isActiveNormSet(). bool RooAbsPdf::isActiveNormSet ; (; RooArgSet const *; normSet); const. inlineprotected . Checks if normSet is the currently active normalization set of this PDF, meaning is exactly the same object as the one the _normSet member points to (or both are nullptr). ; Definition at line 299 of file RooAbsPdf.h. isDirectGenSafe(). bool RooAbsPdf::isDirectGenSafe ; (; const RooAbsArg &; arg); const. virtual . Check if given observable can be safely generated using the pdfs internal generator mechanism (if that existsP). ; Observables on which a PDF depends via more than route are not safe for use with internal generators because they introduce correlations not known to the internal generator ; Reimplemented in RooAbsAnaConvPdf, RooAddModel, RooBinSamplingPdf, and RooProdPdf.; Definition at line 1557 of file RooAbsPdf.cxx. logBatchComputationErrors(). void RooAbsPdf::logBatchComputationErrors ; (; std::span< const double > &; outputs, . std::size_t; begin. ); const. private . Scan through outputs and fix+log all nans and negative values. ; Parameters. [in,out]outputsArray to be scanned & fixed. ; [in]beginBegin of event range. Only needed to print the correct event number where the error occurred. . Definition at line 654 of file RooAbsPdf.cxx. mustBeExtended(). bool RooAbsPdf::mustBeExtended ; (; ); const. inline . If true PDF must provide extended likelihood term. ; Definition at line 222 of file RooAbsPdf.h. normalizeWithNaNPacking(). double RooAbsPdf::normalizeWithNaNPacking ; (; double; rawVal, . double; normVal. ); const. protected . Definition at line 282 of file RooAbsPdf.cxx. normRange(). const char * RooAbsPdf::normRange ; (; ); const. inline . Definition at line 250 of file RooAbsPdf.h. paramOn() [1/2]. RooPlot * RooAbsPdf::paramOn ; (; RooPlot *; frame, . const RooArgSet &; params, . bool",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsPdf.html:132998,log,logBatchComputationErrors,132998,doc/master/classRooAbsPdf.html,https://root.cern,https://root.cern/doc/master/classRooAbsPdf.html,1,['log'],['logBatchComputationErrors']
Testability,"lutionModel::isConvolved(); virtual Bool_tRooAbsArg::isDerived() const; virtual Bool_tRooAbsPdf::isDirectGenSafe(const RooAbsArg& arg) const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; virtual Bool_tRooAbsArg::isFundamental() const; virtual Bool_tRooAbsArg::isLValue() const; Bool_tTObject::IsOnHeap() const; Bool_tRooAbsArg::isShapeDirty() const; Bool_tRooAbsArg::isShapeServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isShapeServer(const char* name) const; virtual Bool_tRooAbsArg::IsSortable() const; Bool_tRooAbsArg::isValueDirty() const; Bool_tRooAbsArg::isValueServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isValueServer(const char* name) const; Bool_tTObject::IsZombie() const; voidRooAbsArg::leafNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; voidRooAbsReal::logEvalError(const char* message, const char* serverValueString = 0) const; static voidRooAbsReal::logEvalError(const RooAbsReal* originator, const char* origName, const char* message, const char* serverValueString = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooMoment*RooAbsReal::mean(RooRealVar& obs); RooMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); Int_tRooAbsPdf::minDimNormValueCaching() const; virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tRooAbsPdf::mustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); virtual voidRooResolutionModel::normLeafServerList(RooArgSet& list) const; const char*RooAbsPdf::normRange() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCache",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooGaussModel.html:20328,log,logEvalError,20328,root/html528/RooGaussModel.html,https://root.cern,https://root.cern/root/html528/RooGaussModel.html,6,['log'],['logEvalError']
Testability,"lutionModel::isConvolved(); virtual Bool_tRooAbsArg::isDerived() const; virtual Bool_tRooAbsPdf::isDirectGenSafe(const RooAbsArg& arg) const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; virtual Bool_tRooAbsArg::isFundamental() const; virtual Bool_tRooAbsArg::isLValue() const; Bool_tTObject::IsOnHeap() const; Bool_tRooAbsArg::isShapeDirty() const; Bool_tRooAbsArg::isShapeServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isShapeServer(const char* name) const; virtual Bool_tRooAbsArg::IsSortable() const; Bool_tRooAbsArg::isValueDirty() const; Bool_tRooAbsArg::isValueServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isValueServer(const char* name) const; Bool_tTObject::IsZombie() const; voidRooAbsArg::leafNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; voidRooAbsReal::logEvalError(const char* message, const char* serverValueString = 0) const; static voidRooAbsReal::logEvalError(const RooAbsReal* originator, const char* origName, const char* message, const char* serverValueString = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooMoment*RooAbsReal::mean(RooRealVar& obs); RooMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); Int_tRooAbsPdf::minDimNormValueCaching() const; virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tRooAbsPdf::mustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); virtual voidRooResolutionModel::normLeafServerList(RooArgSet& list) const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEva",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooGaussModel.html:20266,log,logEvalError,20266,root/html526/RooGaussModel.html,https://root.cern,https://root.cern/root/html526/RooGaussModel.html,3,['log'],['logEvalError']
Testability,"ly kept; Int_tfMergedWorkersNumber of workers merged; TMonitor*fMergingMonitorMonitor for merging sockets; TServerSocket*fMergingSocketSocket used for merging outputs if submerger; Long64_tfMsgSizeHWMHigh-Water-Mark on the size of messages with results; Int_tfNcmdcommand history number; TStringfOrdinalslave ordinal number; TStringfPackageDirdirectory containing packages and user libs; TProofLockPath*fPackageLockpackage dir locker; TVirtualProofPlayer*fPlayeractual player; TStringfPrefixPrefix identifying the node; TProof*fProofPROOF talking to slave servers; Int_tfProtocolprotocol version number; TQueryResultManager*fQMgrQuery-result manager; TMutex*fQMtxTo protect async msg queue; TStringfQueryDirdirectory containing query results and status; TProofLockPath*fQueryLockquery dir locker; Int_tfQuerySeqNumsequential number of the current or last query; TList*fQueuedMsglist of messages waiting to be processed; Float_tfRealTimereal time spent executing commands; Bool_tfRealTimeLogTRUE if log messages should be send back in real-time; TReaperTimer*fReaperTimerTimer used to control children state; Bool_tfSendLogToMasterOn workers, controls logs sending to master; TStringfServiceservice we are running, either ""proofserv"" or ""proofslave""; TStringfSessionDirdirectory containing session dependent files; TStringfSessionTagtag for the server session; TShutdownTimer*fShutdownTimerTimer used to shutdown out-of-control sessions; TSocket*fSocketsocket connection to client; TStringfTopSessionTagtag for the global session; Int_tfTotSessionsTotal number of PROOF sessions on the cluster ; TStringfUseruser as which we run; TList*fWaitingQuerieslist of TProofQueryResult waiting to be processed; TStringfWorkDirdirectory containing all proof related info; static FILE*fgErrorHandlerFileFile where to log; static Int_tfgLogToSysLog>0 sent to syslog too; static Float_tfgMemHWMThreshold fraction of max for warning and finer monitoring; static Float_tfgMemStopFraction of max for stop processing; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TProofServ.html:19088,log,log,19088,root/html528/TProofServ.html,https://root.cern,https://root.cern/root/html528/TProofServ.html,3,['log'],['log']
Testability,"ly needs to be downloaded; (a valid copy may already exist in the cache; from a previous run); the bit is set by; UploadPackage, since the check is done elsewhere.; kForward (0x4) if set, ask server to forward the file to slave; or submaster (meaningless for slave servers).; kCpBin (0x8) Retrieve from the cache the binaries associated; with the file; kCp (0x10) Retrieve the files from the cache. Definition at line 6894 of file TProof.cxx. SendGroupView(). Int_t TProof::SendGroupView ; (; ). private . Send to all active slaves servers the current slave group size and their unique id. ; Returns number of active slaves. Returns -1 in case of error. ; Definition at line 6460 of file TProof.cxx. SendingLogToWindow(). Bool_t TProof::SendingLogToWindow ; (; ); const. inline . Definition at line 1016 of file TProof.h. SendInitialState(). Int_t TProof::SendInitialState ; (; ). private . Transfer the initial (i.e. ; current) state of the master to all slave servers. Currently the initial state includes: log level. Returns the number of active slaves. Returns -1 in case of error. ; Definition at line 6774 of file TProof.cxx. SendInputData(). Int_t TProof::SendInputData ; (; TQueryResult *; qr, . TProof *; p, . TString &; emsg. ). staticprotected . Send the input data file to the workers. ; Definition at line 12380 of file TProof.cxx. SendInputDataFile(). void TProof::SendInputDataFile ; (; ). protectedvirtual . Send the input data objects to the master; the objects are taken from the dedicated list and / or the specified file. ; If the fInputData is empty the specified file is sent over. If there is no specified file, a file named ""inputdata.root"" is created locally with the content of fInputData and sent over to the master. If both fInputData and the specified file are not empty, a copy of the file is made locally and augmented with the content of fInputData. ; Reimplemented in TProofLite.; Definition at line 9612 of file TProof.cxx. SendLogToWindow(). void TPr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProof.html:139779,log,log,139779,doc/master/classTProof.html,https://root.cern,https://root.cern/doc/master/classTProof.html,1,['log'],['log']
Testability,"lyLine(4, xb, yb);; 3753 }; 3754 if (ylow2 == ylow && DrawYLow) {; 3755 xb[0] = x-tx; yb[0] = ylow2+ty;; 3756 xb[1] = x-tx; yb[1] = ylow2;; 3757 xb[2] = x+tx; yb[2] = ylow2;; 3758 xb[3] = x+tx; yb[3] = ylow2+ty;; 3759 gPad->PaintPolyLine(4, xb, yb);; 3760 }; 3761 } else {; 3762 if (yup2 == yup && DrawYUp) gPad->PaintLine(x-tx,yup2,x+tx,yup2);; 3763 if (ylow2 == ylow && DrawYLow) gPad->PaintLine(x-tx,ylow2,x+tx,ylow2);; 3764 }; 3765 }; 3766 }; 3767 }; 3768 }; 3769 ; 3770 if (!brackets && !axis) PaintGraphSimple(theGraph, option);; 3771 gPad->ResetBit(TGraph::kClipFrame);; 3772 ; 3773 if (option3) {; 3774 Int_t logx = gPad->GetLogx();; 3775 Int_t logy = gPad->GetLogy();; 3776 gPad->SetLogx(0);; 3777 gPad->SetLogy(0);; 3778 if (option4) PaintGraph(theGraph, 2*theNpoints, xline.data(), yline.data(),""FC"");; 3779 else PaintGraph(theGraph, 2*theNpoints, xline.data(), yline.data(),""F"");; 3780 gPad->SetLogx(logx);; 3781 gPad->SetLogy(logy);; 3782 }; 3783}; 3784 ; 3785 ; 3786////////////////////////////////////////////////////////////////////////////////; 3787/// [Paint this TGraphPolar with its current attributes.](\ref GrP4); 3788 ; 3789void TGraphPainter::PaintGraphPolar(TGraph *theGraph, Option_t* options); 3790{; 3791 ; 3792 Int_t ipt, i;; 3793 Double_t rwrmin, rwrmax, rwtmin, rwtmax;; 3794 ; 3795 TGraphPolar *theGraphPolar = (TGraphPolar*) theGraph;; 3796 ; 3797 Int_t theNpoints = theGraphPolar->GetN();; 3798 Double_t *theX = theGraphPolar->GetX();; 3799 Double_t *theY = theGraphPolar->GetY();; 3800 Double_t *theEX = theGraphPolar->GetEX();; 3801 Double_t *theEY = theGraphPolar->GetEY();; 3802 ; 3803 if (theNpoints<1) return;; 3804 TString opt = options;; 3805 opt.ToUpper();; 3806 ; 3807 Bool_t nolabel = kFALSE;; 3808 if (opt.Contains(""N"")){; 3809 nolabel = kTRUE;; 3810 opt.ReplaceAll(""N"","""");; 3811 }; 3812 ; 3813 TGraphPolargram *thePolargram = theGraphPolar->GetPolargram();; 3814 ; 3815 // Check for existing TGraphPolargram in the Pad; 3816 if (gPad) {; 3817 // Existin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGraphPainter_8cxx_source.html:133594,log,logx,133594,doc/master/TGraphPainter_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGraphPainter_8cxx_source.html,2,['log'],"['logx', 'logy']"
Testability,"lyMarkerA PolyMarker is defined by an array on N points in a 2-D space ; CTPolyMarker3DA 3D polymarker ; CTPosixCondition; CTPosixMutex; CTPosixThread; CTPosixThreadCleanUp; CTPosixThreadFactory; CTPostScriptInterface to PostScript ; CTPRegexp; CTPrimaryOld version of a dynamic particle class created by event generators ; CTPrincipalPrincipal Components Analysis (PCA) ; CTProcessEventTimer; CTProcessIDA TProcessID identifies a ROOT job in a unique way in time and space ; CTProcessUUIDThis class is a specialized TProcessID managing the list of UUIDs ; CTProfileProfile Histogram ; CTProfile2DProfile2D histograms are used to display the mean value of Z and its RMS for each cell in X,Y ; CTProfile2Poly; CTProfile2PolyBin; CTProfile3DProfile3D histograms are used to display the mean value of T and its RMS for each cell in X,Y,Z ; CTProfileHelper; CTProofThis class controls a Parallel ROOT Facility, PROOF, cluster ; CMD5Mod_t; CTProofBenchSteering class for PROOF benchmarks ; CTProofBenchDataSetHandle operations on datasets used by ProofBench ; CTProofBenchRunAbstract base class for PROOF benchmark runs ; CTProofBenchRunCPUCPU-intensive PROOF benchmark test generates events and fill 1, 2, or 3-D histograms ; CTProofBenchRunDataReadI/O-intensive PROOF benchmark test reads in event files distributed on the cluster ; CTProofChain; CTProofCondor; CTProofDebug; CTProofDesc; CTProofDrawImplement Tree drawing using PROOF ; CTProofDrawEntryList; CTProofDrawEventList; CTProofDrawGraph; CTProofDrawHist; CTProofDrawListOfGraphs; CPoint3D_t; CTProofDrawListOfPolyMarkers3D; CPoint4D_t; CTProofDrawPolyMarker3D; CTProofDrawProfile; CTProofDrawProfile2D; CTProofInputHandler; CTProofInterruptHandler; CTProofLimitsFinderClass to find axis limits and synchronize them between workers ; CTProofLiteThis class starts a PROOF session on the local machine: no daemons, client and master merged, communications via UNIX-like sockets ; CTProofLockPath;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v610/annotated.html:186302,benchmark,benchmarks,186302,doc/v610/annotated.html,https://root.cern,https://root.cern/doc/v610/annotated.html,1,['benchmark'],['benchmarks']
Testability,"lyticalIntegral(). int RooLegacyExpPoly::getAnalyticalIntegral ; (; RooArgSet &; allVars, . RooArgSet &; analVars, . const char *; rangeName = nullptr. ); const. overridevirtual . Interface function getAnalyticalIntergral advertises the analytical integrals that are supported. ; 'integSet' is the set of dependents for which integration is requested. The function should copy the subset of dependents it can analytically integrate to anaIntSet and return a unique identification code for this integration configuration. If no integration can be performed, zero should be returned. ; Reimplemented from RooAbsReal.; Definition at line 199 of file RooLegacyExpPoly.cxx. getFormulaExpression(). std::string RooLegacyExpPoly::getFormulaExpression ; (; bool; expand); const. Definition at line 299 of file RooLegacyExpPoly.cxx. getLogVal(). double RooLegacyExpPoly::getLogVal ; (; const RooArgSet *; set); const. overridevirtual . Return the log of the current value with given normalization An error message is printed if the argument of the log is negative. ; Reimplemented from RooAbsPdf.; Definition at line 191 of file RooLegacyExpPoly.cxx. IsA(). TClass * RooLegacyExpPoly::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from RooAbsPdf.; Definition at line 57 of file RooLegacyExpPoly.h. lowestOrder(). int RooLegacyExpPoly::lowestOrder ; (; ); const. inline . Return the order for the first coefficient in the list. ; Definition at line 33 of file RooLegacyExpPoly.h. Streamer(). void RooLegacyExpPoly::Streamer ; (; TBuffer &; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from RooAbsPdf. StreamerNVirtual(). void RooLegacyExpPoly::StreamerNVirtual ; (; TBuffer &; ClassDef_StreamerNVirtual_b). inline . Definition at line 57 of file RooLegacyExpPoly.h. x(). RooAbsReal const & RooLegacyExpPoly::x ; (; ); const. inline . Get the x variable. ; Definition at line 27 of file RooLegacyExpPoly.h.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooLegacyExpPoly.html:78981,log,log,78981,doc/master/classRooLegacyExpPoly.html,https://root.cern,https://root.cern/doc/master/classRooLegacyExpPoly.html,2,['log'],['log']
Testability,"l}; /// Number of warnings.; 56 std::atomic<long long> fNumErrors{0ll}; /// Number of errors.; 57 std::atomic<long long> fNumFatalErrors{0ll}; /// Number of fatal errors.; 58 ; 59public:; 60 /// Returns the current number of warnings.; 61 long long GetNumWarnings() const { return fNumWarnings; }; 62 ; 63 /// Returns the current number of errors.; 64 long long GetNumErrors() const { return fNumErrors; }; 65 ; 66 /// Returns the current number of fatal errors.; 67 long long GetNumFatalErrors() const { return fNumFatalErrors; }; 68 ; 69 /// Increase warning or error count.; 70 void Increment(ELogLevel severity); 71 {; 72 switch (severity) {; 73 case ELogLevel::kFatal: ++fNumFatalErrors; break;; 74 case ELogLevel::kError: ++fNumErrors; break;; 75 case ELogLevel::kWarning: ++fNumWarnings; break;; 76 default:;; 77 }; 78 }; 79};; 80 ; 81/**; 82 Abstract RLogHandler base class. ROOT logs everything from info to error; 83 to entities of this class.; 84 */; 85class RLogHandler {; 86public:; 87 virtual ~RLogHandler();; 88 /// Emit a log entry.; 89 /// \param entry - the RLogEntry to be emitted.; 90 /// \returns false if further emission of this Log should be suppressed.; 91 ///; 92 /// \note This function is called concurrently; log emission must be locked; 93 /// if needed. (The default log handler using ROOT's DefaultErrorHandler is locked.); 94 virtual bool Emit(const RLogEntry &entry) = 0;; 95};; 96 ; 97/**; 98 A log configuration for a channel, e.g. ""RHist"".; 99 Each ROOT module has its own log, with potentially distinct verbosity.; 100 */; 101class RLogChannel : public RLogDiagCount {; 102 /// Name as shown in diagnostics; 103 std::string fName;; 104 ; 105 /// Verbosity of this channel. By default, use the global verbosity.; 106 ELogLevel fVerbosity = ELogLevel::kUnset;; 107 ; 108public:; 109 /// Construct an anonymous channel.; 110 RLogChannel() = default;; 111 ; 112 /// Construct an anonymous channel with a default verbosity.; 113 explicit RLogChannel(ELogLevel verbosit",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RLogger_8hxx_source.html:2913,log,log,2913,doc/master/RLogger_8hxx_source.html,https://root.cern,https://root.cern/doc/master/RLogger_8hxx_source.html,1,['log'],['log']
Testability,"m EServType { kProofd; kXProofd; kProofLite; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TSignalHandler*fIntHandlerInterrupt signal handler (ctrl-c); TStringfMssUrlURL for the remote data pool, if any; TStringTNamed::fNameobject identifier; Int_tfRemoteProtocolProtocol number run by the daemon server; TProofMgr::EServTypefServTypeType of server: old-proofd, XrdProofd; TList*fSessionsPROOF session managed by this server; TStringTNamed::fTitleobject title; TUrlfUrlServer URL; static TListfgListOfManagersSub-list of TROOT::ListOfProofs for managers. private:. static TProofMgr_tfgTXProofMgrHookConstructor hooks for TXProofMgr. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TProofMgr(const char* url, Int_t loglevel = -1, const char* alias = """"); Create a PROOF manager for the standard (old) environment. ~TProofMgr(); Destroy a TProofMgr instance. TProof * AttachSession(Int_t , Bool_t = kFALSE); Dummy version provided for completeness. Just returns a pointer to; existing session 'id' (as shown by TProof::QuerySessions) or 0 if 'id' is; not valid. The boolena 'gui' should be kTRUE when invoked from the GUI. TProof * AttachSession(TProofDesc* , Bool_t = kFALSE); Dummy version provided for completeness. Just returns a pointer to; existing session 'id' (as shown by TProof::QuerySessions) or 0 if 'id' is; not valid. void DetachSession(Int_t , Option_t* = """"); Detach session with 'id' from its proofserv. The 'id' is the number; shown by QuerySessions. The correspondent TProof object is deleted.; If id == 0 all the known sessions are detached.; Option opt=""S"" or ""s"" forces session shutdown. void DetachSession(TProof* , Option_t* = """"); Detach session 'p' from its proofserv. The instance 'p' is invalidated; and shou",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TProofMgr.html:9029,log,loglevel,9029,root/html534/TProofMgr.html,https://root.cern,https://root.cern/root/html534/TProofMgr.html,1,['log'],['loglevel']
Testability,"m TObject; enum { ; kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ; kBitMask = 0x00ffffff. }; ; enum { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); }; ; enum EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); }; ; enum EStatusBits { ; kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ; kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). }; ; Protected Types inherited from TObject; enum { kOnlyPrepStep = (1ULL << ( 3 )); }; ; Protected Member Functions inherited from TMVA::FitterBase; MsgLogger &Log () const; message logger ; ; Protected Member Functions inherited from TMVA::Configurable; voidEnableLooseOptions (Bool_t b=kTRUE); ; const TString &GetReferenceFile () const; ; Bool_tLooseOptionCheckingEnabled () const; ; voidResetSetFlag (); resets the IsSet flag for all declare options to be called before options are read from stream ; ; voidWriteOptionsReferenceToFile (); write complete options to output stream ; ; Protected Member Functions inherited from TObject; virtual voidDoError (int level, const char *location, const char *fmt, va_list va) const; Interface to ErrorHandler (protected). ; ; voidMakeZombie (); . #include <TMVA/MinuitFitter.h>. Inheritance diagram for TMVA::MinuitFitter:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. MinuitFitter(). TMVA::MinuitFitter::MinuitFitter ; (; IFitterTarget &; target, . const TString &; name, . std::vector< TMVA::Interval * > &; ranges, . const TString &; theOption. ). constructor ; Definition at line 47 of file MinuitFitter.cxx. ~MinuitFitter(). TMVA::MinuitFitter::~MinuitFitter ; (; ). virtual . destructor ; Definition at line 64 of fi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1MinuitFitter.html:15775,log,logger,15775,doc/master/classTMVA_1_1MinuitFitter.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1MinuitFitter.html,1,['log'],['logger']
Testability,"m TObject; enum { ; kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ; kBitMask = 0x00ffffff. }; ; enum { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); }; ; enum EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); }; ; enum EStatusBits { ; kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ; kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). }; ; Protected Types inherited from TObject; enum { kOnlyPrepStep = (1ULL << ( 3 )); }; ; Protected Member Functions inherited from TMVA::FitterBase; MsgLogger &Log () const; message logger ; ; Protected Member Functions inherited from TMVA::Configurable; voidEnableLooseOptions (Bool_t b=kTRUE); ; const TString &GetReferenceFile () const; ; Bool_tLooseOptionCheckingEnabled () const; ; voidResetSetFlag (); resets the IsSet flag for all declare options to be called before options are read from stream ; ; voidWriteOptionsReferenceToFile (); write complete options to output stream ; ; Protected Member Functions inherited from TObject; virtual voidDoError (int level, const char *location, const char *fmt, va_list va) const; Interface to ErrorHandler (protected). ; ; voidMakeZombie (); ; Protected Attributes inherited from TMVA::FitterBase; TStringfClassName; ; bool *fExitFromTraining = nullptr; ; IFitterTarget &fFitterTarget; ; UInt_t *fIPyCurrentIter = nullptr; ; UInt_t *fIPyMaxIter = nullptr; ; MsgLogger *fLogger; ; Int_tfNpars; ; const std::vector< TMVA::Interval * >fRanges; ; Protected Attributes inherited from TMVA::Configurable; MsgLogger *fLogger; ! message logger ; ; Protected Attributes inherited from TNamed; TStringfName; ; TStringfTitle; . #include <TMVA/GeneticFitter.h>. Inheritance diagram for TMVA::GeneticFitter",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1GeneticFitter.html:15668,log,logger,15668,doc/master/classTMVA_1_1GeneticFitter.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1GeneticFitter.html,1,['log'],['logger']
Testability,"m TObject; enum { ; kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ; kBitMask = 0x00ffffff. }; ; enum { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); }; ; enum EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); }; ; enum EStatusBits { ; kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ; kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). }; ; Protected Types inherited from TObject; enum { kOnlyPrepStep = (1ULL << ( 3 )); }; ; Protected Member Functions inherited from TMVA::FitterBase; MsgLogger &Log () const; message logger ; ; Protected Member Functions inherited from TMVA::Configurable; voidEnableLooseOptions (Bool_t b=kTRUE); ; const TString &GetReferenceFile () const; ; Bool_tLooseOptionCheckingEnabled () const; ; voidResetSetFlag (); resets the IsSet flag for all declare options to be called before options are read from stream ; ; voidWriteOptionsReferenceToFile (); write complete options to output stream ; ; Protected Member Functions inherited from TObject; virtual voidDoError (int level, const char *location, const char *fmt, va_list va) const; Interface to ErrorHandler (protected). ; ; voidMakeZombie (); ; Protected Attributes inherited from TMVA::FitterBase; TStringfClassName; ; bool *fExitFromTraining = nullptr; ; IFitterTarget &fFitterTarget; ; UInt_t *fIPyCurrentIter = nullptr; ; UInt_t *fIPyMaxIter = nullptr; ; MsgLogger *fLogger; ; Int_tfNpars; ; const std::vector< TMVA::Interval * >fRanges; ; Protected Attributes inherited from TMVA::Configurable; MsgLogger *fLogger; ! message logger ; ; Protected Attributes inherited from TNamed; TStringfName; ; TStringfTitle; . #include <TMVA/MCFitter.h>. Inheritance diagram for TMVA::MCFitter:. This br",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1MCFitter.html:14454,log,logger,14454,doc/master/classTMVA_1_1MCFitter.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1MCFitter.html,1,['log'],['logger']
Testability,"m TObject; enum { ; kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ; kBitMask = 0x00ffffff. }; ; enum { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); }; ; enum EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); }; ; enum EStatusBits { ; kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ; kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). }; ; Protected Types inherited from TObject; enum { kOnlyPrepStep = (1ULL << ( 3 )); }; ; Protected Member Functions inherited from TMVA::FitterBase; MsgLogger &Log () const; message logger ; ; Protected Member Functions inherited from TMVA::Configurable; voidEnableLooseOptions (Bool_t b=kTRUE); ; const TString &GetReferenceFile () const; ; Bool_tLooseOptionCheckingEnabled () const; ; voidResetSetFlag (); resets the IsSet flag for all declare options to be called before options are read from stream ; ; voidWriteOptionsReferenceToFile (); write complete options to output stream ; ; Protected Member Functions inherited from TObject; virtual voidDoError (int level, const char *location, const char *fmt, va_list va) const; Interface to ErrorHandler (protected). ; ; voidMakeZombie (); ; Protected Attributes inherited from TMVA::FitterBase; TStringfClassName; ; bool *fExitFromTraining = nullptr; ; IFitterTarget &fFitterTarget; ; UInt_t *fIPyCurrentIter = nullptr; ; UInt_t *fIPyMaxIter = nullptr; ; MsgLogger *fLogger; ; Int_tfNpars; ; const std::vector< TMVA::Interval * >fRanges; ; Protected Attributes inherited from TMVA::Configurable; MsgLogger *fLogger; ! message logger ; ; Protected Attributes inherited from TNamed; TStringfName; ; TStringfTitle; . #include <TMVA/SimulatedAnnealingFitter.h>. Inheritance diagram for TMVA::Si",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1SimulatedAnnealingFitter.html:15373,log,logger,15373,doc/master/classTMVA_1_1SimulatedAnnealingFitter.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1SimulatedAnnealingFitter.html,1,['log'],['logger']
Testability,"m element. ; If more than one element is minimum returns first found. ; Definition at line 1000 of file TMath.h. LocMin() [2/2]. template<typename T > . Long64_t TMath::LocMin ; (; Long64_t; n, . const T *; a. ). Returns index of array with the minimum element. ; If more than one element is minimum returns first found.; Implement here since this one is found to be faster (mainly on 64 bit machines) than stl generic implementation. When performing the comparison, the STL implementation needs to de-reference both the array iterator and the iterator pointing to the resulting minimum location ; Definition at line 982 of file TMath.h. Log(). Double_t TMath::Log ; (; Double_t; x). inline . Returns the natural logarithm of x. ; Definition at line 756 of file TMath.h. Log10(). Double_t TMath::Log10 ; (; Double_t; x). inline . Returns the common (base-10) logarithm of x. ; Definition at line 762 of file TMath.h. Log2(). Double_t TMath::Log2 ; (; Double_t; x). Returns the binary (base-2) logarithm of x. ; Definition at line 107 of file TMath.cxx. LogE(). constexpr Double_t TMath::LogE ; (; ). constexpr . Base-10 log of e (to convert ln to log) ; Definition at line 107 of file TMath.h. LogNormal(). Double_t TMath::LogNormal ; (; Double_t; x, . Double_t; sigma, . Double_t; theta = 0, . Double_t; m = 1. ). Computes the density of LogNormal distribution at point x. ; Variable X has lognormal distribution if Y=Ln(X) has normal distribution; Parameters. [in]xis the evaluation point ; [in]sigmais the shape parameter ; [in]thetais the location parameter ; [in]mis the scale parameter. The formula was taken from ""Engineering Statistics Handbook"" on site http://www.itl.nist.gov/div898/handbook/eda/section3/eda3669.htm Implementation using ROOT::Math::lognormal_pdf. Definition at line 2437 of file TMath.cxx. Max() [1/10]. Double_t TMath::Max ; (; Double_t; a, . Double_t; b. ). inline . Returns the largest of a and b. ; If both are equivalent, a is returned. aa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/namespaceTMath.html:60532,log,logarithm,60532,doc/master/namespaceTMath.html,https://root.cern,https://root.cern/doc/master/namespaceTMath.html,1,['log'],['logarithm']
Testability,"m previous sessions; TProofOutputListfOutputListTList implementation filtering ls(...) and Print(...); TStringfPackageDirpackage directory (used on client); TProofLockPath*fPackageLockpackage lock; TStringfPerfTreeIf non-null triggers saving of the performance info into fPerfTree; TVirtualProofPlayer*fPlayercurrent player; PrintProgress_tfPrintProgressFunction function to display progress info in batch mode; TPluginHandler*fProgressDialogprogress dialog plugin; Bool_tfProgressDialogStartedindicates if the progress dialog is up; TList*fQuerieslist of TProofQuery objects; Float_tfRealTimerealtime spent by all slaves during the session; TList*fRecvMessagesMessages received during collect not yet processed; Bool_tfRedirLogredirect received log info; Int_tfRedirectNext; TProof::ERunStatusfRunStatusrun status; Bool_tfSaveLogToMacroWhether to save received logs to TMacro fMacroLog (use with care); Bool_tfSendGroupViewif true send new group view; Int_tfSeqNumRemote sequential # of the last query submitted; Int_tfSessionIDremote ID of the session; TList*fSlaveInfo!list returned by kPROOF_GETSLAVEINFO; Int_tfStatusremote return status (part of kPROOF_LOGDONE); Bool_tfSynctrue if type of currently processed query is sync; Bool_tfTtyTRUE if connected to a terminal; TMonitor*fUniqueMonitormonitor activity on all unique slave sockets; TList*fUniqueSlaveslist of all active slaves with unique file systems; Bool_tfValidis this a valid proof object; TList*fWaitingSlavesstores a TPair of the slaves's TSocket and TMessage; TStringfWorkDircurrent work directory on remote servers; Int_tfWorkersToMergeCurrent total number of workers, which have not been yet assigned to any merger; TList*fWrksOutputReadyList of workers ready to send output (in control output sending mode); static TPluginHandler*fgLogViewerLog dialog box plugin; static TList*fgProofEnvListList of TNameds defining environment. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TProof(c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TProof.html:33752,log,log,33752,root/html534/TProof.html,https://root.cern,https://root.cern/root/html534/TProof.html,2,['log'],"['log', 'logs']"
Testability,"m requirement; Double_t**fCutMinminimum requirement; vector<Interval*>fCutRangeallowed ranges for cut optimisation; Double_t*fCutRangeMaxmaximum of allowed cut range; Double_t*fCutRangeMinminimum of allowed cut range; TH1*fEffBvsSLocalintermediate eff. background versus eff signal histo; TMVA::MethodCuts::EEffMethodfEffMethodchosen efficiency calculation method; TStringfEffMethodSchosen efficiency calculation method (string); Double_tfEffRefreference efficiency; Double_tfEffSMaxused to test optimized signal efficiency; Double_tfEffSMinused to test optimized signal efficiency; TMVA::MethodCuts::EFitMethodTypefFitMethodchosen fit method; TStringfFitMethodSchosen fit method (string); vector<EFitParameters>*fFitParamsvector for series of fit methods; vector<Double_t>*fMeanBmeans of variables (background); vector<Double_t>*fMeanSmeans of variables (signal); Bool_tfNegEffWarningflag risen in case of negative efficiency warning; Int_tfNparnumber of parameters in fit (default: 2*Nvar); TRandom*fRandomrandom generator for MC optimisation method; vector<Int_t>*fRangeSignused to match cuts to fit parameters (and vice versa); vector<Double_t>*fRmsBRMSs of variables (background); vector<Double_t>*fRmsSRMSs of variables (signal); Double_tfTestSignalEffused to test optimized signal efficiency; Double_t*fTmpCutMaxtemporary maximum requirement; Double_t*fTmpCutMintemporary minimum requirement; vector<TH1*>*fVarHistBreference histograms (background); vector<TH1*>*fVarHistB_smoothsmoothed reference histograms (background); vector<TH1*>*fVarHistSreference histograms (signal); vector<TH1*>*fVarHistS_smoothsmoothed reference histograms (signal) ; vector<PDF*>*fVarPdfBreference PDFs (background); vector<PDF*>*fVarPdfSreference PDFs (signal). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; MethodCuts(const TString& jobName, const TString& methodTitle, TMVA::DataSetInfo& theData, const TString& theOption = ""MC:150:10000:"", TDirectory* theTargetFile",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMVA__MethodCuts.html:19085,test,test,19085,root/html528/TMVA__MethodCuts.html,https://root.cern,https://root.cern/root/html528/TMVA__MethodCuts.html,12,['test'],['test']
Testability,"m to send back a; message with the output of its TObject::Print(). Returns -1 on error, the; number of workers that received the objects on success. Int_t Echo(const char* str); Sends a string to master and workers and expect them to echo it back to; the client via a message. It is a special case of the generic Echo(); that works with TObjects. Returns -1 on error, the number of workers that; received the message on success. Int_t SendObject(const TObject* obj, TProof::ESlaves list = kActive); Send object to master or slave servers. Returns number of slaves object; was sent to, -1 in case of error. Int_t SendPrint(Option_t* option = """"); Send print command to master server. Returns number of slaves message; was sent to. Returns -1 in case of error. void SetLogLevel(Int_t level, UInt_t mask = TProofDebug::kAll); Set server logging level. void SetRealTimeLog(Bool_t on = kTRUE); Switch ON/OFF the real-time logging facility. When this option is; ON, log messages from processing are sent back as they come, instead of; being sent back at the end in one go. This may help debugging or monitoring; in some cases, but, depending on the amount of log, it may have significant; consequencies on the load over the network, so it must be used with care. Int_t SetParallelSilent(Int_t nodes, Bool_t random = kFALSE); Tell PROOF how many slaves to use in parallel. If random is TRUE a random; selection is done (if nodes is less than the available nodes).; Returns the number of parallel slaves. Returns -1 in case of error. Int_t SetParallel(Int_t nodes = -1, Bool_t random = kFALSE); Tell PROOF how many slaves to use in parallel. Returns the number of; parallel slaves. Returns -1 in case of error. Int_t GoMoreParallel(Int_t nWorkersToAdd); Add nWorkersToAdd workers to current list of workers. This function is; works on the master only, and only when an analysis is ongoing. A message; is sent back to the client when we go ""more"" parallel.; Returns -1 on error, number of total (not added!) w",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TProof.html:67215,log,log,67215,root/html534/TProof.html,https://root.cern,https://root.cern/root/html534/TProof.html,3,['log'],['log']
Testability,"m with 217 events; 1977/// and the weighted histogram with 500 events:; 1978/// 1. unweighted histogram;; 1979/// 2. weighted histogram;; 1980/// 3. normalized residuals plot;; 1981/// 4. normal Q-Q plot of residuals.; 1982///; 1983/// The value of the test statistic \f$ \chi^{2} \f$ is equal to; 1984/// 32.33 with p-value equal to 0.029, therefore the hypothesis of identity of; 1985/// the two histograms is rejected for 0.05 significant level. The behavior of; 1986/// the normalized residuals plot (see Fig. 2c) and the normal Q-Q plot (see; 1987/// Fig. 2d) of residuals are not regular and we can identify the outlier or; 1988/// bin with a big influence on \f$ \chi^{2} \f$.; 1989///; 1990/// #### References:; 1991///; 1992/// - [1] Pearson, K., 1904. On the Theory of Contingency and Its Relation to; 1993/// Association and Normal Correlation. Drapers' Co. Memoirs, Biometric; 1994/// Series No. 1, London.; 1995/// - [2] Gagunashvili, N., 2006. \f$ \sigma^{2} \f$ test for comparison; 1996/// of weighted and unweighted histograms. Statistical Problems in Particle; 1997/// Physics, Astrophysics and Cosmology, Proceedings of PHYSTAT05,; 1998/// Oxford, UK, 12-15 September 2005, Imperial College Press, London, 43-44.; 1999/// Gagunashvili,N., Comparison of weighted and unweighted histograms,; 2000/// arXiv:physics/0605123, 2006.; 2001/// - [3] Cramer, H., 1946. Mathematical methods of statistics.; 2002/// Princeton University Press, Princeton.; 2003/// - [4] Haberman, S.J., 1973. The analysis of residuals in cross-classified tables.; 2004/// Biometrics 29, 205-220.; 2005/// - [5] Lewontin, R.C. and Felsenstein, J., 1965. The robustness of homogeneity; 2006/// test in 2xN tables. Biometrics 21, 19-33.; 2007/// - [6] Seber, G.A.F., Lee, A.J., 2003, Linear Regression Analysis.; 2008/// John Wiley & Sons Inc., New York.; 2009 ; 2010Double_t TH1::Chi2Test(const TH1* h2, Option_t *option, Double_t *res) const; 2011{; 2012 Double_t chi2 = 0;; 2013 Int_t ndf = 0, igood = 0;; 2014",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TH1_8cxx_source.html:81336,test,test,81336,doc/master/TH1_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html,1,['test'],['test']
Testability,"m with given unique ID code. ; ; Int_terrorCount () const; ; StreamConfig &getStream (Int_t id); ; boolgetStreamStatus (Int_t id) const; Get activation status of stream with given unique ID. ; ; RooFit::MsgLevelglobalKillBelow () const; ; TClass *IsA () const override; ; template<class T > ; boolisActive (T self, RooFit::MsgTopic topic, RooFit::MsgLevel level); Check if logging is active for given object/topic/RooFit::MsgLevel combination. ; ; std::ostream &log (const RooAbsArg *self, RooFit::MsgLevel level, RooFit::MsgTopic facility, bool forceSkipPrefix=false); Log error message associated with RooAbsArg object self at given level and topic. ; ; std::ostream &log (const TObject *self, RooFit::MsgLevel level, RooFit::MsgTopic facility, bool forceSkipPrefix=false); Log error message associated with TObject object self at given level and topic. ; ; std::ostream &log (std::nullptr_t, RooFit::MsgLevel level, RooFit::MsgTopic facility, bool forceSkipPrefix=false); ; Int_tnumStreams () const; ; voidPrint (Option_t *options=nullptr) const override; Print configuration of message service. ; ; voidreset (); ; voidrestoreState (); Restore last saved state of message service. ; ; voidsaveState (); Save current state of message service. ; ; voidsetGlobalKillBelow (RooFit::MsgLevel level); ; voidsetSilentMode (bool flag); ; voidsetStreamStatus (Int_t id, bool active); (De)Activate stream with given unique ID ; ; voidshowPid (bool flag); ; boolsilentMode () const; ; voidStreamer (TBuffer &) override; Stream an object of class TObject. ; ; voidStreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b); ; Public Member Functions inherited from TObject; TObject (); TObject constructor. ; ; TObject (const TObject &object); TObject copy ctor. ; ; virtual~TObject (); TObject destructor. ; ; voidAbstractMethod (const char *method) const; Use this method to implement an ""abstract"" method that you don't want to leave purely abs",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooMsgService.html:3899,log,log,3899,doc/master/classRooMsgService.html,https://root.cern,https://root.cern/doc/master/classRooMsgService.html,1,['log'],['log']
Testability,"m);; TVectorD sig = svd.GetSig(); sig.Sqr();; // Symmetric matrix EigenVector algorithm; TMatrixDSym mtm(TMatrixDBase::kAtA,m);; const TMatrixDSymEigen eigen(mtm);; const TVectorD eigenVal = eigen.GetEigenValues();; const Bool_t ok = VerifyVectorIdentity(sig,eigenVal,1,1.-e-14);; 14.8 Speed Comparisons; Speed of four matrix operations have been compared between four matrix libraries, GSL CLHEP, ROOT v3.10 and ROOT v4.0. Next figure shows the CPU time for these four operations as a function of the matrix size:. A*B The execution time is measured for the sum of A * Bsym, Bsym* A and A * B. Notice the matrix_size3 dependence of execution time. CLHEP results are hampered by a poor implementation of symmetric matrix multiplications. For instance, for general matrices of size 100x100, the time is 0.015 sec.while A * Bsym takes 0.028 sec and Bsym* A takes 0.059 sec. Both GSL and ROOT v4.0 can be setup to use the hardware-optimized multiplication routines of the BLAS libraries. It was tested on a G4 PowerPC. The improvement becomes clearly visible around sizes of (50x50) were the execution speed improvement of the Altivec processor becomes more significant than the overhead of filling its pipe. \(A^{-1}\) Here, the time is measured for an in-place matrix inversion. Except for ROOT v3.10, the algorithms are all based on an LUfactorization followed by forward/back-substitution. ROOT v3.10 is using the slower Gaussian elimination method. The numerical accuracy of the CLHEP routine is poor:. up to 6x6 the numerical imprecise Cramer multiplication is hard-coded. For instance, calculating U=H*H-1, where H is a (5x5) Hilbert matrix, results in off-diagonal elements of \(10^{-7}\) instead of the \(10^{-13}\) using an LUaccording to Crout.; scaling protection is non-existent and limits are hard-coded, as a consequence inversion of a Hilbert matrix for sizes>(12x12) fails. In order to gain speed the CLHEP algorithm stores its permutation info of the pivots points in a static array, m",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:802242,test,tested,802242,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['test'],['tested']
Testability,"m.SetParName(i, fnorm_exp_cb.GetParName(i)); ; # GENERATE HISTOGRAM TO FIT ..............................................................; w = ROOT.TStopwatch(); w.Start(); h_sum = ROOT.TH1D(""h_ExpCB"", ""Exponential Bkg + CrystalBall function"", nBins, -5.0, 5.0); h_sum.FillRandom(""fsum"", nEvents); print(""Time to generate {0} events: "".format(nEvents)); w.Print(); ; # need to scale histogram with width since we are fitting a density; h_sum.Sumw2(); h_sum.Scale(1.0, ""width""); ; # fit - use Minuit2 if available; ROOT.Math.MinimizerOptions.SetDefaultMinimizer(""Minuit2""); c1 = ROOT.TCanvas(""Fit"", ""Fit"", 800, 1000); # do a least-square fit of the spectrum; result = h_sum.Fit(""fsum"", ""SQ""); result.Print(); h_sum.Draw(); print(""Time to fit using ROOT TF1Normsum: ""); w.Print(); ; # test if parameters are fine; for i, pref in enumerate([nsig, nbkg, signal_mean]):; if not ROOT.TMath.AreEqualAbs(pref, f_sum.GetParameter(i), f_sum.GetParError(i) * 10.0):; ROOT.Error(; ""testFitNormSum"",; ""Difference found in fitted {0} - difference is {1:.2f} sigma"".format(; f_sum.GetParName(i), (f_sum.GetParameter(i) - pref) / f_sum.GetParError(i); ),; ); ; ROOT.gStyle.SetOptStat(0); # add parameters; t1 = ROOT.TLatex(-2.5, 300000, ""NSignal = {0:g} #pm {1:g}"".format(f_sum.GetParameter(0), f_sum.GetParError(0))); t2 = ROOT.TLatex(-2.5, 270000, ""Nbackgr = {0:g} #pm {1:g}"".format(f_sum.GetParameter(1), f_sum.GetParError(1))); t1.Draw(); t2.Draw(); ; c1.SaveAs(""fitNormSum.png""); formatOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid window const char font_name cursor keysym reg const char only_if_exist regb h Point_t winding char text const ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/fitNormSum_8py.html:3434,test,testFitNormSum,3434,doc/master/fitNormSum_8py.html,https://root.cern,https://root.cern/doc/master/fitNormSum_8py.html,1,['test'],['testFitNormSum']
Testability,"m.rootlogon.C, the global; 335/// user logon ~/.rootlogon.C and the local ./.rootlogon.C. For backward; 336/// compatibility also the logon macro as specified by the Rint.Logon; 337/// environment setting, by default ./rootlogon.C, will be executed.; 338/// No logon macros will be executed when the system is started with; 339/// the -n option.; 340 ; 341void TRint::ExecLogon(); 342{; 343 if (NoLogOpt()) return;; 344 ; 345 TString name = "".rootlogon.C"";; 346 TString sname = ""system"";; 347 sname += name;; 348 char *s = gSystem->ConcatFileName(TROOT::GetEtcDir(), sname);; 349 if (!gSystem->AccessPathName(s, kReadPermission)) {; 350 ProcessFile(s);; 351 }; 352 delete [] s;; 353 s = gSystem->ConcatFileName(gSystem->HomeDirectory(), name);; 354 if (!gSystem->AccessPathName(s, kReadPermission)) {; 355 ProcessFile(s);; 356 }; 357 delete [] s;; 358 // avoid executing ~/.rootlogon.C twice; 359 if (strcmp(gSystem->HomeDirectory(), gSystem->WorkingDirectory())) {; 360 if (!gSystem->AccessPathName(name, kReadPermission)); 361 ProcessFile(name);; 362 }; 363 ; 364 // execute also the logon macro specified by ""Rint.Logon""; 365 const char *logon = gEnv->GetValue(""Rint.Logon"", (char*)nullptr);; 366 if (logon) {; 367 char *mac = gSystem->Which(TROOT::GetMacroPath(), logon, kReadPermission);; 368 if (mac); 369 ProcessFile(logon);; 370 delete [] mac;; 371 }; 372}; 373 ; 374////////////////////////////////////////////////////////////////////////////////; 375/// Main application eventloop. First process files given on the command; 376/// line and then go into the main application event loop, unless the -q; 377/// command line option was specified in which case the program terminates.; 378/// When return is true this method returns even when -q was specified.; 379///; 380/// When QuitOpt is true and return is false, terminate the application with; 381/// an error code equal to either the ProcessLine error (if any) or the; 382/// return value of the command casted to a long.; 383 ; 384void T",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TRint_8cxx_source.html:12589,log,logon,12589,doc/master/TRint_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TRint_8cxx_source.html,1,['log'],['logon']
Testability,"m2 *= kBiginv;; 745 qkm1 *= kBiginv;; 746 }; 747 if( (std::abs(qk) < kBiginv) || (std::abs(pk) < kBiginv) ); 748 {; 749 pkm2 *= kBig;; 750 pkm1 *= kBig;; 751 qkm2 *= kBig;; 752 qkm1 *= kBig;; 753 }; 754 }; 755 while( ++n < 300 );; 756cdone:; 757 return(ans);; 758}; 759 ; 760 ; 761/*---------------------------------------------------------------------------*/; 762 ; 763/* Power series for incomplete beta integral.; 764 Use when b*x is small and x not too close to 1. */; 765 ; 766double pseries( double a, double b, double x ); 767{; 768 double s, t, u, v, n, t1, z, ai;; 769 ; 770 ai = 1.0 / a;; 771 u = (1.0 - b) * x;; 772 v = u / (a + 1.0);; 773 t1 = v;; 774 t = u;; 775 n = 2.0;; 776 s = 0.0;; 777 z = kMACHEP * ai;; 778 while( std::abs(v) > z ); 779 {; 780 u = (n - b) * x / n;; 781 t *= u;; 782 v = t / (a + n);; 783 s += v;; 784 n += 1.0;; 785 }; 786 s += t1;; 787 s += ai;; 788 ; 789 u = a * log(x);; 790 if( (a+b) < kMAXSTIR && std::abs(u) < kMAXLOG ); 791 {; 792 t = gamma(a+b)/(gamma(a)*gamma(b));; 793 s = s * t * pow(x,a);; 794 }; 795 else; 796 {; 797 t = lgam(a+b) - lgam(a) - lgam(b) + u + std::log(s);; 798 if( t < kMINLOG ); 799 s = 0.0;; 800 else; 801 s = std::exp(t);; 802 }; 803 return(s);; 804}; 805 ; 806/*---------------------------------------------------------------------------*/; 807 ; 808 ; 809/*---------------------------------------------------------------------------*/; 810/* for evaluation of error function */; 811/*---------------------------------------------------------------------------*/; 812 ; 813static double erfP[] = {; 814 2.46196981473530512524E-10,; 815 5.64189564831068821977E-1,; 816 7.46321056442269912687E0,; 817 4.86371970985681366614E1,; 818 1.96520832956077098242E2,; 819 5.26445194995477358631E2,; 820 9.34528527171957607540E2,; 821 1.02755188689515710272E3,; 822 5.57535335369399327526E2; 823};; 824static double erfQ[] = {; 825/* 1.00000000000000000000E0,*/; 826 1.32281951154744992508E1,; 827 8.67072140885989742329E1,; 828 3.5493777888781",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/SpecFuncCephes_8cxx_source.html:17089,log,log,17089,doc/master/SpecFuncCephes_8cxx_source.html,https://root.cern,https://root.cern/doc/master/SpecFuncCephes_8cxx_source.html,2,['log'],['log']
Testability,"mDescription::IsPrincipalEndNode(int nodeid); 1395{; 1396 TLockGuard lock(fMutex);; 1397 ; 1398 if ((nodeid < 0) || (nodeid >= (int)fDesc.size())); 1399 return false;; 1400 ; 1401 auto &desc = fDesc[nodeid];; 1402 ; 1403 return (desc.sortid < fDrawIdCut) && desc.IsVisible() && desc.CanDisplay() && (desc.chlds.empty());; 1404}; 1405 ; 1406/////////////////////////////////////////////////////////////////////; 1407/// Search visible nodes for provided name; 1408/// If number of found elements less than 100, create description and shapes for them; 1409/// Returns number of match elements; 1410 ; 1411int RGeomDescription::SearchVisibles(const std::string &find, std::string &hjson, std::string &json); 1412{; 1413 TLockGuard lock(fMutex);; 1414 ; 1415 hjson.clear();; 1416 json.clear();; 1417 ; 1418 if (find.empty()) {; 1419 hjson = ""FOUND:RESET"";; 1420 return 0;; 1421 }; 1422 ; 1423 std::vector<int> nodescnt(fDesc.size(), 0), viscnt(fDesc.size(), 0);; 1424 ; 1425 int nmatches = 0;; 1426 std::string test = find;; 1427 int kind = 0;; 1428 if (test.compare(0, 2, ""c:"") == 0) {; 1429 test.erase(0, 2);; 1430 kind = 1;; 1431 } else if (test.compare(0, 2, ""m:"") == 0) {; 1432 test.erase(0, 2);; 1433 kind = 2;; 1434 }; 1435 ; 1436 TRegexp regexp(test.c_str());; 1437 ; 1438 auto match_func = [&regexp, kind](RGeomNode &node) {; 1439 return (node.vol > 0) && (TString(node.GetArg(kind)).Index(regexp) >= 0);; 1440 };; 1441 ; 1442 // first count how many times each individual node appears; 1443 ScanNodes(false, 0,; 1444 [&nodescnt, &viscnt, &match_func, &nmatches](RGeomNode &node, std::vector<int> &, bool is_vis, int) {; 1445 if (match_func(node)) {; 1446 nmatches++;; 1447 nodescnt[node.id]++;; 1448 if (is_vis); 1449 viscnt[node.id]++;; 1450 };; 1451 return true;; 1452 });; 1453 ; 1454 // do not send too much data, limit could be made configurable later; 1455 if (nmatches == 0) {; 1456 hjson = ""FOUND:NO"";; 1457 return nmatches;; 1458 }; 1459 ; 1460 if ((GetMaxVisNodes() > 0) && (nmatches >",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RGeomData_8cxx_source.html:43261,test,test,43261,doc/master/RGeomData_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RGeomData_8cxx_source.html,4,['test'],['test']
Testability,"mIntCatVars() const; const RooArgSet&numIntRealVars() const; Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TNamed&TNamed::operator=(const TNamed& rhs); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg(), const RooCmdArg& arg9 = RooCmdArg(), const RooCmdArg& arg10 = RooCmdArg()) const; virtual list<Double_t>*plotSamplingHint(RooAbsRealLValue& obs, Double_t xlo, Double_t xhi) const; virtual RooPlot*RooAbsReal::plotSliceOn(RooPlot* frame, const RooArgSet& sliceSet, Option_t* drawOptions = ""L"", Double_t scaleFactor = 1.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooRealIntegral.html:18328,test,testArg,18328,root/html530/RooRealIntegral.html,https://root.cern,https://root.cern/root/html530/RooRealIntegral.html,2,['test'],['testArg']
Testability,"mStatus(). bool RooMsgService::getStreamStatus ; (; Int_t; id); const. Get activation status of stream with given unique ID. ; Definition at line 331 of file RooMsgService.cxx. globalKillBelow(). RooFit::MsgLevel RooMsgService::globalKillBelow ; (; ); const. inline . Definition at line 170 of file RooMsgService.h. instance(). RooMsgService & RooMsgService::instance ; (; ). static . Return reference to singleton instance. ; Definition at line 345 of file RooMsgService.cxx. IsA(). TClass * RooMsgService::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TObject.; Definition at line 246 of file RooMsgService.h. isActive(). template<class T > . bool RooMsgService::isActive ; (; T; self, . RooFit::MsgTopic; topic, . RooFit::MsgLevel; level. ). inline . Check if logging is active for given object/topic/RooFit::MsgLevel combination. ; Definition at line 186 of file RooMsgService.h. log() [1/3]. ostream & RooMsgService::log ; (; const RooAbsArg *; self, . RooFit::MsgLevel; level, . RooFit::MsgTopic; topic, . bool; skipPrefix = false. ). Log error message associated with RooAbsArg object self at given level and topic. ; If skipPrefix is true the standard RooMsgService prefix is not added. ; Definition at line 419 of file RooMsgService.cxx. log() [2/3]. ostream & RooMsgService::log ; (; const TObject *; self, . RooFit::MsgLevel; level, . RooFit::MsgTopic; topic, . bool; skipPrefix = false. ). Log error message associated with TObject object self at given level and topic. ; If skipPrefix is true the standard RooMsgService prefix is not added. ; Definition at line 456 of file RooMsgService.cxx. log() [3/3]. std::ostream & RooMsgService::log ; (; std::nullptr_t; , . RooFit::MsgLevel; level, . RooFit::MsgTopic; facility, . bool; forceSkipPrefix = false. ). inline . Definition at line 180 of file RooMsgService.h. numStreams(). Int_t RooMsgService::numStreams ; (; ); const. inline . Definition",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooMsgService.html:19936,log,log,19936,doc/master/classRooMsgService.html,https://root.cern,https://root.cern/doc/master/classRooMsgService.html,1,['log'],['log']
Testability,"mTH1F * fHistogramPointer to histogram used for drawing axis.Definition TGraph.h:50; TGraph::Paintvoid Paint(Option_t *chopt="""") overrideDraw this graph with its current attributes.Definition TGraph.cxx:1977; TGraph::EStatusBitsEStatusBitsDefinition TGraph.h:74; TGraph::kNotEditable@ kNotEditableBit set if graph is non editable.Definition TGraph.h:78; TGraph::kIsHighlight@ kIsHighlightBit set if graph is highlight.Definition TGraph.h:80; TGraph::kIsSortedX@ kIsSortedXGraph is sorted in X points.Definition TGraph.h:79; TGraph::kClipFrame@ kClipFrameClip to the frame boundary.Definition TGraph.h:76; TGraph::kResetHisto@ kResetHistofHistogram must be reset in GetHistogramDefinition TGraph.h:77; TGraph::kNoStats@ kNoStatsDon't draw stats box.Definition TGraph.h:75; TGraph::GetErrorXlowvirtual Double_t GetErrorXlow(Int_t bin) constIt always returns a negative value.Definition TGraph.cxx:1387; TGraph::MovePointsvirtual void MovePoints(Double_t dx, Double_t dy, Bool_t logx=kFALSE, Bool_t logy=kFALSE)Move all graph points on specified values dx,dy If log argument specified, calculation done in logari...Definition TGraph.cxx:2691; TGraph::GetErrorYlowvirtual Double_t GetErrorYlow(Int_t bin) constIt always returns a negative value.Definition TGraph.cxx:1405; TGraph::UpdateArraysvirtual void UpdateArrays(const std::vector< Int_t > &sorting_indices, Int_t numSortedPoints, Int_t low)Update the fX and fY arrays with the sorted values.Definition TGraph.cxx:2592; TGraph::CopyAndReleasevirtual void CopyAndRelease(Double_t **newarrays, Int_t ibegin, Int_t iend, Int_t obegin)Copy points from fX and fY to arrays[0] and arrays[1] or to fX and fY if arrays == 0 and ibegin !...Definition TGraph.cxx:762; TGraph::GetMinimumDouble_t GetMinimum() constDefinition TGraph.h:152; TGraph::Printvoid Print(Option_t *chopt="""") const overridePrint graph values.Definition TGraph.cxx:2013; TGraph::GetEYlowvirtual Double_t * GetEYlow() constDefinition TGraph.h:146; TGraph::SetMaximumvirtual void SetMaximu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGraph_8h_source.html:17402,log,logx,17402,doc/master/TGraph_8h_source.html,https://root.cern,https://root.cern/doc/master/TGraph_8h_source.html,4,['log'],"['log', 'logari', 'logx', 'logy']"
Testability,"mThreads-1; ++idxThread); 796 {; 797 batches.push_back (Batch (itPat, itPat + patternPerThread));; 798 itPat += patternPerThread;; 799 }; 800 if (itPat != testPattern.end ()); 801 batches.push_back (Batch (itPat, testPattern.end ()));; 802 ; 803 std::vector<std::future<std::tuple<double,std::vector<double>>>> futures;; 804 for (auto& batch : batches); 805 {; 806 // -------------------- execute each of the batch ranges on a different thread -------------------------------; 807 futures.push_back (; 808 std::async (std::launch::async, [&](); 809 {; 810 std::vector<double> localOutput;; 811 pass_through_type passThrough (settings, batch, dropContainerTest);; 812 double testBatchError = (*this) (passThrough, weights, ModeOutput::FETCH, localOutput);; 813 return std::make_tuple (testBatchError, localOutput);; 814 }); 815 );; 816 }; 817 ; 818 auto itBatch = batches.begin ();; 819 for (auto& f : futures); 820 {; 821 std::tuple<double,std::vector<double>> result = f.get ();; 822 testError += std::get<0>(result) / batches.size ();; 823 std::vector<double> output = std::get<1>(result);; 824 if (output.size() == (outputSize() - 1) * itBatch->size()); 825 {; 826 auto output_iterator = output.begin();; 827 for (auto pattern_it = itBatch->begin(); pattern_it != itBatch->end(); ++pattern_it); 828 {; 829 for (size_t output_index = 1; output_index < outputSize(); ++output_index); 830 {; 831 settings.testSample (0, *output_iterator, (*pattern_it).output ().at (0),; 832 (*pattern_it).weight ());; 833 ++output_iterator;; 834 }; 835 }; 836 }; 837 ++itBatch;; 838 }; 839 ; 840 }; 841 else; 842 {; 843 std::vector<double> output;; 844 //for (auto it = begin (testPattern), itEnd = end (testPattern); it != itEnd; ++it); 845 {; 846 //const Pattern& p = (*it);; 847 //double weight = p.weight ();; 848 //Batch batch (it, it+1);; 849 Batch batch (begin (testPattern), end (testPattern));; 850 output.clear ();; 851 pass_through_type passThrough (settings, batch, dropContainerTest);; 852 double testPa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/NeuralNet_8icc_source.html:24713,test,testError,24713,doc/master/NeuralNet_8icc_source.html,https://root.cern,https://root.cern/doc/master/NeuralNet_8icc_source.html,1,['test'],['testError']
Testability,mTransformFunction.cxx; mixmax.cxx; mixmax.h; mixmax_skip_N256.icc; MixMaxEngine.cxx; ParameterSettings.cxx; PdfFuncMathCore.cxx; ProbFuncMathCore.cxx; QuantFuncMathCore.cxx; RandomFunctions.cxx; RichardsonDerivator.cxx; RootFinder.cxx; SparseData.cxx; SpecFuncCephes.cxx; SpecFuncCephes.h; SpecFuncCephesInv.cxx; SpecFuncMathCore.cxx; TComplex.cxx; TDataPointN.cxx; TKDTree.cxx; TKDTreeBinning.cxx; TMath.cxx; TRandom.cxx; TRandom1.cxx; TRandom2.cxx; TRandom3.cxx; triangle.c; triangle.h; TStatistic.cxx; UnBinData.cxx; test; fit; GaussFunction.h; MinimizerTypes.h; SparseDataComparer.cxx; SparseFit3.cxx; SparseFit4.cxx; testFit.cxx; testFitPerf.cxx; testGraphFit.cxx; testMinim.cxx; testRooFit.cxx; WrapperRooPdf.h; binarySearchTime.cxx; kDTreeTest.cxx; newKDTreeTest.cxx; stdsort.cxx; stressGoFTest.cxx; stressTF1.cxx; stressTMath.cxx; testAnalyticalIntegrals.cxx; testBinarySearch.cxx; testDistSampler.cxx; testIntegration.cxx; testIntegrationMultiDim.cxx; testkdTreeBinning.cxx; testMathRandom.cxx; testRootFinder.cxx; testSampleQuantiles.cxx; testSortOrder.cxx; testSpecFuncBeta.cxx; testSpecFuncBetaI.cxx; testSpecFuncErf.cxx; testSpecFuncGamma.cxx; testSpecFuncSiCi.cxx; testTMath.cxx; testTStatistic.cxx; v7; inc; ROOT; TFit.h; mathmore; inc; Math; ChebyshevApprox.h; Derivator.h; DistFuncMathMore.h; GSLFunctionAdapter.h; GSLIntegrator.h; GSLMCIntegrator.h; GSLMinimizer.h; GSLMinimizer1D.h; GSLMultiRootFinder.h; GSLNLSMinimizer.h; GSLQuasiRandom.h; GSLRandom.h; GSLRandomFunctions.h; GSLRndmEngines.h; GSLRootFinder.h; GSLRootFinderDeriv.h; GSLRootHelper.h; GSLSimAnMinimizer.h; GSLSimAnnealing.h; IntegrationTypes.h; InterpolationTypes.h; Interpolator.h; KelvinFunctions.h; LinkDef.h; LinkDef_Func.h; LinkDef_RootFinding.h; MCIntegrationTypes.h; MCParameters.h; MultiNumGradFunction.h; MultiRootFinder.h; ParamFunction.h; PdfFuncMathMore.h; Polynomial.h; QuantFun,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html606/files.html:46214,test,testIntegrationMultiDim,46214,root/html606/files.html,https://root.cern,https://root.cern/root/html606/files.html,1,['test'],['testIntegrationMultiDim']
Testability,"mW2S, Float_t sumW2B) const; voidGetSample(const TMVA::Event& e, vector<const TMVA::BinarySearchTreeNode*,allocator<const TMVA::BinarySearchTreeNode*> >& events, TMVA::Volume* volume); virtual voidInit(); virtual voidProcessOptions(); voidRRScalc(const TMVA::Event&, vector<Float_t>* count); voidSetVolumeElement(); voidUpdateThis(). Data Members; public:. enum EVolumeRangeMode { kUnsupported; kMinMax; kRMS; kAdaptive; kUnscaled; kkNN; };; enum EKernelEstimator { kBox; kSphere; kTeepee; kGauss; kSinc3; kSinc5; kSinc7; kSinc9; kSinc11; kLanczos2; kLanczos3; kLanczos5; kLanczos8; kTrim; };; enum TMVA::MethodBase::EWeightFileType { kROOT; kTEXT; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. public:. Bool_tTMVA::MethodBase::fSetupCompletedis method setup; const TMVA::Event*TMVA::MethodBase::fTmpEvent! temporary event when testing on a different DataSet than the own one. protected:. TMVA::Types::EAnalysisTypeTMVA::MethodBase::fAnalysisTypemethod-mode : true --> regression, false --> classification; UInt_tTMVA::MethodBase::fBackgroundClassindex of the Background-class; Int_tfFcnCallnumber of external function calls (RootFinder); TMVA::Volume*fHelpVolumeauxiliary variable; vector<TString>*TMVA::MethodBase::fInputVarsvector of input variables used in MVA; vector<Float_t>*TMVA::MethodBase::fMulticlassReturnValholds the return-values for the multiclass classification; Int_tTMVA::MethodBase::fNbinsnumber of bins in input variable histograms; Int_tTMVA::MethodBase::fNbinsHnumber of bins in evaluation histograms; Int_tTMVA::MethodBase::fNbinsMVAoutputnumber of bins in MVA output histograms; TMVA::Ranking*TMVA::MethodBase::fRankingpointer to ranking object (created by derived classifiers); vector<Float_t>*TMVA::MethodBase::fRegressionReturnValholds the return-values for the r",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TMVA__MethodPDERS.html:18048,test,testing,18048,root/html530/TMVA__MethodPDERS.html,https://root.cern,https://root.cern/root/html530/TMVA__MethodPDERS.html,3,['test'],['testing']
Testability,"mW2S, Float_t sumW2B) const; voidGetSample(const TMVA::Event& e, vector<const TMVA::BinarySearchTreeNode*,allocator<const TMVA::BinarySearchTreeNode*> >& events, TMVA::Volume* volume); virtual voidInit(); virtual voidProcessOptions(); voidRRScalc(const TMVA::Event&, vector<Float_t>* count); voidSetVolumeElement(); voidUpdateThis(). Data Members; public:. enum EVolumeRangeMode { kUnsupported; kMinMax; kRMS; kAdaptive; kUnscaled; kkNN; };; enum EKernelEstimator { kBox; kSphere; kTeepee; kGauss; kSinc3; kSinc5; kSinc7; kSinc9; kSinc11; kLanczos2; kLanczos3; kLanczos5; kLanczos8; kTrim; };; enum TMVA::MethodBase::EWeightFileType { kROOT; kTEXT; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. public:. Bool_tTMVA::MethodBase::fSetupCompletedis method setup; const TMVA::Event*TMVA::MethodBase::fTmpEvent! temporary event when testing on a different DataSet than the own one. protected:. TMVA::Types::EAnalysisTypeTMVA::MethodBase::fAnalysisTypemethod-mode : true --> regression, false --> classification; UInt_tTMVA::MethodBase::fBackgroundClassindex of the Background-class; Int_tfFcnCallnumber of external function calls (RootFinder); TMVA::Volume*fHelpVolumeauxiliary variable; vector<TString>*TMVA::MethodBase::fInputVarsvector of input variables used in MVA; vector<Float_t>*TMVA::MethodBase::fMulticlassReturnValholds the return-values for the multiclass classification; Int_tTMVA::MethodBase::fNbinsnumber of bins in representative histograms; Int_tTMVA::MethodBase::fNbinsHnumber of bins in evaluation histograms; TMVA::Ranking*TMVA::MethodBase::fRankingpointer to ranking object (created by derived classifiers); vector<Float_t>*TMVA::MethodBase::fRegressionReturnValholds the return-values for the regression; UInt_tTMVA::MethodBase::fSignalClassindex of the Signal-class. priva",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMVA__MethodPDERS.html:17507,test,testing,17507,root/html528/TMVA__MethodPDERS.html,https://root.cern,https://root.cern/root/html528/TMVA__MethodPDERS.html,1,['test'],['testing']
Testability,"m[in] sigma is the shape parameter; 2397/// \param[in] theta is the location parameter; 2398/// \param[in] m is the scale parameter; 2399///; 2400/// The formula was taken from ""Engineering Statistics Handbook"" on site; 2401/// http://www.itl.nist.gov/div898/handbook/eda/section3/eda3669.htm; 2402/// Implementation using ROOT::Math::lognormal_pdf; 2403///; 2404/// Begin_Macro; 2405/// {; 2406/// TCanvas *c1 = new TCanvas(""c1"", ""c1"", 700, 500);; 2407///; 2408/// c1->SetLogy();; 2409/// c1->SetGridx();; 2410/// c1->SetGridy();; 2411///; 2412/// TF1 *logn = new TF1(""logn"", ""TMath::LogNormal(x, [0], [1], [2])"", 0, 5);; 2413/// logn->SetMinimum(1e-3);; 2414///; 2415/// logn->SetParameters(0.5, 0., 1.);; 2416/// logn->SetLineColor(2);; 2417/// TF1 *logn1 = logn->DrawCopy(""L"");; 2418/// logn->SetParameters(1.0, 0., 1.);; 2419/// logn->SetLineColor(3);; 2420/// TF1 *logn2 = logn->DrawCopy(""LSAME"");; 2421/// logn->SetParameters(2.0, 0., 1.);; 2422/// logn->SetLineColor(4);; 2423/// TF1 *logn3 = logn->DrawCopy(""LSAME"");; 2424/// logn->SetParameters(5.0, 0., 1.);; 2425/// logn->SetLineColor(6);; 2426/// TF1 *logn4 = logn->DrawCopy(""LSAME"");; 2427///; 2428/// auto legend = new TLegend(0.15, 0.15, 0.5, 0.35);; 2429/// legend->AddEntry(logn1, ""sigma = 0.5, theta = 0, m = 1"", ""L"");; 2430/// legend->AddEntry(logn2, ""sigma = 1.0, theta = 0, m = 1"", ""L"");; 2431/// legend->AddEntry(logn3, ""sigma = 2.0, theta = 0, m = 1"", ""L"");; 2432/// legend->AddEntry(logn4, ""sigma = 5.0, theta = 0, m = 1"", ""L"");; 2433/// legend->Draw();; 2434/// }; 2435/// End_Macro; 2436 ; 2437Double_t TMath::LogNormal(Double_t x, Double_t sigma, Double_t theta, Double_t m); 2438{; 2439 if ((x<theta) || (sigma<=0) || (m<=0)) {; 2440 Error(""TMath::Lognormal"", ""illegal parameter values"");; 2441 return 0;; 2442 }; 2443 // lognormal_pdf uses same definition of http://en.wikipedia.org/wiki/Log-normal_distribution; 2444 // where mu = log(m); 2445 ; 2446 return ::ROOT::Math::lognormal_pdf(x, TMath::Log(m), sigma, theta);; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMath_8cxx_source.html:82584,log,logn,82584,doc/master/TMath_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TMath_8cxx_source.html,3,['log'],['logn']
Testability,"mal number of events requested by a leaf node as percentage of the ; : number of training events (option ""MinNodeSize"" replacing the actual number ; : of events ""nEventsMin"" as given in earlier versions; : If this number is too large, detailed features ; : in the parameter space are hard to be modelled. If it is too small, ; : the risk to overtrain rises and boosting seems to be less effective; : typical values from our current experience for best performance ; : are between 0.5(%) and 10(%) ; : ; : The default minimal number is currently set to ; : max(20, (N_training_events / N_variables^2 / 10)) ; : and can be changed by the user.; : ; : The other crucial parameter, the pruning strength (""PruneStrength""),; : is also related to overtraining. It is a regularisation parameter ; : that is used when determining after the training which splits ; : are considered statistically insignificant and are removed. The; : user is advised to carefully watch the BDT screen output for; : the comparison between efficiencies obtained on the training and; : the independent test sample. They should be equal within statistical; : errors, in order to minimize statistical fluctuations in different samples.; : ; : <Suppress this message by specifying ""!H"" in the booking option>; : [1m================================================================[0m; : ; BDTG : #events: (reweighted) sig: 1600 bkg: 1600; : #events: (unweighted) sig: 1600 bkg: 1600; : Training 100 Decision Trees ... patience please; : Elapsed time for training with 3200 events: 1.7 sec ; BDTG : [dataset] : Evaluation of BDTG on training sample (3200 events); : Elapsed time for evaluation of 3200 events: 0.0183 sec ; : Creating xml weight file: [0;36mdataset/weights/TMVAClassification_BDTG.weights.xml[0m; : Creating standalone class: [0;36mdataset/weights/TMVAClassification_BDTG.class.C[0m; : data_RNN_CPU.root:/dataset/Method_BDT/BDTG; Factory : Training finished; : ; : Ranking input variables (method specific)...; : ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVA__RNN__Classification_8py.html:32989,test,test,32989,doc/master/TMVA__RNN__Classification_8py.html,https://root.cern,https://root.cern/doc/master/TMVA__RNN__Classification_8py.html,1,['test'],['test']
Testability,"malizeTransformLinear interpolation class.Definition VariableNormalizeTransform.h:48; TMVA::VariablePCATransformLinear interpolation class.Definition VariablePCATransform.h:48; TMVA::VariableTransformBaseLinear interpolation class.Definition VariableTransformBase.h:54; TMVA::VariableTransformBase::SelectInputvirtual void SelectInput(const TString &inputVariables, Bool_t putIntoVariables=kFALSE)select the variables/targets/spectators which serve as input to the transformationDefinition VariableTransformBase.cxx:110; TNamed::GetNameconst char * GetName() const overrideReturns name of object.Definition TNamed.h:47; TObjStringCollectable string class.Definition TObjString.h:28; TStringBasic string class.Definition TString.h:139; TString::ReplaceTString & Replace(Ssiz_t pos, Ssiz_t n, const char *s)Definition TString.h:694; TString::RemoveTString & Remove(Ssiz_t pos)Definition TString.h:685; TString::Sizeofvirtual Int_t Sizeof() constReturns size string will occupy on I/O buffer.Definition TString.cxx:1401; TString::ContainsBool_t Contains(const char *pat, ECaseCompare cmp=kExact) constDefinition TString.h:632; TString::IndexSsiz_t Index(const char *pat, Ssiz_t i=0, ECaseCompare cmp=kExact) constDefinition TString.h:651; int; TMVAcreate variable transformationsDefinition GeneticMinimizer.h:22; TMVA::gToolsTools & gTools(); TMVA::CreateVariableTransformsvoid CreateVariableTransforms(const TString &trafoDefinition, TMVA::DataSetInfo &dataInfo, TMVA::TransformationHandler &transformationHandler, TMVA::MsgLogger &log)Definition VariableTransform.cxx:59; TMVA::variablesvoid variables(TString dataset, TString fin=""TMVA.root"", TString dirName=""InputVariables_Id"", TString title=""TMVA Input Variables"", Bool_t isRegression=kFALSE, Bool_t useTMVAStyle=kTRUE); TMVA::EndlMsgLogger & Endl(MsgLogger &ml)Definition MsgLogger.h:148; Config.h; Types.h. tmvatmvasrcVariableTransform.cxx. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:01 (GVA Time) using Doxygen 1.9.8 ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/VariableTransform_8cxx_source.html:11326,log,log,11326,doc/master/VariableTransform_8cxx_source.html,https://root.cern,https://root.cern/doc/master/VariableTransform_8cxx_source.html,1,['log'],['log']
Testability,"mall variation of each input. ; ; voidDrawNetwork (Int_t neuron, const char *signal, const char *bg); Draws the distribution of the neural network (using ith neuron). ; ; TProfile *DrawTruthDeviation (Int_t outnode=0, Option_t *option=""""); Create a profile of the difference of the MLP output minus the true value for a given output node outnode, vs the true value for outnode, for all test data events. ; ; TProfile *DrawTruthDeviationInOut (Int_t innode, Int_t outnode=0, Option_t *option=""""); Creates a profile of the difference of the MLP output outnode minus the true value of outnode vs the input value innode, for all test data events. ; ; THStack *DrawTruthDeviationInsOut (Int_t outnode=0, Option_t *option=""""); Creates a profile of the difference of the MLP output outnode minus the true value of outnode vs the input value, stacked for all inputs, for all test data events. ; ; THStack *DrawTruthDeviations (Option_t *option=""""); Creates TProfiles of the difference of the MLP output minus the true value vs the true value, one for each output, filled with the test data events. ; ; voidGatherInformations (); Collect information about what is useful in the network. ; ; TTree *GetIOTree () const; ; TClass *IsA () const override; ; voidStreamer (TBuffer &) override; Stream an object of class TObject. ; ; voidStreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b); ; Public Member Functions inherited from TObject; TObject (); TObject constructor. ; ; TObject (const TObject &object); TObject copy ctor. ; ; virtual~TObject (); TObject destructor. ; ; voidAbstractMethod (const char *method) const; Use this method to implement an ""abstract"" method that you don't want to leave purely abstract. ; ; virtual voidAppendPad (Option_t *option=""""); Append graphics object to current pad. ; ; virtual voidBrowse (TBrowser *b); Browse object. May be overridden for another default action. ; ; ULong_tCheckedHash (); Check and record whether thi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMLPAnalyzer.html:2126,test,test,2126,doc/master/classTMLPAnalyzer.html,https://root.cern,https://root.cern/doc/master/classTMLPAnalyzer.html,1,['test'],['test']
Testability,"managed by this class; use auto_ptr to manage previously existing distribution objects. bool SetRandomGenerator(); set an external random generator. bool SetContDistribution(const TUnuranContDist& dist); internal method to set in unuran the function pointer for a continuous univariate distribution. bool SetMultiDistribution(const TUnuranMultiContDist& dist); internal method to set in unuran the function pointer for a multivariate distribution. bool SetEmpiricalDistribution(const TUnuranEmpDist& dist). bool SetDiscreteDistribution(const TUnuranDiscrDist& dist); internal method to set in unuran the function pointer for a discrete univariate distribution. bool SetMethodAndInit(). int SampleDiscr(); sample one-dimensional distribution. double Sample(); sample one-dimensional distribution. bool SampleMulti(double* x); sample multidimensional distribution. void SetSeed(unsigned int seed). bool SetLogLevel(unsigned int iflag = 1). bool InitPoisson(double mu, const string& method = ""dstd""); initializaton for a Poisson. bool InitBinomial(unsigned int ntot, double prob, const string& method = ""dstd""); initializaton for a Binomial. bool ReInitDiscrDist(unsigned int npar, double* params); re-initialization of UNURAN without freeing and creating a new fGen object; works only for pre-defined distribution by changing their parameters. void SetRandom(TRandom* r). set the random engine.; Must be called before init to have effect. TRandom * GetRandom(). return instance of the random engine used. bool SetLogStream(). set stream for log and error (not yet implemented). { return false;}. const std::string & MethodName() const. used Unuran method. { return fMethod; }.  Author: L. Moneta Tue Sep 26 16:25:09 2006  Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *;  Last changed: root/unuran:$Id$  Last generated: 2015-06-30 15:32; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TUnuran.html:4780,log,log,4780,root/html602/TUnuran.html,https://root.cern,https://root.cern/root/html602/TUnuran.html,1,['log'],['log']
Testability,"managed by this class; use auto_ptr to manage previously existing distribution objects. bool SetRandomGenerator(); set an external random generator. bool SetContDistribution(const TUnuranContDist& dist); internal method to set in unuran the function pointer for a continuous univariate distribution. bool SetMultiDistribution(const TUnuranMultiContDist& dist); internal method to set in unuran the function pointer for a multivariate distribution. bool SetEmpiricalDistribution(const TUnuranEmpDist& dist). bool SetDiscreteDistribution(const TUnuranDiscrDist& dist); internal method to set in unuran the function pointer for a discrete univariate distribution. bool SetMethodAndInit(). int SampleDiscr(); sample one-dimensional distribution. double Sample(); sample one-dimensional distribution. bool SampleMulti(double* x); sample multidimensional distribution. void SetSeed(unsigned int seed). bool SetLogLevel(unsigned int iflag = 1). bool InitPoisson(double mu, const string& method = ""dstd""); initializaton for a Poisson. bool InitBinomial(unsigned int ntot, double prob, const string& method = ""dstd""); initializaton for a Binomial. bool ReInitDiscrDist(unsigned int npar, double* params); re-initialization of UNURAN without freeing and creating a new fGen object; works only for pre-defined distribution by changing their parameters. void SetRandom(TRandom* r). set the random engine.; Must be called before init to have effect. TRandom * GetRandom(). return instance of the random engine used. bool SetLogStream(). set stream for log and error (not yet implemented). { return false;}. const std::string & MethodName() const. used Unuran method. { return fMethod; }.  Author: L. Moneta Tue Sep 26 16:25:09 2006  Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *;  Last changed: root/unuran:$Id$  Last generated: 2015-09-08 17:49; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TUnuran.html:4780,log,log,4780,root/html604/TUnuran.html,https://root.cern,https://root.cern/root/html604/TUnuran.html,1,['log'],['log']
Testability,"mand.cxx. ls(). void TQUndoManager::ls ; (; Option_t *; option = """"); const. overridevirtual . Lists all commands in stack. ; Reimplemented from TQCommand.; Definition at line 901 of file TQCommand.cxx. PrintCollectionEntry(). void TQUndoManager::PrintCollectionEntry ; (; TObject *; entry, . Option_t *; option, . Int_t; recurse. ); const. overrideprotectedvirtual . Print collection entry. ; Reimplemented from TCollection.; Definition at line 921 of file TQCommand.cxx. Redo(). void TQUndoManager::Redo ; (; Option_t *; option = """"). overridevirtual . Performs redo action. Move cursor position forward in history stack. ; Reimplemented from TQCommand.; Definition at line 1053 of file TQCommand.cxx. SetLimit(). void TQUndoManager::SetLimit ; (; UInt_t; limit). virtual . Returns a maximum number of commands which could be located in stack. ; Definition at line 1137 of file TQCommand.cxx. SetLogging(). void TQUndoManager::SetLogging ; (; Bool_t; on = kTRUE). virtual . Start logging. ; Delete all previous log records Note: logging is not implemented yet ; Definition at line 938 of file TQCommand.cxx. Streamer(). void TQUndoManager::Streamer ; (; TBuffer &; b). overridevirtual . Stream all objects in the collection to or from the I/O buffer. ; Reimplemented from TQCommand. StreamerNVirtual(). void TQUndoManager::StreamerNVirtual ; (; TBuffer &; ClassDef_StreamerNVirtual_b). inline . Definition at line 133 of file TQCommand.h. Undo(). void TQUndoManager::Undo ; (; Option_t *; option = """"). overridevirtual . Performs undo action. Move cursor position backward in history stack. ; Reimplemented from TQCommand.; Definition at line 1021 of file TQCommand.cxx. Member Data Documentation. fCurrent. TQCommand* TQUndoManager::fCurrent. protected . Definition at line 107 of file TQCommand.h. fCursor. TObjLink* TQUndoManager::fCursor. protected . Definition at line 106 of file TQCommand.h. fLimit. UInt_t TQUndoManager::fLimit. protected . Definition at lin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTQUndoManager.html:32449,log,logging,32449,doc/master/classTQUndoManager.html,https://root.cern,https://root.cern/doc/master/classTQUndoManager.html,1,['log'],['logging']
Testability,"mandskUnloadPackage; static TProof::EProofCacheCommandskUnloadPackages; static TProof::EProofDataSetCommandskUploadDataSet; static TProof::EProofDataSetCommandskVerifyDataSet. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TProof(const char* masterurl, const char* conffile = kPROOF_ConfFile, const char* confdir = kPROOF_ConfDir, Int_t loglevel = 0, const char* alias = 0, TProofMgr* mgr = 0); Create a PROOF environment. Starting PROOF involves either connecting; to a master server, which in turn will start a set of slave servers, or; directly starting as master server (if master = """"). Masterurl is of; the form: [proof[s]://]host[:port]. Conffile is the name of the config; file describing the remote PROOF cluster (this argument alows you to; describe different cluster configurations).; The default is proof.conf. Confdir is the directory where the config; file and other PROOF related files are (like motd and noproof files).; Loglevel is the log level (default = 1). User specified custom config; files will be first looked for in $HOME/.conffile. TProof(); Protected constructor to be used by classes deriving from TProof; (they have to call Init themselves and override StartSlaves; appropriately). This constructor simply closes any previous gProof and sets gProof; to this instance. void InitMembers(); Default initializations. ~TProof(); Clean up PROOF environment. Int_t Init(const char* masterurl, const char* conffile, const char* confdir, Int_t loglevel, const char* alias = 0); Start the PROOF environment. Starting PROOF involves either connecting; to a master server, which in turn will start a set of slave servers, or; directly starting as master server (if master = """"). For a description; of the arguments see the TProof ctor. Returns the number of started; master or slave servers, returns 0 in case of error, in which case; fValid remains false. Int_t GetSandbox(TString& sb, Bool_t assert = kFALSE, const char* rc = 0); Set th",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TProof.html:38227,log,log,38227,root/html602/TProof.html,https://root.cern,https://root.cern/root/html602/TProof.html,2,['log'],['log']
Testability,"many Linux distributions. On Debian/Ubuntu it is available with the package name tig from the default repositories.; On RHEL-based systems it is available from the additional repository RepoForge.; On OS X it is easily installed via Homebrew:; brew install tig. Tig pager mode; Many git commands can be piped into tig. When tig is invoked this way, it is in pager mode: output will be colored according to the input format, and colored.; For instance it is possible to pipe the differences of one file like this:; git diff path/to/file.cxx | tig. or see the changes of one revision like this:; git show b204d4c87 | tig. The most important interactive tig commands are:. 'h': opens the help screen; 'q': closes current window; 'Q': closes all windows and exits. Log view; Tig invoked without any argument spawns a full log view with one line per commit including author, date and log message. Heads of the different branches are clearly indicated. To see a graph view indicating branching graphically (just like git log --oneline --graph), do:; tig --all. A log can be selected with Enter to see the revision changes.; An example of useful application of the log view is interactive cherry-picking: just press 'C' to cherry-pick currently selected commit into your current branch.; Blame view; Blame view is extremely useful to see which lines were committed by whom. It is an improved version of the standard git blame command with a much clearer and interactive output.; Each line can be selected to display the associated full commit log and diff. Usage:; tig blame path/to/file.cxx. Interactive staging and current status; tig status opens an interactive display to quickly select files to be staged. Move over the file and press 'u' to (un)stage it. The .gitconfig file; This file contains global (~/.gitconfig) or repository-local configuration settings. You can (eg):. Set user and email information to label commits usefully:; git config --global user.name ""Chris Green"" ; git config --global ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/git-tips-and-tricks.html:17372,log,log,17372,d/git-tips-and-tricks.html,https://root.cern,https://root.cern/d/git-tips-and-tricks.html,1,['log'],['log']
Testability,"map<int,std::string>_levelNames; map<int,std::string>_topicNames. protected:. ostream*_devnull; Int_t_errorCount; map<std::string,std::ostream*>_files; RooFit::MsgLevel_globMinLevel; static RooMsgService*_instance; RooFit::MsgLevel_lastMsgLevel; Bool_t_showPid; Bool_t_silentMode; vector<StreamConfig>_streams; stack<std::vector<StreamConfig> >_streamsSaved. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void cleanup(); Cleanup function called by atexit() handler installed by RooSentinel; to delete all global object upon program termination. RooMsgService(); Constructor. Defines names of message levels; and mapping of topic codes to topic names; Install default message streams. ~RooMsgService(); Destructor. Bool_t anyDebug(); Returns true if any debug level stream is active. Int_t addStream(RooFit::MsgLevel level, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg()); Add a message logging stream for message with given RooFit::MsgLevel or higher (i.e. more severe); This method accepts the following arguments to configure the stream. Output Style options. Prefix(Bool_t flag=kTRUE) -- Prefix all messages in this stream with Topic/Originator information. Filtering options. Topic(const char*) -- Restrict stream to messages on given topic; ObjectName(const char*) -- Restrict stream to messages from object with given name; ClassName(const char*) -- Restrict stream to messages from objects with given class name; BaseClassName(const char*)-- Restrict stream to messages from objects with given base class name; LabelName(const chat*) -- Restrict stream to messages from objects setAtrribute(const char*) tag with given name. Output redirection options. OutputFile(const char*) -- Send output to file with given name. Multiple streams can write to same file.; OutputStream(os",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooMsgService.html:8702,log,logging,8702,root/html526/RooMsgService.html,https://root.cern,https://root.cern/root/html526/RooMsgService.html,1,['log'],['logging']
Testability,"map_tTGScrollBar::fgBckgndPixmap; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static Int_tTGScrollBar::fgScrollBarWidth; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGHScrollBar(const TGWindow* p = 0, UInt_t w = 4, UInt_t h = 2, UInt_t options = kHorizontalFrame, Pixel_t back = GetDefaultFrameBackground()); Create a horizontal scrollbar widget. void Layout(); Layout and move horizontal scrollbar components. Bool_t HandleButton(Event_t* event); Handle a mouse button event in a horizontal scrolbar. Bool_t HandleMotion(Event_t* event); Handle mouse motion event in a horizontal scrollbar. void SetRange(Int_t range, Int_t page_size); Set range of horizontal scrollbar. void SetPosition(Int_t pos); Set logical slider position of horizontal scrollbar. void SavePrimitive(ostream& out, Option_t* option = """"); Save an horizontal scrollbar as a C++ statement(s) on output stream out. virtual ~TGHScrollBar(); { }. TGDimension GetDefaultSize() const; { return TGDimension(fWidth, GetScrollBarWidth()); }.  Author: Fons Rademakers 10/01/98  Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *;  Last changed: root/gui:$Id: TGScrollBar.h 23115 2008-04-10 13:35:37Z rdm $  Last generated: 2010-09-23 20:06; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGHScrollBar.html:20565,log,logical,20565,root/html528/TGHScrollBar.html,https://root.cern,https://root.cern/root/html528/TGHScrollBar.html,1,['log'],['logical']
Testability,"maryOld version of a dynamic particle class created by event generators ; CTPrincipalPrincipal Components Analysis (PCA) ; CTProcessEventTimer; CTProcessIDA TProcessID identifies a ROOT job in a unique way in time and space ; CTProcessUUIDThis class is a specialized TProcessID managing the list of UUIDs ; CTProfileProfile Historam ; CTProfile2DProfile2D histograms are used to display the mean value of Z and its RMS for each cell in X,Y ; CTProfile3DProfile3D histograms are used to display the mean value of T and its RMS for each cell in X,Y,Z ; CTProfileHelper; CTProofThis class controls a Parallel ROOT Facility, PROOF, cluster ; CMD5Mod_t; CTProofBenchSteering class for PROOF benchmarks ; CTProofBenchDataSetHandle operations on datasets used by ProofBench ; CTProofBenchRunAbstract base class for PROOF benchmark runs ; CTProofBenchRunCPUCPU-intensive PROOF benchmark test generates events and fill 1, 2, or 3-D histograms ; CTProofBenchRunDataReadI/O-intensive PROOF benchmark test reads in event files distributed on the cluster ; CTProofChain; CTProofCondor; CTProofDebug; CTProofDesc; CTProofDrawImplement Tree drawing using PROOF ; CTProofDrawEntryList; CTProofDrawEventList; CTProofDrawGraph; CTProofDrawHist; CTProofDrawListOfGraphs; CPoint3D_t; CTProofDrawListOfPolyMarkers3D; CPoint4D_t; CTProofDrawPolyMarker3D; CTProofDrawProfile; CTProofDrawProfile2D; CTProofInputHandler; CTProofInterruptHandler; CTProofLimitsFinderClass to find axis limits and synchronize them between workers ; CTProofLiteThis class starts a PROOF session on the local machine: no daemons, client and master merged, communications via UNIX-like sockets ; CTProofLockPath; CTProofLockPathGuard; CTProofLogImplementation of the PROOF session log handler ; CTProofLogElem; CTProofMergePrg; CTProofMgrThe PROOF manager interacts with the PROOF server coordinator to create or destroy a PROOF session, attach to or detach from existing one, and to monitor any client ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v608/annotated.html:177521,benchmark,benchmark,177521,doc/v608/annotated.html,https://root.cern,https://root.cern/doc/v608/annotated.html,1,['benchmark'],['benchmark']
Testability,"mat ; CTRootSnifferStoreXmlStorage of hierarchy scan in TRootSniffer in XML format ; CTRotationDescribes a rotation of objects of the TVector3 class ; CTRotationRow; CTRotMatrixManages a detector rotation matrix ; CTRSA_fun; CTRWLock; CTS3HTTPRequest; CTS3WebFile; CTSapDBResult; CTSapDBRow; CTSapDBServer; CTSAXParserTSAXParser is a subclass of TXMLParser, it is a wraper class to libxml library ; CTSecContext; CTSecContextCleanup; CTSelectorA TSelector object is used by the TTree::Draw, TTree::Scan, TTree::Process to navigate in a TTree and make selections ; CTSelectorDrawA specialized TSelector for TTree::Draw ; CTSelectorEntriesThe class is derived from the ROOT class TSelector ; CTSelectorListA TList derived class that makes sure that objects added to it are not linked to the currently open file (like histograms, eventlists and trees) ; CTSelectorScalarNamed scalar type, based on Long64_t, streamable, storable and mergable ; CTSelEventSelector for PROOF I/O benchmark test ; CTSelEventGenSelector for event file generation ; CTSelHandleDataSetPROOF selector for file cache release ; CTSelHistPROOF selector for CPU-intensive benchmark test ; CTSelVerifyDataSetSelector to verify dataset in parallel on workers ; CTSemaphore; CTSeqCollectionSequenceable collection abstract base class ; CTServerSocket; CTSessionDescription; CTSessionFrame; CTSessionInputFrame; CTSessionLogView; CTSessionOutputFrame; CTSessionQueryFrame; CTSessionServerFrame; CTSessionViewer; CTShapeThis is the base class for all geometry shapes ; CTShutdownTimer; CTSignalHandler; CTSimpleAnalysisA TSimpleAnalysis object creates histograms from a TChain ; CTSlaveClass describing a PROOF worker server ; CTSlaveInfo; CTSlaveLiteVersion of TSlave for local worker servers ; CTSliderA specialized TPad including a TSliderBox object ; CTSliderBoxThe moving box in a TSlider ; CTSocket; CTSortedListA sorted doubly linked list ; CTSpectrumAdvanced Spectra Processing ; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v612/annotated.html:203394,benchmark,benchmark,203394,doc/v612/annotated.html,https://root.cern,https://root.cern/doc/v612/annotated.html,3,['benchmark'],['benchmark']
Testability,"mation about fit parameters printed in the histogram statistics; box can be selected via the parameter mode. The parameter mode can be; = pcev (default = 0111). p = 1; print Probability; c = 1; print Chisquare/Number of degrees of freedom; e = 1; print errors (if e=1, v must be 1); v = 1; print name/values of parameters. Example:. gStyle->SetOptFit(1011);. print fit probability, parameter names/values and errors. When ""v"" = 1 is specified, only the non-fixed parameters are; shown.; When ""v"" = 2 all parameters are shown. Note: gStyle->SetOptFit(1) means ""default value"", so it is equivalent; to gStyle->SetOptFit(111); Statistics box editing; The following example show how to remove and add a line in a statistics box. Picture; Source. TCanvas *statsEditing() {; // This example shows:; // - how to remove a stat element from the stat box; // - how to add a new one; //; // Author: Olivier Couet. // Create and plot a test histogram with stats; TCanvas *se = new TCanvas;; TH1F *h = new TH1F(""h"",""test"",100,-3,3);; h->FillRandom(""gaus"",3000);; gStyle->SetOptStat();; h->Draw();; se->Update();. // Retrieve the stat box; TPaveStats *ps = (TPaveStats*)se->GetPrimitive(""stats"");; ps->SetName(""mystats"");; TList *list = ps->GetListOfLines();. // Remove the RMS line; TText *tconst = ps->GetLineWith(""RMS"");; list->Remove(tconst);. // Add a new line in the stat box.; // Note that ""="" is a control character; TLatex *myt = new TLatex(0,0,""Test = 10"");; myt ->SetTextFont(42);; myt ->SetTextSize(0.04);; myt ->SetTextColor(kRed);; list->Add(myt);. // the following line is needed to avoid that the automatic redrawing of stats; h->SetStats(0);. se->Modified();; return se;; } . Function Members (Methods); public:. virtual~TPaveStats(); voidTObject::AbstractMethod(const char* method) const; virtual TBox*AddBox(Double_t, Double_t, Double_t, Double_t); virtual TLine*AddLine(Double_t, Double_t, Double_t, Double_t); virtual TText*TPaveText::AddText(const char* label); virtual TText*TPaveText::AddTex",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TPaveStats.html:5215,test,test,5215,root/html602/TPaveStats.html,https://root.cern,https://root.cern/root/html602/TPaveStats.html,4,['test'],['test']
Testability,"mation of the Compton edges and decreasing clipping window. In the lower part of the Figure we present the background, which was added to the synthetic spectrum. One can observe good coincidence with the estimated background. The method of the estimation of Compton edge is described in detail in [3]. Synthetic spectrum with Compton edges. The generalized form of the algorithm is implemented in the function.; char *Background1General(float *spectrum,; int size,; int number_of_iterations,; int direction,; int filter_order,; bool compton);; The meaning of the parameters is as follows:. spectrum pointer to the vector of source spectrum; size length of spectrum vector; number_of_iterations maximal width of clipping window,; direction direction of change of clipping window. Possible values:. BACK1_INCREASING_WINDOW; BACK1_DECREASING_WINDOW. filter_order order of clipping filter. Possible values:. BACK1_ORDER2; BACK1_ORDER4; BACK1_ORDER6; BACK1_ORDER8. compton logical variable whether the estimation of Compton edge will be included. Possible values:. BACK1_EXCLUDE_COMPTON; BACK1_INCLUDE_COMPTON. 1.2 2-DIMENSIONAL SPECTRA; This basic background estimation function allows to separate useless spectrum information (2D-continuous background and coincidences of peaks with background in both dimensions) from peaks. It calculates background spectrum from source spectrum. The result is placed in the array pointed by spectrum pointer. On successful completion it returns 0. On error it returns pointer to the string describing error.; char *Background2(float **spectrum,; int sizex,; int sizey,; int number_of_iterations);; Function parameters:. spectrum pointer to the array of source spectrum; sizex x length of spectrum; sizey y length of spectrum; number_of_iterations width of the clipping window. In Figure 1.6 we present an example of 2-dimensional spectrum before background elimination. 2-dimensional spectrum before background elimination. Estimated background is shown in Figure 1.7",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/guides/spectrum/Spectrum.html:4503,log,logical,4503,root/html534/guides/spectrum/Spectrum.html,https://root.cern,https://root.cern/root/html534/guides/spectrum/Spectrum.html,1,['log'],['logical']
Testability,mation.cxx; mnvert.cxx; mnxerbla.cxx; ModularFunctionMinimizer.cxx; MPIProcess.cxx; NegativeG2LineSearch.cxx; Numerical2PGradientCalculator.cxx; ParametricFunction.cxx; ScanBuilder.cxx; SimplexBuilder.cxx; SimplexParameters.cxx; SimplexSeedGenerator.cxx; SinParameterTransformation.cxx; SqrtLowParameterTransformation.cxx; SqrtUpParameterTransformation.cxx; TMinuit2TraceObject.cxx; VariableMetricBuilder.cxx; VariableMetricEDMEstimator.cxx; test; MnSim; DemoFumili.cxx; DemoGaussSim.cxx; demoMinimizer.cxx; FlatRandomGen.h; GaussDataGen.cxx; GaussDataGen.h; GaussFcn.cxx; GaussFcn.h; GaussFcn2.cxx; GaussFcn2.h; GaussFunction.h; GaussianModelFunction.h; GaussRandomGen.h; ParallelTest.cxx; PaulTest.cxx; PaulTest2.cxx; PaulTest3.cxx; PaulTest4.cxx; ReneTest.cxx; MnTutorial; Quad12F.h; Quad12FMain.cxx; Quad1F.h; Quad1FMain.cxx; Quad4F.h; Quad4FMain.cxx; Quad8F.h; Quad8FMain.cxx; testMinimizer.cxx; testNdimFit.cxx; testUnbinGausFit.cxx; testUserFunc.cxx; mlp; inc; LinkDef.h; TMLPAnalyzer.h; TMultiLayerPerceptron.h; TNeuron.h; TSynapse.h; src; TMLPAnalyzer.cxx; TMultiLayerPerceptron.cxx; TNeuron.cxx; TSynapse.cxx; physics; inc; LinkDef.h; TFeldmanCousins.h; TGenPhaseSpace.h; TLorentzRotation.h; TLorentzVector.h; TQuaternion.h; TRobustEstimator.h; TRolke.h; TRotation.h; TVector2.h; TVector3.h; src; TFeldmanCousins.cxx; TGenPhaseSpace.cxx; TLorentzRotation.cxx; TLorentzVector.cxx; TQuaternion.cxx; TRobustEstimator.cxx; TRolke.cxx; TRotation.cxx; TVector2.cxx; TVector3.cxx; quadp; inc; LinkDef.h; TGondzioSolver.h; TMehrotraSolver.h; TQpDataBase.h; TQpDataDens.h; TQpDataSparse.h; TQpLinSolverBase.h; TQpLinSolverDens.h; TQpLinSolverSparse.h; TQpProbBase.h; TQpProbDens.h; TQpProbSparse.h; TQpResidual.h; TQpSolverBase.h; TQpVar.h; src; TGondzioSolver.cxx; TMehrotraSolver.cxx; TQpDataBase.cxx; TQpDataDens.cxx; TQpDataSparse.cxx; TQpLinSolverBase.cxx; TQ,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v608/files.html:55377,test,testUserFunc,55377,doc/v608/files.html,https://root.cern,https://root.cern/doc/v608/files.html,2,['test'],['testUserFunc']
Testability,mation.cxx; mnvert.cxx; mnxerbla.cxx; ModularFunctionMinimizer.cxx; MPIProcess.cxx; NegativeG2LineSearch.cxx; Numerical2PGradientCalculator.cxx; ParametricFunction.cxx; ScanBuilder.cxx; SimplexBuilder.cxx; SimplexParameters.cxx; SimplexSeedGenerator.cxx; SinParameterTransformation.cxx; SqrtLowParameterTransformation.cxx; SqrtUpParameterTransformation.cxx; TMinuit2TraceObject.cxx; VariableMetricBuilder.cxx; VariableMetricEDMEstimator.cxx; test; MnSim; DemoFumili.cxx; DemoGaussSim.cxx; demoMinimizer.cxx; FlatRandomGen.h; GaussDataGen.cxx; GaussDataGen.h; GaussFcn.cxx; GaussFcn.h; GaussFcn2.cxx; GaussFcn2.h; GaussFunction.h; GaussianModelFunction.h; GaussRandomGen.h; ParallelTest.cxx; PaulTest.cxx; PaulTest2.cxx; PaulTest3.cxx; PaulTest4.cxx; ReneTest.cxx; MnTutorial; Quad12F.h; Quad12FMain.cxx; Quad1F.h; Quad1FMain.cxx; Quad4F.h; Quad4FMain.cxx; Quad8F.h; Quad8FMain.cxx; testMinimizer.cxx; testNdimFit.cxx; testUnbinGausFit.cxx; testUserFunc.cxx; mlp; inc; TMLPAnalyzer.h; TMultiLayerPerceptron.h; TNeuron.h; TSynapse.h; src; TMLPAnalyzer.cxx; TMultiLayerPerceptron.cxx; TNeuron.cxx; TSynapse.cxx; physics; inc; TFeldmanCousins.h; TGenPhaseSpace.h; TLorentzRotation.h; TLorentzVector.h; TQuaternion.h; TRobustEstimator.h; TRolke.h; TRotation.h; TVector2.h; TVector3.h; src; TFeldmanCousins.cxx; TGenPhaseSpace.cxx; TLorentzRotation.cxx; TLorentzVector.cxx; TQuaternion.cxx; TRobustEstimator.cxx; TRolke.cxx; TRotation.cxx; TVector2.cxx; TVector3.cxx; quadp; inc; TGondzioSolver.h; TMehrotraSolver.h; TQpDataBase.h; TQpDataDens.h; TQpDataSparse.h; TQpLinSolverBase.h; TQpLinSolverDens.h; TQpLinSolverSparse.h; TQpProbBase.h; TQpProbDens.h; TQpProbSparse.h; TQpResidual.h; TQpSolverBase.h; TQpVar.h; src; TGondzioSolver.cxx; TMehrotraSolver.cxx; TQpDataBase.cxx; TQpDataDens.cxx; TQpDataSparse.cxx; TQpLinSolverBase.cxx; TQpLinSolverDens.cxx; TQpLinSolverSpa,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v610/files.html:53919,test,testUserFunc,53919,doc/v610/files.html,https://root.cern,https://root.cern/doc/v610/files.html,1,['test'],['testUserFunc']
Testability,"maximum entry in vector. Int_t GetIndexMinElement(vector<Double_t>& ); find index of minimum entry in vector. Bool_t ContainsRegularExpression(const TString& s); check if regular expression; helper function to search for ""$!%^&()'<>?= "" in a string. TString ReplaceRegularExpressions(const TString& s, const TString& replace = ""+""); replace regular expressions; helper function to remove all occurences ""$!%^&()'<>?= "" from a string; and replace all ::,$,*,/,+,- with _M_,_S_,_T_,_D_,_P_,_M_ respectively. const TString& Color(const TString& ); human readable color strings. void FormattedOutput(const vector<Double_t>& , const vector<TString>& , const TString titleVars, const TString titleValues, TMVA::MsgLogger& logger, TString format = ""%+1.3f""); formatted output of simple table. void FormattedOutput(const TMatrixD& , const vector<TString>& , TMVA::MsgLogger& logger); formatted output of matrix (with labels). void FormattedOutput(const TMatrixD& , const vector<TString>& vert, const vector<TString>& horiz, TMVA::MsgLogger& logger); formatted output of matrix (with labels). TString GetXTitleWithUnit(const TString& title, const TString& unit); histogramming utility. TString GetYTitleWithUnit(const TH1& h, const TString& unit, Bool_t normalised); histogramming utility. void WriteFloatArbitraryPrecision(Float_t val, ostream& os); writes a float value with the available precision to a stream. void ReadFloatArbitraryPrecision(Float_t& val, istream& is); reads a float value with the available precision from a stream. Bool_t HasAttr(void* node, const char* attrname); add attribute from xml. void ReadAttr(void* node, const char* attrname, TString& value); add attribute from xml. void AddAttr(void* node, const char* attrname, const char* value); add attribute to node. void* AddChild(void* parent, const char* childname, const char* content = 0, bool isRootNode = false). Bool_t AddComment(void* node, const char* comment). void* GetParent(void* child). void* GetChild(void* parent, con",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMVA__Tools.html:9600,log,logger,9600,root/html528/TMVA__Tools.html,https://root.cern,https://root.cern/root/html528/TMVA__Tools.html,1,['log'],['logger']
Testability,"maximum entry in vector. Int_t GetIndexMinElement(vector<Double_t>& ); find index of minimum entry in vector. Bool_t ContainsRegularExpression(const TString& s); check if regular expression; helper function to search for ""$!%^&()'<>?= "" in a string. TString ReplaceRegularExpressions(const TString& s, const TString& replace = ""+""); replace regular expressions; helper function to remove all occurences ""$!%^&()'<>?= "" from a string; and replace all ::,$,*,/,+,- with _M_,_S_,_T_,_D_,_P_,_M_ respectively. const TString& Color(const TString& ); human readable color strings. void FormattedOutput(const vector<Double_t>& , const vector<TString>& , const TString titleVars, const TString titleValues, TMVA::MsgLogger& logger, TString format = ""%+1.3f""); formatted output of simple table. void FormattedOutput(const TMatrixD& , const vector<TString>& , TMVA::MsgLogger& logger); formatted output of matrix (with labels). void FormattedOutput(const TMatrixD& , const vector<TString>& vert, const vector<TString>& horiz, TMVA::MsgLogger& logger); formatted output of matrix (with labels). TString GetXTitleWithUnit(const TString& title, const TString& unit); histogramming utility. TString GetYTitleWithUnit(const TH1& h, const TString& unit, Bool_t normalised); histogramming utility. void WriteFloatArbitraryPrecision(Float_t val, ostream& os); writes a float value with the available precision to a stream. void ReadFloatArbitraryPrecision(Float_t& val, istream& is); reads a float value with the available precision from a stream. Bool_t HasAttr(void* node, const char* attrname); add attribute from xml. void ReadAttr(void* node, const char* attrname, TString& value); add attribute from xml. void AddAttr(void* node, const char* attrname, const char* value); add attribute to node. void* AddChild(void* parent, const char* childname, const char* content = 0, bool isRootNode = false); add child node. Bool_t AddComment(void* node, const char* comment). void* GetParent(void* child); get parent node.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TMVA__Tools.html:9648,log,logger,9648,root/html530/TMVA__Tools.html,https://root.cern,https://root.cern/root/html530/TMVA__Tools.html,5,['log'],['logger']
Testability,"maximum values By default otherwise the domain is undefined, i.e. ; is [-inf,+inf] To remove the domain do a SetDomain(0,0). There is no possibility to have a domain defined in only one coordinate. Use instead inf or DOUBLE_MAX to specify un infinite domain in that coordinate ; Definition at line 103 of file TUnuranMultiContDist.h. SetMode(). void TUnuranMultiContDist::SetMode ; (; const double *; x). inline . set the mode of the distribution (coordinates of the distribution maximum values) ; Definition at line 112 of file TUnuranMultiContDist.h. Streamer(). void TUnuranMultiContDist::Streamer ; (; TBuffer &; ). overridevirtual . Reimplemented from TUnuranBaseDist. StreamerNVirtual(). void TUnuranMultiContDist::StreamerNVirtual ; (; TBuffer &; ClassDef_StreamerNVirtual_b). inline . Definition at line 176 of file TUnuranMultiContDist.h. Member Data Documentation. fIsLogPdf. bool TUnuranMultiContDist::fIsLogPdf. private . flag to control if function pointer represent log of pdf ; Definition at line 172 of file TUnuranMultiContDist.h. fMode. std::vector<double> TUnuranMultiContDist::fMode. private . vector representing the x coordinates of the maximum of the pdf ; Definition at line 170 of file TUnuranMultiContDist.h. fOwnFunc. bool TUnuranMultiContDist::fOwnFunc. private . flag to indicate if class manages the function pointers ; Definition at line 173 of file TUnuranMultiContDist.h. fPdf. const ROOT::Math::IMultiGenFunction* TUnuranMultiContDist::fPdf. private . Definition at line 166 of file TUnuranMultiContDist.h. fXmax. std::vector<double> TUnuranMultiContDist::fXmax. private . vector with upper x values of the domain ; Definition at line 169 of file TUnuranMultiContDist.h. fXmin. std::vector<double> TUnuranMultiContDist::fXmin. private . vector with lower x values of the domain ; Definition at line 168 of file TUnuranMultiContDist.h. Libraries for TUnuranMultiContDist:. [legend]; The documentation for this class was generated from the followi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTUnuranMultiContDist.html:10013,log,log,10013,doc/master/classTUnuranMultiContDist.html,https://root.cern,https://root.cern/doc/master/classTUnuranMultiContDist.html,1,['log'],['log']
Testability,"maxiter (default = 100) controls the maximum number; of iteration of the Brent algorithm; If the flag logx is set the grid search is done in log step size; This is done automatically if the log scale is set in the current Pad. NOTE: see also TF1::GetX. Double_t GetMinimum(Double_t xmin = 0, Double_t xmax = 0, Double_t epsilon = 1.E-10, Int_t maxiter = 100, Bool_t logx = false) const; Returns the minimum value of the function on the (xmin, xmax) interval; Method:; First, the grid search is used to bracket the maximum; with the step size = (xmax-xmin)/fNpx. This way, the step size; can be controlled via the SetNpx() function. If the function is; unimodal or if its extrema are far apart, setting the fNpx to; a small value speeds the algorithm up many times.; Then, Brent's method is applied on the bracketed interval; epsilon (default = 1.E-10) controls the relative accuracy (if |x| > 1 ); and absolute (if |x| < 1) and maxiter (default = 100) controls the maximum number; of iteration of the Brent algorithm; If the flag logx is set the grid search is done in log step size; This is done automatically if the log scale is set in the current Pad. NOTE: see also TF1::GetMaximumX and TF1::GetX. Double_t GetMinimumX(Double_t xmin = 0, Double_t xmax = 0, Double_t epsilon = 1.E-10, Int_t maxiter = 100, Bool_t logx = false) const; Returns the X value corresponding to the minimum value of the function; on the (xmin, xmax) interval; Method:; First, the grid search is used to bracket the maximum; with the step size = (xmax-xmin)/fNpx. This way, the step size; can be controlled via the SetNpx() function. If the function is; unimodal or if its extrema are far apart, setting the fNpx to; a small value speeds the algorithm up many times.; Then, Brent's method is applied on the bracketed interval; epsilon (default = 1.E-10) controls the relative accuracy (if |x| > 1 ); and absolute (if |x| < 1) and maxiter (default = 100) controls the maximum number; of iteration of the Brent algorithm; If",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TF1.html:41661,log,logx,41661,root/html528/TF1.html,https://root.cern,https://root.cern/root/html528/TF1.html,12,['log'],"['log', 'logx']"
Testability,"mbers(TMemberInspector&); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); voidToggleOdometerInfos(); voidToggleThreshold(). private:. Float_tAdjustBytes(Float_t mbs, TString& sf). Data Members; public:. enum EQueryStatus { kRunning; kDone; kStopped; kAborted; kIncomplete; };. private:. TGTextButton*fAbort; TGraph*fActWGraph; TGTextButton*fAsyn; Double_tfAvgMBRate; Double_tfAvgRate; TGProgressBar*fBarprogress bar; TGTextButton*fClose; TGTransientFrame*fDialogtransient frame, main dialog window; TGraph*fEffSGraph; TTimefEndTime; Long64_tfEntries; TGTextEntry*fEntry; TGLabel*fEstim; Int_tfFiles; TGLabel*fFilesEvents; Long64_tfFirst; TGLabel*fInit; Float_tfInitTime; Bool_tfKeep; TGCheckButton*fKeepToggle; TGTextButton*fLog; Bool_tfLogQuery; TGCheckButton*fLogQueryToggle; TProofProgressLog*fLogWindowtransient frame for logs; TGraph*fMBRtGraph; TGTextButton*fMemPlot; TProofProgressMemoryPlot*fMemWindowtransient frame for memory plots; Long64_tfPrevProcessed; Long64_tfPrevTotal; Float_tfProcTime; TGLabel*fProcessed; TProof*fProof; TGLabel*fRate; TGraph*fRateGraph; TGTextButton*fRatePlot; TNtuple*fRatePoints; Int_tfRightInfo; Int_tfSVNRev; TGLabel*fSelector; TStringfSessionUrl; TGCheckButton*fSmoothSpeedouse smooth speedometer update; TGSpeedo*fSpeedospeedometer; Bool_tfSpeedoEnabledwhether to enable the speedometer; TTimefStartTime; TProofProgressDialog::EQueryStatusfStatus; TGTextButton*fStop; TGTextBuffer*fTextQuery; TGLabel*fTimeLab; TGLabel*fTitleLab; TGraph*fTotSGraph; TGLabel*fTotal; TGTextButton*fUpdtSpeedo; static Bool_tfgKeepDefault; static Bool_tfgLogQueryDefault; static TStringfgTextQueryDefault. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TProofProgressDialog(TProof* proof, const char* selector, Int_t files, Long64_t first, Long64_t entries); Create PROOF processing progress dialog. void ToggleOdometerInfos(); Toggle information displayed in Analog Meter. void ToggleThresh",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TProofProgressDialog.html:2351,log,logs,2351,root/html534/TProofProgressDialog.html,https://root.cern,https://root.cern/root/html534/TProofProgressDialog.html,1,['log'],['logs']
Testability,"mbers; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. Long64_tfFromstarting offset of the current content; TProofLog*fLoggerparent TProofLog; TMacro*fMacrocontainer for the log lines; TStringfRolerole (master-submaster-worker); Long64_tfSizebest knowledge of the log file size; Long64_tfToend offset of the current content; static Long64_tfgMaxTransferSize. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void Display(const char *ord = ""*"", Int_t from = -10, Int_t to = -1). Int_t Grep(const char *txt, Int_t from = 0). void Print(Option_t* opt = 0) const. void Prt(const char* what). Int_t Retrieve(const char *ord = ""*"", TProofLog::ERetrieveOpt opt = TProofLog::kTrailing, const char *fname = 0, const char *pattern = 0). void SetMaxTransferSize(Long64_t maxsz). TProofLogElem(const char* ord, const char* url, TProofLog* logger); the name of TProofLogElem is the ordinal number of the corresp. worker; the title is the url. TMacro * GetMacro() const; { return fMacro; }. const char * GetRole(); { return fRole.Data(); }. Bool_t IsMaster() const; { return (fRole == ""master"") ? kTRUE : kFALSE; }. Bool_t IsSubMaster() const; { return (fRole == ""submaster"") ? kTRUE : kFALSE; }. Bool_t IsWorker() const; { return (fRole == ""worker"") ? kTRUE : kFALSE; }. Long64_t GetMaxTransferSize().  Author: G. Ganis 31/08/06  Copyright (C) 1995-2006, Rene Brun and Fons Rademakers. *;  Last changed: root/proof:$Id: TProofLog.h 28808 2009-06-04 14:18:34Z ganis $  Last generated: 2010-09-23 20:19; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TProofLogElem.html:6684,log,logger,6684,root/html528/TProofLogElem.html,https://root.cern,https://root.cern/root/html528/TProofLogElem.html,1,['log'],['logger']
Testability,"mbers; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. Long64_tfFromstarting offset of the current content; TProofLog*fLoggerparent TProofLog; TMacro*fMacrocontainer for the log lines; TStringfRolerole (master-submaster-worker); Long64_tfSizebest knowledge of the log file size; Long64_tfToend offset of the current content; static Long64_tfgMaxTransferSize. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void Display(const char *ord = ""*"", Int_t from = -10, Int_t to = -1). Int_t Grep(const char *txt, Int_t from = 0). void Print(Option_t* opt = 0) const. void Prt(const char* what). Int_t Retrieve(const char *ord = ""*"", TProofLog::ERetrieveOpt opt = TProofLog::kTrailing, const char *fname = 0, const char *pattern = 0). void SetMaxTransferSize(Long64_t maxsz). TProofLogElem(const char* ord, const char* url, TProofLog* logger); the name of TProofLogElem is the ordinal number of the corresp. worker; the title is the url. TMacro * GetMacro() const; { return fMacro; }. const char * GetRole(); { return fRole.Data(); }. Bool_t IsMaster() const; { return (fRole == ""master"") ? kTRUE : kFALSE; }. Bool_t IsSubMaster() const; { return (fRole == ""submaster"") ? kTRUE : kFALSE; }. Bool_t IsWorker() const; { return (fRole == ""worker"") ? kTRUE : kFALSE; }. Long64_t GetMaxTransferSize().  Author: G. Ganis 31/08/06  Copyright (C) 1995-2006, Rene Brun and Fons Rademakers. *;  Last changed: root/proof:$Id: TProofLog.h 28808 2009-06-04 14:18:34Z ganis $  Last generated: 2011-07-04 15:36; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TProofLogElem.html:6755,log,logger,6755,root/html530/TProofLogElem.html,https://root.cern,https://root.cern/root/html530/TProofLogElem.html,1,['log'],['logger']
Testability,"mbers; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. Long64_tfFromstarting offset of the current content; TProofLog*fLoggerparent TProofLog; TMacro*fMacrocontainer for the log lines; TStringfRolerole (master-submaster-worker); Long64_tfSizebest knowledge of the log file size; Long64_tfToend offset of the current content; static Long64_tfgMaxTransferSize. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void Display(const char *ord = ""*"", Int_t from = -10, Int_t to = -1). Int_t Grep(const char *txt, Int_t from = 0). void Print(Option_t* opt = 0) const. void Prt(const char* what). Int_t Retrieve(const char *ord = ""*"", TProofLog::ERetrieveOpt opt = TProofLog::kTrailing, const char *fname = 0, const char *pattern = 0). void SetMaxTransferSize(Long64_t maxsz). TProofLogElem(const char* ord, const char* url, TProofLog* logger); the name of TProofLogElem is the ordinal number of the corresp. worker; the title is the url. TMacro * GetMacro() const; { return fMacro; }. const char * GetRole(); { return fRole.Data(); }. Bool_t IsMaster() const; { return (fRole == ""master"") ? kTRUE : kFALSE; }. Bool_t IsSubMaster() const; { return (fRole == ""submaster"") ? kTRUE : kFALSE; }. Bool_t IsWorker() const; { return (fRole == ""worker"") ? kTRUE : kFALSE; }. Long64_t GetMaxTransferSize().  Author: G. Ganis 31/08/06  Copyright (C) 1995-2006, Rene Brun and Fons Rademakers. *;  Last changed: root/proof:$Id: TProofLog.h 28808 2009-06-04 14:18:34Z ganis $  Last generated: 2011-11-03 20:21; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TProofLogElem.html:6755,log,logger,6755,root/html532/TProofLogElem.html,https://root.cern,https://root.cern/root/html532/TProofLogElem.html,1,['log'],['logger']
Testability,"mbie(); TBenchmark&operator=(const TBenchmark&); TBenchmark(const TBenchmark&). Data Members; public:. static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. Float_t*fCpuTime[fNbench] Cpu Time; TStringTNamed::fNameobject identifier; TString*fNames[fNbench] Names of benchmarks; Int_tfNbenchNumber of active benchmarks; Int_tfNmaxMaximum number of benchmarks initialized; Float_t*fRealTime[fNbench] Real Time; TStopwatch*fTimerTimers; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBenchmark(); Benchmark default constructor. TBenchmark(const TBenchmark& ); Copy constructor. TBenchmark& operator=(const TBenchmark& ); Assignment operator. ~TBenchmark(); Benchmark destructor. Int_t GetBench(const char* name) const; Returns index of Benchmark name. Float_t GetCpuTime(const char* name); Returns Cpu time used by Benchmark name. Float_t GetRealTime(const char* name); Returns Realtime used by Benchmark name. void Print(Option_t* name = """") const; Prints parameters of Benchmark name. void Reset(); Reset all Benchmarks. void Show(const char* name); Stops Benchmark name and Prints results. void Start(const char* name); Starts Benchmark with the specified name. An independent timer (see class TStopwatch) is started.; The name of th",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TBenchmark.html:6271,benchmark,benchmarks,6271,root/html602/TBenchmark.html,https://root.cern,https://root.cern/root/html602/TBenchmark.html,6,['benchmark'],['benchmarks']
Testability,"mdataset/weights/TMVAClassification_PyKeras_LSTM.class.C[0m; Factory : Training finished; : ; Factory : Train method: BDTG for Classification; : ; : ; : [1m================================================================[0m; : [1mH e l p f o r M V A m e t h o d [ BDTG ] :[0m; : ; : [1m--- Short description:[0m; : ; : Boosted Decision Trees are a collection of individual decision; : trees which form a multivariate classifier by (weighted) majority ; : vote of the individual trees. Consecutive decision trees are ; : trained using the original training data set with re-weighted ; : events. By default, the AdaBoost method is employed, which gives ; : events that were misclassified in the previous tree a larger ; : weight in the training of the following tree.; : ; : Decision trees are a sequence of binary splits of the data sample; : using a single discriminant variable at a time. A test event ; : ending up after the sequence of left-right splits in a final ; : (""leaf"") node is classified as either signal or background; : depending on the majority type of training events in that node.; : ; : [1m--- Performance optimisation:[0m; : ; : By the nature of the binary splits performed on the individual; : variables, decision trees do not deal well with linear correlations; : between variables (they need to approximate the linear split in; : the two dimensional space by a sequence of splits on the two ; : variables individually). Hence decorrelation could be useful ; : to optimise the BDT performance.; : ; : [1m--- Performance tuning via configuration options:[0m; : ; : The two most important parameters in the configuration are the ; : minimal number of events requested by a leaf node as percentage of the ; : number of training events (option ""MinNodeSize"" replacing the actual number ; : of events ""nEventsMin"" as given in earlier versions; : If this number is too large, detailed features ; : in the parameter space are hard to be modelled. If it is too small, ; : the ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVA__RNN__Classification_8py.html:31149,test,test,31149,doc/master/TMVA__RNN__Classification_8py.html,https://root.cern,https://root.cern/doc/master/TMVA__RNN__Classification_8py.html,1,['test'],['test']
Testability,"me = 0); HybridResult default constructor (with name ). HybridResult(const char* name, const vector<double>& testStat_sb_vals, const vector<double>& testStat_b_vals, bool sumLargerValues = true); HybridResult constructor (with name, title and vectors of S+B and B values). ~HybridResult(); HybridResult destructor. void SetDataTestStatistics(double testStat_data_val); set the value of the test statistics on data. double NullPValue() const; return 1-CL_b : the B p-value. double AlternatePValue() const; return CL_s+b : the S+B p-value. Double_t CLbError() const; Returns an estimate of the error on CLb assuming a binomial error on; CLb:. Double_t CLsplusbError() const; Returns an estimate of the error on CLsplusb assuming a binomial; error on CLsplusb:. Double_t CLsError() const; Returns an estimate of the error on CLs through combination of the; errors on CLb and CLsplusb:. void Add(RooStats::HybridResult* other); add additional toy-MC experiments to the current results; use the data test statistics of the added object if none is already present (otherwise, ignore the new one). HybridPlot* GetPlot(const char* name, const char* title, int n_bins); prepare a plot showing a result and return a pointer to a HybridPlot object; the needed arguments are: an object name, a title and the number of bins in the plot. void PrintMore(const char* options); Print out some information about the results. explicit HybridResult(const char* name = 0); Default constructor. std::vector<double> GetTestStat_sb(); Get test statistics values for the sb model. {return fTestStat_sb;}. std::vector<double> GetTestStat_b(); Get test statistics values for the b model. {return fTestStat_b;}. double GetTestStat_data(); Get test statistics value for data. { return fTestStat_data;}.  Last changed: root/roostats:$Id$  Last generated: 2015-03-10 17:19; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooStats__HybridResult.html:12177,test,test,12177,root/html534/RooStats__HybridResult.html,https://root.cern,https://root.cern/root/html534/RooStats__HybridResult.html,3,['test'],['test']
Testability,"me = 0); HybridResult default constructor (with name ). HybridResult(const char* name, const vector<double>& testStat_sb_vals, const vector<double>& testStat_b_vals, bool sumLargerValues = true); HybridResult constructor (with name, title and vectors of S+B and B values). ~HybridResult(); HybridResult destructor. void SetDataTestStatistics(double testStat_data_val); set the value of the test statistics on data. double NullPValue() const; return 1-CL_b : the B p-value. double AlternatePValue() const; return CL_s+b : the S+B p-value. Double_t CLbError() const; Returns an estimate of the error on CLb assuming a binomial error on; CLb:. Double_t CLsplusbError() const; Returns an estimate of the error on CLsplusb assuming a binomial; error on CLsplusb:. Double_t CLsError() const; Returns an estimate of the error on CLs through combination of the; errors on CLb and CLsplusb:. void Add(RooStats::HybridResult* other); add additional toy-MC experiments to the current results; use the data test statistics of the added object if none is already present (otherwise, ignore the new one). HybridPlot* GetPlot(const char* name, const char* title, int n_bins); prepare a plot showing a result and return a pointer to a HybridPlot object; the needed arguments are: an object name, a title and the number of bins in the plot. void PrintMore(const char* options); Print out some information about the results. explicit HybridResult(const char* name = 0); Default constructor. std::vector<double> GetTestStat_sb(); Get test statistics values for the sb model. {return fTestStat_sb;}. std::vector<double> GetTestStat_b(); Get test statistics values for the b model. {return fTestStat_b;}. double GetTestStat_data(); Get test statistics value for data. { return fTestStat_data;}.  Last changed: root/roostats:$Id$  Last generated: 2015-06-02 15:34; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/RooStats__HybridResult.html:12608,test,test,12608,root/html604/RooStats__HybridResult.html,https://root.cern,https://root.cern/root/html604/RooStats__HybridResult.html,3,['test'],['test']
Testability,"me = 0); HybridResult default constructor (with name ). HybridResult(const char* name, const vector<double>& testStat_sb_vals, const vector<double>& testStat_b_vals, bool sumLargerValues = true); HybridResult constructor (with name, title and vectors of S+B and B values). ~HybridResult(); HybridResult destructor. void SetDataTestStatistics(double testStat_data_val); set the value of the test statistics on data. double NullPValue() const; return 1-CL_b : the B p-value. double AlternatePValue() const; return CL_s+b : the S+B p-value. Double_t CLbError() const; Returns an estimate of the error on CLb assuming a binomial error on; CLb:. Double_t CLsplusbError() const; Returns an estimate of the error on CLsplusb assuming a binomial; error on CLsplusb:. Double_t CLsError() const; Returns an estimate of the error on CLs through combination of the; errors on CLb and CLsplusb:. void Add(RooStats::HybridResult* other); add additional toy-MC experiments to the current results; use the data test statistics of the added object if none is already present (otherwise, ignore the new one). HybridPlot* GetPlot(const char* name, const char* title, int n_bins); prepare a plot showing a result and return a pointer to a HybridPlot object; the needed arguments are: an object name, a title and the number of bins in the plot. void PrintMore(const char* options); Print out some information about the results. explicit HybridResult(const char* name = 0); Default constructor. std::vector<double> GetTestStat_sb(); Get test statistics values for the sb model. {return fTestStat_sb;}. std::vector<double> GetTestStat_b(); Get test statistics values for the b model. {return fTestStat_b;}. double GetTestStat_data(); Get test statistics value for data. { return fTestStat_data;}.  Last changed: root/roostats:$Id$  Last generated: 2015-06-30 14:36; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooStats__HybridResult.html:12608,test,test,12608,root/html602/RooStats__HybridResult.html,https://root.cern,https://root.cern/root/html602/RooStats__HybridResult.html,3,['test'],['test']
Testability,me TNtuple from different threads ; mt201_parallelHistoFill.C Parallel fill of a histogram ; mt301_TTaskGroupSimple.C Shows how to run items of work asynchronously with a TTaskGroup ; mt302_TTaskGroupNested.C Calculate Fibonacci numbers exploiting nested parallelism through TTaskGroup ; mt303_AsyncSimple.C Shows how to run items of work asynchronously with Async ; mt304_AsyncNested.C Calculate Fibonacci numbers exploiting nested parallelism through Async ; mt304_fillHistos.CFill histograms in parallel with automatic binning ; mt305_TFuture.C Shows how to use the Future class of ROOT as a wrapper of std::future ; mtbb001_fillHistos.C Fill histograms in parallel and write them on file ; mtbb101_fillNtuples.C Fill n-tuples in distinct workers ; mtbb201_parallelHistoFill.C Parallel fill of a histogram ; net; alien.C Example of use of the TAlien class (an implementation of TGrid) ; authclient.CThis macro should be run together with authserv.C to test authentication between two remote ROOT sessions ; authserv.CThis macro should be run together with authclient.C to test authentication between two remote ROOT sessions ; fastMergeServer.CThis script shows how to make a simple iterative server that can receive TMemFile from multiple clients and merge them into a single file without block ; hclient.CClient program which creates and fills a histogram ; hclientbonj.CClient program which creates and fills a histogram ; hcons.CHistogram consumer script ; hprod.CHistogram producer script ; hserv.CServer program which waits for two clients to connect ; hserv2.CThis script shows how to make a simple iterative server that can accept connections while handling currently open connections ; hserv2bonj.CThis script shows how to make a simple iterative server that can accept connections while handling currently open connections ; LDAPExample.C; parallelMergeClient.CClient program which creates and fills 2 histograms and a TTree ; parallelMergeServer.CThis script ,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v612/files.html:136079,test,test,136079,doc/v612/files.html,https://root.cern,https://root.cern/doc/v612/files.html,1,['test'],['test']
Testability,"me behavior for general and symmetric matrices; in contrast to the iterator access methods which behave differently (it follows the data order).; SMatrix33 m;; m(0,0) = 1; // set the element in first row and first column; *(m.begin()+1) = 2; // set the second element (0,1); double d[9]={1,2,3,4,5,6,7,8,9};; m.SetElements(d,d+9); // set the d[] values in m; double x = m(2,1); // return the element in 3; x = m.apply(7); // return the 8-th element (row=2,col=1); x = *(m.begin()+7); // return the 8-th element (row=2,col=1); // symmetric matrices; //(note the difference in behavior between apply and the iterators); x = *(m.begin()+4) // return the element (row=2,col=1); x = m.apply(7); // returns again the (row=2,col=1) element; There are methods to place and/or retrieve ROOT::Math::SVector objects as rows or columns in (from) a matrix. In addition one can put (get) a sub-matrix as another ROOT::Math::SMatrix object in a matrix. If the size of the sub-vector or sub-matrix is larger than the matrix size a static assert (a compilation error) is produced. The non-const methods are:; SMatrix33 m;; SVector2 v2(1,2);; // place a vector in the first row from; // element (0,1) : m(0,1)=v2[0]; m.Place_in_row(v2,0,1);; // place the vector in the second column from; // (0,1) : m(0,1) = v2[0]; m.Place in_col(v2,0,1);; SMatrix22 m2;; // place m2 in m starting from the; // element (1,1) : m(1,1) = m2(0,0); m.Place_at(m2,1,1);; SVector3 v3(1,2,3);; // set v3 as the diagonal elements; // of m : m(i,i) = v3[i] for i=0,1,2; m.SetDiagonal(v3); The const methods retrieving contents (getting slices of a matrix) are:; a = {1,2,3,4,5,6,7,8,9};; SMatrix33 m(a,a+9);; SVector3 irow = m.Row(0); // return as vector the first row; SVector3 jcol = m.Col(1); // return as vector the second column. // return a slice of the first row from; // (0,1): r2[0]= m(0,1); r2[1]=m(0,2); SVector2 r2 = m.SubRow<SVector2> (0,1);; // return a slice of the second column from; // (0,1): c2[0] = m(0,1); c2[1] = m(1,1); ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:758807,assert,assert,758807,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['assert'],['assert']
Testability,"me rules for building a valid geometry. The daughter volume(s) must not extrude the mother shape. They are allowed however to have a common boundaries.; The volumes positioned in the same container must not overlap with each other. They may touch on one boundaries or shape vertex. The daughter nodes of a volume can be also removed or replaced with other nodes:; void RemoveNode(TGeoNode* node); TGeoNode*ReplaceNode(TGeoNode* nodeorig, TGeoShape* newshape = 0,; TGeoMatrix* newpos = 0, TGeoMedium* newmed = 0); TGeoNodeA node represent a volume positioned inside another.They store links to both volumes and to the TGeoM...Definition TGeoNode.h:39; TGeoShapeBase abstract class for all shapes.Definition TGeoShape.h:25; The last method allows replacing an existing daughter of a volume with another one. Providing only the node to be replaced will just create a new volume for the node but having exactly the same parameters as the old one. This helps in case of divisions for decoupling a node from the logical hierarchy so getting new content/properties. For non-divided volumes, one can change the shape and/or the position of the daughter.; Virtual Containers and Assemblies of Volumes; Virtual containers are volumes that do not represent real objects, but they are needed for grouping and positioning together other volumes. Such grouping helps not only geometry creation, but also optimizes tracking performance; therefore, it is highly recommended. Virtual volumes need to inherit material/medium properties from the volume they are placed into in order to be ""invisible"" at tracking time.; Let us suppose that we need to group together two volumes A and B into a structure and position this into several other volumes D,E, and F. What we need to do is to create a virtual container volume C holding A and B, then position C in the other volumes.; Note that C is a volume having a determined medium. Since it is not a real volume, we need to manually set its medium the same as that of D,E ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__Geometry.html:31054,log,logical,31054,doc/master/group__Geometry.html,https://root.cern,https://root.cern/doc/master/group__Geometry.html,1,['log'],['logical']
Testability,"me(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. private:. TGTextButton*fCancelcancel button; TGLabel*fLabeltext entry label; TGTextButton*fOkok button; char*fRetStraddress to store return string; TGTextEntry*fTEtext entry widget. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGInputDialog(const TGWindow* p = 0, const TGWindow* main = 0, const char* prompt = 0, const char* defval = 0, char* retstr = 0, UInt_t options = kVerticalFrame); Create simple input dialog. It is important to know that the case where the constructor in; which all the variables are initialized to their default values is; only used for the TBrowser to inspect on the classes. For normal; use the only variable that should be free is options. Variables prompt, defval are the content of the input dialog while; retstr has to be initialized to a char[256]. In case these are not; initialized, they will show default values while retstr will be; automatically allocated by the dialog. However this will make; impossible to retrieve the value entered by the dialog. To see TGInputDialog in use see:; $ROOTSYS/tutorials/testInputDialog.cxx. ~TGInputDialog(); Cleanup dialog. Bool_t ProcessMessage(Long_t msg, Long_t parm1, Long_t ); Handle button and text enter events. TGInputDialog(const TGInputDialog& ). TGInputDialog & operator=(const TGInputDialog& ).  Author: David Gonzalez Maline 19/07/2006  Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *;  Last changed: root/gui:$Id$  Last generated: 2015-03-13 19:25; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGInputDialog.html:22918,test,testInputDialog,22918,root/html534/TGInputDialog.html,https://root.cern,https://root.cern/root/html534/TGInputDialog.html,1,['test'],['testInputDialog']
Testability,"me(h->fFile, kReadPermission)) {; 1735 Error(""ShowOutput"", ""file '%s' cannot be read"", h->fFile.Data());; 1736 return;; 1737 }; 1738 ; 1739 // Open the file; 1740 FILE *f = nullptr;; 1741 if (!(f = fopen(h->fFile.Data(), ""r""))) {; 1742 Error(""ShowOutput"", ""file '%s' cannot be open"", h->fFile.Data());; 1743 return;; 1744 }; 1745 ; 1746 // Determine the number of bytes to be read from the file.; 1747 off_t ltot = lseek(fileno(f), (off_t) 0, SEEK_END);; 1748 Int_t begin = (h->fReadOffSet > 0 && h->fReadOffSet < ltot) ? h->fReadOffSet : 0;; 1749 lseek(fileno(f), (off_t) begin, SEEK_SET);; 1750 Int_t left = ltot - begin;; 1751 ; 1752 // Now readout from file; 1753 const Int_t kMAXBUF = 16384;; 1754 char buf[kMAXBUF];; 1755 Int_t wanted = (left > kMAXBUF-1) ? kMAXBUF-1 : left;; 1756 Int_t len;; 1757 do {; 1758 while ((len = read(fileno(f), buf, wanted)) < 0 &&; 1759 TSystem::GetErrno() == EINTR); 1760 TSystem::ResetErrno();; 1761 ; 1762 if (len < 0) {; 1763 SysError(""ShowOutput"", ""error reading log file"");; 1764 break;; 1765 }; 1766 ; 1767 // Null-terminate; 1768 buf[len] = 0;; 1769 fprintf(stderr,""%s"", buf);; 1770 ; 1771 // Update counters; 1772 left -= len;; 1773 wanted = (left > kMAXBUF) ? kMAXBUF : left;; 1774 ; 1775 } while (len > 0 && left > 0);; 1776 ; 1777 // Do not display twice the same thing; 1778 h->fReadOffSet = ltot;; 1779 fclose(f);; 1780}; 1781 ; 1782//---- Dynamic Loading ---------------------------------------------------------; 1783 ; 1784////////////////////////////////////////////////////////////////////////////////; 1785/// Add a new directory to the dynamic path.; 1786 ; 1787void TSystem::AddDynamicPath(const char *); 1788{; 1789 AbstractMethod(""AddDynamicPath"");; 1790}; 1791 ; 1792////////////////////////////////////////////////////////////////////////////////; 1793/// Return the dynamic path (used to find shared libraries).; 1794 ; 1795const char *TSystem::GetDynamicPath(); 1796{; 1797 AbstractMethod(""GetDynamicPath"");; 1798 return nullptr;; 1799};",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TSystem_8cxx_source.html:56804,log,log,56804,doc/master/TSystem_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html,1,['log'],['log']
Testability,"me) != 0) {; 521 fprintf(stderr,""Error in TClassTable::AddAlternate: ""; 522 ""Second registration of %s with a different normalized name (old: '%s', new: '%s')\n"",; 523 alternate, a->fNormName, normName);; 524 }; 525 return nullptr;; 526 }; 527 }; 528 ; 529 fgAlternate[slot] = new TClassAlt(alternate,normName,fgAlternate[slot]);; 530 return fgAlternate[slot];; 531}; 532 ; 533////////////////////////////////////////////////////////////////////////////////; 534///; 535void TClassTable::RemoveAlternate(ROOT::TClassAlt *alt); 536{; 537 if (!alt || !gClassTable); 538 return;; 539 ; 540 std::lock_guard<std::mutex> lock(GetClassTableMutex());; 541 ; 542 UInt_t slot = ROOT::ClassTableHash(alt->fName, fgSize);; 543 ; 544 if (!fgAlternate[slot]); 545 return;; 546 ; 547 if (fgAlternate[slot] == alt); 548 fgAlternate[slot] = alt->fNext.release();; 549 else {; 550 for (TClassAlt *a = fgAlternate[slot]; a; a = a->fNext.get()) {; 551 if (a->fNext.get() == alt) {; 552 a->fNext.swap( alt->fNext );; 553 assert( alt == alt->fNext.get());; 554 alt->fNext.release();; 555 }; 556 }; 557 }; 558 delete alt;; 559}; 560 ; 561////////////////////////////////////////////////////////////////////////////////; 562 ; 563Bool_t TClassTable::Check(const char *cname, std::string &normname); 564{; 565 if (!CheckClassTableInit()); 566 return kFALSE;; 567 ; 568 std::lock_guard<std::mutex> lock(GetClassTableMutex());; 569 ; 570 UInt_t slot = ROOT::ClassTableHash(cname, fgSize);; 571 ; 572 // Check if 'cname' is a known normalized name.; 573 for (TClassRec *r = fgTable[slot]; r; r = r->fNext); 574 if (strcmp(cname,r->fName)==0) return kTRUE;; 575 ; 576 // See if 'cname' is register in the list of alternate names; 577 for (const TClassAlt *a = fgAlternate[slot]; a; a = a->fNext.get()) {; 578 if (strcmp(cname,a->fName)==0) {; 579 normname = a->fNormName;; 580 return kTRUE;; 581 }; 582 }; 583 ; 584 return kFALSE;; 585}; 586 ; 587////////////////////////////////////////////////////////////////////////////////; 5",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TClassTable_8cxx_source.html:18429,assert,assert,18429,doc/master/TClassTable_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TClassTable_8cxx_source.html,2,['assert'],['assert']
Testability,"me) const; Bool_tRooAbsArg::isCloneOf(const RooAbsArg& other) const; Bool_tRooAbsArg::isConstant() const; Bool_tisConvolved(); virtual Bool_tRooAbsArg::isDerived() const; virtual Bool_tRooAbsPdf::isDirectGenSafe(const RooAbsArg& arg) const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; virtual Bool_tRooAbsArg::isFundamental() const; virtual Bool_tRooAbsArg::isLValue() const; Bool_tTObject::IsOnHeap() const; Bool_tRooAbsArg::isShapeDirty() const; Bool_tRooAbsArg::isShapeServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isShapeServer(const char* name) const; virtual Bool_tRooAbsArg::IsSortable() const; Bool_tRooAbsArg::isValueDirty() const; Bool_tRooAbsArg::isValueServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isValueServer(const char* name) const; Bool_tTObject::IsZombie() const; voidRooAbsArg::leafNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; voidRooAbsReal::logEvalError(const char* message, const char* serverValueString = 0) const; static voidRooAbsReal::logEvalError(const RooAbsReal* originator, const char* origName, const char* message, const char* serverValueString = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooMoment*RooAbsReal::mean(RooRealVar& obs); RooMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); Int_tRooAbsPdf::minDimNormValueCaching() const; virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tRooAbsPdf::mustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); virtual voidnormLeafServerList(RooArgSet& list) const; const char*RooAbsPd",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooResolutionModel.html:21206,log,logEvalError,21206,root/html528/RooResolutionModel.html,https://root.cern,https://root.cern/root/html528/RooResolutionModel.html,2,['log'],['logEvalError']
Testability,"me) const; Bool_tRooAbsArg::isCloneOf(const RooAbsArg& other) const; Bool_tRooAbsArg::isConstant() const; Bool_tisConvolved(); virtual Bool_tRooAbsArg::isDerived() const; virtual Bool_tRooAbsPdf::isDirectGenSafe(const RooAbsArg& arg) const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; virtual Bool_tRooAbsArg::isFundamental() const; virtual Bool_tRooAbsArg::isLValue() const; Bool_tTObject::IsOnHeap() const; Bool_tRooAbsArg::isShapeDirty() const; Bool_tRooAbsArg::isShapeServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isShapeServer(const char* name) const; virtual Bool_tRooAbsArg::IsSortable() const; Bool_tRooAbsArg::isValueDirty() const; Bool_tRooAbsArg::isValueServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isValueServer(const char* name) const; Bool_tTObject::IsZombie() const; voidRooAbsArg::leafNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; voidRooAbsReal::logEvalError(const char* message, const char* serverValueString = 0) const; static voidRooAbsReal::logEvalError(const RooAbsReal* originator, const char* origName, const char* message, const char* serverValueString = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooMoment*RooAbsReal::mean(RooRealVar& obs); RooMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); Int_tRooAbsPdf::minDimNormValueCaching() const; virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tRooAbsPdf::mustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); virtual voidnormLeafServerList(RooArgSet& list) const; virtual Bool_tTObje",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooResolutionModel.html:21144,log,logEvalError,21144,root/html526/RooResolutionModel.html,https://root.cern,https://root.cern/root/html526/RooResolutionModel.html,1,['log'],['logEvalError']
Testability,"me) const; Bool_tTObject::IsZombie() const; voidRooAbsArg::leafNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; Bool_tRooAbsArg::localNoDirtyInhibit() const; const RooCatType*RooAbsCategory::lookupType(Int_t index, Bool_t printError = kFALSE) const; const RooCatType*RooAbsCategory::lookupType(const char* label, Bool_t printError = kFALSE) const; const RooCatType*RooAbsCategory::lookupType(const RooCatType& type, Bool_t printError = kFALSE) const; virtual voidTNamed::ls(Option_t* option = """") const; Bool_tmap(const char* inKeyRegExp, const char* outKeyName, Int_t outKeyNum = NoCatIdx); voidTObject::MayNotUse(const char* method) const; static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; Int_tRooAbsCategory::numTypes(const char* = 0) const; Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); Bool_tRooAbsCategory::operator!=(Int_t index); Bool_tRooAbsCategory::operator!=(const char* label); Bool_tRooAbsCategory::operator!=(const RooAbsArg& other); TNamed&TNamed::operator=(const TNamed& rhs); Bool_tRooAbsCategory::operator==(Int_t index) const; Bool_tRooAbsCategory::operator==(const char* label) const; virtual Bool_tRooAbsCategory::operator==(const RooAbsArg& other); RooAbsArg::OperM",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooMappedCategory.html:10372,test,testArg,10372,root/html534/RooMappedCategory.html,https://root.cern,https://root.cern/root/html534/RooMappedCategory.html,1,['test'],['testArg']
Testability,"me) const; Bool_tTObject::IsZombie() const; voidRooAbsArg::leafNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; Bool_tRooAbsArg::localNoDirtyInhibit() const; const RooCatType*RooAbsCategory::lookupType(Int_t index, Bool_t printError = kFALSE) const; const RooCatType*RooAbsCategory::lookupType(const char* label, Bool_t printError = kFALSE) const; const RooCatType*RooAbsCategory::lookupType(const RooCatType& type, Bool_t printError = kFALSE) const; virtual voidTNamed::ls(Option_t* option = """") const; Bool_tmap(const char* inKeyRegExp, const char* outKeyName, Int_t outKeyNum = NoCatIdx); voidTObject::MayNotUse(const char* method) const; static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; Int_tRooAbsCategory::numTypes(const char* = 0) const; Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); Bool_tRooAbsCategory::operator!=(Int_t index); Bool_tRooAbsCategory::operator!=(const char* label); Bool_tRooAbsCategory::operator!=(const RooAbsArg& other); RooMappedCategory&operator=(const RooMappedCategory&); Bool_tRooAbsCategory::operator==(Int_t index) const; Bool_tRooAbsCategory::operator==(const char* label) const; virtual Bool_tRooAbsCategory::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::oper",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooMappedCategory.html:10125,test,testArg,10125,root/html602/RooMappedCategory.html,https://root.cern,https://root.cern/root/html602/RooMappedCategory.html,2,['test'],['testArg']
Testability,"me);; 8234}; 8235 ; 8236ClassInfo_t* TCling::ClassInfo_Factory(DeclId_t declid) const; 8237{; 8238 R__LOCKGUARD(gInterpreterMutex);; 8239 return (ClassInfo_t*) new TClingClassInfo(GetInterpreterImpl(), (const clang::Decl*)declid);; 8240}; 8241 ; 8242 ; 8243////////////////////////////////////////////////////////////////////////////////; 8244 ; 8245int TCling::ClassInfo_GetMethodNArg(ClassInfo_t* cinfo, const char* method, const char* proto, Bool_t objectIsConst /* = false */, EFunctionMatchMode mode /* = kConversionMatch */) const; 8246{; 8247 TClingClassInfo* TClinginfo = (TClingClassInfo*) cinfo;; 8248 return TClinginfo->GetMethodNArg(method, proto, objectIsConst, mode);; 8249}; 8250 ; 8251////////////////////////////////////////////////////////////////////////////////; 8252 ; 8253bool TCling::ClassInfo_HasDefaultConstructor(ClassInfo_t* cinfo, Bool_t testio) const; 8254{; 8255 TClingClassInfo *TClinginfo = (TClingClassInfo *) cinfo;; 8256 return TClinginfo->HasDefaultConstructor(testio) != ROOT::TMetaUtils::EIOCtorCategory::kAbsent;; 8257}; 8258 ; 8259////////////////////////////////////////////////////////////////////////////////; 8260 ; 8261bool TCling::ClassInfo_HasMethod(ClassInfo_t* cinfo, const char* name) const; 8262{; 8263 TClingClassInfo* TClinginfo = (TClingClassInfo*) cinfo;; 8264 return TClinginfo->HasMethod(name);; 8265}; 8266 ; 8267////////////////////////////////////////////////////////////////////////////////; 8268 ; 8269void TCling::ClassInfo_Init(ClassInfo_t* cinfo, const char* name) const; 8270{; 8271 R__LOCKGUARD(gInterpreterMutex);; 8272 TClingClassInfo* TClinginfo = (TClingClassInfo*) cinfo;; 8273 TClinginfo->Init(name);; 8274}; 8275 ; 8276////////////////////////////////////////////////////////////////////////////////; 8277 ; 8278void TCling::ClassInfo_Init(ClassInfo_t* cinfo, int tagnum) const; 8279{; 8280 R__LOCKGUARD(gInterpreterMutex);; 8281 TClingClassInfo* TClinginfo = (TClingClassInfo*) cinfo;; 8282 TClinginfo->Init(tagnum);; 8283}; 8",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCling_8cxx_source.html:321687,test,testio,321687,doc/master/TCling_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html,1,['test'],['testio']
Testability,"me*fFC; TGCompositeFrame*fFD; TGCompositeFrame*fFEfive tabs element; TGLabel*fInfoLine[19]infos on session; TGTextView*fInfoTextViewsummary on current query; TGListBox*fLBPackagespackages listbox; TGNumberEntry*fLogLevellog level number entry; TGTab*fTabmain tab frame; TGTextEntry*fTxtParallelparallel nodes text entry; TSessionViewer*fViewerpointer on main viewer. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TSessionFrame(TGWindow* parent, Int_t w, Int_t h); Constructor. ~TSessionFrame(); Destructor. void Build(TSessionViewer* gui); Build session frame. void ProofInfos(); Display informations on current session. void OnBtnUploadDSet(); Open Upload Dataset dialog. void UpdateListOfDataSets(); Update list of dataset present on the cluster. void OnBtnRemoveDSet(); Remove dataset from the list and from the cluster. void OnBtnVerifyDSet(); Verify that the files in the selected dataset are present on the cluster. void OnApplyLogLevel(); Apply selected log level on current session. void OnApplyParallel(); Apply selected number of workers on current Proof session. void OnMultipleSelection(Bool_t on); Handle multiple selection check button. void OnStartupEnable(Bool_t on); Handle multiple selection check button. void UpdatePackages(); Update list of packages. void OnUploadPackages(); Upload selected package(s) to the current session. void OnEnablePackages(); Enable selected package(s) in the current session. void OnDisablePackages(); Disable selected package(s) in the current session. void OnClearPackages(); Clear (disable) all packages in the current session. void OnBtnAddClicked(); Open file dialog and add selected package file to the list. void OnBtnRemoveClicked(); Remove selected package from the list. void OnBtnUpClicked(); Move selected package entry one position up in the list. void OnBtnDownClicked(); Move selected package entry one position down in the list. void OnBtnDisconnectClicked(); Disconnect from current Proof se",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TSessionFrame.html:21598,log,log,21598,root/html528/TSessionFrame.html,https://root.cern,https://root.cern/root/html528/TSessionFrame.html,3,['log'],['log']
Testability,"me, instead of being sent back at the end in one go. This may help debugging or monitoring in some cases, but, depending on the amount of log, it may have significant consequencies on the load over the network, so it must be used with care. ; Definition at line 7096 of file TProof.cxx. SetRunStatus(). void TProof::SetRunStatus ; (; ERunStatus; rst). inlineprivate . Definition at line 672 of file TProof.h. SetupWorkersEnv(). void TProof::SetupWorkersEnv ; (; TList *; wrks, . Bool_t; increasingpool = kFALSE. ). protected . Set up packages, loaded macros, include and lib paths ... ; Definition at line 1528 of file TProof.cxx. ShowCache(). void TProof::ShowCache ; (; Bool_t; all = kFALSE). virtual . List contents of file cache. ; If all is true show all caches also on slaves. If everything is ok all caches are to be the same. ; Reimplemented in TProofLite.; Definition at line 7691 of file TProof.cxx. ShowData(). void TProof::ShowData ; (; ). virtual . List contents of the data directory in the sandbox. ; This is the place where files produced by the client queries are kept ; Reimplemented in TProofLite.; Definition at line 7396 of file TProof.cxx. ShowDataSet(). void TProof::ShowDataSet ; (; const char *; dataset = """", . const char *; opt = ""filter:SsCc"". ). display meta-info for given dataset usi ; Definition at line 10977 of file TProof.cxx. ShowDataSetCache(). void TProof::ShowDataSetCache ; (; const char *; dataset = 0). virtual . Display the content of the dataset cache, if any (matching 'dataset', if defined). ; Reimplemented in TProofLite.; Definition at line 10914 of file TProof.cxx. ShowDataSetQuota(). void TProof::ShowDataSetQuota ; (; Option_t *; opt = 0). shows the quota and usage of all groups if opt contains ""U"" shows also distribution of usage on user-level ; Definition at line 11309 of file TProof.cxx. ShowDataSets(). void TProof::ShowDataSets ; (; const char *; uri = """", . const char *; optStr = """". ). virtual . Shows datase",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProof.html:148205,sandbox,sandbox,148205,doc/master/classTProof.html,https://root.cern,https://root.cern/doc/master/classTProof.html,1,['sandbox'],['sandbox']
Testability,"me.IsNull()) {; 721 Error(""TF1"", ""requires a proper function name!"");; 722 return;; 723 }; 724 ; 725 fMethodCall = std::make_unique<TMethodCall>();; 726 fMethodCall->InitWithPrototype(fName, ""Double_t*,Double_t*"");; 727 ; 728 if (! fMethodCall->IsValid()) {; 729 Error(""TF1"", ""No function found with the signature %s(Double_t*,Double_t*)"", name);; 730 return;; 731 }; 732}; 733 ; 734 ; 735////////////////////////////////////////////////////////////////////////////////; 736/// Constructor using a pointer to a real function.; 737///; 738/// \param[in] name object name; 739/// \param[in] fcn pointer to function; 740/// \param[in] xmin,xmax x axis limits; 741/// \param[in] npar is the number of free parameters used by the function; 742/// \param[in] ndim number of dimensions; 743/// \param[in] addToGlobList boolean marking if it should be added to global list; 744///; 745/// This constructor creates a function of type C when invoked; 746/// with the normal C++ compiler.; 747///; 748/// see test program test/stress.cxx (function stress1) for an example.; 749/// note the interface with an intermediate pointer.; 750///; 751/// \warning A function created with this constructor cannot be Cloned.; 752 ; 753TF1::TF1(const char *name, Double_t (*fcn)(Double_t *, Double_t *), Double_t xmin, Double_t xmax, Int_t npar, Int_t ndim, EAddToList addToGlobList) :; 754 TF1(EFType::kPtrScalarFreeFcn, name, xmin, xmax, npar, ndim, addToGlobList, new TF1Parameters(npar), new TF1FunctorPointerImpl<double>(ROOT::Math::ParamFunctor(fcn))); 755{}; 756 ; 757////////////////////////////////////////////////////////////////////////////////; 758/// Constructor using a pointer to (const) real function.; 759///; 760/// \param[in] name object name; 761/// \param[in] fcn pointer to function; 762/// \param[in] xmin,xmax x axis limits; 763/// \param[in] npar is the number of free parameters used by the function; 764/// \param[in] ndim number of dimensions; 765/// \param[in] addToGlobList boolean marking if ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TF1_8cxx_source.html:25393,test,test,25393,doc/master/TF1_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html,2,['test'],['test']
Testability,"meFormat line by; axis->SetLabelOffset(0.15);; axis->SetTimeFormat(""#splitline{%Y}{%d\/%m}"");; TGaxis::SetLabelOffsetvoid SetLabelOffset(Float_t labeloffset)Definition TGaxis.h:106; will produce the following axis:. The following example shows time axis on a TGraph:; {; TDatime da1(2008,02,28,15,52,00);; TDatime da2(2008,02,28,15,53,00);; ; double x[2],y[2];; ; y[0] = 1.;; y[1] = 2.;; x[0] = da1.Convert();; x[1] = da2.Convert();; ; TGraph mgr(2,x,y);; mgr.SetMarkerStyle(20);; ; mgr.Draw(""apl"");; mgr.GetXaxis()->SetTimeDisplay(1);; mgr.GetXaxis()->SetNdivisions(-503);; mgr.GetXaxis()->SetTimeFormat(""%Y-%m-%d %H:%M"");; mgr.GetXaxis()->SetTimeOffset(0,""gmt"");; }; TGraphA TGraph is an object made of two arrays X and Y with npoints each.Definition TGraph.h:41; yDouble_t y[n]Definition legend1.C:17; xDouble_t x[n]Definition legend1.C:17. The following example compares what the system time function gmtime and localtime give with what gives TGaxis. It can be used as referenced test to check if the time option of TGaxis is working properly.; ; #include ""TAxis.h""; #include ""TGaxis.h""; #include ""TCanvas.h""; #include ""TString.h""; #include ""TLine.h""; #include ""TLatex.h""; #include <ctime>; #include <cstdio>; ; TString stime(time_t* t, bool utc = false, bool display_time_zone = true) {; struct tm* tt;; if (utc) tt = gmtime(t);; else tt = localtime(t);; char buf[256];; if (display_time_zone) strftime(buf, sizeof(buf), ""%Y-%m-%d %H:%M:%S %Z"", tt);; else strftime(buf, sizeof(buf), ""%Y-%m-%d %H:%M:%S"", tt);; return TString(buf);; }; ; ; void timeonaxis3() {; double f = 1.8;; ; auto c = new TCanvas;; ; TLatex tex1;; tex1.SetNDC();; tex1.SetTextFont(102);; tex1.SetTextSize(0.055*f);; ; TLatex tex3;; tex3.SetNDC();; tex3.SetTextFont(102);; tex3.SetTextSize(0.07*f);; tex3.SetTextColor(kBlue+2);; ; TLatex tex2;; tex2.SetNDC();; tex2.SetTextFont(102);; tex2.SetTextSize(0.07*f);; tex2.SetTextColor(kOrange+3);; ; time_t offset[] = {0, 0, 1325376000, 1341100800};; time_t t[] = {1331150400, 1336",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGaxis.html:27336,test,test,27336,doc/master/classTGaxis.html,https://root.cern,https://root.cern/doc/master/classTGaxis.html,1,['test'],['test']
Testability,"mean(RooRealVar& obs); RooMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); Int_tRooAbsPdf::minDimNormValueCaching() const; virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tRooAbsPdf::mustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; virtual voidnormLeafServerList(RooArgSet& list) const; const char*RooAbsPdf::normRange() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TNamed&TNamed::operator=(const TNamed& rhs); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; con",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooResolutionModel.html:23450,test,testArg,23450,root/html532/RooResolutionModel.html,https://root.cern,https://root.cern/root/html532/RooResolutionModel.html,1,['test'],['testArg']
Testability,"mean, fParams[1] = sigma for a Gaussian)Definition GoFTest.h:239; ROOT::Math::GoFTest::ETestTypeETestTypeGoodness of Fit test types for using with the class's unary functions as a shorthand for the in-built...Definition GoFTest.h:85; ROOT::Math::GoFTest::kKS@ kKSAnderson-Darling 2-Samples Test.Definition GoFTest.h:88; ROOT::Math::GoFTest::kAD@ kADDefinition GoFTest.h:86; ROOT::Math::GoFTest::kKS2s@ kKS2sKolmogorov-Smirnov Test.Definition GoFTest.h:89; ROOT::Math::GoFTest::kAD2s@ kAD2sAnderson-Darling Test. Default value.Definition GoFTest.h:87; ROOT::Math::GoFTest::SetSamplesvoid SetSamples(std::vector< const Double_t * > samples, const std::vector< size_t > samplesSizes)set a vector of samplesDefinition GoFTest.cxx:181; ROOT::Math::GoFTest::PValueADKSamplesstatic Double_t PValueADKSamples(size_t nsamples, Double_t A2)Computation of the K-Sample Anderson-Darling Test's p-value as described in (1)Definition GoFTest.cxx:353; ROOT::Math::GoFTest::LogSamplevoid LogSample()Applies the logarithm to the sample when the specified distribution to test is LogNormal.Definition GoFTest.cxx:303; ROOT::Math::GoFTest::~GoFTestvirtual ~GoFTest()Definition GoFTest.cxx:179; ROOT::Math::GoFTest::SetDistributionvoid SetDistribution(EDistribution dist, const std::vector< double > &distParams={})Sets the distribution for the predefined distribution types and optionally its parameters for 1-sampl...Definition GoFTest.cxx:124; ROOT::Math::GoFTest::GaussianCDFDouble_t GaussianCDF(Double_t x) constDefinition GoFTest.cxx:295; ROOT::Math::GoFTest::AndersonDarling2SamplesTestvoid AndersonDarling2SamplesTest(Double_t &pvalue, Double_t &testStat) constPerforms the Anderson-Darling 2-Sample Test.Definition GoFTest.cxx:646; ROOT::Math::GoFTest::GoFTestGoFTest()Disallowed default constructor.; ROOT::Math::GoFTest::KolmogorovSmirnov2SamplesTestvoid KolmogorovSmirnov2SamplesTest(Double_t &pvalue, Double_t &testStat) constKolmogorov-Smirnov 2-Samples Test.Definition GoFTest.cxx:896; ROOT::Math::GoFTest",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/GoFTest_8cxx_source.html:41347,log,logarithm,41347,doc/master/GoFTest_8cxx_source.html,https://root.cern,https://root.cern/doc/master/GoFTest_8cxx_source.html,2,"['log', 'test']","['logarithm', 'test']"
Testability,"mean, sigma_g1);; ; RooRealVar sigma_g2(""sigma_g2"", ""width of g2"", 4, 3.0, 6.0);; RooGaussian g2(""g2"", ""g2"", x, mean, sigma_g2);; ; RooRealVar frac(""frac"", ""frac"", 0.5, 0.0, 1.0);; RooAddPdf model(""model"", ""model"", RooArgList(g1, g2), frac);; ; // Generate 1000 events; std::unique_ptr<RooDataSet> data{model.generate(x, 1000)};; ; // Construct unbinned likelihood of model w.r.t. data; std::unique_ptr<RooAbsReal> nll{model.createNLL(*data)};; ; // I n t e r a c t i v e m i n i m i z a t i o n , e r r o r a n a l y s i s; // -------------------------------------------------------------------------------; ; // Create MINUIT interface object; RooMinimizer m(*nll);; ; // Activate verbose logging of MINUIT parameter space stepping; m.setVerbose(true);; ; // Call MIGRAD to minimize the likelihood; m.migrad();; ; // Print values of all parameters, that reflect values (and error estimates); // that are back propagated from MINUIT; std::unique_ptr<RooArgSet>{model.getParameters(x)}->Print(""s"");; ; // Disable verbose logging; m.setVerbose(false);; ; // Run HESSE to calculate errors from d2L/dp2; m.hesse();; ; // Print value (and error) of sigma_g2 parameter, that reflects; // value and error back propagated from MINUIT; sigma_g2.Print();; ; // Run MINOS on sigma_g2 parameter only; m.minos(sigma_g2);; ; // Print value (and error) of sigma_g2 parameter, that reflects; // value and error back propagated from MINUIT; sigma_g2.Print();; ; // S a v i n g r e s u l t s , c o n t o u r p l o t s; // ---------------------------------------------------------; ; // Save a snapshot of the fit result. This object contains the initial; // fit parameters, the final fit parameters, the complete correlation; // matrix, the EDM, the minimized FCN , the last MINUIT status code and; // the number of times the RooFit function object has indicated evaluation; // problems (e.g. zero probabilities during likelihood evaluation); std::unique_ptr<RooFitResult> fitResult{m.save()};; ; // Make contour plot",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf601__intminuit_8C.html:1957,log,logging,1957,doc/master/rf601__intminuit_8C.html,https://root.cern,https://root.cern/doc/master/rf601__intminuit_8C.html,1,['log'],['logging']
Testability,"med into; foam). - cell - cell to start searching with (usually root cell; fCells[0]). - cells - list of cells found. std::vector<TMVA::PDEFoamCell*> FindCells(vector<Float_t>& ); Find all cells, that contain txvec. This function can be used,; when the dimension of the foam is greater than the dimension of; txvec. E.G this is the case for multi-target regression. Parameters:. - txvec - vector of variables (no targets!) (transformed into; foam). Return value:. - vector of cells, that fit txvec. TH1D* Draw1Dim(const char* opt, Int_t nbin); Draws 1-dimensional foam (= histogram). Parameters:. - opt - cell_value, rms, rms_ov_mean; if cell_value is set, the following values will be filled into; the result histogram:; - number of events - in case of classification with 2 separate; foams or multi-target regression; - discriminator - in case of classification with one; unified foam; - target - in case of mono-target regression. - nbin - number of bins of result histogram. Warning: This function is not well tested!. TH2D* Project2(Int_t idim1, Int_t idim2, const char* opt = ""cell_value"", const char* ker = ""kNone"", UInt_t maxbins = 50); Project foam variable idim1 and variable idim2 to histogram. Parameters:. - idim1, idim2 - dimensions to project to. - opt - cell_value, rms, rms_ov_mean; if cell_value is set, the following values will be filled into; the result histogram:; - number of events - in case of classification with 2 separate; foams or multi-target regression; - discriminator - in case of classification with one; unified foam; - target - in case of mono-target regression. - ker - kGaus, kNone (warning: Gaus may be very slow!). - nbin - number of bins in x and y direction of result histogram. Returns:; a 2-dimensional histogram. Double_t GetProjectionCellValue(TMVA::PDEFoamCell* cell, Int_t idim1, Int_t idim2, TMVA::ECellValue cv); Helper function for projection function Project2(). It returns; the cell value of 'cell' corresponding to the given option 'cv'.; The two",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMVA__PDEFoam.html:24955,test,tested,24955,root/html528/TMVA__PDEFoam.html,https://root.cern,https://root.cern/root/html528/TMVA__PDEFoam.html,1,['test'],['tested']
Testability,"med)""]; : H: ""False"" [Print method-specific help message]; : InputLayout: ""1|1|300"" [The Layout of the input]; : Layout: ""DENSE|64|TANH,DENSE|TANH|64,DENSE|TANH|64,LINEAR"" [Layout of the network.]; : ErrorStrategy: ""CROSSENTROPY"" [Loss function: Mean squared error (regression) or cross entropy (binary classification).]; : WeightInitialization: ""XAVIER"" [Weight initialization strategy]; : RandomSeed: ""0"" [Random seed used for weight initialization and batch shuffling]; : Architecture: ""CPU"" [Which architecture to perform the training on.]; : TrainingStrategy: ""LearningRate=1e-3,Momentum=0.0,Repetitions=1,ConvergenceSteps=10,BatchSize=256,TestRepetitions=1,WeightDecay=1e-4,Regularization=None,MaxEpochs=20DropConfig=0.0+0.+0.+0.,Optimizer=ADAM"" [Defines the training strategies.]; : - Default:; : VerbosityLevel: ""Default"" [Verbosity level]; : CreateMVAPdfs: ""False"" [Create PDFs for classifier outputs (signal and background)]; : IgnoreNegWeightsInTraining: ""False"" [Events with negative weights are ignored in the training (but are included for testing and performance evaluation)]; : BatchLayout: ""0|0|0"" [The Layout of the batch]; : ValidationSize: ""20%"" [Part of the training data to use for validation. Specify as 0.2 or 20% to use a fifth of the data set as validation set. Specify as 100 to use exactly 100 events. (Default: 20%)]; : Will now use the CPU architecture with BLAS and IMT support !; Model: ""sequential""; _________________________________________________________________; Layer (type) Output Shape Param # ; =================================================================; reshape (Reshape) (None, 10, 30) 0 ; ; lstm (LSTM) (None, 10, 10) 1640 ; ; flatten (Flatten) (None, 100) 0 ; ; dense (Dense) (None, 64) 6464 ; ; dense_1 (Dense) (None, 2) 130 ; ; =================================================================; Total params: 8234 (32.16 KB); Trainable params: 8234 (32.16 KB); Non-trainable params: 0 (0.00 Byte); ________________________________________________",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVA__RNN__Classification_8C.html:10724,test,testing,10724,doc/master/TMVA__RNN__Classification_8C.html,https://root.cern,https://root.cern/doc/master/TMVA__RNN__Classification_8C.html,1,['test'],['testing']
Testability,"med)""]; : H: ""False"" [Print method-specific help message]; : InputLayout: ""1|1|300"" [The Layout of the input]; : Layout: ""DENSE|64|TANH,DENSE|TANH|64,DENSE|TANH|64,LINEAR"" [Layout of the network.]; : ErrorStrategy: ""CROSSENTROPY"" [Loss function: Mean squared error (regression) or cross entropy (binary classification).]; : WeightInitialization: ""XAVIER"" [Weight initialization strategy]; : RandomSeed: ""0"" [Random seed used for weight initialization and batch shuffling]; : Architecture: ""CPU"" [Which architecture to perform the training on.]; : TrainingStrategy: ""LearningRate=1e-3,Momentum=0.0,Repetitions=1,ConvergenceSteps=10,BatchSize=256,TestRepetitions=1,WeightDecay=1e-4,Regularization=None,MaxEpochs=20DropConfig=0.0+0.+0.+0.,Optimizer=ADAM"" [Defines the training strategies.]; : - Default:; : VerbosityLevel: ""Default"" [Verbosity level]; : CreateMVAPdfs: ""False"" [Create PDFs for classifier outputs (signal and background)]; : IgnoreNegWeightsInTraining: ""False"" [Events with negative weights are ignored in the training (but are included for testing and performance evaluation)]; : BatchLayout: ""0|0|0"" [The Layout of the batch]; : ValidationSize: ""20%"" [Part of the training data to use for validation. Specify as 0.2 or 20% to use a fifth of the data set as validation set. Specify as 100 to use exactly 100 events. (Default: 20%)]; : Will now use the CPU architecture with BLAS and IMT support !; Running with nthreads = 4; --- RNNClassification : Using input file: time_data_t10_d30.root; number of variables is 300; vars_time0[0]; vars_time0[1]; vars_time0[2]; vars_time0[3]; vars_time0[4]; vars_time0[5]; vars_time0[6]; vars_time0[7]; vars_time0[8]; vars_time0[9]; vars_time0[10]; vars_time0[11]; vars_time0[12]; vars_time0[13]; vars_time0[14]; vars_time0[15]; vars_time0[16]; vars_time0[17]; vars_time0[18]; vars_time0[19]; vars_time0[20]; vars_time0[21]; vars_time0[22]; vars_time0[23]; vars_time0[24]; vars_time0[25]; vars_time0[26]; vars_time0[27]; vars_time0[28]; vars_time0[29",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVA__RNN__Classification_8py.html:6188,test,testing,6188,doc/master/TMVA__RNN__Classification_8py.html,https://root.cern,https://root.cern/doc/master/TMVA__RNN__Classification_8py.html,1,['test'],['testing']
Testability,"med] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TApplication*fAppRemoteCurrent remote application, if defined; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static TList*fgApplicationsList of available applications. private:. TApplicationImp*fAppImp!Window system specific application implementation; Int_tfArgcNumber of com mand line arguments; char**fArgvCommand line arguments; TApplication::EExitOnExceptionfExitOnExceptionExit on exception option; TObjArray*fFilesArray of input files (TObjString's) specified via argv; TStringfIdleCommandCommand to execute while application is idle; TTimer*fIdleTimerIdle timer; Bool_tfIsRunningTrue when in event loop (Run() has been called); Bool_tfNoLogDo not process logon and logoff macros; Bool_tfNoLogoDo not show splash screen and welcome message; Bool_tfQuitExit after having processed input files; Bool_tfReturnFromRunWhen true return from Run(); TSignalHandler*fSigHandlerInterrupt handler; Bool_tfUseMemstatRun with TMemStat enabled; TStringfWorkDirWorking directory specified via argv; static Bool_tfgGraphInitTrue if graphics libs initialized; static Bool_tfgGraphNeededTrue if graphics libs need to be initialized. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TApplication(); Default ctor. Can be used by classes deriving from TApplication. TApplication(const char* appClassName, Int_t* argc, char** argv, void* options = 0, Int_t numOptions = 0); Create an application environment. The application environment; provides an interface to the graphics system and eventloop; (be it X, Windoze, MacOS or BeOS). After creating the application; object start the eventloop by calling its Run() method. T",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TApplication.html:11851,log,logon,11851,root/html528/TApplication.html,https://root.cern,https://root.cern/root/html528/TApplication.html,8,['log'],"['logoff', 'logon']"
Testability,"memory costly logical shapes, and retaining/discarding the physical placements as required. The viewer may decide to force the client to rebuild (republish) the scene (via a TPad repaint at present), and thus collect these objects if the internal viewer state changes. It does this presently by forcing a repaint on the attached TPad object - hence the reason for putting all publishing to the viewer in the attached pad objects Paint() method. We will likely remove this requirement in the future, indicating the rebuild request via a normal ROOT signal, which the client can detect. Physical IDs; TVirtualViewer3D provides for two methods of object addition:virtual Int_t AddObject(const TBuffer3D & buffer, Bool_t * addChildren = 0); virtual Int_t AddObject(UInt_t physicalID, const TBuffer3D & buffer, Bool_t * addChildren = 0); TBuffer3DGeneric 3D primitive description class.Definition TBuffer3D.h:18; bool; unsigned int; If you use the first (simple) case a viewer using logical/physical pairs SetSectionsValid(TBuffer3D::kBoundingBox); will generate IDs for each physical object internally. In the second you can specify a unique identifier from the client, which allows the viewer to be more efficient. It can now cache both logical and physical objects, and only discard physical objects no longer of interest as part of scene rebuilds. Child Objects; In many geometries there is a rigid containment hierarchy, and so if the viewer is not interested in a certain object due to limits/size then it will also not be interest in any of the contained branch of descendents. Both AddObject() methods have an addChildren parameter. The viewer will complete this (if passed) indicating if children (contained within the one just sent) are worth adding. Recycling TBuffer3D; Once add AddObject() has been called, the contents are copied to the viewer internally. You are free to destroy this object, or recycle it for the next object if suitable. ; Definition at line 17 of file TBuffer3D.h. Public",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTBuffer3D.html:8471,log,logical,8471,doc/master/classTBuffer3D.html,https://root.cern,https://root.cern/doc/master/classTBuffer3D.html,1,['log'],['logical']
Testability,"ment > . Bool_t TMatrixTAutoloadOps::operator== ; (; const TMatrixTBase< Element > &; m1, . const TMatrixTBase< Element > &; m2. ). Check to see if two matrices are identical. ; Definition at line 855 of file TMatrixTBase.cxx. operator==() [2/2]. template<class Element > . Bool_t TMatrixTAutoloadOps::operator== ; (; const TVectorT< Element > &; source1, . const TVectorT< Element > &; source2. ). Check to see if two vectors are identical. ; Definition at line 1386 of file TVectorT.cxx. operator>() [1/3]. template<class Element > . TMatrixT< Element > TMatrixTAutoloadOps::operator> ; (; const TMatrixT< Element > &; source1, . const TMatrixT< Element > &; source2. ). logical operation source1 > source2 ; Definition at line 2584 of file TMatrixT.cxx. operator>() [2/3]. template<class Element > . TMatrixT< Element > TMatrixTAutoloadOps::operator> ; (; const TMatrixT< Element > &; source1, . const TMatrixTSym< Element > &; source2. ). logical operation source1 > source2 ; Definition at line 2612 of file TMatrixT.cxx. operator>() [3/3]. template<class Element > . TMatrixT< Element > TMatrixTAutoloadOps::operator> ; (; const TMatrixTSym< Element > &; source1, . const TMatrixT< Element > &; source2. ). logical operation source1 > source2 ; Definition at line 2640 of file TMatrixT.cxx. operator>=() [1/3]. template<class Element > . TMatrixT< Element > TMatrixTAutoloadOps::operator>= ; (; const TMatrixT< Element > &; source1, . const TMatrixT< Element > &; source2. ). logical operation source1 >= source2 ; Definition at line 2649 of file TMatrixT.cxx. operator>=() [2/3]. template<class Element > . TMatrixT< Element > TMatrixTAutoloadOps::operator>= ; (; const TMatrixT< Element > &; source1, . const TMatrixTSym< Element > &; source2. ). logical operation source1 >= source2 ; Definition at line 2677 of file TMatrixT.cxx. operator>=() [3/3]. template<class Element > . TMatrixT< Element > TMatrixTAutoloadOps::operator>= ; (; const TMatrixTSym< El",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/namespaceTMatrixTAutoloadOps.html:36623,log,logical,36623,doc/master/namespaceTMatrixTAutoloadOps.html,https://root.cern,https://root.cern/doc/master/namespaceTMatrixTAutoloadOps.html,1,['log'],['logical']
Testability,"ment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tRooAbsPdf::mustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; const char*RooAbsPdf::normRange() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); Roo2DKeysPdf&operator=(const Roo2DKeysPdf&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsPdf::paramOn(RooPlot* frame, const RooAbsData* data, const char* label = """", Int_t sigDigits = 2, Option_t* options = ""NELU"", Double_t xmin = 0.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/Roo2DKeysPdf.html:23428,test,testArg,23428,root/html602/Roo2DKeysPdf.html,https://root.cern,https://root.cern/root/html602/Roo2DKeysPdf.html,2,['test'],['testArg']
Testability,"ment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tRooAbsPdf::mustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; const char*RooAbsPdf::normRange() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooBMixDecay&operator=(const RooBMixDecay&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsPdf::paramOn(RooPlot* frame, const RooAbsData* data, const char* label = """", Int_t sigDigits = 2, Option_t* options = ""NELU"", Double_t xmin = 0.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooBMixDecay.html:23921,test,testArg,23921,root/html602/RooBMixDecay.html,https://root.cern,https://root.cern/root/html602/RooBMixDecay.html,2,['test'],['testArg']
Testability,"ment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tRooAbsPdf::mustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; const char*RooAbsPdf::normRange() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooBernstein&operator=(const RooBernstein&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsPdf::paramOn(RooPlot* frame, const RooAbsData* data, const char* label = """", Int_t sigDigits = 2, Option_t* options = ""NELU"", Double_t xmin = 0.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooBernstein.html:23538,test,testArg,23538,root/html602/RooBernstein.html,https://root.cern,https://root.cern/root/html602/RooBernstein.html,2,['test'],['testArg']
Testability,"ment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tRooAbsPdf::mustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; const char*RooAbsPdf::normRange() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooCachedPdf&operator=(const RooCachedPdf&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsPdf::paramOn(RooPlot* frame, const RooAbsData* data, const char* label = """", Int_t sigDigits = 2, Option_t* options = ""NELU"", Double_t xmin = 0.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooCachedPdf.html:23511,test,testArg,23511,root/html602/RooCachedPdf.html,https://root.cern,https://root.cern/root/html602/RooCachedPdf.html,2,['test'],['testArg']
Testability,"ment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tRooAbsPdf::mustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; const char*RooAbsPdf::normRange() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooChebychev&operator=(const RooChebychev&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsPdf::paramOn(RooPlot* frame, const RooAbsData* data, const char* label = """", Int_t sigDigits = 2, Option_t* options = ""NELU"", Double_t xmin = 0.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooChebychev.html:23069,test,testArg,23069,root/html602/RooChebychev.html,https://root.cern,https://root.cern/root/html602/RooChebychev.html,2,['test'],['testArg']
Testability,"ment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tRooAbsPdf::mustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; const char*RooAbsPdf::normRange() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooExtendPdf&operator=(const RooExtendPdf&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsPdf::paramOn(RooPlot* frame, const RooAbsData* data, const char* label = """", Int_t sigDigits = 2, Option_t* options = ""NELU"", Double_t xmin = 0.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooExtendPdf.html:23690,test,testArg,23690,root/html602/RooExtendPdf.html,https://root.cern,https://root.cern/root/html602/RooExtendPdf.html,2,['test'],['testArg']
Testability,"ment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tRooAbsPdf::mustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; const char*RooAbsPdf::normRange() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooLognormal&operator=(const RooLognormal&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsPdf::paramOn(RooPlot* frame, const RooAbsData* data, const char* label = """", Int_t sigDigits = 2, Option_t* options = ""NELU"", Double_t xmin = 0.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooLognormal.html:23386,test,testArg,23386,root/html602/RooLognormal.html,https://root.cern,https://root.cern/root/html602/RooLognormal.html,2,['test'],['testArg']
Testability,"ment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tRooAbsPdf::mustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; const char*RooAbsPdf::normRange() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooNDKeysPdf&operator=(const RooNDKeysPdf&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsPdf::paramOn(RooPlot* frame, const RooAbsData* data, const char* label = """", Int_t sigDigits = 2, Option_t* options = ""NELU"", Double_t xmin = 0.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooNDKeysPdf.html:24005,test,testArg,24005,root/html602/RooNDKeysPdf.html,https://root.cern,https://root.cern/root/html602/RooNDKeysPdf.html,2,['test'],['testArg']
Testability,"ment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); Int_tRooAbsPdf::minDimNormValueCaching() const; virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tRooAbsPdf::mustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TNamed&TNamed::operator=(const TNamed& rhs); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsPdf::paramOn(RooPlot* frame, const RooAbsData* data, const char* label = """", Int_t sigDigits = 2, Option_t* options = ""NELU"", Double_t xmin = 0.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/Roo2DKeysPdf.html:21683,test,testArg,21683,root/html526/Roo2DKeysPdf.html,https://root.cern,https://root.cern/root/html526/Roo2DKeysPdf.html,65,['test'],['testArg']
Testability,"ment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tRooAbsPdf::mustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; const char*RooAbsPdf::normRange() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TNamed&TNamed::operator=(const TNamed& rhs); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsPdf::paramOn(RooPlot* frame, const RooAbsData* data, const char* label = """", Int_t sigDigits = 2, Option_t* options = ""NELU"", Double_t xmin = 0.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooAbsAnaConvPdf.html:24548,test,testArg,24548,root/html532/RooAbsAnaConvPdf.html,https://root.cern,https://root.cern/root/html532/RooAbsAnaConvPdf.html,10,['test'],['testArg']
Testability,"ment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tRooAbsPdf::mustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; virtual voidRooResolutionModel::normLeafServerList(RooArgSet& list) const; const char*RooAbsPdf::normRange() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooGaussModel&operator=(const RooGaussModel&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsPdf::paramOn(RooPlot* frame, const RooAbsData* data, const char* label = """", Int_t sigDigits = 2, Option_t* options = ""NELU"", Double_t xmin = 0.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooGaussModel.html:24029,test,testArg,24029,root/html602/RooGaussModel.html,https://root.cern,https://root.cern/root/html602/RooGaussModel.html,2,['test'],['testArg']
Testability,"ment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tRooAbsPdf::mustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; virtual voidRooResolutionModel::normLeafServerList(RooArgSet& list) const; const char*RooAbsPdf::normRange() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooTruthModel&operator=(const RooTruthModel&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsPdf::paramOn(RooPlot* frame, const RooAbsData* data, const char* label = """", Int_t sigDigits = 2, Option_t* options = ""NELU"", Double_t xmin = 0.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooTruthModel.html:24135,test,testArg,24135,root/html602/RooTruthModel.html,https://root.cern,https://root.cern/root/html602/RooTruthModel.html,2,['test'],['testArg']
Testability,"mentation) ; Definition at line 48 of file Ranking.h. Public Member Functions; Ranking (); default constructor ; ; Ranking (const TString &context, const TString &rankingDiscriminatorName); constructor ; ; virtual~Ranking (); destructor ; ; virtual voidAddRank (const Rank &rank); Add a new rank take ownership of it. ; ; virtual TClass *IsA () const; ; virtual voidPrint () const; get maximum length of variable names ; ; voidSetContext (const TString &context); ; voidSetDiscrName (const TString &discrName); ; virtual voidStreamer (TBuffer &); ; voidStreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b); . Static Public Member Functions; static TClass *Class (); ; static const char *Class_Name (); ; static constexpr Version_tClass_Version (); ; static const char *DeclFileName (); . Private Member Functions; MsgLogger &Log () const; . Private Attributes; TStringfContext; the ranking context ; ; MsgLogger *fLogger; ! message logger ; ; std::vector< TMVA::Rank >fRanking; vector of ranks ; ; TStringfRankingDiscriminatorName; the name of the ranking discriminator ; . #include <TMVA/Ranking.h>; Constructor & Destructor Documentation. Ranking() [1/2]. TMVA::Ranking::Ranking ; (; ). default constructor ; Definition at line 46 of file Ranking.cxx. Ranking() [2/2]. TMVA::Ranking::Ranking ; (; const TString &; context, . const TString &; rankingDiscriminatorName. ). constructor ; Definition at line 57 of file Ranking.cxx. ~Ranking(). TMVA::Ranking::~Ranking ; (; ). virtual . destructor ; Definition at line 68 of file Ranking.cxx. Member Function Documentation. AddRank(). void TMVA::Ranking::AddRank ; (; const Rank &; rank). virtual . Add a new rank take ownership of it. ; Definition at line 86 of file Ranking.cxx. Class(). static TClass * TMVA::Ranking::Class ; (; ). static . ReturnsTClass describing this class . Class_Name(). static const char * TMVA::Ranking::Class_Name ; (; ). static . ReturnsName of this class . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1Ranking.html:1326,log,logger,1326,doc/master/classTMVA_1_1Ranking.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1Ranking.html,1,['log'],['logger']
Testability,"mented from TGLCamera.; Definition at line 137 of file TGLCamera.cxx. Truck() [2/3]. Bool_t TGLOrthoCamera::Truck ; (; Int_t; xDelta, . Int_t; yDelta, . Bool_t; mod1, . Bool_t; mod2. ). overridevirtual . Truck the camera - 'move camera parallel to film plane'. ; Returns kTRUE is redraw required (camera change), kFALSE otherwise. ; Implements TGLCamera.; Definition at line 211 of file TGLOrthoCamera.cxx. Truck() [3/3]. virtual Bool_t TGLCamera::Truck ; (; Int_t; xDelta, . Int_t; yDelta, . Bool_t; mod1, . Bool_t; mod2. ). virtual . Implements TGLCamera. Zoom(). Bool_t TGLOrthoCamera::Zoom ; (; Int_t; delta, . Bool_t; mod1, . Bool_t; mod2. ). overridevirtual . Zoom the camera - 'adjust lens focal length, retaining camera position'. ; Arguments are:. 'delta' - mouse viewport delta (pixels) - +ive zoom in, -ive zoom out; 'mod1' / 'mod2' - sensitivity modifiers - see TGLCamera::AdjustAndClampVal(). For an orthographic camera dollying and zooming are identical and both equate logically to a rescaling of the viewport limits - without center shift. There is no perspective foreshortening or lens 'focal length'.; Returns kTRUE is redraw required (camera change), kFALSE otherwise. ; Implements TGLCamera.; Definition at line 168 of file TGLOrthoCamera.cxx. Member Data Documentation. fDefXSize. Double_t TGLOrthoCamera::fDefXSize. private . scene volume ; Definition at line 53 of file TGLOrthoCamera.h. fDefYSize. Double_t TGLOrthoCamera::fDefYSize. private . Definition at line 53 of file TGLOrthoCamera.h. fDollyToZoom. Bool_t TGLOrthoCamera::fDollyToZoom. private . Definition at line 44 of file TGLOrthoCamera.h. fEnableRotate. Bool_t TGLOrthoCamera::fEnableRotate. private . Definition at line 43 of file TGLOrthoCamera.h. fgZoomDeltaSens. UInt_t TGLOrthoCamera::fgZoomDeltaSens = 500. staticprivate . Definition at line 56 of file TGLOrthoCamera.h. fType. EType TGLOrthoCamera::fType. private . Definition at line 42 of file TGLOrthoCamera.h. fVolume. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGLOrthoCamera.html:28381,log,logically,28381,doc/master/classTGLOrthoCamera.html,https://root.cern,https://root.cern/doc/master/classTGLOrthoCamera.html,1,['log'],['logically']
Testability,"mented from TMVA::Configurable. StreamerNVirtual(). void TMVA::Reader::StreamerNVirtual ; (; TBuffer &; ClassDef_StreamerNVirtual_b). inline . Definition at line 164 of file Reader.h. Verbose(). Bool_t TMVA::Reader::Verbose ; (; void; ); const. inline . Definition at line 114 of file Reader.h. Member Data Documentation. fCalculateError. Bool_t TMVA::Reader::fCalculateError. private . error calculation mode ; Definition at line 152 of file Reader.h. fColor. Bool_t TMVA::Reader::fColor. private . color mode ; Definition at line 151 of file Reader.h. fDataInputHandler. DataInputHandler TMVA::Reader::fDataInputHandler. private . Definition at line 138 of file Reader.h. fDataSetInfo. DataSetInfo TMVA::Reader::fDataSetInfo. private . Definition at line 136 of file Reader.h. fDataSetManager. DataSetManager* TMVA::Reader::fDataSetManager. private . Definition at line 128 of file Reader.h. fLogger. MsgLogger* TMVA::Reader::fLogger. mutableprivate . ! message logger ; Definition at line 161 of file Reader.h. fMethodMap. std::map<TString, IMethod*> TMVA::Reader::fMethodMap. private . map of methods ; Definition at line 157 of file Reader.h. fMvaEventError. Double_t TMVA::Reader::fMvaEventError. private . per-event error returned by MVA ; Definition at line 154 of file Reader.h. fMvaEventErrorUpper. Double_t TMVA::Reader::fMvaEventErrorUpper. private . per-event error returned by MVA ; Definition at line 155 of file Reader.h. fSilent. Bool_t TMVA::Reader::fSilent. private . silent mode ; Definition at line 150 of file Reader.h. fTmpEvalVec. std::vector<Float_t> TMVA::Reader::fTmpEvalVec. private . temporary evaluation vector (if user input is v<double>) ; Definition at line 159 of file Reader.h. fVerbose. Bool_t TMVA::Reader::fVerbose. private . verbosity ; Definition at line 149 of file Reader.h. Libraries for TMVA::Reader:. [legend]; The documentation for this class was generated from the following files:; tmva/tmva/inc/TMVA/Reader.h; tmva/tmva/s",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1Reader.html:30856,log,logger,30856,doc/master/classTMVA_1_1Reader.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1Reader.html,1,['log'],['logger']
Testability,"merNVirtual (TBuffer &ClassDef_StreamerNVirtual_b); . Static Public Member Functions; static TClass *Class (); ; static const char *Class_Name (); ; static constexpr Version_tClass_Version (); ; static const char *DeclFileName (); ; Static Public Member Functions inherited from RooLegendre; static TClass *Class (); ; static const char *Class_Name (); ; static constexpr Version_tClass_Version (); ; static const char *DeclFileName (); ; Static Public Member Functions inherited from RooAbsReal; static TClass *Class (); ; static const char *Class_Name (); ; static constexpr Version_tClass_Version (); ; static voidclearEvalErrorLog (); Clear the stack of evaluation error messages. ; ; static const char *DeclFileName (); ; static RooNumIntConfig *defaultIntegratorConfig (); Returns the default numeric integration configuration for all RooAbsReals. ; ; static std::map< constRooAbsArg *, std::pair< std::string, std::list< RooAbsReal::EvalError > > >::iteratorevalErrorIter (); ; static ErrorLoggingModeevalErrorLoggingMode (); Return current evaluation error logging mode. ; ; static boolhideOffset (); ; static voidlogEvalError (const RooAbsReal *originator, const char *origName, const char *message, const char *serverValueString=nullptr); Interface to insert remote error logging messages received by RooRealMPFE into current error logging stream. ; ; static Int_tnumEvalErrorItems (); ; static Int_tnumEvalErrors (); Return the number of logged evaluation errors since the last clearing. ; ; static voidprintEvalErrors (std::ostream &os=std::cout, Int_t maxPerNode=10000000); Print all outstanding logged evaluation error on the given ostream. ; ; static voidsetEvalErrorLoggingMode (ErrorLoggingMode m); Set evaluation error logging mode. ; ; static voidsetHideOffset (bool flag); ; Static Public Member Functions inherited from RooAbsArg; static voidsetDirtyInhibit (bool flag); Control global dirty inhibit mode. ; ; static vo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooSpHarmonic.html:47173,log,logging,47173,doc/master/classRooSpHarmonic.html,https://root.cern,https://root.cern/doc/master/classRooSpHarmonic.html,1,['log'],['logging']
Testability,"mera; TGLPlotCoordinates*TGLPlotPainter::fCoord; Bool_tTGLPlotPainter::fDrawAxes; Bool_tTGLPlotPainter::fDrawPalette; Bool_tTGLPlotPainter::fHighColor; TH1*TGLPlotPainter::fHist; TPointTGLPlotPainter::fMousePosition; Double_tTGLPlotPainter::fPadPhi; Double_tTGLPlotPainter::fPadTheta; const Float_t*TGLPlotPainter::fPhysicalShapeColor; Int_tTGLPlotPainter::fSelectedPart; TGLSelectionBufferTGLPlotPainter::fSelection; Int_tTGLPlotPainter::fSelectionBase; Bool_tTGLPlotPainter::fSelectionPass; Bool_tTGLPlotPainter::fUpdateSelection; TAxis*TGLPlotPainter::fXAxis; Double_tTGLPlotPainter::fXOYSectionPos; Double_tTGLPlotPainter::fXOZSectionPos; TAxis*TGLPlotPainter::fYAxis; Double_tTGLPlotPainter::fYOZSectionPos; TAxis*TGLPlotPainter::fZAxis; vector<Double_t>TGLPlotPainter::fZLevels. private:. vector<Int_t>fBinColors; TStringfBinInfoUsed by GetPlotInfo.; list<Rgl::Pad::Tesselation_t>fCapsCaps for all bins.; vector<Double_t>fPolygonTemporary array for polygon's vertices.; Bool_tfZLogChange in logZ updates only bin heights.; Double_tfZMin. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGLH2PolyPainter(TH1* hist, TGLPlotCamera* camera, TGLPlotCoordinates* coord); Ctor. char * GetPlotInfo(Int_t px, Int_t py); Show number of bin and bin contents, if bin is under the cursor. Bool_t InitGeometry(); Tesselate polygons, if not done yet.; All pointers are validated here (and in functions called from here).; If any pointer is invalid - zero, or has unexpected type (dynamic_cast fails) -; InitGeometry will return false and nothing will be painted later.; That's why there are no checks in other functions. void StartPan(Int_t px, Int_t py); User clicks on a lego with middle mouse button (middle for pad). void Pan(Int_t px, Int_t py); Mouse events handler. void AddOption(const TString& stringOption); No additional options. void ProcessEvent(Int_t event, Int_t px, Int_t py); No events. void InitGL() const; Initialize some gl state variables. void D",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGLH2PolyPainter.html:4273,log,logZ,4273,root/html532/TGLH2PolyPainter.html,https://root.cern,https://root.cern/root/html532/TGLH2PolyPainter.html,2,['log'],['logZ']
Testability,"merical value accordingly. This can be useful to implement cursors; which move from data point to data point. For the message being sent; see ProcessMessage(). Bool_t ProcessMessage(Long_t msg, Long_t parm1, Long_t parm2); Process the up/down button messages. If fButtonToNum is false the; following message is sent: kC_COMMAND, kCM_BUTTON, widget id, param; param % 100 is the step size; param % 10000 / 100 != 0 indicates log step; param / 10000 != 0 indicates button down. TGLayoutManager * GetLayoutManager() const; Return layout manager. void ValueChanged(Long_t val); Emit ValueChanged(Long_t) signal. This signal is emitted when; fButtonToNum is false. The val has the following meaning:; val % 100 is the step size; val % 10000 / 100 != 0 indicates log step; val / 10000 != 0 indicates button down. void ValueSet(Long_t val); Emit ValueSet(Long_t) signal. This signal is emitted when the; number entry value is changed. The val has the following meaning:; val % 100 is the step size; val % 10000 / 100 != 0 indicates log step; val / 10000 != 0 indicates button down. void SavePrimitive(ostream& out, Option_t* = """"); Save a number entry widget as a C++ statement(s) on output stream out. void SetNumber(Double_t val). void SetIntNumber(Long_t val). void SetTime(Int_t hour, Int_t min, Int_t sec). void SetDate(Int_t year, Int_t month, Int_t day). void SetHexNumber(ULong_t val). void SetText(const char* text, Bool_t emit = kTRUE). Double_t GetNumber() const. Long_t GetIntNumber() const. void GetTime(Int_t& hour, Int_t& min, Int_t& sec) const. void GetDate(Int_t& year, Int_t& month, Int_t& day) const. ULong_t GetHexNumber() const. void IncreaseNumber(TGNumberFormat::EStepSize step = kNSSSmall, Int_t sign = 1, Bool_t logstep = kFALSE). void SetLimits(TGNumberFormat::ELimit limits = TGNumberFormat::kNELNoLimits, Double_t min = 0, Double_t max = 1). EStyle GetNumStyle() const; Get the numerical style. EAttribute GetNumAttr() const; Get the numerical attribute. ELimit GetNumLimits() con",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGNumberEntry.html:26499,log,log,26499,root/html528/TGNumberEntry.html,https://root.cern,https://root.cern/root/html528/TGNumberEntry.html,6,['log'],['log']
Testability,"message, const char* serverValueString = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooMoment*RooAbsReal::mean(RooRealVar& obs); RooMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); Int_tminDimNormValueCaching() const; virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tmustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); const char*normRange() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TNamed&TNamed::operator=(const TNamed& rhs); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const Ro",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooAbsPdf.html:24080,test,testArg,24080,root/html528/RooAbsPdf.html,https://root.cern,https://root.cern/root/html528/RooAbsPdf.html,1,['test'],['testArg']
Testability,"message, const char* serverValueString = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooMoment*RooAbsReal::mean(RooRealVar& obs); RooMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); Int_tminDimNormValueCaching() const; virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tmustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); const char*normRange() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TNamed&TNamed::operator=(const TNamed& rhs); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooAbsPdf.html:24213,test,testArg,24213,root/html530/RooAbsPdf.html,https://root.cern,https://root.cern/root/html530/RooAbsPdf.html,1,['test'],['testArg']
Testability,"messages at WARNING level; or higher (e.g. ERROR and FATAL) and for all INFO message on topics Generation,Plotting,; Integration and Minimization and redirects them to stdout. Users can create additional streams ; for logging of e.g. DEBUG messages on particular topics or objects and or redirect streams to; C++ streams or files.; ; The singleton instance is accessible through RooMsgService::instance() ;; . Function Members (Methods); public:. ~StreamConfig(); voidaddTopic(RooFit::MsgTopic newTopic); Bool_tmatch(RooFit::MsgLevel level, RooFit::MsgTopic facility, const RooAbsArg* obj); Bool_tmatch(RooFit::MsgLevel level, RooFit::MsgTopic facility, const TObject* obj); RooMsgService::StreamConfig&operator=(const RooMsgService::StreamConfig&); RooMsgService::StreamConfig&operator=(RooMsgService::StreamConfig&&); voidremoveTopic(RooFit::MsgTopic oldTopic); RooMsgService::StreamConfigStreamConfig(); RooMsgService::StreamConfigStreamConfig(const RooMsgService::StreamConfig&); RooMsgService::StreamConfigStreamConfig(RooMsgService::StreamConfig&&). Data Members; public:. Bool_tactive; stringbaseClassName; stringclassName; Color_tcolor; RooFit::MsgLevelminLevel; stringobjectName; ostream*os; Bool_tprefix; stringtagName; Int_ttopic; Bool_tuniversal. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Bool_t match(RooFit::MsgLevel level, RooFit::MsgTopic facility, const RooAbsArg* obj); Determine if message from given object at given level on given topic is logged. Bool_t match(RooFit::MsgLevel level, RooFit::MsgTopic facility, const TObject* obj); Determine if message from given object at given level on given topic is logged. void addTopic(RooFit::MsgTopic newTopic). void removeTopic(RooFit::MsgTopic oldTopic).  Last changed: Tue Sep 8 17:42:19 2015  Last generated: 2015-09-08 17:42; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/RooMsgService__StreamConfig.html:2572,log,logged,2572,root/html604/RooMsgService__StreamConfig.html,https://root.cern,https://root.cern/root/html604/RooMsgService__StreamConfig.html,2,['log'],['logged']
Testability,"messages from objects with given base class name; LabelName(const chat*) -- Restrict stream to messages from objects setAtrribute(const char*) tag with given name. Output redirection options. OutputFile(const char*) -- Send output to file with given name. Multiple streams can write to same file.; OutputStream(ostream&) -- Send output to given C++ stream. Multiple message streams can write to same c++ stream. The return value is the unique ID code of the defined stream. void deleteStream(Int_t id); Delete stream with given unique ID code. void setStreamStatus(Int_t id, Bool_t active); (De)Activate stream with given unique ID. Bool_t getStreamStatus(Int_t id) const; Get activation status of stream with given unique ID. RooMsgService& instance(); Return reference to singleton instance. void saveState(); Save current state of message service. void restoreState(); Restore last saved state of message service. Bool_t isActive(const RooAbsArg* self, RooFit::MsgTopic topic, RooFit::MsgLevel level); Check if logging is active for given object/topic/RooFit::MsgLevel combination. Bool_t isActive(const TObject* self, RooFit::MsgTopic topic, RooFit::MsgLevel level); Check if logging is active for given object/topic/RooFit::MsgLevel combination. Int_t activeStream(const RooAbsArg* self, RooFit::MsgTopic topic, RooFit::MsgLevel level); Find appropriate logging stream for message from given object with given topic and message level. Int_t activeStream(const TObject* self, RooFit::MsgTopic topic, RooFit::MsgLevel level); Find appropriate logging stream for message from given object with given topic and message level. ostream& log(const RooAbsArg* self, RooFit::MsgLevel level, RooFit::MsgTopic topic, Bool_t skipPrefix); Log error message associated with RooAbsArg object self at given level and topic. If skipPrefix; is true the standard RooMsgService prefix is not added. ostream& log(const TObject* self, RooFit::MsgLevel level, RooFit::MsgTopic topic, Bool_t skipPrefix); Log error mess",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooMsgService.html:10298,log,logging,10298,root/html526/RooMsgService.html,https://root.cern,https://root.cern/root/html526/RooMsgService.html,1,['log'],['logging']
Testability,"meter for 1D ridges in x direction, which allows to fix the parameter (not to fit). ; Definition at line 111 of file TSpectrum2Fit.h. fFixBy. Bool_t TSpectrum2Fit::fFixBy. protected . logical value of b parameter for 1D ridges in y direction, which allows to fix the parameter (not to fit). ; Definition at line 112 of file TSpectrum2Fit.h. fFixPositionX. Bool_t* TSpectrum2Fit::fFixPositionX. protected . [fNPeaks] array of logical values which allow to fix appropriate x positions of 2D peaks (not fit). However they are present in the estimated functional ; Definition at line 95 of file TSpectrum2Fit.h. fFixPositionX1. Bool_t* TSpectrum2Fit::fFixPositionX1. protected . [fNPeaks] array of logical values which allow to fix appropriate x positions of 1D ridges (not fit). However they are present in the estimated functional ; Definition at line 97 of file TSpectrum2Fit.h. fFixPositionY. Bool_t* TSpectrum2Fit::fFixPositionY. protected . [fNPeaks] array of logical values which allow to fix appropriate y positions of 2D peaks (not fit). However they are present in the estimated functional ; Definition at line 96 of file TSpectrum2Fit.h. fFixPositionY1. Bool_t* TSpectrum2Fit::fFixPositionY1. protected . [fNPeaks] array of logical values which allow to fix appropriate y positions of 1D ridges (not fit). However they are present in the estimated functional ; Definition at line 98 of file TSpectrum2Fit.h. fFixRo. Bool_t TSpectrum2Fit::fFixRo. protected . logical value of correlation coefficient, which allows to fix the parameter (not to fit). ; Definition at line 104 of file TSpectrum2Fit.h. fFixSigmaX. Bool_t TSpectrum2Fit::fFixSigmaX. protected . logical value of sigma x parameter, which allows to fix the parameter (not to fit). ; Definition at line 102 of file TSpectrum2Fit.h. fFixSigmaY. Bool_t TSpectrum2Fit::fFixSigmaY. protected . logical value of sigma y parameter, which allows to fix the parameter (not to fit). ; Definition at line 103 of file TSpectrum2Fi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSpectrum2Fit.html:85191,log,logical,85191,doc/master/classTSpectrum2Fit.html,https://root.cern,https://root.cern/doc/master/classTSpectrum2Fit.html,1,['log'],['logical']
Testability,"meter, which allows to fix the parameter (not to fit). ; ; Bool_tfFixAy; logical value of ay parameter, which allows to fix the parameter (not to fit). ; ; Bool_tfFixBx; logical value of b parameter for 1D ridges in x direction, which allows to fix the parameter (not to fit). ; ; Bool_tfFixBy; logical value of b parameter for 1D ridges in y direction, which allows to fix the parameter (not to fit). ; ; Bool_t *fFixPositionX; [fNPeaks] array of logical values which allow to fix appropriate x positions of 2D peaks (not fit). However they are present in the estimated functional ; ; Bool_t *fFixPositionX1; [fNPeaks] array of logical values which allow to fix appropriate x positions of 1D ridges (not fit). However they are present in the estimated functional ; ; Bool_t *fFixPositionY; [fNPeaks] array of logical values which allow to fix appropriate y positions of 2D peaks (not fit). However they are present in the estimated functional ; ; Bool_t *fFixPositionY1; [fNPeaks] array of logical values which allow to fix appropriate y positions of 1D ridges (not fit). However they are present in the estimated functional ; ; Bool_tfFixRo; logical value of correlation coefficient, which allows to fix the parameter (not to fit). ; ; Bool_tfFixSigmaX; logical value of sigma x parameter, which allows to fix the parameter (not to fit). ; ; Bool_tfFixSigmaY; logical value of sigma y parameter, which allows to fix the parameter (not to fit). ; ; Bool_tfFixSx; logical value of s parameter for 1D ridges in x direction, which allows to fix the parameter (not to fit). ; ; Bool_tfFixSxy; logical value of s parameter for 2D peaks, which allows to fix the parameter (not to fit). ; ; Bool_tfFixSy; logical value of s parameter for 1D ridges in y direction, which allows to fix the parameter (not to fit). ; ; Bool_tfFixTx; logical value of t parameter for 1D ridges in x direction, which allows to fix the parameter (not to fit). ; ; Bool_tfFixTxy; logica",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSpectrum2Fit.html:27556,log,logical,27556,doc/master/classTSpectrum2Fit.html,https://root.cern,https://root.cern/doc/master/classTSpectrum2Fit.html,1,['log'],['logical']
Testability,"method returns first(). Otherwise it will return the option with the same Descriptor::index that follows this option on the command line. ; Definition at line 695 of file OptionParser.h. operator const Option *(). ROOT::option::Option::operator const Option * ; (; ); const. inline . Casts from Option to const Option* but only if this Option is valid. ; If this Option is valid (i.e. desc!=NULL), returns this. Otherwise returns NULL. This allows testing an Option directly in an if-clause to see if it is used: if (options[CREATE]); {; ...; }; It also allows you to write loops like this: for (Option* opt = options[FILE]; opt; opt = opt->next()); fname = opt->arg; ... . Definition at line 736 of file OptionParser.h. operator Option *(). ROOT::option::Option::operator Option * ; (; ). inline . Casts from Option to Option* but only if this Option is valid. ; If this Option is valid (i.e. desc!=NULL), returns this. Otherwise returns NULL. This allows testing an Option directly in an if-clause to see if it is used: if (options[CREATE]); {; ...; }; It also allows you to write loops like this: for (Option* opt = options[FILE]; opt; opt = opt->next()); fname = opt->arg; ... . Definition at line 757 of file OptionParser.h. operator=(). Option & ROOT::option::Option::operator= ; (; const Option &; orig). inline . Makes *this a copy of orig except for the linked list pointers. ; After this operation *this will be a one-element linked list. ; Definition at line 792 of file OptionParser.h. prev(). Option * ROOT::option::Option::prev ; (; ). inline . Returns a pointer to the previous element of the linked list or NULL if called on first(). ; If called on first() this method returns NULL. Otherwise it will return the option with the same Descriptor::index that precedes this option on the command line. ; Definition at line 656 of file OptionParser.h. prevwrap(). Option * ROOT::option::Option::prevwrap ; (; ). inline . Returns a pointer to the previous element of the linked l",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1option_1_1Option.html:10561,test,testing,10561,doc/v632/classROOT_1_1option_1_1Option.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1option_1_1Option.html,2,['test'],['testing']
Testability,"method); Double_tGetBoostROCIntegral(Bool_t, TMVA::Types::ETreeType, Bool_t CalcOverlapIntergral = kFALSE); virtual voidInit(); voidInitHistos(); voidMonitorBoost(TMVA::Types::EBoostStage stage, UInt_t methodIdx = 0); voidPrintResults(const TString&, vector<Double_t>&, const Double_t) const; virtual voidProcessOptions(); voidResetBoostWeights(); Double_tSingleBoost(TMVA::MethodBase* method); voidSingleTrain(); virtual voidTestClassification(); virtual voidWriteEvaluationHistosToFile(TMVA::Types::ETreeType treetype); virtual voidWriteMonitoringHistosToFile() const. Data Members; public:. enum TMVA::MethodBase::EWeightFileType { kROOT; kTEXT; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. public:. Bool_tTMVA::MethodBase::fSetupCompletedis method setup; const TMVA::Event*TMVA::MethodBase::fTmpEvent! temporary event when testing on a different DataSet than the own one. protected:. TMVA::Types::EAnalysisTypeTMVA::MethodBase::fAnalysisTypemethod-mode : true --> regression, false --> classification; UInt_tTMVA::MethodBase::fBackgroundClassindex of the Background-class; TMVA::MethodBase*TMVA::MethodCompositeBase::fCurrentMethod; UInt_tTMVA::MethodCompositeBase::fCurrentMethodIdx; vector<TString>*TMVA::MethodBase::fInputVarsvector of input variables used in MVA; vector<Double_t>TMVA::MethodCompositeBase::fMethodWeight; vector<IMethod*>TMVA::MethodCompositeBase::fMethodsvector of all classifiers; vector<Float_t>*TMVA::MethodBase::fMulticlassReturnValholds the return-values for the multiclass classification; Int_tTMVA::MethodBase::fNbinsnumber of bins in input variable histograms; Int_tTMVA::MethodBase::fNbinsHnumber of bins in evaluation histograms; Int_tTMVA::MethodBase::fNbinsMVAoutputnumber of bins in MVA output histograms; TMVA::Ranking*TMVA::MethodBase::fRankingpoin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TMVA__MethodBoost.html:16556,test,testing,16556,root/html534/TMVA__MethodBoost.html,https://root.cern,https://root.cern/root/html534/TMVA__MethodBoost.html,1,['test'],['testing']
Testability,"methodDir). inline . Definition at line 374 of file MethodBase.h. SetMethodDir(). void TMVA::MethodBase::SetMethodDir ; (; TDirectory *; methodDir). inline . Definition at line 372 of file MethodBase.h. SetModelPersistence(). void TMVA::MethodBase::SetModelPersistence ; (; Bool_t; status). inline . Definition at line 382 of file MethodBase.h. SetNormalised(). void TMVA::MethodBase::SetNormalised ; (; Bool_t; norm). inlineprotected . Definition at line 497 of file MethodBase.h. SetSignalReferenceCut(). void TMVA::MethodBase::SetSignalReferenceCut ; (; Double_t; cut). inline . Definition at line 364 of file MethodBase.h. SetSignalReferenceCutOrientation(). void TMVA::MethodBase::SetSignalReferenceCutOrientation ; (; Double_t; cutOrientation). inline . Definition at line 365 of file MethodBase.h. SetSilentFile(). void TMVA::MethodBase::SetSilentFile ; (; Bool_t; status). inline . Definition at line 378 of file MethodBase.h. SetTestTime(). void TMVA::MethodBase::SetTestTime ; (; Double_t; testTime). inline . Definition at line 165 of file MethodBase.h. SetTestvarName(). void TMVA::MethodBase::SetTestvarName ; (; const TString &; v = """"). inline . Definition at line 341 of file MethodBase.h. SetTrainTime(). void TMVA::MethodBase::SetTrainTime ; (; Double_t; trainTime). inline . Definition at line 161 of file MethodBase.h. SetTuneParameters(). void TMVA::MethodBase::SetTuneParameters ; (; std::map< TString, Double_t >; tuneParameters). virtual . set the tuning parameters according to the argument This is just a dummy . ; . have a look at the MethodBDT how you could perhaps implement the same thing for the other Classifiers.. ; Reimplemented in TMVA::MethodBDT, and TMVA::MethodSVM.; Definition at line 644 of file MethodBase.cxx. SetupMethod(). void TMVA::MethodBase::SetupMethod ; (; ). setup of methods ; Definition at line 406 of file MethodBase.cxx. SetWeightFileDir(). void TMVA::MethodBase::SetWeightFileDir ; (; TString; fileDir). prote",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1MethodBase.html:73199,test,testTime,73199,doc/master/classTMVA_1_1MethodBase.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1MethodBase.html,1,['test'],['testTime']
Testability,"methodname); static voidDestroyInstance(); TStringGetMethodName(TMVA::Types::EMVA method) const; TMVA::Types::EMVAGetMethodType(const TString& method) const; static TMVA::Types&Instance(); TMVA::Types&operator=(const TMVA::Types&); TMVA::TypesTypes(const TMVA::Types&). private:. TMVA::MsgLogger&Log() const; TMVA::TypesTypes(). Data Members; public:. enum EMVA { kVariable; kCuts; kLikelihood; kPDERS; kHMatrix; kFisher; kKNN; kCFMlpANN; kTMlpANN; kBDT; kDT; kRuleFit; kSVM; kMLP; kBayesClassifier; kFDA; kBoost; kPDEFoam; kLD; kPlugins; kCategory; kMaxMethod; };; enum EVariableTransform { kIdentity; kDecorrelated; kNormalized; kPCA; kRearranged; kGauss; kUniform; kMaxVariableTransform; };; enum EAnalysisType { kClassification; kRegression; kMulticlass; kNoAnalysisType; kMaxAnalysisType; };; enum ESBType { kSignal; kBackground; kSBBoth; kMaxSBType; kTrueType; };; enum ETreeType { kTraining; kTesting; kMaxTreeType; kValidation; kTrainingOriginal; };; enum EBoostStage { kBoostProcBegin; kBeforeTraining; kBeforeBoosting; kAfterBoosting; kBoostProcEnd; };. private:. TMVA::MsgLogger*fLoggermessage logger; map<TString,TMVA::Types::EMVA>fStr2typetypes-to-text map; static TMVA::Types*fgTypesPtr. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Types(); constructor. ~Types(); destructor. TMVA::Types& Instance(); the the single instance of ""Types"" if existin already, or create it (Signleton). void DestroyInstance(); ""destructor"" of the single instance. Bool_t AddTypeMapping(TMVA::Types::EMVA method, const TString& methodname). TString GetMethodName(TMVA::Types::EMVA method) const. Types::EMVA GetMethodType(const TString& method) const. Types().  Author: Andreas Hoecker, Joerg Stelzer, Helge Voss  Copyright (c) 2005: *;  Last changed: root/tmva $Id$  Last generated: 2015-09-08 17:04; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TMVA__Types.html:1484,log,logger,1484,root/html534/TMVA__Types.html,https://root.cern,https://root.cern/root/html534/TMVA__Types.html,1,['log'],['logger']
Testability,"ming that all the bins are uncorrelated.; By default the integral is computed as the sum of bin contents in the range.; if option ""width"" is specified, the integral is the sum of; the bin contents multiplied by the bin width in x, y and in z. Double_t Interpolate(Double_t x). Double_t Interpolate(Double_t x, Double_t y). Double_t Interpolate(Double_t x, Double_t y, Double_t z); Given a point P(x,y,z), Interpolate approximates the value via trilinear interpolation; based on the 8 nearest bin center points ( corner of the cube surronding the points); The Algorithm is described in http://en.wikipedia.org/wiki/Trilinear_interpolation; The given values (x,y,z) must be between first bin center and last bin center for each coordinate:. fXAxis.GetBinCenter(1) < x < fXaxis.GetBinCenter(nbinX) AND; fYAxis.GetBinCenter(1) < y < fYaxis.GetBinCenter(nbinY) AND; fZAxis.GetBinCenter(1) < z < fZaxis.GetBinCenter(nbinZ). Double_t KolmogorovTest(const TH1* h2, Option_t* option = """") const; Statistical test of compatibility in shape between; THIS histogram and h2, using Kolmogorov test.; Default: Ignore under- and overflow bins in comparison. option is a character string to specify options; ""U"" include Underflows in test; ""O"" include Overflows; ""N"" include comparison of normalizations; ""D"" Put out a line of ""Debug"" printout; ""M"" Return the Maximum Kolmogorov distance instead of prob. The returned function value is the probability of test; (much less than one means NOT compatible). The KS test uses the distance between the pseudo-CDF's obtained; from the histogram. Since in more than 1D the order for generating the pseudo-CDF is; arbitrary, we use the pseudo-CDF's obtained from all the possible 6 combinatons of the 3 axis.; The average of all the maximum distances obtained is used in the tests. Long64_t Merge(TCollection* list); Add all histograms in the collection to this histogram.; This function computes the min/max for the axes,; compute a new number of bins, if necessary,; add bin ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TH3.html:36604,test,test,36604,root/html528/TH3.html,https://root.cern,https://root.cern/root/html528/TH3.html,8,['test'],['test']
Testability,missing recursive traversal; [#13623] - Add directory wildcarding in TChain; [#13531] - Huge RAM consumption of the hadd command for input files with several directories; [#13511] - TMapFile cant work; [#13497] - Assertion failure in TMVA with vector iterators incompatible error on Windows; [#13441] - error in root-generated code for cubic spline (TSpline3); [#13421] - [MSVC] ROOT builds under msvc option /permissive- with error C4576; [#13359] - Bug in TFileMerger class for a single input file and a selective list of objects to be merged in output file; [#13288] - [cling] long double type incorrectly parsed by interpreter; [#13155] - TMVA doesnt compile with pytorch 2.0.1; [#13130] - Valgrind reports leak when constructing TChain; [#13110] - Bug in TDecompBase::DiagProd; [#13079] - Builtin TBB library sometimes not found (or more exactly the one install in /usr/lib sometimes take priority); [#13041] - TVirtualFitter::GetFitter() unexpectedly returns NULL on macOS 12 and 13 with Xcode 14; [#13019] - LLVM assertion failure in HandleUnionActiveMemberChange; [#12993] - std::source_location not working in the interpreter; [#12959] - [ntuple] Distinguish between connecting a page sink and a page source in RColumn; [#12783] - [IO] Writing HistFactory model file twice gives strange results since ROOT 6.26.02; [#12770] - tmva/sofie_parsers does not build with latest Protobuf (22.x); [#12744] - wrong Python version found during build; [#12718] - A crash when trying to initialise a vector from a >1D numpy array in PyROOT; [#12685] - TEnum::GetEnum does NOT process typedefs; [#12644] - Cant find cxxabi.h and build module ROOT_Foundation_Stage1_NoRTTI when building from source on Macos; [#12631] - Unable to build master with external XROOTD; [#12621] - [I/O][RDF] Usage of xrootd from multi-thread event loops runs into severe bottlenecks; [#12592] - [doc] TProfile bin error documentation is not correct; [#12591] - Allow partial enablement of modules; [#12527] - MacOS build f,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/release-notes.html:32985,assert,assertion,32985,doc/v632/release-notes.html,https://root.cern,https://root.cern/doc/v632/release-notes.html,1,['assert'],['assertion']
Testability,"mit; if rebuild = false (default) it will re-use the results of the scan done; for obtained the observed limit and no extra toys will be generated; if rebuild a new set of B toys will be done and the procedure will be repeted; for each toy. void SetData(RooAbsData& ). SamplingDistribution * RebuildDistributions(bool isUpper = true, int nToys = 100, TList* clsDist = 0, TList* clsbDist = 0, TList* clbDist = 0); rebuild the sampling distributions by; generating some toys and find for each of theam a new upper limit; Return the upper limit distribution and optionally also the pValue distributions for Cls, Clsb and Clbxs; as a TList for each scanned point. void SetFixedScan(int nBins, double xMin = 1, double xMax = -1); set for a fixed scan in nbins. void SetAutoScan(); set auto scan (default). { SetFixedScan(0); }. void UseCLs(bool on = true); { fUseCLs = on; if (fResults) fResults->UseCLs(on); }. void SetModel(const RooStats::ModelConfig& ); { }. void SetTestSize(Double_t size); set the size of the test (rate of Type I error) ( Eg. 0.05 for a 95% Confidence Interval). {fSize = size; if (fResults) fResults->SetTestSize(size); }. void SetConfidenceLevel(Double_t cl); set the confidence level for the interval (eg. 0.95 for a 95% Confidence Interval). {fSize = 1.-cl; if (fResults) fResults->SetConfidenceLevel(cl); }. Double_t Size() const; Get the size of the test (eg. rate of Type I error). {return fSize;}. Double_t ConfidenceLevel() const; Get the Confidence level for the test. {return 1.-fSize;}. HypoTestCalculatorGeneric * GetHypoTestCalculator() const; retrieved a reference to the internally used HypoTestCalculator; it might be invalid when the class is deleted. { return fCalculator0; }. void SetVerbose(int level = 1); set verbose level (0,1,2). { fVerbose = level; }. void SetMaximumToys(int ntoys); set maximum number of toys. { fMaxToys = ntoys;}. void SetNumErr(double err); set numerical error in test statistic evaluation (default is zero). { fNumErr = err; }.  Auth",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooStats__HypoTestInverter.html:10831,test,test,10831,root/html530/RooStats__HypoTestInverter.html,https://root.cern,https://root.cern/root/html530/RooStats__HypoTestInverter.html,2,['test'],['test']
Testability,"mits<unsigned int>::max());; 605 ; 606 // Sum from 0 to just before the bin outside of the range.; 607 if (ixMin == 0) {; 608 return ROOT::Math::inc_gamma_c(ixMax, mu);; 609 } else {; 610 // If necessary, subtract from 0 to the beginning of the range; 611 if (ixMin <= mu) {; 612 return ROOT::Math::inc_gamma_c(ixMax, mu) - ROOT::Math::inc_gamma_c(ixMin, mu);; 613 } else {; 614 // Avoid catastrophic cancellation in the high tails:; 615 return ROOT::Math::inc_gamma(ixMin, mu) - ROOT::Math::inc_gamma(ixMax, mu);; 616 }; 617 }; 618 }; 619 ; 620 // the integral with respect to the mean is the integral of a gamma distribution; 621 // negative ix does not need protection (gamma returns 0.0); 622 const double ix = 1 + x;; 623 ; 624 return ROOT::Math::inc_gamma(ix, integrandMax) - ROOT::Math::inc_gamma(ix, integrandMin);; 625}; 626 ; 627inline double logNormalIntegral(double xMin, double xMax, double m0, double k); 628{; 629 const double root2 = std::sqrt(2.);; 630 ; 631 double ln_k = std::abs(std::log(k));; 632 double ret =; 633 0.5 * (TMath::Erf(std::log(xMax / m0) / (root2 * ln_k)) - TMath::Erf(std::log(xMin / m0) / (root2 * ln_k)));; 634 ; 635 return ret;; 636}; 637 ; 638inline double logNormalIntegralStandard(double xMin, double xMax, double mu, double sigma); 639{; 640 const double root2 = std::sqrt(2.);; 641 ; 642 double ln_k = std::abs(sigma);; 643 double ret =; 644 0.5 * (TMath::Erf((std::log(xMax) - mu) / (root2 * ln_k)) - TMath::Erf((std::log(xMin) - mu) / (root2 * ln_k)));; 645 ; 646 return ret;; 647}; 648 ; 649inline double cbShapeIntegral(double mMin, double mMax, double m0, double sigma, double alpha, double n); 650{; 651 const double sqrtPiOver2 = 1.2533141373;; 652 const double sqrt2 = 1.4142135624;; 653 ; 654 double result = 0.0;; 655 bool useLog = false;; 656 ; 657 if (std::abs(n - 1.0) < 1.0e-05); 658 useLog = true;; 659 ; 660 double sig = std::abs(sigma);; 661 ; 662 double tmin = (mMin - m0) / sig;; 663 double tmax = (mMax - m0) / sig;; 664 ; 665 if (alph",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/MathFuncs_8h_source.html:21054,log,log,21054,doc/master/MathFuncs_8h_source.html,https://root.cern,https://root.cern/doc/master/MathFuncs_8h_source.html,1,['log'],['log']
Testability,mixmax_skip_N256.icc; MixMaxEngine.cxx; ParameterSettings.cxx; PdfFuncMathCore.cxx; ProbFuncMathCore.cxx; QuantFuncMathCore.cxx; RandomFunctions.cxx; RichardsonDerivator.cxx; RootFinder.cxx; SparseData.cxx; SpecFuncCephes.cxx; SpecFuncCephes.h; SpecFuncCephesInv.cxx; SpecFuncMathCore.cxx; TComplex.cxx; TDataPointN.cxx; TKDTree.cxx; TKDTreeBinning.cxx; TMath.cxx; TRandom.cxx; TRandom1.cxx; TRandom2.cxx; TRandom3.cxx; triangle.c; triangle.h; TStatistic.cxx; UnBinData.cxx; test; fit; GaussFunction.h; MinimizerTypes.h; SparseDataComparer.cxx; SparseFit3.cxx; SparseFit4.cxx; testFit.cxx; testFitPerf.cxx; testGraphFit.cxx; testMinim.cxx; testRooFit.cxx; WrapperRooPdf.h; binarySearchTime.cxx; kDTreeTest.cxx; newKDTreeTest.cxx; stdsort.cxx; stressGoFTest.cxx; stressTF1.cxx; stressTMath.cxx; testAnalyticalIntegrals.cxx; testBinarySearch.cxx; testDistSampler.cxx; testIntegration.cxx; testIntegrationMultiDim.cxx; testkdTreeBinning.cxx; testMathRandom.cxx; testRootFinder.cxx; testSampleQuantiles.cxx; testSortOrder.cxx; testSpecFuncBeta.cxx; testSpecFuncBetaI.cxx; testSpecFuncErf.cxx; testSpecFuncGamma.cxx; testSpecFuncSiCi.cxx; testTMath.cxx; testTStatistic.cxx; v7; inc; ROOT; TFit.h; mathmore; inc; Math; ChebyshevApprox.h; Derivator.h; DistFuncMathMore.h; GSLFunctionAdapter.h; GSLIntegrator.h; GSLMCIntegrator.h; GSLMinimizer.h; GSLMinimizer1D.h; GSLMultiRootFinder.h; GSLNLSMinimizer.h; GSLQuasiRandom.h; GSLRandom.h; GSLRandomFunctions.h; GSLRndmEngines.h; GSLRootFinder.h; GSLRootFinderDeriv.h; GSLRootHelper.h; GSLSimAnMinimizer.h; GSLSimAnnealing.h; IntegrationTypes.h; InterpolationTypes.h; Interpolator.h; KelvinFunctions.h; LinkDef.h; LinkDef_Func.h; LinkDef_RootFinding.h; MCIntegrationTypes.h; MCParameters.h; MultiNumGradFunction.h; MultiRootFinder.h; ParamFunction.h; PdfFuncMathMore.h; Polynomial.h; QuantFuncMathMore.h; QuasiRandom.h; RootFinderAlgorithms,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html606/files.html:46268,test,testMathRandom,46268,root/html606/files.html,https://root.cern,https://root.cern/root/html606/files.html,1,['test'],['testMathRandom']
Testability,"mizeCaching (); This method changes the value caching logic for all nodes that depends on any of the observables as defined by the given dataset. ; ; voidoptimizeConstantTerms (bool, bool=true); Driver function to activate global constant term optimization. ; ; voidprintCompactTreeHook (std::ostream &os, const char *indent="""") override; Catch print hook function and forward to function clone. ; ; boolredirectServersHook (const RooAbsCollection &newServerList, bool mustReplaceAll, bool nameChange, bool isRecursive) override; Catch server redirect calls and forward to internal clone of function. ; ; virtual RooArgSetrequiredExtraObservables () const; ; voidrunRecalculateCache (std::size_t firstEvent, std::size_t lastEvent, std::size_t stepSize) const override; ; boolsetDataSlave (RooAbsData &data, bool cloneData=true, bool ownNewDataAnyway=false) override; Change dataset that is used to given one. ; ; Protected Member Functions inherited from RooAbsTestStatistic; doubleevaluate () const override; Calculate and return value of test statistic. ; ; virtual doublegetCarry () const; ; boolinitialize (); One-time initialization of the test statistic. ; ; voidinitMPMode (RooAbsReal *real, RooAbsData *data, const RooArgSet *projDeps, std::string const &rangeName, std::string const &addCoefRangeName); Initialize multi-processor calculation mode. ; ; voidinitSimMode (RooSimultaneous *pdf, RooAbsData *data, const RooArgSet *projDeps, std::string const &rangeName, std::string const &addCoefRangeName); Initialize simultaneous p.d.f processing mode. ; ; Int_tnumSets () const; ; voidprintCompactTreeHook (std::ostream &os, const char *indent="""") override; Add extra information on component test statistics when printing itself as part of a tree structure. ; ; virtual boolprocessEmptyDataSets () const; ; boolredirectServersHook (const RooAbsCollection &newServerList, bool mustReplaceAll, bool nameChange, bool isRecursive) override; Forward serve",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooChi2Var.html:51735,test,test,51735,doc/master/classRooChi2Var.html,https://root.cern,https://root.cern/doc/master/classRooChi2Var.html,1,['test'],['test']
Testability,"mizer(const char* minimizer); voidSetPrintLevel(Int_t printLevel); voidSetReuseNLL(Bool_t flag); voidSetStrategy(Int_t strategy); voidSetSubtractMLE(bool subtract); voidSetTolerance(Double_t tol); virtual voidShowMembers(TMemberInspector&); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). Data Members; private:. RooArgSet*fAltPOI; RooStats::ProfileLikelihoodTestStatfAltProfile; RooArgSet*fDetailedOutput; boolfDetailedOutputEnabled; RooStats::ProfileLikelihoodTestStatfNullProfile; Bool_tfSubtractMLE; static Bool_tfgAlwaysReuseNll. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RatioOfProfiledLikelihoodsTestStat(); Proof constructor. Don't use. RatioOfProfiledLikelihoodsTestStat(RooAbsPdf& nullPdf, RooAbsPdf& altPdf, const RooArgSet* altPOI = 0). Calculates the ratio of profiled likelihoods. 	 By default the calculation is:. 	 Lambda(mu_alt , conditional MLE for alt nuisance); 	log --------------------------------------------; 	 Lambda(mu_null , conditional MLE for null nuisance). 	where Lambda is the profile likeihood ratio, so the; 	MLE for the null and alternate are subtracted off. 	If SetSubtractMLE(false) then it calculates:. 	 L(mu_alt , conditional MLE for alt nuisance); 	log --------------------------------------------; 	 L(mu_null , conditional MLE for null nuisance). 	The values of the parameters of interest for the alternative; 	hypothesis are taken at the time of the construction.; 	If empty, it treats all free parameters as nuisance parameters. 	The value of the parameters of interest for the null hypotheses; 	are given at each call of Evaluate(data,nullPOI). ~RatioOfProfiledLikelihoodsTestStat(void). Double_t ProfiledLikelihood(RooAbsData& data, RooArgSet& poi, RooAbsPdf& pdf); returns -logL(poi, conditional MLE of nuisance params); it does not subtract off the global MLE; because nuisance parameters of null and alternate may not; be the same. Double_t Evaluate(RooAbsDa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooStats__RatioOfProfiledLikelihoodsTestStat.html:2493,log,log,2493,root/html534/RooStats__RatioOfProfiledLikelihoodsTestStat.html,https://root.cern,https://root.cern/root/html534/RooStats__RatioOfProfiledLikelihoodsTestStat.html,1,['log'],['log']
Testability,"ml or .txt. Files ending on .txt will be converted to HTML before they are copied to the output directory. For each file, the links text will be the file name without extension, with underscores replaced by spaces.; You can see an example of the module documentation including links, the corresponding index.html, and the module class index at http://root.cern.ch/root/html/HIST_Index.html.; 27.2 Converting Sources (and Other Files) to HTML; THtml can take a file (C++ or text) and convert it to HTML. There are two main use cases:; The output of a macro converted to HTML will almost look like the beautified source file of a class reference. The Begin_Html/End_Html keywords are supported; comments, strings, and keywords are colored like in THtmls output for source code.; The macro Event.cxx in $ROOTSYS/test can be seen as an example of documented ROOT macros at http://root.cern.ch/root/html/examples/Event.cxx.html; THtml::Convert()converts a single text file to HTML. For example, it can be run on a change log. Each known class name will be linked to its documentation page. An example is ROOTs change log at http://root.cern.ch/root/html/examples/V5.16.txt.html; To convert the source file MyCode.C to HTML, you can run; root[] THtml h; root[] h.Convert(""MyCode.C"", ""Look At My Code"", ""htmlout/"");; This will create the file htmlout/MyCode.C.html. The HTML page will have the title Look At My Code.; 27.3 Special Documentation Elements: Directives; A common documentation problem is the inclusion of images. They are usually generated externally, which poses problems with where to keep the images, and how to keep them up to date. THtml solves this by offering a few special documentation elements: macro and latex directives.; 27.3.1 Latex Directive; Documentation surrounded by the keywords BEGIN_LATEX / END_LATEX will be passed to ROOT Latex engine TLatex. The keywords can be written with small or capital letters (case insensitive). The output will be stored to an image file, ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1244302,log,log,1244302,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['log'],['log']
Testability,ml; inc; TBufferXML.h; TKeyXML.h; TXMLEngine.h; TXMLFile.h; TXMLPlayer.h; TXMLSetup.h; src; TBufferXML.cxx; TKeyXML.cxx; TXMLEngine.cxx; TXMLFile.cxx; TXMLPlayer.cxx; TXMLSetup.cxx; xmlparser; inc; TDOMParser.h; TSAXParser.h; TXMLAttr.h; TXMLDocument.h; TXMLNode.h; TXMLParser.h; src; TDOMParser.cxx; TSAXParser.cxx; TXMLAttr.cxx; TXMLDocument.cxx; TXMLNode.cxx; TXMLParser.cxx; math; fftw; inc; TFFTComplex.h; TFFTComplexReal.h; TFFTReal.h; TFFTRealComplex.h; src; TFFTComplex.cxx; TFFTComplexReal.cxx; TFFTReal.cxx; TFFTRealComplex.cxx; foam; inc; TFoam.h; TFoamCell.h; TFoamIntegrand.h; TFoamMaxwt.h; TFoamSampler.h; TFoamVect.h; src; TFoam.cxx; TFoamCell.cxx; TFoamIntegrand.cxx; TFoamMaxwt.cxx; TFoamSampler.cxx; TFoamVect.cxx; fumili; inc; TFumili.h; TFumiliMinimizer.h; src; TFumili.cxx; TFumiliMinimizer.cxx; genetic; inc; Math; GeneticMinimizer.h; src; GeneticMinimizer.cxx; test; GAMinTutorial.cxx; testGAMinimizer.cxx; timeGA.cxx; genvector; inc; Math; GenVector; 3DConversions.h; 3DDistances.h; AxisAngle.h; AxisAnglefwd.h; BitReproducible.h; Boost.h; Boostfwd.h; BoostX.h; BoostXfwd.h; BoostY.h; BoostYfwd.h; BoostZ.h; BoostZfwd.h; Cartesian2D.h; Cartesian2Dfwd.h; Cartesian3D.h; Cartesian3Dfwd.h; CoordinateSystemTags.h; Cylindrical3D.h; Cylindrical3Dfwd.h; CylindricalEta3D.h; CylindricalEta3Dfwd.h; DisplacementVector2D.h; DisplacementVector2Dfwd.h; DisplacementVector3D.h; DisplacementVector3Dfwd.h; eta.h; etaMax.h; EulerAngles.h; EulerAnglesfwd.h; GenVector_exception.h; GenVectorIO.h; LorentzRotation.h; LorentzRotationfwd.h; LorentzVector.h; LorentzVectorfwd.h; Plane3D.h; Polar2D.h; Polar2Dfwd.h; Polar3D.h; Polar3Dfwd.h; PositionVector2D.h; PositionVector2Dfwd.h; PositionVector3D.h; PositionVector3Dfwd.h; PtEtaPhiE4D.h; PtEtaPhiE4Dfwd.h; PtEtaPhiM4D.h; PtEtaPhiM4Dfwd.h; PxPyPzE4D.h; PxPyPzE4Dfwd.h; ,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v610/files.html:39024,test,test,39024,doc/v610/files.html,https://root.cern,https://root.cern/doc/v610/files.html,1,['test'],['test']
Testability,"mnMajor ) ? fStrides.back() : fShape.front();}; 300 size_t GetNcols() const { return (GetLayout() == MemoryLayout::ColumnMajor ) ? fShape.back() : fStrides.front(); }; 301 ; 302 ; 303 // Matrix conversion for tensors of shape 2; 304 TCudaMatrix<AFloat> GetMatrix() const {; 305 // remember TCudaMatrix is always column-major; 306 if ( GetLayout() == MemoryLayout::ColumnMajor &&; 307 (fNDim == 2 || (fNDim == 3 && GetFirstSize() == 1) ) ); 308 return TCudaMatrix<AFloat>(fElementBuffer, GetHSize(), GetWSize());; 309 ; 310 ; 311 //case of N,M,1,1,..; 312 bool caseNM11 = true;; 313 for (size_t i = 2; i < fNDim; ++i) caseNM11 &= fShape[i] == 1;; 314 if (caseNM11) {; 315 return (GetLayout() == MemoryLayout::ColumnMajor ) ?; 316 TCudaMatrix<AFloat>(fElementBuffer, fShape[0], fShape[1]) :; 317 TCudaMatrix<AFloat>(fElementBuffer, fShape[1], fShape[0]);; 318 }; 319 bool case11NM = true;; 320 for (size_t i = 0; i < fNDim-2; ++i) case11NM &= fShape[i] == 1;; 321 if (case11NM) {; 322 return (GetLayout() == MemoryLayout::ColumnMajor ) ?; 323 TCudaMatrix<AFloat>(fElementBuffer, fShape[fNDim-2], fShape[fNDim-1]) :; 324 TCudaMatrix<AFloat>(fElementBuffer, fShape[fNDim-1], fShape[fNDim-2]);; 325 }; 326 ; 327 assert(false);; 328 return TCudaMatrix<AFloat>();; 329 }; 330 ; 331 // for backward compatibility with old tensor; 332 TCudaMatrix<AFloat> operator[](size_t i) const {; 333 //assert(GetLayout() == MemoryLayout::ColumnMajor );; 334 return At(i).GetMatrix();; 335 }; 336 ; 337 ; 338 ; 339 static inline std::vector<std::size_t> ComputeStridesFromShape(const std::vector<std::size_t> &shape,; 340 bool rowmajorLayout);; 341 ; 342 void ReshapeInPlace(const Shape_t & newShape) {; 343 fShape = newShape;; 344 fStrides = ComputeStridesFromShape(fShape, fMemoryLayout == MemoryLayout::RowMajor);; 345 fNDim = fShape.size();; 346 // in principle reshape should not change tensor size; 347 size_t newSize = (fMemoryLayout == MemoryLayout::RowMajor) ? fStrides.front() * fShape.front() : fStrides.back()",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/CudaTensor_8h_source.html:12934,assert,assert,12934,doc/master/CudaTensor_8h_source.html,https://root.cern,https://root.cern/doc/master/CudaTensor_8h_source.html,2,['assert'],['assert']
Testability,"mode optimization with given definition of observables.; The cache operation mode of all objects in the expression tree will; modified such that all nodes that depend directly or indirectly on; any of the listed observables will be set to ADirty, as they are; expected to change every time. This save change tracking overhead for; nodes that are a priori known to change every time. void optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Activate cache mode optimization with given definition of observables.; The cache operation mode of all objects in the expression tree will; modified such that all nodes that depend directly or indirectly on; any of the listed observables will be set to ADirty, as they are; expected to change every time. This save change tracking overhead for; nodes that are a priori known to change every time. Bool_t findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList); Find branch nodes with all-constant parameters, and add them to the list of; nodes that can be cached with a dataset in a test statistic calculation. Bool_t findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList, RooLinkedList& processedNodes); Find branch nodes with all-constant parameters, and add them to the list of; nodes that can be cached with a dataset in a test statistic calculation. void constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); Interface function signaling a request to perform constant term; optimization. This default implementation takes no action other than to; forward the calls to all servers. void setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); Change cache operation mode to given mode. If recurseAdirty; is true, then a mode change to AlwaysDirty will automatically; be propagated recursively to all client nodes. void printCompactTree(const char* indent = """", const char* fileName = 0, const char* namePat = 0, RooAbsArg* client = 0); Print tree structure of",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooAbsArg.html:30551,test,test,30551,root/html528/RooAbsArg.html,https://root.cern,https://root.cern/root/html528/RooAbsArg.html,2,['test'],['test']
Testability,"mode optimization with given definition of observables.; The cache operation mode of all objects in the expression tree will; modified such that all nodes that depend directly or indirectly on; any of the listed observables will be set to ADirty, as they are; expected to change every time. This save change tracking overhead for; nodes that are a priori known to change every time. void optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Activate cache mode optimization with given definition of observables.; The cache operation mode of all objects in the expression tree will; modified such that all nodes that depend directly or indirectly on; any of the listed observables will be set to ADirty, as they are; expected to change every time. This save change tracking overhead for; nodes that are a priori known to change every time. Bool_t findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList); Find branch nodes with all-constant parameters, and add them to the list of; nodes that can be cached with a dataset in a test statistic calculation. Bool_t findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList, RooLinkedList& processedNodes); Find branch nodes with all-constant parameters, and add them to the list of; nodes that can be cached with a dataset in a test statistic calculation. void constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); Interface function signaling a request to perform constant term; optimization. This default implementation takes no action other than to; forward the calls to all servers. void setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); Change cache operation mode to given mode. If recurseAdirty; is true, then a mode change to AlwaysDirty will automatically; be propagated recursively to all client nodes. void printCompactTree(const char* indent, const char* filename, const char* namePat, RooAbsArg* client); Print tree structure of expression tree ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAbsArg.html:30348,test,test,30348,root/html526/RooAbsArg.html,https://root.cern,https://root.cern/root/html526/RooAbsArg.html,1,['test'],['test']
Testability,"mode optimization with given definition of observables.; The cache operation mode of all objects in the expression tree will; modified such that all nodes that depend directly or indirectly on; any of the listed observables will be set to ADirty, as they are; expected to change every time. This save change tracking overhead for; nodes that are a priori known to change every time. void optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Activate cache mode optimization with given definition of observables.; The cache operation mode of all objects in the expression tree will; modified such that all nodes that depend directly or indirectly on; any of the listed observables will be set to ADirty, as they are; expected to change every time. This save change tracking overhead for; nodes that are a priori known to change every time. Bool_t findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList); Find branch nodes with all-constant parameters, and add them to the list of; nodes that can be cached with a dataset in a test statistic calculation. Bool_t findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList, RooLinkedList& processedNodes); Find branch nodes with all-constant parameters, and add them to the list of; nodes that can be cached with a dataset in a test statistic calculation. void constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); Interface function signaling a request to perform constant term; optimization. This default implementation takes no action other than to; forward the calls to all servers. void setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); Change cache operation mode to given mode. If recurseAdirty; is true, then a mode change to AlwaysDirty will automatically; be propagated recursively to all client nodes. void printCompactTree(const char* indent = """", const char* fileName = 0, const char* namePat = 0, RooAbsArg* cl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooAbsArg.html:30808,test,test,30808,root/html532/RooAbsArg.html,https://root.cern,https://root.cern/root/html532/RooAbsArg.html,4,['test'],['test']
Testability,"moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tRooAbsPdf::mustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; const char*RooAbsPdf::normRange() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooBukinPdf&operator=(const RooBukinPdf&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsPdf::paramOn(RooPlot* frame, const RooAbsData* data, const char* label = """", Int_t sigDigits = 2, Option_t* options = ""NELU"", Double_t xmin = 0.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooBukinPdf.html:23091,test,testArg,23091,root/html602/RooBukinPdf.html,https://root.cern,https://root.cern/root/html602/RooBukinPdf.html,2,['test'],['testArg']
Testability,"moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tRooAbsPdf::mustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; const char*RooAbsPdf::normRange() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooGaussian&operator=(const RooGaussian&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsPdf::paramOn(RooPlot* frame, const RooAbsData* data, const char* label = """", Int_t sigDigits = 2, Option_t* options = ""NELU"", Double_t xmin = 0.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooGaussian.html:23001,test,testArg,23001,root/html602/RooGaussian.html,https://root.cern,https://root.cern/root/html602/RooGaussian.html,2,['test'],['testArg']
Testability,"moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tRooAbsPdf::mustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; const char*RooAbsPdf::normRange() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooVoigtian&operator=(const RooVoigtian&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsPdf::paramOn(RooPlot* frame, const RooAbsData* data, const char* label = """", Int_t sigDigits = 2, Option_t* options = ""NELU"", Double_t xmin = 0.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooVoigtian.html:23516,test,testArg,23516,root/html602/RooVoigtian.html,https://root.cern,https://root.cern/root/html602/RooVoigtian.html,2,['test'],['testArg']
Testability,"moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tRooAbsPdf::mustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; const char*RooAbsPdf::normRange() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooCFunction4PdfBinding<double,double,double,double,double>&operator=(const RooCFunction4PdfBinding<double,double,double,double,double>&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsPdf::paramOn(RooPlot* frame, const RooAbsData* data, const char* label = """", Int_t sigDigits = 2, Option_t* options = ""NELU"", Double_t xmin = 0.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooCFunction4PdfBinding_double_double_double_double_double_.html:23842,test,testArg,23842,root/html602/RooCFunction4PdfBinding_double_double_double_double_double_.html,https://root.cern,https://root.cern/root/html602/RooCFunction4PdfBinding_double_double_double_double_double_.html,2,['test'],['testArg']
Testability,"more than one adequate generator. If you use Visual Studio, NMake Makefiles is a generator you can use for building with NMake. By default, CMake chooses the most specific generator supported by your development environment. If you want an alternative generator, you must tell this to CMake with the -G option.; Options and variables; Variables customize how the build will be generated. Options are boolean variables, with possible values ON/OFF. Options and variables are defined on the CMake command line like this:; $ cmake -DVARIABLE=value path/to/source. You can set a variable after the initial CMake invocation to change its value. You can also undefine a variable:; $ cmake -UVARIABLE path/to/source. Variables are stored in the CMake cache. This is a file named CMakeCache.txt stored at the root of your build directory that is generated by cmake. Editing it yourself is not recommended.; Variables are listed in the CMake cache with the variable name and type separated by a colon. You can also specify the variable and type on the CMake command line:; $ cmake -DVARIABLE:TYPE=value path/to/source. Variables in the CMake cache are 'remembered', so you do not need to type them if you execute cmake command again. It is recommended to delete the file CMakeCache.txt to start from a clean configuration. Sitemap. DownloadDownload ROOT; All Releases. DocumentationReference Manual; User's Guides; HowTo; Courses; Building ROOT; Tutorials; Javascript Root; ROOT and Spark; Publications; FAQ. NewsBlog; Workshops. SupportForum; Bug submission guidelines; Submit a Bug; Discourse Mailing List Mode; RootTalk Digest. AboutLicence; Contact Us; Project Founders; Team; Previous Developers. DevelopmentProgram of Work; Code Owners; Release Checklist; Coding Conventions; Shifter's Instructions; Git Primer; Browse Sources; Meetings; ROOT 7; Run the tests; Jenkins; Setup externals from AFS/CVMFS; Doxygen; Benchmarks. ContributeCollaborate with Us.  Copyright CERN 2014-18. All rights reserved. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/building-root.html:24128,test,tests,24128,d/building-root.html,https://root.cern,https://root.cern/d/building-root.html,1,['test'],['tests']
Testability,"mory overhead when including <vector>; 211 // In $ROOTSYS/etc/system.rootrc, you can set the variable Rint.Includes to 0; 212 // to disable the loading of these includes at startup.; 213 // You can set the variable to 1 (default) to load only <iostream>, <string> and <DllImport.h>; 214 // You can set it to 2 to load in addition <vector> and <utility>; 215 // We strongly recommend setting the variable to 2 if your scripts include <vector>; 216 // and you execute your scripts multiple times.; 217 if (includes > 0) {; 218 TString code;; 219 code = ""#include <iostream>\n""; 220 ""#include <string>\n"" // for std::string std::iostream.; 221 ""#include <DllImport.h>\n"";// Defined R__EXTERN; 222 if (includes > 1) {; 223 code += ""#include <vector>\n""; 224 ""#include <utility>"";; 225 }; 226 ProcessLine(code, kTRUE);; 227 }; 228 }; 229 ; 230 // Load user functions; 231 const char *logon;; 232 logon = gEnv->GetValue(""Rint.Load"", (char*)nullptr);; 233 if (logon) {; 234 char *mac = gSystem->Which(TROOT::GetMacroPath(), logon, kReadPermission);; 235 if (mac); 236 ProcessLine(Form("".L %s"",logon), kTRUE);; 237 delete [] mac;; 238 }; 239 ; 240 // Execute logon macro; 241 ExecLogon();; 242 ; 243 // Save current interpreter context; 244 gCling->SaveContext();; 245 gCling->SaveGlobalsContext();; 246 ; 247 // Install interrupt and terminal input handlers; 248 TInterruptHandler *ih = new TInterruptHandler();; 249 ih->Add();; 250 SetSignalHandler(ih);; 251 ; 252 // Handle stdin events; 253 fInputHandler = new TTermInputHandler(0);; 254 fInputHandler->Add();; 255 ; 256 // Goto into raw terminal input mode; 257 char defhist[kMAXPATHLEN];; 258 snprintf(defhist, sizeof(defhist), ""%s/.root_hist"", gSystem->HomeDirectory());; 259 logon = gEnv->GetValue(""Rint.History"", defhist);; 260 // In the code we had HistorySize and HistorySave, in the rootrc and doc; 261 // we have HistSize and HistSave. Keep the doc as it is and check; 262 // now also for HistSize and HistSave in case the user did not use; 263 ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TRint_8cxx_source.html:7784,log,logon,7784,doc/master/TRint_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TRint_8cxx_source.html,2,['log'],['logon']
Testability,"mous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGraphPainter(). Default constructor; ; . ~TGraphPainter(). Destructor.; ; . void ComputeLogs(Int_t npoints, Int_t opt). Compute the logarithm of global variables gxwork and gywork; according to the value of Options and put the results in the global; variables gxworkl and gyworkl.; ; npoints : Number of points in gxwork and in gywork.; ; opt = 1 ComputeLogs is called from PaintGrapHist; opt = 0 ComputeLogs is called from PaintGraph; ; . Int_t DistancetoPrimitiveHelper(TGraph* theGraph, Int_t px, Int_t py). Compute distance from point px,py to a graph.; ; Compute the closest distance of approach from point px,py to this line.; The distance is computed in pixels units.; ; . void DrawPanelHelper(TGraph* theGraph). Display a panel with all histogram drawing options.; ; . void ExecuteEventHelper(TGraph* theGraph, Int_t event, Int_t px, Int_t py). Execute action corresponding to one event.; ; This member function is called when a graph is clicked with the locator.; ; If the left mouse button is clicked on one of the line end points, this point; follows the cursor until button is released.; ; If the middle mouse button clicked, the line is moved parallel to itself; until the button is rele",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGraphPainter.html:20284,log,logarithm,20284,root/html602/TGraphPainter.html,https://root.cern,https://root.cern/root/html602/TGraphPainter.html,2,['log'],['logarithm']
Testability,"mous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. Bool_t_debug; TFile*_refFile; list<pair<RooPlot*,string> >_regPlots; list<pair<RooFitResult*,string> >_regResults; list<pair<TH1*,string> >_regTH; list<pair<RooTable*,string> >_regTables; list<pair<Double_t,string> >_regValues; list<pair<RooWorkspace*,string> >_regWS; Int_t_verb; Bool_t_write; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; static TDirectory*gMemDir. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooUnitTest(const char* name, TFile* refFile, Bool_t writeRef, Int_t verbose). ~RooUnitTest(). void regPlot(RooPlot* frame, const char* refName). void regResult(RooFitResult* r, const char* refName). void regValue(Double_t value, const char* refName). void regTable(RooTable* t, const char* refName). void regWS(RooWorkspace* ws, const char* refName). void regTH(TH1* h, const char* refName). RooWorkspace* getWS(const char* refName). Bool_t areTHidentical(TH1* htest, TH1* href). Bool_t runCompTests(). void setSilentMode(). void clearSilentMode(). Bool_t runTest(). void setMemDir(TDirectory* memDir); Set gMemDir to memDir. RooUnitTest(const char* name, TFile* refFile, Bool_t writeRef, Int_t verbose). void setDebug(Bool_t flag); { _debug = flag ; }. Bool_t isTestAvailable(); { return kTRUE ; }. Bool_t testCode(). Double_t htol(); { return 5e-4 ; }. Double_t ctol(); { return 2e-3 ; }. Double_t fptol(); { return 1e-3 ; }. Double_t fctol(); { return 1e-3 ; }. Double_t vtol(); { return 1e-3 ; }.  Last changed: Tue Jun 2 15:36:32 2015  Last generated: 2015-06-02 15:36; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/RooUnitTest.html:8552,test,testCode,8552,root/html604/RooUnitTest.html,https://root.cern,https://root.cern/root/html604/RooUnitTest.html,1,['test'],['testCode']
Testability,"mous)TObject::kZombie. private:. TStopwatchfComputemeasures time spend processing a query on the master; Int_tfDrawQueriesnumber of draw queries processed; Int_tfKeptQueriesnumber of queries fully in memory and in dir; TProofLockPath*fLockdir locker; FILE*fLogFilelog file; TList*fPreviousQuerieslist of TProofQueryResult objects from previous sections; TList*fQuerieslist of TProofQueryResult objects; TStringfQueryDirdirectory containing query results and status; Int_tfSeqNumsequential number of last processed query; TStringfSessionDirdirectory containing session dependent files; TStringfSessionTagtag for the session. Class Charts. Inheritance Chart:. TObject. ; TQueryResultManager. Function documentation; TQueryResultManager(const char* qdir, const char* stag, const char* sdir, TProofLockPath* lck, FILE* logfile = 0); Constructor. ~TQueryResultManager(); Cleanup. Not really necessary since after this dtor there is no; live anyway. void AddLogFile(TProofQueryResult* pq); Add part of log file concerning TQueryResult pq to its macro; container. Int_t CleanupQueriesDir(); Remove all queries results referring to previous sessions. void ScanPreviousQueries(const char* dir); Scan the queries directory for the results of previous queries.; The headers of the query results found are loaded in fPreviousQueries.; The full query result can be retrieved via TProof::Retrieve. Int_t ApplyMaxQueries(Int_t mxq); Scan the queries directory and remove the oldest ones (and relative dirs,; if empty) in such a way only 'mxq' queries are kept.; Return 0 on success, -1 in case of problems. Int_t LockSession(const char* sessiontag, TProofLockPath** lck); Try locking query area of session tagged sessiontag.; The id of the locking file is returned in fid and must be; unlocked via UnlockQueryFile(fid). Int_t CleanupSession(const char* sessiontag); Cleanup query dir qdir. void SaveQuery(TProofQueryResult* qr, const char* fout = 0); Save current status of query 'qr' to file name fout.; If fout ==",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TQueryResultManager.html:7686,log,log,7686,root/html602/TQueryResultManager.html,https://root.cern,https://root.cern/root/html602/TQueryResultManager.html,1,['log'],['log']
Testability,"mous)TObject::kZombie. private:. TStopwatchfComputemeasures time spend processing a query on the master; Int_tfDrawQueriesnumber of draw queries processed; Int_tfKeptQueriesnumber of queries fully in memory and in dir; TProofLockPath*fLockdir locker; FILE*fLogFilelog file; TList*fPreviousQuerieslist of TProofQueryResult objects from previous sections; TList*fQuerieslist of TProofQueryResult objects; TStringfQueryDirdirectory containing query results and status; Int_tfSeqNumsequential number of last processed query; TStringfSessionDirdirectory containing session dependent files; TStringfSessionTagtag for the session. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TQueryResultManager(const char* qdir, const char* stag, const char* sdir, TProofLockPath* lck, FILE* logfile = 0); Constructor. ~TQueryResultManager(); Cleanup. Not really necessary since after this dtor there is no; live anyway. void AddLogFile(TProofQueryResult* pq); Add part of log file concerning TQueryResult pq to its macro; container. Int_t CleanupQueriesDir(); Remove all queries results referring to previous sessions. void ScanPreviousQueries(const char* dir); Scan the queries directory for the results of previous queries.; The headers of the query results found are loaded in fPreviousQueries.; The full query result can be retrieved via TProof::Retrieve. Int_t ApplyMaxQueries(Int_t mxq); Scan the queries directory and remove the oldest ones (and relative dirs,; if empty) in such a way only 'mxq' queries are kept.; Return 0 on success, -1 in case of problems. Int_t LockSession(const char* sessiontag, TProofLockPath** lck); Try locking query area of session tagged sessiontag.; The id of the locking file is returned in fid and must be; unlocked via UnlockQueryFile(fid). Int_t CleanupSession(const char* sessiontag); Cleanup query dir qdir. void SaveQuery(TProofQueryResult* qr, const char* fout = 0); Save current status of query 'qr' to file name fout.; If fout ==",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TQueryResultManager.html:7662,log,log,7662,root/html604/TQueryResultManager.html,https://root.cern,https://root.cern/root/html604/TQueryResultManager.html,1,['log'],['log']
Testability,"mous)TObject::kZombie. protected:. Float_t*fCpuTime[fNbench] Cpu Time; TStringTNamed::fNameobject identifier; TString*fNames[fNbench] Names of benchmarks; Int_tfNbenchNumber of active benchmarks; Int_tfNmaxMaximum number of benchmarks initialized; Float_t*fRealTime[fNbench] Real Time; TStopwatch*fTimerTimers; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBenchmark(); Benchmark default constructor. TBenchmark(const TBenchmark& ); Copy constructor. TBenchmark& operator=(const TBenchmark& ); Assignment operator. ~TBenchmark(); Benchmark destructor. Int_t GetBench(const char* name) const; Returns index of Benchmark name. Float_t GetCpuTime(const char* name); Returns Cpu time used by Benchmark name. Float_t GetRealTime(const char* name); Returns Realtime used by Benchmark name. void Print(Option_t* name = """") const; Prints parameters of Benchmark name. void Reset(); Reset all Benchmarks. void Show(const char* name); Stops Benchmark name and Prints results. void Start(const char* name); Starts Benchmark with the specified name. An independent timer (see class TStopwatch) is started.; The name of the benchmark is entered into the list of benchmarks.; Benchmark can be stopped via TBenchmark::Stop().; Results can be printed via TBenchmark::Print().; TBenchmark::Show() can be used to stop benchmark and print results.; If name is an already existing benchmark, timing will resume.; A summary of all benchmarks can be seen via TBenchmark::Summary(). void Stop(const char* name); Terminates Benchmark with specified name. void Summary(Float_t& rt, Float_t& cp); Prints a summary of all benchmarks.  Author: Rene Brun 12/12/94  Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *;  Last changed: root/base:$Id$  Last generated: 2015-06-02 15:38; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TBenchmark.html:7320,benchmark,benchmark,7320,root/html604/TBenchmark.html,https://root.cern,https://root.cern/root/html604/TBenchmark.html,6,['benchmark'],"['benchmark', 'benchmarks']"
Testability,"mous)TObject::kZombie. protected:. Float_t*fCpuTime[fNbench] Cpu Time; TStringTNamed::fNameobject identifier; TString*fNames[fNbench] Names of benchmarks; Int_tfNbenchNumber of active benchmarks; Int_tfNmaxMaximum number of benchmarks initialized; Float_t*fRealTime[fNbench] Real Time; TStopwatch*fTimerTimers; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBenchmark(); Benchmark default constructor. TBenchmark(const TBenchmark& ); Copy constructor. TBenchmark& operator=(const TBenchmark& ); Assignment operator. ~TBenchmark(); Benchmark destructor. Int_t GetBench(const char* name) const; Returns index of Benchmark name. Float_t GetCpuTime(const char* name); Returns Cpu time used by Benchmark name. Float_t GetRealTime(const char* name); Returns Realtime used by Benchmark name. void Print(Option_t* name = """") const; Prints parameters of Benchmark name. void Reset(); Reset all Benchmarks. void Show(const char* name); Stops Benchmark name and Prints results. void Start(const char* name); Starts Benchmark with the specified name. An independent timer (see class TStopwatch) is started.; The name of the benchmark is entered into the list of benchmarks.; Benchmark can be stopped via TBenchmark::Stop().; Results can be printed via TBenchmark::Print().; TBenchmark::Show() can be used to stop benchmark and print results.; If name is an already existing benchmark, timing will resume.; A summary of all benchmarks can be seen via TBenchmark::Summary(). void Stop(const char* name); Terminates Benchmark with specified name. void Summary(Float_t& rt, Float_t& cp); Prints a summary of all benchmarks.  Author: Rene Brun 12/12/94  Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *;  Last changed: root/base:$Id$  Last generated: 2015-06-30 14:39; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TBenchmark.html:7320,benchmark,benchmark,7320,root/html602/TBenchmark.html,https://root.cern,https://root.cern/root/html602/TBenchmark.html,6,['benchmark'],"['benchmark', 'benchmarks']"
Testability,"mpact, bool verbose=false) overrideRead object contents from stream (dummy for now)Definition RooAbsReal.cxx:426; RooAbsReal::matchArgsbool matchArgs(const RooArgSet &allDeps, RooArgSet &numDeps, const RooArgProxy &a) constUtility function for use in getAnalyticalIntegral().Definition RooAbsReal.cxx:3146; RooAbsReal::fillTreeBranchvoid fillTreeBranch(TTree &t) overrideFill the tree branch that associated with this object with its current value.Definition RooAbsReal.cxx:3099; RooAbsReal::printMultilinevoid printMultiline(std::ostream &os, Int_t contents, bool verbose=false, TString indent="""") const overrideStructure printing.Definition RooAbsReal.cxx:455; RooAbsReal::plotAsymOnvirtual RooPlot * plotAsymOn(RooPlot *frame, const RooAbsCategoryLValue &asymCat, PlotOpt o) constDefinition RooAbsReal.cxx:2199; RooAbsReal::operator==bool operator==(double value) constEquality operator comparing to a double.Definition RooAbsReal.cxx:250; RooAbsReal::evalErrorLoggingModestatic ErrorLoggingMode evalErrorLoggingMode()Return current evaluation error logging mode.Definition RooAbsReal.cxx:4302; RooAbsReal::redirectServersHookbool redirectServersHook(const RooAbsCollection &newServerList, bool mustReplaceAll, bool nameChange, bool isRecursiveStep) overrideFunction that is called at the end of redirectServers().Definition RooAbsReal.cxx:4474; RooAbsReal::isValidRealvirtual bool isValidReal(double, bool printError=false) constInterface function to check if given value is a valid value for this object. Returns true unless over...Definition RooAbsReal.h:447; RooAbsReal::setIntegratorConfigvoid setIntegratorConfig()Remove the specialized numeric integration configuration associated with this object.Definition RooAbsReal.cxx:3346; RooAbsReal::printValuevoid printValue(std::ostream &os) const overridePrint object value.Definition RooAbsReal.cxx:445; RooAbsReal::isIdenticalbool isIdentical(const RooAbsArg &other, bool assumeSameType=false) const overrideDefinition RooAbsReal.cxx:270; RooA",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RooAbsReal_8cxx_source.html:223522,log,logging,223522,doc/master/RooAbsReal_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html,1,['log'],['logging']
Testability,"mplUnionBuilderImpl(const Reflex::UnionBuilderImpl&); Reflex::UnionBuilderImplUnionBuilderImpl(const char* nam, size_t size, const type_info& ti, unsigned int modifiers = 0, Reflex::TYPE typ = UNION). protected:. voidEnableCallback(const bool enable = true). Data Members; private:. boolfCallbackEnabled; Reflex::MemberfLastMember; Reflex::Union*fUnion. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; UnionBuilderImpl(const char* nam, size_t size, const type_info& ti, unsigned int modifiers = 0, Reflex::TYPE typ = UNION); constructor . virtual ~UnionBuilderImpl(); destructor . void AddItem(const char* nam, const Reflex::Type& typ). * AddItem will add one union item; * @param Name the Name of the union item; * @param At the At of the union item. void AddFunctionMember(const char* nam, const Reflex::Type& typ, Reflex::StubFunction stubFP, void* stubCtx = 0, const char* params = 0, unsigned int modifiers = 0); AddDataMember will add the information about one data; * MemberAt of the union; *; * @param Name of the data MemberAt; * @param At of the data MemberAt; * @param Offset of the data MemberAt; * @param modifiers the modifiers of the data MemberAt. AddFunctionMember will add the information about one; * function MemberAt of the union; *; * @param Name of the function MemberAt; * @param At of the function MemberAt; * @param stubFP Stub function pointer for the function; * @param stubCxt Stub user context for the stub function; * @param params parameter names and default values (semi-colon separated); * @param modifiers the modifiers of the function MemberAt. void AddProperty(const char* key, const char* value). * AddProperty will add a PropertyNth to the PropertyNth stack; * which will be emtpied with the next build of a union; * or union item; * @param key the PropertyNth key; * @param value the value of the PropertyNth; * @return a reference to the building class. Type ToType(); SetSizeOf will set the SizeOf property for this",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/Reflex__UnionBuilderImpl.html:1807,stub,stubFP,1807,root/html526/Reflex__UnionBuilderImpl.html,https://root.cern,https://root.cern/root/html526/Reflex__UnionBuilderImpl.html,10,['stub'],"['stubCtx', 'stubFP']"
Testability,"mplate constructor.Definition GoFTest.h:73; ROOT::Math::GoFTest::kUserDefined@ kUserDefinedDefault value for non templated 1-sample test. Set with SetDistribution.Definition GoFTest.h:72; ROOT::Math::GoFTest::kUndefined@ kUndefinedDefinition GoFTest.h:71; ROOT::Math::GoFTest::fDistEDistribution fDistType of distribution.Definition GoFTest.h:238; ROOT::Math::GoFTest::Instantiatevoid Instantiate(const Double_t *sample, size_t sampleSize)Definition GoFTest.cxx:279; ROOT::Math::GoFTest::fCombinedSamplesstd::vector< Double_t > fCombinedSamplesThe combined data.Definition GoFTest.h:241; ROOT::Math::GoFTest::KolmogorovSmirnovTestvoid KolmogorovSmirnovTest(Double_t &pvalue, Double_t &testStat) constKolmogorov-Smirnov 1-Sample Test.Definition GoFTest.cxx:921; ROOT::Math::GoFTest::fParamsstd::vector< Double_t > fParamsThe distribution parameters (e.g. fParams[0] = mean, fParams[1] = sigma for a Gaussian)Definition GoFTest.h:239; ROOT::Math::GoFTest::ETestTypeETestTypeGoodness of Fit test types for using with the class's unary functions as a shorthand for the in-built...Definition GoFTest.h:85; ROOT::Math::GoFTest::kKS@ kKSAnderson-Darling 2-Samples Test.Definition GoFTest.h:88; ROOT::Math::GoFTest::kAD@ kADDefinition GoFTest.h:86; ROOT::Math::GoFTest::kKS2s@ kKS2sKolmogorov-Smirnov Test.Definition GoFTest.h:89; ROOT::Math::GoFTest::kAD2s@ kAD2sAnderson-Darling Test. Default value.Definition GoFTest.h:87; ROOT::Math::GoFTest::SetSamplesvoid SetSamples(std::vector< const Double_t * > samples, const std::vector< size_t > samplesSizes)set a vector of samplesDefinition GoFTest.cxx:181; ROOT::Math::GoFTest::PValueADKSamplesstatic Double_t PValueADKSamples(size_t nsamples, Double_t A2)Computation of the K-Sample Anderson-Darling Test's p-value as described in (1)Definition GoFTest.cxx:353; ROOT::Math::GoFTest::LogSamplevoid LogSample()Applies the logarithm to the sample when the specified distribution to test is LogNormal.Definition GoFTest.cxx:303; ROOT::Math::GoFTest::~GoFTestvirt",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/GoFTest_8cxx_source.html:40473,test,test,40473,doc/master/GoFTest_8cxx_source.html,https://root.cern,https://root.cern/doc/master/GoFTest_8cxx_source.html,1,['test'],['test']
Testability,"mplate.Definition TCling.cxx:8957; TCling::fMetaProcessorstd::unique_ptr< cling::MetaProcessor > fMetaProcessorDefinition TCling.h:131; TCling::TypeInfo_IsValidbool TypeInfo_IsValid(TypeInfo_t *tinfo) const finalDefinition TCling.cxx:9380; TCling::RegisterPrebuiltModulePathbool RegisterPrebuiltModulePath(const std::string &FullPath, const std::string &ModuleMapName=""module.modulemap"") const finalDefinition TCling.cxx:1906; TCling::MethodInfo_TypeNormalizedNamestd::string MethodInfo_TypeNormalizedName(MethodInfo_t *minfo) const finalDefinition TCling.cxx:9156; TCling::ClassInfo_Nameconst char * ClassInfo_Name(ClassInfo_t *info) const finalDefinition TCling.cxx:8434; TCling::GenerateTClassTClass * GenerateTClass(const char *classname, Bool_t emulation, Bool_t silent=kFALSE) finalGenerate a TClass for the given class.Definition TCling.cxx:4554; TCling::fTransactionCountULong64_t fTransactionCountDefinition TCling.h:148; TCling::ClassInfo_HasDefaultConstructorbool ClassInfo_HasDefaultConstructor(ClassInfo_t *info, Bool_t testio=kFALSE) const finalDefinition TCling.cxx:8253; TCling::EndOfLineActionvoid EndOfLineAction() finalIt calls a ""fantom"" method to synchronize user keyboard input and ROOT prompt line.Definition TCling.cxx:3121; TCling::TypeInfo_FactoryCopyTypeInfo_t * TypeInfo_FactoryCopy(TypeInfo_t *) const finalDefinition TCling.cxx:9364; TCling::TypeInfo_QualTypePtrvoid * TypeInfo_QualTypePtr(TypeInfo_t *tinfo) constDefinition TCling.cxx:9428; TCling::ClassInfo_HasMethodbool ClassInfo_HasMethod(ClassInfo_t *info, const char *name) const finalDefinition TCling.cxx:8261; TCling::ClassInfo_DeleteArrayvoid ClassInfo_DeleteArray(ClassInfo_t *info, void *arena, bool dtorOnly) const finalDefinition TCling.cxx:8199; TCling::fClassesHeadersMapstd::map< size_t, std::vector< const char * > > fClassesHeadersMapDefinition TCling.h:119; TCling::DataMemberInfo_TypeTrueNameconst char * DataMemberInfo_TypeTrueName(DataMemberInfo_t *dminfo) const finalDefinition TCling.cxx:8690; T",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCling_8cxx_source.html:461836,test,testio,461836,doc/master/TCling_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html,2,['test'],['testio']
Testability,"mple(); voidTObject::MakeZombie(); RooRealVar*RooAbsMCStudyModule::nllVar(); Double_tRooAbsMCStudyModule::numExpGen(); RooArgSet*RooAbsMCStudyModule::projDeps(); Bool_tRooAbsMCStudyModule::randProto(); RooFitResult*RooAbsMCStudyModule::refit(RooAbsData* inGenSample = 0); Bool_tRooAbsMCStudyModule::verboseGen(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. Double_t_cl; RooDataSet*_dataSummary dataset to store results; RooAbsPdf*_model; string_parNameName of Nsignal parameter; RooStats::ProfileLikelihoodCalculator*_plc; const RooArgSet*_poiparameters of interest; RooRealVar*_ul. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; UpperLimitMCSModule(const RooArgSet* poi, Double_t CL = 0.95). UpperLimitMCSModule(const RooStats::UpperLimitMCSModule& other); Copy constructor. Bool_t initializeInstance(); Initialize module after attachment to RooMCStudy object. Bool_t initializeRun(Int_t ); Initialize module at beginning of RooCMStudy run. RooDataSet* finalizeRun(); Return auxiliary dataset with results of delta(-log(L)); calculations of this module so that it is merged with; RooMCStudy::fitParDataSet() by RooMCStudy. Bool_t processBetweenGenAndFit(Int_t ). virtual ~UpperLimitMCSModule().  Author: Kyle Cranmer, Lorenzo Moneta, Gregory Schott, Wouter Verkerke, Nils Ruthmann  Copyright (C) 1995-2008, Rene Brun and Fons Rademakers. *;  Last changed: root/roostats:$Id: UpperLimitMCSModule.h 31276 2009-11-18 15:06:42Z moneta $  Last generated: 2009-12-07 13:49; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooStats__UpperLimitMCSModule.html:7755,log,log,7755,root/html526/RooStats__UpperLimitMCSModule.html,https://root.cern,https://root.cern/root/html526/RooStats__UpperLimitMCSModule.html,1,['log'],['log']
Testability,"mple(); voidTObject::MakeZombie(); RooRealVar*RooAbsMCStudyModule::nllVar(); Double_tRooAbsMCStudyModule::numExpGen(); RooArgSet*RooAbsMCStudyModule::projDeps(); Bool_tRooAbsMCStudyModule::randProto(); RooFitResult*RooAbsMCStudyModule::refit(RooAbsData* inGenSample = 0); Bool_tRooAbsMCStudyModule::verboseGen(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. Double_t_cl; RooDataSet*_dataSummary dataset to store results; RooAbsPdf*_model; string_parNameName of Nsignal parameter; RooStats::ProfileLikelihoodCalculator*_plc; const RooArgSet*_poiparameters of interest; RooRealVar*_ul. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; UpperLimitMCSModule(const RooArgSet* poi, Double_t CL = 0.95). UpperLimitMCSModule(const RooStats::UpperLimitMCSModule& other); Copy constructor. Bool_t initializeInstance(); Initialize module after attachment to RooMCStudy object. Bool_t initializeRun(Int_t ); Initialize module at beginning of RooCMStudy run. RooDataSet* finalizeRun(); Return auxiliary dataset with results of delta(-log(L)); calculations of this module so that it is merged with; RooMCStudy::fitParDataSet() by RooMCStudy. Bool_t processBetweenGenAndFit(Int_t ). virtual ~UpperLimitMCSModule().  Author: Kyle Cranmer, Lorenzo Moneta, Gregory Schott, Wouter Verkerke, Nils Ruthmann  Copyright (C) 1995-2008, Rene Brun and Fons Rademakers. *;  Last changed: root/roostats:$Id: UpperLimitMCSModule.h 31276 2009-11-18 15:06:42Z moneta $  Last generated: 2010-09-23 20:01; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooStats__UpperLimitMCSModule.html:7731,log,log,7731,root/html528/RooStats__UpperLimitMCSModule.html,https://root.cern,https://root.cern/root/html528/RooStats__UpperLimitMCSModule.html,1,['log'],['log']
Testability,"mple(); voidTObject::MakeZombie(); RooRealVar*RooAbsMCStudyModule::nllVar(); Double_tRooAbsMCStudyModule::numExpGen(); RooArgSet*RooAbsMCStudyModule::projDeps(); Bool_tRooAbsMCStudyModule::randProto(); RooFitResult*RooAbsMCStudyModule::refit(RooAbsData* inGenSample = 0); Bool_tRooAbsMCStudyModule::verboseGen(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. Double_t_cl; RooDataSet*_dataSummary dataset to store results; RooAbsPdf*_model; string_parNameName of Nsignal parameter; RooStats::ProfileLikelihoodCalculator*_plc; const RooArgSet*_poiparameters of interest; RooRealVar*_ul. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; UpperLimitMCSModule(const RooArgSet* poi, Double_t CL = 0.95). UpperLimitMCSModule(const RooStats::UpperLimitMCSModule& other); Copy constructor. Bool_t initializeInstance(); Initialize module after attachment to RooMCStudy object. Bool_t initializeRun(Int_t ); Initialize module at beginning of RooCMStudy run. RooDataSet* finalizeRun(); Return auxiliary dataset with results of delta(-log(L)); calculations of this module so that it is merged with; RooMCStudy::fitParDataSet() by RooMCStudy. Bool_t processBetweenGenAndFit(Int_t ). virtual ~UpperLimitMCSModule().  Author: Kyle Cranmer, Lorenzo Moneta, Gregory Schott, Wouter Verkerke, Nils Ruthmann  Copyright (C) 1995-2008, Rene Brun and Fons Rademakers. *;  Last changed: root/roostats:$Id: UpperLimitMCSModule.h 39391 2011-05-26 09:51:59Z moneta $  Last generated: 2011-07-04 15:24; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooStats__UpperLimitMCSModule.html:7810,log,log,7810,root/html530/RooStats__UpperLimitMCSModule.html,https://root.cern,https://root.cern/root/html530/RooStats__UpperLimitMCSModule.html,1,['log'],['log']
Testability,"mple(); voidTObject::MakeZombie(); RooRealVar*RooAbsMCStudyModule::nllVar(); Double_tRooAbsMCStudyModule::numExpGen(); RooArgSet*RooAbsMCStudyModule::projDeps(); Bool_tRooAbsMCStudyModule::randProto(); RooFitResult*RooAbsMCStudyModule::refit(RooAbsData* inGenSample = 0); Bool_tRooAbsMCStudyModule::verboseGen(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. Double_t_cl; RooDataSet*_dataSummary dataset to store results; RooAbsPdf*_model; string_parNameName of Nsignal parameter; RooStats::ProfileLikelihoodCalculator*_plc; const RooArgSet*_poiparameters of interest; RooRealVar*_ul. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; UpperLimitMCSModule(const RooArgSet* poi, Double_t CL = 0.95). UpperLimitMCSModule(const RooStats::UpperLimitMCSModule& other); Copy constructor. Bool_t initializeInstance(); Initialize module after attachment to RooMCStudy object. Bool_t initializeRun(Int_t ); Initialize module at beginning of RooCMStudy run. RooDataSet* finalizeRun(); Return auxiliary dataset with results of delta(-log(L)); calculations of this module so that it is merged with; RooMCStudy::fitParDataSet() by RooMCStudy. Bool_t processBetweenGenAndFit(Int_t ). virtual ~UpperLimitMCSModule().  Author: Kyle Cranmer, Lorenzo Moneta, Gregory Schott, Wouter Verkerke, Nils Ruthmann  Copyright (C) 1995-2008, Rene Brun and Fons Rademakers. *;  Last changed: root/roostats:$Id: UpperLimitMCSModule.h 39391 2011-05-26 09:51:59Z moneta $  Last generated: 2011-11-03 20:09; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooStats__UpperLimitMCSModule.html:7810,log,log,7810,root/html532/RooStats__UpperLimitMCSModule.html,https://root.cern,https://root.cern/root/html532/RooStats__UpperLimitMCSModule.html,1,['log'],['log']
Testability,"mplemented in derived PDF types. If you mean to customize the likelihood fitting routine, you need to override the virtual RooAbsPdf::fitToImpl() method.; The following named arguments are supported:. Type of CmdArg Options to control construction of -log(L) . All command arguments that can also be passed to the NLL creation method. See alsoRooAbsPdf::createNLL(). Options to control flow of fit procedure . Minimizer(""<type>"", ""<algo>"") Choose minimization package and optionally the algorithm to use. Default is MINUIT/MIGRAD through the RooMinimizer interface, but others can be specified (through RooMinimizer interface). . Type Algorithm . Minuit migrad, simplex, minimize (=migrad+simplex), migradimproved (=migrad+improve) . Minuit2 migrad, simplex, minimize, scan . GSLMultiMin conjugatefr, conjugatepr, bfgs, bfgs2, steepestdescent . GSLSimAn - . InitialHesse(bool flag) Flag controls if HESSE before MIGRAD as well, off by default . Optimize(bool flag) Activate constant term optimization of test statistic during minimization (on by default) . Hesse(bool flag) Flag controls if HESSE is run after MIGRAD, on by default . Minos(bool flag) Flag controls if MINOS is run after HESSE, off by default . Minos(const RooArgSet& set) Only run MINOS on given subset of arguments . Save(bool flag) Flag controls if RooFitResult object is produced and returned, off by default . Strategy(Int_t flag) Set Minuit strategy (0 to 2, default is 1) . MaxCalls(int n) Change maximum number of likelihood function calls from MINUIT (if n <= 0, the default of 500 * #parameters is used) . EvalErrorWall(bool flag=true) When parameters are in disallowed regions (e.g. PDF is negative), return very high value to fitter to force it out of that region. This can, however, mean that the fitter gets lost in this region. If this happens, try switching it off. . RecoverFromUndefinedRegions(double strength) When PDF is invalid (e.g. parameter in undefined region), try to direct minimiser away from that region. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsPdf.html:105909,test,test,105909,doc/master/classRooAbsPdf.html,https://root.cern,https://root.cern/doc/master/classRooAbsPdf.html,1,['test'],['test']
Testability,"mpler&). Data Members; private:. TRandom*fRand; Double_tfSize; RooRealVar*fTestStatistic. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; DebuggingSampler(). virtual ~DebuggingSampler(). SamplingDistribution* GetSamplingDistribution(RooArgSet& paramsOfInterest); Main interface to get a ConfInterval, pure virtual. Double_t EvaluateTestStatistic(RooAbsData& , RooArgSet& ); Main interface to evaluate the test statistic on a dataset. TestStatistic* GetTestStatistic() const; Get the TestStatistic. Double_t ConfidenceLevel() const; Get the Confidence level for the test. {return 1.-fSize;}. void Initialize(RooAbsArg& , RooArgSet& , RooArgSet& ); Common Initialization. void SetPdf(RooAbsPdf& ); Set the Pdf, add to the the workspace if not already there. {}. void SetParameters(RooArgSet& ); specify the parameters of interest in the interval. {}. void SetNuisanceParameters(const RooArgSet& ); specify the nuisance parameters (eg. the rest of the parameters). {}. void SetParametersForTestStat(const RooArgSet& ); specify the values of parameters used when evaluating test statistic. {}. void SetGlobalObservables(const RooArgSet& ); specify the conditional observables. {}. void SetTestSize(Double_t size); set the size of the test (rate of Type I error) ( Eg. 0.05 for a 95% Confidence Interval). {fSize = size;}. void SetConfidenceLevel(Double_t cl); set the confidence level for the interval (eg. 0.95 for a 95% Confidence Interval). {fSize = 1.-cl;}. void SetTestStatistic(RooStats::TestStatistic* ); Set the TestStatistic (want the argument to be a function of the data & parameter points.  Author: Kyle Cranmer, Lorenzo Moneta, Gregory Schott, Wouter Verkerke  Copyright (C) 1995-2008, Rene Brun and Fons Rademakers. *;  Last changed: root/roostats:$Id$  Last generated: 2015-06-30 14:36; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooStats__DebuggingSampler.html:3393,test,test,3393,root/html602/RooStats__DebuggingSampler.html,https://root.cern,https://root.cern/root/html602/RooStats__DebuggingSampler.html,2,['test'],['test']
Testability,"mpler&). Data Members; private:. TRandom*fRand; Double_tfSize; RooRealVar*fTestStatistic. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; DebuggingSampler(). virtual ~DebuggingSampler(). SamplingDistribution* GetSamplingDistribution(RooArgSet& paramsOfInterest); Main interface to get a ConfInterval, pure virtual. Double_t EvaluateTestStatistic(RooAbsData& , RooArgSet& ); Main interface to evaluate the test statistic on a dataset. TestStatistic* GetTestStatistic() const; Get the TestStatistic. Double_t ConfidenceLevel() const; Get the Confidence level for the test. {return 1.-fSize;}. void Initialize(RooAbsArg& , RooArgSet& , RooArgSet& ); Common Initialization. void SetPdf(RooAbsPdf& ); Set the Pdf, add to the the workspace if not already there. {}. void SetParameters(RooArgSet& ); specify the parameters of interest in the interval. {}. void SetNuisanceParameters(const RooArgSet& ); specify the nuisance parameters (eg. the rest of the parameters). {}. void SetParametersForTestStat(const RooArgSet& ); specify the values of parameters used when evaluating test statistic. {}. void SetGlobalObservables(const RooArgSet& ); specify the conditional observables. {}. void SetTestSize(Double_t size); set the size of the test (rate of Type I error) ( Eg. 0.05 for a 95% Confidence Interval). {fSize = size;}. void SetConfidenceLevel(Double_t cl); set the confidence level for the interval (eg. 0.95 for a 95% Confidence Interval). {fSize = 1.-cl;}. void SetTestStatistic(RooStats::TestStatistic* ); Set the TestStatistic (want the argument to be a function of the data & parameter points.  Author: Kyle Cranmer, Lorenzo Moneta, Gregory Schott, Wouter Verkerke  Copyright (C) 1995-2008, Rene Brun and Fons Rademakers. *;  Last changed: root/roostats:$Id$  Last generated: 2015-09-08 17:42; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/RooStats__DebuggingSampler.html:3393,test,test,3393,root/html604/RooStats__DebuggingSampler.html,https://root.cern,https://root.cern/root/html604/RooStats__DebuggingSampler.html,2,['test'],['test']
Testability,mplerOptions.cxx; Factory.cxx; FitConfig.cxx; FitResult.cxx; Fitter.cxx; FitUtil.cxx; FitUtilParallel.cxx; GaussIntegrator.cxx; GaussLegendreIntegrator.cxx; GenAlgoOptions.cxx; GoFTest.cxx; Integrator.cxx; IntegratorOptions.cxx; MersenneTwisterEngine.cxx; MinimizerOptions.cxx; MinimizerVariableTransformation.cxx; MinimTransformFunction.cxx; mixmax.cxx; mixmax.h; mixmax_skip_N256.icc; MixMaxEngine.cxx; ParameterSettings.cxx; PdfFuncMathCore.cxx; ProbFuncMathCore.cxx; QuantFuncMathCore.cxx; RandomFunctions.cxx; RichardsonDerivator.cxx; RootFinder.cxx; SparseData.cxx; SpecFuncCephes.cxx; SpecFuncCephes.h; SpecFuncCephesInv.cxx; SpecFuncMathCore.cxx; TComplex.cxx; TDataPointN.cxx; TKDTree.cxx; TKDTreeBinning.cxx; TMath.cxx; TRandom.cxx; TRandom1.cxx; TRandom2.cxx; TRandom3.cxx; triangle.c; triangle.h; TStatistic.cxx; UnBinData.cxx; test; fit; GaussFunction.h; MinimizerTypes.h; SparseDataComparer.cxx; SparseFit3.cxx; SparseFit4.cxx; testFit.cxx; testFitPerf.cxx; testGraphFit.cxx; testMinim.cxx; testRooFit.cxx; WrapperRooPdf.h; binarySearchTime.cxx; kDTreeTest.cxx; newKDTreeTest.cxx; stdsort.cxx; stressGoFTest.cxx; stressTF1.cxx; stressTMath.cxx; testAnalyticalIntegrals.cxx; testBinarySearch.cxx; testDistSampler.cxx; testIntegration.cxx; testIntegrationMultiDim.cxx; testkdTreeBinning.cxx; testMathRandom.cxx; testRootFinder.cxx; testSampleQuantiles.cxx; testSortOrder.cxx; testSpecFuncBeta.cxx; testSpecFuncBetaI.cxx; testSpecFuncErf.cxx; testSpecFuncGamma.cxx; testSpecFuncSiCi.cxx; testTMath.cxx; testTStatistic.cxx; v7; inc; ROOT; TFit.h; mathmore; inc; Math; ChebyshevApprox.h; Derivator.h; DistFuncMathMore.h; GSLFunctionAdapter.h; GSLIntegrator.h; GSLMCIntegrator.h; GSLMinimizer.h; GSLMinimizer1D.h; GSLMultiRootFinder.h; GSLNLSMinimizer.h; GSLQuasiRandom.h; GSLRandom.h; GSLRandomFunctions.h; GSLRndmEngines.h; GSLRootFinder.h; GSLRootFinderDeriv.h; GSLRo,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html606/files.html:45887,test,testFit,45887,root/html606/files.html,https://root.cern,https://root.cern/root/html606/files.html,1,['test'],['testFit']
Testability,"mplete gamma function, ROOT::Math::inc_gamma, from Cephes ; Definition at line 204 of file ProbFuncMathCore.cxx. gamma_cdf_c(). double ROOT::Math::gamma_cdf_c ; (; double; x, . double; alpha, . double; theta, . double; x0 = 0. ). Complement of the cumulative distribution function of the gamma distribution (upper tail). . \[ D(x) = \int_{x}^{+\infty} {1 \over \Gamma(\alpha) \theta^{\alpha}} x'^{\alpha-1} e^{-x'/\theta} dx' \]. For detailed description see Mathworld. It is implemented using the incomplete gamma function, ROOT::Math::inc_gamma, from Cephes ; Definition at line 198 of file ProbFuncMathCore.cxx. landau_cdf(). double ROOT::Math::landau_cdf ; (; double; x, . double; xi = 1, . double; x0 = 0. ). Cumulative distribution function of the Landau distribution (lower tail). . \[ D(x) = \int_{-\infty}^{x} p(x) dx \]. where \(p(x)\) is the Landau probability density function : ; \[ p(x) = \frac{1}{\xi} \phi (\lambda) \]. with ; \[ \phi(\lambda) = \frac{1}{2 \pi i}\int_{c-i\infty}^{c+i\infty} e^{\lambda s + s \log{s}} ds\]. with \(\lambda = (x-x_0)/\xi\). For a detailed description see K.S. Klbig and B. Schorr, A program package for the Landau distribution, Computer Phys. Comm. 31 (1984) 97-111 [Erratum-ibid. 178 (2008) 972]. The same algorithms as in CERNLIB (DISLAN) is used.; Parameters. xThe argument \(x\) ; xiThe width parameter \(\xi\) ; x0The location parameter \(x_0\) . Definition at line 336 of file ProbFuncMathCore.cxx. landau_cdf_c(). double ROOT::Math::landau_cdf_c ; (; double; x, . double; xi = 1, . double; x0 = 0. ). inline . Complement of the distribution function of the Landau distribution (upper tail). . \[ D(x) = \int_{x}^{+\infty} p(x) dx \]. where p(x) is the Landau probability density function. It is implemented simply as 1. - landau_cdf; Parameters. xThe argument \(x\) ; xiThe width parameter \(\xi\) ; x0The location parameter \(x_0\) . Definition at line 402 of file ProbFuncMathCore.h. lognormal_cdf(). double ROOT::Math::l",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__ProbFunc.html:16094,log,log,16094,doc/master/group__ProbFunc.html,https://root.cern,https://root.cern/doc/master/group__ProbFunc.html,1,['log'],['log']
Testability,"mputation graph is printed.; Following there is an example of usage: // First, a sample computational graph is built; ROOT::RDataFrame df(""tree"", ""f.root"");; ; auto df2 = df.Define(""x"", []() { return 1; }); .Filter(""col0 % 1 == col0""); .Filter([](int b1) { return b1 <2; }, {""cut1""}); .Define(""y"", []() { return 1; });; ; auto count = df2.Count();; ; // Prints the graph to the rd1.dot file in the current directory; ROOT::RDF::SaveGraph(df, ""./mydot.dot"");; // Prints the graph to standard output; ROOT::RDF::SaveGraph(df);; ROOT::RDF::SaveGraphstd::string SaveGraph(NodeType node)Create a graphviz representation of the dataframe computation graph, return it as a string.Definition RDFHelpers.hxx:120; The generated graph can be rendered using one of the graphviz filters, e.g. dot. For instance, the image below can be generated with the following command: $ dot -Tpng computation_graph.dot -ocomputation_graph.png. Activating RDataFrame execution logs; RDataFrame has experimental support for verbose logging of the event loop runtimes and other interesting related information. It is activated as follows: #include <ROOT/RLogger.hxx>; ; // this increases RDF's verbosity level as long as the `verbosity` variable is in scope; auto verbosity = ROOT::Experimental::RLogScopedVerbosity(ROOT::Detail::RDF::RDFLogChannel(), ROOT::Experimental::ELogLevel::kInfo);; RLogger.hxx; ROOT::Experimental::RLogScopedVerbosityChange the verbosity level (global or specific to the RLogChannel passed to the constructor) for the ...Definition RLogger.hxx:243; ROOT::Detail::RDF::RDFLogChannelROOT::Experimental::RLogChannel & RDFLogChannel()Definition RDFUtils.cxx:37; ROOT::Experimental::ELogLevel::kInfo@ kInfoInformational messages; used for instance for tracing.; or in Python: import ROOT; ; verbosity = ROOT.Experimental.RLogScopedVerbosity(ROOT.Detail.RDF.RDFLogChannel(), ROOT.Experimental.ELogLevel.kInfo); More information (e.g. start and end of each multi-thread task) is printed using ELogLevel.kDebu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1RDataFrame.html:75130,log,logs,75130,doc/v632/classROOT_1_1RDataFrame.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1RDataFrame.html,4,['log'],"['logging', 'logs']"
Testability,"mt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; Double_tTMVA::PDEFoamDensityBase::GetBoxVolume(); TMVA::MsgLogger&TMVA::PDEFoamDensityBase::Log() const; voidTObject::MakeZombie(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TMVA::BinarySearchTree*TMVA::PDEFoamDensityBase::fBstBinary tree to find events within a volume; TMVA::MsgLogger*TMVA::PDEFoamDensityBase::fLogger! message logger. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; PDEFoamEventDensity(); {}. PDEFoamEventDensity(vector<Double_t> box); User construcor. Parameters:. - box - size of sampling box. PDEFoamEventDensity(const TMVA::PDEFoamEventDensity& ); Copy constructor. Double_t Density(vector<Double_t>& Xarg, Double_t& event_density); This function is needed during the foam buildup. It returns the; event density within the range-searching volume (specified by; fBox). Parameters:. - Xarg - event vector (in [fXmin,fXmax]) to place the box at. - event_density - here the event density is stored. Returns:. Number of events (event weights), which were found in the; range-searching volume at point 'Xarg', divided by the box; volume. virtual ~PDEFoamEventDensity(); {}.  Author: Tancredi Carli, Dominik Dannheim, Alexander Voigt  Copyright (c) 2008, 2010: *;  Last changed: root/tmva $Id",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TMVA__PDEFoamEventDensity.html:6015,log,logger,6015,root/html530/TMVA__PDEFoamEventDensity.html,https://root.cern,https://root.cern/root/html530/TMVA__PDEFoamEventDensity.html,2,['log'],['logger']
Testability,"mt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; Double_tTMVA::PDEFoamDensityBase::GetBoxVolume(); TMVA::MsgLogger&TMVA::PDEFoamDensityBase::Log() const; voidTObject::MakeZombie(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TMVA::BinarySearchTree*TMVA::PDEFoamDensityBase::fBstBinary tree to find events within a volume; TMVA::MsgLogger*TMVA::PDEFoamDensityBase::fLogger! message logger. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; PDEFoamEventDensity(); {}. PDEFoamEventDensity(vector<Double_t> box); User construcor. Parameters:. - box - size of sampling box. PDEFoamEventDensity(const TMVA::PDEFoamEventDensity& ); Copy constructor. Double_t Density(vector<Double_t>& Xarg, Double_t& event_density); This function is needed during the foam buildup. It returns the; event density within the range-searching volume (specified by; fBox). Parameters:. - xev - event vector (in [fXmin,fXmax]) to place the box at. - event_density - here the event density is stored. Returns:. Number of events (event weights), which were found in the; range-searching volume at point 'xev', divided by the box; volume. virtual ~PDEFoamEventDensity(); {}.  Author: Tancredi Carli, Dominik Dannheim, Alexander Voigt  Copyright (c) 2008, 2010: *;  Last changed: root/tmva $Id$ ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TMVA__PDEFoamEventDensity.html:6034,log,logger,6034,root/html534/TMVA__PDEFoamEventDensity.html,https://root.cern,https://root.cern/root/html534/TMVA__PDEFoamEventDensity.html,1,['log'],['logger']
Testability,"mulateEvent(const TMVA::Event* ev); voidSteepestDir(TMatrixD& Dir); voidTrain(Int_t nEpochs); voidTrainOneEpoch(); voidTrainOneEvent(Int_t ievt); voidTrainOneEventFast(Int_t ievt, Float_t*& branchVar, Int_t& type); voidUpdateNetwork(Double_t desired, Double_t eventWeight = 1.0); voidUpdateNetwork(const vector<Float_t>& desired, Double_t eventWeight = 1.0); voidUpdatePriors(); voidUpdateRegulators(); voidUpdateSynapses(). Data Members; public:. enum ETrainingMethod { kBP; kBFGS; kGA; };; enum EBPTrainingMode { kSequential; kBatch; };; enum TMVA::MethodANNBase::EEstimator { kMSE; kCE; };; enum TMVA::MethodBase::EWeightFileType { kROOT; kTEXT; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. public:. Bool_tTMVA::MethodBase::fSetupCompletedis method setup; const TMVA::Event*TMVA::MethodBase::fTmpEvent! temporary event when testing on a different DataSet than the own one. protected:. TMVA::TActivation*TMVA::MethodANNBase::fActivationactivation function to be used for hidden layers; TMVA::Types::EAnalysisTypeTMVA::MethodBase::fAnalysisTypemethod-mode : true --> regression, false --> classification; UInt_tTMVA::MethodBase::fBackgroundClassindex of the Background-class; vector<TH1*>TMVA::MethodANNBase::fEpochMonHistBepoch monitoring hitograms for background; vector<TH1*>TMVA::MethodANNBase::fEpochMonHistSepoch monitoring hitograms for signal; vector<TH1*>TMVA::MethodANNBase::fEpochMonHistWepoch monitoring hitograms for weights; TMVA::MethodANNBase::EEstimatorTMVA::MethodANNBase::fEstimator; TH1F*TMVA::MethodANNBase::fEstimatorHistTestmonitors convergence of independent test sample; TH1F*TMVA::MethodANNBase::fEstimatorHistTrainmonitors convergence of training sample; TStringTMVA::MethodANNBase::fEstimatorS; TMVA::TActivation*TMVA::MethodANNBase::fIdentityactivation for in",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TMVA__MethodMLP.html:18059,test,testing,18059,root/html534/TMVA__MethodMLP.html,https://root.cern,https://root.cern/root/html534/TMVA__MethodMLP.html,1,['test'],['testing']
Testability,"mulative distribution function of the upper tail of the uniform (flat) distribution (uniform_cdf_c). ; ; doubleuniform_quantile (double z, double a, double b); Inverse ( \(D^{-1}(z)\)) of the cumulative distribution function of the lower tail of the uniform (flat) distribution (uniform_cdf). ; ; doublelandau_quantile (double z, double xi=1); Inverse ( \(D^{-1}(z)\)) of the cumulative distribution function of the lower tail of the Landau distribution (landau_cdf). ; ; doublelandau_quantile_c (double z, double xi=1); Inverse ( \(D^{-1}(z)\)) of the cumulative distribution function of the upper tail of the landau distribution (landau_cdf_c). ; ; Special Functions from MathCore; doubleerf (double x); Error function encountered in integrating the normal distribution. ; ; doubleerfc (double x); Complementary error function. ; ; doubletgamma (double x); The gamma function is defined to be the extension of the factorial to real numbers. ; ; doublelgamma (double x); Calculates the logarithm of the gamma function. ; ; doubleinc_gamma (double a, double x); Calculates the normalized (regularized) lower incomplete gamma function (lower integral) ; ; doubleinc_gamma_c (double a, double x); Calculates the normalized (regularized) upper incomplete gamma function (upper integral) ; ; doublebeta (double x, double y); Calculates the beta function. ; ; doubleinc_beta (double x, double a, double b); Calculates the normalized (regularized) incomplete beta function. ; ; doublesinint (double x); Calculates the sine integral. ; ; doublecosint (double x); Calculates the real part of the cosine integral Re(Ci). ; ; Quantile Functions from MathMore; The implementation used is that of GSL. . doubletdistribution_quantile_c (double z, double r); Inverse ( \(D^{-1}(z)\)) of the cumulative distribution function of the upper tail of Student's t-distribution (tdistribution_cdf_c). ; ; doubletdistribution_quantile (double z, double r); Inverse ( \(D^{-1}(z)",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/namespaceROOT_1_1Math.html:110399,log,logarithm,110399,doc/master/namespaceROOT_1_1Math.html,https://root.cern,https://root.cern/doc/master/namespaceROOT_1_1Math.html,2,['log'],['logarithm']
Testability,"multaneous (if any); RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; Bool_t_splitRangeSplit rangeName in RooSimultaneous index labels if true; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; Bool_t_verboseVerbose messaging if true; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~RooAbsTestStatistic(); Destructor. Double_t evaluate() const; Calculates and return value of test statistic. If the test statistic; is calculated from on a RooSimultaneous, the test statistic calculation; is performed separately on each simultaneous p.d.f component and associated; data and then combined. If the test statistic calculation is parallelized; partitions are calculated in nCPU processes and a posteriori combined. Bool_t initialize(); One-time initialization of the test statistic. Setup; infrastructure for simultaneous p.d.f processing and/or; parallelized processing if requested. Bool_t redirectServersHook(const RooAbsCollection& newServerList, Bool_t mustReplaceAll, Bool_t nameChange, Bool_t isRecursive); Forward server redirect calls to component test statistics. void printCompactTreeHook(ostream& os, const char* indent = """"); Add extra information on component test statistics when printing; itself as part of a tree structure. void constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); Forward constant te",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAbsTestStatistic.html:39209,test,test,39209,root/html534/RooAbsTestStatistic.html,https://root.cern,https://root.cern/root/html534/RooAbsTestStatistic.html,1,['test'],['test']
Testability,"multiclass_trainConfusionEffB30;; 1417 std::vector<TMatrixD> multiclass_testConfusionEffB01;; 1418 std::vector<TMatrixD> multiclass_testConfusionEffB10;; 1419 std::vector<TMatrixD> multiclass_testConfusionEffB30;; 1420 ; 1421 std::vector<std::vector<Double_t>> biastrain(1); // ""bias"" of the regression on the training data; 1422 std::vector<std::vector<Double_t>> biastest(1); // ""bias"" of the regression on test data; 1423 std::vector<std::vector<Double_t>> devtrain(1); // ""dev"" of the regression on the training data; 1424 std::vector<std::vector<Double_t>> devtest(1); // ""dev"" of the regression on test data; 1425 std::vector<std::vector<Double_t>> rmstrain(1); // ""rms"" of the regression on the training data; 1426 std::vector<std::vector<Double_t>> rmstest(1); // ""rms"" of the regression on test data; 1427 std::vector<std::vector<Double_t>> minftrain(1); // ""minf"" of the regression on the training data; 1428 std::vector<std::vector<Double_t>> minftest(1); // ""minf"" of the regression on test data; 1429 std::vector<std::vector<Double_t>> rhotrain(1); // correlation of the regression on the training data; 1430 std::vector<std::vector<Double_t>> rhotest(1); // correlation of the regression on test data; 1431 ; 1432 // same as above but for 'truncated' quantities (computed for events within 2sigma of RMS); 1433 std::vector<std::vector<Double_t>> biastrainT(1);; 1434 std::vector<std::vector<Double_t>> biastestT(1);; 1435 std::vector<std::vector<Double_t>> devtrainT(1);; 1436 std::vector<std::vector<Double_t>> devtestT(1);; 1437 std::vector<std::vector<Double_t>> rmstrainT(1);; 1438 std::vector<std::vector<Double_t>> rmstestT(1);; 1439 std::vector<std::vector<Double_t>> minftrainT(1);; 1440 std::vector<std::vector<Double_t>> minftestT(1);; 1441 ; 1442 // following vector contains all methods - with the exception of Cuts, which are special; 1443 MVector methodsNoCuts;; 1444 ; 1445 Bool_t doRegression = kFALSE;; 1446 Bool_t doMulticlass = kFALSE;; 1447 ; 1448 // iterate over met",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/tmva_2tmva_2src_2Factory_8cxx_source.html:59018,test,test,59018,doc/master/tmva_2tmva_2src_2Factory_8cxx_source.html,https://root.cern,https://root.cern/doc/master/tmva_2tmva_2src_2Factory_8cxx_source.html,1,['test'],['test']
Testability,"mum and maximum radius. TGeoCone(const char* name, Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2); Default constructor specifying minimum and maximum radius. TGeoCone(Double_t* params); Default constructor specifying minimum and maximum radius; param[0] = dz; param[1] = Rmin1; param[2] = Rmax1; param[3] = Rmin2; param[4] = Rmax2. Double_t Capacity() const; Computes capacity of the shape in [length^3]. Double_t Capacity(Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2); Computes capacity of the shape in [length^3]. ~TGeoCone(); destructor. void ComputeBBox(); compute bounding box of the sphere. void ComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); Compute normal to closest surface from POINT. void ComputeNormalS(Double_t* point, Double_t* dir, Double_t* norm, Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2); Compute normal to closest surface from POINT. Bool_t Contains(Double_t* point) const; test if point is inside this cone. Double_t DistFromInsideS(Double_t* point, Double_t* dir, Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2); Compute distance from inside point to surface of the cone (static); Boundary safe algorithm. Double_t DistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from inside point to surface of the cone; Boundary safe algorithm. Double_t DistFromOutsideS(Double_t* point, Double_t* dir, Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2); Compute distance from outside point to surface of the tube; Boundary safe algorithm.; compute distance to Z planes. Double_t DistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from outside point to surface of the tube; compute safe radius. void DistToCone(Double_t* point, Double_t* dir, Do",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoCone.html:13474,test,test,13474,root/html528/TGeoCone.html,https://root.cern,https://root.cern/root/html528/TGeoCone.html,3,['test'],['test']
Testability,"n (fFormula) ? fFormula->GetExpFormula(option) : TString();; 492 }; 493 virtual const TObject *GetLinearPart(Int_t i) const; 494 {; 495 return (fFormula) ? fFormula->GetLinearPart(i) : nullptr;; 496 }; 497 virtual Double_t GetMaximum(Double_t xmin = 0, Double_t xmax = 0, Double_t epsilon = 1.E-10, Int_t maxiter = 100, Bool_t logx = false) const;; 498 virtual Double_t GetMinimum(Double_t xmin = 0, Double_t xmax = 0, Double_t epsilon = 1.E-10, Int_t maxiter = 100, Bool_t logx = false) const;; 499 virtual Double_t GetMaximumX(Double_t xmin = 0, Double_t xmax = 0, Double_t epsilon = 1.E-10, Int_t maxiter = 100, Bool_t logx = false) const;; 500 virtual Double_t GetMinimumX(Double_t xmin = 0, Double_t xmax = 0, Double_t epsilon = 1.E-10, Int_t maxiter = 100, Bool_t logx = false) const;; 501 virtual Double_t GetMaximumStored() const; 502 {; 503 return fMaximum;; 504 }; 505 virtual Double_t GetMinimumStored() const; 506 {; 507 return fMinimum;; 508 }; 509 virtual Int_t GetNpar() const; 510 {; 511 return fNpar;; 512 }; 513 virtual Int_t GetNdim() const; 514 {; 515 return fNdim;; 516 }; 517 virtual Int_t GetNDF() const;; 518 virtual Int_t GetNpx() const; 519 {; 520 return fNpx;; 521 }; 522 TMethodCall *GetMethodCall() const; 523 {; 524 return fMethodCall.get();; 525 }; 526 virtual Int_t GetNumber() const; 527 {; 528 return (fFormula) ? fFormula->GetNumber() : 0;; 529 }; 530 virtual Int_t GetNumberFreeParameters() const;; 531 virtual Int_t GetNumberFitPoints() const; 532 {; 533 return fNpfits;; 534 }; 535 char *GetObjectInfo(Int_t px, Int_t py) const override;; 536 TObject *GetParent() const; 537 {; 538 return fParent;; 539 }; 540 virtual Double_t GetParameter(Int_t ipar) const; 541 {; 542 return (fFormula) ? fFormula->GetParameter(ipar) : fParams->GetParameter(ipar);; 543 }; 544 virtual Double_t GetParameter(const TString &name) const; 545 {; 546 return (fFormula) ? fFormula->GetParameter(name) : fParams->GetParameter(name);; 547 }; 548 virtual Double_t *GetParameters() const;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TF1_8h_source.html:21622,log,logx,21622,doc/master/TF1_8h_source.html,https://root.cern,https://root.cern/doc/master/TF1_8h_source.html,1,['log'],['logx']
Testability,"n = """"); boolbasic_ios<char,char_traits<char> >::bad() const; virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); voidbasic_ios<char,char_traits<char> >::clear(ios_base::iostate state = goodbit); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; basic_ios<char,char_traits<char> >&basic_ios<char,char_traits<char> >::copyfmt(const basic_ios<char,char_traits<char> >& rhs); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static voidEnableOutput(); static TMVA::MsgLogger&Endmsg(TMVA::MsgLogger& logger); boolbasic_ios<char,char_traits<char> >::eof() const; virtual voidTObject::Error(const char* method, const char* msgfmt) const; ios_base::iostatebasic_ios<char,char_traits<char> >::exceptions() const; voidbasic_ios<char,char_traits<char> >::exceptions(ios_base::iostate excpt); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); boolbasic_ios<char,char_traits<char> >::fail() const; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; basic_ios<char,char_traits<char> >::char_typebasic_ios<char,char_traits<char> >::fill() const; basic_ios<char,char_traits<char> >::char_typebasic_ios<char,char_traits<char> >::fill(basic_ios<char,char_traits<char> >::char_type ch); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMVA__MsgLogger.html:1523,log,logger,1523,root/html528/TMVA__MsgLogger.html,https://root.cern,https://root.cern/root/html528/TMVA__MsgLogger.html,4,['log'],['logger']
Testability,"n Approx ; ; bent.C;  Bent error bars ; ; bent.py;  Bent error bars. ; ; exclusiongraph.C;  Draw three graphs with an exclusion zone. ; ; exclusiongraph2.C;  Draw several graphs with an exclusion zones. ; ; gerrors.C;  Draw a graph with error bars ; ; gerrors2.C;  Draw two graphs with error bars ; ; gmultierrors.C;  Draw a graph with multiple y errors ; ; graph.C;  Draw a simple graph. ; ; graph2derrorsfit.C;  Draw and fit a TGraph2DErrors ; ; graphApply.C;  A macro to demonstrate the functionality of TGraph::Apply() method. ; ; graphpalettecolor.C;  Palette coloring for graphs is activated thanks to the options PFC (Palette Fill Color), PLC (Palette Line Color) and AMC (Palette Marker Color). ; ; graphpolar.C;  Create and draw a polar graph. ; ; graphpolar2.C;  Create and draw a polar graph with PI axis ; ; graphpolar3.C;  Create and draw a polar graph with PI axis using a TF1. ; ; graphreverse.C;  This example test all the various case of reverse graphs combined with logarithmic scale. ; ; graphShade.C;  Show how to shade an area between two graphs ; ; graphstruct.C;  Draw a simple graph structure. ; ; graphtext.C;  Draw a graph with text attached to each point. ; ; gtime.C;  Example of TGraphTime. ; ; gtime2.C;  Example of TGraphTime showing how the class could be used to visualize a set of particles with their time stamp in a MonteCarlo program. ; ; hlGraph1.C; This tutorial demonstrates how to use the highlight mode on graph. ; ; hlGraph2.C; This tutorial demonstrates how to use the highlight mode on graph. ; ; labels1.C;  Setting alphanumeric labels in a 1-d histogram. ; ; labels2.C;  Setting alphanumeric labels. ; ; motorcycle.C;  Macro to test scatterplot smoothers: ksmooth, lowess, supsmu as described in: ; ; multigraph.C;  Create and Draw a TMultiGraph. ; ; multigraphpalettecolor.C;  Palette coloring for multi-graphs is activated thanks to the options PFC (Palette Fill Color),",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/dir_21ec31480a793facd4ea3dd8f2d42294.html:1408,test,test,1408,doc/master/dir_21ec31480a793facd4ea3dd8f2d42294.html,https://root.cern,https://root.cern/doc/master/dir_21ec31480a793facd4ea3dd8f2d42294.html,2,"['log', 'test']","['logarithmic', 'test']"
Testability,"n Members (Methods); public:. TGLPhysicalShape(UInt_t ID, const TGLLogicalShape& logicalShape, const TGLMatrix& transform, Bool_t invertedWind, const Float_t* rgba); TGLPhysicalShape(UInt_t ID, const TGLLogicalShape& logicalShape, const double* transform, Bool_t invertedWind, const Float_t* rgba); virtual~TGLPhysicalShape(); voidAddReference(TGLPShapeRef* ref); const TGLBoundingBox&BoundingBox() const; virtual voidCalculateShapeLOD(TGLRnrCtx& rnrCtx, Float_t& pixSize, Short_t& shapeLOD) const; static TClass*Class(); const Float_t*Color() const; virtual voidDraw(TGLRnrCtx& rnrCtx) const; const TGLLogicalShape*GetLogical() const; TGLPhysicalShape::EManipGetManip() const; const TGLPhysicalShape*GetNextPhysical() const; TGLVector3GetScale() const; UChar_tGetSelected() const; TGLVertex3GetTranslation() const; UInt_tID() const; voidInvokeContextMenu(TContextMenu& menu, UInt_t x, UInt_t y) const; virtual TClass*IsA() const; Bool_tIsInvisible() const; Bool_tIsModified() const; Bool_tIsSelected() const; Bool_tIsTransparent() const; voidModified(); virtual voidQuantizeShapeLOD(Short_t shapeLOD, Short_t combiLOD, Short_t& quantLOD) const; voidRemoveReference(TGLPShapeRef* ref); voidRotate(const TGLVertex3& pivot, const TGLVector3& axis, Double_t angle); voidScale(const TGLVector3& scale); voidSelect(UChar_t select); voidSetColor(const Float_t* rgba); voidSetColorOnFamily(const Float_t* rgba); voidSetDiffuseColor(const Float_t* rgba); voidSetDiffuseColor(const UChar_t* rgba); voidSetDiffuseColor(Color_t ci, UChar_t transparency); voidSetManip(TGLPhysicalShape::EManip manip); voidSetTransform(const TGLMatrix& transform); voidSetTransform(const Double_t* vals); voidSetTranslation(const TGLVertex3& translation); voidSetupGLColors(TGLRnrCtx& rnrCtx, const Float_t* color = 0) const; virtual voidShowMembers(TMemberInspector&); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); voidTranslate(const TGLVector3& vect). private:. TGLPhysicalShape(c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGLPhysicalShape.html:1404,log,logicalShape,1404,root/html534/TGLPhysicalShape.html,https://root.cern,https://root.cern/root/html534/TGLPhysicalShape.html,2,['log'],['logicalShape']
Testability,"n R.Raja 6-Sep-2008. ; Reimplemented from TH1.; Reimplemented in TH2Poly.; Definition at line 1366 of file TH2.cxx. Interpolate() [3/3]. Double_t TH2::Interpolate ; (; Double_t; x, . Double_t; y, . Double_t; z. ); const. overridevirtual . illegal for a TH2 ; Reimplemented from TH1.; Reimplemented in TH2Poly.; Definition at line 1440 of file TH2.cxx. IsA(). TClass * TH2::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TH1.; Reimplemented in TH2C, TH2S, TH2I, TH2L, TH2F, TH2D, TH2Poly, TProfile2D, and TProfile2Poly.; Definition at line 133 of file TH2.h. KolmogorovTest(). Double_t TH2::KolmogorovTest ; (; const TH1 *; h2, . Option_t *; option = """". ); const. overridevirtual . Statistical test of compatibility in shape between THIS histogram and h2, using Kolmogorov test. ; Default: Ignore under- and overflow bins in comparison; option is a character string to specify options; ""U"" include Underflows in test; ""O"" include Overflows; ""N"" include comparison of normalizations; ""D"" Put out a line of ""Debug"" printout; ""M"" Return the Maximum Kolmogorov distance instead of prob. The returned function value is the probability of test (much less than one means NOT compatible); The KS test uses the distance between the pseudo-CDF's obtained from the histogram. Since in 2D the order for generating the pseudo-CDF is arbitrary, two pairs of pseudo-CDF are used, one starting from the x axis the other from the y axis and the maximum distance is the average of the two maximum distances obtained.; Code adapted by Rene Brun from original HBOOK routine HDIFF ; Reimplemented from TH1.; Definition at line 1470 of file TH2.cxx. operator=(). TH2 & TH2::operator= ; (; const TH2 &; ). privatedelete . ProfileX(). TProfile * TH2::ProfileX ; (; const char *; name = ""_pfx"", . Int_t; firstybin = 1, . Int_t; lastybin = -1, . Option_t *; option = """". ); const. Project a 2-D histogram into a profile histogram along X. ; The p",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTH2.html:91749,test,test,91749,doc/master/classTH2.html,https://root.cern,https://root.cern/doc/master/classTH2.html,1,['test'],['test']
Testability,"n Rtypes.h:346; TArrayD.h; TF1.h; pwinID h TVirtualViewer3D TVirtualGLPainter pDefinition TGWin32VirtualGLProxy.cxx:51; optionOption_t Option_t optionDefinition TGWin32VirtualXProxy.cxx:44; valueOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void valueDefinition TGWin32VirtualXProxy.cxx:142; namechar name[80]Definition TGX11.cxx:110; xminfloat xminDefinition THbookFile.cxx:95; yminfloat yminDefinition THbookFile.cxx:95; xmaxfloat xmaxDefinition THbookFile.cxx:95; ymaxfloat ymaxDefinition THbookFile.cxx:95; ROOT::Math::ParamFunctorTemplParam Functor class for Multidimensional functions.Definition ParamFunctor.h:274; TArrayDArray of doubles (64 bits per element).Definition TArrayD.h:27; TF11-Dim function classDefinition TF1.h:233; TF1::GetMinimumvirtual Double_t GetMinimum(Double_t xmin=0, Double_t xmax=0, Double_t epsilon=1.E-10, Int_t maxiter=100, Bool_t logx=false) constReturns the minimum value of the function on the (xmin, xmax) interval.Definition TF1.cxx:1696; TF1::SetRangevirtual void SetRange(Double_t xmin, Double_t xmax)Initialize the upper and lower bounds to draw the function.Definition TF1.cxx:3528; TF1::Integralvirtual Double_t Integral(Double_t a, Double_t b, Double_t epsrel=1.e-12)IntegralOneDim or analytical integral.Definition TF1.cxx:2531; TF1::GetRangevirtual void GetRange(Double_t *xmin, Double_t *xmax) constReturn range of a generic N-D function.Definition TF1.cxx:2281; TF1::fNpxInt_t fNpxNumber of points used for the graphical representation.Definition TF1.h:267; TF1::GetMaximumvirtual Double_t GetMaximum(Double_t xmin=0, Double_t xmax=0, Double_t epsilon=1.E-10, Int_t maxiter=100, Bool_t logx=false) constReturns the maximum value of the function.Definition TF1.cxx:1614; TF2A 2-Dim function with parameters.Definition TF2.h:29; TF2::GetMaximumXYvirtual Double_t GetMaximumXY(Double_t &x, Double_t &y) constCompute the X and Y values correspondin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TF2_8h_source.html:9114,log,logx,9114,doc/master/TF2_8h_source.html,https://root.cern,https://root.cern/doc/master/TF2_8h_source.html,1,['log'],['logx']
Testability,"n TGraphPainter.cxx:4820; TGraphPainter::PaintPolyLineHatchesvoid PaintPolyLineHatches(TGraph *theGraph, Int_t n, const Double_t *x, const Double_t *y)Paint a polyline with hatches on one side showing an exclusion zone.Definition TGraphPainter.cxx:4620; TGraphPainter::DrawPanelHelpervoid DrawPanelHelper(TGraph *theGraph) overrideDisplay a panel with all histogram drawing options.Definition TGraphPainter.cxx:796; TGraphPainter::GetObjectInfoHelperchar * GetObjectInfoHelper(TGraph *theGraph, Int_t px, Int_t py) const overrideDefinition TGraphPainter.cxx:1101; TGraphPainter::ExecuteEventHelpervoid ExecuteEventHelper(TGraph *theGraph, Int_t event, Int_t px, Int_t py) overrideExecute action corresponding to one event.Definition TGraphPainter.cxx:821; TGraphPainter::HighlightPointvirtual void HighlightPoint(TGraph *theGraph, Int_t hpoint, Int_t distance)Check on highlight point.Definition TGraphPainter.cxx:1136; TGraphPainter::ComputeLogsvoid ComputeLogs(Int_t npoints, Int_t opt)Compute the logarithm of variables gxwork and gywork according to the value of Options and put the re...Definition TGraphPainter.cxx:690; TGraphPainter::gxworklstd::vector< Double_t > gxworklDefinition TGraphPainter.h:69; TGraphPainter::DistancetoPrimitiveHelperInt_t DistancetoPrimitiveHelper(TGraph *theGraph, Int_t px, Int_t py) overrideCompute distance from point px,py to a graph.Definition TGraphPainter.cxx:717; TGraphPainter::gxworkstd::vector< Double_t > gxworkDefinition TGraphPainter.h:69; TGraphPainter::gyworkstd::vector< Double_t > gyworkDefinition TGraphPainter.h:69; TGraphPainter::PaintScattervoid PaintScatter(TScatter *theScatter, Option_t *option) overridePaint a scatter plot.Definition TGraphPainter.cxx:4392; TGraphPainter::Smoothvoid Smooth(TGraph *theGraph, Int_t npoints, Double_t *x, Double_t *y, Int_t drawtype)Smooth a curve given by N points.Definition TGraphPainter.cxx:4938; TGraphPainter::gyworklstd::vector< Double_t > gyworklInternal buffers for coordinates. Used for graphs pa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGraphPainter_8cxx_source.html:199886,log,logarithm,199886,doc/master/TGraphPainter_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGraphPainter_8cxx_source.html,2,['log'],['logarithm']
Testability,"n a d which will be replaced by the commend number. The default prompt is ""root [%d] "". The maximum length of the prompt is 55 characters. To set the prompt in an interactive session do: root [0] ((TRint*)gROOT->GetApplication())->SetPrompt(""aap> "") aap> ; Definition at line 595 of file TRint.cxx. Streamer(). void TRint::Streamer ; (; TBuffer &; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from TApplication. StreamerNVirtual(). void TRint::StreamerNVirtual ; (; TBuffer &; ClassDef_StreamerNVirtual_b). inline . Definition at line 67 of file TRint.h. TabCompletionHook(). Int_t TRint::TabCompletionHook ; (; char *; buf, . int *; pLoc, . std::ostream &; out. ). overridevirtual . Forward tab completion request to our TTabCom::Hook(). ; Reimplemented from TApplication.; Definition at line 827 of file TRint.cxx. Terminate(). void TRint::Terminate ; (; int; status). overridevirtual . Terminate the application. ; Reset the terminal to sane mode and call the logoff macro defined via Rint.Logoff environment variable. NoteThe function does not return, unless the class has been told to return from Run(), by a call to SetReturnFromRun(). ; Reimplemented from TApplication.; Definition at line 722 of file TRint.cxx. Member Data Documentation. fBackslashContinue. Bool_t TRint::fBackslashContinue {}. private . Definition at line 41 of file TRint.h. fCaughtSignal. Int_t TRint::fCaughtSignal. private . Definition at line 39 of file TRint.h. fDefaultPrompt. TString TRint::fDefaultPrompt. private . Definition at line 35 of file TRint.h. fInputHandler. TFileHandler* TRint::fInputHandler. private . Definition at line 40 of file TRint.h. fInterrupt. Bool_t TRint::fInterrupt. private . Definition at line 38 of file TRint.h. fNcmd. Int_t TRint::fNcmd. private . Definition at line 34 of file TRint.h. fNonContinuePrompt. TString TRint::fNonContinuePrompt. private . Definition at line 36 of file TRint.h. fPrompt. char TRint::fPrompt[6",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTRint.html:28322,log,logoff,28322,doc/master/classTRint.html,https://root.cern,https://root.cern/doc/master/classTRint.html,1,['log'],['logoff']
Testability,"n accept connections while handling currently open connections ; hserv2bonj.CThis script shows how to make a simple iterative server that can accept connections while handling currently open connections ; LDAPExample.C; parallelMergeClient.CClient program which creates and fills 2 histograms and a TTree ; parallelMergeServer.CThis script shows how to make a simple iterative server that can accept connections while handling currently open connections ; parallelMergeTest.C; pclient.CClient program to test parallel sockets ; pserv.CServer program to test parallel sockets ; spy.CClient program which allows the snooping of objects from a spyserv process ; spyserv.CServer program which allows clients, ""spies"", to connect and snoop objects ; TestAuth.CMacro test authentication methods stand alone ; testTUDPSocket.CAs test echo server use udpserver.c in the same directory ; treeClient.CClient program which creates and fills 2 histograms and a TTree ; TUriTest.CRudimentary TUri test macro ; udpserver.c; physics; PhaseSpace.C Example of use of TGenPhaseSpace ; proof; EmptyInclude.hEmpty file to test TProof::Load in runProof.C and StressProof.cxx in conjunction with ProcFileElements and ProofEventProc ; finalizeProof.CMacro to finalize queries run with the macro tutorials/runProof ; getProof.CAttaches to a PROOF session, possibly at the indicated URL ; ProcFileElements.CClass to hold information about the processed elements of a file ; ProcFileElements.hClass to hold information about the processed elements of a file ; ProofAux.CSelector used for auxiliary actions in the PROOF tutorials ; ProofAux.hSelector used for auxiliary actions in the PROOF tutorials ; ProofEvent.CSelector for generic processing with Event ; ProofEvent.hSelector for generic processing with Event ; ProofEventProc.CSelector to process trees containing Event structures ; ProofEventProc.hSelector to process trees containing Event structures ; ProofFriends.CSelector to process",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v608/files.html:135363,test,test,135363,doc/v608/files.html,https://root.cern,https://root.cern/doc/v608/files.html,5,['test'],['test']
Testability,"n applications cannot easily specify template parameters or pass C++ callables to RDataFrame. See Efficient analysis in Python for possible ways to speed up hot paths in this case.; Just-in-time compilation happens once, right before starting an event loop. To reduce the runtime cost of this step, make sure to book all operations for all RDataFrame computation graphs before the first event loop is triggered: just-in-time compilation will happen once for all code required to be generated up to that point, also across different computation graphs.; Also make sure not to count the just-in-time compilation time (which happens once before the event loop and does not depend on the size of the dataset) as part of the event loop runtime (which scales with the size of the dataset). RDataFrame has an experimental logging feature that simplifies measuring the time spent in just-in-time compilation and in the event loop (as well as providing some more interesting information). See Activating RDataFrame execution logs. Memory usage; There are two reasons why RDataFrame may consume more memory than expected. Firstly, each result is duplicated for each worker thread, which e.g. in case of many (possibly multi-dimensional) histograms with fine binning can result in visible memory consumption during the event loop. The thread-local copies of the results are destroyed when the final result is produced. Reducing the number of threads or using coarser binning will reduce the memory usage.; Secondly, just-in-time compilation of string expressions or non-templated actions (see the previous paragraph) causes Cling, ROOT's C++ interpreter, to allocate some memory for the generated code that is only released at the end of the application. This commonly results in memory usage creep in long-running applications that create many RDataFrames one after the other. Possible mitigations include creating and running each RDataFrame event loop in a sub-process, or booking all operations for all diff",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1RDataFrame.html:50863,log,logs,50863,doc/v632/classROOT_1_1RDataFrame.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1RDataFrame.html,2,['log'],['logs']
Testability,"n array params.; 1455/// If argument params is omitted or equal 0, the internal values; 1456/// of parameters (array fParams) will be used instead.; 1457/// For a 1-D function only x[0] must be given.; 1458/// In case of a multi-dimensional function, the arrays x must be; 1459/// filled with the corresponding number of dimensions.; 1460///; 1461/// WARNING. In case of an interpreted function (fType=2), it is the; 1462/// user's responsibility to initialize the parameters via InitArgs; 1463/// before calling this function.; 1464/// InitArgs should be called at least once to specify the addresses; 1465/// of the arguments x and params.; 1466/// InitArgs should be called every time these addresses change.; 1467 ; 1468Double_t TF1::EvalPar(const Double_t *x, const Double_t *params); 1469{; 1470 //fgCurrent = this;; 1471 ; 1472 if (fType == EFType::kFormula) {; 1473 assert(fFormula);; 1474 ; 1475 if (fNormalized && fNormIntegral != 0); 1476 return fFormula->EvalPar(x, params) / fNormIntegral;; 1477 else; 1478 return fFormula->EvalPar(x, params);; 1479 }; 1480 Double_t result = 0;; 1481 if (fType == EFType::kPtrScalarFreeFcn || fType == EFType::kTemplScalar) {; 1482 if (fFunctor) {; 1483 assert(fParams);; 1484 if (params) result = ((TF1FunctorPointerImpl<Double_t> *)fFunctor.get())->fImpl((Double_t *)x, (Double_t *)params);; 1485 else result = ((TF1FunctorPointerImpl<Double_t> *)fFunctor.get())->fImpl((Double_t *)x, (Double_t *)fParams->GetParameters());; 1486 ; 1487 } else result = GetSave(x);; 1488 ; 1489 if (fNormalized && fNormIntegral != 0); 1490 result = result / fNormIntegral;; 1491 ; 1492 return result;; 1493 }; 1494 if (fType == EFType::kInterpreted) {; 1495 if (fMethodCall) fMethodCall->Execute(result);; 1496 else result = GetSave(x);; 1497 ; 1498 if (fNormalized && fNormIntegral != 0); 1499 result = result / fNormIntegral;; 1500 ; 1501 return result;; 1502 }; 1503 ; 1504#ifdef R__HAS_VECCORE; 1505 if (fType == EFType::kTemplVec) {; 1506 if (fFunctor) {; 1507 if ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TF1_8cxx_source.html:53362,assert,assert,53362,doc/master/TF1_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html,2,['assert'],['assert']
Testability,"n at line 273 of file TGNumberEntry.h. IsEditable(). Bool_t TGNumberEntry::IsEditable ; (; ); const. inlineoverridevirtual . Return kTRUE if frame is being edited. ; Reimplemented from TGCompositeFrame.; Definition at line 267 of file TGNumberEntry.h. IsLogStep(). virtual Bool_t TGNumberEntry::IsLogStep ; (; ); const. inlinevirtual . Definition at line 239 of file TGNumberEntry.h. Modified(). void TGNumberEntry::Modified ; (; ). virtual . Emit Modified() signal. ; This signal is emitted when the number entry value is changed. ; Definition at line 2186 of file TGNumberEntry.cxx. operator=(). TGNumberEntry & TGNumberEntry::operator= ; (; const TGNumberEntry &; ). privatedelete . ProcessMessage(). Bool_t TGNumberEntry::ProcessMessage ; (; Longptr_t; msg, . Longptr_t; parm1, . Longptr_t; parm2. ). overridevirtual . Process the up/down button messages. ; If fButtonToNum is false the following message is sent: kC_COMMAND, kCM_BUTTON, widget id, param param % 100 is the step size param % 10000 / 100 != 0 indicates log step param / 10000 != 0 indicates button down ; Reimplemented from TGCompositeFrame.; Definition at line 2116 of file TGNumberEntry.cxx. SavePrimitive(). void TGNumberEntry::SavePrimitive ; (; std::ostream &; out, . Option_t *; option = """". ). overridevirtual . Save a number entry widget as a C++ statement(s) on output stream out. ; Reimplemented from TGCompositeFrame.; Definition at line 2194 of file TGNumberEntry.cxx. SetButtonToNum(). void TGNumberEntry::SetButtonToNum ; (; Bool_t; state). virtual . Send button messages to the number field (true) or parent widget (false). ; When the message is sent to the parent widget, it is responsible to change the numerical value accordingly. This can be useful to implement cursors which move from data point to data point. For the message being sent see ProcessMessage(). ; Definition at line 2104 of file TGNumberEntry.cxx. SetDate(). virtual void TGNumberEntry::SetDate ; (; Int_t; year, . Int_",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGNumberEntry.html:43341,log,log,43341,doc/master/classTGNumberEntry.html,https://root.cern,https://root.cern/doc/master/classTGNumberEntry.html,1,['log'],['log']
Testability,"n at line 40 of file TObjString.h. GetName(). const char * TObjString::GetName ; (; ); const. inlineoverridevirtual . Returns name of object. ; This default method returns the class name. Classes that give objects a name should override this method. ; Reimplemented from TObject.; Definition at line 38 of file TObjString.h. GetString(). const TString & TObjString::GetString ; (; ); const. inline . Definition at line 46 of file TObjString.h. Hash(). ULong_t TObjString::Hash ; (; ); const. inlineoverridevirtual . Return hash value for this object. ; Note: If this routine is overloaded in a derived class, this derived class should also add ROOT::CallRecursiveRemoveIfNeeded(*this); ROOT::CallRecursiveRemoveIfNeededvoid CallRecursiveRemoveIfNeeded(TObject &obj)call RecursiveRemove for obj if gROOT is valid and obj.TestBit(kMustCleanup) is true.Definition TROOT.h:395; Otherwise, when RecursiveRemove is called (by ~TObject or example) for this type of object, the transversal of THashList and THashTable containers will will have to be done without call Hash (and hence be linear rather than logarithmic complexity). You will also see warnings like Error in <ROOT::Internal::TCheckHashRecursiveRemoveConsistency::CheckRecursiveRemove>: The class SomeName overrides TObject::Hash but does not call TROOT::RecursiveRemove in its destructor.; TObjString::HashULong_t Hash() const overrideReturn hash value for this object.Definition TObjString.h:39; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TROOT::RecursiveRemovevoid RecursiveRemove(TObject *obj) overrideRecursively remove this object from the list of Cleanups.Definition TROOT.cxx:2498. Reimplemented from TObject.; Definition at line 39 of file TObjString.h. IsA(). TClass * TObjString::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented fr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTObjString.html:12762,log,logarithmic,12762,doc/master/classTObjString.html,https://root.cern,https://root.cern/doc/master/classTObjString.html,1,['log'],['logarithmic']
Testability,"n boundaries if this distribution is binned in `obs`.; 3556/// \param[in] obs Observable to retrieve boundaries for.; 3557/// \param[in] xlo Beginning of range.; 3558/// \param[in] xhi End of range.; 3559/// \return The caller owns the returned std::list.; 3560std::list<double>* RooAbsReal::binBoundaries(RooAbsRealLValue& /*obs*/, double /*xlo*/, double /*xhi*/) const {; 3561 return nullptr;; 3562}; 3563 ; 3564 ; 3565////////////////////////////////////////////////////////////////////////////////; 3566/// Interface for returning an optional hint for initial sampling points when constructing a curve projected on observable `obs`.; 3567/// \param[in] obs Observable to retrieve sampling hint for.; 3568/// \param[in] xlo Beginning of range.; 3569/// \param[in] xhi End of range.; 3570/// \return The caller owns the returned std::list.; 3571std::list<double>* RooAbsReal::plotSamplingHint(RooAbsRealLValue& /*obs*/, double /*xlo*/, double /*xhi*/) const {; 3572 return nullptr;; 3573}; 3574 ; 3575////////////////////////////////////////////////////////////////////////////////; 3576/// Print all outstanding logged evaluation error on the given ostream. If maxPerNode; 3577/// is zero, only the number of errors for each source (object with unique name) is listed.; 3578/// If maxPerNode is greater than zero, up to maxPerNode detailed error messages are shown; 3579/// per source of errors. A truncation message is shown if there were more errors logged; 3580/// than shown.; 3581 ; 3582void RooAbsReal::printEvalErrors(std::ostream &os, Int_t maxPerNode); 3583{; 3584 if (evalErrorData().mode == CountErrors) {; 3585 os << evalErrorData().count << "" errors counted"" << std::endl;; 3586 }; 3587 ; 3588 if (maxPerNode < 0); 3589 return;; 3590 ; 3591 for (auto const &item : evalErrorData().errorList) {; 3592 if (maxPerNode == 0) {; 3593 ; 3594 // Only print node name with total number of errors; 3595 os << item.second.first;; 3596 // item.first->printStream(os,kName|kClassName|kArgs,kInline",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RooAbsReal_8cxx_source.html:152918,log,logged,152918,doc/master/RooAbsReal_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html,1,['log'],['logged']
Testability,"n documentation; TASPaletteEditor(TAttImage* attImage, UInt_t w, UInt_t h); Palette editor constructor.; The palette editor aloows the editing of the color palette of the image. ~TASPaletteEditor(); Palette editor destructor. Deletes all frames and their layout hints. void CloseWindow(); Close editor. Bool_t ProcessMessage(Long_t msg, Long_t param1, Long_t param2); Process all editor mouse events. void InsertNewPalette(TImagePalette* newPalette); The newPalette is inserted in the list of palettes (fPaletteList) and; fPalette is set to the newPalette. Protected method,. void Save(); Saves the current palette either into a ROOT file or in an ASCII file.; It is called by the Save - button. Protected method. void Open(); Opens either a ROOT file or an ASCII file and reads a palette.; It is called by the Open - button. Protected method. void UpdateScreen(Bool_t histoUpdate); All widgeds of the screen are updated with the current palette.; Protected method. void LogPalette(); The anchor points are rescaled by a log operation.; It is called by the log - button. Protected method. void ExpPalette(); The anchor points are rescaled by a exp operation.; It is called by the exp - button. Protected method. void LinPalette(); The anchor points are rescaled to be linar.; It is called by the lin - button. Protected method. void InvertPalette(); The palette is inverted.; It is called by the invert - button. Protected method. void NewPalette(Long_t id); A new palette is created, depending on the id.; It is called by the combo box. Protected method. void SetStep(); Create a step palette. This is called by the step - check button.; Protected method. void SetRamp(Long_t ramp); The palette is repeated up to 4 times.; This is called by one of the ramp radio buttons. Protected method. void UpdateRange(); Updates the range of the palette.; This is called after the blue limit lines were moved to define; a new range. TASPaletteEditor(TAttImage* attImage, UInt_t w, UInt_t h).  Author: Reiner R",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TASPaletteEditor.html:24338,log,log,24338,root/html602/TASPaletteEditor.html,https://root.cern,https://root.cern/root/html602/TASPaletteEditor.html,2,['log'],['log']
Testability,"n documentation; TASPaletteEditor(TAttImage* attImage, UInt_t w, UInt_t h); Palette editor constructor.; The palette editor aloows the editing of the color palette of the image. ~TASPaletteEditor(); Palette editor destructor. Deletes all frames and their layout hints. void CloseWindow(); Close editor. Bool_t ProcessMessage(Long_t msg, Long_t param1, Long_t param2); Process all editor mouse events. void InsertNewPalette(TImagePalette* newPalette); The newPalette is inserted in the list of palettes (fPaletteList) and; fPalette is set to the newPalette. Protected method,. void Save(); Saves the current palette either into a ROOT file or in an ASCII file.; It is called by the Save - button. Protected method. void Open(); Opens either a ROOT file or an ASCII file and reads a palette.; It is called by the Open - button. Protected method. void UpdateScreen(Bool_t histoUpdate); All widgeds of the screen are updated with the current palette.; Protected method. void LogPalette(); The anchor points are rescaled by a log operation.; It is called by the log - button. Protected method. void ExpPalette(); The anchor points are rescaled by a exp operation.; It is called by the exp - button. Protected method. void LinPalette(); The anchor points are rescaled to be linar.; It is called by the lin - button. Protected method. void InvertPalette(); The palette is inverted.; It is called by the invert - button. Protected method. void NewPalette(Long_t id); A new palette is created, depending on the id.; It is called by the combo box. Protected method. void SetStep(); Create a step palette. This is called by the step - check button.; Protected method. void SetRamp(Long_t ramp); The palette is repeated up to 4 times.; This is called by one of the ramp radio buttons. Protected method. void UpdateRange(); Updates the range of the palette.; This is called after the blue limit lines were moved to define; a new range.  Author: Reiner Rohlfs 24/03/2002  Copyright (C) 1995-2002, Rene Brun, Fons",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/TASPaletteEditor.html:23317,log,log,23317,root/html526/TASPaletteEditor.html,https://root.cern,https://root.cern/root/html526/TASPaletteEditor.html,5,['log'],['log']
Testability,"n easily have a sequence of almost unique vertices (at a pixel level).; ; //Includes for ACLiC.; #include <cassert>; #include <vector>; ; #include ""TRandom.h""; #include ""TCanvas.h""; #include ""TError.h""; #include ""Rtypes.h""; #include ""TNamed.h""; #include ""TMath.h""; ; class PolyTest1 : public TNamed, public TAttLine, public TAttFill {; public:; PolyTest1(unsigned nVertices);; ; void Paint(const Option_t *notUsed) override;; void Reset(unsigned nVertices);; ; private:; enum {; kNPointsDefault = 10000//minimal number of points.; };; ; std::vector<Double_t> fXs;; std::vector<Double_t> fYs;; };; ; //_____________________________________________________________; PolyTest1::PolyTest1(unsigned nVertices); : TNamed(""polygon_compression_test1"", ""polygon_compression_test1""); {; Reset(nVertices);; }; ; //_____________________________________________________________; void PolyTest1::Reset(unsigned nVertices); {; //Some canvas must already exist by this point.; assert(gPad != nullptr && ""Reset, gPad is null"");; //We need a gRandom to exist.; assert(gRandom != nullptr && ""Reset, gRandom is null"");; ; if (nVertices < kNPointsDefault) {; Warning(""Reset"", ""resetting nVertices parameter to %u"", unsigned(kNPointsDefault));; nVertices = kNPointsDefault;; }; ; fXs.resize(nVertices);; fYs.resize(nVertices);; ; Double_t xMin = 0., xMax = 0., yMin = 0., yMax = 0.;; gPad->GetRange(xMin, yMin, xMax, yMax);; assert(xMax - xMin > 0 && yMax - yMin > 0 && ""Reset, invalid canvas' ranges"");; ; const Double_t xCentre = xMin + 0.5 * (xMax - xMin);; const Double_t yCentre = yMin + 0.5 * (yMax - yMin);; ; const Double_t r = TMath::Min(xMax - xMin, yMax - yMin) * 0.8 / 2;; const Double_t angle = TMath::TwoPi() / (nVertices - 1);; ; for (unsigned i = 0; i < nVertices - 1; ++i) {; const Double_t currR = r + gRandom->Rndm() * r * 0.01;; fXs[i] = xCentre + currR * TMath::Cos(angle * i);; fYs[i] = yCentre + currR * TMath::Sin(angle * i);; }; ; fXs[nVertices - 1] = fXs[0];; fYs[nVertices - 1] = fYs[0];; }; ; /",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/polytest1_8C.html:1854,assert,assert,1854,doc/master/polytest1_8C.html,https://root.cern,https://root.cern/doc/master/polytest1_8C.html,1,['assert'],['assert']
Testability,"n errors assumming that all the bins are uncorrelated.; By default the integral is computed as the sum of bin contents in the range.; if option ""width"" is specified, the integral is the sum of; the bin contents multiplied by the bin width in x and in y. Double_t Interpolate(Double_t x); illegal for a TH2. Double_t Interpolate(Double_t x, Double_t y); Given a point P(x,y), Interpolate approximates the value via bilinear; interpolation based on the four nearest bin centers; see Wikipedia, Bilinear Interpolation; Andy Mastbaum 10/8/2008; vaguely based on R.Raja 6-Sep-2008. Double_t Interpolate(Double_t x, Double_t y, Double_t z); illegal for a TH2. Double_t KolmogorovTest(const TH1* h2, Option_t* option = """") const; Statistical test of compatibility in shape between; THIS histogram and h2, using Kolmogorov test.; Default: Ignore under- and overflow bins in comparison. option is a character string to specify options; ""U"" include Underflows in test; ""O"" include Overflows; ""N"" include comparison of normalizations; ""D"" Put out a line of ""Debug"" printout; ""M"" Return the Maximum Kolmogorov distance instead of prob. The returned function value is the probability of test; (much less than one means NOT compatible). The KS test uses the distance between the pseudo-CDF's obtained; from the histogram. Since in 2D the order for generating the pseudo-CDF is; arbitrary, two pairs of pseudo-CDF are used, one starting from the x axis the; other from the y axis and the maximum distance is the average of the two maximum; distances obtained. Code adapted by Rene Brun from original HBOOK routine HDIFF. Long64_t Merge(TCollection* list); Add all histograms in the collection to this histogram.; This function computes the min/max for the axes,; compute a new number of bins, if necessary,; add bin contents, errors and statistics.; If overflows are present and limits are different the function will fail.; The function returns the total number of entries in the result histogram; if the merge is ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TH2.html:39770,test,test,39770,root/html528/TH2.html,https://root.cern,https://root.cern/root/html528/TH2.html,6,['test'],['test']
Testability,"n function of the upper tail of the gamma distribution (gamma_cdf_c). ; ; doubleROOT::Math::gamma_quantile (double z, double alpha, double theta); Inverse ( \(D^{-1}(z)\)) of the cumulative distribution function of the lower tail of the gamma distribution (gamma_cdf). ; ; doubleROOT::Math::gaussian_quantile_c (double z, double sigma); Inverse ( \(D^{-1}(z)\)) of the cumulative distribution function of the upper tail of the normal (Gaussian) distribution (gaussian_cdf_c). ; ; doubleROOT::Math::gaussian_quantile (double z, double sigma); Inverse ( \(D^{-1}(z)\)) of the cumulative distribution function of the lower tail of the normal (Gaussian) distribution (gaussian_cdf). ; ; doubleROOT::Math::lognormal_quantile_c (double x, double m, double s); Inverse ( \(D^{-1}(z)\)) of the cumulative distribution function of the upper tail of the lognormal distribution (lognormal_cdf_c). ; ; doubleROOT::Math::lognormal_quantile (double x, double m, double s); Inverse ( \(D^{-1}(z)\)) of the cumulative distribution function of the lower tail of the lognormal distribution (lognormal_cdf). ; ; doubleROOT::Math::normal_quantile_c (double z, double sigma); Inverse ( \(D^{-1}(z)\)) of the cumulative distribution function of the upper tail of the normal (Gaussian) distribution (normal_cdf_c). ; ; doubleROOT::Math::normal_quantile (double z, double sigma); Inverse ( \(D^{-1}(z)\)) of the cumulative distribution function of the lower tail of the normal (Gaussian) distribution (normal_cdf). ; ; doubleROOT::Math::uniform_quantile_c (double z, double a, double b); Inverse ( \(D^{-1}(z)\)) of the cumulative distribution function of the upper tail of the uniform (flat) distribution (uniform_cdf_c). ; ; doubleROOT::Math::uniform_quantile (double z, double a, double b); Inverse ( \(D^{-1}(z)\)) of the cumulative distribution function of the lower tail of the uniform (flat) distribution (uniform_cdf). ; ; doubleROOT::Math::landau_quantile (double z, double xi=1); Inve",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__QuantFunc.html:7056,log,lognormal,7056,doc/master/group__QuantFunc.html,https://root.cern,https://root.cern/doc/master/group__QuantFunc.html,1,['log'],['lognormal']
Testability,"n has selected 7525 events out of the 283813 events in the chain of files. (2.65 per cent); Root > chain.Process(""h1analysis.C"",""fillList""). Case D: Process only entries in the entry list; The entry list is read from the file in elist.root generated by step C; Root > chain.Process(""h1analysis.C"",""useList""). Case E: The above steps have been executed via the interpreter.; You can repeat the steps B, C and D using the script compiler by replacing ""h1analysis.C"" by ""h1analysis.C+"" or ""h1analysis.C++"" in a new session (see F). Case F: Create the chain as in A, then execute; Root > chain.Process(""h1analysis.C+"",""useList""); The same analysis can be run on PROOF. For a quick try start a PROOF-Lite session; Root > TProof *p = TProof::Open(""""); pwinID h TVirtualViewer3D TVirtualGLPainter pDefinition TGWin32VirtualGLProxy.cxx:51; TProofThis class controls a Parallel ROOT Facility, PROOF, cluster.Definition TProof.h:316; TProof::Openstatic TProof * Open(const char *url=0, const char *conffile=0, const char *confdir=0, Int_t loglevel=0)Start a PROOF session on a specific cluster.Definition TProof.cxx:11583; create (if not already done) the chain by executing the 'h1chain.C' macro mentioned above, and then tell ROOT to use PROOF to process the chain:; Root > chain.SetProof(); You can then repeat step B above. Step C can also be executed in PROOF. However, step D cannot be executed in PROOF as in the local session (i.e. just passing option 'useList'): to use the entry list you have to. Case G: Load first in the session the list form the file; Root > TFile f(""elist.root""); Root > TEntryList *elist = (TEntryList *) f.Get(""elist""); f#define f(i)Definition RSha256.hxx:104; TEntryListA List of entry numbers in a TTree or TChain.Definition TEntryList.h:26; TFileA ROOT file is an on-disk file, usually with extension .root, that stores objects in a file-system-li...Definition TFile.h:53; set it on the chain:; Root > chain.SetEntryList(elist); call Process as in step B. Of course this work",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/h1analysis_8C.html:4525,log,loglevel,4525,doc/master/h1analysis_8C.html,https://root.cern,https://root.cern/doc/master/h1analysis_8C.html,1,['log'],['loglevel']
Testability,"n is possible, return integration scenario code. RooAddPdf queries each component PDF for its analytical integration capability of the requested; set ('allVars'). It finds the largest common set of variables that can be integrated; by all components. If such a set exists, it reconfirms that each component is capable of; analytically integrating the common set, and combines the components individual integration; codes into a single integration code valid for RooAddPdf. Double_t analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; Return analytical integral defined by given scenario code. Double_t expectedEvents(const RooArgSet* nset) const; Return the number of expected events, which is either the sum of all coefficients; or the sum of the components extended terms, multiplied with the fraction that; is in the current range w.r.t the reference range. void selectNormalization(const RooArgSet* depSet = 0, Bool_t force = kFALSE); Interface function used by test statistics to freeze choice of observables; for interpretation of fraction coefficients. void selectNormalizationRange(const char* rangeName = 0, Bool_t force = kFALSE); Interface function used by test statistics to freeze choice of range; for interpretation of fraction coefficients. RooAbsGenContext* genContext(const RooArgSet& vars, const RooDataSet* prototype = 0, const RooArgSet* auxProto = 0, Bool_t verbose = kFALSE) const; Return specialized context to efficiently generate toy events from RooAddPdfs; return RooAbsPdf::genContext(vars,prototype,auxProto,verbose) ; // WVE DEBUG. std::list<Double_t>* plotSamplingHint(RooAbsRealLValue& obs, Double_t xlo, Double_t xhi) const; Loop over components for plot sampling hints and merge them if there are multiple. std::list<Double_t>* binBoundaries(RooAbsRealLValue& , Double_t , Double_t ) const; Loop over components for plot sampling hints and merge them if there are multiple. Bool_t isBinnedDistribution(const RooArgSet& obs) con",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooAddPdf.html:48540,test,test,48540,root/html532/RooAddPdf.html,https://root.cern,https://root.cern/root/html532/RooAddPdf.html,4,['test'],['test']
Testability,"n is possible, return integration scenario code. RooAddPdf queries each component PDF for its analytical integration capability of the requested; set ('allVars'). It finds the largest common set of variables that can be integrated; by all components. If such a set exists, it reconfirms that each component is capable of; analytically integrating the common set, and combines the components individual integration; codes into a single integration code valid for RooAddPdf. Double_t analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; Return analytical integral defined by given scenario code. Double_t expectedEvents(const RooArgSet* nset) const; Return the number of expected events, which is either the sum of all coefficients; or the sum of the components extended terms, multiplied with the fraction that; is in the current range w.r.t the reference range. void selectNormalization(const RooArgSet* depSet = 0, Bool_t force = kFALSE); Interface function used by test statistics to freeze choice of observables; for interpretation of fraction coefficients. void selectNormalizationRange(const char* rangeName = 0, Bool_t force = kFALSE); Interface function used by test statistics to freeze choice of range; for interpretation of fraction coefficients. RooAbsGenContext* genContext(const RooArgSet& vars, const RooDataSet* prototype = 0, const RooArgSet* auxProto = 0, Bool_t verbose = kFALSE) const; Return specialized context to efficiently generate toy events from RooAddPdfs; return RooAbsPdf::genContext(vars,prototype,auxProto,verbose) ; // WVE DEBUG. std::list<Double_t>* plotSamplingHint(RooAbsRealLValue& obs, Double_t xlo, Double_t xhi) const; Loop over components for plot sampling hints and merge them if there are multiple. void printMetaArgs(ostream& os) const; Customized printing of arguments of a RooAddPdf to more intuitively reflect the contents of the; product operator construction. TObject* clone(const char* newname) const; { return n",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooAddPdf.html:46937,test,test,46937,root/html528/RooAddPdf.html,https://root.cern,https://root.cern/root/html528/RooAddPdf.html,2,['test'],['test']
Testability,"n is set and type is consistent; 807 fitOpt.fCoordErrors &= (type == BinData::kCoordError) || (type == BinData::kAsymError) ;; 808 fitOpt.fAsymErrors &= (type == BinData::kAsymError);; 809 ; 810 ; 811 // if data are filled already check if there are consistent - otherwise do nothing; 812 if (dv.Size() > 0 && dv.NDim() == 1 ) {; 813 // check if size is correct otherwise flag an errors; 814 if ( dv.GetErrorType() != type ) {; 815 Error(""FillData"",""Inconsistent TGraph with previous data set- skip all graph data"");; 816 return;; 817 }; 818 }; 819 ; 820 DoFillData(dv, gr, type, func);; 821 ; 822}; 823 ; 824void FillData ( BinData & dv, const TMultiGraph * mg, TF1 * func ) {; 825 // fill the data vector from a TMultiGraph. Pass also the TF1 function which is; 826 // needed in case to exclude points rejected by the function; 827 assert(mg != nullptr);; 828 ; 829 TList * grList = mg->GetListOfGraphs();; 830 assert(grList != nullptr);; 831 ; 832#ifdef DEBUG; 833// grList->Print();; 834 TIter itr(grList, kIterBackward);; 835 TObject *obj;; 836 std::cout << ""multi-graph list of graps: "" << std::endl;; 837 while ((obj = itr())) {; 838 std::cout << obj->IsA()->GetName() << std::endl;; 839 }; 840 ; 841#endif; 842 ; 843 // get fit option; 844 DataOptions & fitOpt = dv.Opt();; 845 ; 846 // loop on the graphs to get the data type (use maximum); 847 TIter next(grList);; 848 ; 849 BinData::ErrorType type = BinData::kNoError;; 850 TGraph *gr = nullptr;; 851 while ((gr = (TGraph*) next())) {; 852 BinData::ErrorType t = GetDataType(gr,fitOpt);; 853 if (t > type ) type = t;; 854 }; 855 // adjust option according to type; 856 fitOpt.fErrors1 = (type == BinData::kNoError);; 857 // use coordinate or asym errors in case option is set and type is consistent; 858 fitOpt.fCoordErrors &= (type == BinData::kCoordError) || (type == BinData::kAsymError);; 859 fitOpt.fAsymErrors &= (type == BinData::kAsymError);; 860 ; 861 ; 862#ifdef DEBUG; 863 std::cout << ""Fitting MultiGraph of type "" << type << s",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/HFitInterface_8cxx_source.html:27042,assert,assert,27042,doc/master/HFitInterface_8cxx_source.html,https://root.cern,https://root.cern/doc/master/HFitInterface_8cxx_source.html,2,['assert'],['assert']
Testability,"n last bin on the axis; 466/// i.e. fNbins if no range defined; 467/// NOTE: in some cases a zero is returned (see TAxis::SetRange); 468 ; 469Int_t TAxis::GetLast() const; 470{; 471 if (!TestBit(kAxisRange)) return fNbins;; 472 return fLast;; 473}; 474 ; 475////////////////////////////////////////////////////////////////////////////////; 476/// Return center of bin; 477 ; 478Double_t TAxis::GetBinCenter(Int_t bin) const; 479{; 480 Double_t binwidth;; 481 if (!fXbins.fN || bin<1 || bin>fNbins) {; 482 binwidth = (fXmax - fXmin) / Double_t(fNbins);; 483 return fXmin + (bin-1) * binwidth + 0.5*binwidth;; 484 } else {; 485 binwidth = fXbins.fArray[bin] - fXbins.fArray[bin-1];; 486 return fXbins.fArray[bin-1] + 0.5*binwidth;; 487 }; 488}; 489 ; 490////////////////////////////////////////////////////////////////////////////////; 491/// Return center of bin in log; 492/// With a log-equidistant binning for a bin with low and up edges, the mean is :; 493/// 0.5*(ln low + ln up) i.e. sqrt(low*up) in logx (e.g. sqrt(10^0*10^2) = 10).; 494/// Imagine a bin with low=1 and up=100 :; 495/// - the center in lin is (100-1)/2=50.5; 496/// - the center in log would be sqrt(1*100)=10 (!=log(50.5)); 497///; 498/// NB: if the low edge of the bin is negative, the function returns the bin center; 499/// as computed by TAxis::GetBinCenter; 500 ; 501Double_t TAxis::GetBinCenterLog(Int_t bin) const; 502{; 503 Double_t low,up;; 504 if (!fXbins.fN || bin<1 || bin>fNbins) {; 505 Double_t binwidth = (fXmax - fXmin) / Double_t(fNbins);; 506 low = fXmin + (bin-1) * binwidth;; 507 up = low+binwidth;; 508 } else {; 509 low = fXbins.fArray[bin-1];; 510 up = fXbins.fArray[bin];; 511 }; 512 if (low <=0 ) return GetBinCenter(bin);; 513 return TMath::Sqrt(low*up);; 514}; 515////////////////////////////////////////////////////////////////////////////////; 516/// Return low edge of bin; 517 ; 518Double_t TAxis::GetBinLowEdge(Int_t bin) const; 519{; 520 if (fXbins.fN && bin > 0 && bin <=fNbins) return fXbins.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TAxis_8cxx_source.html:16063,log,logx,16063,doc/master/TAxis_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TAxis_8cxx_source.html,1,['log'],['logx']
Testability,"n loss: 0.436; [8] val loss: 0.758; [9, 4] train loss: 0.381; [9, 8] train loss: 0.435; [9, 12] train loss: 0.456; [9] val loss: 1.218; [10, 4] train loss: 0.438; [10, 8] train loss: 0.436; [10, 12] train loss: 0.444; [10] val loss: 0.632; Finished Training on 10 Epochs!; running Torch code defining the model....; The PyTorch CNN model is created and saved as PyTorchModelCNN.pt; : Loaded pytorch train function: ; : Loaded pytorch optimizer: ; : Loaded pytorch loss function: ; : Loaded pytorch predict function: ; : Loaded model from file: PyTorchTrainedModelCNN.pt; PyTorch : [dataset] : Evaluation of PyTorch on testing sample (400 events); : Elapsed time for evaluation of 400 events: 0.12 sec ; Factory : [1mEvaluate all methods[0m; Factory : Evaluate classifier: BDT; : ; BDT : [dataset] : Loop over test events and fill histograms with classifier response...; : ; : Dataset[dataset] : variable plots are not produces ! The number of variables is 256 , it is larger than 200; Factory : Evaluate classifier: TMVA_DNN_CPU; : ; TMVA_DNN_CPU : [dataset] : Loop over test events and fill histograms with classifier response...; : ; : Evaluate deep neural network on CPU using batches with size = 1000; : ; : Dataset[dataset] : variable plots are not produces ! The number of variables is 256 , it is larger than 200; Factory : Evaluate classifier: TMVA_CNN_CPU; : ; TMVA_CNN_CPU : [dataset] : Loop over test events and fill histograms with classifier response...; : ; : Evaluate deep neural network on CPU using batches with size = 1000; : ; : Dataset[dataset] : variable plots are not produces ! The number of variables is 256 , it is larger than 200; Factory : Evaluate classifier: PyKeras; : ; PyKeras : [dataset] : Loop over test events and fill histograms with classifier response...; : ; : Dataset[dataset] : variable plots are not produces ! The number of variables is 256 , it is larger than 200; Factory : Evaluate classifier: PyTorch; : ; PyTorch : [dataset] : Loop over test events a",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVA__CNN__Classification_8C.html:41851,test,test,41851,doc/master/TMVA__CNN__Classification_8C.html,https://root.cern,https://root.cern/doc/master/TMVA__CNN__Classification_8C.html,1,['test'],['test']
Testability,"n modified - retain across scene rebuilds; TGLPhysicalShape*fNextPhysical! pointer to next replica; UChar_tfSelected! selected state; TGLMatrixfTransform! transform (placement) of physical instance. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGLPhysicalShape(UInt_t ID, const TGLLogicalShape& logicalShape, const TGLMatrix& transform, Bool_t invertedWind, const Float_t* rgba); Construct a physical shape using arguments:; ID - unique drawable id.; logicalShape - bound logical shape; transform - transform for placement of logical drawing; invertedWind - use inverted face polygon winding?; rgba - basic four component (RGBA) diffuse color. TGLPhysicalShape(UInt_t ID, const TGLLogicalShape& logicalShape, const double* transform, Bool_t invertedWind, const Float_t* rgba); Construct a physical shape using arguments:; id - unique drawable id.; logicalShape - bound logical shape; transform - 16 Double_t component transform for placement of logical drawing; invertedWind - use inverted face polygon winding?; rgba - basic four component (RGBA) diffuse color. ~TGLPhysicalShape(); Destroy the physical shape. void AddReference(TGLPShapeRef* ref); Add reference ref. void RemoveReference(TGLPShapeRef* ref); Remove reference ref. void Modified(); Call this after modifying the physical so that the information; can be propagated to the object referencing it. void UpdateBoundingBox(); Update our internal bounding box (in global frame). void InitColor(const Float_t* rgba); Initialise the colors, using basic RGBA diffuse material color supplied. void SetColor(const Float_t* rgba); Set full color attributes - see OpenGL material documentation; for full description.; 0->3 diffuse, 4->7 ambient, 8->11 specular, 12->15 emission, 16 shininess. void SetColorOnFamily(const Float_t* rgba); Set full color attributes to all physicals sharing the same; logical with this object. void SetDiffuseColor(const Float_t rgba[4]); Set color from ROOT color index ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGLPhysicalShape.html:4993,log,logicalShape,4993,root/html528/TGLPhysicalShape.html,https://root.cern,https://root.cern/root/html528/TGLPhysicalShape.html,12,['log'],"['logical', 'logicalShape']"
Testability,"n object and replaces it with a more meaningful name. In addition, TGeoPNEntry objects are faster to search by name and they may optionally store an additional user matrix.; // Creating a symlink object.; TGeoPNEntry *TGeoManager::SetAlignableEntry(const char *unique_n,; const char*path); // Retrieving an existing alignable object.; TGeoPNEntry *TGeoManager::GetAlignableEntry(const char *name); // Retrieving an existing alignable object at a given index.; TGeoPNEntry *GetAlignableEntry(Int_t index); TGeoManager::GetAlignableEntryTGeoPNEntry * GetAlignableEntry(const char *name) constRetrieves an existing alignable object.Definition TGeoManager.cxx:3370; TGeoManager::SetAlignableEntryTGeoPNEntry * SetAlignableEntry(const char *unique_name, const char *path, Int_t uid=-1)Creates an alignable object with unique name corresponding to a path and adds it to the list of align...Definition TGeoManager.cxx:3342; Physical nodes store internally the full list of logical nodes corresponding to the elements from the string path, as well as the global transformation matrix for each of them. The top node corresponds to the level 0 in the stored array, while the last node will correspond to level n. For each level, the node, volume and global matrix can be retrieved using corresponding getters:; TGeoHMatrix *GetMatrix(Int_t level=-1) const; TGeoNode *GetNode(Int_t level=-1) const; TGeoShape *GetShape(Int_t level=-1) const; TGeoVolume *GetVolume(Int_t level=-1) const; By default the object at level n is retrieved (the align-able object).; Once created, a physical node can be misaligned, meaning that its positioning matrix or even the shape.:; void Align(TGeoMatrix* newmat=0, TGeoShape* newshape=0,; Bool_t check=kFALSE); The convention used is that newmat represents the new local matrix of the last node in the branch with respect to its mother volume. The Align() method will actually duplicate the corresponding branch within the logical hierarchy, creating new volumes and nodes. This",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__Geometry.html:117620,log,logical,117620,doc/master/group__Geometry.html,https://root.cern,https://root.cern/doc/master/group__Geometry.html,1,['log'],['logical']
Testability,"n of F-distribution (probability function, integral of density, is computed in FDistI). ; Parameters N and M stand for degrees of freedom of chi-squares mentioned above parameter F is the actual variable x of the density function p(x) and the point at which the density function is calculated. About F distribution:; F-distribution arises in testing whether two random samples have the same variance. It is the ratio of two chi-square distributions, with N and M degrees of freedom respectively, where each chi-square is first divided by it's number of degrees of freedom.; AuthorAnna Kreshuk ; Definition at line 2277 of file TMath.cxx. FDistI(). Double_t TMath::FDistI ; (; Double_t; F, . Double_t; N, . Double_t; M. ). Calculates the cumulative distribution function of F-distribution (see ROOT::Math::fdistribution_cdf). ; This function occurs in the statistical test of whether two observed samples have the same variance. For this test a certain statistic F, the ratio of observed dispersion of the first sample to that of the second sample, is calculated. N and M stand for numbers of degrees of freedom in the samples 1-FDistI() is the significance level at which the hypothesis ""1 has smaller variance than 2"" can be rejected. A small numerical value of 1 - FDistI() implies a very significant rejection, in turn implying high confidence in the hypothesis ""1 has variance greater than 2"".; AuthorAnna Kreshuk ; Definition at line 2297 of file TMath.cxx. Finite() [1/2]. Int_t TMath::Finite ; (; Double_t; x). inline . Check if it is finite with a mask in order to be consistent in presence of fast math. ; Inspired from the CMSSW FWCore/Utilities package ; Definition at line 770 of file TMath.h. Finite() [2/2]. Int_t TMath::Finite ; (; Float_t; x). inline . Check if it is finite with a mask in order to be consistent in presence of fast math. ; Inspired from the CMSSW FWCore/Utilities package ; Definition at line 800 of file TMath.h. Floor(). Double_t TMath::Floor ; (; Dou",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/namespaceTMath.html:41164,test,test,41164,doc/master/namespaceTMath.html,https://root.cern,https://root.cern/doc/master/namespaceTMath.html,1,['test'],['test']
Testability,"n of viewer architecture. Int_t ValidateObjectBuffer(const TBuffer3D& buffer, Bool_t includeRaw) const; Validate if the passed 'buffer' contains all sections we require to add object.; Returns Int_t combination of TBuffer::ESection flags still required - or; TBuffer3D::kNone if buffer is valid.; If 'includeRaw' is kTRUE check for kRaw/kRawSizes - skip otherwise.; See base/src/TVirtualViewer3D.cxx for description of viewer architecture. TGLLogicalShape* CreateNewLogical(const TBuffer3D& buffer) const; Create and return a new TGLLogicalShape from the supplied buffer. CreateNewPhysical(UInt_t physicalID, const TBuffer3D& buffer, const TGLLogicalShape& logical) const; Create and return a new TGLPhysicalShape with id 'ID', using; 'buffer' placement information (translation etc), and bound to; suppled 'logical'. RootCsg::TBaseMesh* BuildComposite(); Build and return composite shape mesh. TGLLogicalShape* AttemptDirectRenderer(TObject* id); Try to construct an appropriate logical-shape sub-class based; on id'class, following convention that SomeClassGL is a suitable; renderer for class SomeClass. TGLScenePad(const TGLScenePad& ). TGLScenePad& operator=(const TGLScenePad& ). virtual ~TGLScenePad(); {}. TVirtualPad* GetPad() const; void SetPad(TVirtualPad* p) { fPad = p; /* also need to drop contents */ }. { return fPad; }. Bool_t GetSmartRefresh() const; { return fSmartRefresh; }. void SetSmartRefresh(Bool_t smart_ref); { fSmartRefresh = smart_ref; }. Bool_t CanLoopOnPrimitives() const; TVirtualViewer3D interface. { return kTRUE; }. Int_t DistancetoPrimitive(Int_t , Int_t ); For now handled by viewer. { return 9999; }. void ExecuteEvent(Int_t , Int_t , Int_t ); {}. Bool_t PreferLocalFrame() const; { return kTRUE; }. Bool_t BuildingScene() const; { return CurrentLock() == kModifyLock; }.  Author: Matevz Tadel, Jun 2007  Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *;  Last changed: root/gl:$Id: TGLScenePad.h 36884 2010-11-23 17:52:08Z matevz $  Last generated:",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGLScenePad.html:16142,log,logical-shape,16142,root/html528/TGLScenePad.html,https://root.cern,https://root.cern/root/html528/TGLScenePad.html,1,['log'],['logical-shape']
Testability,"n one of the data member; 984 // was declared using a typedef _and_ the current class definition; 985 // uses a different typedef, we are unable to recalculate the; 986 // checksum as it was, because the information is missing from; 987 // the StreamerInfo, and for the same reason CompareContent can; 988 // not know whether this is okay or not ...; 989 //; 990 // Since this is such an unlikely scenario, let's complain; 991 // about it anyway (The class layout *may* have changed, we; 992 // don't know).; 993 ; 994 // if (this has only base classes) {; 995 // match = kTRUE;; 996 // }; 997 }; 998#endif; 999 } else {; 1000 // The on-file TStreamerInfo's checksum differs from the checksum of a TStreamerInfo on another file.; 1001 ; 1002 match = kFALSE;; 1003 oldIsNonVersioned = (info->fOnFileClassVersion==1 && info->fClassVersion != 1) || isStdPair;; 1004 ; 1005 // In the case where the read-in TStreamerInfo does not; 1006 // match in the 'current' in memory TStreamerInfo for; 1007 // a non foreign class (we can not get here if this is; 1008 // a foreign class so we do not need to test it),; 1009 // we need to add this one more test since the CINT behaviour; 1010 // with enums changed over time, so verify the checksum ignoring; 1011 // members of type enum. We also used to not count the //[xyz] comment; 1012 // in the checksum, so test for that too.; 1013 if (fCheckSum == info->GetCheckSum(TClass::kCurrentCheckSum); 1014 || info->MatchLegacyCheckSum(fCheckSum); 1015 || GetCheckSum(TClass::kCurrentCheckSum) == info->fCheckSum; 1016 || MatchLegacyCheckSum(info->GetCheckSum()); 1017 || GetCheckSum(TClass::kCurrentCheckSum) == info->GetCheckSum(TClass::kCurrentCheckSum)); 1018 {; 1019 match = kTRUE;; 1020 }; 1021 if (fOldVersion <= 2) {; 1022 // Names of STL base classes was modified in vers==3. Allocators removed; 1023 // (We could be more specific (see test for the same case below); 1024 match = kTRUE;; 1025 }; 1026 if (!match && CompareContent(0,info,kFALSE,kFALSE,file)) ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html:37517,test,test,37517,doc/master/TStreamerInfo_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html,2,['test'],['test']
Testability,"n one process and view it from another process; The following two scripts illustrate how to do this. The script treew.C is executed by process1, treer.C by process2; script treew.C: void treew() {; TFile f(""test.root"",""recreate"");; TNtuple *ntuple = new TNtuple(""ntuple"",""Demo"",""px:py:pz:random:i"");; Float_t px, py, pz;; for ( Int_t i=0; i<10000000; i++) {; gRandom->Rannor(px,py);; pz = px*px + py*py;; Float_t random = gRandom->Rndm(1);; ntuple->Fill(px,py,pz,random,i);; if (i%1000 == 1) ntuple->AutoSave(""SaveSelf"");; }; }; TNtupleA simple TTree restricted to a list of float variables only.Definition TNtuple.h:28; TNtuple::FillInt_t Fill() overrideFill a Ntuple with current values in fArgs.Definition TNtuple.cxx:169; TRandom::RndmDouble_t Rndm() overrideMachine independent random number generator.Definition TRandom.cxx:559; TTree::AutoSavevirtual Long64_t AutoSave(Option_t *option="""")AutoSave tree header every fAutoSave bytes.Definition TTree.cxx:1500; int; script treer.C: void treer() {; TFile f(""test.root"");; TTree *ntuple = (TTree*)f.Get(""ntuple"");; TCanvas c1;; Int_t first = 0;; while(1) {; if (first == 0) ntuple->Draw(""px>>hpx"", """","""",10000000,first);; else ntuple->Draw(""px>>+hpx"","""","""",10000000,first);; first = (Int_t)ntuple->GetEntries();; c1.Update();; gSystem->Sleep(1000); //sleep 1 second; ntuple->Refresh();; }; }; gSystemR__EXTERN TSystem * gSystemDefinition TSystem.h:555; TCanvasThe Canvas class.Definition TCanvas.h:23; TSystem::Sleepvirtual void Sleep(UInt_t milliSec)Sleep milliSec milli seconds.Definition TSystem.cxx:437; TTree::Drawvoid Draw(Option_t *opt) overrideDefault Draw method for all objects.Definition TTree.h:431; TTree::GetEntriesvirtual Long64_t GetEntries() constDefinition TTree.h:463; TTree::Refreshvirtual void Refresh()Refresh contents of this tree and its branches from the current status on disk.Definition TTree.cxx:7916; c1return c1Definition legend1.C:41. Definition at line 1500 of file TTree.cxx. Branch() [1/13]. Int_t TTree::Branch ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTTree.html:77387,test,test,77387,doc/v632/classTTree.html,https://root.cern,https://root.cern/doc/v632/classTTree.html,1,['test'],['test']
Testability,"n one process and view it from another process; The following two scripts illustrate how to do this. The script treew.C is executed by process1, treer.C by process2; script treew.C: void treew() {; TFile f(""test.root"",""recreate"");; TNtuple *ntuple = new TNtuple(""ntuple"",""Demo"",""px:py:pz:random:i"");; Float_t px, py, pz;; for ( Int_t i=0; i<10000000; i++) {; gRandom->Rannor(px,py);; pz = px*px + py*py;; Float_t random = gRandom->Rndm(1);; ntuple->Fill(px,py,pz,random,i);; if (i%1000 == 1) ntuple->AutoSave(""SaveSelf"");; }; }; TNtupleA simple TTree restricted to a list of float variables only.Definition TNtuple.h:28; TNtuple::FillInt_t Fill() overrideFill a Ntuple with current values in fArgs.Definition TNtuple.cxx:169; TRandom::RndmDouble_t Rndm() overrideMachine independent random number generator.Definition TRandom.cxx:559; TTree::AutoSavevirtual Long64_t AutoSave(Option_t *option="""")AutoSave tree header every fAutoSave bytes.Definition TTree.cxx:1500; int; script treer.C: void treer() {; TFile f(""test.root"");; TTree *ntuple = (TTree*)f.Get(""ntuple"");; TCanvas c1;; Int_t first = 0;; while(1) {; if (first == 0) ntuple->Draw(""px>>hpx"", """","""",10000000,first);; else ntuple->Draw(""px>>+hpx"","""","""",10000000,first);; first = (Int_t)ntuple->GetEntries();; c1.Update();; gSystem->Sleep(1000); //sleep 1 second; ntuple->Refresh();; }; }; gSystemR__EXTERN TSystem * gSystemDefinition TSystem.h:561; TCanvasThe Canvas class.Definition TCanvas.h:23; TSystem::Sleepvirtual void Sleep(UInt_t milliSec)Sleep milliSec milli seconds.Definition TSystem.cxx:437; TTree::Drawvoid Draw(Option_t *opt) overrideDefault Draw method for all objects.Definition TTree.h:431; TTree::GetEntriesvirtual Long64_t GetEntries() constDefinition TTree.h:463; TTree::Refreshvirtual void Refresh()Refresh contents of this tree and its branches from the current status on disk.Definition TTree.cxx:7916; c1return c1Definition legend1.C:41. Definition at line 1500 of file TTree.cxx. Branch() [1/13]. Int_t TTree::Branch ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTTree.html:77560,test,test,77560,doc/master/classTTree.html,https://root.cern,https://root.cern/doc/master/classTTree.html,1,['test'],['test']
Testability,"n only the Y axis see Rebin3D. ; ; virtual TH3 *RebinZ (Int_t ngroup=2, const char *newname=""""); Rebin only the Z axis see Rebin3D. ; ; voidSetBinContent (Int_t bin, Double_t content) override; Set bin content. ; ; voidSetBinContent (Int_t bin, Int_t, Double_t content) override; ; voidSetBinContent (Int_t binx, Int_t biny, Int_t binz, Double_t content) override; ; virtual voidSetShowProjection (const char *option=""xy"", Int_t nbins=1); When the mouse is moved in a pad containing a 3-d view of this histogram a second canvas shows a projection type given as option. ; ; voidStreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b); ; Public Member Functions inherited from TH1; ~TH1 () override; Histogram default destructor. ; ; virtual Double_tAndersonDarlingTest (const TH1 *h2, Double_t &advalue) const; Same function as above but returning also the test statistic value. ; ; virtual Double_tAndersonDarlingTest (const TH1 *h2, Option_t *option="""") const; Statistical test of compatibility in shape between this histogram and h2, using the Anderson-Darling 2 sample test. ; ; voidBrowse (TBrowser *b) override; Browse the Histogram object. ; ; virtual Bool_tCanExtendAllAxes () const; Returns true if all axes are extendable. ; ; virtual Double_tChi2Test (const TH1 *h2, Option_t *option=""UU"", Double_t *res=nullptr) const; \( \chi^{2} \) test for comparing weighted and unweighted histograms. ; ; virtual Double_tChi2TestX (const TH1 *h2, Double_t &chi2, Int_t &ndf, Int_t &igood, Option_t *option=""UU"", Double_t *res=nullptr) const; The computation routine of the Chisquare test. ; ; virtual Double_tChisquare (TF1 *f1, Option_t *option="""") const; Compute and return the chisquare of this histogram with respect to a function The chisquare is computed by weighting each histogram point by the bin error By default the full range of the histogram is used. ; ; virtual voidClearUnderflowAndOverflow (); Remove all the content from the underflow and ove",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProfile3D.html:15911,test,test,15911,doc/master/classTProfile3D.html,https://root.cern,https://root.cern/doc/master/classTProfile3D.html,2,['test'],['test']
Testability,"n performance; : ; : Evaluate deep neural network on CPU using batches with size = 800; : ; TMVA_DNN : [dataset] : Evaluation of TMVA_DNN on testing sample (800 events); : Elapsed time for evaluation of 800 events: 0.0212 sec ; Factory : Test method: PyKeras_LSTM for Classification performance; : ; : Setting up tf.keras; : Using TensorFlow version 2; : Use Keras version from TensorFlow : tf.keras; : Applying GPU option: gpu_options.allow_growth=True; : Disabled TF eager execution when evaluating model ; : Loading Keras Model ; : Loaded model from file: trained_model_LSTM.h5; PyKeras_LSTM : [dataset] : Evaluation of PyKeras_LSTM on testing sample (800 events); : Elapsed time for evaluation of 800 events: 0.202 sec ; Factory : Test method: BDTG for Classification performance; : ; BDTG : [dataset] : Evaluation of BDTG on testing sample (800 events); : Elapsed time for evaluation of 800 events: 0.00597 sec ; Factory : [1mEvaluate all methods[0m; Factory : Evaluate classifier: TMVA_LSTM; : ; TMVA_LSTM : [dataset] : Loop over test events and fill histograms with classifier response...; : ; : Evaluate deep neural network on CPU using batches with size = 1000; : ; : Dataset[dataset] : variable plots are not produces ! The number of variables is 300 , it is larger than 200; Factory : Evaluate classifier: TMVA_DNN; : ; TMVA_DNN : [dataset] : Loop over test events and fill histograms with classifier response...; : ; : Evaluate deep neural network on CPU using batches with size = 1000; : ; : Dataset[dataset] : variable plots are not produces ! The number of variables is 300 , it is larger than 200; Factory : Evaluate classifier: PyKeras_LSTM; : ; PyKeras_LSTM : [dataset] : Loop over test events and fill histograms with classifier response...; : ; : Dataset[dataset] : variable plots are not produces ! The number of variables is 300 , it is larger than 200; Factory : Evaluate classifier: BDTG; : ; BDTG : [dataset] : Loop over test events and fill histograms with classifier respo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVA__RNN__Classification_8py.html:46378,test,test,46378,doc/master/TMVA__RNN__Classification_8py.html,https://root.cern,https://root.cern/doc/master/TMVA__RNN__Classification_8py.html,1,['test'],['test']
Testability,"n performance; : ; : Evaluate deep neural network on CPU using batches with size = 800; : ; TMVA_DNN : [dataset] : Evaluation of TMVA_DNN on testing sample (800 events); : Elapsed time for evaluation of 800 events: 0.0218 sec ; Factory : Test method: PyKeras_LSTM for Classification performance; : ; : Setting up tf.keras; : Using TensorFlow version 2; : Use Keras version from TensorFlow : tf.keras; : Applying GPU option: gpu_options.allow_growth=True; : Disabled TF eager execution when evaluating model ; : Loading Keras Model ; : Loaded model from file: trained_model_LSTM.h5; PyKeras_LSTM : [dataset] : Evaluation of PyKeras_LSTM on testing sample (800 events); : Elapsed time for evaluation of 800 events: 0.249 sec ; Factory : Test method: BDTG for Classification performance; : ; BDTG : [dataset] : Evaluation of BDTG on testing sample (800 events); : Elapsed time for evaluation of 800 events: 0.00679 sec ; Factory : [1mEvaluate all methods[0m; Factory : Evaluate classifier: TMVA_LSTM; : ; TMVA_LSTM : [dataset] : Loop over test events and fill histograms with classifier response...; : ; : Evaluate deep neural network on CPU using batches with size = 1000; : ; : Dataset[dataset] : variable plots are not produces ! The number of variables is 300 , it is larger than 200; Factory : Evaluate classifier: TMVA_DNN; : ; TMVA_DNN : [dataset] : Loop over test events and fill histograms with classifier response...; : ; : Evaluate deep neural network on CPU using batches with size = 1000; : ; : Dataset[dataset] : variable plots are not produces ! The number of variables is 300 , it is larger than 200; Factory : Evaluate classifier: PyKeras_LSTM; : ; PyKeras_LSTM : [dataset] : Loop over test events and fill histograms with classifier response...; : ; : Dataset[dataset] : variable plots are not produces ! The number of variables is 300 , it is larger than 200; Factory : Evaluate classifier: BDTG; : ; BDTG : [dataset] : Loop over test events and fill histograms with classifier respo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVA__RNN__Classification_8C.html:53985,test,test,53985,doc/master/TMVA__RNN__Classification_8C.html,https://root.cern,https://root.cern/doc/master/TMVA__RNN__Classification_8C.html,1,['test'],['test']
Testability,n representing a Barlow-Beeston minimized profile likelihood of external (likelihood) function; RooStats::HistFactory::Sample ; RooStats::HistFactory::ShapeFactor ; RooStats::HistFactory::ShapeSys ; RooStats::HistFactory::StatError ; RooStats::HistFactory::StatErrorConfig ; RooStats::HybridCalculator ; RooStats::HybridCalculatorOriginal Hypothesis test calculator using a Bayesian-frequentist hybrid method; RooStats::HybridPlot Provides the plots for an HybridResult; RooStats::HybridResult Class containing the results of the HybridCalculator; RooStats::HypoTestCalculator Interface for tools doing hypothesis tests; RooStats::HypoTestCalculatorGeneric ; RooStats::HypoTestInverter HypoTestInverter class; RooStats::HypoTestInverterOriginal HypoTestInverterOriginal class; RooStats::HypoTestInverterPlot HypoTestInverterPlot class; RooStats::HypoTestInverterResult HypoTestInverterResult class ; RooStats::HypoTestPlot ; RooStats::HypoTestResult Base class to represent results of a hypothesis test; RooStats::IntervalCalculator Interface for tools setting limits (producing confidence intervals); RooStats::LikelihoodInterval Concrete implementation of a ConfInterval based on a likelihood ratio; RooStats::LikelihoodIntervalPlot Class containing the results of the IntervalCalculator; RooStats::MCMCCalculator Markov Chain Monte Carlo calculator for Bayesian credible intervals; RooStats::MCMCInterval Concrete implementation of a ConfInterval based on MCMC calculation; RooStats::MCMCIntervalPlot Class containing the results of the MCMCCalculator; RooStats::MarkovChain ; RooStats::MaxLikelihoodEstimateTestStat ; RooStats::MetropolisHastings Markov Chain Monte Carlo calculator for Bayesian credible intervals; RooStats::MinNLLTestStat implements the minimum NLL as a test statistic to be used with several tools; RooStats::ModelConfig A class that holds configuration information for a model using a workspace as a store; RooStats::NeymanConstruction Interface for tools setting limits (prod,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/ClassIndex.html:47799,test,test,47799,root/html534/ClassIndex.html,https://root.cern,https://root.cern/root/html534/ClassIndex.html,1,['test'],['test']
Testability,"n representing moment of p.d.f (normalized w.r.t given observables) of given order. If central is; true, the central moment is given <(x-<x>)^2>. If intNormObs is true, the moment of the function integrated over; all normalization observables is returned. Double_t findRoot(RooRealVar& x, Double_t xmin, Double_t xmax, Double_t yval). Return value of x (in range xmin,xmax) at which function equals yval.; (Calculation is performed with Brent root finding algorithm). RooGenFunction* iGenFunction(RooRealVar& x, const RooArgSet& nset). RooMultiGenFunction* iGenFunction(const RooArgSet& observables, const RooArgSet& nset). RooFitResult* chi2FitTo(RooDataHist& data, RooCmdArg arg1, RooCmdArg arg2, 				 RooCmdArg arg3, RooCmdArg arg4, RooCmdArg arg5, 				 RooCmdArg arg6, RooCmdArg arg7, RooCmdArg arg8); Perform a chi^2 fit to given histogram By default the fit is executed through the MINUIT; commands MIGRAD, HESSE in succession. The following named arguments are supported. Options to control construction of -log(L). Range(const char* name) -- Fit only data inside range with given name; Range(Double_t lo, Double_t hi) -- Fit only data inside given range. A range named ""fit"" is created on the fly on all observables.; Multiple comma separated range names can be specified.; NumCPU(int num) -- Parallelize NLL calculation on num CPUs; Optimize(Bool_t flag) -- Activate constant term optimization (on by default). Options to control flow of fit procedure. InitialHesse(Bool_t flag) -- Flag controls if HESSE before MIGRAD as well, off by default; Hesse(Bool_t flag) -- Flag controls if HESSE is run after MIGRAD, on by default; Minos(Bool_t flag) -- Flag controls if MINOS is run after HESSE, on by default; Minos(const RooArgSet& set) -- Only run MINOS on given subset of arguments; Save(Bool_t flag) -- Flac controls if RooFitResult object is produced and returned, off by default; Strategy(Int_t flag) -- Set Minuit strategy (0 through 2, default is 1); FitOptions(const char* optStr) -- Ste",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAbsReal.html:70292,log,log,70292,root/html526/RooAbsReal.html,https://root.cern,https://root.cern/root/html526/RooAbsReal.html,1,['log'],['log']
Testability,"n squared error (regression) or cross entropy (binary classification).]; : WeightInitialization: ""XAVIERUNIFORM"" [Weight initialization strategy]; : RandomSeed: ""1234"" [Random seed used for weight initialization and batch shuffling]; : ValidationSize: ""0.2"" [Part of the training data to use for validation. Specify as 0.2 or 20% to use a fifth of the data set as validation set. Specify as 100 to use exactly 100 events. (Default: 20%)]; : Architecture: ""CPU"" [Which architecture to perform the training on.]; : TrainingStrategy: ""LearningRate=1e-3,Momentum=0.0,Repetitions=1,ConvergenceSteps=5,BatchSize=100,TestRepetitions=1,WeightDecay=1e-2,Regularization=None,MaxEpochs=10Optimizer=ADAM,DropConfig=0.0+0.+0.+0."" [Defines the training strategies.]; : - Default:; : VerbosityLevel: ""Default"" [Verbosity level]; : CreateMVAPdfs: ""False"" [Create PDFs for classifier outputs (signal and background)]; : IgnoreNegWeightsInTraining: ""False"" [Events with negative weights are ignored in the training (but are included for testing and performance evaluation)]; : BatchLayout: ""0|0|0"" [The Layout of the batch]; : Will now use the CPU architecture with BLAS and IMT support !; Factory : Booking method: [1mTMVA_DNN[0m; : ; : Parsing option string: ; : ... ""!H:V:ErrorStrategy=CROSSENTROPY:VarTransform=None:WeightInitialization=XAVIER:RandomSeed=0:InputLayout=1|1|300:Layout=DENSE|64|TANH,DENSE|TANH|64,DENSE|TANH|64,LINEAR:TrainingStrategy=LearningRate=1e-3,Momentum=0.0,Repetitions=1,ConvergenceSteps=10,BatchSize=256,TestRepetitions=1,WeightDecay=1e-4,Regularization=None,MaxEpochs=20DropConfig=0.0+0.+0.+0.,Optimizer=ADAM:CPU""; : The following options are set:; : - By User:; : <none>; : - Default:; : Boost_num: ""0"" [Number of times the classifier will be boosted]; : Parsing option string: ; : ... ""!H:V:ErrorStrategy=CROSSENTROPY:VarTransform=None:WeightInitialization=XAVIER:RandomSeed=0:InputLayout=1|1|300:Layout=DENSE|64|TANH,DENSE|TANH|64,DENSE|TANH|64,LINEAR:TrainingStrategy=LearningRate=1",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVA__RNN__Classification_8py.html:3500,test,testing,3500,doc/master/TMVA__RNN__Classification_8py.html,https://root.cern,https://root.cern/doc/master/TMVA__RNN__Classification_8py.html,1,['test'],['testing']
Testability,"n the %Title of the Postscript files.Definition TStyle.cxx:1383; TStyle::fHistFillStyleStyle_t fHistFillStyleHistogram fill style.Definition TStyle.h:79; TStyle::SetHistMinimumZerovoid SetHistMinimumZero(Bool_t zero=kTRUE)If the argument zero=kTRUE the minimum value for the Y axis of 1-d histograms is set to 0.Definition TStyle.cxx:1288; TStyle::GetPadGridXBool_t GetPadGridX() constDefinition TStyle.h:215; TStyle::GetStatHFloat_t GetStatH() constDefinition TStyle.h:267; TStyle::GetShowEventStatusInt_t GetShowEventStatus() constDefinition TStyle.h:252; TStyle::SetPadLeftMarginvoid SetPadLeftMargin(Float_t margin=0.1)Definition TStyle.h:360; TStyle::fEndErrorSizeFloat_t fEndErrorSizeSize of lines at the end of error bars.Definition TStyle.h:55; TStyle::SetStatHvoid SetStatH(Float_t h=0.1)Definition TStyle.h:400; TStyle::SetPadGridYvoid SetPadGridY(Bool_t gridy)Definition TStyle.h:363; TStyle::GetTitleYSizeFloat_t GetTitleYSize() constDefinition TStyle.h:279; TStyle::SetOptLogyvoid SetOptLogy(Int_t logy=1)Definition TStyle.h:330; TStyle::SetJoinLinePSvoid SetJoinLinePS(Int_t joinline=0)Set the line join method used for PostScript, PDF and SVG output. See TPostScript::SetLineJoin for de...Definition TStyle.h:306; TStyle::fIsReadingBool_t fIsReading! Set to FALSE when userclass::UseCurrentStyle is called by the style managerDefinition TStyle.h:139; TStyle::GetGridWidthWidth_t GetGridWidth() constDefinition TStyle.h:224; TStyle::GetOptFileInt_t GetOptFile() constDefinition TStyle.h:243; TStyle::fFrameBorderSizeWidth_t fFrameBorderSizePad frame border size.Definition TStyle.h:75; TStyle::GetFuncColorColor_t GetFuncColor() constDefinition TStyle.h:219; TStyle::SetTitleXOffsetvoid SetTitleXOffset(Float_t offset=1)Definition TStyle.h:409; TStyle::SetLegendBorderSizevoid SetLegendBorderSize(Width_t size=4)Definition TStyle.h:350; TStyle::GetAttDateTAttText * GetAttDate()Definition TStyle.h:168; TStyle::fTitleTextColorColor_t fTitleTextColorTitle text color.Definition TStyle.h:",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TStyle_8h_source.html:50623,log,logy,50623,doc/master/TStyle_8h_source.html,https://root.cern,https://root.cern/doc/master/TStyle_8h_source.html,1,['log'],['logy']
Testability,"n the Forum; The Users' Forum has a section which describes how to submit contributions. It is the easiest way to make your code known to the community, even if it will not be automatically integrated in ROOT. Of course the most successful contributions will become part of the repository!; 2. Sending Patches; You can send us a patch or a pull request with Github, provided that you follow these two simple rules:. Make sure you follow the ROOT coding conventions in your code; Make sure you provide a set of tests for your feature/bug fix. Often it is useful to contact us first to discuss the code you want to develop or the bug you want to fix.; Picking up an Idea; We maintain a set of ""ideas"" for talented scientists and developers to pick up. An ""idea"" is a sketch of a development project, a functionality a missing feature we would like to see in our tool, in your ROOT! You can inspect the ideas in the following list. Ideas. ; 30-01-2019 ; Transform GNU-makefile tests to CMake; ROOT's test suite has several crucial tests that still try on GNU-Makefile. We need to integrate them with CMake. ; 30-01-2019 ; Better argument parsing; Use a C++ command line argument library for defining and parsing ROOT's options. ; 30-01-2019 ; More tests, more benchmarks!; ROOT relies on testing, including performance testing - and we need to improve both. ; 05-01-2016 ; Wanted: A tool to 'warn' user of inefficient (for I/O) construct in data model; A tool to 'warn' user of inefficient (for I/O) construct in data model. ; 02-09-2015 ; Wanted: Storage of HEP data via key/value storage solutions; Interface the ROOT I/O to key/value stores. Completed ideas. ; 28-03-2015 ; Commandline tools for ROOT files inspection, modification and automated plotting; Create a unix-like set of Python command line tools to explore, modify and display the content of ROOT files. . Sitemap. DownloadDownload ROOT; All Releases. DocumentationReference Manual; User's Guides; HowTo; Courses; Building ROOT; Tutorials",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/collaborate-with-us.html:3381,test,tests,3381,d/collaborate-with-us.html,https://root.cern,https://root.cern/d/collaborate-with-us.html,3,['test'],"['test', 'tests']"
Testability,"n the MCMCInterval. Finds a 95% confidence interval. MCMCInterval* GetInterval() const; Main interface to get a RooStats::ConfInterval. MCMCCalculator(); default constructor. virtual ~MCMCCalculator(); {}. Double_t Size() const; Get the size of the test (eg. rate of Type I error). {return fSize;}. Double_t ConfidenceLevel() const; Get the Confidence level for the test. {return 1.-fSize;}. void SetData(RooAbsData& data); Set the DataSet if not already there. { fData = &data; }. void SetPdf(RooAbsPdf& pdf); Set the Pdf if not already there. { fPdf = &pdf; }. void SetPriorPdf(RooAbsPdf& pdf); Set the Prior Pdf if not already there. { fPriorPdf = &pdf; }. void SetParameters(const RooArgSet& set); specify the parameters of interest in the interval. { fPOI.removeAll(); fPOI.add(set); }. void SetNuisanceParameters(const RooArgSet& set); specify the nuisance parameters (eg. the rest of the parameters). {fNuisParams.removeAll(); fNuisParams.add(set);}. void SetTestSize(Double_t size); set the size of the test (rate of Type I error) ( Eg. 0.05 for a 95% Confidence Interval). {fSize = size;}. void SetConfidenceLevel(Double_t cl); set the confidence level for the interval (eg. 0.95 for a 95% Confidence Interval). {fSize = 1.-cl;}. void SetProposalFunction(RooStats::ProposalFunction& proposalFunction); set the proposal function for suggesting new points for the MCMC. { fPropFunc = &proposalFunction; }. void SetNumIters(Int_t numIters); set the number of iterations to run the metropolis algorithm. { fNumIters = numIters; }. void SetNumBurnInSteps(Int_t numBurnInSteps); set the number of steps in the chain to discard as burn-in,; starting from the first. { fNumBurnInSteps = numBurnInSteps; }. void SetNumBins(Int_t numBins); set the number of bins to create for each axis when constructing the interval. { fNumBins = numBins; }. void SetAxes(RooArgList& axes); set which variables to put on each axis. { fAxes = &axes; }. void SetUseKeys(Bool_t useKeys); set whether to use kernel estima",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooStats__MCMCCalculator.html:11365,test,test,11365,root/html526/RooStats__MCMCCalculator.html,https://root.cern,https://root.cern/root/html526/RooStats__MCMCCalculator.html,1,['test'],['test']
Testability,"n the nodes. Int_t Rm(const char* what, const char* how = 0, const char* where = 0); Run 'rm' on the nodes. The user is prompted before removal, unless 'how'; contains ""--force"" or a combination of single letter options including 'f',; e.g. ""-fv"". void Tail(const char* what, const char* how = 0, const char* where = 0); Run 'tail' on the nodes. Int_t Md5sum(const char* what, TString& sum, const char* where = 0); Run 'md5sum' on one of the nodes. Int_t Stat(const char* what, FileStat_t& st, const char* where = 0); Run 'stat' on one of the nodes. TObjString * Exec(Int_t action, const char* what, const char* how, const char* where); Execute 'action' (see EAdminExecType in 'XProofProtocol.h') at 'where'; (default master), with options 'how', on 'what'. The option specified by; 'how' are typically unix option for the relate commands. In addition to; the unix authorizations, the limitations are:. action = kRm limited to the sandbox (but basic dirs cannot be; removed) and on files owned by the user in the; allowed directories; action = kTail option '-f' is not supported and will be ignored. Int_t GetFile(const char* remote, const char* local, const char* opt = 0); Get file 'remote' into 'local' from the master.; If opt contains ""force"", the file, if it exists remotely, is copied in all cases,; otherwise a check is done on the MD5sum.; If opt contains ""silent"" standard notificatons are not printed (errors and; warnings and prompts still are).; Return 0 on success, -1 on error. Int_t PutFile(const char* local, const char* remote, const char* opt = 0); Put file 'local'to 'remote' to the master; If opt is ""force"", the file, if it exists remotely, is copied in all cases,; otherwise a check is done on the MD5sum.; Return 0 on success, -1 on error. void CpProgress(const char* pfx, Long64_t bytes, Long64_t size, TStopwatch* watch, Bool_t cr = kFALSE); Print file copy progress. Int_t Cp(const char* src, const char* dst = 0, const char* opts = 0); Copy files in/out of the sandbox. Eit",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TXProofMgr.html:14790,sandbox,sandbox,14790,root/html528/TXProofMgr.html,https://root.cern,https://root.cern/root/html528/TXProofMgr.html,6,['sandbox'],['sandbox']
Testability,"n tree headed by this RooAbsArg object. ; ; voidgraphVizTree (std::ostream &os, const char *delimiter=""\n"", bool useTitle=false, bool useLatex=false); Write the GraphViz representation of the expression tree headed by this RooAbsArg object to the given ostream. ; ; boolhasClients () const; ; boolhasDataToken () const; ; virtual boolhasRange (const char *) const; ; virtual boolinRange (const char *) const; ; virtual boolisCategory () const; ; boolisConstant () const; Check if the ""Constant"" attribute is set. ; ; virtual boolisDerived () const; Does value or shape of this arg depend on any other arg? ; ; virtual boolisReducerNode () const; ; boolIsSortable () const override; ; boollocalNoDirtyInhibit () const; ; const TNamed *namePtr () const; De-duplicated pointer to this object's name. ; ; Int_tnumProxies () const; Return the number of registered proxies. ; ; boolobservableOverlaps (const RooAbsData *dset, const RooAbsArg &testArg) const; Test if any of the dependents of the arg tree (as determined by getObservables) overlaps with those of the testArg. ; ; boolobservableOverlaps (const RooArgSet *depList, const RooAbsArg &testArg) const; Test if any of the dependents of the arg tree (as determined by getObservables) overlaps with those of the testArg. ; ; RooAbsArg &operator= (const RooAbsArg &other)=delete; ; booloverlaps (const RooAbsArg &testArg, bool valueOnly=false) const; Test if any of the nodes of tree are shared with that of the given tree. ; ; const RooArgSet *ownedComponents () const; ; voidPrint (Option_t *options=nullptr) const override; Print the object to the defaultPrintStream(). ; ; voidprintAddress (std::ostream &os) const override; Print address of this RooAbsArg. ; ; voidprintArgs (std::ostream &os) const override; Print object arguments, ie its proxies. ; ; voidprintClassName (std::ostream &os) const override; Print object class name. ; ; voidprintCompactTree (const char *indent="""", const",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooHistFunc.html:26806,test,testArg,26806,doc/master/classRooHistFunc.html,https://root.cern,https://root.cern/doc/master/classRooHistFunc.html,4,['test'],['testArg']
Testability,"n value) ; See TF1::Integral() for parameter definitions; AuthorGene Van Buren gene@.nosp@m.bnl..nosp@m.gov ; Definition at line 3739 of file TF1.cxx. Class(). static TClass * TF1::Class ; (; ). static . ReturnsTClass describing this class . Class_Name(). static const char * TF1::Class_Name ; (; ). static . ReturnsName of this class . Class_Version(). static constexpr Version_t TF1::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 755 of file TF1.h. Clone(). TObject * TF1::Clone ; (; const char *; newname = nullptr); const. overridevirtual . Make a complete copy of the underlying object. ; If 'newname' is set, the copy's name will be set to that name. ; Reimplemented from TObject.; Definition at line 1064 of file TF1.cxx. ComputeCdfTable(). Bool_t TF1::ComputeCdfTable ; (; Option_t *; option). protected . Compute the cumulative function at fNpx points between fXmin and fXmax. ; Option can be used to force a log scale (option = ""log""), linear (option = ""lin"") or automatic if empty. ; Definition at line 2081 of file TF1.cxx. Copy(). void TF1::Copy ; (; TObject &; obj); const. overridevirtual . Copy this F1 to a new F1. ; Note that the cached integral with its related arrays are not copied (they are also set as transient data members) ; Reimplemented from TObject.; Reimplemented in TF12, TF2, and TF3.; Definition at line 1005 of file TF1.cxx. CreateHistogram(). virtual TH1 * TF1::CreateHistogram ; (; ). inlinevirtual . Reimplemented in TF2, and TF3.; Definition at line 477 of file TF1.h. DeclFileName(). static const char * TF1::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 755 of file TF1.h. DefaultAddToGlobalList(). Bool_t TF1::DefaultAddToGlobalList ; (; Bool_t; on = kTRUE). static . Static method to add/avoid to add automatically functions to the global list (gROOT->GetListOfFunctions() ) After having called this static method, all ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTF1.html:60302,log,log,60302,doc/master/classTF1.html,https://root.cern,https://root.cern/doc/master/classTF1.html,2,['log'],['log']
Testability,"n width of bin); -2D : bc,e,xc,xw,yc,yw; -3D : bc,e,xc,xw,yc,yw,zc,zw. void FitLikelihood(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Likelihood method*-*-*-*-*-*; Basically, it forms the likelihood by determining the Poisson; probability that given a number of entries in a particular bin,; the fit would predict it's value. This is then done for each bin,; and the sum of the logs is taken as the likelihood.; Default method (function evaluated at center of bin); for each point the cache contains the following info; -1D : bc,e,xc (bin content, error, x of center of bin); -2D : bc,e,xc,yc; -3D : bc,e,xc,yc,zc. void FitLikelihoodI(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Likelihood method*-*-*-*-*-*; Basically, it forms the likelihood by determining the Poisson; probability that given a number of entries in a particular bin,; the fit would predict it's value. This is then done for each bin,; and the sum of the logs is taken as the likelihood.; The ""I""ntegral method is used; for each point the cache contains the following info; -1D : bc,e,xc,xw (bin content, error, x of center of bin, x bin width of bin); -2D : bc,e,xc,xw,yc,yw; -3D : bc,e,xc,xw,yc,yw,zc,zw. TFumili(Int_t maxpar = 25); TF1 *fTFNF1; //Pointer to theoretical function; void (*fFCN) (Int_t &, Double_t *, Double_t &f, Double_t *, Int_t);; //wrapper function to calculate functional value, gradients and Z-matrix; Double_t (*fTFN)(Double_t *, Double_t *, Double_t*); // Wrapper function for TFN. Double_t* GetPL0() const; { return fPL0;}. Double_t* GetZ() const; { return fZ;}. void SetParNumber(Int_t ParNum); { fNpar = ParNum;}.  Last changed: root/fumili:$Id: TFumili.h 20882 2007-11-19 11:31:26Z rdm $  Last generated: 2010-09-23 20:05; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TFumili.html:24300,log,logs,24300,root/html528/TFumili.html,https://root.cern,https://root.cern/root/html528/TFumili.html,1,['log'],['logs']
Testability,"n width of bin); -2D : bc,e,xc,xw,yc,yw; -3D : bc,e,xc,xw,yc,yw,zc,zw. void FitLikelihood(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Likelihood method*-*-*-*-*-*; Basically, it forms the likelihood by determining the Poisson; probability that given a number of entries in a particular bin,; the fit would predict it's value. This is then done for each bin,; and the sum of the logs is taken as the likelihood.; Default method (function evaluated at center of bin); for each point the cache contains the following info; -1D : bc,e,xc (bin content, error, x of center of bin); -2D : bc,e,xc,yc; -3D : bc,e,xc,yc,zc. void FitLikelihoodI(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Likelihood method*-*-*-*-*-*; Basically, it forms the likelihood by determining the Poisson; probability that given a number of entries in a particular bin,; the fit would predict it's value. This is then done for each bin,; and the sum of the logs is taken as the likelihood.; The ""I""ntegral method is used; for each point the cache contains the following info; -1D : bc,e,xc,xw (bin content, error, x of center of bin, x bin width of bin); -2D : bc,e,xc,xw,yc,yw; -3D : bc,e,xc,xw,yc,yw,zc,zw. TFumili(Int_t maxpar = 25); TF1 *fTFNF1; //Pointer to theoretical function; void (*fFCN) (Int_t &, Double_t *, Double_t &f, Double_t *, Int_t);; //wrapper function to calculate functional value, gradients and Z-matrix; Double_t (*fTFN)(Double_t *, Double_t *, Double_t*); // Wrapper function for TFN. Double_t* GetPL0() const; { return fPL0;}. Double_t* GetZ() const; { return fZ;}. void SetParNumber(Int_t ParNum); { fNpar = ParNum;}.  Last changed: root/fumili:$Id: TFumili.h 20882 2007-11-19 11:31:26Z rdm $  Last generated: 2011-07-04 15:28; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TFumili.html:24369,log,logs,24369,root/html530/TFumili.html,https://root.cern,https://root.cern/root/html530/TFumili.html,1,['log'],['logs']
Testability,"n x. Double_t IntegralAndError(Int_t binx1, Int_t binx2, Double_t& err, Option_t* option = """") const; Return integral of bin contents in range [binx1,binx2] and its error; By default the integral is computed as the sum of bin contents in the range.; if option ""width"" is specified, the integral is the sum of; the bin contents multiplied by the bin width in x.; the error is computed using error propagation from the bin errors assumming that; all the bins are uncorrelated. Double_t DoIntegral(Int_t ix1, Int_t ix2, Int_t iy1, Int_t iy2, Int_t iz1, Int_t iz2, Double_t& err, Option_t* opt, Bool_t doerr = kFALSE) const; internal function compute integral and optionally the error between the limits; specified by the bin number values working for all histograms (1D, 2D and 3D). Double_t AndersonDarlingTest(const TH1* h2, Option_t* option = """") const; Statistical test of compatibility in shape between; this histogram and h2, using the Anderson-Darling 2 sample test.; The AD 2 sample test formula are derived from the paper; F.W Scholz, M.A. Stephens ""k-Sample Anderson-Darling Test"".; The test is implemented in root in the ROOT::Math::GoFTest class; It is the same formula ( (6) in the paper), and also shown in this preprint; http://arxiv.org/pdf/0804.0380v1.pdf; Binned data are considered as un-binned data; with identical observation happening in the bin center. option is a character string to specify options; ""D"" Put out a line of ""Debug"" printout; ""T"" Return the normalized A-D test statistic. Note1: Underflow and overflow are not considered in the test; Note2: The test works only for un-weighted histogram (i.e. representing counts); Note3: The histograms are not required to have the same X axis; Note4: The test works only for 1-dimensional histograms. Double_t AndersonDarlingTest(const TH1* h2, Double_t& advalue) const; Same funciton as above but returning also the test statistic value. Double_t KolmogorovTest(const TH1* h2, Option_t* option = """") const; Statistical test of co",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TH1.html:113913,test,test,113913,root/html534/TH1.html,https://root.cern,https://root.cern/root/html534/TH1.html,3,['test'],['test']
Testability,"n! Use with care !); 98 static void InhibitOutput();; 99 static void EnableOutput();; 100 ; 101 private:; 102 ; 103 // private utility routines; 104 void Send();; 105 void InitMaps();; 106 void WriteMsg( EMsgType type, const std::string& line ) const;; 107 ; 108 const TObject* fObjSource; ///< the source TObject (used for name); 109 std::string fStrSource; ///< alternative string source; 110 static const std::string fgPrefix; ///< the prefix of the source name; 111 static const std::string fgSuffix; ///< suffix following source name; 112 EMsgType fActiveType; ///< active type; 113 static const UInt_t fgMaxSourceSize; ///< maximum length of source name; 114 static std::atomic<Bool_t> fgOutputSupressed; ///< disable the output globally (used by generic booster); 115 static std::atomic<Bool_t> fgInhibitOutput; ///< flag to suppress all output; 116 ; 117 static std::atomic<const std::map<EMsgType, std::string>*> fgTypeMap; ///< matches output types with strings; 118 static std::atomic<const std::map<EMsgType, std::string>*> fgColorMap; ///< matches output types with terminal colors; 119 EMsgType fMinType; ///< minimum type for output; 120 ; 121 ClassDef(MsgLogger,0) // Ostringstream derivative to redirect and format logging output; 122 }; // class MsgLogger; 123 ; 124 inline MsgLogger& MsgLogger::operator<< ( MsgLogger& (*_f)( MsgLogger& ) ); 125 {; 126 return (_f)(*this);; 127 }; 128 ; 129 inline MsgLogger& MsgLogger::operator<< ( std::ostream& (*_f)( std::ostream& ) ); 130 {; 131 (_f)(*this);; 132 return *this;; 133 }; 134 ; 135 inline MsgLogger& MsgLogger::operator<< ( std::ios& ( *_f )( std::ios& ) ); 136 {; 137 (_f)(*this);; 138 return *this;; 139 }; 140 ; 141 inline MsgLogger& MsgLogger::operator<< ( EMsgType type ); 142 {; 143 fActiveType = type;; 144 return *this;; 145 }; 146 ; 147 // Shortcut; 148 inline MsgLogger& Endl(MsgLogger& ml) { return MsgLogger::Endmsg(ml); }; 149 ; 150}; 151 ; 152#endif // TMVA_MsgLogger; UInt_tunsigned int UInt_tDefinition RtypesCore.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/MsgLogger_8h_source.html:4631,log,logging,4631,doc/master/MsgLogger_8h_source.html,https://root.cern,https://root.cern/doc/master/MsgLogger_8h_source.html,1,['log'],['logging']
Testability,"n( const UserFunc & f, double xmin, double xlow, double xup). Set, or reset, minimizer to use the function f and the initial search interval [xlow, xup], with a guess for the location of the minimum xmin.; The condition : \f$ f(xlow) > f(xmin) < f(xup)\f$ must be satisfied. int Iterate(). Perform a minimizer iteration and; if an unexepcted problem occurr then an error code will be returned. double XMinimum() const. Return current estimate of the position of the minimum. double XLower() const. Return current lower bound of the minimization interval. double XUpper() const. Return current upper bound of the minimization interval. double FValMinimum() const. Return function value at current estimate of the minimum. double FValLower() const. Return function value at current lower bound of the minimization interval. double FValUpper() const. Return function value at current upper bound of the minimization interval. int Minimize(int maxIter, double absTol, double relTol). Find minimum position iterating until convergence specified by the absolute and relative tolerance or; the maximum number of iteration is reached; \@param maxIter maximum number of iteration; \@param absTol desired absolute error in the minimum position; \@param absTol desired relative error in the minimum position. int Iterations() const. Return number of iteration used to find minimum. const char * Name() const. Return name of minimization algorithm. int TestInterval(double xlow, double xup, double epsAbs, double epsRel). Test convergence of the interval.; The test returns success if; \f[; |x_{min}-x_{truemin}| < epsAbs + epsRel *x_{truemin}; \f].  Author: L. Moneta, A. Zsenei 08/2005  Copyright (c) 2004 moneta, CERN/PH-SFT *;  Last changed: root/mathmore:$Id: GSLMinimizer1D.h 24477 2008-06-23 12:58:47Z moneta $  Last generated: 2009-12-07 13:43; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Math__GSLMinimizer1D.html:3929,test,test,3929,root/html526/ROOT__Math__GSLMinimizer1D.html,https://root.cern,https://root.cern/root/html526/ROOT__Math__GSLMinimizer1D.html,1,['test'],['test']
Testability,"n(); STL const_iterator interface. . const_iterator end(); STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j). read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j). read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](int j); { return (*fMat)(fRow,j); }. const T & operator[](int j); { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const double& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const double& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const double& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const double& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLIB (written in C++ from CLHEP authors); In case of symmetric matrices Bunch-Kaufman diagonal pivoting method is used; (The implementation is the one written by the CLHEP authors). SMatrix<T,D1,D2,R> Inverse(int& ifail) const. Invert a square Matrix and returns a new matr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Math__SMatrix_double_2_2_-p1MatRepStd_double_2_2___.html:7204,assert,assert,7204,root/html526/ROOT__Math__SMatrix_double_2_2_-p1MatRepStd_double_2_2___.html,https://root.cern,https://root.cern/root/html526/ROOT__Math__SMatrix_double_2_2_-p1MatRepStd_double_2_2___.html,15,['assert'],['assert']
Testability,"n();; 2963}; 2964 ; 2965 ; 2966////////////////////////////////////////////////////////////////////////////////; 2967/// loop on the TStreamerElement list; 2968/// regroup members with same type; 2969/// Store predigested information into local arrays. This saves a huge amount; 2970/// of time compared to an explicit iteration on all elements.; 2971 ; 2972void TStreamerInfo::Compile(); 2973{; 2974 if (IsCompiled()) {; 2975 //Error(""Compile"",""can only be called once; this first call generates both the optimized and memberwise actions."");; 2976 return;; 2977 }; 2978 R__LOCKGUARD(gInterpreterMutex);; 2979 ; 2980 // fprintf(stderr,""Running Compile for %s %d %d req=%d,%d\n"",GetName(),fClassVersion,fOptimized,CanOptimize(),TestBit(kCannotOptimize));; 2981 ; 2982 // if (IsCompiled() && (!fOptimized || (CanOptimize() && !TestBit(kCannotOptimize)))) return;; 2983 fOptimized = kFALSE;; 2984 fNdata = 0;; 2985 fNfulldata = 0;; 2986 ; 2987 TObjArray* infos = (TObjArray*) gROOT->GetListOfStreamerInfo();; 2988 if (fNumber < 0) {; 2989 ++fgCount;; 2990 fNumber = fgCount;; 2991 }; 2992 if (fNumber >= infos->GetSize()) {; 2993 infos->AddAtAndExpand(this, fNumber);; 2994 } else {; 2995 if (!infos->At(fNumber)) {; 2996 infos->AddAt(this, fNumber);; 2997 }; 2998 }; 2999 ; 3000 assert(fComp == 0 && fCompFull == 0 && fCompOpt == 0);; 3001 ; 3002 ; 3003 Int_t ndata = fElements->GetEntriesFast();; 3004 ; 3005 ; 3006 if (fReadObjectWise) fReadObjectWise->fActions.clear();; 3007 else fReadObjectWise = new TStreamerInfoActions::TActionSequence(this,ndata);; 3008 ; 3009 if (fWriteObjectWise) fWriteObjectWise->fActions.clear();; 3010 else fWriteObjectWise = new TStreamerInfoActions::TActionSequence(this,ndata);; 3011 ; 3012 if (fReadMemberWise) fReadMemberWise->fActions.clear();; 3013 else fReadMemberWise = new TStreamerInfoActions::TActionSequence(this,ndata);; 3014 ; 3015 if (fReadText) fReadText->fActions.clear();; 3016 else fReadText = new TStreamerInfoActions::TActionSequence(this,ndata);; 3",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TStreamerInfoActions_8cxx_source.html:131436,assert,assert,131436,doc/master/TStreamerInfoActions_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TStreamerInfoActions_8cxx_source.html,1,['assert'],['assert']
Testability,"n(Double_t x) constFind bin number corresponding to abscissa x.Definition TAxis.cxx:419; TAxis::ChooseTimeFormatconst char * ChooseTimeFormat(Double_t axislength=0)Choose a reasonable time format from the coordinates in the active pad and the number of divisions in...Definition TAxis.cxx:132; TAxis::SaveAttributesvoid SaveAttributes(std::ostream &out, const char *name, const char *subname) overrideSave axis attributes as C++ statement(s) on output stream out.Definition TAxis.cxx:710; TAxis::IsATClass * IsA() const overrideDefinition TAxis.h:177; TAxis::GetLastInt_t GetLast() constReturn last bin on the axis i.e.Definition TAxis.cxx:469; TAxis::ImportAttributesvirtual void ImportAttributes(const TAxis *axis)Copy axis attributes to this.Definition TAxis.cxx:680; TAxis::GetTimeFormatOnlyvirtual const char * GetTimeFormatOnly() constReturn only the time format from the string fTimeFormat.Definition TAxis.cxx:599; TAxis::GetBinCenterLogvirtual Double_t GetBinCenterLog(Int_t bin) constReturn center of bin in log With a log-equidistant binning for a bin with low and up edges,...Definition TAxis.cxx:501; TAxis::SetAlphanumericvoid SetAlphanumeric(Bool_t alphanumeric=kTRUE)Set axis alphanumeric.Definition TAxis.cxx:842; TAxis::Streamervoid Streamer(TBuffer &) overrideStream an object of class TAxis.Definition TAxis.cxx:1216; TAxis::operator=TAxis & operator=(const TAxis &)Assignment operator.Definition TAxis.cxx:118; TAxis::~TAxis~TAxis() overrideDestructor.Definition TAxis.cxx:89; TAxis::ChangeLabelByValuevoid ChangeLabelByValue(Double_t labValue, Double_t labAngle=-1., Double_t labSize=-1., Int_t labAlign=-1, Int_t labColor=-1, Int_t labFont=-1, const TString &labText="""")Define new text attributes for the label value ""labValue"".Definition TAxis.cxx:1009; TAxis::SetRangeUservirtual void SetRangeUser(Double_t ufirst, Double_t ulast)Set the viewing range for the axis from ufirst to ulast (in user coordinates, that is,...Definition TAxis.cxx:1080; TAxis::GetTimeFormatvirtual c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TAxis_8cxx_source.html:58461,log,log,58461,doc/master/TAxis_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TAxis_8cxx_source.html,2,['log'],"['log', 'log-equidistant']"
Testability,"n(TMVA::TActivation* activation); virtual voidTMVA::MethodBase::SetAnalysisType(TMVA::Types::EAnalysisType type); voidTMVA::MethodBase::SetBaseDir(TDirectory* methodDir); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTMVA::Configurable::SetConfigDescription(const char* d); voidTMVA::Configurable::SetConfigName(const char* n); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTMVA::MethodBase::SetMethodBaseDir(TDirectory* methodDir); voidTMVA::MethodBase::SetMethodDir(TDirectory* methodDir); voidTMVA::Configurable::SetMsgType(TMVA::EMsgType t); voidSetNeuronInputCalculator(TMVA::TNeuronInput* inputCalculator); static voidTObject::SetObjectStat(Bool_t stat); voidTMVA::Configurable::SetOptions(const TString& s); voidTMVA::MethodBase::SetSignalReferenceCut(Double_t cut); voidTMVA::MethodBase::SetSignalReferenceCutOrientation(Double_t cutOrientation); voidTMVA::MethodBase::SetTestTime(Double_t testTime); voidTMVA::MethodBase::SetTestvarName(const TString& v = """"); voidTMVA::MethodBase::SetTrainTime(Double_t trainTime); virtual voidTMVA::MethodBase::SetTuneParameters(map<TString,Double_t> tuneParameters); virtual voidTObject::SetUniqueID(UInt_t uid); voidTMVA::MethodBase::SetupMethod(); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTMVA::MethodBase::TestClassification(); virtual voidTMVA::MethodBase::TestMulticlass(); virtual voidTMVA::MethodBase::TestRegression(Double_t& bias, Double_t& biasT, Double_t& dev, Double_t& devT, Double_t& rms, Double_t& rmsT, Double_t& mInf, Double_t& mInfT, Double_t& corr, TMVA::Types::ETreeType type); virtual voidTrain(); voidTMVA::MethodBase::TrainMethod(); virtual voidTObject::UseCu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TMVA__MethodANNBase.html:12331,test,testTime,12331,root/html602/TMVA__MethodANNBase.html,https://root.cern,https://root.cern/root/html602/TMVA__MethodANNBase.html,2,['test'],['testTime']
Testability,"n(TMVA::TActivation* activation); virtual voidTMVA::MethodBase::SetAnalysisType(TMVA::Types::EAnalysisType type); voidTMVA::MethodBase::SetBaseDir(TDirectory* methodDir); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTMVA::Configurable::SetConfigDescription(const char* d); voidTMVA::Configurable::SetConfigName(const char* n); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTMVA::MethodBase::SetMethodBaseDir(TDirectory* methodDir); voidTMVA::MethodBase::SetMethodDir(TDirectory* methodDir); voidTMVA::Configurable::SetMsgType(TMVA::EMsgType t); voidSetNeuronInputCalculator(TMVA::TNeuronInput* inputCalculator); static voidTObject::SetObjectStat(Bool_t stat); voidTMVA::Configurable::SetOptions(const TString& s); voidTMVA::MethodBase::SetSignalReferenceCut(Double_t cut); voidTMVA::MethodBase::SetSignalReferenceCutOrientation(Double_t cutOrientation); voidTMVA::MethodBase::SetTestTime(Double_t testTime); voidTMVA::MethodBase::SetTestvarName(const TString& v = """"); voidTMVA::MethodBase::SetTrainTime(Double_t trainTime); virtual voidTMVA::MethodBase::SetTuneParameters(map<TString,Double_t> tuneParameters); virtual voidTObject::SetUniqueID(UInt_t uid); voidTMVA::MethodBase::SetupMethod(); virtual voidShowMembers(TMemberInspector&); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTMVA::MethodBase::TestClassification(); virtual voidTMVA::MethodBase::TestMulticlass(); virtual voidTMVA::MethodBase::TestRegression(Double_t& bias, Double_t& biasT, Double_t& dev, Double_t& devT, Double_t& rms, Double_t& rmsT, Double_t& mInf, Double_t& mInfT, Double_t& corr, TMVA::Types::ETreeType type); virtual voidTrain(); voidTMVA::MethodBase::TrainMethod(); virtual voidTObject::UseCurrentStyle(",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TMVA__MethodANNBase.html:11352,test,testTime,11352,root/html534/TMVA__MethodANNBase.html,https://root.cern,https://root.cern/root/html534/TMVA__MethodANNBase.html,1,['test'],['testTime']
Testability,"n(const LayerContainer &_layers, std::vector< LayerData > &layerData) constDefinition NeuralNet.icc:1221; TMVA::DNN::Net::backPropagatevoid backPropagate(std::vector< std::vector< LayerData > > &layerPatternData, const Settings &settings, size_t trainFromLayer, size_t totalNumWeights) constDefinition NeuralNet.icc:1355; TMVA::DNN::SettingsSettings for the training of the neural net.Definition NeuralNet.h:730; TMVA::DNN::Settings::useMultithreadingbool useMultithreading() constis multithreading turned on?Definition NeuralNet.h:815; TMVA::DNN::Settings::regularizationEnumRegularization regularization() constsome regularization of the DNN is turned on?Definition NeuralNet.h:813; TMVA::DNN::Settings::convergenceCountsize_t convergenceCount() constreturns the current convergence countDefinition NeuralNet.h:827; TMVA::DNN::Settings::testRepetitionssize_t testRepetitions() consthow often is the test data testedDefinition NeuralNet.h:768; TMVA::DNN::Settings::endTestCyclevirtual void endTestCycle()callback for monitoring and logggingDefinition NeuralNet.h:805; TMVA::DNN::Settings::testIterationvirtual void testIteration()callback for monitoring and logggingDefinition NeuralNet.h:806; TMVA::DNN::Settings::hasConvergedvirtual bool hasConverged(double testError)has this training converged already?Definition NeuralNet.cxx:485; TMVA::DNN::Settings::cyclevirtual void cycle(double progress, TString text)Definition NeuralNet.h:799; TMVA::DNN::Settings::endTrainCyclevirtual void endTrainCycle(double)callback for monitoring and loggingDefinition NeuralNet.h:788; TMVA::DNN::Settings::dropFractionsconst std::vector< double > & dropFractions() constDefinition NeuralNet.h:762; TMVA::DNN::Settings::addPointvoid addPoint(std::string histoName, double x)for monitoringDefinition NeuralNet.h:821; TMVA::DNN::Settings::testSamplevirtual void testSample(double, double, double, double)virtual function to be used for monitoring (callback)Definition NeuralNet.h:781; TMVA::DNN::Settings::plotvoid pl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/NeuralNet_8icc_source.html:67462,log,logggingDefinition,67462,doc/master/NeuralNet_8icc_source.html,https://root.cern,https://root.cern/doc/master/NeuralNet_8icc_source.html,1,['log'],['logggingDefinition']
Testability,"n(const TH1* hist, Bool_t errors = kFALSE, Bool_t zBins = kFALSE); Bool_tSetRangesCylindrical(const TH1* hist); Bool_tSetRangesPolar(const TH1* hist); Bool_tSetRangesSpherical(const TH1* hist); TGLPlotCoordinates(const TGLPlotCoordinates&). Data Members; private:. EGLCoordTypefCoordType; Double_tfFactor; Bool_tfModified; Rgl::BinRange_tfXBins; Bool_tfXLog; Rgl::Range_tfXRange; Rgl::Range_tfXRangeScaled; Double_tfXScale; Rgl::BinRange_tfYBins; Bool_tfYLog; Rgl::Range_tfYRange; Rgl::Range_tfYRangeScaled; Double_tfYScale; Rgl::BinRange_tfZBins; Bool_tfZLog; Rgl::Range_tfZRange; Rgl::Range_tfZRangeScaled; Double_tfZScale. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGLPlotCoordinates(); Constructor. ~TGLPlotCoordinates(); Destructor. void SetCoordType(EGLCoordType type); If coord type was changed, plot must reset sections (if any),; set fModified. EGLCoordType GetCoordType() const; Get coordinates type. void SetXLog(Bool_t xLog); If log changed, sections must be reset,; set fModified. Bool_t GetXLog() const; Get X log. void SetYLog(Bool_t yLog); If log changed, sections must be reset,; set fModified. Bool_t GetYLog() const; Get Y log. void SetZLog(Bool_t zLog); If log changed, sections must be reset,; set fModified. Bool_t GetZLog() const; Get Z log. void ResetModified(); Reset modified. Bool_t Modified() const; Modified. Bool_t SetRanges(const TH1* hist, Bool_t errors = kFALSE, Bool_t zBins = kFALSE); Set bin ranges, ranges. Int_t GetNXBins() const; Number of X bins. Int_t GetNYBins() const; Number of Y bins. Int_t GetNZBins() const; Number of Z bins. const Rgl::BinRange_t & GetXBins() const; X bins range. const Rgl::BinRange_t & GetYBins() const; Y bins range. const Rgl::BinRange_t & GetZBins() const; Z bins range. const Rgl::Range_t & GetXRange() const; X range. Double_t GetXLength() const; X length. const Rgl::Range_t & GetYRange() const; Y range. Double_t GetYLength() const; Y length. const Rgl::Range_t & GetZRange() co",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGLPlotCoordinates.html:3037,log,log,3037,root/html602/TGLPlotCoordinates.html,https://root.cern,https://root.cern/root/html602/TGLPlotCoordinates.html,2,['log'],['log']
Testability,"n(frame1, Cut=""sample==sample::physics""); ; # Plot ""physics"" slice of simultaneous pdf.; # NB: You *must* project the sample index category with data using ProjWData as; # a RooSimultaneous makes no prediction on the shape in the index category and; # can thus not be integrated. In other words: Since the PDF doesn't know the; # number of events in the different category states, it doesn't know how much; # of each component it has to project out. This info is read from the data.; simPdf.plotOn(frame1, Slice=(sample, ""physics""), ProjWData=(sample, combData)); simPdf.plotOn(frame1, Slice=(sample, ""physics""), Components=""px"", ProjWData=(sample, combData), LineStyle=""--""); ; # The same plot for the control sample slice. We do this with a different; # approach this time, for illustration purposes. Here, we are slicing the; # dataset and then use the data slice for the projection, because then the; # RooFit::Slice() becomes unnecessary. This approach is more general,; # because you can plot sums of slices by using logical or in the Cut(); # command.; frame2 = x.frame(Title=""Control sample""); slicedData = combData.reduce(Cut=""sample==sample::control""); slicedData.plotOn(frame2); simPdf.plotOn(frame2, ProjWData=(sample, slicedData)); simPdf.plotOn(frame2, Components=""px_ctl"", ProjWData=(sample, slicedData), LineStyle=""--""); ; # The same plot for all the phase space. Here, we can just use the original; # combined dataset.; frame3 = x.frame(Title=""Both samples""); combData.plotOn(frame3); simPdf.plotOn(frame3, ProjWData=(sample, combData)); simPdf.plotOn(frame3, Components=""px,px_ctl"", ProjWData=(sample, combData), LineStyle=""--""); ; c = ROOT.TCanvas(""rf501_simultaneouspdf"", ""rf501_simultaneouspdf"", 1200, 400); c.Divide(3); ; ; def draw(i, frame):; c.cd(i); ROOT.gPad.SetLeftMargin(0.15); frame.GetYaxis().SetTitleOffset(1.4); frame.Draw(); ; ; draw(1, frame1); draw(2, frame2); draw(3, frame3); ; c.SaveAs(""rf501_simultaneouspdf.png""); [#1] INFO:Fitting -- RooAbsPdf::fitTo(simPdf) ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf501__simultaneouspdf_8py.html:4360,log,logical,4360,doc/master/rf501__simultaneouspdf_8py.html,https://root.cern,https://root.cern/doc/master/rf501__simultaneouspdf_8py.html,1,['log'],['logical']
Testability,"n))->fTypeSize; }. UInt_t Dimensions(Int_t columnIndex) const; {return ((tableDescriptor_st *)At(column))->fDimensions;}. TTable::EColumnType ColumnType(Int_t columnIndex) const; {return EColumnType(((tableDescriptor_st *)At(column))->fType);}. TClass * RowClass() const; { return fRowClass;}. void SetOffset(UInt_t offset, Int_t column); {((tableDescriptor_st *)At(column))->fOffset = offset;}. void SetSize(UInt_t size, Int_t column); {((tableDescriptor_st *)At(column))->fSize = size; }. void SetTypeSize(UInt_t size, Int_t column); {((tableDescriptor_st *)At(column))->fTypeSize = size; }. void SetDimensions(UInt_t dim, Int_t column); {((tableDescriptor_st *)At(column))->fDimensions = dim; }. void SetColumnType(TTable::EColumnType type, Int_t column); {((tableDescriptor_st *)At(column))->fType = type; }. TTableDescriptor & operator=(const TTableDescriptor& dsc). TTableDescriptor(const TTable* parentTable). TTableDescriptor(TClass* classPtr). TTableDescriptor(const TTableDescriptor& dsc); {}. TTableDescriptor(); {SetType(""tableDescriptor_st"");}. TTableDescriptor(const char* name); {SetType(""tableDescriptor_st"");}. tableDescriptor_st * GetTable(Int_t i = 0) const; { return ((tableDescriptor_st *)GetArray())+i;}. tableDescriptor_st & operator[](Int_t i); { assert(i>=0 && i < GetNRows()); return *GetTable(i); }. const tableDescriptor_st & operator[](Int_t i) const; { assert(i>=0 && i < GetNRows()); return *((const tableDescriptor_st *)(GetTable(i))); }. tableDescriptor_st * begin() const; { return GetNRows()? GetTable(0):0;}. tableDescriptor_st * end() const; {Long_t i = GetNRows(); return i? GetTable(i):0;}. const char * TableDictionary().  Author: Valery Fine 09/08/99 (E-mail: fine@bnl.gov)  Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *;  Last changed: root/table:$Id$  Last generated: 2015-06-30 15:31; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TTableDescriptor.html:22156,assert,assert,22156,root/html602/TTableDescriptor.html,https://root.cern,https://root.cern/root/html602/TTableDescriptor.html,2,['assert'],['assert']
Testability,"n))->fTypeSize; }. UInt_t Dimensions(Int_t columnIndex) const; {return ((tableDescriptor_st *)At(column))->fDimensions;}. TTable::EColumnType ColumnType(Int_t columnIndex) const; {return EColumnType(((tableDescriptor_st *)At(column))->fType);}. TClass * RowClass() const; { return fRowClass;}. void SetOffset(UInt_t offset, Int_t column); {((tableDescriptor_st *)At(column))->fOffset = offset;}. void SetSize(UInt_t size, Int_t column); {((tableDescriptor_st *)At(column))->fSize = size; }. void SetTypeSize(UInt_t size, Int_t column); {((tableDescriptor_st *)At(column))->fTypeSize = size; }. void SetDimensions(UInt_t dim, Int_t column); {((tableDescriptor_st *)At(column))->fDimensions = dim; }. void SetColumnType(TTable::EColumnType type, Int_t column); {((tableDescriptor_st *)At(column))->fType = type; }. TTableDescriptor & operator=(const TTableDescriptor& dsc). TTableDescriptor(const TTable* parentTable). TTableDescriptor(TClass* classPtr). TTableDescriptor(const TTableDescriptor& dsc); {}. TTableDescriptor(); {SetType(""tableDescriptor_st"");}. TTableDescriptor(const char* name); {SetType(""tableDescriptor_st"");}. tableDescriptor_st * GetTable(Int_t i = 0) const; { return ((tableDescriptor_st *)GetArray())+i;}. tableDescriptor_st & operator[](Int_t i); { assert(i>=0 && i < GetNRows()); return *GetTable(i); }. const tableDescriptor_st & operator[](Int_t i) const; { assert(i>=0 && i < GetNRows()); return *((const tableDescriptor_st *)(GetTable(i))); }. tableDescriptor_st * begin() const; { return GetNRows()? GetTable(0):0;}. tableDescriptor_st * end() const; {Long_t i = GetNRows(); return i? GetTable(i):0;}. const char * TableDictionary().  Author: Valery Fine 09/08/99 (E-mail: fine@bnl.gov)  Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *;  Last changed: root/table:$Id$  Last generated: 2015-09-08 17:49; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TTableDescriptor.html:22100,assert,assert,22100,root/html604/TTableDescriptor.html,https://root.cern,https://root.cern/root/html604/TTableDescriptor.html,2,['assert'],['assert']
Testability,"n, const char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Float_tfCarry; Int_tfCount24; Float_tfFloatSeedTable[24]; Int_tfIlag; const Int_tfIntModulus; Int_tfJlag; Int_tfLuxury; const Double_tfMantissaBit12; const Double_tfMantissaBit24; TStringTNamed::fNameobject identifier; Int_tfNskip; UInt_tTRandom::fSeedRandom number generator seed; const UInt_t*fTheSeeds; TStringTNamed::fTitleobject title; static Int_tfgMaxIndex; static Int_tfgNumEngines. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TRandom1(UInt_t seed, Int_t lux = 3); Luxury level is set in the same way as the original FORTRAN routine.; level 0 (p=24): equivalent to the original RCARRY of Marsaglia; and Zaman, very long period, but fails many tests.; level 1 (p=48): considerable improvement in quality over level 0,; now passes the gap test, but still fails spectral test.; level 2 (p=97): passes all known tests, but theoretically still; defective.; level 3 (p=223): DEFAULT VALUE. Any theoretically possible; correlations have very small chance of being observed.; level 4 (p=389): highest possible luxury, all 24 bits chaotic. TRandom1(); default constructor. TRandom1(Int_t rowIndex, Int_t colIndex, Int_t lux); constructor. ~TRandom1(); destructor. void GetTableSeeds(UInt_t* seeds, Int_t index); static function returning the table of seeds. Double_t Rndm(Int_t i = 0); return a random number in ]0,1]. void RndmArray(Int_t size, Float_t* vect); return an array of random numbers in ]0,1]. void RndmArray(Int_t size, Double_t* vect); return an array of random numbers in ]0,1[. void SetSeeds(const UInt_t* seeds, Int_t lux = 3); set seeds. void SetSeed2(UInt_t seed, Int_t lux = 3); T",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TRandom1.html:7860,test,tests,7860,root/html534/TRandom1.html,https://root.cern,https://root.cern/root/html534/TRandom1.html,1,['test'],['tests']
Testability,"n, const char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Float_tfCarry; Int_tfCount24; Float_tfFloatSeedTable[24]; Int_tfIlag; const Int_tfIntModulus; Int_tfJlag; Int_tfLuxury; const Double_tfMantissaBit12; const Double_tfMantissaBit24; TStringTNamed::fNameobject identifier; Int_tfNskip; UInt_tTRandom::fSeedRandom number generator seed; const UInt_t*fTheSeeds; TStringTNamed::fTitleobject title; static Int_tfgMaxIndex; static Int_tfgNumEngines. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TRandom1(UInt_t seed, Int_t lux = 3); Luxury level is set in the same way as the original FORTRAN routine.; level 0 (p=24): equivalent to the original RCARRY of Marsaglia; and Zaman, very long period, but fails many tests.; level 1 (p=48): considerable improvement in quality over level 0,; now passes the gap test, but still fails spectral test.; level 2 (p=97): passes all known tests, but theoretically still; defective.; level 3 (p=223): DEFAULT VALUE. Any theoretically possible; correlations have very small chance of being observed.; level 4 (p=389): highest possible luxury, all 24 bits chaotic. TRandom1(); default constructor. TRandom1(Int_t rowIndex, Int_t colIndex, Int_t lux); constructor. ~TRandom1(); destructor. void GetTableSeeds(UInt_t* seeds, Int_t index); static function returning the table of seeds. Double_t Rndm(Int_t i = 0); return a random number in ]0,1]. void RndmArray(Int_t size, Float_t* vect); return an array of random numbers in ]0,1]. void RndmArray(Int_t size, Double_t* vect); return an array of random numbers in ]0,1]. void SetSeeds(const UInt_t* seeds, Int_t lux = 3); set seeds. void SetSeed2(UInt_t seed, Int_t lux = 3); T",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TRandom1.html:7781,test,tests,7781,root/html528/TRandom1.html,https://root.cern,https://root.cern/root/html528/TRandom1.html,3,['test'],['tests']
Testability,"n, double m, double x0=0); Cumulative distribution function of the F-distribution (lower tail). ; ; doubleROOT::Math::fdistribution_cdf_c (double x, double n, double m, double x0=0); Complement of the cumulative distribution function of the F-distribution (upper tail). ; ; doubleROOT::Math::gamma_cdf (double x, double alpha, double theta, double x0=0); Cumulative distribution function of the gamma distribution (lower tail). ; ; doubleROOT::Math::gamma_cdf_c (double x, double alpha, double theta, double x0=0); Complement of the cumulative distribution function of the gamma distribution (upper tail). ; ; doubleROOT::Math::landau_cdf (double x, double xi=1, double x0=0); Cumulative distribution function of the Landau distribution (lower tail). ; ; doubleROOT::Math::landau_cdf_c (double x, double xi=1, double x0=0); Complement of the distribution function of the Landau distribution (upper tail). ; ; doubleROOT::Math::lognormal_cdf (double x, double m, double s, double x0=0); Cumulative distribution function of the lognormal distribution (lower tail). ; ; doubleROOT::Math::lognormal_cdf_c (double x, double m, double s, double x0=0); Complement of the cumulative distribution function of the lognormal distribution (upper tail). ; ; doubleROOT::Math::negative_binomial_cdf (unsigned int k, double p, double n); Cumulative distribution function of the Negative Binomial distribution Lower tail of the integral of the negative_binomial_pdf. ; ; doubleROOT::Math::negative_binomial_cdf_c (unsigned int k, double p, double n); Complement of the cumulative distribution function of the Negative Binomial distribution. ; ; doubleROOT::Math::normal_cdf (double x, double sigma=1, double x0=0); Cumulative distribution function of the normal (Gaussian) distribution (lower tail). ; ; doubleROOT::Math::normal_cdf_c (double x, double sigma=1, double x0=0); Complement of the cumulative distribution function of the normal (Gaussian) distribution (upper tail). ; ;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__ProbFunc.html:5025,log,lognormal,5025,doc/master/group__ProbFunc.html,https://root.cern,https://root.cern/doc/master/group__ProbFunc.html,1,['log'],['lognormal']
Testability,"n, double& xmax) const; boolHasCdf() const; boolHasMode() const; boolHasPdfArea() const; virtual TClass*IsA() const; boolIsLogPdf() const; doubleMode() const; TUnuranContDist&operator=(const TUnuranContDist& rhs); doublePdf(double x) const; doublePdfArea() const; voidSetCdf(TF1* cdf); voidSetCdf(const ROOT::Math::IGenFunction& cdf); voidSetDomain(double xmin, double xmax); voidSetMode(double mode); voidSetPdfArea(double area); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Data Members; private:. doublefAreaarea below pdf; const ROOT::Math::IBaseFunctionOneDim*fCdfpointer to the cdf (cumulative dist.); const ROOT::Math::IBaseFunctionOneDim*fDPdfpointer to the derivative of the pdf; boolfHasAreaflag to control if distribution has a pre-computed area below the pdf; boolfHasDomainflag to control if distribution has a defined domain (otherwise is [-inf,+inf]; boolfHasModeflag to control if distribution has a pre-computed mode; boolfIsLogPdfflag to control if function pointer represent log of pdf; doublefModemode of the distribution; boolfOwnFuncflag to indicate if class manages the function pointers; const ROOT::Math::IBaseFunctionOneDim*fPdfpointer to the pdf ; doublefXmaxupper value of the domain; doublefXminlower value of the domain . Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TUnuranContDist(const ROOT::Math::IGenFunction& pdf, const ROOT::Math::IGenFunction* dpdf = 0, bool isLogPdf = false, bool copyFunc = false); Constructor from generic function interfaces; manage the functions and clone them if flag copyFunc is true. TUnuranContDist(TF1* pdf = 0, TF1* deriv = 0, bool isLogPdf = false); Constructor from a TF1 objects; function pointers are managed by class. TUnuranContDist(const TUnuranContDist& ); Implementation of copy constructor. ~TUnuranContDist(); destructor implementation. void SetCdf(const ROOT::Math::IGenFunction& cdf); set cdf distributi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TUnuranContDist.html:1841,log,log,1841,root/html528/TUnuranContDist.html,https://root.cern,https://root.cern/root/html528/TUnuranContDist.html,3,['log'],['log']
Testability,"n, the other the derivative. One or both function object can be a free C function of type double ()(double ).; 13.7.4.3 Wrapping Multi-dimensional Functions; The class ROOT::Math::Functor is used to wrap in a very simple and convenient way multi-dimensional function objects. It can wrap all the following types: * Any C++ callable object implementing double operator()( const double * ). * A free C function of type double ()(const double * ). * A member function with the correct signature like Foo::Eval(const double * ). In this case one pass the object pointer and a pointer to the member function (&Foo::Eval).; The function dimension is required when constructing the functor.; Example of using Functor:; #include ""Math/Functor.h"". class MyFunction {. public:; double operator()(const double *x) const {; return x[0]+x[1];; }. double Eval(const double * x) const { return x[0]+x[1]; }; };. double freeFunction(const double * x ); {; return x[0]+x[1];; }. int main(); {; // test directly calling the function object; MyFunction myf;. // test from a free function pointer; ROOT::Math::Functor f1(&freeFunction,2);. // test from function object; ROOT::Math::Functor f2(myf,2);. // test from a member function; ROOT::Math::Functor f3(&myf,&MyFunction::Eval,2);. double x[] = {1,2};. cout << f1(x) << endl;; cout << f2(x) << endl;; cout << f3(x) << endl;. return 0;; }; 13.7.4.4 Wrapping Multi-dimensional Gradient Functions; The class ROOT::Math::GradFunctor is used to wrap in a very C++ callable object to make gradient functions. It can be constructed in three different way: * From an object implementing both double operator()( const double * ) for the function evaluation and double Derivative(const double *, int icoord) for the partial derivatives. * From an object implementing any member function like Foo::XXX(const double *) for the function evaluation and any member function like Foo::XXX(const double *, int icoord) for the partial derivatives. * From an function object implementin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:697144,test,test,697144,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['test'],['test']
Testability,"n, which allows to fix the parameter (not to fit).;  Bool_t; fFixSx; //logical value of s parameter for 1D ridges in; x direction, which allows to fix the parameter (not to fit).;  Bool_t; fFixSy; //logical value of s parameter for 1D ridges in; y direction, which allows to fix the parameter (not to fit).;  Bool_t fFixBx; //logical; value of b parameter for 1D ridges in x direction, which allows to fix the; parameter (not to fit).;  Bool_t; fFixBy; //logical value of b parameter for 1D ridges in; y direction, which allows to fix the parameter (not to fit).;  Bool_t; fFixA0; //logical value of a0 parameter, which allows; to fix the parameter (not to fit).;  Bool_t; fFixAx; //logical value of ax parameter, which allows; to fix the parameter (not to fit).;  Bool_t; fFixAy; //logical value of ay parameter, which allows; to fix the parameter (not to fit).; ; References:; [1] Phillps G.W., Marlow K.W.,; NIM 137 (1976) 525.; [2] I. A. Slavic: Nonlinear; least-squares fitting without matrix inversion applied to complex Gaussian; spectra analysis. NIM 134 (1976) 285-289.; [3] T. Awaya: A new method for; curve fitting to the data with low statistics not using chi-square method. NIM; 165 (1979) 317-323.; [4] T. Hauschild, M. Jentschel:; Comparison of maximum likelihood estimation and chi-square statistics applied; to counting experiments. NIM A 457 (2001) 384-401.; [5] M. Morh, J.; Kliman, M. Jandel, . Krupa, V. Matouek: Study of fitting algorithms; applied to simultaneous analysis of large number of peaks in -ray spectra. Applied Spectroscopy, Vol. 57, No. 7, pp. 753-760, 2003; ; Example  script FitAwmi2.c:. Fig. 1 Original two-dimensional; spectrum with found peaks (using TSpectrum2 peak searching function). The; positions of peaks were used as initial estimates i",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TSpectrum2Fit.html:50691,log,logical,50691,root/html528/TSpectrum2Fit.html,https://root.cern,https://root.cern/root/html528/TSpectrum2Fit.html,6,['log'],['logical']
Testability,"n,; 6171 selectionFileName,; 6172 targetLibName,; 6173 multidict,; 6174 pcmsNames,; 6175 includes,; 6176 preprocDefines,; 6177 preprocUndefines,; 6178 warnings,; 6179 rootmapFileName,; 6180 rootmapLibName,; 6181 interpreteronly,; 6182 doSplit,; 6183 isCxxmodule,; 6184 writeEmptyRootPCM,; 6185 selSyntaxOnly,; 6186 noIncludePaths,; 6187 noGlobalUsingStd,; 6188 headersNames,; 6189 failOnWarnings,; 6190 printRootclingInvocation,; 6191 ofileName);; 6192 } else {; 6193 // Here ofilename is either """" or a directory: this is irrelevant.; 6194 returnValue = invokeManyRootCling(verbosityOption,; 6195 selectionFileName,; 6196 targetLibName,; 6197 multidict,; 6198 pcmsNames,; 6199 includes,; 6200 preprocDefines,; 6201 preprocUndefines,; 6202 warnings,; 6203 rootmapFileName,; 6204 rootmapLibName,; 6205 interpreteronly,; 6206 doSplit,; 6207 isCxxmodule,; 6208 writeEmptyRootPCM,; 6209 selSyntaxOnly,; 6210 noIncludePaths,; 6211 noGlobalUsingStd,; 6212 headersNames,; 6213 failOnWarnings,; 6214 printRootclingInvocation,; 6215 ofileName);; 6216 }; 6217 ; 6218 return returnValue;; 6219}; 6220 ; 6221 ; 6222////////////////////////////////////////////////////////////////////////////////; 6223 ; 6224extern ""C""; 6225int ROOT_rootcling_Driver(int argc, char **argv, const ROOT::Internal::RootCling::DriverConfig& config); 6226{; 6227 ; 6228 assert(!gDriverConfig && ""Driver configuration already set!"");; 6229 gDriverConfig = &config;; 6230 ; 6231 gBuildingROOT = config.fBuildingROOTStage1; // gets refined later; 6232 ; 6233 std::string exeName = ExtractFileName(GetExePath());; 6234#ifdef __APPLE__; 6235 // _dyld_get_image_name() on macOS11 and later sometimes returns ""rootcling"" for ""genreflex"".; 6236 // Fix that (while still initializing the binary path, needed for ROOTSYS) by updating the; 6237 // exeName to argv[0]:; 6238 exeName = ExtractFileName(argv[0]);; 6239#endif; 6240 ; 6241 // Select according to the name of the executable the procedure to follow:; 6242 // 1) RootCling; 6243 // 2) G",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rootcling__impl_8cxx_source.html:244428,assert,assert,244428,doc/master/rootcling__impl_8cxx_source.html,https://root.cern,https://root.cern/doc/master/rootcling__impl_8cxx_source.html,1,['assert'],['assert']
Testability,"n.; 3270 ; 3271 cl = GetIdMap()->Find(typeinfo.name());; 3272 ; 3273 if (cl) {; 3274 if (cl->IsLoaded()) return cl;; 3275 //we may pass here in case of a dummy class created by TVirtualStreamerInfo; 3276 load = kTRUE;; 3277 } else {; 3278 // Note we might need support for typedefs and simple types!; 3279 ; 3280 // TDataType *objType = GetType(name, load);; 3281 //if (objType) {; 3282 // const char *typdfName = objType->GetTypeName();; 3283 // if (typdfName && strcmp(typdfName, name)) {; 3284 // cl = GetClass(typdfName, load);; 3285 // return cl;; 3286 // }; 3287 // }; 3288 }; 3289 ; 3290 if (!load) return nullptr;; 3291 ; 3292 DictFuncPtr_t dict = TClassTable::GetDict(typeinfo);; 3293 if (dict) {; 3294 cl = (dict)();; 3295 if (cl) cl->PostLoadCheck();; 3296 return cl;; 3297 }; 3298 if (cl) return cl;; 3299 ; 3300 TIter next(gROOT->GetListOfClassGenerators());; 3301 TClassGenerator *gen;; 3302 while( (gen = (TClassGenerator*) next()) ) {; 3303 cl = gen->GetClass(typeinfo,load);; 3304 if (cl) {; 3305 cl->PostLoadCheck();; 3306 return cl;; 3307 }; 3308 }; 3309 ; 3310 // try AutoLoading the typeinfo; 3311 int autoload_old = gCling->SetClassAutoLoading(1);; 3312 if (!autoload_old) {; 3313 // Re-disable, we just meant to test; 3314 gCling->SetClassAutoLoading(0);; 3315 }; 3316 if (autoload_old && gInterpreter->AutoLoad(typeinfo,kTRUE)) {; 3317 // Disable autoload to avoid potential infinite recursion; 3318 TInterpreter::SuspendAutoLoadingRAII autoloadOff(gInterpreter);; 3319 cl = GetClass(typeinfo, load, hint_pair_offset, hint_pair_size);; 3320 if (cl) {; 3321 return cl;; 3322 }; 3323 }; 3324 ; 3325 if (hint_pair_offset) {; 3326 int err = 0;; 3327 char* demangled_name = TClassEdit::DemangleTypeIdName(typeinfo, err);; 3328 if (!err) {; 3329 cl = TClass::GetClass(demangled_name, load, kTRUE, hint_pair_offset, hint_pair_size);; 3330 free(demangled_name);; 3331 if (cl); 3332 return cl;; 3333 }; 3334 }; 3335 ; 3336 // last attempt. Look in the interpreter list of all (compiled+",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/TClass_8cxx_source.html:126046,test,test,126046,doc/v632/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html,1,['test'],['test']
Testability,"n.; 3337 ; 3338 cl = GetIdMap()->Find(typeinfo.name());; 3339 ; 3340 if (cl) {; 3341 if (cl->IsLoaded()) return cl;; 3342 //we may pass here in case of a dummy class created by TVirtualStreamerInfo; 3343 load = kTRUE;; 3344 } else {; 3345 // Note we might need support for typedefs and simple types!; 3346 ; 3347 // TDataType *objType = GetType(name, load);; 3348 //if (objType) {; 3349 // const char *typdfName = objType->GetTypeName();; 3350 // if (typdfName && strcmp(typdfName, name)) {; 3351 // cl = GetClass(typdfName, load);; 3352 // return cl;; 3353 // }; 3354 // }; 3355 }; 3356 ; 3357 if (!load) return nullptr;; 3358 ; 3359 DictFuncPtr_t dict = TClassTable::GetDict(typeinfo);; 3360 if (dict) {; 3361 cl = (dict)();; 3362 if (cl) cl->PostLoadCheck();; 3363 return cl;; 3364 }; 3365 if (cl) return cl;; 3366 ; 3367 TIter next(gROOT->GetListOfClassGenerators());; 3368 TClassGenerator *gen;; 3369 while( (gen = (TClassGenerator*) next()) ) {; 3370 cl = gen->GetClass(typeinfo,load);; 3371 if (cl) {; 3372 cl->PostLoadCheck();; 3373 return cl;; 3374 }; 3375 }; 3376 ; 3377 // try AutoLoading the typeinfo; 3378 int autoload_old = gCling->SetClassAutoLoading(1);; 3379 if (!autoload_old) {; 3380 // Re-disable, we just meant to test; 3381 gCling->SetClassAutoLoading(0);; 3382 }; 3383 if (autoload_old && gInterpreter->AutoLoad(typeinfo,kTRUE)) {; 3384 // Disable autoload to avoid potential infinite recursion; 3385 TInterpreter::SuspendAutoLoadingRAII autoloadOff(gInterpreter);; 3386 cl = GetClass(typeinfo, load, hint_pair_offset, hint_pair_size);; 3387 if (cl) {; 3388 return cl;; 3389 }; 3390 }; 3391 ; 3392 if (hint_pair_offset) {; 3393 int err = 0;; 3394 char* demangled_name = TClassEdit::DemangleTypeIdName(typeinfo, err);; 3395 if (!err) {; 3396 cl = TClass::GetClass(demangled_name, load, kTRUE, hint_pair_offset, hint_pair_size);; 3397 free(demangled_name);; 3398 if (cl); 3399 return cl;; 3400 }; 3401 }; 3402 ; 3403 // last attempt. Look in the interpreter list of all (compiled+",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TClass_8cxx_source.html:128797,test,test,128797,doc/master/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TClass_8cxx_source.html,1,['test'],['test']
Testability,"n.; 98 ; 99 L. Peter Deutsch; 100 ghost@aladdin.com; 101 ; 102 */; 103/* $Id: md5.c,v 1.6 2002/04/13 19:20:28 lpd Exp $ */; 104/*; 105 Independent implementation of MD5 (RFC 1321).; 106 ; 107 This code implements the MD5 Algorithm defined in RFC 1321, whose; 108 text is available at; 109 http://www.ietf.org/rfc/rfc1321.txt; 110 The code is derived from the text of the RFC, including the test suite; 111 (section A.5) but excluding the rest of Appendix A. It does not include; 112 any code or documentation that is identified in the RFC as being; 113 copyrighted.; 114 ; 115 The original and principal author of md5.c is L. Peter Deutsch; 116 <ghost@aladdin.com>. Other authors are noted in the change history; 117 that follows (in reverse chronological order):; 118 ; 119 2002-04-13 lpd Clarified derivation from RFC 1321; now handles byte order; 120 either statically or dynamically; added missing #include <string.h>; 121 in library.; 122 2002-03-11 lpd Corrected argument list for main(), and added int return; 123 type, in test program and T value program.; 124 2002-02-21 lpd Added missing #include <stdio.h> in test program.; 125 2000-07-03 lpd Patched to eliminate warnings about ""constant is; 126 unsigned in ANSI C, signed in traditional""; made test program; 127 self-checking.; 128 1999-11-04 lpd Edited comments slightly for automatic TOC extraction.; 129 1999-10-18 lpd Fixed typo in header comment (ansi2knr rather than md5).; 130 1999-05-03 lpd Original version.; 131 */; 132 ; 133#if !defined(MD5_STATIC); 134#include <stdint.h>; 135#include <string.h>; 136#endif; 137 ; 138#undef BYTE_ORDER /* 1 = big-endian, -1 = little-endian, 0 = unknown */; 139#if defined(ARCH_IS_BIG_ENDIAN); 140#define BYTE_ORDER (ARCH_IS_BIG_ENDIAN ? 1 : -1); 141#else; 142#define BYTE_ORDER (0); 143#endif; 144 ; 145#define T_MASK ((md5_word_t)~0); 146#define T1 /* 0xd76aa478 */ (T_MASK ^ 0x28955b87); 147#define T2 /* 0xe8c7b756 */ (T_MASK ^ 0x173848a9); 148#define T3 (0x242070db); 149#define T4 /* 0xc1",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/md5_8inl_source.html:5093,test,test,5093,doc/master/md5_8inl_source.html,https://root.cern,https://root.cern/doc/master/md5_8inl_source.html,1,['test'],['test']
Testability,"n; 281 ; 282 // Set individual event weights (the variables must exist in the original TTree); 283 // - for signal : `dataloader->SetSignalWeightExpression (""weight1*weight2"");`; 284 // - for background: `dataloader->SetBackgroundWeightExpression(""weight1*weight2"");`; 285 dataloader->SetBackgroundWeightExpression( ""weight"" );; 286 ; 287 // Apply additional cuts on the signal and background samples (can be different); 288 TCut mycuts = """"; // for example: TCut mycuts = ""abs(var1)<0.5 && abs(var2-0.5)<1"";; 289 TCut mycutb = """"; // for example: TCut mycutb = ""abs(var1)<0.5"";; 290 ; 291 // Tell the dataloader how to use the training and testing events; 292 //; 293 // If no numbers of events are given, half of the events in the tree are used; 294 // for training, and the other half for testing:; 295 //; 296 // dataloader->PrepareTrainingAndTestTree( mycut, ""SplitMode=random:!V"" );; 297 //; 298 // To also specify the number of testing events, use:; 299 //; 300 // dataloader->PrepareTrainingAndTestTree( mycut,; 301 // ""NSigTrain=3000:NBkgTrain=3000:NSigTest=3000:NBkgTest=3000:SplitMode=Random:!V"" );; 302 dataloader->PrepareTrainingAndTestTree( mycuts, mycutb,; 303 ""nTrain_Signal=1000:nTrain_Background=1000:SplitMode=Random:NormMode=NumEvents:!V"" );; 304 ; 305 // ### Book MVA methods; 306 //; 307 // Please lookup the various method configuration options in the corresponding cxx files, eg:; 308 // src/MethoCuts.cxx, etc, or here: http://tmva.sourceforge.net/old_site/optionRef.html; 309 // it is possible to preset ranges in the option string in which the cut optimisation should be done:; 310 // ""...:CutRangeMin[2]=-1:CutRangeMax[2]=1""..."", where [2] is the third input variable; 311 ; 312 // Cut optimisation; 313 if (Use[""Cuts""]); 314 factory->BookMethod( dataloader, TMVA::Types::kCuts, ""Cuts"",; 315 ""!H:!V:FitMethod=MC:EffSel:SampleSize=200000:VarProp=FSmart"" );; 316 ; 317 if (Use[""CutsD""]); 318 factory->BookMethod( dataloader, TMVA::Types::kCuts, ""CutsD"",; 319 ""!H:!V:FitMethod",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVAClassification_8C_source.html:12938,test,testing,12938,doc/master/TMVAClassification_8C_source.html,https://root.cern,https://root.cern/doc/master/TMVAClassification_8C_source.html,3,['test'],['testing']
Testability,"n; Long_t*TQCommand::fUndoArgsundo values; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TQUndoManager(); Constructor. ~TQUndoManager(); Destructor. void ls(Option_t* option = """") const; Lists all commands in stack. void PrintCollectionEntry(TObject* entry, Option_t* option, Int_t recurse) const; Print collection entry. void SetLogging(Bool_t on = kTRUE); Start logging. Delete all previous log records; Note: logging is not implemented yet. void Add(TObject* obj, Option_t* opt); Add command to the stack of commands.; Command's redo action will be executed. option string can contain the following substrings:; ""merge"" - input command will be merged; ""compress"" - input command will be compressed. void CurrentChanged(TQCommand* c); emit signal. void Undo(Option_t* option = """"); Performs undo action. Move cursor position backward in history stack. void Redo(Option_t* option = """"); Performs redo action. Move cursor position forward in history stack. Bool_t CanRedo() const; Returns kTRUE if redo action is possible. Bool_t CanUndo() const; Returns kTRUE if undo action is possible. Bool_t IsLogging() const; Returns kTRUE if logging is ON. TQCommand * GetCurrent() const; Returns the last executed command. TQCommand * GetCursor() const; Returns a command correspondent to the current cursor position in stack. void SetLimit(UInt_t limit); Returns a maximum number of commands which could be located in stack. UInt_t GetLimit() const; Returns a maximum number of commands which could be located in stack. void Add(TObject* obj, Option_t* opt).  Author: Valeriy Onuchin 04/27/2004  Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *;  Last changed: root/base:$Id$  Last generated: 2015-03-14 16:48; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TQUndoManager.html:19724,log,logging,19724,root/html534/TQUndoManager.html,https://root.cern,https://root.cern/root/html534/TQUndoManager.html,1,['log'],['logging']
Testability,"n; UseNTrainEvents number of training events used in randomised (and bagged) trees; SeparationType the separation criterion applied in the node splitting; known: GiniIndex; MisClassificationError; CrossEntropy; SDivSqrtSPlusB; nEventsMin: the minimum number of events in a node (leaf criteria, stop splitting); nCuts: the number of steps in the optimisation of the cut for a node (if < 0, then; step size is determined by the events); UseFisherCuts: use multivariate splits using the Fisher criterion; UseYesNoLeaf decide if the classification is done simply by the node type, or the S/B; (from the training) in the leaf node; NodePurityLimit the minimum purity to classify a node as a signal node (used in pruning and boosting to determine; misclassification error rate); UseWeightedTrees use average classification from the trees, or have the individual trees; trees in the forest weighted (e.g. log(boostweight) from AdaBoost; PruneMethod The Pruning method:; known: NoPruning // switch off pruning completely; ExpectedError; CostComplexity; PruneStrength a parameter to adjust the amount of pruning. Should be large enough such that overtraining is avoided.; PruneBeforeBoost flag to prune the tree before applying boosting algorithm; PruningValFraction number of events to use for optimizing pruning (only if PruneStrength < 0, i.e. automatic pruning); NegWeightTreatment IgnoreNegWeightsInTraining Ignore negative weight events in the training.; DecreaseBoostWeight Boost ev. with neg. weight with 1/boostweight instead of boostweight; PairNegWeightsGlobal Pair ev. with neg. and pos. weights in traning sample and ""annihilate"" them; PairNegWeightsInNode Randomly pair miscl. ev. with neg. and pos. weights in node and don't boost them; NNodesMax maximum number of nodes allwed in the tree splitting, then it stops.; MaxDepth maximum depth of the decision tree allowed before further splitting is stopped. void DeclareCompatibilityOptions(). void ProcessOptions(); the option string is decoded,",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TMVA__MethodBDT.html:27334,log,log,27334,root/html530/TMVA__MethodBDT.html,https://root.cern,https://root.cern/root/html530/TMVA__MethodBDT.html,2,['log'],['log']
Testability,"n; UseNTrainEvents number of training events used in randomised (and bagged) trees; SeparationType the separation criterion applied in the node splitting; known: GiniIndex; MisClassificationError; CrossEntropy; SDivSqrtSPlusB; nEventsMin: the minimum number of events in a node (leaf criteria, stop splitting); nCuts: the number of steps in the optimisation of the cut for a node (if < 0, then; step size is determined by the events); UseFisherCuts: use multivariate splits using the Fisher criterium; UseYesNoLeaf decide if the classification is done simply by the node type, or the S/B; (from the training) in the leaf node; NodePurityLimit the minimum purity to classify a node as a signal node (used in pruning and boosting to determine; misclassification error rate); UseWeightedTrees use average classification from the trees, or have the individual trees; trees in the forest weighted (e.g. log(boostweight) from AdaBoost; PruneMethod The Pruning method:; known: NoPruning // switch off pruning completely; ExpectedError; CostComplexity; PruneStrength a parameter to adjust the amount of pruning. Should be large enough such that overtraining is avoided.; PruneBeforeBoost flag to prune the tree before applying boosting algorithm; PruningValFraction number of events to use for optimizing pruning (only if PruneStrength < 0, i.e. automatic pruning); IgnoreNegWeightsInTraining Ignore negative weight events in the training.; NNodesMax maximum number of nodes allwed in the tree splitting, then it stops.; MaxDepth maximum depth of the decision tree allowed before further splitting is stopped. void DeclareCompatibilityOptions(). void ProcessOptions(); the option string is decoded, for available options see ""DeclareOptions"". void Init( void ); common initialisation with defaults for the BDT-Method. void Reset( void ); reset the method, as if it had just been instantiated (forget all training etc.). ~MethodBDT( void ); destructor. void InitEventSample( void ); Write all Events from the ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMVA__MethodBDT.html:25929,log,log,25929,root/html528/TMVA__MethodBDT.html,https://root.cern,https://root.cern/root/html528/TMVA__MethodBDT.html,1,['log'],['log']
Testability,"n;; 6293 } else {; 6294 if (Hoption.Logx); 6295 xarr[i] = TMath::Log10(x1 + xlen);; 6296 else; 6297 xarr[i] = x1 + xlen;; 6298 if (Hoption.Logy); 6299 yarr[i] = TMath::Log10(y1);; 6300 else; 6301 yarr[i] = y1;; 6302 }; 6303 itarr[i] = n;; 6304 icount++;; 6305 i +=2;; 6306 n++;; 6307 }; 6308 return icount;; 6309}; 6310 ; 6311////////////////////////////////////////////////////////////////////////////////; 6312/// [Draw 1D histograms error bars.](\ref HP09); 6313 ; 6314void THistPainter::PaintErrors(Option_t *); 6315{; 6316 ; 6317 // On iOS, we do not highlight histogram, if it's not picked at the moment; 6318 // (but part of histogram (axis or pavestat) was picked, that's why this code; 6319 // is called at all. This conditional statement never executes on non-iOS platform.; 6320 if (gPad->PadInHighlightMode() && gPad->GetSelected() != fH) return;; 6321 ; 6322 const Int_t kBASEMARKER=8;; 6323 Double_t xp, yp, ex1, ex2, ey1, ey2;; 6324 Double_t delta;; 6325 Double_t s2x, s2y, bxsize, bysize, symbolsize, xerror, sbasex, sbasey;; 6326 Double_t xi1, xi2, xi3, xi4, yi1, yi2, yi3, yi4;; 6327 Double_t xmin, xmax, ymin, ymax;; 6328 Double_t logxmin = 0;; 6329 Double_t logymin = 0;; 6330 Double_t offset = 0.;; 6331 Double_t width = 0.;; 6332 Int_t i, k, npoints, first, last, fixbin;; 6333 Int_t if1 = 0;; 6334 Int_t if2 = 0;; 6335 Int_t drawmarker, errormarker;; 6336 Int_t option0, option1, option2, option3, option4, optionE, optionEX0, optionI0;; 6337 static Float_t cxx[30] = {1.0,1.0,0.5,0.5,1.0,1.0,0.5,0.6,1.0,0.5,0.5,1.0,0.5,0.6,1.0,1.0,1.0,1.0,1.0,1.0,0.0,0.0,1.0,1.0,1.0,1.0,0.5,0.5,0.5,1.0};; 6338 static Float_t cyy[30] = {1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,0.5,0.5,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,0.0,0.0,1.0,1.0,1.0,1.0,0.5,0.5,0.5,1.0};; 6339 ; 6340 std::vector<Double_t> xline, yline;; 6341 option0 = option1 = option2 = option3 = option4 = optionE = optionEX0 = optionI0 = 0;; 6342 if (Hoption.Error >= 40) {Hoption.Error -=40; option0 = 1;}; 6343 if (Int_t(Hoption.E",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/THistPainter_8cxx_source.html:232558,log,logxmin,232558,doc/master/THistPainter_8cxx_source.html,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html,2,['log'],"['logxmin', 'logymin']"
Testability,"n;; 8070 opt.ToUpper();; 8071 if (opt.Contains(""D"") ) {; 8072 printf("" AndersonDarlingTest Prob = %g, AD TestStatistic = %g\n"",pvalue,advalue);; 8073 }; 8074 if (opt.Contains(""T"") ) return advalue;; 8075 ; 8076 return pvalue;; 8077}; 8078 ; 8079////////////////////////////////////////////////////////////////////////////////; 8080/// Same function as above but returning also the test statistic value; 8081 ; 8082Double_t TH1::AndersonDarlingTest(const TH1 *h2, Double_t & advalue) const; 8083{; 8084 if (GetDimension() != 1 || h2->GetDimension() != 1) {; 8085 Error(""AndersonDarlingTest"",""Histograms must be 1-D"");; 8086 return -1;; 8087 }; 8088 ; 8089 // empty the buffer. Probably we could add as an unbinned test; 8090 if (fBuffer) ((TH1*)this)->BufferEmpty();; 8091 ; 8092 // use the BinData class; 8093 ROOT::Fit::BinData data1;; 8094 ROOT::Fit::BinData data2;; 8095 ; 8096 ROOT::Fit::FillData(data1, this, nullptr);; 8097 ROOT::Fit::FillData(data2, h2, nullptr);; 8098 ; 8099 double pvalue;; 8100 ROOT::Math::GoFTest::AndersonDarling2SamplesTest(data1,data2, pvalue,advalue);; 8101 ; 8102 return pvalue;; 8103}; 8104 ; 8105////////////////////////////////////////////////////////////////////////////////; 8106/// Statistical test of compatibility in shape between; 8107/// this histogram and h2, using Kolmogorov test.; 8108/// Note that the KolmogorovTest (KS) test should in theory be used only for unbinned data; 8109/// and not for binned data as in the case of the histogram (see NOTE 3 below).; 8110/// So, before using this method blindly, read the NOTE 3.; 8111///; 8112/// Default: Ignore under- and overflow bins in comparison; 8113///; 8114/// \param[in] h2 histogram; 8115/// \param[in] option is a character string to specify options; 8116/// - ""U"" include Underflows in test (also for 2-dim); 8117/// - ""O"" include Overflows (also valid for 2-dim); 8118/// - ""N"" include comparison of normalizations; 8119/// - ""D"" Put out a line of ""Debug"" printout; 8120/// - ""M"" Return the Max",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TH1_8cxx_source.html:317092,test,test,317092,doc/master/TH1_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html,3,['test'],['test']
Testability,"n=""""); Performs the operation: this = this + c1*f1 if errors are defined (see TH1::Sumw2), errors are also recalculated. ; ; virtual Double_tAndersonDarlingTest (const TH1 *h2, Double_t &advalue) const; Same function as above but returning also the test statistic value. ; ; virtual Double_tAndersonDarlingTest (const TH1 *h2, Option_t *option="""") const; Statistical test of compatibility in shape between this histogram and h2, using the Anderson-Darling 2 sample test. ; ; voidBrowse (TBrowser *b) override; Browse the Histogram object. ; ; virtual Int_tBufferEmpty (Int_t action=0); Fill histogram with all entries in the buffer. ; ; virtual Bool_tCanExtendAllAxes () const; Returns true if all axes are extendable. ; ; virtual Double_tChi2Test (const TH1 *h2, Option_t *option=""UU"", Double_t *res=nullptr) const; \( \chi^{2} \) test for comparing weighted and unweighted histograms. ; ; virtual Double_tChi2TestX (const TH1 *h2, Double_t &chi2, Int_t &ndf, Int_t &igood, Option_t *option=""UU"", Double_t *res=nullptr) const; The computation routine of the Chisquare test. ; ; virtual Double_tChisquare (TF1 *f1, Option_t *option="""") const; Compute and return the chisquare of this histogram with respect to a function The chisquare is computed by weighting each histogram point by the bin error By default the full range of the histogram is used. ; ; virtual voidClearUnderflowAndOverflow (); Remove all the content from the underflow and overflow bins, without changing the number of entries After calling this method, every undeflow and overflow bins will have content 0.0 The Sumw2 is also cleared, since there is no more content in the bins. ; ; TObject *Clone (const char *newname="""") const override; Make a complete copy of the underlying object. ; ; virtual Double_tComputeIntegral (Bool_t onlyPositive=false); Compute integral (normalized cumulative sum of bins) w/o under/overflows The result is stored in fIntegral and used by the GetRandom functions. ; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTH1C.html:3407,test,test,3407,doc/master/classTH1C.html,https://root.cern,https://root.cern/doc/master/classTH1C.html,6,['test'],['test']
Testability,"n="""", Long64_t nentries=-1, Long64_t firstentry=0) override; Process a data set (TDSet) using the specified selector object. ; ; Long64_tProcess (TFileCollection *fc, const char *sel, Option_t *o="""", Long64_t nent=-1, Long64_t fst=0) override; Process a data set (TFileCollection) using the specified selector (.C) file or TSelector object. ; ; Long64_tProcess (TFileCollection *fc, TSelector *sel, Option_t *o="""", Long64_t nent=-1, Long64_t fst=0) override; Process a data set (TFileCollection) using the specified selector object The default tree is analyzed (i.e. ; ; Long64_tProcess (TSelector *sel, Long64_t nent, Option_t *o="""") override; Generic (non-data based) selector processing: the Process() method of the specified selector is called 'n' times. ; ; voidStreamer (TBuffer &) override; Stream an object of class TObject. ; ; voidStreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b); ; Public Member Functions inherited from TProof; TProof (const char *masterurl, const char *conffile=kPROOF_ConfFile, const char *confdir=kPROOF_ConfDir, Int_t loglevel=0, const char *alias=0, TProofMgr *mgr=0); Create a PROOF environment. ; ; ~TProof () override; Clean up PROOF environment. ; ; Int_tActivateWorker (const char *ord, Bool_t save=kTRUE); Make sure that the worker identified by the ordinal number 'ord' is in the active list. ; ; voidAddChain (TChain *chain); Add chain to data set. ; ; Int_tAddDynamicPath (const char *libpath, Bool_t onClient=kFALSE, TList *wrks=0, Bool_t doCollect=kTRUE); Add 'libpath' to the lib path search. ; ; voidAddFeedback (const char *name); Add object to feedback list. ; ; Int_tAddIncludePath (const char *incpath, Bool_t onClient=kFALSE, TList *wrks=0, Bool_t doCollect=kTRUE); Add 'incpath' to the inc path search. ; ; voidAddInput (TObject *obj); Add objects that might be needed during the processing of the selector (see Process()). ; ; voidAddInputData (TObject *obj, Bool_t push=kFALSE); Add data objects ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProofSuperMaster.html:2723,log,loglevel,2723,doc/master/classTProofSuperMaster.html,https://root.cern,https://root.cern/doc/master/classTProofSuperMaster.html,1,['log'],['loglevel']
Testability,"nBins); Create 1-, 2- or 3-d ROOT histogram with labels taken from the variables in 'vars' and the with range and binning specified in xlo,xhi and nBins. ; ; static const char *DeclFileName (); ; Static Public Member Functions inherited from RooAbsReal; static TClass *Class (); ; static const char *Class_Name (); ; static constexpr Version_tClass_Version (); ; static voidclearEvalErrorLog (); Clear the stack of evaluation error messages. ; ; static const char *DeclFileName (); ; static RooNumIntConfig *defaultIntegratorConfig (); Returns the default numeric integration configuration for all RooAbsReals. ; ; static std::map< constRooAbsArg *, std::pair< std::string, std::list< RooAbsReal::EvalError > > >::iteratorevalErrorIter (); ; static ErrorLoggingModeevalErrorLoggingMode (); Return current evaluation error logging mode. ; ; static boolhideOffset (); ; static voidlogEvalError (const RooAbsReal *originator, const char *origName, const char *message, const char *serverValueString=nullptr); Interface to insert remote error logging messages received by RooRealMPFE into current error logging stream. ; ; static Int_tnumEvalErrorItems (); ; static Int_tnumEvalErrors (); Return the number of logged evaluation errors since the last clearing. ; ; static voidprintEvalErrors (std::ostream &os=std::cout, Int_t maxPerNode=10000000); Print all outstanding logged evaluation error on the given ostream. ; ; static voidsetEvalErrorLoggingMode (ErrorLoggingMode m); Set evaluation error logging mode. ; ; static voidsetHideOffset (bool flag); ; Static Public Member Functions inherited from RooAbsArg; static voidsetDirtyInhibit (bool flag); Control global dirty inhibit mode. ; ; static voidverboseDirty (bool flag); Activate verbose messaging related to dirty flag propagation. ; ; Static Public Member Functions inherited from TNamed; static TClass *Class (); ; static const char *Class_Name (); ; static constexpr Version_tClass_Versi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooErrorVar.html:54915,log,logEvalError,54915,doc/master/classRooErrorVar.html,https://root.cern,https://root.cern/doc/master/classRooErrorVar.html,12,['log'],"['logEvalError', 'logging']"
Testability,"nDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Float_tfCarry; Int_tfCount24; Float_tfFloatSeedTable[24]; Int_tfIlag; const Int_tfIntModulus; Int_tfJlag; Int_tfLuxury; const Double_tfMantissaBit12; const Double_tfMantissaBit24; TStringTNamed::fNameobject identifier; Int_tfNskip; UInt_tTRandom::fSeedRandom number generator seed; const UInt_t*fTheSeeds; TStringTNamed::fTitleobject title; static Int_tfgMaxIndex; static Int_tfgNumEngines. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TRandom1(UInt_t seed, Int_t lux = 3); Luxury level is set in the same way as the original FORTRAN routine.; level 0 (p=24): equivalent to the original RCARRY of Marsaglia; and Zaman, very long period, but fails many tests.; level 1 (p=48): considerable improvement in quality over level 0,; now passes the gap test, but still fails spectral test.; level 2 (p=97): passes all known tests, but theoretically still; defective.; level 3 (p=223): DEFAULT VALUE. Any theoretically possible; correlations have very small chance of being observed.; level 4 (p=389): highest possible luxury, all 24 bits chaotic. TRandom1(); default constructor. TRandom1(Int_t rowIndex, Int_t colIndex, Int_t lux); constructor. ~TRandom1(); destructor. void GetTableSeeds(UInt_t* seeds, Int_t index); static function returning the table of seeds. Double_t Rndm(Int_t i = 0); return a random number in ]0,1]. void RndmArray(Int_t size, Float_t* vect); return an array of random numbers in ]0,1]. void RndmArray(Int_t size, Double_t* vect); return an array of random numbers in ]0,1[. void SetSeeds(const UInt_t* seeds, Int_t lux = 3); set seeds. void SetSeed2(UInt_t seed, Int_t lux = 3); The initialisation is carried out using a Multiplicative; Congruential generator using formula constants of L'Ecuyer; as ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TRandom1.html:7954,test,test,7954,root/html534/TRandom1.html,https://root.cern,https://root.cern/root/html534/TRandom1.html,2,['test'],['test']
Testability,"nDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Float_tfCarry; Int_tfCount24; Float_tfFloatSeedTable[24]; Int_tfIlag; const Int_tfIntModulus; Int_tfJlag; Int_tfLuxury; const Double_tfMantissaBit12; const Double_tfMantissaBit24; TStringTNamed::fNameobject identifier; Int_tfNskip; UInt_tTRandom::fSeedRandom number generator seed; const UInt_t*fTheSeeds; TStringTNamed::fTitleobject title; static Int_tfgMaxIndex; static Int_tfgNumEngines. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TRandom1(UInt_t seed, Int_t lux = 3); Luxury level is set in the same way as the original FORTRAN routine.; level 0 (p=24): equivalent to the original RCARRY of Marsaglia; and Zaman, very long period, but fails many tests.; level 1 (p=48): considerable improvement in quality over level 0,; now passes the gap test, but still fails spectral test.; level 2 (p=97): passes all known tests, but theoretically still; defective.; level 3 (p=223): DEFAULT VALUE. Any theoretically possible; correlations have very small chance of being observed.; level 4 (p=389): highest possible luxury, all 24 bits chaotic. TRandom1(); default constructor. TRandom1(Int_t rowIndex, Int_t colIndex, Int_t lux); constructor. ~TRandom1(); destructor. void GetTableSeeds(UInt_t* seeds, Int_t index); static function returning the table of seeds. Double_t Rndm(Int_t i = 0); return a random number in ]0,1]. void RndmArray(Int_t size, Float_t* vect); return an array of random numbers in ]0,1]. void RndmArray(Int_t size, Double_t* vect); return an array of random numbers in ]0,1]. void SetSeeds(const UInt_t* seeds, Int_t lux = 3); set seeds. void SetSeed2(UInt_t seed, Int_t lux = 3); The initialisation is carried out using a Multiplicative; Congruential generator using formula constants of L'Ecuyer; as ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TRandom1.html:7875,test,test,7875,root/html528/TRandom1.html,https://root.cern,https://root.cern/root/html528/TRandom1.html,6,['test'],['test']
Testability,nHolder.cxx; TFunctionHolder.h; TMemoryRegulator.cxx; TMemoryRegulator.h; TMethodHolder.cxx; TMethodHolder.h; TPyArg.cxx; TPyBufferFactory.cxx; TPyBufferFactory.h; TPyClassGenerator.cxx; TPyClassGenerator.h; TPyDispatcher.cxx; TPyException.cxx; TPyFitFunction.cxx; TPyReturn.cxx; TPyROOTApplication.cxx; TPySelector.cxx; TPython.cxx; TSetItemHolder.cxx; TSetItemHolder.h; TTupleOfInstances.cxx; TTupleOfInstances.h; Utility.cxx; Utility.h; _pythonization.py; cppyy.py; ROOT.py; r; inc; LinkDef.h; RExports.h; TRDataFrame.h; TRDataFrame__ctors.h; TRFunctionExport.h; TRFunctionImport.h; TRFunctionImport__oprtr.h; TRInterface.h; TRInterface_Binding.h; TRInternalFunction.h; TRInternalFunction__ctors.h; TRObject.h; pkg; ROOT; src; Core.cxx; Graf.cxx; Hist.cxx; Rint.cxx; RIO.cxx; src; RExports.cxx; TRCompletion.cxx; TRCompletion.h; TRDataFrame.cxx; TRFunctionExport.cxx; TRFunctionImport.cxx; TRInterface.cxx; TRObject.cxx; tests; Binding.C; Class.C; DataFrame.C; Exception.C; ExpClass.C; Functions.C; Functor.C; FunModule.C; Object.C; Proxy.C; ROOTR.C; ruby; inc; LinkDef.h; TRuby.h; src; drr.cxx; rrcommon.h; rrenums.h; ruby64.c; TRuby.cxx; core; base; doc; macros; fillpatterns.C; fonts.C; textalign.C; textangle.C; inc; ROOT; StringConv.h; Bswapcpy.h; Buttons.h; Bytes.h; Byteswap.h; config.h; DllImport.h; GLConstants.h; Gtypes.h; GuiTypes.h; Htypes.h; KeySymbols.h; LinkDef.h; LinkDef1.h; LinkDef2.h; LinkDef3.h; Match.h; MessageTypes.h; RConfig.h; Riosfwd.h; Riostream.h; Rpair.h; RQ_OBJECT.h; RStipples.h; Rstrstream.h; Rtypeinfo.h; Rtypes.h; RtypesCore.h; RtypesImp.h; RVersion.h; Strlen.h; TApplication.h; TApplicationImp.h; TAtt3D.h; TAttAxis.h; TAttBBox.h; TAttBBox2D.h; TAttFill.h; TAttLine.h; TAttMarker.h; TAttPad.h; TAttText.h; TBase64.h; TBenchmark.h; TBrowser.h; TBrowserImp.h; TBuffer.h; TBuffer3D.h; TBuffer3DT,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html606/files.html:2330,test,tests,2330,root/html606/files.html,https://root.cern,https://root.cern/root/html606/files.html,1,['test'],['tests']
Testability,"nLevel() constDefinition TFile.h:391; TFile::GetENDvirtual Long64_t GetEND() constDefinition TFile.h:231; TFile::WriteStreamerInfovirtual void WriteStreamerInfo()Write the list of TStreamerInfo as a single object in this file The class Streamer description for al...Definition TFile.cxx:3792; TFile::kDoNotDisconnect@ kDoNotDisconnectDefinition TFile.h:70; TFile::Flushvirtual void Flush()Synchronize a file's in-memory and on-disk states.Definition TFile.cxx:1141; TFile::MakeFreevirtual void MakeFree(Long64_t first, Long64_t last)Mark unused bytes on the file.Definition TFile.cxx:1484; TFile::Openstatic TFile * Open(const char *name, Option_t *option="""", const char *ftitle="""", Int_t compress=ROOT::RCompressionSetting::EDefaults::kUseCompiledDefault, Int_t netopt=0)Create / open a file.Definition TFile.cxx:4089; TFile::WriteHeadervirtual void WriteHeader()Write File Header.Definition TFile.cxx:2615; TFile::GetRecordHeaderInt_t GetRecordHeader(char *buf, Long64_t first, Int_t maxbytes, Int_t &nbytes, Int_t &objlen, Int_t &keylen)Read the logical record header starting at a certain postion.Definition TFile.cxx:1301; TFile::GetCacheReadTFileCacheRead * GetCacheRead(const TObject *tree=nullptr) constReturn a pointer to the current read cache.Definition TFile.cxx:1262; TFolder<div class=""legacybox""><h2>Legacy Code</h2> TFolder is a legacy interface: there will be no bug fixes...Definition TFolder.h:30; TFolder::GetListOfFoldersTCollection * GetListOfFolders() constDefinition TFolder.h:55; TFolder::Occurencevirtual Int_t Occurence(const TObject *obj) constReturn occurence number of object in the list of objects of this folder.Definition TFolder.cxx:427; TFolder::Classstatic TClass * Class(); TFriendElementA TFriendElement TF describes a TTree object TF in a file.Definition TFriendElement.h:33; TFriendElement::ResetUpdatedvoid ResetUpdated()Definition TFriendElement.h:68; TFriendElement::kFromChain@ kFromChainDefinition TFriendElement.h:49; TFriendElement::GetTreeNamevirtual c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTree_8cxx_source.html:413072,log,logical,413072,doc/master/TTree_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html,1,['log'],['logical']
Testability,"nSum::fSumT fSum[N]Definition Util.h:315; ROOT::Math::KahanSum::KahanSumKahanSum(T initialValue=T{})Initialise the sum.Definition Util.h:126; ROOT::Math::KahanSum::KahanSumKahanSum(T initialSumValue, T initialCarryValue)Initialise with a sum value and a carry value.Definition Util.h:135; ROOT::Math::KahanSum::Addvoid Add(T x)Single-element accumulation. Will not vectorise.Definition Util.h:165; ROOT::Math::KahanSum::operator-=KahanSum< T, N > & operator-=(KahanSum< U, M > const &other)Subtract other KahanSum.Definition Util.h:290; ROOT::Math::KahanSum::KahanSumKahanSum(Iterator sumBegin, Iterator sumEnd, Iterator carryBegin, Iterator carryEnd)Initialise the sum with a pre-existing state.Definition Util.h:148; yDouble_t y[n]Definition legend1.C:17; xDouble_t x[n]Definition legend1.C:17; nconst Int_t nDefinition legend1.C:16; MathNamespace for new Math classes and functions.; ROOT::MacOSX::UtilDefinition CocoaUtils.h:22; ROOT::Math::Util::EvalLogT EvalLog(T x)safe evaluation of log(x) with a protections against negative or zero argument to the log smooth line...Definition Util.h:64; ROOT::Math::Util::ToStringstd::string ToString(const T &val)Utility function for conversion to strings.Definition Util.h:50; ROOT::Math::operator+DisplacementVector2D< CoordSystem1, U > operator+(DisplacementVector2D< CoordSystem1, U > v1, const DisplacementVector2D< CoordSystem2, U > &v2)Addition of DisplacementVector2D vectors.Definition DisplacementVector2D.h:440; ROOT::Math::operator-DisplacementVector2D< CoordSystem1, U > operator-(DisplacementVector2D< CoordSystem1, U > v1, DisplacementVector2D< CoordSystem2, U > const &v2)Difference between two DisplacementVector2D vectors.Definition DisplacementVector2D.h:453; ROOTtbb::task_arena is an alias of tbb::interface7::task_arena, which doesn't allow to forward declare tb...Definition EExecutionPolicy.hxx:4; Types.h; sumstatic uint64_t sum(uint64_t i)Definition Factory.cxx:2345. mathmathcoreincMathUtil.h. ROOT master - Reference Guide Gener",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/Util_8h_source.html:17484,log,log,17484,doc/master/Util_8h_source.html,https://root.cern,https://root.cern/doc/master/Util_8h_source.html,2,['log'],['log']
Testability,"nTGLViewer::fPushAction; TGLRedrawTimer*TGLViewer::fRedrawTimer! timer for triggering redraws; Bool_tTGLViewer::fReferenceOn! reference marker on?; TGLVertex3TGLViewer::fReferencePos! reference position; Bool_tTGLViewer::fResetCamerasOnNextUpdatereposition camera on next update; Bool_tTGLViewer::fResetCamerasOnUpdatereposition camera on each update; Bool_tTGLViewerBase::fResetSceneInfosOnRenderRequest rebuild of view-specific scene data.; TGLRnrCtx*TGLViewerBase::fRnrCtx; TGLViewerBase::SceneInfoList_tTGLViewerBase::fScenesRegistered scenes.; TGLSelectRecordTGLViewer::fSecSelRec! select record from last secondary select (should go to context); TGLSelectRecordTGLViewer::fSelRec! select record from last select (should go to context); TGLManipSet*TGLViewer::fSelectedPShapeRef!; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; Bool_tTGLViewer::fSmartRefresh! cache logicals during scene rebuilds; Bool_tTGLViewer::fSmoothLines! smooth line edge rendering; Bool_tTGLViewer::fSmoothPoints! smooth point edge rendering; Bool_tTGLViewer::fStereo! use stereo rendering; Float_tTGLViewer::fStereoEyeOffsetFac!; Float_tTGLViewer::fStereoFrustumAsymFac!; Bool_tTGLViewer::fStereoQuadBuf! draw quad buffer or left/right stereo in left/right half of window; Float_tTGLViewer::fStereoZeroParallax! position of zero-parallax plane: 0 - near clipping plane, 1 - far clipping plane; Short_tTGLViewerBase::fStyleViewer-style for rendering.; TGLRectTGLViewer::fViewport! viewport - drawn area; TGLViewerBase::SceneInfoVec_tTGLViewerBase::fVisScenesVisible scenes.; Float_tTGLViewerBase::fWFLineWOptional override of scene wire-frame line-width; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static TGLColorSetTGLViewer::fgDefaultColorSet! a shared, default color-set; static Bool_tTGLViewer::fgUseDefaultColorSetForNewViewers! name says it all. private:. Int_tfBorder; TGCompositeFrame*fFrame. Class Charts. Inheritance; Inherited Members; Includes;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TGLEmbeddedViewer.html:25241,log,logicals,25241,root/html604/TGLEmbeddedViewer.html,https://root.cern,https://root.cern/root/html604/TGLEmbeddedViewer.html,1,['log'],['logicals']
Testability,"nTGLViewer::fPushAction; TGLRedrawTimer*TGLViewer::fRedrawTimer! timer for triggering redraws; Bool_tTGLViewer::fReferenceOn! reference marker on?; TGLVertex3TGLViewer::fReferencePos! reference position; Bool_tTGLViewer::fResetCamerasOnNextUpdatereposition camera on next update; Bool_tTGLViewer::fResetCamerasOnUpdatereposition camera on each update; Bool_tTGLViewerBase::fResetSceneInfosOnRenderRequest rebuild of view-specific scene data.; TGLRnrCtx*TGLViewerBase::fRnrCtx; TGLViewerBase::SceneInfoList_tTGLViewerBase::fScenesRegistered scenes.; TGLSelectRecordTGLViewer::fSecSelRec! select record from last secondary select (should go to context); TGLSelectRecordTGLViewer::fSelRec! select record from last select (should go to context); TGLManipSet*TGLViewer::fSelectedPShapeRef!; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; Bool_tTGLViewer::fSmartRefresh! cache logicals during scene rebuilds; Bool_tTGLViewer::fSmoothLines! smooth line edge rendering; Bool_tTGLViewer::fSmoothPoints! smooth point edge rendering; Bool_tTGLViewer::fStereo! use stereo rendering; Float_tTGLViewer::fStereoEyeOffsetFac!; Float_tTGLViewer::fStereoFrustumAsymFac!; Bool_tTGLViewer::fStereoQuadBuf! draw quad buffer or left/right stereo in left/right half of window; Float_tTGLViewer::fStereoZeroParallax! position of zero-parallax plane: 0 - near clipping plane, 1 - far clipping plane; Short_tTGLViewerBase::fStyleViewer-style for rendering.; TGLRectTGLViewer::fViewport! viewport - drawn area; TGLViewerBase::SceneInfoVec_tTGLViewerBase::fVisScenesVisible scenes.; Float_tTGLViewerBase::fWFLineWOptional override of scene wire-frame line-width; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static TGLColorSetTGLViewer::fgDefaultColorSet! a shared, default color-set; static Bool_tTGLViewer::fgUseDefaultColorSetForNewViewers! name says it all. private:. TGPopupMenu*fCameraMenu; Bool_tfDeleteMenuBar; TStringfDirName; TGPopupMenu*fFileMenu; TGPopup",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TGLSAViewer.html:26617,log,logicals,26617,root/html604/TGLSAViewer.html,https://root.cern,https://root.cern/root/html604/TGLSAViewer.html,1,['log'],['logicals']
Testability,"nUpClicked (); Move selected package entry one position up in the list. ; ; voidOnBtnUploadDSet (); Open Upload Dataset dialog. ; ; voidOnBtnVerifyDSet (); Verify that the files in the selected dataset are present on the cluster. ; ; voidOnClearPackages (); Clear (disable) all packages in the current session. ; ; voidOnCommandLine (); Command line handling. ; ; voidOnDisablePackages (); Disable selected package(s) in the current session. ; ; voidOnEnablePackages (); Enable selected package(s) in the current session. ; ; voidOnMultipleSelection (Bool_t on); Handle multiple selection check button. ; ; voidOnStartupEnable (Bool_t on); Handle multiple selection check button. ; ; voidOnUploadPackages (); Upload selected package(s) to the current session. ; ; voidProofInfos (); Display information on current session. ; ; voidSetLocal (Bool_t local=kTRUE); Switch widgets status/visibility for local/remote sessions. ; ; voidSetLogLevel (Int_t log); ; voidShutdownSession (); Shutdown current session. ; ; voidStreamer (TBuffer &) override; Stream an object of class TObject. ; ; voidStreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b); ; voidUpdateListOfDataSets (); Update list of dataset present on the cluster. ; ; voidUpdatePackages (); Update list of packages. ; ; Public Member Functions inherited from TGCompositeFrame; TGCompositeFrame (const TGWindow *p=nullptr, UInt_t w=1, UInt_t h=1, UInt_t options=0, Pixel_t back=GetDefaultFrameBackground()); Create a composite frame. ; ; TGCompositeFrame (TGClient *c, Window_t id, const TGWindow *parent=nullptr); Create a frame using an externally created window. ; ; ~TGCompositeFrame () override; Delete a composite frame. ; ; virtual voidAddFrame (TGFrame *f, TGLayoutHints *l=nullptr); Add frame to the composite frame using the specified layout hints. ; ; voidChangeOptions (UInt_t options) override; Change composite frame options. Options is an OR of the EFrameTypes",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSessionFrame.html:2477,log,log,2477,doc/master/classTSessionFrame.html,https://root.cern,https://root.cern/doc/master/classTSessionFrame.html,1,['log'],['log']
Testability,nWrapper.h; GSLMultiMinFunctionAdapter.h; GSLMultiMinFunctionWrapper.h; GSLMultiMinimizer.h; GSLMultiRootFinder.cxx; GSLMultiRootFunctionAdapter.h; GSLMultiRootFunctionWrapper.h; GSLMultiRootSolver.h; GSLNLSMinimizer.cxx; GSLQRngWrapper.h; GSLQuasiRandom.cxx; GSLRndmEngines.cxx; GSLRngWrapper.h; GSLRootFdFSolver.h; GSLRootFinder.cxx; GSLRootFinderDeriv.cxx; GSLRootFSolver.h; GSLRootHelper.cxx; GSLSimAnMinimizer.cxx; GSLSimAnnealing.cxx; Interpolator.cxx; KelvinFunctions.cxx; MCParameters.cxx; MultiNumGradFunction.cxx; PdfFuncMathMore.cxx; Polynomial.cxx; QuantFuncMathMore.cxx; RootFinderAlgorithms.cxx; SpecFuncMathMore.cxx; Vavilov.cxx; VavilovAccurate.cxx; VavilovAccurateCdf.cxx; VavilovAccuratePdf.cxx; VavilovAccurateQuantile.cxx; VavilovFast.cxx; zsolve_cubic.cxx; test; piRandom.C; pirndm.C; simanTSP.cxx; testChebyshev.cxx; testDerivation.cxx; testFunctor.cxx; testGSLIntegration.cxx; testGSLRootFinder.cxx; testInterpolation.cxx; testMCIntegration.cxx; testMinimization1D.cxx; testMultiRootFinder.cxx; testPermute.cxx; testQuasiRandom.cxx; testRandom.cxx; testRandomDist.cxx; testSpecFunc.cxx; testStatFunc.cxx; testVavilov.cxx; UnuRanDist.h; VavilovTest.cxx; VavilovTest.h; matrix; inc; LinkDef.h; TDecompBase.h; TDecompBK.h; TDecompChol.h; TDecompLU.h; TDecompQRH.h; TDecompSparse.h; TDecompSVD.h; TMatrix.h; TMatrixD.h; TMatrixDBase.h; TMatrixDBasefwd.h; TMatrixDEigen.h; TMatrixDfwd.h; TMatrixDLazy.h; TMatrixDSparse.h; TMatrixDSparsefwd.h; TMatrixDSym.h; TMatrixDSymEigen.h; TMatrixDSymfwd.h; TMatrixDUtils.h; TMatrixDUtilsfwd.h; TMatrixF.h; TMatrixFBase.h; TMatrixFBasefwd.h; TMatrixFfwd.h; TMatrixFLazy.h; TMatrixFSparse.h; TMatrixFSparsefwd.h; TMatrixFSym.h; TMatrixFSymfwd.h; TMatrixFUtils.h; TMatrixFUtilsfwd.h; TMatrixT.h; TMatrixTBase.h; TMatrixTCramerInv.h; TMatrixTLazy.h; TMatrixTSparse.h; TMatrixTSym.h; TMatrixTSymCramerInv.h; TMatrixTUtils.h; TVector.h; TVe,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html606/files.html:48912,test,testMCIntegration,48912,root/html606/files.html,https://root.cern,https://root.cern/root/html606/files.html,1,['test'],['testMCIntegration']
Testability,"n] = n%3;; sign[n] = i%2;; px[n] = gRandom->Gaus(0,1);; py[n] = gRandom->Gaus(0,2);; pz[n] = gRandom->Gaus(10,5);; zv[n] = gRandom->Gaus(100,2);; chi2[n] = gRandom->Gaus(0,.01);; sumstat += chi2[n];; pt[n] = TMath::Sqrt(px[n]*px[n] + py[n]*py[n]);; }; t3->Fill();; t3f->Fill();; }; // Write the two files; t3->Print();; f.cd();; t3->Write();; fr.cd();; t3f->Write();; }. // Function to read the two files and add the friend; void tree3r() {; TFile *f = new TFile(""tree3.root"");; TTree *t3 = (TTree*)f->Get(""t3"");; // Add the second tree to the first tree as a friend; t3->AddFriend(""t3f"",""tree3f.root"");; // Draw pz which is in the first tree and use pt; // in the condition. pt is in the friend tree.; t3->Draw(""pz"",""pt>3"");; }. // This is executed when typing .x tree3.C; void tree3() {; tree3w();; tree3r();; }; 12.17 Example 4: A Tree with an Event Class; This example is a simplified version of $ROOTSYS/test/MainEvent.cxx and where Event objects are saved in a tree. The full definition of Event is in $ROOTSYS/test/Event.h. To execute this macro, you will need the library $ROOTSYS/test/libEvent.so. If it does not exist you can build the test directory applications by following the instruction in the $ROOTSYS/test/README file.; In this example we will show. the difference in splitting or not splitting a branch; how to read selected branches of the tree,; how to print a selected entry. 12.17.1 The Event Class; Event is a descendent of TObject. As such it inherits the data members of TObject and its methods such as Dump() and Inspect()andWrite(). In addition, because it inherits from TObject it can be a member of a collection. To summarize, the advantages of inheriting from a TObject are:. Inherit the Write, Inspect, and Dump methods; Enables a class to be a member of a ROOT collection; Enables RTTI. Below is the list of the Event data members. It contains a character array, several integers, a floating-point number, and an EventHeader object. The EventHeader class is described",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:574872,test,test,574872,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['test'],['test']
Testability,n_CutsD.class.C; TMVAClassification_FDA_GA.class.C; TMVAClassification_KNN.class.C; TMVAClassification_LD.class.C; TMVAClassification_Likelihood.class.C; TMVAClassification_LikelihoodPCA.class.C; TMVAClassification_MLPBNN.class.C; TMVAClassification_PDEFoam.class.C; TMVAClassification_PDERS.class.C; TMVAClassification_RuleFit.class.C; TMVAClassification_SVM.class.C; TMVAClassificationCategory_Fisher.class.C; TMVAClassificationCategory_Likelihood.class.C; TMVACrossValidation_BDTG.class.C; TMVACrossValidation_BDTG_fold1.class.C; TMVACrossValidation_BDTG_fold2.class.C; TMVACrossValidation_Fisher.class.C; TMVACrossValidation_Fisher_fold1.class.C; TMVACrossValidation_Fisher_fold2.class.C; TMVAMulticlass_BDTG.class.C; TMVAMulticlass_MLP.class.C; datasetBkg0; weights; TMVAMultiBkg0_BDTG.class.C; datasetBkg1; weights; TMVAMultiBkg1_BDTG.class.C; datasetBkg2; weights; TMVAMultiBkg2_BDTG.class.C; MDF.C; pca.C; RooCFAuto000Pdf.cxx; RooCFAuto000Pdf.h; test.py; geom; gdml; inc; TGDMLParse.h; TGDMLWrite.h; src; TGDMLParse.cxx; TGDMLWrite.cxx; ROOTwriter.py; writer.py; geocad; inc; TGeoToOCC.h; TGeoToStep.h; TOCCToStep.h; src; TGeoToOCC.cxx; TGeoToStep.cxx; TOCCToStep.cxx; geom; inc; LinkDef1.h; LinkDef2.h; TGeoArb8.h; TGeoAtt.h; TGeoBBox.h; TGeoBoolNode.h; TGeoBranchArray.h; TGeoBuilder.h; TGeoCache.h; TGeoCompositeShape.h; TGeoCone.h; TGeoElement.h; TGeoEltu.h; TGeoExtension.h; TGeoGlobalMagField.h; TGeoHalfSpace.h; TGeoHelix.h; TGeoHype.h; TGeoManager.h; TGeoMaterial.h; TGeoMatrix.h; TGeoMedium.h; TGeoNavigator.h; TGeoNode.h; TGeoPara.h; TGeoParaboloid.h; TGeoParallelWorld.h; TGeoPatternFinder.h; TGeoPcon.h; TGeoPgon.h; TGeoPhysicalConstants.h; TGeoPhysicalNode.h; TGeoPolygon.h; TGeoRCPtr.h; TGeoRegion.h; TGeoScaledShape.h; TGeoShape.h; TGeoShapeAssembly.h; TGeoSphere.h; TGeoStateInfo.h; TGeoSystemOfUnits.h; TGeoTorus.h; TGeoTrd1.h; TGeoTrd2.h; TGeoTu,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v614/files.html:11515,test,test,11515,doc/v614/files.html,https://root.cern,https://root.cern/doc/v614/files.html,1,['test'],['test']
Testability,"n_in->Draw(""""); ; }; ; . Int_t SearchHighRes(const Double_t*** source, Double_t*** dest, Int_t ssizex, Int_t ssizey, Int_t ssizez, Double_t sigma, Double_t threshold, Bool_t backgroundRemove, Int_t deconIterations, Bool_t markov, Int_t averWindow). THREE-DIMENSIONAL HIGH-RESOLUTION PEAK SEARCH FUNCTION; This function searches for peaks in source spectrum; It is based on deconvolution method. First the background is; removed (if desired), then Markov spectrum is calculated; (if desired), then the response function is generated; according to given sigma and deconvolution is carried out.; It returns number of found peaks. Function parameters:; source-pointer to the matrix of source spectrum; dest-pointer to the matrix of resulting deconvolved spectrum; ssizex-x length of source spectrum; ssizey-y length of source spectrum; ssizez-z length of source spectrum; sigma-sigma of searched peaks, for details we refer to manual; threshold-threshold value in % for selected peaks, peaks with; amplitude less than threshold*highest_peak/100; are ignored, see manual; backgroundRemove-logical variable, set if the removal of; background before deconvolution is desired; deconIterations-number of iterations in deconvolution operation; markov-logical variable, if it is true, first the source spectrum; is replaced by new spectrum calculated using Markov; chains method.; averWindow-averanging window of searched peaks, for details; we refer to manual (applies only for Markov method). . Peaks searching; ; Goal: to identify; automatically the peaks in spectrum with the presence of the continuous; background, one- and two-fold coincidences (ridges) and statistical; fluctuations - noise. ; ; The common problems connected; with correct peak identification in three-dimensional coincidence spectra are. non-sensitivity to noise, i.e.,; only statistically relevant peaks should be identified; non-sensitivity of the; algorithm to continuous background; non-sensitivity to one-fold coincidences; (c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TSpectrum3.html:31592,log,logical,31592,root/html602/TSpectrum3.html,https://root.cern,https://root.cern/root/html602/TSpectrum3.html,4,['log'],['logical']
Testability,"n_t *option=""h""); Set option(s) to draw axis with labels option can be: ; ; TAxis &operator= (const TAxis &); Assignment operator. ; ; voidRotateTitle (Bool_t rotate=kTRUE); Rotate title by 180 degrees. ; ; voidSaveAttributes (std::ostream &out, const char *name, const char *subname) override; Save axis attributes as C++ statement(s) on output stream out. ; ; voidSetAlphanumeric (Bool_t alphanumeric=kTRUE); Set axis alphanumeric. ; ; virtual voidSetBinLabel (Int_t bin, const char *label); Set label for bin. ; ; voidSetCanExtend (Bool_t canExtend); ; voidSetDecimals (Bool_t dot=kTRUE); Sets the decimals flag By default, blank characters are stripped, and then the label is correctly aligned. ; ; virtual voidSetDefaults (); Set axis default values (from TStyle) ; ; voidSetDrawOption (Option_t *="""") override; Set drawing option for object. ; ; virtual voidSetLimits (Double_t xmin, Double_t xmax); ; voidSetMoreLogLabels (Bool_t more=kTRUE); Set the kMoreLogLabels bit flag When this option is selected more labels are drawn when in log scale and there is a small number of decades (<3). ; ; voidSetNoAlphanumeric (Bool_t noalpha=kTRUE); ; voidSetNoExponent (Bool_t noExponent=kTRUE); Set the NoExponent flag By default, an exponent of the form 10^N is used when the label value are either all very small or very large. ; ; virtual voidSetParent (TObject *obj); ; virtual voidSetRange (Int_t first=0, Int_t last=0); Set the viewing range for the axis using bin numbers. ; ; virtual voidSetRangeUser (Double_t ufirst, Double_t ulast); Set the viewing range for the axis from ufirst to ulast (in user coordinates, that is, the ""natural"" axis coordinates). ; ; virtual voidSetTicks (Option_t *option=""+""); Set ticks orientation. ; ; virtual voidSetTimeDisplay (Int_t value); ; virtual voidSetTimeFormat (const char *format=""""); Change the format used for time plotting. ; ; virtual voidSetTimeOffset (Double_t toffset, Option_t *option=""loca",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classAxis2.html:6390,log,log,6390,doc/master/classAxis2.html,https://root.cern,https://root.cern/doc/master/classAxis2.html,1,['log'],['log']
Testability,"n_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooAbsMoment*RooAbsReal::mean(RooRealVar& obs); RooAbsMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; virtual Bool_tTObject::Notify(); Int_tnumBins() const; Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TNamed&TNamed::operator=(const TNamed& rhs); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& te",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/ParamHistFunc.html:19111,test,testArg,19111,root/html534/ParamHistFunc.html,https://root.cern,https://root.cern/root/html534/ParamHistFunc.html,1,['test'],['testArg']
Testability,"n_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooAbsMoment*RooAbsReal::mean(RooRealVar& obs); RooAbsMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; virtual Bool_tTObject::Notify(); Int_tnumBins() const; Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); ParamHistFunc&operator=(const ParamHistFunc&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/ParamHistFunc.html:18799,test,testArg,18799,root/html602/ParamHistFunc.html,https://root.cern,https://root.cern/root/html602/ParamHistFunc.html,2,['test'],['testArg']
Testability,"n_tClass_Version (); ; static const char *DeclFileName (); ; Static Public Member Functions inherited from TObject; static TClass *Class (); ; static const char *Class_Name (); ; static constexpr Version_tClass_Version (); ; static const char *DeclFileName (); ; static Longptr_tGetDtorOnly (); Return destructor only flag. ; ; static Bool_tGetObjectStat (); Get status of object stat flag. ; ; static voidSetDtorOnly (void *obj); Set destructor only flag. ; ; static voidSetObjectStat (Bool_t stat); Turn on/off tracking of objects in the TObjectTable. ; . Private Member Functions; UInt_tGetEntries (const std::vector< TreeInfo > &tiV) const; return number of entries in tree ; ; MsgLogger &Log () const; ; TTree *ReadInputTree (const TString &dataFile); create trees from these ascii files ; . Private Attributes; std::map< std::string, Bool_t >fExplicitTrainTest; if set to true the user has specified training and testing data explicitly ; ; std::map< TString, std::vector< TreeInfo > >fInputTrees; list of input trees per class (classname is given as first parameter in the map) ; ; MsgLogger *fLogger; ! message logger ; . Additional Inherited Members; Public Types inherited from TObject; enum { ; kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ; kBitMask = 0x00ffffff. }; ; enum { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); }; ; enum EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); }; ; enum EStatusBits { ; kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ; kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). }; ; Protected Types inherited from TObject; enum { kOnlyPrepStep = (1ULL << ( 3 )); }; ; Protected Member Functions inherited from TObject; virtual voidDoError",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1DataInputHandler.html:11656,test,testing,11656,doc/master/classTMVA_1_1DataInputHandler.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1DataInputHandler.html,2,"['log', 'test']","['logger', 'testing']"
Testability,"na Kreshuk.; Incorporates the suggested changes in AS R85 (vol.40(1), pp.233-5, 1991); Parameters:; p - the probability value, at which the quantile is computed; ndf - number of degrees of freedom. Double_t FDist(Double_t F, Double_t N, Double_t M); Computes the density function of F-distribution; (probability function, integral of density, is computed in FDistI). Parameters N and M stand for degrees of freedom of chi-squares; mentioned above parameter F is the actual variable x of the; density function p(x) and the point at which the density function; is calculated. About F distribution:; F-distribution arises in testing whether two random samples; have the same variance. It is the ratio of two chi-square; distributions, with N and M degrees of freedom respectively,; where each chi-square is first divided by it's number of degrees; of freedom.; Implementation by Anna Kreshuk. Double_t FDistI(Double_t F, Double_t N, Double_t M); Calculates the cumulative distribution function of F-distribution,; this function occurs in the statistical test of whether two observed; samples have the same variance. For this test a certain statistic F,; the ratio of observed dispersion of the first sample to that of the; second sample, is calculated. N and M stand for numbers of degrees; of freedom in the samples 1-FDistI() is the significance level at; which the hypothesis ""1 has smaller variance than 2"" can be rejected.; A small numerical value of 1 - FDistI() implies a very significant; rejection, in turn implying high confidence in the hypothesis; ""1 has variance greater than 2"".; Implementation by Anna Kreshuk. Double_t GammaDist(Double_t x, Double_t gamma, Double_t mu = 0, Double_t beta = 1); Computes the density function of Gamma distribution at point x.; gamma - shape parameter; mu - location parameter; beta - scale parameter. The definition can be found in ""Engineering Statistics Handbook"" on site; http://www.itl.nist.gov/div898/handbook/eda/section3/eda366b.htm; use now impleme",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMath.html:30949,test,test,30949,root/html528/TMath.html,https://root.cern,https://root.cern/root/html528/TMath.html,6,['test'],['test']
Testability,"nable. Sets a feature in the TIOFeatures object; emits an Error message if the IO feature is not supported by this version of ROOT.; If the feature is supported by ROOT, this function returns true; otherwise, it returns false. ; Definition at line 139 of file TIOFeatures.cxx. Set() [3/4]. bool TIOFeatures::Set ; (; Experimental::EIOFeatures; input_bits). Set a specific IO feature. ; Parameters. [in]input_bitsThe specific feature to enable. Sets a feature in the TIOFeatures object; emits an Error message if the IO feature is not supported by this version of ROOT.; If the feature is supported by ROOT, this function returns true; otherwise, it returns false. ; Definition at line 125 of file TIOFeatures.cxx. Set() [4/4]. void ROOT::TIOFeatures::Set ; (; UChar_t; newBits). inlineprivate . Definition at line 98 of file TIOFeatures.hxx. Test() [1/3]. bool TIOFeatures::Test ; (; EIOFeatures; input_bits); const. Test to see if a given feature is set. ; Parameters. [in]input_bitsThe specific feature to test. Returns true if the feature is enables in this object and supported by this version of ROOT. ; Definition at line 239 of file TIOFeatures.cxx. Test() [2/3]. bool TIOFeatures::Test ; (; Experimental::EIOFeatures; input_bits); const. Test to see if a given feature is set. ; Parameters. [in]input_bitsThe specific feature to test. Returns true if the feature is enables in this object and supported by this version of ROOT. ; Definition at line 228 of file TIOFeatures.cxx. Test() [3/3]. bool ROOT::TIOFeatures::Test ; (; Experimental::EIOUnsupportedFeatures; bits); const. Friends And Related Symbol Documentation. ::TBasket. friend class ::TBasket. friend . Definition at line 72 of file TIOFeatures.hxx. ::TBranch. friend class ::TBranch. friend . Definition at line 71 of file TIOFeatures.hxx. ::TTree. friend class ::TTree. friend . Definition at line 70 of file TIOFeatures.hxx. Member Data Documentation. fIOBits. UChar_t ROOT::TIOFeatures::fIOBits {0}. priv",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1TIOFeatures.html:6366,test,test,6366,doc/v632/classROOT_1_1TIOFeatures.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1TIOFeatures.html,2,['test'],['test']
Testability,"nadaptiveKDE, const TH1* hist = 0, Float_t lower_edge = 0., Float_t upper_edge = 1., TMVA::KDEKernel::EKernelBorder kborder = kNoTreatment, Float_t FineFactor = 1.); TMVA::KDEKernel&operator=(const TMVA::KDEKernel&); voidSetKernelType(TMVA::KDEKernel::EKernelType ktype = kGauss); virtual voidShowMembers(TMemberInspector&); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). private:. TMVA::MsgLogger&Log() const. Data Members; public:. enum EKernelType { kNone; kGauss; };; enum EKernelIter { kNonadaptiveKDE; kAdaptiveKDE; };; enum EKernelBorder { kNoTreatment; kKernelRenorm; kSampleMirror; };. private:. Float_tfFineFactorfine tuning factor for Adaptive KDE: factor to multiply the ""width"" of the Kernel function; TH1F*fFirstIterHisthistogram to be filled in the hidden iteration; Bool_tfHiddenIterationDefines if whats currently running is the ; TH1F*fHistcopy of input histogram; TMVA::KDEKernel::EKernelIterfIteriteration number; TMVA::KDEKernel::EKernelBorderfKDEborderThe method to take care about ""border"" effects; TF1*fKernel_integthe integral of the Kernel function; TMVA::MsgLogger*fLoggermessage logger; Float_tfLowerEdgethe lower edge of the PDF; Float_tfSigmaWidth of the Kernel function; TH1F*fSigmaHistcontains the Sigmas Widths for adaptive KDE ; Float_tfUpperEdgethe upper edge of the PDF. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; KDEKernel(TMVA::KDEKernel::EKernelIter kiter = kNonadaptiveKDE, const TH1* hist = 0, Float_t lower_edge = 0., Float_t upper_edge = 1., TMVA::KDEKernel::EKernelBorder kborder = kNoTreatment, Float_t FineFactor = 1.); constructor; sanity check. ~KDEKernel(); destructor. void SetKernelType(TMVA::KDEKernel::EKernelType ktype = kGauss); fIter == 1 ---> nonadaptive KDE; fIter == 2 ---> adaptive KDE. Float_t GetBinKernelIntegral(Float_t lowr, Float_t highr, Float_t mean, Int_t binnum); calculates the integral of the Kernel. KDEKernel(TMVA::KDEKernel::EKernel",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TMVA__KDEKernel.html:1772,log,logger,1772,root/html534/TMVA__KDEKernel.html,https://root.cern,https://root.cern/root/html534/TMVA__KDEKernel.html,1,['log'],['logger']
Testability,"nal Inherited Members; Public Types inherited from TMVA::IPruneTool; typedef std::vector< const Event * >EventSample; ; Protected Attributes inherited from TMVA::IPruneTool; Double_tB; ; Double_tfPruneStrength; ! regularization parameter in pruning ; ; Double_tS; . #include <TMVA/ExpectedErrorPruneTool.h>. Inheritance diagram for TMVA::ExpectedErrorPruneTool:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ExpectedErrorPruneTool(). TMVA::ExpectedErrorPruneTool::ExpectedErrorPruneTool ; (; ). Definition at line 62 of file ExpectedErrorPruneTool.cxx. ~ExpectedErrorPruneTool(). TMVA::ExpectedErrorPruneTool::~ExpectedErrorPruneTool ; (; ). virtual . Definition at line 71 of file ExpectedErrorPruneTool.cxx. Member Function Documentation. CalculatePruningInfo(). TMVA::PruningInfo * TMVA::ExpectedErrorPruneTool::CalculatePruningInfo ; (; DecisionTree *; dt, . const IPruneTool::EventSample *; testEvents = nullptr, . Bool_t; isAutomatic = kFALSE. ). virtual . Implements TMVA::IPruneTool.; Definition at line 79 of file ExpectedErrorPruneTool.cxx. CountNodes(). Int_t TMVA::ExpectedErrorPruneTool::CountNodes ; (; DecisionTreeNode *; node, . Int_t; icount = 0. ). inlineprivate . Definition at line 81 of file ExpectedErrorPruneTool.h. FindListOfNodes(). void TMVA::ExpectedErrorPruneTool::FindListOfNodes ; (; DecisionTreeNode *; node). private . recursive pruning of nodes using the Expected Error Pruning (EEP) ; Definition at line 175 of file ExpectedErrorPruneTool.cxx. GetNodeError(). Double_t TMVA::ExpectedErrorPruneTool::GetNodeError ; (; DecisionTreeNode *; node); const. private . Calculate an UPPER limit on the error made by the classification done by this node. ; If the S/S+B of the node is f, then according to the training sample, the error rate (fraction of misclassified events by this node) is (1-f) Now f has a statistical error according to the binomia",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1ExpectedErrorPruneTool.html:3505,test,testEvents,3505,doc/master/classTMVA_1_1ExpectedErrorPruneTool.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1ExpectedErrorPruneTool.html,1,['test'],['testEvents']
Testability,"nal function to create minimizer object needed to find contours or interval limits; (running MINOS).; Minimizer must be Minuit or Minuit2. bool FindLimits(const RooRealVar& param, double& lower, double& upper); Method to find both lower and upper limits using MINOS; If cached values exist (limits have been already found) return them in that case; check first if limit has been computed; otherwise compute limit using MINOS; in case of failure lower and upper will mantain previous value (will not be modified). Int_t GetContourPoints(const RooRealVar& paramX, const RooRealVar& paramY, Double_t* x, Double_t* y, Int_t npoints = 30); use Minuit to find the contour of the likelihood function at the desired CL. explicit LikelihoodInterval(const char* name = 0); defult constructor. void SetConfidenceLevel(Double_t cl); set the confidence level for the interval (e.g 0.682 for a 1-sigma interval). {fConfidenceLevel = cl; ResetLimits(); }. Double_t ConfidenceLevel() const; return confidence level. {return fConfidenceLevel;}. Double_t LowerLimit(const RooRealVar& param); return the lower bound of the interval on a given parameter. { bool ok; return LowerLimit(param,ok); }. Double_t UpperLimit(const RooRealVar& param); return the upper bound of the interval on a given parameter. { bool ok; return UpperLimit(param,ok); }. RooAbsReal* GetLikelihoodRatio(); return the profile log-likelihood ratio function. {return fLikelihoodRatio;}. const RooArgSet * GetBestFitParameters() const; return a pointer to a snapshot with best fit parameter of interest. { return fBestFitParams; }.  Author: Kyle Cranmer, Lorenzo Moneta, Gregory Schott, Wouter Verkerke  Copyright (C) 1995-2008, Rene Brun and Fons Rademakers. *;  Last changed: root/roostats:$Id: LikelihoodInterval.h 33206 2010-04-26 09:59:06Z moneta $  Last generated: 2010-11-10 17:31; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooStats__LikelihoodInterval.html:11197,log,log-likelihood,11197,root/html528/RooStats__LikelihoodInterval.html,https://root.cern,https://root.cern/root/html528/RooStats__LikelihoodInterval.html,1,['log'],['log-likelihood']
Testability,"nal function to create minimizer object needed to find contours or interval limits; (running MINOS).; Minimizer must be Minuit or Minuit2. bool FindLimits(const RooRealVar& param, double& lower, double& upper); Method to find both lower and upper limits using MINOS; If cached values exist (limits have been already found) return them in that case; check first if limit has been computed; otherwise compute limit using MINOS; in case of failure lower and upper will mantain previous value (will not be modified). Int_t GetContourPoints(const RooRealVar& paramX, const RooRealVar& paramY, Double_t* x, Double_t* y, Int_t npoints = 30); use Minuit to find the contour of the likelihood function at the desired CL. explicit LikelihoodInterval(const char* name = 0); defult constructor. void SetConfidenceLevel(Double_t cl); set the confidence level for the interval (e.g 0.682 for a 1-sigma interval). {fConfidenceLevel = cl; ResetLimits(); }. Double_t ConfidenceLevel() const; return confidence level. {return fConfidenceLevel;}. Double_t LowerLimit(const RooRealVar& param); return the lower bound of the interval on a given parameter. { bool ok; return LowerLimit(param,ok); }. Double_t UpperLimit(const RooRealVar& param); return the upper bound of the interval on a given parameter. { bool ok; return UpperLimit(param,ok); }. RooAbsReal* GetLikelihoodRatio(); return the profile log-likelihood ratio function. {return fLikelihoodRatio;}. const RooArgSet * GetBestFitParameters() const; return a pointer to a snapshot with best fit parameter of interest. { return fBestFitParams; }.  Author: Kyle Cranmer, Lorenzo Moneta, Gregory Schott, Wouter Verkerke  Copyright (C) 1995-2008, Rene Brun and Fons Rademakers. *;  Last changed: root/roostats:$Id: LikelihoodInterval.h 39391 2011-05-26 09:51:59Z moneta $  Last generated: 2011-07-04 15:24; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooStats__LikelihoodInterval.html:11276,log,log-likelihood,11276,root/html530/RooStats__LikelihoodInterval.html,https://root.cern,https://root.cern/root/html530/RooStats__LikelihoodInterval.html,1,['log'],['log-likelihood']
Testability,"nal function to create minimizer object needed to find contours or interval limits; (running MINOS).; Minimizer must be Minuit or Minuit2. bool FindLimits(const RooRealVar& param, double& lower, double& upper); Method to find both lower and upper limits using MINOS; If cached values exist (limits have been already found) return them in that case; check first if limit has been computed; otherwise compute limit using MINOS; in case of failure lower and upper will mantain previous value (will not be modified). Int_t GetContourPoints(const RooRealVar& paramX, const RooRealVar& paramY, Double_t* x, Double_t* y, Int_t npoints = 30); use Minuit to find the contour of the likelihood function at the desired CL. explicit LikelihoodInterval(const char* name = 0); defult constructor. void SetConfidenceLevel(Double_t cl); set the confidence level for the interval (e.g 0.682 for a 1-sigma interval). {fConfidenceLevel = cl; ResetLimits(); }. Double_t ConfidenceLevel() const; return confidence level. {return fConfidenceLevel;}. Double_t LowerLimit(const RooRealVar& param); return the lower bound of the interval on a given parameter. { bool ok; return LowerLimit(param,ok); }. Double_t UpperLimit(const RooRealVar& param); return the upper bound of the interval on a given parameter. { bool ok; return UpperLimit(param,ok); }. RooAbsReal* GetLikelihoodRatio(); return the profile log-likelihood ratio function. {return fLikelihoodRatio;}. const RooArgSet * GetBestFitParameters() const; return a pointer to a snapshot with best fit parameter of interest. { return fBestFitParams; }.  Author: Kyle Cranmer, Lorenzo Moneta, Gregory Schott, Wouter Verkerke  Copyright (C) 1995-2008, Rene Brun and Fons Rademakers. *;  Last changed: root/roostats:$Id: LikelihoodInterval.h 39391 2011-05-26 09:51:59Z moneta $  Last generated: 2011-11-03 20:09; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooStats__LikelihoodInterval.html:11276,log,log-likelihood,11276,root/html532/RooStats__LikelihoodInterval.html,https://root.cern,https://root.cern/root/html532/RooStats__LikelihoodInterval.html,1,['log'],['log-likelihood']
Testability,"nal nodes in \( T \); \( T' \) - the pruned subtree of \( T_max \) that has the best quality index \( R(T') \); \( \alpha \) - the prune strength parameter in Cost Complexity pruning \( (R_{\alpha}(T) = R(T) + \alpha*|\sim T|) \). There are two running modes in CCPruner: (i) one may select a prune strength and prune back the tree \( T_{max}\) until the criterion: ; \[; \alpha < \frac{R(T) - R(t)}{|\sim T_t| - 1}; \]. is true for all nodes t in \( T \), or (ii) the algorithm finds the sequence of critical points \( \alpha_k < \alpha_{k+1} ... < \alpha_K \) such that \( T_K = root(T_{max}) \) and then selects the optimally-pruned subtree, defined to be the subtree with the best quality index for the validation sample. ; Definition at line 62 of file CostComplexityPruneTool.h. Public Member Functions; CostComplexityPruneTool (SeparationBase *qualityIndex=nullptr); the constructor for the cost complexity pruning ; ; virtual~CostComplexityPruneTool (); the destructor for the cost complexity pruning ; ; virtual PruningInfo *CalculatePruningInfo (DecisionTree *dt, const IPruneTool::EventSample *testEvents=nullptr, Bool_t isAutomatic=kFALSE); the routine that basically ""steers"" the pruning process. ; ; Public Member Functions inherited from TMVA::IPruneTool; IPruneTool (); ; virtual~IPruneTool (); ; Double_tGetPruneStrength () const; ; Bool_tIsAutomatic () const; ; voidSetAutomatic (); ; voidSetPruneStrength (Double_t alpha); . Private Member Functions; voidInitTreePruningMetaData (DecisionTreeNode *n); initialise ""meta data"" for the pruning, like the ""costcomplexity"", the critical alpha, the minimal alpha down the tree, etc... for each node!! ; ; MsgLogger &Log () const; output stream to save logging information ; ; voidOptimize (DecisionTree *dt, Double_t weights); after the critical \( \alpha \) values (at which the corresponding nodes would be pruned away) had been established in the ""InitMetaData"" we need now: automatic pruning: ; . Privat",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1CostComplexityPruneTool.html:1780,test,testEvents,1780,doc/master/classTMVA_1_1CostComplexityPruneTool.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1CostComplexityPruneTool.html,1,['test'],['testEvents']
Testability,"nal numerical integration engine; RooMCStudy A general purpose toy Monte Carlo study manager; RooMPSentinel Singleton class that terminate MP server processes when parent exists; RooMapCatEntry Utility class, holding a map expression from a index label regexp to a RooCatType; RooMappedCategory Index variable, derived from another index using pattern-matching based mapping; RooMappedCategory::Entry Map cat entry definition; RooMath math utility routines; RooMinimizer RooFit interface to ROOT::Fit::Fitter; RooMinimizerFcn ; RooMinuit RooFit minimizer based on MINUIT; RooMsgService RooFit Message Service Singleton class; RooMsgService::StreamConfig ; RooMultiCatIter Iterator over all state permutations of a list of categories; RooMultiCategory Product operator for categories; RooMultiGenFunction Export RooAbsReal as functor; RooMultiVarGaussian Multivariate Gaussian PDF with correlations; RooNDKeysPdf General N-dimensional non-parametric kernel estimation p.d.f; RooNLLVar Function representing (extended) -log(L) of p.d.f and dataset; RooNameReg String name registry; RooNameSet A sterile version of RooArgSet, containing only the names of the contained RooAbsArgs; RooNonCPEigenDecay PDF to model CP-violating decays to final states which are not CP eigenstates; RooNormSetCache Management tool for tracking sets of similar integration/normalization sets; RooNovosibirsk Novosibirsk PDF; RooNumCdf Numeric calculator for CDF for a given PDF; RooNumConvPdf Operator PDF implementing numeric convolution of 2 input PDFs; RooNumConvolution Operator PDF implementing numeric convolution of 2 input functions; RooNumGenConfig Numeric (MC) Event generator configuration ; RooNumGenFactory Numeric Generator factory; RooNumIntConfig Numeric Integrator configuration ; RooNumIntFactory Numeric Integrator factory; RooNumRunningInt Numeric calculator for running integral of a given function; RooNumber wrapper class for portable numerics; RooObjCacheManager Cache manager for generic caches that ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html524/ClassIndex.html:37376,log,log,37376,root/html524/ClassIndex.html,https://root.cern,https://root.cern/root/html524/ClassIndex.html,1,['log'],['log']
Testability,"nalization). All of these should be made fairly explicit in the interface. Function Members (Methods); public:. virtual~ToyMCSamplerOld(); virtual RooStats::SamplingDistribution*AppendSamplingDistribution(RooArgSet& allParameters, RooStats::SamplingDistribution* last, Int_t additionalMC); static TClass*Class(); virtual Double_tConfidenceLevel() const; virtual Double_tEvaluateTestStatistic(RooAbsData& data, RooArgSet& allParameters); virtual RooAbsData*GenerateToyData(RooArgSet& allParameters) const; virtual RooStats::SamplingDistribution*GetSamplingDistribution(RooArgSet& allParameters); virtual RooStats::TestStatistic*GetTestStatistic() const; virtual voidInitialize(RooAbsArg&, RooArgSet&, RooArgSet&); virtual TClass*IsA() const; stringMakeName(RooArgSet&); RooStats::TestStatSampler&RooStats::TestStatSampler::operator=(const RooStats::TestStatSampler&); virtual voidSetConfidenceLevel(Double_t cl); virtual voidSetData(RooAbsData& data); virtual voidSetData(const char* name); virtual voidSetExtended(const Bool_t isExtended); virtual voidSetGlobalObservables(const RooArgSet&); virtual voidSetNEventsPerToy(const Int_t nevents); virtual voidSetNToys(const Int_t ntoy); virtual voidSetNuisanceParameters(const RooArgSet& set); virtual voidSetObservables(const RooArgSet& set); virtual voidSetParametersForTestStat(const RooArgSet& nullpoi); virtual voidSetPdf(RooAbsPdf& pdf); virtual voidSetPdf(const char* name); virtual voidSetPriorNuisance(RooAbsPdf*); virtual voidSetSamplingDistName(const char* name); virtual voidSetTestSize(Double_t size); virtual voidSetTestStatistic(RooStats::TestStatistic* testStat); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); RooStats::ToyMCSamplerOldToyMCSamplerOld(RooStats::TestStatistic& ts); RooStats::ToyMCSamplerOldToyMCSamplerOld(const RooStats::ToyMCSamplerOld&). Data Members; private:. Int_tfCountercounter for naming sampling dist objects; const char*fDataNamename of dat",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooStats__ToyMCSamplerOld.html:2647,test,testStat,2647,root/html528/RooStats__ToyMCSamplerOld.html,https://root.cern,https://root.cern/root/html528/RooStats__ToyMCSamplerOld.html,3,['test'],['testStat']
Testability,"nally was unweighted; by default underflows and overflows are not included:; ""OF"" = overflows included; ""UF"" = underflows included. ""P"" = print chi2, ndf, p_value, igood; ""CHI2"" = returns chi2 instead of p-value; ""CHI2/NDF"" = returns \( \chi^{2} \)/ndf . [in]resnot empty - computes normalized residuals and returns them in this array. The current implementation is based on the papers \( \chi^{2} \) test for comparison of weighted and unweighted histograms"" in Proceedings of PHYSTAT05 and; ""Comparison weighted and unweighted histograms"", arXiv:physics/0605123 by N.Gagunashvili. This function has been implemented by Daniel Haertl in August 2006.; Introduction:; A frequently used technique in data analysis is the comparison of histograms. First suggested by Pearson [1] the \( \chi^{2} \) test of homogeneity is used widely for comparing usual (unweighted) histograms. This paper describes the implementation modified \( \chi^{2} \) tests for comparison of weighted and unweighted histograms and two weighted histograms [2] as well as usual Pearson's \( \chi^{2} \) test for comparison two usual (unweighted) histograms.; Overview:; Comparison of two histograms expect hypotheses that two histograms represent identical distributions. To make a decision p-value should be calculated. The hypotheses of identity is rejected if the p-value is lower then some significance level. Traditionally significance levels 0.1, 0.05 and 0.01 are used. The comparison procedure should include an analysis of the residuals which is often helpful in identifying the bins of histograms responsible for a significant overall \( \chi^{2} \) value. Residuals are the difference between bin contents and expected bin contents. Most convenient for analysis are the normalized residuals. If hypotheses of identity are valid then normalized residuals are approximately independent and identically distributed random variables having N(0,1) distribution. Analysis of residuals expect test of above mentioned properties",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTH1.html:87267,test,tests,87267,doc/master/classTH1.html,https://root.cern,https://root.cern/doc/master/classTH1.html,2,['test'],"['test', 'tests']"
Testability,"nals; TList*TProof::fSlaveslist of all slave servers as in config file; TList*TProof::fTerminatedSlaveInfoslist of unique infos of terminated slaves; TStringTNamed::fTitleobject title; Long64_tTProof::fTotalBytesnumber of bytes to be analyzed; TUrlTProof::fUrlUrl of the master; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static TSemaphore*TProof::fgSemaphoresemaphore to control no of parallel startup threads. private:. TStringfCacheDirDirectory containing cache of user files; TProofLockPath*fCacheLockCache dir locker; TStringfDataSetDirDirectory containing info about known data sets; TDataSetManager*fDataSetManagerDataset manager; TDataSetManagerFile*fDataSetStgRepoDataset manager for staging requests; Int_tfDynamicStartupNMaxDyn Startup simulation: max number of workers; Int_tfDynamicStartupStepDyn Startup simulation: increment at each call; Bool_tfForkStartupStartup N-1 workers forking the first worker; Int_tfNWorkersNumber of workers; TQueryResultManager*fQMgrQuery-result manager; TStringfQueryDirDirectory containing query results and status; TProofLockPath*fQueryLockQuery dir locker; TPMERegexp*fReInvalidRegular expression matching invalid dataset URIs; TStringfSandboxPROOF sandbox root dir; TStringfSelectionInternal variable to pass drawing options; TServerSocket*fServSockServer socket to accept call backs; TStringfSockPathUNIX socket path for communication with workers; TStringfVarExpInternal variable to pass drawing options; static Int_tfgWrksMaxMax number of workers. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TProofLite(const char* masterurl, const char* conffile = kPROOF_ConfFile, const char* confdir = kPROOF_ConfDir, Int_t loglevel = 0, const char* alias = 0, TProofMgr* mgr = 0); Create a PROOF environment. Starting PROOF involves either connecting; to a master server, which in turn will start a set of slave servers, or; directly starting as master server (if master = """"",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TProofLite.html:27418,sandbox,sandbox,27418,root/html534/TProofLite.html,https://root.cern,https://root.cern/root/html534/TProofLite.html,1,['sandbox'],['sandbox']
Testability,"nalysis on; ; , to get linear; indenpendent (among themselves, but not independent of; ; ) quantities . For each component ; make a mutlidimensional fit,; using ; as the variables, thus determing a set of; coefficents ; .; . To process data, using this parameterisation, do; ; Test wether the observation ; within the domain of; the parameterization, using the result from the Principal Component; Analysis.; ; Determine ; as before.; ; Detetmine ; as before.; ; Use the result of the fit to determind ; .; ; Transform back to ; from ; , using; the result from the Principal Component Analysis.; . Testing the parameterization; . The class also provides functionality for testing the, over the; training sample, found parameterization; (TMultiDimFit::Fit). This is done by passing; the class a test sample of tuples of the form ; , where ; are the independent; variables, the known, dependent quantity, and is; the square error in ; (TMultiDimFit::AddTestRow).; ; The parameterization is then evaluated at every ; in the; test sample, and; . is evaluated. The relative error over the test sample; . should not be to low or high compared to from the training; sample. Also, multiple correlation coefficient from both samples should; be fairly close, otherwise one of the samples is not representive of; the problem. A large difference in the reduced over the two; samples indicate an over fit, and the maximum number of terms in the; parameterisation should be reduced.; ; It's possible to use Minuit; [4] to further improve the fit, using the test sample.; . Christian Holm; November 2000, NBI; . Bibliography; 1. PhilipR. Bevington and D.Keith Robinson.; Data Reduction and Error Analysis for the Physical Sciences.; McGraw-Hill, 2 edition, 1992.; 2. Ren Brun etal.; Mudifi.; Long writeup DD/75-23, CERN, 1980.; 3. GeneH. Golub and CharlesF. van Loan.; Matrix Computations.; John Hopkins Univeristy Press, Baltimore, 3 edition, 1996.; 4. F.James.; Minuit.; Long writeup D506, CERN, 1998.; 5. H",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TMultiDimFit.html:12258,test,test,12258,root/html534/TMultiDimFit.html,https://root.cern,https://root.cern/root/html534/TMultiDimFit.html,3,['test'],['test']
Testability,"nalysisType(TMVA::Types::EAnalysisType type); voidTMVA::MethodBase::SetBaseDir(TDirectory* methodDir); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTMVA::Configurable::SetConfigDescription(const char* d); voidTMVA::Configurable::SetConfigName(const char* n); virtual voidTMVA::MethodBase::SetCurrentEvent(Long64_t ievt) const; virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTMVA::MethodBase::SetMethodBaseDir(TDirectory* methodDir); voidTMVA::MethodBase::SetMethodDir(TDirectory* methodDir); voidTMVA::Configurable::SetMsgType(TMVA::EMsgType t); voidSetNeuronInputCalculator(TMVA::TNeuronInput* inputCalculator); static voidTObject::SetObjectStat(Bool_t stat); voidTMVA::Configurable::SetOptions(const TString& s); voidTMVA::MethodBase::SetSignalReferenceCut(Double_t cut); voidTMVA::MethodBase::SetSignalReferenceCutOrientation(Double_t cutOrientation); voidTMVA::MethodBase::SetTestTime(Double_t testTime); voidTMVA::MethodBase::SetTestvarName(const TString& v = """"); voidTMVA::MethodBase::SetTrainTime(Double_t trainTime); virtual voidTMVA::MethodBase::SetTuneParameters(map<TString,Double_t> tuneParameters); virtual voidTObject::SetUniqueID(UInt_t uid); voidTMVA::MethodBase::SetupMethod(); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTMVA::MethodBase::TestClassification(); virtual voidTMVA::MethodBase::TestMulticlass(); virtual voidTMVA::MethodBase::TestRegression(Double_t& bias, Double_t& biasT, Double_t& dev, Double_t& devT, Double_t& rms, Double_t& rmsT, Double_t& mInf, Double_t& mInfT, Double_t& corr, TMVA::Types::ETreeType type); virtual voidTrain(); voidTMVA::MethodBase::TrainMethod(); virtual voidTObject::UseCurrentStyle(); virtual voidTObj",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TMVA__MethodANNBase.html:11332,test,testTime,11332,root/html530/TMVA__MethodANNBase.html,https://root.cern,https://root.cern/root/html530/TMVA__MethodANNBase.html,2,['test'],['testTime']
Testability,"nalysisTypekMaxAnalysisType; static TMVA::Types::EMVAkMaxMethod; static TMVA::Types::ESBTypekMaxSBType; static TMVA::Types::ETreeTypekMaxTreeType; static TMVA::Types::EVariableTransformkMaxVariableTransform; static TMVA::Types::EAnalysisTypekMulticlass; static TMVA::Types::EAnalysisTypekNoAnalysisType; static TMVA::Types::EVariableTransformkNormalized; static TMVA::Types::EVariableTransformkPCA; static TMVA::Types::EMVAkPDEFoam; static TMVA::Types::EMVAkPDERS; static TMVA::Types::EMVAkPlugins; static TMVA::Types::EVariableTransformkRearranged; static TMVA::Types::EAnalysisTypekRegression; static TMVA::Types::EMVAkRuleFit; static TMVA::Types::ESBTypekSBBoth; static TMVA::Types::EMVAkSVM; static TMVA::Types::ESBTypekSignal; static TMVA::Types::EMVAkTMlpANN; static TMVA::Types::ETreeTypekTesting; static TMVA::Types::ETreeTypekTraining; static TMVA::Types::ETreeTypekTrainingOriginal; static TMVA::Types::ESBTypekTrueType; static TMVA::Types::EVariableTransformkUniform; static TMVA::Types::ETreeTypekValidation; static TMVA::Types::EMVAkVariable. private:. TMVA::MsgLogger*fLoggermessage logger; map<TString,TMVA::Types::EMVA>fStr2typetypes-to-text map; static atomic<TMVA::Types*>fgTypesPtr. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Types(); constructor. ~Types(); destructor. TMVA::Types& Instance(); the the single instance of ""Types"" if existin already, or create it (Signleton). void DestroyInstance(); ""destructor"" of the single instance. Bool_t AddTypeMapping(TMVA::Types::EMVA method, const TString& methodname). TString GetMethodName(TMVA::Types::EMVA method) const. Types::EMVA GetMethodType(const TString& method) const. Types().  Author: Andreas Hoecker, Joerg Stelzer, Helge Voss  Copyright (c) 2005: *;  Last changed: root/tmva $Id$  Last generated: 2015-06-30 15:18; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TMVA__Types.html:2782,log,logger,2782,root/html602/TMVA__Types.html,https://root.cern,https://root.cern/root/html602/TMVA__Types.html,1,['log'],['logger']
Testability,"nalysisTypekMaxAnalysisType; static TMVA::Types::EMVAkMaxMethod; static TMVA::Types::ESBTypekMaxSBType; static TMVA::Types::ETreeTypekMaxTreeType; static TMVA::Types::EVariableTransformkMaxVariableTransform; static TMVA::Types::EAnalysisTypekMulticlass; static TMVA::Types::EAnalysisTypekNoAnalysisType; static TMVA::Types::EVariableTransformkNormalized; static TMVA::Types::EVariableTransformkPCA; static TMVA::Types::EMVAkPDEFoam; static TMVA::Types::EMVAkPDERS; static TMVA::Types::EMVAkPlugins; static TMVA::Types::EVariableTransformkRearranged; static TMVA::Types::EAnalysisTypekRegression; static TMVA::Types::EMVAkRuleFit; static TMVA::Types::ESBTypekSBBoth; static TMVA::Types::EMVAkSVM; static TMVA::Types::ESBTypekSignal; static TMVA::Types::EMVAkTMlpANN; static TMVA::Types::ETreeTypekTesting; static TMVA::Types::ETreeTypekTraining; static TMVA::Types::ETreeTypekTrainingOriginal; static TMVA::Types::ESBTypekTrueType; static TMVA::Types::EVariableTransformkUniform; static TMVA::Types::ETreeTypekValidation; static TMVA::Types::EMVAkVariable. private:. TMVA::MsgLogger*fLoggermessage logger; map<TString,TMVA::Types::EMVA>fStr2typetypes-to-text map; static atomic<TMVA::Types*>fgTypesPtr. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Types(); constructor. ~Types(); destructor. TMVA::Types& Instance(); the the single instance of ""Types"" if existin already, or create it (Signleton). void DestroyInstance(); ""destructor"" of the single instance. Bool_t AddTypeMapping(TMVA::Types::EMVA method, const TString& methodname). TString GetMethodName(TMVA::Types::EMVA method) const. Types::EMVA GetMethodType(const TString& method) const. Types().  Author: Andreas Hoecker, Joerg Stelzer, Helge Voss  Copyright (c) 2005: *;  Last changed: root/tmva $Id$  Last generated: 2015-09-08 17:46; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TMVA__Types.html:2790,log,logger,2790,root/html604/TMVA__Types.html,https://root.cern,https://root.cern/root/html604/TMVA__Types.html,1,['log'],['logger']
Testability,"name = 0); Copy constructor. Initializes in clean state so that upon eval; this instance will create its own server processes. ~RooRealMPFE(); Destructor. void initVars(); Initialize list of variables of front-end argument 'arg'. void initialize(); Initialize the remote process and message passing; pipes between current process and remote process. void serverLoop(); Server loop of remote processes. This function will return; only when an incoming TERMINATE message is received. void calculate() const; Client-side function that instructs server process to start; asynchronuous (re)calculation of function value. This function; returns immediately. The calculated value can be retrieved; using getVal(). Double_t getVal(const RooArgSet* nset = 0) const; If value needs recalculation and calculation has not beed started; with a call to calculate() start it now. This function blocks; until remote process has finished calculation and returns; remote value. Double_t evaluate() const; Send message to server process to retrieve output value; If error were logged use logEvalError() on remote side; transfer those errors to the local eval error queue. void standby(); Terminate remote server process and return front-end class; to standby mode. Calls to calculate() or evaluate() after; this call will automatically recreated the server process. void constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); Intercept call to optimize constant term in test statistics; and forward it to object on server side. void setVerbose(Bool_t clientFlag = kTRUE, Bool_t serverFlag = kTRUE); Control verbose messaging related to inter process communication; on both client and server side. TObject* clone(const char* newname) const; { return new RooRealMPFE(*this,newname); }.  Last changed: Mon Jul 4 15:23:51 2011  Last generated: 2011-07-04 15:23; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooRealMPFE.html:36024,log,logged,36024,root/html530/RooRealMPFE.html,https://root.cern,https://root.cern/root/html530/RooRealMPFE.html,3,"['log', 'test']","['logEvalError', 'logged', 'test']"
Testability,"name = 0); Copy constructor. Initializes in clean state so that upon eval; this instance will create its own server processes. ~RooRealMPFE(); Destructor. void initVars(); Initialize list of variables of front-end argument 'arg'. void initialize(); Initialize the remote process and message passing; pipes between current process and remote process. void serverLoop(); Server loop of remote processes. This function will return; only when an incoming TERMINATE message is received. void calculate() const; Client-side function that instructs server process to start; asynchronuous (re)calculation of function value. This function; returns immediately. The calculated value can be retrieved; using getVal(). Double_t getVal(const RooArgSet* nset = 0) const; If value needs recalculation and calculation has not beed started; with a call to calculate() start it now. This function blocks; until remote process has finished calculation and returns; remote value. Double_t evaluate() const; Send message to server process to retrieve output value; If error were logged use logEvalError() on remote side; transfer those errors to the local eval error queue. void standby(); Terminate remote server process and return front-end class; to standby mode. Calls to calculate() or evaluate() after; this call will automatically recreated the server process. void constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); Intercept call to optimize constant term in test statistics; and forward it to object on server side. void setVerbose(Bool_t clientFlag = kTRUE, Bool_t serverFlag = kTRUE); Control verbose messaging related to inter process communication; on both client and server side. TObject* clone(const char* newname) const; { return new RooRealMPFE(*this,newname); }.  Last changed: Tue Dec 8 17:03:19 2009  Last generated: 2009-12-08 17:03; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooRealMPFE.html:35244,log,logged,35244,root/html526/RooRealMPFE.html,https://root.cern,https://root.cern/root/html526/RooRealMPFE.html,3,"['log', 'test']","['logEvalError', 'logged', 'test']"
Testability,"name = TString::Format(""%d"", i);; 2957 SetParameter(name, params[i]);; 2958 }; 2959 return;; 2960 }; 2961 fAllParametersSetted = true;; 2962 std::copy(params, params+size, fClingParameters.begin() );; 2963}; 2964 ; 2965////////////////////////////////////////////////////////////////////////////////; 2966/// Set a vector of parameters value.; 2967/// Order in the vector is by default the alphabetic order given to the parameters; 2968/// apart if the users has defined explicitly the parameter names; 2969 ; 2970void TFormula::SetParameters(const Double_t *params); 2971{; 2972 DoSetParameters(params,fNpar);; 2973}; 2974 ; 2975////////////////////////////////////////////////////////////////////////////////; 2976/// Set a parameter given a parameter index.; 2977/// The parameter index is by default the alphabetic order given to the parameters,; 2978/// apart if the users has defined explicitly the parameter names.; 2979 ; 2980void TFormula::SetParameter(Int_t param, Double_t value); 2981{; 2982 if (param < 0 || param >= fNpar) return;; 2983 assert(int(fClingParameters.size()) == fNpar);; 2984 fClingParameters[param] = value;; 2985 // TString name = TString::Format(""%d"",param);; 2986 // SetParameter(name,value);; 2987}; 2988 ; 2989////////////////////////////////////////////////////////////////////////////////; 2990void TFormula::SetParName(Int_t ipar, const char * name); 2991{; 2992 ; 2993 if (ipar < 0 || ipar > fNpar) {; 2994 Error(""SetParName"",""Wrong Parameter index %d "",ipar);; 2995 return;; 2996 }; 2997 TString oldName;; 2998 // find parameter with given index; 2999 for ( auto &it : fParams) {; 3000 if (it.second == ipar) {; 3001 oldName = it.first;; 3002 fParams.erase(oldName);; 3003 fParams.insert(std::make_pair(name, ipar) );; 3004 break;; 3005 }; 3006 }; 3007 if (oldName.IsNull() ) {; 3008 Error(""SetParName"",""Parameter %d is not existing."",ipar);; 3009 return;; 3010 }; 3011 ; 3012 //replace also parameter name in formula expression in case is not a lambda; 3013 if",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TFormula_8cxx_source.html:114222,assert,assert,114222,doc/master/TFormula_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TFormula_8cxx_source.html,1,['assert'],['assert']
Testability,"name T5 = T0, typename T6 = T0, typename T7 = T0, typename Common_t = std::common_type_t<T0, T1, T2, T3, T4, T5, T6, T7>> . Common_t ROOT::VecOps::InvariantMasses_PxPyPzM ; (; const T0 &; x1, . const T1 &; y1, . const T2 &; z1, . const T3 &; mass1, . const T4 &; x2, . const T5 &; y2, . const T6 &; z2, . const T7 &; mass2. ). Return the invariant mass of two particles given x coordinate (px), y coordinate (py), z coordinate (pz) and mass. ; The function computes the invariant mass of two particles with the four-vectors (x1, y2, z1, mass1) and (x2, py2, pz2, mass2). ; Definition at line 3051 of file RVec.hxx. lgamma(). template<typename T > . RVec< PromoteType< T > > ROOT::VecOps::lgamma ; (; const RVec< T > &; v). Definition at line 1875 of file RVec.hxx. llround(). template<typename T > . RVec< PromoteType< T > > ROOT::VecOps::llround ; (; const RVec< T > &; v). Definition at line 1871 of file RVec.hxx. log(). template<typename T > . RVec< PromoteType< T > > ROOT::VecOps::log ; (; const RVec< T > &; v). Definition at line 1841 of file RVec.hxx. log10(). template<typename T > . RVec< PromoteType< T > > ROOT::VecOps::log10 ; (; const RVec< T > &; v). Definition at line 1842 of file RVec.hxx. log1p(). template<typename T > . RVec< PromoteType< T > > ROOT::VecOps::log1p ; (; const RVec< T > &; v). Definition at line 1844 of file RVec.hxx. log2(). template<typename T > . RVec< PromoteType< T > > ROOT::VecOps::log2 ; (; const RVec< T > &; v). Definition at line 1843 of file RVec.hxx. lround(). template<typename T > . RVec< PromoteType< T > > ROOT::VecOps::lround ; (; const RVec< T > &; v). Definition at line 1870 of file RVec.hxx. Map(). template<typename... Args> . auto ROOT::VecOps::Map ; (; Args &&...; args). Create new collection applying a callable to the elements of the input collection. ; Example code, at the ROOT prompt: using namespace ROOT::VecOps;; RVecF v {1.f, 2.f, 4.f};; auto v_square = Map(v, [](float f){return f* 2.f;});; v",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__vecops.html:56943,log,log,56943,doc/master/group__vecops.html,https://root.cern,https://root.cern/doc/master/group__vecops.html,1,['log'],['log']
Testability,"name, const int kBufSize); 1133{; 1134 int n, ier, iter, lx, ncopy;; 1135 char *inp, *out, *x, *t, *buff;; 1136 const char *b, *c, *e;; 1137 const char *p;; 1138 buff = new char[kBufSize * 4];; 1139 ; 1140 iter = 0; xname[0] = 0; inp = buff + kBufSize; out = inp + kBufSize;; 1141 inp[-1] = ' '; inp[0] = 0; out[-1] = ' ';; 1142 c = fname + strspn(fname, "" \t\f\r"");; 1143 //VP if (isalnum(c[0])) { strcpy(inp, WorkingDirectory()); strcat(inp, ""/""); } // add $cwd; 1144 ; 1145 strlcat(inp, c, kBufSize);; 1146 ; 1147again:; 1148 iter++; c = inp; ier = 0;; 1149 x = out; x[0] = 0;; 1150 ; 1151 p = nullptr; e = nullptr;; 1152 if (c[0] == '~' && c[1] == '/') { // ~/ case; 1153 std::string hd = GetHomeDirectory();; 1154 p = hd.c_str();; 1155 e = c + 1;; 1156 if (p) { // we have smth to copy; 1157 strlcpy(x, p, kBufSize);; 1158 x += strlen(p);; 1159 c = e;; 1160 } else {; 1161 ++ier;; 1162 ++c;; 1163 }; 1164 } else if (c[0] == '~' && c[1] != '/') { // ~user case; 1165 n = strcspn(c+1, ""/ "");; 1166 assert((n+1) < kBufSize && ""This should have been prevented by the truncation 'strlcat(inp, c, kBufSize)'"");; 1167 // There is no overlap here as the buffer is segment in 4 strings of at most kBufSize; 1168 (void)strlcpy(buff, c+1, n+1); // strlcpy copy 'size-1' characters.; 1169 std::string hd = GetHomeDirectory(buff);; 1170 e = c+1+n;; 1171 if (!hd.empty()) { // we have smth to copy; 1172 p = hd.c_str();; 1173 strlcpy(x, p, kBufSize);; 1174 x += strlen(p);; 1175 c = e;; 1176 } else {; 1177 x++[0] = c[0];; 1178 //++ier;; 1179 ++c;; 1180 }; 1181 }; 1182 ; 1183 for ( ; c[0]; c++) {; 1184 ; 1185 p = nullptr; e = nullptr;; 1186 ; 1187 if (c[0] == '.' && c[1] == '/' && c[-1] == ' ') { // $cwd; 1188 std::string wd = GetWorkingDirectory();; 1189 strlcpy(buff, wd.c_str(), kBufSize);; 1190 p = buff;; 1191 e = c + 1;; 1192 }; 1193 if (p) { // we have smth to copy */; 1194 strlcpy(x, p, kBufSize); x += strlen(p); c = e-1; continue;; 1195 }; 1196 ; 1197 if (c[0] != '$') { // not $, simple copy; 1",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TSystem_8cxx_source.html:35960,assert,assert,35960,doc/master/TSystem_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html,1,['assert'],['assert']
Testability,"namecycle.Definition TDirectoryFile.cxx:937; TFileA ROOT file is an on-disk file, usually with extension .root, that stores objects in a file-system-li...Definition TFile.h:53; TFile::Openstatic TFile * Open(const char *name, Option_t *option="""", const char *ftitle="""", Int_t compress=ROOT::RCompressionSetting::EDefaults::kUseCompiledDefault, Int_t netopt=0)Create / open a file.Definition TFile.cxx:4089; TFile::SetCacheFileDirstatic Bool_t SetCacheFileDir(std::string_view cacheDir, Bool_t operateDisconnected=kTRUE, Bool_t forceCacheread=kFALSE)Sets the directory where to locally stage/cache remote files.Definition TFile.cxx:4626; TMVA::DataLoaderDefinition DataLoader.h:50; TMVA::DataLoader::AddSignalTreevoid AddSignalTree(TTree *signal, Double_t weight=1.0, Types::ETreeType treetype=Types::kMaxTreeType)number of signal events (used to compute significance)Definition DataLoader.cxx:371; TMVA::DataLoader::PrepareTrainingAndTestTreevoid PrepareTrainingAndTestTree(const TCut &cut, const TString &splitOpt)prepare the training and test trees -> same cuts for signal and backgroundDefinition DataLoader.cxx:632; TMVA::DataLoader::AddBackgroundTreevoid AddBackgroundTree(TTree *background, Double_t weight=1.0, Types::ETreeType treetype=Types::kMaxTreeType)number of signal events (used to compute significance)Definition DataLoader.cxx:402; TMVA::DataLoader::AddVariablevoid AddVariable(const TString &expression, const TString &title, const TString &unit, char type='F', Double_t min=0, Double_t max=0)user inserts discriminating variable in data set infoDefinition DataLoader.cxx:485; TMVA::FactoryThis is the main MVA steering class.Definition Factory.h:80; TMVA::PyMethodBase::PyInitializestatic void PyInitialize()Initialize Python interpreter.Definition PyMethodBase.cxx:153; TMVA::Tools::Instancestatic Tools & Instance()Definition Tools.cxx:71; TMVA::Types::kFisher@ kFisherDefinition Types.h:82; TMVA::Types::kPyKeras@ kPyKerasDefinition Types.h:103; TMVA::Types::kBDT@ kBDTDefinitio",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVA__Higgs__Classification_8C.html:71424,test,test,71424,doc/master/TMVA__Higgs__Classification_8C.html,https://root.cern,https://root.cern/doc/master/TMVA__Higgs__Classification_8C.html,1,['test'],['test']
Testability,"napse(); TMVA::TSynapseTSynapse(const TMVA::TSynapse&); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). private:. TMVA::MsgLogger&Log() const. Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. private:. Int_tfCountnumber of updates contributing to error field; Double_tfDEDwsum of deltas; Double_tfDeltalocal error field; Double_tfLearnRatelearning rate parameter; TMVA::TNeuron*fPostNeuronpointer to post-neuron; TMVA::TNeuron*fPreNeuronpointer to pre-neuron; Double_tfWeightweight of the synapse; static TMVA::MsgLogger*fgLogger! message logger, static to save resources. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TSynapse(); constructor. ~TSynapse(); destructor. void SetWeight(Double_t weight); set synapse weight. Double_t GetWeightedValue(); get output of pre-neuron weighted by synapse weight. Double_t GetWeightedDelta(); get error field of post-neuron weighted by synapse weight. void AdjustWeight(); adjust the weight based on the error field all ready calculated by CalculateDelta. void CalculateDelta(); calculate/adjust the error field for this synapse. TSynapse(). Double_t GetWeight(); get the weight of the synapse. { return fWeight; }. void SetLearningRate(Double_t rate); set the learning rate. { fLearnRate = rate; }. Double_t GetLearningRate(); get the learning rate. { return fLearnRate; }. void DecayLearningRate(Doub",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMVA__TSynapse.html:5884,log,logger,5884,root/html528/TMVA__TSynapse.html,https://root.cern,https://root.cern/root/html528/TMVA__TSynapse.html,4,['log'],['logger']
Testability,"napsesarray of pointers to synapses, no structural data; boolTMVA::MethodANNBase::fUseRegulatorzjh; TRandom3*TMVA::MethodANNBase::frgenrandom number generator for various uses. private:. TMVA::MethodMLP::EBPTrainingModefBPModebackprop learning mode (sequential or batch); Int_tfBatchSizebatch size, only matters if in batch learning mode; TStringfBpModeSbackprop learning mode option string (sequential or batch); boolfCalculateErrorscompute inverse hessian matrix at the end of the training; Double_tfDecayRatedecay rate for above learning rate; Bool_tfEpochMoncreate and fill epoch-wise monitoring histograms (makes outputfile big!); Double_tfGA_SC_factorGA settings: SC_factor; Int_tfGA_SC_rateGA settings: SC_rate; Int_tfGA_SC_stepsGA settings: SC_steps; Int_tfGA_nstepsGA settings: number of steps; Int_tfGA_preCalcGA settings: number of pre-calc steps; Double_tfLastAlphaline search variable; Double_tfLearnRatelearning rate for synapse weight adjustments; Double_tfPriorzjh; vector<Double_t>fPriorDevzjh; Int_tfResetStepreset time (how often we clear hessian matrix); Float_tfSamplingEpochfraction of epochs where sampling is used; Float_tfSamplingFractionfraction of events which is sampled for training; Bool_tfSamplingTestingThe testing sample is sampled; Bool_tfSamplingTrainingThe training sample is sampled; Float_tfSamplingWeightchanging factor for event weights when sampling is turned on; Double_tfTauline search variable; Int_tfTestRatetest for overtraining performed at each #th epochs; TStringfTrainMethodStraining method option param; TMVA::MethodMLP::ETrainingMethodfTrainingMethodmethod of training, BP or GA; Int_tfUpdateLimitzjh; boolfUseRegulatorzjh; static const Bool_tfgPRINT_BATCHdebug flags; static const Int_tfgPRINT_ESTIMATOR_INCdebug flags; static const Bool_tfgPRINT_SEQdebug flags. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; MethodMLP(const TString& jobName, const TString& methodTitle, TMVA::DataSetInfo& theData, cons",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMVA__MethodMLP.html:21075,test,testing,21075,root/html528/TMVA__MethodMLP.html,https://root.cern,https://root.cern/root/html528/TMVA__MethodMLP.html,1,['test'],['testing']
Testability,"nav = gGeoManager->AddNavigator(navig);; // Make its own navigator the active one; gGeoManager->SetCurrentNavigator(inav);; // Switch between navigators; gGeoManager->SetCurrentNavigator(0);; TGeoManager::AddNavigatorTGeoNavigator * AddNavigator()Add a navigator in the list of navigators.Definition TGeoManager.cxx:789; TGeoManager::SetCurrentNavigatorBool_t SetCurrentNavigator(Int_t index)Switch to another existing navigator for the calling thread.Definition TGeoManager.cxx:849; TGeoNavigatorClass providing navigation API for TGeo geometries.Definition TGeoNavigator.h:32; A navigator holds several variables describing the current navigation state: current point position, current direction distance to next boundary, isotropic safety, pointer to current and next nods as well as several tracking flags related to volume boundary conditions or other properties required for track propagation in geometry. Each geometry query affects these variables, so the only way in testing several navigation alternatives and remembering the active navigation state is to use parallel navigation. The following paragraphs will describe the usage of a single navigator. All setters/getters for navigation state parameters as well as navigation queries provided by TGeoNavigator are interfaced by TGeoManager and will act on the current navigator. Initializing the Starting Point; The current point (x,y,z) known by the modeller is stored as Double_t fCurrentPoint[3] by the navigator class. This array of the three coordinates is defined in the current global reference system and can be retrieved any time:; Const Double_t *cpoint = gGeoManager->GetCurrentPoint();; TGeoManager::GetCurrentPointconst Double_t * GetCurrentPoint() constDefinition TGeoManager.h:501; Initializing this point can be done like:; gGeoManager->SetCurrentPoint(x,y,z);; // or:; gGeoManager->SetCurrentPoint(Double_t *point[3]);; TGeoManager::SetCurrentPointvoid SetCurrentPoint(Double_t *point)Definition TGeoManager.h:515. Initiali",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__Geometry.html:68554,test,testing,68554,doc/master/group__Geometry.html,https://root.cern,https://root.cern/doc/master/group__Geometry.html,1,['test'],['testing']
Testability,nbkg * bkg_over_bkg_Int[x] + nsig * sig ] has 1 errors; ; RooAbsMinimizerFcn: Minimized function has error status.; Returning maximum FCN so far (-777.498) to force MIGRAD to back out of this region. Error log follows.; Parameter values: a0=0.516095 a1=-0.955515 mean=5.14443 nbkg=157.502 nsig=97.2821 sig1frac=0.174928; RooAddPdf::model[ nbkg * bkg_over_bkg_Int[x] + nsig * sig ] has 1 errors; ; RooAbsMinimizerFcn: Minimized function has error status.; Returning maximum FCN so far (-777.498) to force MIGRAD to back out of this region. Error log follows.; Parameter values: a0=0.510348 a1=-0.776595 mean=5.09286 nbkg=154.805 nsig=114.979 sig1frac=0.0496841; RooAddPdf::model[ nbkg * bkg_over_bkg_Int[x] + nsig * sig ] has 1 errors; ; [#0] PROGRESS:Generation -- RooMCStudy::run: sample 120; [#0] PROGRESS:Generation -- RooMCStudy::run: sample 110; RooAbsMinimizerFcn: Minimized function has error status.; Returning maximum FCN so far (-796.54) to force MIGRAD to back out of this region. Error log follows.; Parameter values: a0=0.702991 a1=-0.414346 mean=5.11911 nbkg=145.466 nsig=141.134 sig1frac=0.532895; RooAddPdf::model[ nbkg * bkg_over_bkg_Int[x] + nsig * sig ] has 1 errors; ; [#0] PROGRESS:Generation -- RooMCStudy::run: sample 100; RooAbsMinimizerFcn: Minimized function has error status.; Returning maximum FCN so far (-920.777) to force MIGRAD to back out of this region. Error log follows.; Parameter values: a0=0.726241 a1=-0.424659 mean=5.05565 nbkg=151.228 nsig=170.816 sig1frac=0.771802; RooAddPdf::model[ nbkg * bkg_over_bkg_Int[x] + nsig * sig ] has 1 errors; ; RooAbsMinimizerFcn: Minimized function has error status.; Returning maximum FCN so far (-743.339) to force MIGRAD to back out of this region. Error log follows.; Parameter values: a0=0.942558 a1=-0.775768 mean=4.99866 nbkg=187.872 nsig=63.0852 sig1frac=0.868175; RooAddPdf::model[ nbkg * bkg_over_bkg_Int[x] + nsig * sig ] has 1 errors; ; RooAbsMinimizerFcn: Minimized function has error status.; Returning maximum F,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf801__mcstudy_8C.html:26557,log,log,26557,doc/master/rf801__mcstudy_8C.html,https://root.cern,https://root.cern/doc/master/rf801__mcstudy_8C.html,2,['log'],['log']
Testability,"nce ; (; ). static . Return reference to singleton instance. ; Definition at line 345 of file RooMsgService.cxx. IsA(). TClass * RooMsgService::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TObject.; Definition at line 246 of file RooMsgService.h. isActive(). template<class T > . bool RooMsgService::isActive ; (; T; self, . RooFit::MsgTopic; topic, . RooFit::MsgLevel; level. ). inline . Check if logging is active for given object/topic/RooFit::MsgLevel combination. ; Definition at line 186 of file RooMsgService.h. log() [1/3]. ostream & RooMsgService::log ; (; const RooAbsArg *; self, . RooFit::MsgLevel; level, . RooFit::MsgTopic; topic, . bool; skipPrefix = false. ). Log error message associated with RooAbsArg object self at given level and topic. ; If skipPrefix is true the standard RooMsgService prefix is not added. ; Definition at line 419 of file RooMsgService.cxx. log() [2/3]. ostream & RooMsgService::log ; (; const TObject *; self, . RooFit::MsgLevel; level, . RooFit::MsgTopic; topic, . bool; skipPrefix = false. ). Log error message associated with TObject object self at given level and topic. ; If skipPrefix is true the standard RooMsgService prefix is not added. ; Definition at line 456 of file RooMsgService.cxx. log() [3/3]. std::ostream & RooMsgService::log ; (; std::nullptr_t; , . RooFit::MsgLevel; level, . RooFit::MsgTopic; facility, . bool; forceSkipPrefix = false. ). inline . Definition at line 180 of file RooMsgService.h. numStreams(). Int_t RooMsgService::numStreams ; (; ); const. inline . Definition at line 163 of file RooMsgService.h. Print(). void RooMsgService::Print ; (; Option_t *; options = nullptr); const. overridevirtual . Print configuration of message service. ; If ""v"" option is given also inactive streams are listed ; Reimplemented from TObject.; Definition at line 486 of file RooMsgService.cxx. reset(). void RooMsgService::reset ; (; ). Definit",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooMsgService.html:20306,log,log,20306,doc/master/classRooMsgService.html,https://root.cern,https://root.cern/doc/master/classRooMsgService.html,1,['log'],['log']
Testability,"nce ; Bool_t_init! Is object initialized ; RooRealMPFE**_mpfeArray! Array of parallel execution frond ends; Bool_t_mpinterlUse interleaving strategy rather than N-wise split for partioning of dataset for multiprocessor-split; Int_t_nCPUNumber of processors to use in parallel calculation mode; Int_t_nEventsTotal number of events in test statistic calculation; Int_t_nGofNumber of sub-contexts ; Int_t_numSetsTotal number of partitions in parallel calculation mode; Int_t_setNumPartition number of this instance in parallel calculation mode. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~RooAbsTestStatistic(); Destructor. Double_t evaluate() const; Calculates and return value of test statistic. If the test statistic; is calculated from on a RooSimultaneous, the test statistic calculation; is performed separately on each simultaneous p.d.f component and associated; data and then combined. If the test statistic calculation is parallelized; partitions are calculated in nCPU processes and a posteriori combined. Bool_t initialize(); One-time initialization of the test statistic. Setup; infrastructure for simultaneous p.d.f processing and/or; parallelized processing if requested. Bool_t redirectServersHook(const RooAbsCollection& newServerList, Bool_t mustReplaceAll, Bool_t nameChange, Bool_t isRecursive); Forward server redirect calls to component test statistics. void printCompactTreeHook(ostream& os, const char* indent = """"); Add extra information on component test statistics when printing; itself as part of a tree structure. void constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); Forward constant term optimization management calls to component; test statistics. void setMPSet(Int_t setNum, Int_t numSets); Set MultiProcessor set number identification of this instance. void initMPMode(RooAbsReal* real, RooAbsData* data, const RooArgSet* projDeps, const char* rangeName, const char* addCoefRangeName); Initialize multi-processo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAbsTestStatistic.html:35582,test,test,35582,root/html526/RooAbsTestStatistic.html,https://root.cern,https://root.cern/root/html526/RooAbsTestStatistic.html,3,['test'],['test']
Testability,"nce ; Bool_t_init! Is object initialized ; RooRealMPFE**_mpfeArray! Array of parallel execution frond ends; Bool_t_mpinterlUse interleaving strategy rather than N-wise split for partioning of dataset for multiprocessor-split; Int_t_nCPUNumber of processors to use in parallel calculation mode; Int_t_nEventsTotal number of events in test statistic calculation; Int_t_nGofNumber of sub-contexts ; Int_t_numSetsTotal number of partitions in parallel calculation mode; Int_t_setNumPartition number of this instance in parallel calculation mode. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~RooAbsTestStatistic(); Destructor. Double_t evaluate() const; Calculates and return value of test statistic. If the test statistic; is calculated from on a RooSimultaneous, the test statistic calculation; is performed separately on each simultaneous p.d.f component and associated; data and then combined. If the test statistic calculation is parallelized; partitions are calculated in nCPU processes and a posteriori combined. Bool_t initialize(); One-time initialization of the test statistic. Setup; infrastructure for simultaneous p.d.f processing and/or; parallelized processing if requested. Bool_t redirectServersHook(const RooAbsCollection& newServerList, Bool_t mustReplaceAll, Bool_t nameChange, Bool_t isRecursive); Forward server redirect calls to component test statistics. void printCompactTreeHook(ostream& os, const char* indent = """"); Add extra information on component test statistics when printing; itself as part of a tree structure. void constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); Forward constant term optimization management calls to component; test statistics. void setMPSet(Int_t setNum, Int_t numSets); Set MultiProcessor set number identification of this instance. void initMPMode(RooAbsReal* real, RooAbsData* data, const RooArgSet* projDeps, const char* rangeName, const char* addCoefRan",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooAbsTestStatistic.html:37120,test,test,37120,root/html532/RooAbsTestStatistic.html,https://root.cern,https://root.cern/root/html532/RooAbsTestStatistic.html,1,['test'],['test']
Testability,"nce documentation.; 13.3 TMath; In the namespace, TMath, a collection of free functions is provided for the following functionality:. numerical constants (like pi, e, h, etc.);; trigonometric and elementary mathematical functions;; functions to work with arrays and collections (e.g.functions to find min and max of arrays);; statistic functions to work on array of data (e.g.mean and RMS of arrays);; algorithms for binary search/hashing sorting;; special mathematical functions like Bessel, Erf, Gamma, etc.;; statistical functions, like common probability and cumulative (quantile) distributions; geometrical functions. For more details, see the reference documentation of TMath at <http://root.cern.ch/root/htmldoc/TMath.html>.; 13.3.1 Numerical Constants; TMath offers a wide range of constants in the form of inline functions. Notice that they are not defined as C/C++ preprocessor macros. This set of functions includes one or more definitions for the following constants:. Pi.; Base of natural logarithm.; Velocity of light.; Gravitational constant (G).; Standard acceleration of gravity (g).; Standard acceleration of Gravity.; Planks contant.; Boltzmanns and Steffan-Boltzmanns constants.; Avogadros number.; Universal gas constant.; Molecular weight of dry air.; Dry air gas constant.; Euler-Mascheroni Constant.; Elementary charge. 13.3.2 Elementary Functions; A set of miscellaneous elementary mathematical functions is provided along with a set of basic trigonometrical functions. Some of this functions refer to basic mathematical functions like the square root, the power to a number of the calculus of a logarithm, while others are used for number treatment, like rounding.; Although there are some functions that are not in the standard C math library (like Factorial), most of the functionality offered here is just a wrapper of the first ones. Nevertheless, some of the them also offer some security checks or a better precision, like the trigonometrical functions ASin(x), ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:661649,log,logarithm,661649,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['log'],['logarithm']
Testability,"nce the check is done elsewhere.; kForward (0x4) if set, ask server to forward the file to slave; or submaster (meaningless for slave servers).; kCpBin (0x8) Retrieve from the cache the binaries associated; with the file; kCp (0x10) Retrieve the files from the cache. Int_t SendObject(const TObject* obj, TProof::ESlaves list = kActive); Send object to master or slave servers. Returns number of slaves object; was sent to, -1 in case of error. Int_t SendPrint(Option_t* option = """"); Send print command to master server. Returns number of slaves message; was sent to. Returns -1 in case of error. void SetLogLevel(Int_t level, UInt_t mask = TProofDebug::kAll); Set server logging level. void SetRealTimeLog(Bool_t on = kTRUE); Switch ON/OFF the real-time logging facility. When this option is; ON, log messages from processing are sent back as they come, instead of; being sent back at the end in one go. This may help debugging or monitoring; in some cases, but, depending on the amount of log, it may have significant; consequencies on the load over the network, so it must be used with care. Int_t SetParallelSilent(Int_t nodes, Bool_t random = kFALSE); Tell PROOF how many slaves to use in parallel. If random is TRUE a random; selection is done (if nodes is less than the available nodes).; Returns the number of parallel slaves. Returns -1 in case of error. Int_t SetParallel(Int_t nodes = 9999, Bool_t random = kFALSE); Tell PROOF how many slaves to use in parallel. Returns the number of; parallel slaves. Returns -1 in case of error. Int_t GoParallel(Int_t nodes, Bool_t accept = kFALSE, Bool_t random = kFALSE); Go in parallel mode with at most ""nodes"" slaves. Since the fSlaves; list is sorted by slave performace the active list will contain first; the most performant nodes. Returns the number of active slaves.; If random is TRUE, and nodes is less than the number of available workers,; a random selection is done.; Returns -1 in case of error. void ShowData(); List contents of the d",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TProof.html:57928,log,log,57928,root/html528/TProof.html,https://root.cern,https://root.cern/root/html528/TProof.html,3,['log'],['log']
Testability,"nce; Inherited Members; Includes; Libraries. Function documentation; ~TMLPAnalyzer(); Destructor. Int_t GetLayers(); Returns the number of layers. Int_t GetNeurons(Int_t layer); Returns the number of neurons in given layer. TString GetNeuronFormula(Int_t idx); Returns the formula used as input for neuron (idx) in; the first layer. const char* GetInputNeuronTitle(Int_t in); Returns the name of any neuron from the input layer. const char* GetOutputNeuronTitle(Int_t out); Returns the name of any neuron from the output layer. void CheckNetwork(); Gives some information about the network in the terminal. void GatherInformations(); Collect information about what is usefull in the network.; This method has to be called first when analyzing a network.; Fills the two analysis trees. void DrawDInput(Int_t i); Draws the distribution (on the test sample) of the; impact on the network output of a small variation of; the ith input. void DrawDInputs(); Draws the distribution (on the test sample) of the; impact on the network output of a small variation of; each input.; DrawDInputs() draws something that approximates the distribution of the; derivative of the NN w.r.t. each input. That quantity is recognized as; one of the measures to determine key quantities in the network. What is done is to vary one input around its nominal value and to see; how the NN changes. This is done for each entry in the sample and produces; a distribution. What you can learn from that is:; - is variable a really useful, or is my network insensitive to it ?; - is there any risk of big systematic ? Is the network extremely sensitive; to small variations of any of my inputs ?. As you might understand, this is to be considered with care and can serve; as input for an ""educated guess"" when optimizing the network. void DrawNetwork(Int_t neuron, const char* signal, const char* bg); Draws the distribution of the neural network (using ith neuron).; Two distributions are drawn, for events passing respectively the",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TMLPAnalyzer.html:7068,test,test,7068,root/html534/TMLPAnalyzer.html,https://root.cern,https://root.cern/root/html534/TMLPAnalyzer.html,3,['test'],['test']
Testability,"nch for each data member of the Event class. The list of tracks (a TClonesArray) has the data members of the Track class also split into individual buffers. These tests were run on Pentium III CPU with 650 MHz. Event Parameters; File Size; Total Time to Write (MB/sec); Effective Time to Write (MB/sec); Total Time to Read All (MB/sec); Total Time to Read Sample (MB/sec). Comp = 0; Split = 1; 19.75 MB; 6.84 s.(2.8 MB/s); 3.56 s.(5.4 MB/s); 0.79s.(24.2 MB/s); 0.79 s.(24.2 MB/s). Comp = 1; Split = 1; 17.73 MB; 6.44 s.(3.0 MB/s); 4.02 s.(4.8 MB/s); 0.90 s.(21.3 MB/s); 0.90 s.(21.3 MB/s). Comp = 2; Split = 1; 13.78 MB; 11.34s.(1.7 MB/s); 9.51 s.(2.0 MB/s); 2.17 s.(8.8 MB/s); 2.17 s.(8.8 MB/s). The Total Time is the real time in seconds to run the program. Effective time is the real time minus the time spent in non I/O operations (essentially the random number generator). The program Event generates in average 600 tracks per event. Each track has 17 data members. The read benchmark runs in the interactive version of ROOT. The Total Time to Read All is the real time reported by the execution of the script &ROOTSYS/test/eventa.; We did not correct this time for the overhead coming from the interpreter itself. The Total time to read sample is the execution time of the script $ROOTSYS/test/eventb. This script loops on all events. For each event, the branch containing the number of tracks is read. In case the number of tracks is less than 585, the full event is read in memory. This test is obviously not possible in non-split mode. In non-split mode, the full event must be read in memory. The times reported in the table correspond to complete I/O operations necessary to deal with machine independent binary files. On Linux, this also includes byte-swapping operations. The ROOT file allows for direct access to any event in the file and direct access to any part of an event when split=1.; Note also that the uncompressed file generated with split=0 is 48.7 Mbytes and only 47.17 Mb",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:649683,benchmark,benchmark,649683,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['benchmark'],['benchmark']
Testability,"nchElement::Unroll(const char *name, TClass *cl, TStreamerInfo *sinfo, char* objptr, Int_t bufsize, Int_t splitlevel); 6079{; 6080 //; 6081 // Do we have a final dot in our name?; 6082 //; 6083 ; 6084 // Note: The branch constructor which takes a folder as input; 6085 // creates top-level branch names with dots in them to; 6086 // indicate the folder hierarchy.; 6087 char* dot = (char*) strchr(name, '.');; 6088 Int_t nch = strlen(name);; 6089 bool dotlast = false;; 6090 if (nch && (name[nch-1] == '.')) {; 6091 dotlast = true;; 6092 }; 6093 ; 6094 // Loop on all public data members of the class and its base classes and create branches for each one.; 6095 TObjArray* blist = this->GetListOfBranches();; 6096 TIter next(sinfo->GetElements());; 6097 TStreamerElement* element = nullptr;; 6098 TString bname;; 6099 for (Int_t id = 0; (element = (TStreamerElement*) next()); ++id) {; 6100 if (element->IsA() == TStreamerArtificial::Class()) {; 6101 continue;; 6102 }; 6103 if (element->TestBit(TStreamerElement::kRepeat)) {; 6104 continue;; 6105 }; 6106 if (element->TestBit(TStreamerElement::kCache) && !element->TestBit(TStreamerElement::kWrite)) {; 6107 continue;; 6108 }; 6109 char* pointer = (char*) (objptr + element->GetOffset());; 6110 // FIXME: This is not good enough, an STL container can be; 6111 // a base, and the test will fail.; 6112 // See TBranchElement::InitializeOffsets() for the; 6113 // correct test.; 6114 bool isBase = (element->IsA() == TStreamerBase::Class());; 6115 if (isBase) {; 6116 TClass* clbase = element->GetClassPointer();; 6117 if ((clbase == TObject::Class()) && cl->CanIgnoreTObjectStreamer()) {; 6118 // Note: TStreamerInfo::Compile() leaves this element; 6119 // out of the optimized info, although it does; 6120 // exists in the non-compiled and non-optimized info.; 6121 // FIXME: The test that TStreamerInfo::Compile() uses; 6122 // is element->GetType() < 0, so that is what; 6123 // we should do as well.; 6124 continue;; 6125 }; 6126 if (clbase->GetLi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TBranchElement_8cxx_source.html:228594,test,test,228594,doc/master/TBranchElement_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TBranchElement_8cxx_source.html,1,['test'],['test']
Testability,"nclude ""TFile.h""; 82#include ""TLeaf.h""; 83#include ""TEventList.h""; 84#include ""TH2.h""; 85#include ""TGraph.h""; 86#include ""TStyle.h""; 87#include ""TMatrixF.h""; 88#include ""TMatrixDSym.h""; 89#include ""TMultiGraph.h""; 90#include ""TPrincipal.h""; 91#include ""TMath.h""; 92#include ""TSystem.h""; 93#include ""TCanvas.h""; 94 ; 95const Int_t MinNoTrainingEvents = 10;; 96// const Int_t MinNoTestEvents = 1;; 97 ; 98ClassImp(TMVA::Factory);; 99 ; 100#define READXML kTRUE; 101 ; 102// number of bits for bitset; 103#define VIBITS 32; 104 ; 105////////////////////////////////////////////////////////////////////////////////; 106/// Standard constructor.; 107///; 108/// - jobname : this name will appear in all weight file names produced by the MVAs; 109/// - theTargetFile : output ROOT file; the test tree and all evaluation plots; 110/// will be stored here; 111/// - theOption : option string; currently: ""V"" for verbose; 112 ; 113TMVA::Factory::Factory(TString jobName, TFile *theTargetFile, TString theOption); 114 : Configurable(theOption), fTransformations(""I""), fVerbose(kFALSE), fVerboseLevel(kINFO), fCorrelations(kFALSE),; 115 fROC(kTRUE), fSilentFile(theTargetFile == nullptr), fJobName(jobName), fAnalysisType(Types::kClassification),; 116 fModelPersistence(kTRUE); 117{; 118 fName = ""Factory"";; 119 fgTargetFile = theTargetFile;; 120 fLogger->SetSource(fName.Data());; 121 ; 122 // render silent; 123 if (gTools().CheckForSilentOption(GetOptions())); 124 Log().InhibitOutput(); // make sure is silent if wanted to; 125 ; 126 // init configurable; 127 SetConfigDescription(""Configuration options for Factory running"");; 128 SetConfigName(GetName());; 129 ; 130 // histograms are not automatically associated with the current; 131 // directory and hence don't go out of scope when closing the file; 132 // TH1::AddDirectory(kFALSE);; 133 Bool_t silent = kFALSE;; 134#ifdef WIN32; 135 // under Windows, switch progress bar and color off by default, as the typical windows shell doesn't handle these; 13",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/tmva_2tmva_2src_2Factory_8cxx_source.html:3826,test,test,3826,doc/master/tmva_2tmva_2src_2Factory_8cxx_source.html,https://root.cern,https://root.cern/doc/master/tmva_2tmva_2src_2Factory_8cxx_source.html,1,['test'],['test']
Testability,"nclude ""TMVA/Reader.h""; #include ""TMVA/MethodCuts.h""; ; using namespace TMVA;; ; void TMVAClassificationApplication( TString myMethodList = """" ); {; ; //---------------------------------------------------------------; // This loads the library; TMVA::Tools::Instance();; ; // Default MVA methods to be trained + tested; std::map<std::string,int> Use;; ; // Cut optimisation; Use[""Cuts""] = 1;; Use[""CutsD""] = 1;; Use[""CutsPCA""] = 0;; Use[""CutsGA""] = 0;; Use[""CutsSA""] = 0;; //; // 1-dimensional likelihood (""naive Bayes estimator""); Use[""Likelihood""] = 1;; Use[""LikelihoodD""] = 0; // the ""D"" extension indicates decorrelated input variables (see option strings); Use[""LikelihoodPCA""] = 1; // the ""PCA"" extension indicates PCA-transformed input variables (see option strings); Use[""LikelihoodKDE""] = 0;; Use[""LikelihoodMIX""] = 0;; //; // Mutidimensional likelihood and Nearest-Neighbour methods; Use[""PDERS""] = 1;; Use[""PDERSD""] = 0;; Use[""PDERSPCA""] = 0;; Use[""PDEFoam""] = 1;; Use[""PDEFoamBoost""] = 0; // uses generalised MVA method boosting; Use[""KNN""] = 1; // k-nearest neighbour method; //; // Linear Discriminant Analysis; Use[""LD""] = 1; // Linear Discriminant identical to Fisher; Use[""Fisher""] = 0;; Use[""FisherG""] = 0;; Use[""BoostedFisher""] = 0; // uses generalised MVA method boosting; Use[""HMatrix""] = 0;; //; // Function Discriminant analysis; Use[""FDA_GA""] = 1; // minimisation of user-defined function using Genetics Algorithm; Use[""FDA_SA""] = 0;; Use[""FDA_MC""] = 0;; Use[""FDA_MT""] = 0;; Use[""FDA_GAMT""] = 0;; Use[""FDA_MCMT""] = 0;; //; // Neural Networks (all are feed-forward Multilayer Perceptrons); Use[""MLP""] = 0; // Recommended ANN; Use[""MLPBFGS""] = 0; // Recommended ANN with optional training method; Use[""MLPBNN""] = 1; // Recommended ANN with BFGS training method and bayesian regulator; Use[""CFMlpANN""] = 0; // Depreciated ANN from ALEPH; Use[""TMlpANN""] = 0; // ROOT's own ANN; Use[""DNN_CPU""] = 0; // CUDA-accelerated DNN training.; Use[""DNN_GPU""] = 0; // Multi-core accelerated DN",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVAClassificationApplication_8C.html:5283,test,tested,5283,doc/master/TMVAClassificationApplication_8C.html,https://root.cern,https://root.cern/doc/master/TMVAClassificationApplication_8C.html,1,['test'],['tested']
Testability,"nclude <exception>; 52#include <stdexcept>; 53#include <set>; 54 ; 55////////////////////////////////////////////////////////////////////////////////; 56/// create variable transformations; 57 ; 58namespace TMVA {; 59void CreateVariableTransforms(const TString& trafoDefinitionIn,; 60 TMVA::DataSetInfo& dataInfo,; 61 TMVA::TransformationHandler& transformationHandler,; 62 TMVA::MsgLogger& log); 63{; 64 TString trafoDefinition(trafoDefinitionIn);; 65 if (trafoDefinition == ""None"") return; // no transformations; 66 ; 67 // workaround for transformations to complicated to be handled by makeclass; 68 // count number of transformations with incomplete set of variables; 69 TString trafoDefinitionCheck(trafoDefinitionIn);; 70 int npartial = 0;; 71 for (Int_t pos = 0, siz = trafoDefinition.Sizeof(); pos < siz; ++pos) {; 72 TString ch = trafoDefinition(pos,1);; 73 if ( ch == ""("" ) npartial++;; 74 }; 75 if (npartial>1) {; 76 log << kWARNING; 77 << ""The use of multiple partial variable transformations during the ""; 78 ""application phase can be properly invoked via the \""Reader\"", but ""; 79 ""it is not yet implemented in \""MakeClass\"", the creation mechanism ""; 80 ""for standalone C++ application classes. The standalone C++ class ""; 81 ""produced by this training job is thus INCOMPLETE AND MUST NOT BE USED! ""; 82 ""The transformation in question is: "" << trafoDefinitionIn << Endl;; 83 // ToDo make info and do not write the standalone class; 84 //; 85 // this does not work since this function is static; 86 // fDisableWriting=true; // disable creation of stand-alone class; 87 // ToDo we need to tell the transformation that it cannot write itself; 88 }; 89 // workaround end; 90 ; 91 Int_t parenthesisCount = 0;; 92 for (Int_t position = 0, size = trafoDefinition.Sizeof(); position < size; ++position) {; 93 TString ch = trafoDefinition(position,1);; 94 if (ch == ""("") ++parenthesisCount;; 95 else if (ch == "")"") --parenthesisCount;; 96 else if (ch == "","" && parenthesisCount == 0) trafoDefin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/VariableTransform_8cxx_source.html:2939,log,log,2939,doc/master/VariableTransform_8cxx_source.html,https://root.cern,https://root.cern/doc/master/VariableTransform_8cxx_source.html,1,['log'],['log']
Testability,"ncrement bin content by 1. ; ; virtual voidAddBinContent (Int_t bin, Double_t w); Increment bin content by a weight w. ; ; virtual Double_tAndersonDarlingTest (const TH1 *h2, Double_t &advalue) const; Same function as above but returning also the test statistic value. ; ; virtual Double_tAndersonDarlingTest (const TH1 *h2, Option_t *option="""") const; Statistical test of compatibility in shape between this histogram and h2, using the Anderson-Darling 2 sample test. ; ; voidBrowse (TBrowser *b) override; Browse the Histogram object. ; ; virtual Int_tBufferEmpty (Int_t action=0); Fill histogram with all entries in the buffer. ; ; virtual Bool_tCanExtendAllAxes () const; Returns true if all axes are extendable. ; ; virtual Double_tChi2Test (const TH1 *h2, Option_t *option=""UU"", Double_t *res=nullptr) const; \( \chi^{2} \) test for comparing weighted and unweighted histograms. ; ; virtual Double_tChi2TestX (const TH1 *h2, Double_t &chi2, Int_t &ndf, Int_t &igood, Option_t *option=""UU"", Double_t *res=nullptr) const; The computation routine of the Chisquare test. ; ; virtual Double_tChisquare (TF1 *f1, Option_t *option="""") const; Compute and return the chisquare of this histogram with respect to a function The chisquare is computed by weighting each histogram point by the bin error By default the full range of the histogram is used. ; ; virtual voidClearUnderflowAndOverflow (); Remove all the content from the underflow and overflow bins, without changing the number of entries After calling this method, every undeflow and overflow bins will have content 0.0 The Sumw2 is also cleared, since there is no more content in the bins. ; ; TObject *Clone (const char *newname="""") const override; Make a complete copy of the underlying object. ; ; virtual Double_tComputeIntegral (Bool_t onlyPositive=false); Compute integral (normalized cumulative sum of bins) w/o under/overflows The result is stored in fIntegral and used by the GetRandom functions. ; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTH1.html:26107,test,test,26107,doc/master/classTH1.html,https://root.cern,https://root.cern/doc/master/classTH1.html,2,['test'],['test']
Testability,"nction documentation; CombinedCalculator(); {}. CombinedCalculator(RooAbsData& data, RooAbsPdf& pdf, const RooArgSet& paramsOfInterest, Double_t size = 0.050000000000000003, const RooArgSet* nullParams = 0, const RooArgSet* altParams = 0, const RooArgSet* nuisParams = 0). SetTestSize(Double_t size). CombinedCalculator(RooAbsData& data, const RooStats::ModelConfig& model, Double_t size = 0.050000000000000003); constructor from data and model configuration. SetModel(const RooStats::ModelConfig& model). virtual ~CombinedCalculator(); destructor. { }. ConfInterval* GetInterval() const; Main interface to get a ConfInterval, pure virtual. HypoTestResult* GetHypoTest() const; main interface to get a HypoTestResult, pure virtual. void SetConfidenceLevel(Double_t cl); set the confidence level for the interval (eg. 0.95 for a 95% Confidence Interval). {fSize = 1.-cl;}. Double_t Size() const; Get the size of the test (eg. rate of Type I error). {return fSize;}. Double_t ConfidenceLevel() const; Get the Confidence level for the test. {return 1.-fSize;}. void SetData(RooAbsData& data); Set the DataSet, add to the the workspace if not already there. void SetNullModel(const RooStats::ModelConfig& ). void SetAlternateModel(const RooStats::ModelConfig& ). void SetPdf(RooAbsPdf& pdf); specific setting - keep for convenience- some of them could be removed; Set the Pdf. { fPdf = &pdf; }. void SetParameters(const RooArgSet& set); specify the parameters of interest in the interval. { fPOI.removeAll(); fPOI.add(set); }. void SetNuisanceParameters(const RooArgSet& set); specify the nuisance parameters (eg. the rest of the parameters). {fNuisParams.removeAll(); fNuisParams.add(set);}. void SetNullParameters(const RooArgSet& set); set parameter values for the null if using a common PDF. {fNullParams.removeAll(); fNullParams.add(set);}. void SetAlternateParameters(const RooArgSet& set); set parameter values for the alternate if using a common PDF. {fAlternateParams.removeAll(); fAlternateParam",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooStats__CombinedCalculator.html:5756,test,test,5756,root/html602/RooStats__CombinedCalculator.html,https://root.cern,https://root.cern/root/html602/RooStats__CombinedCalculator.html,2,['test'],['test']
Testability,"nction members; data members; class charts. ROOT;  GUI;  GUI;  TGPasswdDialog. class TGPasswdDialog. TGPasswdDialog. Graphic dialog to enter passwords. Usage:. {; Buffer for the passwd; char pwdbuf[128]. Open the dialog box; TGPasswdDialog dialog(""My prompt"", pwdbuf, 128);. Wait until the user is done; while (gROOT->IsInterrupted()); gSystem->DispatchOneEvent(kFALSE);. Password is now in pwdbuf. }. Function Members (Methods); public:. TGPasswdDialog(const TGPasswdDialog&); TGPasswdDialog(const char* prompt, char* pwdbuf, Int_t pwdlenmax, UInt_t w = 400, UInt_t h = 400); virtual~TGPasswdDialog(); static TClass*Class(); voidCloseWindow(); voidDoClose(); virtual TClass*IsA() const; TGPasswdDialog&operator=(const TGPasswdDialog&); voidReturnPressed(); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Data Members; private:. TGTransientFrame*fDialogmain frame of this widget; TGTextButton*fOkOk button; TGTextEntry*fPasswdPassword TextEntry; TGTextBuffer*fPasswdTextPasswd Buffer; char*fPwdBufbuffer where to store the passwd; Int_tfPwdLenMaxpasswd buffer length. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGPasswdDialog(const char* prompt, char* pwdbuf, Int_t pwdlenmax, UInt_t w = 400, UInt_t h = 400); Create an editor in a dialog. ~TGPasswdDialog(); Delete log window. void DoClose(); Handle close button. void CloseWindow(); Called when closed via window manager action. void ReturnPressed(); Handle return. TGPasswdDialog(const char* prompt, char* pwdbuf, Int_t pwdlenmax, UInt_t w = 400, UInt_t h = 400).  Author: G. Ganis 10/10/2005  Copyright (C) 1995-2005, Rene Brun and Fons Rademakers. *;  Last changed: root/gui:$Id: TGPasswdDialog.h 23115 2008-04-10 13:35:37Z rdm $  Last generated: 2010-09-23 20:07; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGPasswdDialog.html:1568,log,log,1568,root/html528/TGPasswdDialog.html,https://root.cern,https://root.cern/root/html528/TGPasswdDialog.html,1,['log'],['log']
Testability,"nction members; data members; class charts. ROOT;  GUI;  GUI;  TGPasswdDialog. class TGPasswdDialog. TGPasswdDialog. Graphic dialog to enter passwords. Usage:. {; Buffer for the passwd; char pwdbuf[128]. Open the dialog box; TGPasswdDialog dialog(""My prompt"", pwdbuf, 128);. Wait until the user is done; while (gROOT->IsInterrupted()); gSystem->DispatchOneEvent(kFALSE);. Password is now in pwdbuf. }. Function Members (Methods); public:. TGPasswdDialog(const TGPasswdDialog&); TGPasswdDialog(const char* prompt, char* pwdbuf, Int_t pwdlenmax, UInt_t w = 400, UInt_t h = 400); virtual~TGPasswdDialog(); static TClass*Class(); voidCloseWindow(); voidDoClose(); virtual TClass*IsA() const; TGPasswdDialog&operator=(const TGPasswdDialog&); voidReturnPressed(); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Data Members; private:. TGTransientFrame*fDialogmain frame of this widget; TGTextButton*fOkOk button; TGTextEntry*fPasswdPassword TextEntry; TGTextBuffer*fPasswdTextPasswd Buffer; char*fPwdBufbuffer where to store the passwd; Int_tfPwdLenMaxpasswd buffer length. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGPasswdDialog(const char* prompt, char* pwdbuf, Int_t pwdlenmax, UInt_t w = 400, UInt_t h = 400); Create an editor in a dialog. ~TGPasswdDialog(); Delete log window. void DoClose(); Handle close button. void CloseWindow(); Called when closed via window manager action. void ReturnPressed(); Handle return. TGPasswdDialog(const char* prompt, char* pwdbuf, Int_t pwdlenmax, UInt_t w = 400, UInt_t h = 400).  Author: G. Ganis 10/10/2005  Copyright (C) 1995-2005, Rene Brun and Fons Rademakers. *;  Last changed: root/gui:$Id: TGPasswdDialog.h 23115 2008-04-10 13:35:37Z rdm $  Last generated: 2011-07-04 15:30; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TGPasswdDialog.html:1568,log,log,1568,root/html530/TGPasswdDialog.html,https://root.cern,https://root.cern/root/html530/TGPasswdDialog.html,1,['log'],['log']
Testability,"nction members; data members; class charts. ROOT;  GUI;  GUI;  TGPasswdDialog. class TGPasswdDialog. TGPasswdDialog. Graphic dialog to enter passwords. Usage:. {; Buffer for the passwd; char pwdbuf[128]. Open the dialog box; TGPasswdDialog dialog(""My prompt"", pwdbuf, 128);. Wait until the user is done; while (gROOT->IsInterrupted()); gSystem->DispatchOneEvent(kFALSE);. Password is now in pwdbuf. }. Function Members (Methods); public:. TGPasswdDialog(const TGPasswdDialog&); TGPasswdDialog(const char* prompt, char* pwdbuf, Int_t pwdlenmax, UInt_t w = 400, UInt_t h = 400); virtual~TGPasswdDialog(); static TClass*Class(); voidCloseWindow(); voidDoClose(); virtual TClass*IsA() const; TGPasswdDialog&operator=(const TGPasswdDialog&); voidReturnPressed(); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Data Members; private:. TGTransientFrame*fDialogmain frame of this widget; TGTextButton*fOkOk button; TGTextEntry*fPasswdPassword TextEntry; TGTextBuffer*fPasswdTextPasswd Buffer; char*fPwdBufbuffer where to store the passwd; Int_tfPwdLenMaxpasswd buffer length. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGPasswdDialog(const char* prompt, char* pwdbuf, Int_t pwdlenmax, UInt_t w = 400, UInt_t h = 400); Create an editor in a dialog. ~TGPasswdDialog(); Delete log window. void DoClose(); Handle close button. void CloseWindow(); Called when closed via window manager action. void ReturnPressed(); Handle return. TGPasswdDialog(const char* prompt, char* pwdbuf, Int_t pwdlenmax, UInt_t w = 400, UInt_t h = 400).  Author: G. Ganis 10/10/2005  Copyright (C) 1995-2005, Rene Brun and Fons Rademakers. *;  Last changed: root/gui:$Id: TGPasswdDialog.h 23115 2008-04-10 13:35:37Z rdm $  Last generated: 2011-11-03 20:15; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGPasswdDialog.html:1568,log,log,1568,root/html532/TGPasswdDialog.html,https://root.cern,https://root.cern/root/html532/TGPasswdDialog.html,1,['log'],['log']
Testability,"nction to create background efficiency (rejection) versus signal efficiency plot (first ...Definition MethodCuts.cxx:1442; TMVA::MethodCuts::HasAnalysisTypevirtual Bool_t HasAnalysisType(Types::EAnalysisType type, UInt_t numberClasses, UInt_t numberTargets)Cuts can only handle classification with 2 classes.Definition MethodCuts.cxx:211; TMVA::MethodCuts::ProcessOptionsvoid ProcessOptions()process user options.Definition MethodCuts.cxx:363; TMVA::MethodCuts::WriteMonitoringHistosToFilevoid WriteMonitoringHistosToFile(void) constwrite histograms and PDFs to file for monitoring purposesDefinition MethodCuts.cxx:1411; TMVA::MethodCuts::EEffMethodEEffMethodDefinition MethodCuts.h:157; TMVA::MethodCuts::MatchParsToCutsvoid MatchParsToCuts(const std::vector< Double_t > &, Double_t *, Double_t *)translates parameters into cutsDefinition MethodCuts.cxx:974; TMVA::MethodCuts::~MethodCutsvirtual ~MethodCuts(void)destructorDefinition MethodCuts.cxx:270; TMVA::MethodCuts::TestClassificationvoid TestClassification()nothing to testDefinition MethodCuts.cxx:827; TMVA::MethodCuts::EFitMethodTypeEFitMethodTypeDefinition MethodCuts.h:146; TMVA::MethodCuts::ReadWeightsFromXMLvoid ReadWeightsFromXML(void *wghtnode)read coefficients from xml weight fileDefinition MethodCuts.cxx:1327; TMVA::MethodCuts::GetEffsfromPDFsvoid GetEffsfromPDFs(Double_t *cutMin, Double_t *cutMax, Double_t &effS, Double_t &effB)compute signal and background efficiencies from PDFs for given cut sampleDefinition MethodCuts.cxx:1023; TMVA::MethodCuts::GetCutsDouble_t GetCuts(Double_t effS, std::vector< Double_t > &cutMin, std::vector< Double_t > &cutMax) constretrieve cut values for given signal efficiencyDefinition MethodCuts.cxx:551; TMVA::MethodCuts::PrintCutsvoid PrintCuts(Double_t effS) constprint cutsDefinition MethodCuts.cxx:465; TMVA::MinuitFitter/Fitter using MINUITDefinition MinuitFitter.h:48; TMVA::PDFPDF wrapper for histograms; uses user-defined spline interpolation.Definition PDF.h:63; TMVA::PDF::kSpline",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/MethodCuts_8cxx_source.html:82029,test,testDefinition,82029,doc/master/MethodCuts_8cxx_source.html,https://root.cern,https://root.cern/doc/master/MethodCuts_8cxx_source.html,1,['test'],['testDefinition']
Testability,"nction will return; only when an incoming TERMINATE message is received. void calculate() const; Client-side function that instructs server process to start; asynchronuous (re)calculation of function value. This function; returns immediately. The calculated value can be retrieved; using getVal(). Double_t getValV(const RooArgSet* nset = 0) const; If value needs recalculation and calculation has not beed started; with a call to calculate() start it now. This function blocks; until remote process has finished calculation and returns; remote value. Double_t evaluate() const; Send message to server process to retrieve output value; If error were logged use logEvalError() on remote side; transfer those errors to the local eval error queue. void standby(); Terminate remote server process and return front-end class; to standby mode. Calls to calculate() or evaluate() after; this call will automatically recreated the server process. void constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTracking = kTRUE); Intercept call to optimize constant term in test statistics; and forward it to object on server side. void setVerbose(Bool_t clientFlag = kTRUE, Bool_t serverFlag = kTRUE); Control verbose messaging related to inter process communication; on both client and server side. void applyNLLWeightSquared(Bool_t flag); Control verbose messaging related to inter process communication; on both client and server side. void doApplyNLLW2(Bool_t flag). void enableOffsetting(Bool_t flag); Control verbose messaging related to inter process communication; on both client and server side. TObject* clone(const char* newname) const; { return new RooRealMPFE(*this,newname); }. void followAsSlave(RooRealMPFE& master); { _updateMaster = &master ; }.  Last changed: Tue Jun 2 15:33:24 2015  Last generated: 2015-06-02 15:33; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/RooRealMPFE.html:41301,test,test,41301,root/html604/RooRealMPFE.html,https://root.cern,https://root.cern/root/html604/RooRealMPFE.html,1,['test'],['test']
Testability,"nction.; -fitTaylor - order of Taylor expansion, possible values kFitTaylorOrderFirst, kFitTaylorOrderSecond. It applies only for Awmi fitting function. void SetPeakParameters(Double_t sigmaX, Bool_t fixSigmaX, Double_t sigmaY, Bool_t fixSigmaY, Double_t ro, Bool_t fixRo, const Float_t* positionInitX, const Bool_t* fixPositionX, const Float_t* positionInitY, const Bool_t* fixPositionY, const Float_t* positionInitX1, const Bool_t* fixPositionX1, const Float_t* positionInitY1, const Bool_t* fixPositionY1, const Float_t* ampInit, const Bool_t* fixAmp, const Float_t* ampInitX1, const Bool_t* fixAmpX1, const Float_t* ampInitY1, const Bool_t* fixAmpY1). SETTER FUNCTION. This function sets the following fitting parameters of peaks:; -sigmaX - initial value of sigma x parameter; -fixSigmaX - logical value of sigma x parameter, which allows to fix the parameter (not to fit); -sigmaY - initial value of sigma y parameter; -fixSigmaY - logical value of sigma y parameter, which allows to fix the parameter (not to fit); -ro - initial value of ro parameter (correlation coefficient); -fixRo - logical value of ro parameter, which allows to fix the parameter (not to fit); -positionInitX - aray of initial values of peaks x positions; -fixPositionX - array of logical values which allow to fix appropriate x positions (not fit). However they are present in the estimated functional.; -positionInitY - aray of initial values of peaks y positions; -fixPositionY - array of logical values which allow to fix appropriate y positions (not fit). However they are present in the estimated functional.; -ampInit - aray of initial values of 2D peaks amplitudes; -fixAmp - aray of logical values which allow to fix appropriate amplitudes of 2D peaks (not fit). However they are present in the estimated functional; -ampInitX1 - aray of initial values of amplitudes of 1D ridges in x direction; -fixAmpX1 - aray of logical values which allow to fix appropriate amplitudes of 1D ridges in x direction (not fit). ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TSpectrum2Fit.html:64601,log,logical,64601,root/html528/TSpectrum2Fit.html,https://root.cern,https://root.cern/root/html528/TSpectrum2Fit.html,16,['log'],['logical']
Testability,"nction>fObjFunction! pointer to used objective function; auto_ptr<ROOT::Fit::FitResult>fResult! pointer to the object containing the result of the fit; boolfUseGradientflag to indicate if using gradient or not. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; bool FitFCN(ROOT::Fit::Fitter::MinuitFCN_t fcn, int npar = 0, const double* params = 0, unsigned int dataSize = 0, bool chi2fit = false). Fitter(). Default constructor. ~Fitter(). Destructor. Fitter(const ROOT::Fit::Fitter& ). Copy constructor (disabled, class is not copyable). bool Fit( const Data & data, const Function & func). fit a data set using any generic model function; Pre-requisite on the function:. SetFunction(func). return Fit(data). bool Fit(const BinData & data). fit a binned data set (default method: use chi2); To be implemented option to do likelihood bin fit. return DoLeastSquareFit(const ROOT::Fit::BinData& data). bool Fit(const UnBinData & data). fit an binned data set using loglikelihood method. return DoLikelihoodFit(data). bool LikelihoodFit(const Data & data). Likelihood fit. return DoLikelihoodFit(data). bool LikelihoodFit( const Data & data, const Function & func). fit a data set using any generic model function; Pre-requisite on the function:. SetFunction(func). bool FitFCN(ROOT::Fit::Fitter::MinuitFCN_t fcn, int npar = 0, const double* params = 0, unsigned int dataSize = 0, bool chi2fit = false). Fit using the a generic FCN function as a C++ callable object implementing; double () (const double *); Note that the function dimension (i.e. the number of parameter) is needed in this case; For the options see documentation for following methods FitFCN(IMultiGenFunction & fcn,..). bool FitFCN(const ROOT::Math::IMultiGenFunction& fcn, const double* params = 0, unsigned int dataSize = 0, bool chi2fit = false). Fit using the given FCN function represented by a multi-dimensional function interface; (ROOT::Math::IMultiGenFunction).; Give optionally the in",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/ROOT__Fit__Fitter.html:4150,log,loglikelihood,4150,root/html528/ROOT__Fit__Fitter.html,https://root.cern,https://root.cern/root/html528/ROOT__Fit__Fitter.html,1,['log'],['loglikelihood']
Testability,"nctions inherited from TGWidget; TGWidget (const TGWidget &tgw); ; Int_tClearFlags (Int_t flags); ; TGWidget &operator= (const TGWidget &tgw); ; Int_tSetFlags (Int_t flags); . Protected Attributes; Bool_tfConstrained; kTRUE if pointer is constrained to slider edges ; ; Int_tfCz; horizontal pointer position in pixel coordinates ; ; const TGPicture *fPointerPic; picture to draw pointer ; ; Bool_tfRelative; kTRUE if pointer position is relative to slider ; ; Double_tfSCz; vertical pointer position ; ; Protected Attributes inherited from TGDoubleHSlider; Int_tfXp; horizontal slider x position in pixel coordinates ; ; Protected Attributes inherited from TGDoubleSlider; Bool_tfMarkEnds; lines marking where stretch zones begin ; ; Int_tfMove; 1: move min value 2: move max value 3: move min and max value 0: don't move any value ; ; Double_tfPos; logical position between fVmin and fVmax ; ; Int_tfPressPoint; mouse position at button press event ; ; Double_tfPressSmax; logical max position at button press event ; ; Double_tfPressSmin; logical min position at button press event ; ; Int_tfRelPos; slider position in pixel coordinates ; ; Bool_tfReversedScale; reverse which end is min and max ; ; Int_tfScale; tick mark scale ; ; Int_tfScaleType; tick mark scale type (no, downright, both) ; ; const TGPicture *fSliderPic; picture to draw slider ends ; ; Double_tfSmax; logical position of max value of Slider ; ; Double_tfSmin; logical position of min value of Slider ; ; Double_tfVmax; logical upper limit of slider ; ; Double_tfVmin; logical lower limit of slider ; ; Protected Attributes inherited from TGFrame; Pixel_tfBackground; frame background color ; ; Int_tfBorderWidth; frame border width ; ; Int_tfDNDState; EDNDFlags. ; ; UInt_tfEventMask; currently active event mask ; ; TGFrameElement *fFE; pointer to frame element ; ; UInt_tfHeight; frame height ; ; UInt_tfMaxHeight; maximal frame he",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGTripleHSlider.html:28828,log,logical,28828,doc/master/classTGTripleHSlider.html,https://root.cern,https://root.cern/doc/master/classTGTripleHSlider.html,7,['log'],['logical']
Testability,"nctions using in Fit for evaluating the various fit method functions (chi2, likelihood, etc..) given the data and the model function ; NHFitInterface; NGLTutorials; NInternal; NExecutorUtils; NRDF; NSHA256; NTDS; NTThreadedObjectUtils; NMacOSX; NDetails; NOpenGL; NUtil; NX11; NDetail; NMath; NBlas; NBrentMethods; NCephes; NChebyshevTemplate recursive functions for defining evaluation of Chebyshev polynomials T_n(x) and the series S(x) = Sum_i c_i* T_i(x) ; NCholeskyDecompHelpersHelpers for CholeskyDecomp ; Ndetail; NGenAlgoOptUtil; NGenVector; NGenVector_detail; NGSLRootHelperHelper functions to test convergence of Root-Finding algorithms ; NGSLSimAn; Ngv_detail; NImpl; NIntegMultiDim; NIntegOneDim; NIntegOptionsUtil; NIntegration; NIntegrationMultiDim; NIntegrationOneDim; NInternal; NInterpolation; NMCIntegration; NMinim; NMinim1D; NRootsRoot-Finding Algorithms ; NrowOffsetsUtils; NSampler; NUtilNamespace defining Utility functions needed by mathcore ; NVectorUtilGlobal Helper functions for generic Vector classes ; NMathMore; NMeta; NSelection; NMinuit; NMinuit2; NQuartz; NRNamespace associated R package for ROOT ; NRDF; NTF1Helper; NTMetaUtils; NTreeUtils; NTThreadedObjectUtils; NTypeTraitsROOT type_traits extensions ; Nv5; NTFastFun; NVecOps; Nrootmarks; NROOTwriter; Nshapes; Nsqlcreatedb; Nsqlfilldb; Nsqlio; Nsqlselect; Nstaff; NstdSTL namespace ; N__ROOT; NDetail; Nsurfaces; Ntbb; NTClassEdit; Ntest; NTGeoUnit; NtimeSeriesFromCSV; NTMathTMath ; NTMatrixTCramerInv; NTMatrixTSymCramerInv; NTMVAAbstract ClassifierFactory template that handles arbitrary types ; NDNN; NBlas; NCNN; NRNN; NExperimental; NkNN; NTMVAGlob; Ntornado; Ntree; NTStreamerInfoActions; NtStudent; Ntwoscales; Nvecgeom; Ncxx; Nvo001_AdoptOrOwnMemory; Nwriter; Nxmlio; NXPD; NXrdCl; Nzdemo; Nzones. ROOT 6.14/05 - Reference Guide Generated on Fri Nov 2 2018 11:01:27 (GVA Time) using Doxygen",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v614/namespaces.html:3107,test,test,3107,doc/v614/namespaces.html,https://root.cern,https://root.cern/doc/v614/namespaces.html,1,['test'],['test']
Testability,nctor class. More...; ; class Functor1D; Functor1D class for one-dimensional functions. More...; ; class GaussIntegrator; User class for performing function integration. More...; ; class GaussLegendreIntegrator; User class for performing function integration. More...; ; class GenAlgoOptions; class implementing generic options for a numerical algorithm Just store the options in a map of string-value pairs More...; ; struct GeneralHessianCalc; ; struct GeneralHessianCalc< double >; ; struct GeneralLinearFunctionDerivation; Auxiliar class to bypass the (provisional) lack of vectorization in TFormula::EvalPar. More...; ; struct GeneralLinearFunctionDerivation< double >; ; class GeneticMinimizer; GeneticMinimizer. More...; ; struct GeneticMinimizerParameters; ; class GenVector_exception; ; class GlobalCoordinateSystemTag; Tag for identifying vectors based on a global coordinate system. More...; ; class GoFTest; GoFTest class implementing the 1 sample and 2 sample goodness of fit tests for uni-variate distributions and data. More...; ; class GradFunctor; GradFunctor class for Multidimensional gradient functions. More...; ; class GradFunctor1D; GradFunctor1D class for one-dimensional gradient functions. More...; ; class GSL1DMinimizerWrapper; wrapper class for gsl_min_fminimizer structure More...; ; class GSLChebSeries; wrapper class for C struct gsl_cheb_series More...; ; class GSLDerivator; Class for computing numerical derivative of a function based on the GSL numerical algorithm This class is implemented using the numerical derivatives algorithms provided by GSL (see GSL Online Manual ). More...; ; class GSLError; class to change GSL Error handler to use ROOT one. More...; ; class GSLFunctionAdapter; Class for adapting any C++ functor class to C function pointers used by GSL. More...; ; class GSLFunctionDerivWrapper; class to wrap a gsl_function_fdf (with derivatives) More...; ; class GSLFunctionWrapper; Wrap,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/namespaceROOT_1_1Math.html:8520,test,tests,8520,doc/master/namespaceROOT_1_1Math.html,https://root.cern,https://root.cern/doc/master/namespaceROOT_1_1Math.html,2,['test'],['tests']
Testability,"ncy known. ; Definition at line 1243 of file TRolke.cxx. LikeMod5(). Double_t TRolke::LikeMod5 ; (; Double_t; mu, . Double_t; b, . Int_t; x, . Double_t; bm, . Double_t; u. ). private . Profile Likelihood function for MODEL 5: Gauss background/Efficiency known. ; Definition at line 1288 of file TRolke.cxx. LikeMod6(). Double_t TRolke::LikeMod6 ; (; Double_t; mu, . Double_t; b, . Double_t; e, . Int_t; x, . Int_t; z, . Int_t; m. ). private . Profile Likelihood function for MODEL 6: background known/ Efficiency binomial. ; Definition at line 1343 of file TRolke.cxx. LikeMod7(). Double_t TRolke::LikeMod7 ; (; Double_t; mu, . Double_t; b, . Double_t; e, . Int_t; x, . Double_t; em, . Double_t; v. ). private . Profile Likelihood function for MODEL 6: background known/ Efficiency gaussian. ; Definition at line 1398 of file TRolke.cxx. LogFactorial(). Double_t TRolke::LogFactorial ; (; Int_t; n). private . LogFactorial function (use the logGamma function via the relation Gamma(n+1) = n! ; Definition at line 1449 of file TRolke.cxx. Print(). void TRolke::Print ; (; Option_t *; ); const. overridevirtual . Dump internals. Print members. ; Reimplemented from TObject.; Definition at line 594 of file TRolke.cxx. ProfLikeMod1(). void TRolke::ProfLikeMod1 ; (; Double_t; mu, . Double_t &; b, . Double_t &; e, . Int_t; x, . Int_t; y, . Int_t; z, . Double_t; tau, . Int_t; m. ). private . Helper for calculation of estimates of efficiency and background for model 1. ; Definition at line 1030 of file TRolke.cxx. SetBounding(). void TRolke::SetBounding ; (; const bool; bnd). inline . Definition at line 184 of file TRolke.h. SetCL(). void TRolke::SetCL ; (; Double_t; CL). inline . Definition at line 124 of file TRolke.h. SetCLSigmas(). void TRolke::SetCLSigmas ; (; Double_t; CLsigmas). inline . Definition at line 129 of file TRolke.h. SetGaussBkgGaussEff(). void TRolke::SetGaussBkgGaussEff ; (; Int_t; x, . Double_t; bm, . Double_t; em, ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTRolke.html:36138,log,logGamma,36138,doc/master/classTRolke.html,https://root.cern,https://root.cern/doc/master/classTRolke.html,1,['log'],['logGamma']
Testability,"nd Fons Rademakers. *; 6 * All rights reserved. *; 7 * *; 8 * For the licensing terms see $ROOTSYS/LICENSE. *; 9 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 10 *************************************************************************/; 11 ; 12/** \class TVirtualFFT; 13\ingroup Base; 14 ; 15TVirtualFFT is an interface class for Fast Fourier Transforms.; 16 ; 17The default FFT library is FFTW. To use it, FFTW3 library should already; 18be installed, and ROOT should be have fftw3 module enabled, with the directories; 19of fftw3 include file and library specified (see installation instructions).; 20Function SetDefaultFFT() allows to change the default library.; 21 ; 22## Available transform types:; 23FFT:; 24 - ""C2CFORWARD"" - a complex input/output discrete Fourier transform (DFT); 25 in one or more dimensions, -1 in the exponent; 26 - ""C2CBACKWARD""- a complex input/output discrete Fourier transform (DFT); 27 in one or more dimensions, +1 in the exponent; 28 - ""R2C"" - a real-input/complex-output discrete Fourier transform (DFT); 29 in one or more dimensions,; 30 - ""C2R"" - inverse transforms to ""R2C"", taking complex input; 31 (storing the non-redundant half of a logically Hermitian array); 32 to real output; 33 - ""R2HC"" - a real-input DFT with output in halfcomplex format,; 34 i.e. real and imaginary parts for a transform of size n stored as; 35 r0, r1, r2, ..., rn/2, i(n+1)/2-1, ..., i2, i1; 36 - ""HC2R"" - computes the reverse of FFTW_R2HC, above; 37 - ""DHT"" - computes a discrete Hartley transform; 38 ; 39## Sine/cosine transforms:; 40Different types of transforms are specified by parameter kind of the SineCosine() static; 41function. 4 different kinds of sine and cosine transforms are available; 42 ; 43 - DCT-I (REDFT00 in FFTW3 notation)- kind=0; 44 - DCT-II (REDFT01 in FFTW3 notation)- kind=1; 45 - DCT-III(REDFT10 in FFTW3 notation)- kind=2; 46 - DCT-IV (REDFT11 in FFTW3 notation)- kind=3; 47 - DST-I (RODFT00 in FFTW3 notation)- kind=4; 48 - DST-",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TVirtualFFT_8cxx_source.html:1564,log,logically,1564,doc/master/TVirtualFFT_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TVirtualFFT_8cxx_source.html,1,['log'],['logically']
Testability,nd and communicate best axis limits; TProofLite PROOF-Lite control class; TProofLog PROOF session log handler; TProofLogElem PROOF session log element; TProofMgr Abstract PROOF manager interface; TProofMgrLite XrdProofd PROOF manager interface; TProofMonSender Interface for PROOF monitoring; TProofMonSenderML Interface for PROOF monitoring; TProofMonSenderSQL Interface for PROOF monitoring; TProofNodeInfo Class describing a PROOF node; TProofNodes Node and worker information; TProofOutputFile Wrapper class to steer the merging of files produced on workers; TProofOutputList Output list specific TList derivation; TProofPlayer Basic PROOF player; TProofPlayerLite PROOF player running in PROOF-Lite; TProofPlayerLocal PROOF player running on client; TProofPlayerRemote PROOF player running on master server; TProofPlayerSlave PROOF player running on slave server; TProofPlayerSuperMaster PROOF player running on super master; TProofProgressDialog PROOF progress dialog; TProofProgressInfo Progress information; TProofProgressLog Class implementing a log graphic box; TProofProgressMemoryPlot PROOF progress memory plots; TProofProgressStatus Proof progress status class; TProofQueryResult Class describing a PROOF query; TProofResources Abstract class describing PROOF resources; TProofResourcesStatic Class to handle PROOF static config; TProofServ PROOF Server Application Interface; TProofServLite PROOF-Lite Server Application Interface; TProofSuperMaster PROOF control class for making submasters; TProofVectorContainer<TProofDrawListOfGraphs::Point3D_t> Class describing a vector container; TProofVectorContainer<TProofDrawListOfPolyMarkers3D::Point4D_t> Class describing a vector container; TPyDispatcher Python dispatcher class; TPyMultiGenFunction Python for Math::IMultiGenFunction equivalent; TPyMultiGradFunction Python for Math::IMultiGradFunction equivalent; TPyReturn Python morphing return object; TPySelector Python equivalent base class for PROOF; TPythia6 Interface to Pythia6.,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/ClassIndex.html:119127,log,log,119127,root/html532/ClassIndex.html,https://root.cern,https://root.cern/root/html532/ClassIndex.html,1,['log'],['log']
Testability,"nd convenient way multi-dimensional function objects. It can wrap all the following types: * Any C++ callable object implementing double operator()( const double * ). * A free C function of type double ()(const double * ). * A member function with the correct signature like Foo::Eval(const double * ). In this case one pass the object pointer and a pointer to the member function (&Foo::Eval).; The function dimension is required when constructing the functor.; Example of using Functor:; #include ""Math/Functor.h"". class MyFunction {. public:; double operator()(const double *x) const {; return x[0]+x[1];; }. double Eval(const double * x) const { return x[0]+x[1]; }; };. double freeFunction(const double * x ); {; return x[0]+x[1];; }. int main(); {; // test directly calling the function object; MyFunction myf;. // test from a free function pointer; ROOT::Math::Functor f1(&freeFunction,2);. // test from function object; ROOT::Math::Functor f2(myf,2);. // test from a member function; ROOT::Math::Functor f3(&myf,&MyFunction::Eval,2);. double x[] = {1,2};. cout << f1(x) << endl;; cout << f2(x) << endl;; cout << f3(x) << endl;. return 0;; }; 13.7.4.4 Wrapping Multi-dimensional Gradient Functions; The class ROOT::Math::GradFunctor is used to wrap in a very C++ callable object to make gradient functions. It can be constructed in three different way: * From an object implementing both double operator()( const double * ) for the function evaluation and double Derivative(const double *, int icoord) for the partial derivatives. * From an object implementing any member function like Foo::XXX(const double *) for the function evaluation and any member function like Foo::XXX(const double *, int icoord) for the partial derivatives. * From an function object implementing double operator()( const double * ) for the function evaluation and another function object implementing double operator() (const double *, int icoord) for the partial derivatives.; The function dimension is required when",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:697349,test,test,697349,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['test'],['test']
Testability,"nd instruct it to split the object with this command (from the UNIX command line).; > $ROOTSYS/test/Event 400 1 2 1; This creates an Event.root file with 400 events, compressed, split, and filled.; See $ROOTSYS/test/MainEvent.cxx for more info.; The person who designed the tree makes a shared library available to you, which defines the classes needed. In this case, the classes are Event, EventHeader, and Track and they are defined in the shared library libEvent.so. The designer also gives you the Event.h file to see the definition of the classes. You can locate Event.h in $ROOTSYS/test, and if you have not yet built libEvent.so, please see the instructions of how to build it (typing make in $ROOTSYS/test is enough). If you have already built it, you can now use it again.; 12.21.1 Creating a Class with MakeClass; First, we load the shared library and open Event.root.; root[] .L libEvent.so; root[] TFile *f = new TFile(""Event.root"");; root[] f->ls();; TFile** Event.root TTree benchmark ROOT file; TFile* Event.root TTree benchmark ROOT file; KEY: TH1F htime;1 Real-Time to write versus time; KEY: TTree T;1 An example of a ROOT tree; We can see there is a tree T, and just to verify that we are working with the correct one, we print the tree, which will show us the header and branches.; root[] T->Print();; From the output of print we can see that the tree has one branch for each data member of Event, Track, and EventHeader. Now we can use TTree::MakeClass on our tree T. MakeClass takes one parameter, a string containing the name of the class to be made. In the command below, the name of our class will be MyClass.; root[] T->MakeClass(""MyClass""); Files: MyClass.h and MyClass.C generated from Tree: T; Cling informs us that it has created two files. MyClass.h contains the class definition and MyClass.C contains the MyClass::Loop() method. MyClass has more methods than just Loop(). The other methods are a constructor, a destructor, GetEntry(), LoadTree(), Notify(), Cut()",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:635905,benchmark,benchmark,635905,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['benchmark'],['benchmark']
Testability,"nd its RMS for each cell in X,Y,Z ; CTProfileHelper; CTProofThis class controls a Parallel ROOT Facility, PROOF, cluster ; CMD5Mod_t; CTProofBenchSteering class for PROOF benchmarks ; CTProofBenchDataSetHandle operations on datasets used by ProofBench ; CTProofBenchRunAbstract base class for PROOF benchmark runs ; CTProofBenchRunCPUCPU-intensive PROOF benchmark test generates events and fill 1, 2, or 3-D histograms ; CTProofBenchRunDataReadI/O-intensive PROOF benchmark test reads in event files distributed on the cluster ; CTProofChain; CTProofCondor; CTProofDebug; CTProofDesc; CTProofDrawImplement Tree drawing using PROOF ; CTProofDrawEntryList; CTProofDrawEventList; CTProofDrawGraph; CTProofDrawHist; CTProofDrawListOfGraphs; CPoint3D_t; CTProofDrawListOfPolyMarkers3D; CPoint4D_t; CTProofDrawPolyMarker3D; CTProofDrawProfile; CTProofDrawProfile2D; CTProofInputHandler; CTProofInterruptHandler; CTProofLimitsFinderClass to find axis limits and synchronize them between workers ; CTProofLiteThis class starts a PROOF session on the local machine: no daemons, client and master merged, communications via UNIX-like sockets ; CTProofLockPath; CTProofLockPathGuard; CTProofLogImplementation of the PROOF session log handler ; CTProofLogElem; CTProofMergePrg; CTProofMgrThe PROOF manager interacts with the PROOF server coordinator to create or destroy a PROOF session, attach to or detach from existing one, and to monitor any client activity on the cluster ; CTProofMgrLiteBasic TProofMgr functionality implementation in the case of Lite session ; CTProofMonSenderProvides the interface for PROOF monitoring to different writers ; CTDSetPlet; CTProofMonSenderMLTProofMonSender implementation for the ML writer ; CTProofMonSenderSQLTProofMonSender implementation for the SQL writers ; CTProofNodeInfoThe purpose of this class is to provide a complete node description for masters, submasters and workers ; CTProofNodesPROOF worker node information .",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v616/annotated.html:203597,log,log,203597,doc/v616/annotated.html,https://root.cern,https://root.cern/doc/v616/annotated.html,1,['log'],['log']
Testability,"nd setting the variable to 2 if your scripts include <vector>; 216 // and you execute your scripts multiple times.; 217 if (includes > 0) {; 218 TString code;; 219 code = ""#include <iostream>\n""; 220 ""#include <string>\n"" // for std::string std::iostream.; 221 ""#include <DllImport.h>\n"";// Defined R__EXTERN; 222 if (includes > 1) {; 223 code += ""#include <vector>\n""; 224 ""#include <utility>"";; 225 }; 226 ProcessLine(code, kTRUE);; 227 }; 228 }; 229 ; 230 // Load user functions; 231 const char *logon;; 232 logon = gEnv->GetValue(""Rint.Load"", (char*)nullptr);; 233 if (logon) {; 234 char *mac = gSystem->Which(TROOT::GetMacroPath(), logon, kReadPermission);; 235 if (mac); 236 ProcessLine(Form("".L %s"",logon), kTRUE);; 237 delete [] mac;; 238 }; 239 ; 240 // Execute logon macro; 241 ExecLogon();; 242 ; 243 // Save current interpreter context; 244 gCling->SaveContext();; 245 gCling->SaveGlobalsContext();; 246 ; 247 // Install interrupt and terminal input handlers; 248 TInterruptHandler *ih = new TInterruptHandler();; 249 ih->Add();; 250 SetSignalHandler(ih);; 251 ; 252 // Handle stdin events; 253 fInputHandler = new TTermInputHandler(0);; 254 fInputHandler->Add();; 255 ; 256 // Goto into raw terminal input mode; 257 char defhist[kMAXPATHLEN];; 258 snprintf(defhist, sizeof(defhist), ""%s/.root_hist"", gSystem->HomeDirectory());; 259 logon = gEnv->GetValue(""Rint.History"", defhist);; 260 // In the code we had HistorySize and HistorySave, in the rootrc and doc; 261 // we have HistSize and HistSave. Keep the doc as it is and check; 262 // now also for HistSize and HistSave in case the user did not use; 263 // the History versions; 264 int hist_size = gEnv->GetValue(""Rint.HistorySize"", 500);; 265 if (hist_size == 500); 266 hist_size = gEnv->GetValue(""Rint.HistSize"", 500);; 267 int hist_save = gEnv->GetValue(""Rint.HistorySave"", 400);; 268 if (hist_save == 400); 269 hist_save = gEnv->GetValue(""Rint.HistSave"", 400);; 270 const char *envHist = gSystem->Getenv(""ROOT_HIST"");; 271 if (env",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TRint_8cxx_source.html:7917,log,logon,7917,doc/master/TRint_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TRint_8cxx_source.html,2,['log'],['logon']
Testability,"nd test trees -> same cuts for signal and backgroundDefinition DataLoader.cxx:632; TMVA::DataLoader::AddTreevoid AddTree(TTree *tree, const TString &className, Double_t weight=1.0, const TCut &cut="""", Types::ETreeType tt=Types::kMaxTreeType)Definition DataLoader.cxx:351; TMVA::DataLoader::AddVariablevoid AddVariable(const TString &expression, const TString &title, const TString &unit, char type='F', Double_t min=0, Double_t max=0)user inserts discriminating variable in data set infoDefinition DataLoader.cxx:485; TMVA::FactoryThis is the main MVA steering class.Definition Factory.h:80; TMVA::Factory::TrainAllMethodsvoid TrainAllMethods()Iterates through all booked methods and calls training.Definition Factory.cxx:1114; TMVA::Factory::BookMethodMethodBase * BookMethod(DataLoader *loader, TString theMethodName, TString methodTitle, TString theOption="""")Book a classifier or regression method.Definition Factory.cxx:352; TMVA::Factory::TestAllMethodsvoid TestAllMethods()Evaluates all booked methods on the testing data and adds the output to the Results in the corresponi...Definition Factory.cxx:1271; TMVA::Factory::EvaluateAllMethodsvoid EvaluateAllMethods(void)Iterates over all MVAs that have been booked, and calls their evaluation methods.Definition Factory.cxx:1376; TMVA::Tools::Instancestatic Tools & Instance()Definition Tools.cxx:71; TMVA::Tools::SplitStringstd::vector< TString > SplitString(const TString &theOpt, const char separator) constsplits the option string at 'separator' and fills the list 'splitV' with the primitive stringsDefinition Tools.cxx:1199; TMVA::Types::kFDA@ kFDADefinition Types.h:92; TMVA::Types::kBDT@ kBDTDefinition Types.h:86; TMVA::Types::kDL@ kDLDefinition Types.h:99; TMVA::Types::kPDEFoam@ kPDEFoamDefinition Types.h:94; TMVA::Types::kMLP@ kMLPDefinition Types.h:90; TNamed::GetNameconst char * GetName() const overrideReturns name of object.Definition TNamed.h:47; TStringBasic string class.Definition TString.h:139; TString::IsNullBool_t IsNull(",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVAMulticlass_8C.html:40356,test,testing,40356,doc/master/TMVAMulticlass_8C.html,https://root.cern,https://root.cern/doc/master/TMVAMulticlass_8C.html,2,['test'],['testing']
Testability,"nd the function directly returns the pointer using a static_cast. If the template parameter of this proxy is not an LValue type, then; in a debug build, a dynamic_cast with an assertion is used.; in a release build, a static_cast is forced, irrespective of what the type of the object actually is. This is dangerous, but equivalent to the behaviour before refactoring the RooFit proxies. Deprecated:This function is unnecessary if the template parameter is RooAbsRealLValue (+ derived types) or RooAbsCategoryLValue (+derived types), as arg() will always return the correct type. . Definition at line 411 of file RooTemplateProxy.h. lvptr() [4/4]. template<class T > . LValue_t * RooTemplateProxy< T >::lvptr ; (; RooAbsArg *; ). inline . Return l-value pointer to contents. ; If the contents derive from RooAbsLValue or RooAbsCategoryLValue, the conversion is safe, and the function directly returns the pointer using a static_cast. If the template parameter of this proxy is not an LValue type, then; in a debug build, a dynamic_cast with an assertion is used.; in a release build, a static_cast is forced, irrespective of what the type of the object actually is. This is dangerous, but equivalent to the behaviour before refactoring the RooFit proxies. Deprecated:This function is unnecessary if the template parameter is RooAbsRealLValue (+ derived types) or RooAbsCategoryLValue (+derived types), as arg() will always return the correct type. . Definition at line 426 of file RooTemplateProxy.h. R__DEPRECATED(). template<class T > . template<typename Bool = bool, typename = std::enable_if_t<std::is_same<Bool,bool>::value>> . RooTemplateProxy< T >::R__DEPRECATED ; (; 6; , . 36; , . ""Use RooTemplateProxy< T >(const char*, const char*, RooAbsArg*, bool, bool) and transfer the ownership with RooTemplateProxy< T >::putOwnedArg().""; . ); const. Constructor with owner. ; Deprecated:Kept for backwards compatibility and will be removed in ROOT 6.36. Either use RooTemplateProxy(const cha",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooTemplateProxy.html:26293,assert,assertion,26293,doc/master/classRooTemplateProxy.html,https://root.cern,https://root.cern/doc/master/classRooTemplateProxy.html,1,['assert'],['assertion']
Testability,"nd the result of statement; should be stored in internal buffers with the method TSQLStatement::StoreResult().; Information about selected fields (columns); can be obtained with GetNumFields() and GetFieldName() methods.; To receive data for the next result row, NextResultRow() method should be called.; Value from each column can be retrieved with the GetInt(), GetDouble(),; GetString() and other methods. There are no strict limitations on which method should be used; to get column values. GetString() can be used as a generic method,; which should always return correct result, but also conversions between most; basic data types are supported. For instance, if a column contains integer; values, GetInt(), GetLong64(), GetDouble() and GetString() methods can be used.; If column has floating point format, GetDouble() and GetString() methods can; be used without loss of precision while GetInt() or GetLong64() will return; only the integer part of the value. One also can test whether; a value is NULL with the IsNull() method. The buffer length specified for a statement in the TSQLServer::Statement() call; will also be used to allocate buffers for column values. Usage of these; buffers is transparent for users and does not limit the number of rows; which can be accessed with one statement. Again, local databases do not work; with buffers inside TSQLStatement at all and ignore this value.; Example of select query:. stmt = serv->Statement(""SELECT * FROM TESTTABLE"", 100);; // process statement; if (stmt->Process()) {; // store result of statement in buffer; stmt->StoreResult();. // display info about selected field; cout << ""NumFields = "" << stmt->GetNumFields() << endl;; for (int n=0;n<stmt->GetNumFields();n++); cout << ""Field "" << n << "" = "" << stmt->GetFieldName(n) << endl;. // extract rows one after another; while (stmt->NextResultRow()) {; Double_t id1 = stmt->GetDouble(0);; UInt_t id2 = stmt->GetUInt(1);; const char* name1 = stmt->GetString(2);; const char* name2 = stmt-",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TSQLStatement.html:6665,test,test,6665,root/html534/TSQLStatement.html,https://root.cern,https://root.cern/root/html534/TSQLStatement.html,1,['test'],['test']
Testability,"nd the result of statement; should be stored in internal buffers with the method TSQLStatement::StoreResult().; Information about selected fields (columns); can be obtained with GetNumFields() and GetFieldName() methods.; To receive data for the next result row, NextResultRow() method should be called.; Value from each column can be retrieved with the GetInt(), GetDouble(),; GetString() and other methods. There are no strict limitations on which method should be used; to get column values. GetString() can be used as a generic method,; which should always return correct result, but also conversions between most; basic data types are supported. For instance, if a column contains integer; values, GetInt(), GetLong64(), GetDouble() and GetString() methods can be used.; If column has floating point format, GetDouble() and GetString() methods can; be used without loss of precision while GetInt() or GetLong64() will return; only the integer part of the value. One also can test whether; a value is NULL with the IsNull() method. The buffer length specified for a statement in the TSQLServer::Statement() call; will also be used to allocate buffers for column values. Usage of these; buffers is transparent for users and does not limit the number of rows; which can be accessed with one statement. Again, local databases do not work; with buffers inside TSQLStatement at all and ignore this value.; Example of select query:. stmt = serv->Statement(""SELECT * FROM TESTTABLE"", 100);; // process statement; if (stmt->Process()) {; // store result of statement in buffer; stmt->StoreResult();. // display info about selected field; std::cout << ""NumFields = "" << stmt->GetNumFields() << std::endl;; for (int n=0;n<stmt->GetNumFields();n++); std::cout << ""Field "" << n << "" = "" << stmt->GetFieldName(n) << std::endl;. // extract rows one after another; while (stmt->NextResultRow()) {; Double_t id1 = stmt->GetDouble(0);; UInt_t id2 = stmt->GetUInt(1);; const char* name1 = stmt->GetString(2);; const",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TSQLStatement.html:6689,test,test,6689,root/html602/TSQLStatement.html,https://root.cern,https://root.cern/root/html602/TSQLStatement.html,2,['test'],['test']
Testability,"nd then; 1815/// \f[; 1816/// X^{2} = \sum_{i=1}^{r}\frac{(n_{i}-N\hat{p}_{i})^{2}}{N\hat{p}_{i}} + \sum_{i=1}^{r}\frac{(m_{i}-M\hat{p}_{i})^{2}}{M\hat{p}_{i}} =\frac{1}{MN} \sum_{i=1}^{r}\frac{(Mn_{i}-Nm_{i})^{2}}{n_{i}+m_{i}}; 1817/// \f]; 1818/// has approximately a \f$ \chi^{2}_{(r-1)} \f$ distribution [3].; 1819/// The comparison procedure can include an analysis of the residuals which; 1820/// is often helpful in identifying the bins of histograms responsible for; 1821/// a significant overall \f$ \chi^{2} \f$ value. Most convenient for; 1822/// analysis are the adjusted (normalized) residuals [4]; 1823/// \f[; 1824/// r_{i} = \frac{n_{i}-N\hat{p}_{i}}{\sqrt{N\hat{p}_{i}}\sqrt{(1-N/(N+M))(1-(n_{i}+m_{i})/(N+M))}}; 1825/// \f]; 1826/// If hypotheses of homogeneity are valid then residuals ri are; 1827/// approximately independent and identically distributed random variables; 1828/// having N(0,1) distribution. The application of the \f$ \chi^{2} \f$ test has; 1829/// restrictions related to the value of the expected frequencies Npi,; 1830/// Mpi, i=1,...,r. A conservative rule formulated in [5] is that all the; 1831/// expectations must be 1 or greater for both histograms. In practical; 1832/// cases when expected frequencies are not known the estimated expected; 1833/// frequencies \f$ M\hat{p}_{i}, N\hat{p}_{i}, i=1,...,r \f$ can be used.; 1834///; 1835/// #### Unweighted and weighted histograms comparison:; 1836///; 1837/// A simple modification of the ideas described above can be used for the; 1838/// comparison of the usual (unweighted) and weighted histograms. Let us; 1839/// denote the number of events in the ith bin in the unweighted; 1840/// histogram as ni and the common weight of events in the ith bin of the; 1841/// weighted histogram as wi. The total number of events in the; 1842/// unweighted histogram is equal to; 1843///\f[; 1844/// N = \sum_{i=1}^{r} n_{i}; 1845///\f]; 1846/// and the total weight of events in the weighted histogram is equal to;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TH1_8cxx_source.html:72081,test,test,72081,doc/master/TH1_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html,1,['test'],['test']
Testability,"nd verify; ientry = mychain.LoadTree(jentry); if ientry < 0:; break. # copy next entry into memory and verify; nb = mychain.GetEntry(jentry); if nb<=0:; continue. # use the values directly from the tree; nEvent = int(mychain.ev); if nEvent<0:; continue. print(mychain.pz, '=', mychain.px*mychain.px, '+', mychain.py*mychain.py); Access to arrays works the same way as access to single value tree elements, where the size of the array is determined by the number of values actually read from the file. For example:; # loop over array tree element; for d in mychain.mydoubles:; print(d). # direct access into an array tree element; i5 = mychain.myints[5]; 19.1.9.2 Writing a Tree; Writing a ROOT TTree in a Python session is a little convoluted, if only because you will need a C++ class to make sure that data members can be mapped, unless you are working with built-in types. Here is an example for working with the latter only:; from ROOT import TFile, TTree; from array import array. h = TH1F('h1','test',100,-10.,10.); f = TFile('test.root','recreate'); t = TTree('t1','tree with histos'); maxn = 10; n = array('i',[0]); d = array('f',maxn*[0.]); t.Branch('mynum',n,'mynum/I'); t.Branch('myval',d,'myval[mynum]/F'). for i in range(25):; n[0] = min(i,maxn); for j in range(n[0]):; d[j] = i*0.1+j; t.Fill(). f.Write(); f.Close(); The use of arrays is needed, because the pointer to the address of the object that is used for filling must be given to the TTree::Branch() call, even though the formal argument is declared a void*'. In the case of ROOT objects, similar pointer manipulation is unnecessary, because the full type information is available, and TTree::Branch() has been Pythonized to take care of the call details. However, data members of such objects that are of built-in types, still require something extra since they are normally translated to Python primitive types on access and hence their address cannot be taken. For that purpose, there is the AddressOf() function. As an examp",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1070535,test,test,1070535,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['test'],['test']
Testability,"nd(). void TGCommandPlugin::HandleCommand ; (; ). Handle command line from the ""command"" combo box. ; Definition at line 193 of file TGCommandPlugin.cxx. HandleTab(). void TGCommandPlugin::HandleTab ; (; ). Handle the 'TAB' key events. ; Definition at line 229 of file TGCommandPlugin.cxx. HandleTextChanged(). void TGCommandPlugin::HandleTextChanged ; (; const char *; text). Handle the text changed events. ; Definition at line 264 of file TGCommandPlugin.cxx. HandleTimer(). Bool_t TGCommandPlugin::HandleTimer ; (; TTimer *; t). overridevirtual . Handle timer event. ; Reimplemented from TObject.; Definition at line 272 of file TGCommandPlugin.cxx. IsA(). TClass * TGCommandPlugin::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TObject.; Definition at line 56 of file TGCommandPlugin.h. SetHistAdd(). void TGCommandPlugin::SetHistAdd ; (; Bool_t; add = kTRUE). The function SetHistAdd() is needed for a standalone TApplication to log the TGCommandPlugin commands into a ROOT history file. ; However, this function has no effect if the user does not explictly set on his standalone application the name of the ROOT history file. To log into the default ROOT history file, call this on the user-side of the code: Gl_histinit(gEnv->GetValue(""Rint.History"", gSystem->HomeDirectory())); Otherwise, replace the argument of Gl_histinit with a text file name you want to use for application-specific logging. ; Definition at line 302 of file TGCommandPlugin.cxx. Streamer(). void TGCommandPlugin::Streamer ; (; TBuffer &; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from TObject. StreamerNVirtual(). void TGCommandPlugin::StreamerNVirtual ; (; TBuffer &; ClassDef_StreamerNVirtual_b). inline . Definition at line 56 of file TGCommandPlugin.h. ToggleTimer(). void TGCommandPlugin::ToggleTimer ; (; Bool_t; on). Let user stop the internal timer when there is no need to check for remote. ; or ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGCommandPlugin.html:38972,log,log,38972,doc/master/classTGCommandPlugin.html,https://root.cern,https://root.cern/doc/master/classTGCommandPlugin.html,1,['log'],['log']
Testability,"nd=0:SplitMode=Random:NormMode=NumEvents:!V"" );; ; // Boosted Decision Trees; factory->BookMethod( dataloader, TMVA::Types::kBDT, ""BDTG"",; ""!H:!V:NTrees=1000:BoostType=Grad:Shrinkage=0.30:UseBaggedBoost:BaggedSampleFraction=0.6:SeparationType=GiniIndex:nCuts=20:MaxDepth=2"" );; factory->TrainAllMethods();; factory->TestAllMethods();; factory->EvaluateAllMethods();; ; outputFile->Close();; ; delete factory;; delete dataloader;; ; ; // background 2; // ____________; ; outfileName = ""TMVASignalBackground2.root"";; outputFile = TFile::Open( outfileName, ""RECREATE"" );; ; factory = new TMVA::Factory( ""TMVAMultiBkg2"", outputFile, factoryOptions );; dataloader=new TMVA::DataLoader(""datasetBkg2"");; ; dataloader->AddVariable( ""var1"", ""Variable 1"", """", 'F' );; dataloader->AddVariable( ""var2"", ""Variable 2"", """", 'F' );; dataloader->AddVariable( ""var3"", ""Variable 3"", ""units"", 'F' );; dataloader->AddVariable( ""var4"", ""Variable 4"", ""units"", 'F' );; ; dataloader->AddSignalTree ( signal, signalWeight );; dataloader->AddBackgroundTree( background2, background2Weight );; ; // dataloader->SetBackgroundWeightExpression(""weight"");; ; // tell the dataloader to use all remaining events in the trees after training for testing:; dataloader->PrepareTrainingAndTestTree( mycuts, mycutb,; ""nTrain_Signal=0:nTrain_Background=0:SplitMode=Random:NormMode=NumEvents:!V"" );; ; // Boosted Decision Trees; factory->BookMethod( dataloader, TMVA::Types::kBDT, ""BDTG"",; ""!H:!V:NTrees=1000:BoostType=Grad:Shrinkage=0.30:UseBaggedBoost:BaggedSampleFraction=0.5:SeparationType=GiniIndex:nCuts=20:MaxDepth=2"" );; factory->TrainAllMethods();; factory->TestAllMethods();; factory->EvaluateAllMethods();; ; outputFile->Close();; ; delete factory;; delete dataloader;; ; }; ; ; ; ; ; // ----------------------------------------------------------------------------------------------; // Application; // ----------------------------------------------------------------------------------------------; //; // create a summary tree with",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVAMultipleBackgroundExample_8C.html:35812,test,testing,35812,doc/master/TMVAMultipleBackgroundExample_8C.html,https://root.cern,https://root.cern/doc/master/TMVAMultipleBackgroundExample_8C.html,1,['test'],['testing']
Testability,"nd=0:SplitMode=Random:NormMode=NumEvents:!V"" );; ; // Boosted Decision Trees; factory->BookMethod( dataloader, TMVA::Types::kBDT, ""BDTG"",; ""!H:!V:NTrees=1000:BoostType=Grad:Shrinkage=0.30:UseBaggedBoost:BaggedSampleFraction=0.6:SeparationType=GiniIndex:nCuts=20:MaxDepth=2"" );; factory->TrainAllMethods();; factory->TestAllMethods();; factory->EvaluateAllMethods();; ; outputFile->Close();; ; delete factory;; delete dataloader;; ; ; ; // background 1; // ____________; ; outfileName = ""TMVASignalBackground1.root"";; outputFile = TFile::Open( outfileName, ""RECREATE"" );; dataloader=new TMVA::DataLoader(""datasetBkg1"");; ; factory = new TMVA::Factory( ""TMVAMultiBkg1"", outputFile, factoryOptions );; dataloader->AddVariable( ""var1"", ""Variable 1"", """", 'F' );; dataloader->AddVariable( ""var2"", ""Variable 2"", """", 'F' );; dataloader->AddVariable( ""var3"", ""Variable 3"", ""units"", 'F' );; dataloader->AddVariable( ""var4"", ""Variable 4"", ""units"", 'F' );; ; dataloader->AddSignalTree ( signal, signalWeight );; dataloader->AddBackgroundTree( background1, background1Weight );; ; // dataloader->SetBackgroundWeightExpression(""weight"");; ; // tell the factory to use all remaining events in the trees after training for testing:; dataloader->PrepareTrainingAndTestTree( mycuts, mycutb,; ""nTrain_Signal=0:nTrain_Background=0:SplitMode=Random:NormMode=NumEvents:!V"" );; ; // Boosted Decision Trees; factory->BookMethod( dataloader, TMVA::Types::kBDT, ""BDTG"",; ""!H:!V:NTrees=1000:BoostType=Grad:Shrinkage=0.30:UseBaggedBoost:BaggedSampleFraction=0.6:SeparationType=GiniIndex:nCuts=20:MaxDepth=2"" );; factory->TrainAllMethods();; factory->TestAllMethods();; factory->EvaluateAllMethods();; ; outputFile->Close();; ; delete factory;; delete dataloader;; ; ; // background 2; // ____________; ; outfileName = ""TMVASignalBackground2.root"";; outputFile = TFile::Open( outfileName, ""RECREATE"" );; ; factory = new TMVA::Factory( ""TMVAMultiBkg2"", outputFile, factoryOptions );; dataloader=new TMVA::DataLoader(""datasetBkg2"")",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVAMultipleBackgroundExample_8C.html:34503,test,testing,34503,doc/master/TMVAMultipleBackgroundExample_8C.html,https://root.cern,https://root.cern/doc/master/TMVAMultipleBackgroundExample_8C.html,1,['test'],['testing']
Testability,ndPixmap. Pixmap_t TGScrollBar::fgBckgndPixmap = 0. staticprotected . Definition at line 89 of file TGScrollBar.h. fGrabPointer. Bool_t TGScrollBar::fGrabPointer. protected . grab pointer when dragging ; Definition at line 71 of file TGScrollBar.h. fgScrollBarWidth. Int_t TGScrollBar::fgScrollBarWidth = kDefaultScrollBarWidth. staticprotected . Definition at line 90 of file TGScrollBar.h. fHead. TGScrollBarElement* TGScrollBar::fHead. protected . head button of scrollbar ; Definition at line 78 of file TGScrollBar.h. fHeadPic. const TGPicture* TGScrollBar::fHeadPic. protected . picture in head (up or left arrow) ; Definition at line 81 of file TGScrollBar.h. fHighColor. Pixel_t TGScrollBar::fHighColor. protected . highlight color ; Definition at line 87 of file TGScrollBar.h. fPos. Int_t TGScrollBar::fPos. protected . logical current position ; Definition at line 74 of file TGScrollBar.h. fPsize. Int_t TGScrollBar::fPsize. protected . logical page size of scrollbar ; Definition at line 73 of file TGScrollBar.h. fRange. Int_t TGScrollBar::fRange. protected . logical upper range of scrollbar ; Definition at line 72 of file TGScrollBar.h. fRepeat. TTimer* TGScrollBar::fRepeat. protected . repeat rate timer (when mouse stays pressed) ; Definition at line 83 of file TGScrollBar.h. fSlider. TGScrollBarElement* TGScrollBar::fSlider. protected . slider ; Definition at line 80 of file TGScrollBar.h. fSliderRange. Int_t TGScrollBar::fSliderRange. protected . logical slider range ; Definition at line 76 of file TGScrollBar.h. fSliderSize. Int_t TGScrollBar::fSliderSize. protected . logical slider size ; Definition at line 75 of file TGScrollBar.h. fSmallInc. Int_t TGScrollBar::fSmallInc. protected . Small Increment in the sliding algorithm. ; Definition at line 77 of file TGScrollBar.h. fSubw. Window_t TGScrollBar::fSubw. protected . sub window in which mouse is pressed ; Definition at line 84 of file TGScrollBar.h. fTail. TGScrollBarElement* TGSc,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGScrollBar.html:39009,log,logical,39009,doc/master/classTGScrollBar.html,https://root.cern,https://root.cern/doc/master/classTGScrollBar.html,1,['log'],['logical']
Testability,"nd_mbLegend for profiles mbs; TProfile*fProfile_cpu_eff; TProfile*fProfile_perfstat_IO; TProfile*fProfile_perfstat_IOmax; TProfile*fProfile_perfstat_event; TProfile*fProfile_perfstat_evtmax; TProfile*fProfile_queryresult_IO; TProfile*fProfile_queryresult_event; TProof*fProofpointer to proof; TPBReadType*fReadTyperead type; Bool_tfReleaseCacheRelease cache for data reads between runs ; Int_tfStartstart number of workers; Int_tfSteptest to be performed every fStep workers; Int_tfStopstop number of workers. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TProofBenchRunDataRead(TProofBenchDataSet* pbds, TPBReadType* readtype = 0, TDirectory* dirproofbench = 0, TProof* proof = 0, TProofNodes* nodes = 0, Long64_t nevents = -1, Int_t ntries = 2, Int_t start = 1, Int_t stop = -1, Int_t step = 1, Int_t debug = 0). ~TProofBenchRunDataRead(); Destructor. void Run(const char* dset, Int_t start, Int_t stop, Int_t step, Int_t ntries, Int_t debug, Int_t ); Run benchmark; Input parameters; dset: Dataset on which to run; start: Start scan with 'start' workers.; stop: Stop scan at 'stop workers.; step: Scan every 'step' workers.; ntries: Number of tries. When it is -1, data member fNTries is used.; debug: debug switch.; Int_t: Ignored; Returns; Nothing. TFileCollection * GetDataSet(const char* dset, Int_t nact, Bool_t nx); Get a subsample of dsname suited to run with 'nact' and option 'nx'. void FillPerfStatProfiles(TTree* t, Int_t nactive). void Print(Option_t* option = """") const; Print the content of this object. void DrawPerfProfiles(); Get canvas. TString GetNameStem() const; Get name for this run. Int_t SetParameters(); Set parameters. Int_t DeleteParameters(); Delete parameters set for this run. void BuildHistos(Int_t start, Int_t stop, Int_t step, Bool_t nx); Build histograms, profiles and graphs needed for this run. TProofBenchRunDataRead(TProofBenchDataSet* pbds, TPBReadType* readtype = 0, TDirectory* dirproofbench = 0, TProof* proo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TProofBenchRunDataRead.html:8927,benchmark,benchmark,8927,root/html534/TProofBenchRunDataRead.html,https://root.cern,https://root.cern/root/html534/TProofBenchRunDataRead.html,1,['benchmark'],['benchmark']
Testability,"ndarySelect() const; UInt_tUnrefFirstPhysical(); virtual voidUpdateBoundingBox(); voidUpdateBoundingBoxesOfPhysicals(). protected:. voidPurgeDLRange(UInt_t base, Int_t size) const. private:. TGLLogicalShape&operator=(const TGLLogicalShape&). Data Members; public:. enum ELODAxes { kLODAxesNone; kLODAxesX; kLODAxesY; kLODAxesZ; kLODAxesAll; };. protected:. TGLBoundingBoxfBoundingBox! Shape's bounding box.; UInt_tfDLBase! display-list id base; Bool_tfDLCache! use display list caching; Int_tfDLSize! display-list size for different LODs; UShort_tfDLValid! display-list validity bit-field; TObject*fExternalObj! Also plays the role of ID.; TGLPhysicalShape*fFirstPhysical! first replica; Bool_tfOwnExtObj! External object is a fake; UInt_tfRef! physical instance ref counting; Bool_tfRefStrong! Strong ref (delete on 0 ref); not in scene; TGLScene*fScene! scene where object is stored (can be zero!). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~TGLLogicalShape(); Destroy logical shape. void AddRef(TGLPhysicalShape* phys) const; Add reference to given physical shape. void SubRef(TGLPhysicalShape* phys) const; Remove reference to given physical shape, potentially deleting; *this* object when hitting zero ref-count (if fRefStrong is; true). void DestroyPhysicals(); Destroy all physicals attached to this logical. UInt_t UnrefFirstPhysical(); Unreference first physical in the list, returning its id and; making it fit for destruction somewhere else.; Returns 0 if there are no replicas attached. void UpdateBoundingBoxesOfPhysicals(); Update bounding-boxed of all dependent physicals. Bool_t SetDLCache(Bool_t cached); Modify capture of draws into display list cache kTRUE - capture,; kFALSE direct draw. Return kTRUE is state changed, kFALSE if not. Bool_t ShouldDLCache(const TGLRnrCtx& rnrCtx) const; Returns kTRUE if draws should be display list cached; kFALSE otherwise. Here we check that:; a) fScene is set (Scene manages link to GL-context);",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGLLogicalShape.html:4619,log,logical,4619,root/html528/TGLLogicalShape.html,https://root.cern,https://root.cern/root/html528/TGLLogicalShape.html,3,['log'],['logical']
Testability,"ndefined, const std::vector< double > &distParams={}); Constructor for 1-sample tests with a specified distribution. ; ; virtual~GoFTest (); ; Double_tAndersonDarling2SamplesTest (const Char_t *option=""p"") const; Anderson-Darling 2-Sample Test. ; ; voidAndersonDarling2SamplesTest (Double_t &pvalue, Double_t &testStat) const; Performs the Anderson-Darling 2-Sample Test. ; ; Double_tAndersonDarlingTest (const Char_t *option=""p"") const; Anderson-Darling 2-Sample Test. ; ; voidAndersonDarlingTest (Double_t &pvalue, Double_t &testStat) const; Performs the Anderson-Darling 1-Sample Test. ; ; Double_tKolmogorovSmirnov2SamplesTest (const Char_t *option=""p"") const; Kolmogorov-Smirnov 2-Samples Test. ; ; voidKolmogorovSmirnov2SamplesTest (Double_t &pvalue, Double_t &testStat) const; Kolmogorov-Smirnov 2-Samples Test. ; ; Double_tKolmogorovSmirnovTest (const Char_t *option=""p"") const; Kolmogorov-Smirnov 1-Sample Test. ; ; voidKolmogorovSmirnovTest (Double_t &pvalue, Double_t &testStat) const; Kolmogorov-Smirnov 1-Sample Test. ; ; voidoperator() (ETestType test, Double_t &pvalue, Double_t &testStat) const; The class's unary functions performing the gif test according to the ETestType provided. ; ; Double_toperator() (ETestType test=kAD, const Char_t *option=""p"") const; Returns default Anderson Darling 1-Sample Test and default p-value; option ""t"" returns the test statistic value specific to the test type. ; ; voidSetDistribution (EDistribution dist, const std::vector< double > &distParams={}); Sets the distribution for the predefined distribution types and optionally its parameters for 1-sample tests. ; ; voidSetUserCDF (const IGenFunction &cdf, Double_t xmin=1, Double_t xmax=0); Specialization to set the user input distribution as a cumulative distribution function for 1-sample tests. ; ; template<class Dist > ; voidSetUserCDF (Dist &cdf, Double_t xmin=1, Double_t xmax=0); Sets the user input distribution as a cumulative distribution fu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1GoFTest.html:3789,test,testStat,3789,doc/master/classROOT_1_1Math_1_1GoFTest.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1GoFTest.html,1,['test'],['testStat']
Testability,nder.cxx; GSLMultiRootFunctionAdapter.h; GSLMultiRootFunctionWrapper.h; GSLMultiRootSolver.h; GSLNLSMinimizer.cxx; GSLQRngWrapper.h; GSLQuasiRandom.cxx; GSLRndmEngines.cxx; GSLRngWrapper.h; GSLRootFdFSolver.h; GSLRootFinder.cxx; GSLRootFinderDeriv.cxx; GSLRootFSolver.h; GSLRootHelper.cxx; GSLSimAnMinimizer.cxx; GSLSimAnnealing.cxx; Interpolator.cxx; KelvinFunctions.cxx; MCParameters.cxx; MultiNumGradFunction.cxx; PdfFuncMathMore.cxx; Polynomial.cxx; QuantFuncMathMore.cxx; RootFinderAlgorithms.cxx; SpecFuncMathMore.cxx; Vavilov.cxx; VavilovAccurate.cxx; VavilovAccurateCdf.cxx; VavilovAccuratePdf.cxx; VavilovAccurateQuantile.cxx; VavilovFast.cxx; zsolve_cubic.cxx; test; piRandom.C; pirndm.C; simanTSP.cxx; testChebyshev.cxx; testDerivation.cxx; testFunctor.cxx; testGSLIntegration.cxx; testGSLRootFinder.cxx; testInterpolation.cxx; testMCIntegration.cxx; testMinimization1D.cxx; testMultiRootFinder.cxx; testPermute.cxx; testQuasiRandom.cxx; testRandom.cxx; testRandomDist.cxx; testSpecFunc.cxx; testStatFunc.cxx; testVavilov.cxx; UnuRanDist.h; VavilovTest.cxx; VavilovTest.h; matrix; inc; LinkDef.h; TDecompBase.h; TDecompBK.h; TDecompChol.h; TDecompLU.h; TDecompQRH.h; TDecompSparse.h; TDecompSVD.h; TMatrix.h; TMatrixD.h; TMatrixDBase.h; TMatrixDBasefwd.h; TMatrixDEigen.h; TMatrixDfwd.h; TMatrixDLazy.h; TMatrixDSparse.h; TMatrixDSparsefwd.h; TMatrixDSym.h; TMatrixDSymEigen.h; TMatrixDSymfwd.h; TMatrixDUtils.h; TMatrixDUtilsfwd.h; TMatrixF.h; TMatrixFBase.h; TMatrixFBasefwd.h; TMatrixFfwd.h; TMatrixFLazy.h; TMatrixFSparse.h; TMatrixFSparsefwd.h; TMatrixFSym.h; TMatrixFSymfwd.h; TMatrixFUtils.h; TMatrixFUtilsfwd.h; TMatrixT.h; TMatrixTBase.h; TMatrixTCramerInv.h; TMatrixTLazy.h; TMatrixTSparse.h; TMatrixTSym.h; TMatrixTSymCramerInv.h; TMatrixTUtils.h; TVector.h; TVectorD.h; TVectorDfwd.h; TVectorF.h; TVectorFfwd.h; TVectorfwd.h; TVectorT.h; src; TDecompBase.cxx; TDe,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html606/files.html:49027,test,testRandom,49027,root/html606/files.html,https://root.cern,https://root.cern/root/html606/files.html,1,['test'],['testRandom']
Testability,"ndersonDarling2SamplesTest(const Char_t* option = ""p"") const; voidAndersonDarling2SamplesTest(Double_t& pvalue, Double_t& testStat) const; static voidAndersonDarling2SamplesTest(const ROOT::Fit::BinData& data1, const ROOT::Fit::BinData& data2, Double_t& pvalue, Double_t& testStat); Double_tAndersonDarlingTest(const Char_t* option = ""p"") const; voidAndersonDarlingTest(Double_t& pvalue, Double_t& testStat) const; ROOT::Math::GoFTestGoFTest(UInt_t sampleSize, const Double_t* sample, ROOT::Math::GoFTest::EDistribution dist = kUndefined); ROOT::Math::GoFTestGoFTest(UInt_t sample1Size, const Double_t* sample1, UInt_t sample2Size, const Double_t* sample2); ROOT::Math::GoFTestGoFTest(UInt_t sampleSize, const Double_t* sample, const ROOT::Math::IGenFunction& dist, ROOT::Math::GoFTest::EUserDistribution userDist = kPDF, Double_t xmin = 1, Double_t xmax = 0); Double_tKolmogorovSmirnov2SamplesTest(const Char_t* option = ""p"") const; voidKolmogorovSmirnov2SamplesTest(Double_t& pvalue, Double_t& testStat) const; Double_tKolmogorovSmirnovTest(const Char_t* option = ""p"") const; voidKolmogorovSmirnovTest(Double_t& pvalue, Double_t& testStat) const; Double_toperator()(ROOT::Math::GoFTest::ETestType test = kAD, const Char_t* option = ""p"") const; voidoperator()(ROOT::Math::GoFTest::ETestType test, Double_t& pvalue, Double_t& testStat) const; static Double_tPValueADKSamples(UInt_t nsamples, Double_t A2); voidSetDistribution(ROOT::Math::GoFTest::EDistribution dist); voidSetUserCDF(const ROOT::Math::IGenFunction& cdf, Double_t xmin = 1, Double_t xmax = 0); voidSetUserDistribution(const ROOT::Math::IGenFunction& dist, ROOT::Math::GoFTest::EUserDistribution userDist = kPDF, Double_t xmin = 1, Double_t xmax = 0); voidSetUserDistribution<const ROOT::Math::IBaseFunctionOneDim>(ROOT::Math::const IBaseFunctionOneDim& dist, ROOT::Math::GoFTest::EUserDistribution userDist = kPDF, Double_t xmin = 1, Double_t xmax = 0); voidSetUserPDF(const ROOT::Math::IGenFunction& pdf, Double_t xmin = 1, Double_t xm",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/ROOT__Math__GoFTest.html:1343,test,testStat,1343,root/html602/ROOT__Math__GoFTest.html,https://root.cern,https://root.cern/root/html602/ROOT__Math__GoFTest.html,2,['test'],['testStat']
Testability,"ndex (needed by MINUIT). Double_t getPdfParamErr(Int_t index); Access PDF parameter error by ordinal index (needed by MINUIT). Bool_t setPdfParamVal(Int_t index, Double_t value, Bool_t verbose = kFALSE); Modify PDF parameter value by ordinal index (needed by MINUIT). void setPdfParamErr(Int_t index, Double_t value); Modify PDF parameter error by ordinal index (needed by MINUIT). void clearPdfParamAsymErr(Int_t index); Modify PDF parameter error by ordinal index (needed by MINUIT). void setPdfParamErr(Int_t index, Double_t loVal, Double_t hiVal); Modify PDF parameter error by ordinal index (needed by MINUIT). void profileStart(); Start profiling timer. void profileStop(); Stop profiling timer and report results of last session. void backProp(); Transfer MINUIT fit results back into RooFit objects. void applyCovarianceMatrix(TMatrixDSym& V); Apply results of given external covariance matrix. i.e. propagate its errors; to all RRV parameter representations and give this matrix instead of the; HESSE matrix at the next save() call. RooMinuit(RooAbsReal& function). void setEvalErrorWall(Bool_t flag); { _doEvalErrorWall = flag ; }. void setPrintEvalErrors(Int_t numEvalErrors); { _printEvalErrors = numEvalErrors ; }. void setVerbose(Bool_t flag = kTRUE); { _verbose = flag ; }. void setProfile(Bool_t flag = kTRUE); { _profile = flag ; }. void setMaxEvalMultiplier(Int_t n); { _maxEvalMult = n ; }. Int_t evalCounter() const; { return _evalCounter ; }. void zeroEvalCount(); { _evalCounter = 0 ; }. Int_t getNPar() const; { return _nPar ; }. ofstream* logfile() const; { return _logfile ; }. Double_t& maxFCN(); { return _maxFCN ; }. void saveStatus(const char* label, Int_t status); { _statusHistory.push_back(std::pair<std::string,int>(label,status)) ; }.  Last changed: Fri Dec 2 14:26:52 2011  Last generated: 2011-12-02 14:26; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooMinuit.html:14461,log,logfile,14461,root/html532/RooMinuit.html,https://root.cern,https://root.cern/root/html532/RooMinuit.html,1,['log'],['logfile']
Testability,"ndex0], v[index0+1], v[index0+2], v[index0+3] );; 161 return *this;; 162 }; 163#endif; 164 ; 165 // ------ Set, Get, and access coordinate data ------; 166 ; 167 /**; 168 Retrieve a const reference to the coordinates object; 169 */; 170 const CoordSystem & Coordinates() const {; 171 return fCoordinates;; 172 }; 173 ; 174 /**; 175 Set internal data based on an array of 4 Scalar numbers; 176 */; 177 LorentzVector<CoordSystem>& SetCoordinates( const Scalar src[] ) {; 178 fCoordinates.SetCoordinates(src);; 179 return *this;; 180 }; 181 ; 182 /**; 183 Set internal data based on 4 Scalar numbers; 184 */; 185 LorentzVector<CoordSystem>& SetCoordinates( Scalar a, Scalar b, Scalar c, Scalar d ) {; 186 fCoordinates.SetCoordinates(a, b, c, d);; 187 return *this;; 188 }; 189 ; 190 /**; 191 Set internal data based on 4 Scalars at *begin to *end; 192 */; 193 template< class IT >; 194 LorentzVector<CoordSystem>& SetCoordinates( IT begin, IT end ) {; 195 IT a = begin; IT b = ++begin; IT c = ++begin; IT d = ++begin;; 196 (void)end;; 197 assert (++begin==end);; 198 SetCoordinates (*a,*b,*c,*d);; 199 return *this;; 200 }; 201 ; 202 /**; 203 get internal data into 4 Scalar numbers; 204 */; 205 void GetCoordinates( Scalar& a, Scalar& b, Scalar& c, Scalar & d ) const; 206 { fCoordinates.GetCoordinates(a, b, c, d); }; 207 ; 208 /**; 209 get internal data into an array of 4 Scalar numbers; 210 */; 211 void GetCoordinates( Scalar dest[] ) const; 212 { fCoordinates.GetCoordinates(dest); }; 213 ; 214 /**; 215 get internal data into 4 Scalars at *begin to *end; 216 */; 217 template <class IT>; 218 void GetCoordinates( IT begin, IT end ) const; 219 { IT a = begin; IT b = ++begin; IT c = ++begin; IT d = ++begin;; 220 (void)end;; 221 assert (++begin==end);; 222 GetCoordinates (*a,*b,*c,*d);; 223 }; 224 ; 225 /**; 226 get internal data into 4 Scalars at *begin; 227 */; 228 template <class IT>; 229 void GetCoordinates( IT begin ) const {; 230 Scalar a,b,c,d = 0;; 231 GetCoordinates (a,b,c,d);; 232 *",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/GenVector_2LorentzVector_8h_source.html:6993,assert,assert,6993,doc/master/GenVector_2LorentzVector_8h_source.html,https://root.cern,https://root.cern/doc/master/GenVector_2LorentzVector_8h_source.html,1,['assert'],['assert']
Testability,"ndex; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; namespace description; function members; data members; class charts. ROOT;  CORE;  METAUTILS;  TClassEdit. namespace TClassEdit. Function Members (Methods); public:. stringCleanType(const char* typeDesc, int mode = 0, const char** tail = 0); char*DemangleName(const char* mangled_name, int& errorCode); char*DemangleTypeIdName(const type_info& ti, int& errorCode); TClassEdit::EComplexTypeGetComplexType(const char*); stringGetLong64_Name(const char* original); stringGetLong64_Name(const string& original); voidGetNormalizedName(string& norm_name, string_view name); intGetSplit(const char* type, vector<string>& output, int& nestedLoc, TClassEdit::EModType mode = TClassEdit::kNone); const char*GetUnqualifiedName(const char* name); voidInit(TClassEdit::TInterpreterLookupHelper* helper); stringInsertStd(const char* tname); boolIsDefAlloc(const char* alloc, const char* classname); boolIsDefAlloc(const char* alloc, const char* keyclassname, const char* valueclassname); boolIsDefComp(const char* comp, const char* classname); boolIsDefHash(const char* hashname, const char* classname); boolIsDefPred(const char* predname, const char* classname); boolIsInterpreterDetail(const char* type); boolIsStdClass(const char* type); boolIsSTLBitset(const char* type); ROOT::ESTLTypeIsSTLCont(string_view type); intIsSTLCont(const char* type, int testAlloc); boolIsVectorBool(const char* name); stringResolveTypedef(const char* tname, bool resolveAll = false); stringShortType(const char* typeDesc, int mode); intSTLArgs(int kind); ROOT::ESTLTypeSTLKind(string_view type); ROOT::ESTLTypeUnderlyingIsSTLCont(string_view type). Data Members. Class Charts; Function documentation; void Init(TClassEdit::TInterpreterLookupHelper* helper). ROOT::ESTLType STLKind(string_view type); Converts STL container name to number. vector -> 1, etc..; If len is greater than 0, only look at that many characters in ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TClassEdit.html:1499,test,testAlloc,1499,root/html604/TClassEdit.html,https://root.cern,https://root.cern/root/html604/TClassEdit.html,1,['test'],['testAlloc']
Testability,"nding number of dimensions. WARNING. In case of an interpreted function (fType=2), it is the; user's responsability to initialize the parameters via InitArgs; before calling this function.; InitArgs should be called at least once to specify the addresses; of the arguments x and params.; InitArgs should be called everytime these addresses change. void ExecuteEvent(Int_t event, Int_t px, Int_t py); Execute action corresponding to one event. This member function is called when a F1 is clicked with the locator. void FixParameter(Int_t ipar, Double_t value); Fix the value of a parameter; The specified value will be used in a fit operation. TF1 * GetCurrent(); Static function returning the current function being processed. TH1 * GetHistogram() const; Return a pointer to the histogram used to vusualize the function. Double_t GetMaximum(Double_t xmin = 0, Double_t xmax = 0, Double_t epsilon = 1.0E-10, Int_t maxiter = 100, Bool_t logx = false) const; Return the maximum value of the function; Method:; First, the grid search is used to bracket the maximum; with the step size = (xmax-xmin)/fNpx.; This way, the step size can be controlled via the SetNpx() function.; If the function is unimodal or if its extrema are far apart, setting; the fNpx to a small value speeds the algorithm up many times.; Then, Brent's method is applied on the bracketed interval; epsilon (default = 1.E-10) controls the relative accuracy (if |x| > 1 ); and absolute (if |x| < 1) and maxiter (default = 100) controls the maximum number; of iteration of the Brent algorithm; If the flag logx is set the grid search is done in log step size; This is done automatically if the log scale is set in the current Pad. NOTE: see also TF1::GetMaximumX and TF1::GetX. Double_t GetMaximumX(Double_t xmin = 0, Double_t xmax = 0, Double_t epsilon = 1.0E-10, Int_t maxiter = 100, Bool_t logx = false) const; Return the X value corresponding to the maximum value of the function; Method:; First, the grid search is used to bracket t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TF1.html:42258,log,logx,42258,root/html602/TF1.html,https://root.cern,https://root.cern/root/html602/TF1.html,2,['log'],['logx']
Testability,"ndle Class ReferenceWeb Display. ; Handle of created web-based display Depending from type of web display, holds handle of started browser process or other display-specific information to correctly stop and cleanup display. ; Definition at line 25 of file RWebDisplayHandle.hxx. Classes; class BrowserCreator; ; class ChromeCreator; ; class Creator; !< page content More...; ; class FirefoxCreator; . Public Member Functions; RWebDisplayHandle (const std::string &url); constructor ; ; virtual~RWebDisplayHandle ()=default; required virtual destructor for correct cleanup at the end ; ; const std::string &GetContent () const; get content ; ; const std::string &GetUrl () const; returns url of start web display ; ; virtual boolResize (int, int); resize web window - if possible ; ; voidSetContent (const std::string &cont); set content ; . Static Public Member Functions; static boolCanProduceImages (const std::string &browser=""""); Returns true if image production for specified browser kind is supported If browser not specified - use currently configured browser or try to test existing web browsers. ; ; static std::unique_ptr< RWebDisplayHandle >Display (const RWebDisplayArgs &args); Create web display. ; ; static boolDisplayUrl (const std::string &url); Display provided url in configured web browser. ; ; static boolNeedHttpServer (const RWebDisplayArgs &args); Check if http server required for display. ; ; static boolProduceImage (const std::string &fname, const std::string &json, int width=800, int height=600, const char *batch_file=nullptr); Produce image file using JSON data as source Invokes JSROOT drawing functionality in headless browser - Google Chrome or Mozilla Firefox. ; ; static boolProduceImages (const std::string &fname, const std::vector< std::string > &jsons, const std::vector< int > &widths, const std::vector< int > &heights, const char *batch_file=nullptr); Produce image file(s) using JSON data as source Invokes JSRO",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1RWebDisplayHandle.html:1430,test,test,1430,doc/v632/classROOT_1_1RWebDisplayHandle.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1RWebDisplayHandle.html,1,['test'],['test']
Testability,"ndleWidth*binWidth);; 5446 myCandle.SetHistoWidth(histoWidth*binWidth);; 5447 myCandle.SetHistogram(hproj);; 5448 myCandle.Paint();; 5449 }; 5450 }; 5451 }; 5452 delete hproj;; 5453}; 5454 ; 5455 ; 5456 ; 5457////////////////////////////////////////////////////////////////////////////////; 5458/// Returns the rendering regions for an axis to use in the COL2 option; 5459///; 5460/// The algorithm analyses the size of the axis compared to the size of; 5461/// the rendering region. It figures out the boundaries to use for each color; 5462/// of the rendering region. Only one axis is computed here.; 5463///; 5464/// This allows for a single computation of the boundaries before iterating; 5465/// through all of the bins.; 5466///; 5467/// \param pAxis the axis to consider; 5468/// \param nPixels the number of pixels to render axis into; 5469/// \param isLog whether the axis is log scale; 5470 ; 5471std::vector<THistRenderingRegion>; 5472THistPainter::ComputeRenderingRegions(TAxis* pAxis, Int_t nPixels, Bool_t isLog); 5473{; 5474 std::vector<THistRenderingRegion> regions;; 5475 ; 5476 enum STRATEGY { Bins, Pixels } strategy;; 5477 ; 5478 Int_t nBins = (pAxis->GetLast() - pAxis->GetFirst() + 1);; 5479 ; 5480 if (nBins >= nPixels) {; 5481 // more bins than pixels... we should loop over pixels and sample; 5482 strategy = Pixels;; 5483 } else {; 5484 // fewer bins than pixels... we should loop over bins; 5485 strategy = Bins;; 5486 }; 5487 ; 5488 if (isLog) {; 5489 ; 5490 Double_t xMin = pAxis->GetBinLowEdge(pAxis->GetFirst());; 5491 Int_t binOffset=0;; 5492 while (xMin <= 0 && ((pAxis->GetFirst()+binOffset) != pAxis->GetLast()) ) {; 5493 binOffset++;; 5494 xMin = pAxis->GetBinLowEdge(pAxis->GetFirst()+binOffset);; 5495 }; 5496 if (xMin <= 0) {; 5497 // this should cause an error if we have; 5498 return regions;; 5499 }; 5500 Double_t xMax = pAxis->GetBinUpEdge(pAxis->GetLast());; 5501 ; 5502 if (strategy == Bins) {; 5503 // logarithmic plot. we find the pixel for the bin; 550",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/THistPainter_8cxx_source.html:204630,log,log,204630,doc/master/THistPainter_8cxx_source.html,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html,1,['log'],['log']
Testability,"ndm());; h.Write();; }; timer.Stop();; printf(""billw%d : RT=%7.3f s, Cpu=%7.3f s, File size= %9d bytes, CX= %g\n"",compress,timer.RealTime(),timer.CpuTime(),; (Int_t)f.GetBytesWritten(),f.GetCompressionFactor());; }; ; void billr(const char *billname, Int_t compress) {; //read N histograms from keys; timer.Start();; TFile f(billname);; TIter next(f.GetListOfKeys());; TH1F *h;; TH1::AddDirectory(kFALSE);; TKey *key;; Int_t i=0;; TH1F *hmean = new TH1F(""hmean"",""hist mean from keys"",100,0,1);; ; while ((key=(TKey*)next())) {; h = (TH1F*)key->ReadObj();; hmean->Fill(h->GetMean());; delete h;; i++;; }; timer.Stop();; printf(""billr%d : RT=%7.3f s, Cpu=%7.3f s\n"",compress,timer.RealTime(),timer.CpuTime());; }; ; void billtw(const char *billtname, Int_t compress) {; //write N histograms to a Tree; timer.Start();; TFile f(billtname,""recreate"",""bill benchmark with trees"",compress);; TH1F *h = new TH1F(""h"",""h"",1000,-3,3);; h->FillRandom(""gaus"",50000);; TTree *T = new TTree(""T"",""test bill"");; T->Branch(""event"",""TH1F"",&h,64000,0);; for (Int_t i=0;i<N;i++) {; char name[20];; sprintf(name,""h%d"",i);; h->SetName(name);; h->Fill(2*gRandom->Rndm());; T->Fill();; }; T->Write();; delete T;; timer.Stop();; printf(""billtw%d : RT=%7.3f s, Cpu=%7.3f s, File size= %9d bytes, CX= %g\n"",compress,timer.RealTime(),timer.CpuTime(),; (Int_t)f.GetBytesWritten(),f.GetCompressionFactor());; }; ; void billtr(const char *billtname, Int_t compress) {; //read N histograms from a tree; timer.Start();; TFile f(billtname);; TH1F *h = nullptr;; TTree *T = (TTree*)f.Get(""T"");; T->SetBranchAddress(""event"",&h);; TH1F *hmeant = new TH1F(""hmeant"",""hist mean from tree"",100,0,1);; Long64_t nentries = T->GetEntries();; for (Long64_t i=0;i<nentries;i++) {; T->GetEntry(i);; hmeant->Fill(h->GetMean());; }; timer.Stop();; printf(""billtr%d : RT=%7.3f s, Cpu=%7.3f s\n"",compress,timer.RealTime(),timer.CpuTime());; }; ; void bill() {; ; TString dir = gSystem->GetDirName(gSystem->UnixPathName(__FILE__));; TString bill = dir +",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/bill_8C.html:3600,benchmark,benchmark,3600,doc/master/bill_8C.html,https://root.cern,https://root.cern/doc/master/bill_8C.html,2,"['benchmark', 'test']","['benchmark', 'test']"
Testability,"ndom(); virtual Double_tTF2::GetRandom(Double_t xmin, Double_t xmax); virtual voidTF2::GetRandom2(Double_t& xrandom, Double_t& yrandom); virtual voidGetRandom3(Double_t& xrandom, Double_t& yrandom, Double_t& zrandom); virtual voidGetRange(Double_t& xmin, Double_t& xmax) const; virtual voidGetRange(Double_t& xmin, Double_t& ymin, Double_t& xmax, Double_t& ymax) const; virtual voidGetRange(Double_t& xmin, Double_t& ymin, Double_t& zmin, Double_t& xmax, Double_t& ymax, Double_t& zmax) const; virtual Double_tGetSave(const Double_t* x); virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Double_tTF1::GetVariable(const TString& name); virtual Double_tTF1::GetX(Double_t y, Double_t xmin = 0, Double_t xmax = 0, Double_t epsilon = 1.0E-10, Int_t maxiter = 100, Bool_t logx = false) const; TAxis*TF1::GetXaxis() const; virtual Double_tTF1::GetXmax() const; virtual Double_tTF1::GetXmin() const; TAxis*TF1::GetYaxis() const; virtual Double_tTF2::GetYmax() const; virtual Double_tTF2::GetYmin() const; TAxis*TF1::GetZaxis() const; virtual Double_tGetZmax() const; virtual Double_tGetZmin() const; virtual Double_tTF1::GradientPar(Int_t ipar, const Double_t* x, Double_t eps = 0.01); virtual voidTF1::GradientPar(const Double_t* x, Double_t* grad, Double_t eps = 0.01); virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTF1::InitArgs(const Double_t* x, const Double_t* params); static voidTF1::InitStandardFunctions(); virtual voidTObject::Inspect() constMENU ; virtual Double_tIntegral(Double_t ax, Double_t bx, Double_t ay, Double_t by, Double_t az, Double_t bz, Double_t epsrel = 9.9999999999999995E-7); virtual Double_tTF1::IntegralError(Double_t a, Double_t b, const Double_t* params = 0, const Double_t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TF3.html:7681,log,logx,7681,root/html604/TF3.html,https://root.cern,https://root.cern/root/html604/TF3.html,1,['log'],['logx']
Testability,"ndom.h""; #include ""TCanvas.h""; #include ""TError.h""; #include ""Rtypes.h""; #include ""TNamed.h""; #include ""TMath.h""; ; class PolyTest1 : public TNamed, public TAttLine, public TAttFill {; public:; PolyTest1(unsigned nVertices);; ; void Paint(const Option_t *notUsed) override;; void Reset(unsigned nVertices);; ; private:; enum {; kNPointsDefault = 10000//minimal number of points.; };; ; std::vector<Double_t> fXs;; std::vector<Double_t> fYs;; };; ; //_____________________________________________________________; PolyTest1::PolyTest1(unsigned nVertices); : TNamed(""polygon_compression_test1"", ""polygon_compression_test1""); {; Reset(nVertices);; }; ; //_____________________________________________________________; void PolyTest1::Reset(unsigned nVertices); {; //Some canvas must already exist by this point.; assert(gPad != nullptr && ""Reset, gPad is null"");; //We need a gRandom to exist.; assert(gRandom != nullptr && ""Reset, gRandom is null"");; ; if (nVertices < kNPointsDefault) {; Warning(""Reset"", ""resetting nVertices parameter to %u"", unsigned(kNPointsDefault));; nVertices = kNPointsDefault;; }; ; fXs.resize(nVertices);; fYs.resize(nVertices);; ; Double_t xMin = 0., xMax = 0., yMin = 0., yMax = 0.;; gPad->GetRange(xMin, yMin, xMax, yMax);; assert(xMax - xMin > 0 && yMax - yMin > 0 && ""Reset, invalid canvas' ranges"");; ; const Double_t xCentre = xMin + 0.5 * (xMax - xMin);; const Double_t yCentre = yMin + 0.5 * (yMax - yMin);; ; const Double_t r = TMath::Min(xMax - xMin, yMax - yMin) * 0.8 / 2;; const Double_t angle = TMath::TwoPi() / (nVertices - 1);; ; for (unsigned i = 0; i < nVertices - 1; ++i) {; const Double_t currR = r + gRandom->Rndm() * r * 0.01;; fXs[i] = xCentre + currR * TMath::Cos(angle * i);; fYs[i] = yCentre + currR * TMath::Sin(angle * i);; }; ; fXs[nVertices - 1] = fXs[0];; fYs[nVertices - 1] = fYs[0];; }; ; //_____________________________________________________________; void PolyTest1::Paint(const Option_t * /*notUsed*/); {; assert(gPad != nullptr && ""Paint",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/polytest1_8C.html:1936,assert,assert,1936,doc/master/polytest1_8C.html,https://root.cern,https://root.cern/doc/master/polytest1_8C.html,1,['assert'],['assert']
Testability,"ndom3.cxx. Go to the documentation of this file. 1// @(#)root/mathcore:$Id$; 2// Author: Peter Malzacher 31/08/99; 3 ; 4/**; 5 ; 6\class TRandom3; 7 ; 8Random number generator class based on; 9 M. Matsumoto and T. Nishimura,; 10 Mersenne Twister: A 623-diminsionally equidistributed; 11 uniform pseudorandom number generator; 12 ACM Transactions on Modeling and Computer Simulation,; 13 Vol. 8, No. 1, January 1998, pp 3--30.; 14 ; 15For more information see the Mersenne Twister homepage; 16 [http://www.math.keio.ac.jp/~matumoto/emt.html]; 17 ; 18Advantage:; 19 ; 20- large period 2**19937 -1; 21- relatively fast (slightly slower than TRandom2 but much faster than TRandom1); 22 ; 23Drawback:; 24- a relative large internal state of 624 integers ; 25- generate only 32 random bits ; 26- not passing all the random generator tests. It fails some tests in TestU01; 27 (see [http://simul.iro.umontreal.ca/testu01/tu01.html]); 28 ; 29An altenativly excellent generator passing all tests of TestU01, having 61 random bits and ; 30fast as Mersenne and Twister is MIXMAX (TRandomMixMax). ; 31 ; 32@ingroup Random; 33 ; 34*/; 35 ; 36//////////////////////////////////////////////////////////////////////; 37// Aug.99 ROOT implementation based on CLHEP by P.Malzacher; 38//; 39// the original code contains the following copyright notice:; 40/* This library is free software; you can redistribute it and/or */; 41/* modify it under the terms of the GNU Library General Public */; 42/* License as published by the Free Software Foundation; either */; 43/* version 2 of the License, or (at your option) any later */; 44/* version. */; 45/* This library is distributed in the hope that it will be useful, */; 46/* but WITHOUT ANY WARRANTY; without even the implied warranty of */; 47/* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. */; 48/* See the GNU Library General Public License for more details. */; 49/* You should have received a copy of the GNU Library General */; 50/* Public License along wit",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TRandom3_8cxx_source.html:1116,test,tests,1116,doc/master/TRandom3_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TRandom3_8cxx_source.html,1,['test'],['tests']
Testability,"ne 165 of file DataLoader.h. IsA(). virtual TClass * TMVA::DataLoader::IsA ; (; ); const. inlinevirtual . ReturnsTClass describing current object ; Reimplemented from TMVA::Configurable.; Definition at line 214 of file DataLoader.h. MakeCopy(). TMVA::DataLoader * TMVA::DataLoader::MakeCopy ; (; TString; name). Copy method use in VI and CV. ; Definition at line 691 of file DataLoader.cxx. MakeKFoldDataSet(). void TMVA::DataLoader::MakeKFoldDataSet ; (; CvSplit &; s). Function required to split the training and testing datasets into a number of folds. ; Required by the CrossValidation and HyperParameterOptimisation classes. The option to split the training dataset into a training set and a validation set is implemented but not currently used. ; Definition at line 662 of file DataLoader.cxx. PrepareFoldDataSet(). void TMVA::DataLoader::PrepareFoldDataSet ; (; CvSplit &; s, . UInt_t; foldNumber, . Types::ETreeType; tt = Types::kTraining. ). Function for assigning the correct folds to the testing or training set. ; Definition at line 670 of file DataLoader.cxx. PrepareTrainingAndTestTree() [1/4]. void TMVA::DataLoader::PrepareTrainingAndTestTree ; (; const TCut &; cut, . const TString &; splitOpt. ). prepare the training and test trees -> same cuts for signal and background ; Definition at line 632 of file DataLoader.cxx. PrepareTrainingAndTestTree() [2/4]. void TMVA::DataLoader::PrepareTrainingAndTestTree ; (; const TCut &; cut, . Int_t; NsigTrain, . Int_t; NbkgTrain, . Int_t; NsigTest, . Int_t; NbkgTest, . const TString &; otherOpt = ""SplitMode=Random:!V"". ). prepare the training and test trees ; Definition at line 602 of file DataLoader.cxx. PrepareTrainingAndTestTree() [3/4]. void TMVA::DataLoader::PrepareTrainingAndTestTree ; (; const TCut &; cut, . Int_t; Ntrain, . Int_t; Ntest = -1. ). prepare the training and test trees kept for backward compatibility ; Definition at line 618 of file DataLoader.cxx. PrepareTrainingAndTestTree() ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1DataLoader.html:30773,test,testing,30773,doc/master/classTMVA_1_1DataLoader.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1DataLoader.html,1,['test'],['testing']
Testability,"ne 734 of file TSystem.cxx. Streamer(). void TSystem::Streamer ; (; TBuffer &; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from TNamed.; Reimplemented in TUnixSystem, TWinNTSystem, and TWebSystem. StreamerNVirtual(). void TSystem::StreamerNVirtual ; (; TBuffer &; ClassDef_StreamerNVirtual_b). inline . Definition at line 558 of file TSystem.h. StripOffProto(). const char * TSystem::StripOffProto ; (; const char *; path, . const char *; proto. ). staticprotected . Strip off protocol string from specified path. ; Definition at line 117 of file TSystem.cxx. Symlink(). int TSystem::Symlink ; (; const char *; from, . const char *; to. ). virtual . Create a symbolic link from file1 to file2. ; Reimplemented in TUnixSystem, and TWinNTSystem.; Definition at line 1368 of file TSystem.cxx. Syslog(). void TSystem::Syslog ; (; ELogLevel; level, . const char *; mess. ). virtual . Send mess to syslog daemon. ; Level is the logging level and mess the message that will be written on the log. ; Reimplemented in TUnixSystem.; Definition at line 1686 of file TSystem.cxx. TempDirectory(). const char * TSystem::TempDirectory ; (; ); const. virtual . Return a user configured or systemwide directory to create temporary files in. ; Reimplemented in TUnixSystem, and TWinNTSystem.; Definition at line 1482 of file TSystem.cxx. TempFileName(). FILE * TSystem::TempFileName ; (; TString &; base, . const char *; dir = nullptr, . const char *; suffix = nullptr. ). virtual . Create a secure temporary file by appending a unique 6 letter string to base. ; The file will be created in a standard (system) directory or in the directory provided in dir. Optionally one can provide suffix append to the final name - like extension "".txt"" or "".html"". The full filename is returned in base and a filepointer is returned for safely writing to the file (this avoids certain security problems). Returns 0 in case of error. ; Reimplemented in TUnixSystem, and ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSystem.html:94329,log,logging,94329,doc/master/classTSystem.html,https://root.cern,https://root.cern/doc/master/classTSystem.html,2,['log'],"['log', 'logging']"
Testability,"ne 937 of file TMultiDimFit.cxx. EvalError(). Double_t TMultiDimFit::EvalError ; (; const Double_t *; x, . const Double_t *; coeff = nullptr. ); const. virtual . Evaluate parameterization error at point x. ; Optional argument coeff is a vector of coefficients for the parameterisation, fNCoefficients elements long. ; Definition at line 904 of file TMultiDimFit.cxx. EvalFactor(). Double_t TMultiDimFit::EvalFactor ; (; Int_t; p, . Double_t; x. ); const. protectedvirtual . PRIVATE METHOD: Evaluate function with power p at variable value x. ; Definition at line 952 of file TMultiDimFit.cxx. FindParameterization(). void TMultiDimFit::FindParameterization ; (; Option_t *; option = """"). virtual . Find the parameterization. ; Options: None so far; For detailed description of what this entails, please refer to the class description ; Definition at line 994 of file TMultiDimFit.cxx. Fit(). void TMultiDimFit::Fit ; (; Option_t *; option = """"). virtual . Try to fit the found parameterisation to the test sample. ; Options M use Minuit to improve coefficients; Also, refer to class description ; Definition at line 1013 of file TMultiDimFit.cxx. GetChi2(). Double_t TMultiDimFit::GetChi2 ; (; ); const. inline . Definition at line 140 of file TMultiDimFit.h. GetCoefficients(). const TVectorD * TMultiDimFit::GetCoefficients ; (; ); const. inline . Definition at line 142 of file TMultiDimFit.h. GetCoefficientsRMS(). const TVectorD * TMultiDimFit::GetCoefficientsRMS ; (; ); const. inline . Definition at line 143 of file TMultiDimFit.h. GetCorrelationMatrix(). const TMatrixD * TMultiDimFit::GetCorrelationMatrix ; (; ); const. inline . Definition at line 141 of file TMultiDimFit.h. GetError(). Double_t TMultiDimFit::GetError ; (; ); const. inline . Definition at line 144 of file TMultiDimFit.h. GetFunctionCodes(). Int_t * TMultiDimFit::GetFunctionCodes ; (; ); const. inline . Definition at line 145 of file TMultiDimFit.h. GetFunctions(). const TMatrixD * TMult",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMultiDimFit.html:43829,test,test,43829,doc/master/classTMultiDimFit.html,https://root.cern,https://root.cern/doc/master/classTMultiDimFit.html,1,['test'],['test']
Testability,"ne ends up with a set of decision trees (a forest). Gradient boosting works more like a function expansion approach, where each tree corresponds to a summand. The parameters for each summand (tree) are determined by the minimization of a error function (binomial log- likelihood for classification and Huber loss for regression). A greedy algorithm is used, which means, that only one tree is modified at a time, while the other trees stay fixed. Bagging:; In this particular variant of the Boosted Decision Trees the boosting is not done on the basis of previous training results, but by a simple stochastic re-sampling of the initial training event sample. Random Trees:; Similar to the ""Random Forests"" from Leo Breiman and Adele Cutler, it uses the bagging algorithm together and bases the determination of the best node-split during the training on a random subset of variables only which is individually chosen for each split. Analysis:; Applying an individual decision tree to a test event results in a classification of the event as either signal or background. For the boosted decision tree selection, an event is successively subjected to the whole set of decision trees and depending on how often it is classified as signal, a ""likelihood"" estimator is constructed for the event being signal or background. The value of this estimator is the one which is then used to select the events from an event sample, and the cut value on this estimator defines the efficiency and purity of the selection. ; Definition at line 63 of file MethodBDT.h. Public Member Functions; MethodBDT (const TString &jobName, const TString &methodTitle, DataSetInfo &theData, const TString &theOption=""""); The standard constructor for the ""boosted decision trees"". ; ; MethodBDT (DataSetInfo &theData, const TString &theWeightFile); ; virtual~MethodBDT (void); Destructor. ; ; voidAddWeightsXMLTo (void *parent) const; Write weights to XML. ; ; Double_tBoost (std::vector< const TMVA::Event * > &, Decis",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1MethodBDT.html:3545,test,test,3545,doc/master/classTMVA_1_1MethodBDT.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1MethodBDT.html,1,['test'],['test']
Testability,"ne exists); Int_tTAttPad::fFrameBorderModepad frame border mode; Width_tTAttPad::fFrameBorderSizepad frame border size; Color_tTAttPad::fFrameFillColorpad frame fill color; Style_tTAttPad::fFrameFillStylepad frame fill style; Color_tTAttPad::fFrameLineColorpad frame line color; Style_tTAttPad::fFrameLineStylepad frame line style; Width_tTAttPad::fFrameLineWidthpad frame line width; Int_tfGLDevice! OpenGL off-screen pixmap identifier; Bool_tfGridxSet to true if grid along X; Bool_tfGridySet to true if grid along Y; Double_tfHNDCHeight of pad along Y in NDC; Float_tTAttPad::fLeftMarginLeftMargin; Color_tTAttLine::fLineColorline color; Style_tTAttLine::fLineStyleline style; Width_tTAttLine::fLineWidthline width; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; Int_tfLogx(=0 if X linear scale, =1 if log scale); Int_tfLogy(=0 if Y linear scale, =1 if log scale); Int_tfLogz(=0 if Z linear scale, =1 if log scale); Bool_tfModifiedSet to true when pad is modified; TPad*fMother! pointer to mother of the list; TStringfNamePad name; Int_tfNumberpad number identifier; Int_tfPadPaintSet to 1 while painting the pad; TObject*fPadPointer! free pointer; TObject*fPadView3D! 3D View of this TPad; Double_tfPhiphi angle to view as lego/surface; Double_tfPixeltoXxworld = fPixeltoXk + fPixeltoX*xpixel; Double_tfPixeltoXkConversion coefficient for pixel to X World; Double_tfPixeltoYyworld = fPixeltoYk + fPixeltoY*ypixel; Double_tfPixeltoYkConversion coefficient for pixel to Y World; Int_tfPixmapID! Off-screen pixmap identifier; TList*fPrimitives->List of primitives (subpads); Bool_tTVirtualPad::fResizing!true when resizing the pad; Float_tTAttPad::fRightMarginRightMargin; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; Double_tfThetatheta angle to view as lego/surface; Int_tfTickxSet to 1 if tick marks along X; Int_tfTickySet to 1 if tick marks along Y; TStringfTitlePad title; Flo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TPad.html:25402,log,log,25402,root/html528/TPad.html,https://root.cern,https://root.cern/root/html528/TPad.html,6,['log'],['log']
Testability,"ne(); // renaming is recommended,; hnew->SetName(""hnew""); // because otherwise you will have; // two histograms with the same; // name; 3.10 Normalizing Histograms; You can scale a histogram ( TH1 *h ) such that the bins integral is equal to the normalization parameter norm:; Double_t scale = norm/h->Integral();; h->Scale(scale);; 3.11 Saving/Reading Histograms to/from a File; The following statements create a ROOT file and store a histogram on the file. Because TH1 derives from TNamed , the key identifier on the file is the histogram name:; TFile f(""histos.root"",""new"");; TH1F h1(""hgaus"",""histo from a gaussian"",100,-3,3);; h1.FillRandom(""gaus"",10000);; h1->Write();; To read this histogram in another ROOT session, do:; TFile f(""histos.root"");; TH1F *h = (TH1F*)f.Get(""hgaus"");; One can save all histograms in memory to the file by:; file->Write();; For a more detailed explanation, see Input/Output.; 3.12 Miscellaneous Operations. TH1::KolmogorovTest( TH1* h2,Option_t *option) is statistical test of compatibility in shape between two histograms. The parameter option is a character string that specifies:; U include Underflows in test (also for 2-dim); O include Overflows (also valid for 2-dim); N include comparison of normalizations; D put out a line of Debug printout; M return the maximum Kolmogorov distance instead of prob; X run the pseudo experiments post-processor with the following procedure: it makes pseudo experiments based on random values from the parent distribution and compare the KS distance of the pseudo experiment to the parent distribution. Bin the KS distances in a histogram, and then take the integral of all the KS values above the value obtained from the original data to Monte Carlo distribution. The number of pseudo-experiments NEXPT is currently fixed at 1000. The function returns the integral. Note that this option X is much slower.; TH1::Smooth - smoothes the bin contents of a 1D histogram.; TH1::Integral(Option_t *opt)-returns the",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:115688,test,test,115688,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['test'],['test']
Testability,"ne(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); virtual RooAbsArg*RooAbsCategory::createFundamental(const char* newname = 0) const; Roo1DTable*RooAbsCategory::createTable(const char* label) const; virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; Bool_tdefineType(const char* label); Bool_tdefineType(const char* label, Int_t index); virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTO",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooCategory.html:3259,test,testArg,3259,root/html532/RooCategory.html,https://root.cern,https://root.cern/root/html532/RooCategory.html,1,['test'],['testArg']
Testability,"ne,; Correlations=False,; ); ; ; ## Declare DataLoader(s); ; # The next step is to declare the DataLoader class that deals with input variables; ; # Define the input variables that shall be used for the MVA training; # note that you may also use variable expressions, which can be parsed by TTree::Draw( ""expression"" )]; ; # In this case the input data consists of an image of 16x16 pixels. Each single pixel is a branch in a ROOT TTree; ; loader = TMVA.DataLoader(""dataset""); ; ; ## Setup Dataset(s); ; # Define input data file and signal and background trees; ; ; imgSize = 16 * 16; inputFileName = ""images_data_16x16.root""; ; # if the input file does not exist create it; if ROOT.gSystem.AccessPathName(inputFileName):; MakeImagesTree(nevt, 16, 16); ; inputFile = TFile.Open(inputFileName); if inputFile is None:; ROOT.Warning(""TMVA_CNN_Classification"", ""Error opening input file %s - exit"", inputFileName.Data()); ; ; # inputFileName = ""tmva_class_example.root""; ; ; # --- Register the training and test trees; ; signalTree = inputFile.Get(""sig_tree""); backgroundTree = inputFile.Get(""bkg_tree""); ; nEventsSig = signalTree.GetEntries(); nEventsBkg = backgroundTree.GetEntries(); ; # global event weights per tree (see below for setting event-wise weights); signalWeight = 1.0; backgroundWeight = 1.0; ; # You can add an arbitrary number of signal or background trees; loader.AddSignalTree(signalTree, signalWeight); loader.AddBackgroundTree(backgroundTree, backgroundWeight); ; ## add event variables (image); ## use new method (from ROOT 6.20 to add a variable array for all image data); loader.AddVariablesArray(""vars"", imgSize); ; # Set individual event weights (the variables must exist in the original TTree); # for signal : factory->SetSignalWeightExpression (""weight1*weight2"");; # for background: factory->SetBackgroundWeightExpression(""weight1*weight2"");; # loader->SetBackgroundWeightExpression( ""weight"" );; ; # Apply additional cuts on the signal and background samples (can be differ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVA__CNN__Classification_8py.html:7117,test,test,7117,doc/master/TMVA__CNN__Classification_8py.html,https://root.cern,https://root.cern/doc/master/TMVA__CNN__Classification_8py.html,1,['test'],['test']
Testability,"ne. protected:. TMVA::Types::EAnalysisTypeTMVA::MethodBase::fAnalysisTypemethod-mode : true --> regression, false --> classification; UInt_tTMVA::MethodBase::fBackgroundClassindex of the Background-class; vector<TString>*TMVA::MethodBase::fInputVarsvector of input variables used in MVA; vector<Float_t>*TMVA::MethodBase::fMulticlassReturnValholds the return-values for the multiclass classification; Int_tTMVA::MethodBase::fNbinsnumber of bins in representative histograms; Int_tTMVA::MethodBase::fNbinsHnumber of bins in evaluation histograms; TMVA::Ranking*TMVA::MethodBase::fRankingpointer to ranking object (created by derived classifiers); vector<Float_t>*TMVA::MethodBase::fRegressionReturnValholds the return-values for the regression; UInt_tTMVA::MethodBase::fSignalClassindex of the Signal-class. private:. Bool_tfCompresscompress foam output file; Bool_tfCutNminKeep for bw compatibility: Grabbing cell with maximal RMS to split next (TFoam default); TStringfDTLogicuse DT algorithm to split cells; TMVA::EDTSeparationfDTSeparationenum which specifies the separation to use for the DT logic; Double_tfDiscrErrCutcut on discrimant error; Int_tfEvPerBinMaximum events (equiv.) per bin in buid-up (1000); Bool_tfFillFoamWithOrigWeightsfill the foam with boost weights; vector<PDEFoam*>fFoam; Double_tfFracFraction used for calc of Xmin, Xmax; TMVA::EKernelfKernelKernel for GetMvaValue(); TStringfKernelStrKernel for GetMvaValue() (option string); UInt_tfMaxDepthmaximum depth of cell tree; Bool_tfMultiTargetRegressiondo regression on multible targets; UInt_tfNminminimal number of events in cell necessary to split cell""; Bool_tfPeekMaxpeek up cell with max. driver integral for split; Bool_tfSigBgSeparatedSeparate Sig and Bg, or not; TMVA::ETargetSelectionfTargetSelectionmethod of selecting the target (only mulit target regr.); TStringfTargetSelectionStrmethod of selecting the target (only mulit target regr.); Bool_tfUseYesNoCellreturn -1 or 1 for bg or signal like event; Float_tfVol",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMVA__MethodPDEFoam.html:16139,log,logic,16139,root/html528/TMVA__MethodPDEFoam.html,https://root.cern,https://root.cern/root/html528/TMVA__MethodPDEFoam.html,1,['log'],['logic']
Testability,ne.h. clone(). TObject * RooSpline::clone ; (; const char *; newname); const. inlineoverridevirtual . Virtual copy constructor. ; Parameters. [in]newnameThe name of the cloned object (optional). . Implements RooAbsArg.; Definition at line 38 of file RooSpline.h. DeclFileName(). static const char * RooSpline::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 49 of file RooSpline.h. evaluate(). double RooSpline::evaluate ; (; ); const. overrideprotectedvirtual . Evaluate the spline function at the current point. ; Implements RooAbsReal.; Definition at line 128 of file RooSpline.cxx. IsA(). TClass * RooSpline::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from RooAbsReal.; Definition at line 49 of file RooSpline.h. Streamer(). void RooSpline::Streamer ; (; TBuffer &; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from RooAbsReal. StreamerNVirtual(). void RooSpline::StreamerNVirtual ; (; TBuffer &; ClassDef_StreamerNVirtual_b). inline . Definition at line 49 of file RooSpline.h. Member Data Documentation. _logx. bool RooSpline::_logx = false. private . Flag indicating logarithmic scaling of x values. ; Definition at line 46 of file RooSpline.h. _logy. bool RooSpline::_logy = false. private . Flag indicating logarithmic scaling of y values. ; Definition at line 47 of file RooSpline.h. _spline. std::unique_ptr<TSpline> RooSpline::_spline. private . The spline object. ; Definition at line 44 of file RooSpline.h. _x. RooRealProxy RooSpline::_x. private . The independent variable. ; Definition at line 45 of file RooSpline.h. Libraries for RooSpline:. [legend]; The documentation for this class was generated from the following files:; roofit/roofit/inc/RooSpline.h; roofit/roofit/src/RooSpline.cxx. RooSpline. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:42:09 (GVA Time) using Doxygen 1.9.8 ; . ,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooSpline.html:65063,log,logarithmic,65063,doc/master/classRooSpline.html,https://root.cern,https://root.cern/doc/master/classRooSpline.html,2,['log'],['logarithmic']
Testability,"ne; TGNumberEntry*fLinesToending line; TGListBox*fLogListlist of workers; TGTextButton*fLogNewdisplay logs button; TProofLog*fProofLogthe log; TGCheckButton*fRawLinesdisplay raw lines button; TGTextButton*fSavesave button; TGNumberEntry*fSessNumrelative index of the session to get; Int_tfSessionIdx; TStringfSessionUrl; TGTextView*fTexttext widget; Int_tfTextTypeType of retrieval; TGTextButton*fUrlButtonrebuild button; TGTextEntry*fUrlTexturl to connect to; TGVerticalFrame*fVworkersVertical frame; static TProofProgressLog::ETextTypekGrep; static TProofProgressLog::ETextTypekRaw; static TProofProgressLog::ETextTypekStd. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TProofProgressLog(TProofProgressDialog* d, Int_t w = 700, Int_t h = 600); Create a window frame for log messages. TProofProgressLog(const char* url = 0, Int_t sessionidx = 0, Int_t w = 700, Int_t h = 600); Create a window frame for log messages. void Init(Int_t w = 700, Int_t h = 600); Init window frame for log messages. ~TProofProgressLog(); Destructor. void Popup(); Show log window. void Clear(Option_t* = 0); Clear log window. void LoadBuffer(const char* buffer); Load a text buffer in the window. void LoadFile(const char* file); Load a file in the window. void AddBuffer(const char* buffer); Add text to the window. void CloseWindow(); Handle close button or when closed via window manager action. void BuildLogList(Bool_t create = kFALSE); Build the list of workers. For this, extract the logs and take the names; of TProofLogElements. void DoLog(Bool_t grep = kFALSE); Display logs. 'grep' is set to kTRUE if it is invoked by pressing the; 'Filter' button. void LogMessage(const char* msg, Bool_t all); Load/append a log msg in the log frame, if open. void SaveToFile(); Save the logs to a file; Only the name of the file is taken, no expansion. void SetGrepView(); Sets the view of grep filters according to the value of checkboxes. void NoLineEntry(); Enable/disable the l",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TProofProgressLog.html:25234,log,log,25234,root/html602/TProofProgressLog.html,https://root.cern,https://root.cern/root/html602/TProofProgressLog.html,2,['log'],['log']
Testability,"ne; first the primitive components. The object that handle boolean; operations among components is called TGeoBoolCombinator and it has to be; constructed providing a string boolean expression between the components names. Example for building a simple geometry :. rootgeom.C //; ; //. /*. */. TGeoManager - the manager class for the geometry package. TGeoManager class is embedding all the API needed for building and tracking; a geometry. It defines a global pointer (gGeoManager) in order to be fully; accessible from external code. The mechanism of handling multiple geometries; at the same time will be soon implemented. TGeoManager is the owner of all geometry objects defined in a session,; therefore users must not try to control their deletion. It contains lists of; media, materials, transformations, shapes and volumes. Logical nodes (positioned; volumes) are created and destroyed by the TGeoVolume class. Physical; nodes and their global transformations are subjected to a caching mechanism; due to the sometimes very large memory requirements of logical graph expansion.; The caching mechanism is triggered by the total number of physical instances; of volumes and the cache manager is a client of TGeoManager. The manager class; also controls the painter client. This is linked with ROOT graphical libraries; loaded on demand in order to control visualization actions. Rules for building a valid geometry. A given geometry can be built in various ways, but there are mandatory steps; that have to be followed in order to be validated by the modeler. There are; general rules : volumes needs media and shapes in order to be created,; both container an containee volumes must be created before linking them together,; and the relative transformation matrix must be provided. All branches must; have an upper link point otherwise they will not be considered as part of the; geometry. Visibility or tracking properties of volumes can be provided both; at build time or after geometry is clo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoManager.html:5494,log,logical,5494,root/html528/TGeoManager.html,https://root.cern,https://root.cern/root/html528/TGeoManager.html,6,['log'],['logical']
Testability,"near to far camera clip planes; (the minimum and maximum visible depth). See also; TGLVertex3 TGLCamera::ViewportToWorld(const TGLVertex3 & viewportVertex) const; for 3D viewport -> 3D world vertex conversions.; See also OpenGL gluUnProject & glDepth documentation. Camera must have valid frustum cache - call Apply() after last modifcation, before using. std::pair<Bool_t, TGLVertex3> ViewportPlaneIntersection(Double_t viewportX, Double_t viewportY, const TGLPlane& worldPlane) const; Find the intersection of projection of supplied viewport point (a 3D world; line - see ViewportToWorld) with supplied world plane. Returns std::pair; of Bool_t and TGLVertex3. If line intersects std::pair.first (Bool_t) is; kTRUE, and std::pair.second (TGLVertex) contains the intersection vertex.; If line does not intersect (line and plane parallel) std::pair.first; (Bool_t) if kFALSE, and std::pair.second (TGLVertex) is invalid. NOTE: The projection lines is extended for the plane intersection test; hence the intersection vertex can lie outside the near/far clip regions; (not visible). Camera must have valid frustum cache - call Apply() after last modifcation, before using. std::pair<Bool_t, TGLVertex3> ViewportPlaneIntersection(const TPoint& viewport, const TGLPlane& worldPlane) const; Find the intersection of projection of supplied viewport TPoint (a 3D world; line - see ViewportToWorld) with supplied world plane. Returns std::pair; of bool and vertex. If line intersects. Camera must have valid frustum cache - call Apply() after last modifcation, before using. TGLVector3 ViewportDeltaToWorld(const TGLVertex3& worldRef, Double_t viewportXDelta, Double_t viewportYDelta, TGLMatrix* modviewMat = 0) const; Apply a 2D viewport delta (shift) to the projection of worldRef onto viewport,; returning the resultant world vector which equates to it. Useful for making; 3D world objects track mouse moves. Camera must have valid frustum cache - call Apply(). Bool_t OfInterest(const TGLBoundingBox& box",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGLCamera.html:12565,test,test,12565,root/html528/TGLCamera.html,https://root.cern,https://root.cern/root/html528/TGLCamera.html,6,['test'],['test']
Testability,"necting; to a master server, which in turn will start a set of slave servers, or; directly starting as master server (if master = """"). For a description; of the arguments see the TProof ctor. Returns the number of started; master or slave servers, returns 0 in case of error, in which case; fValid remains false. ~TProofLite(); Destructor. Int_t GetNumberOfWorkers(const char* url = 0); Static method to determine the number of workers giving priority to users request.; Otherwise use the system information, if available, or just start; the minimal number, i.e. 2 . Int_t SetupWorkers(Int_t opt = 0, TList* wrks = 0); Start up PROOF workers. void NotifyStartUp(const char* action, Int_t done, Int_t tot); Notify setting-up operation message. Int_t SetProofServEnv(const char* ord); Create environment files for worker 'ord'. void ResolveKeywords(TString& s, const char* ord, const char* logfile); Resolve some keywords in 's'; <logfilewrk>, <user>, <rootsys>, <cpupin>. Int_t CreateSandbox(); Create the sandbox for this session. void Print(Option_t* option = """") const; Print status of PROOF-Lite cluster. TProofQueryResult * MakeQueryResult(Long64_t nent, const char* opt, Long64_t fst, TDSet* dset, const char* selec); Create a TProofQueryResult instance for this query. void SetQueryRunning(TProofQueryResult* pq); Set query in running state. Long64_t DrawSelect(TDSet* dset, const char* varexp, const char* selection = """", Option_t* option = """", Long64_t nentries = -1, Long64_t firstentry = 0); Execute the specified drawing action on a data set (TDSet).; Event- or Entry-lists should be set in the data set object using; TDSet::SetEntryList.; Returns -1 in case of error or number of selected events otherwise. Long64_t Process(TDSet* dset, const char* sel, Option_t* o = """", Long64_t nent = -1, Long64_t fst = 0); Process a data set (TDSet) using the specified selector (.C) file.; Entry- or event-lists should be set in the data set object using; TDSet::SetEntryList.; The return value is -",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TProofLite.html:29837,sandbox,sandbox,29837,root/html534/TProofLite.html,https://root.cern,https://root.cern/root/html534/TProofLite.html,3,['sandbox'],['sandbox']
Testability,"nection from any object of the same class to a single slot. ; ; static Bool_tConnect (TQObject *sender, const char *signal, const char *receiver_class, void *receiver, const char *slot); Create connection between sender and receiver. ; ; static const char *DeclFileName (); ; static Bool_tDisconnect (const char *class_name, const char *signal, void *receiver=nullptr, const char *slot=nullptr); Disconnects ""class signal"". ; ; static Bool_tDisconnect (TQObject *sender, const char *signal=nullptr, void *receiver=nullptr, const char *slot=nullptr); Disconnects signal in object sender from slot_method in object receiver. ; . Protected Member Functions; TProofLite (); ; Int_tCopyMacroToCache (const char *macro, Int_t headerRequired=0, TSelector **selector=0, Int_t opt=0, TList *wrks=0); Copy a macro, and its possible associated .h[h] file, to the cache directory, from where the workers can get the file. ; ; Int_tInit (const char *masterurl, const char *conffile, const char *confdir, Int_t loglevel, const char *alias=0); Start the PROOF environment. ; ; TProofQueryResult *MakeQueryResult (Long64_t nent, const char *opt, Long64_t fst, TDSet *dset, const char *selec); Create a TProofQueryResult instance for this query. ; ; Int_tPollForNewWorkers () override; Simulate dynamic addition, for test purposes. ; ; voidSetQueryRunning (TProofQueryResult *pq); Set query in running state. ; ; Int_tSetupWorkers (Int_t opt=0, TList *wrks=0); Start up PROOF workers. ; ; Protected Member Functions inherited from TProof; TProof (); Protected constructor to be used by classes deriving from TProof (they have to call Init themselves and override StartSlaves appropriately). ; ; Int_tAddWorkers (TList *wrks); Works on the master node only. ; ; Int_tAssertPath (const char *path, Bool_t writable); Make sure that 'path' exists; if 'writable' is kTRUE, make also sure that the path is writable. ; ; Int_tCollect (ESlaves list=kActive, Long_t timeout=-1, Int_t ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProofLite.html:35461,log,loglevel,35461,doc/master/classTProofLite.html,https://root.cern,https://root.cern/doc/master/classTProofLite.html,1,['log'],['loglevel']
Testability,"ned by TPyBuffer(). If the optional result parameter is non-zero, the result parameter will be swapped with a std::any variable on the Python side. You need to define this variable yourself, and it needs to be of type std::any and its name needs to be ""_anyresult"" by default. Like this, you can pass information from Python back to C++.; Parameters. cmdThe Python command to be executed as a string. ; resultOptional pointer to a std::any object that can be used to transfer results from Python to C++. ; resultNameName of the Python variable that is swapped over to the std::any result. The default value is ""_anyresult"". . Returnsbool Returns true if the command was successfully executed, otherwise returns false. ; Definition at line 425 of file TPython.cxx. ExecScript(). void TPython::ExecScript ; (; const char *; name, . int; argc = 0, . const char **; argv = nullptr. ). static . Execute a python stand-alone script, with argv CLI arguments. ; example of use: const char* argv[] = { ""1"", ""2"", ""3"" }; TPython::ExecScript( ""test.py"", sizeof(argv)/sizeof(argv[0]), argv ); ; Definition at line 381 of file TPython.cxx. Import(). Bool_t TPython::Import ; (; const char *; name). static . Import the named python module and create Cling equivalents for its classes and methods. ; Definition at line 237 of file TPython.cxx. Initialize(). Bool_t TPython::Initialize ; (; ). staticprivate . Initialization method: setup the python interpreter and load the ROOT module. ; Definition at line 137 of file TPython.cxx. LoadMacro(). void TPython::LoadMacro ; (; const char *; name). static . Execute the give python script as if it were a macro (effectively an execfile in main), and create Cling equivalents for any newly available python classes. ; Definition at line 305 of file TPython.cxx. The documentation for this class was generated from the following files:; bindings/tpython/inc/TPython.h; bindings/tpython/src/TPython.cxx. TPython. ROOT master - Reference Guide Generated on T",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTPython.html:5987,test,test,5987,doc/master/classTPython.html,https://root.cern,https://root.cern/doc/master/classTPython.html,1,['test'],['test']
Testability,"ned extended likelihood fits (Binned(),Extended()) on data generated; // with a Poisson fluctuation on Nobs (Extended()); RooMCStudy *mcs = new RooMCStudy(model, mjjj, Binned(), Silence(), Extended(true),; FitOptions(Extended(true), PrintEvalErrors(-1)));; ; // C u s t o m i z e m a n a g e r; // ---------------------------------; ; // Add module that randomizes the summed value of nsig+nbkg; // sampling from a uniform distribution between 0 and 1000; //; // In general one can randomize a single parameter, or a; // sum of N parameters, using either a uniform or a Gaussian; // distribution. Multiple randomization can be executed; // by a single randomizer module; ; RooRandomizeParamMCSModule randModule;; randModule.sampleSumUniform(RooArgSet(nsig, nbkg), 50, 500);; mcs->addModule(randModule);; ; // Add profile likelihood calculation of significance. Redo each; // fit while keeping parameter nsig fixed to zero. For each toy,; // the difference in -log(L) of both fits is stored, as well; // a simple significance interpretation of the delta(-logL); // using Dnll = 0.5 sigma^2; ; RooDLLSignificanceMCSModule sigModule(nsig, 0);; mcs->addModule(sigModule);; ; // R u n m a n a g e r , m a k e p l o t s; // ---------------------------------------------; ; // Run 1000 experiments. This configuration will generate a fair number; // of (harmless) MINUIT warnings due to the instability of the Chebychev polynomial fit; // at low statistics.; mcs->generateAndFit(500);; ; // Make some plots; TH1 *dll_vs_ngen = mcs->fitParDataSet().createHistogram(""ngen,dll_nullhypo_nsig"", AutoBinning(40), AutoBinning(40));; TH1 *z_vs_ngen = mcs->fitParDataSet().createHistogram(""ngen,significance_nullhypo_nsig"", AutoBinning(40), AutoBinning(40));; TH1 *errnsig_vs_ngen = mcs->fitParDataSet().createHistogram(""ngen,nsigerr"", AutoBinning(40), AutoBinning(40));; TH1 *errnsig_vs_nsig = mcs->fitParDataSet().createHistogram(""nsig,nsigerr"", AutoBinning(40), AutoBinning(40));; ; // Draw plots on canvas; TCanva",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf803__mcstudy__addons2_8C.html:2772,log,log,2772,doc/master/rf803__mcstudy__addons2_8C.html,https://root.cern,https://root.cern/doc/master/rf803__mcstudy__addons2_8C.html,2,['log'],"['log', 'logL']"
Testability,"ned geometrical objects having a given shape and medium and possibly; containing a list of nodes. Nodes represent just positioned instances of volumes; inside a container volume and they are not directly defined by user. They are; automatically created as a result of adding one volume inside other or dividing; a volume. The geometrical transformation hold by nodes is always defined with; respect to their mother (relative positioning). Reflection matrices are allowed.; All volumes have to be fully aware of their containees when the geometry is; closed. They will build aditional structures (voxels) in order to fasten-up; the search algorithms. Finally, nodes can be regarded as bidirectional links; between containers and containees objects. The structure defined in this way is a graph structure since volumes are; replicable (same volume can become daughter node of several other volumes),; every volume becoming a branch in this graph. Any volume in the logical graph; can become the actual top volume at run time (see TGeoManager::SetTopVolume()).; All functionalities of the modeler will behave in this case as if only the; corresponding branch starting from this volume is the registered geometry. /*. */. A given volume can be positioned several times in the geometry. A volume; can be divided according default or user-defined patterns, creating automatically; the list of division nodes inside. The elementary volumes created during the; dividing process follow the same scheme as usual volumes, therefore it is possible; to position further geometrical structures inside or to divide them further more; (see TGeoVolume::Divide()). The primitive shapes supported by the package are basically the GEANT3; shapes (see class TGeoShape), arbitrary wedges with eight vertices on two parallel; planes. All basic primitives inherits from class TGeoBBox since the bounding box; of a solid is essential for the tracking algorithms. They also implement the; virtual methods defined in the virtual",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoManager.html:3116,log,logical,3116,root/html528/TGeoManager.html,https://root.cern,https://root.cern/root/html528/TGeoManager.html,6,['log'],['logical']
Testability,"ned intGetNumberOfToys() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; RooStats::HybridCalculatorOriginalHybridCalculatorOriginal(const char* name = 0); RooStats::HybridCalculatorOriginalHybridCalculatorOriginal(const RooStats::HybridCalculatorOriginal&); RooStats::HybridCalculatorOriginalHybridCalculatorOriginal(RooAbsData& data, const RooStats::ModelConfig& sb_model, const RooStats::ModelConfig& b_model, bool GenerateBinned = false, int testStatistics = 1, int ntoys = 1000); RooStats::HybridCalculatorOriginalHybridCalculatorOriginal(RooAbsPdf& sb_model, RooAbsPdf& b_model, RooArgList& observables, const RooArgSet* nuisance_parameters = 0, RooAbsPdf* prior_pdf = 0, bool GenerateBinned = false, int testStatistics = 1, int ntoys = 1000); RooStats::HybridCalculatorOriginalHybridCalculatorOriginal(RooAbsData& data, RooAbsPdf& sb_model, RooAbsPdf& b_model, const RooArgSet* nuisance_parameters = 0, RooAbsPdf* prior_pdf = 0, bool GenerateBinned = false, int testStatistics = 1, int ntoys = 1000); RooStats::HypoTestCalculatorRooStats::HypoTestCalculator::HypoTestCalculator(); RooStats::HypoTestCalculatorRooStats::HypoTestCalculator::HypoTestCalculator(const RooStats::HypoTestCalculator&); virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTNamed::IsSortable() const; Bool_tTObject::IsZombie() const; virt",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooStats__HybridCalculatorOriginal.html:5351,test,testStatistics,5351,root/html602/RooStats__HybridCalculatorOriginal.html,https://root.cern,https://root.cern/root/html602/RooStats__HybridCalculatorOriginal.html,2,['test'],['testStatistics']
Testability,"ned intGetNumberOfToys() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; RooStats::HybridCalculatorOriginalHybridCalculatorOriginal(const char* name = 0); RooStats::HybridCalculatorOriginalHybridCalculatorOriginal(const RooStats::HybridCalculatorOriginal&); RooStats::HybridCalculatorOriginalHybridCalculatorOriginal(RooAbsData& data, const RooStats::ModelConfig& sb_model, const RooStats::ModelConfig& b_model, bool GenerateBinned = false, int testStatistics = 1, int ntoys = 1000); RooStats::HybridCalculatorOriginalHybridCalculatorOriginal(RooAbsPdf& sb_model, RooAbsPdf& b_model, RooArgList& observables, const RooArgSet* nuisance_parameters = 0, RooAbsPdf* prior_pdf = 0, bool GenerateBinned = false, int testStatistics = 1, int ntoys = 1000); RooStats::HybridCalculatorOriginalHybridCalculatorOriginal(RooAbsData& data, RooAbsPdf& sb_model, RooAbsPdf& b_model, const RooArgSet* nuisance_parameters = 0, RooAbsPdf* prior_pdf = 0, bool GenerateBinned = false, int testStatistics = 1, int ntoys = 1000); virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTNamed::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTNamed::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); static voidTObject::operator delete(void* ptr); static voidTObj",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooStats__HybridCalculatorOriginal.html:5341,test,testStatistics,5341,root/html528/RooStats__HybridCalculatorOriginal.html,https://root.cern,https://root.cern/root/html528/RooStats__HybridCalculatorOriginal.html,1,['test'],['testStatistics']
Testability,"ned intGetNumberOfToys() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; RooStats::HybridCalculatorOriginalHybridCalculatorOriginal(const char* name = 0); RooStats::HybridCalculatorOriginalHybridCalculatorOriginal(const RooStats::HybridCalculatorOriginal&); RooStats::HybridCalculatorOriginalHybridCalculatorOriginal(RooAbsData& data, const RooStats::ModelConfig& sb_model, const RooStats::ModelConfig& b_model, bool GenerateBinned = false, int testStatistics = 1, int ntoys = 1000); RooStats::HybridCalculatorOriginalHybridCalculatorOriginal(RooAbsPdf& sb_model, RooAbsPdf& b_model, RooArgList& observables, const RooArgSet* nuisance_parameters = 0, RooAbsPdf* prior_pdf = 0, bool GenerateBinned = false, int testStatistics = 1, int ntoys = 1000); RooStats::HybridCalculatorOriginalHybridCalculatorOriginal(RooAbsData& data, RooAbsPdf& sb_model, RooAbsPdf& b_model, const RooArgSet* nuisance_parameters = 0, RooAbsPdf* prior_pdf = 0, bool GenerateBinned = false, int testStatistics = 1, int ntoys = 1000); virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTNamed::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTNamed::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers,",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooStats__HybridCalculatorOriginal.html:5351,test,testStatistics,5351,root/html530/RooStats__HybridCalculatorOriginal.html,https://root.cern,https://root.cern/root/html530/RooStats__HybridCalculatorOriginal.html,3,['test'],['testStatistics']
Testability,"negative"",2=""&Positive"")}*; TGNumberFormat::ELimitfNumLimits*OPTION={GetMethod=""GetNumLimits"";SetMethod=""SetNumLimits"";Items=(0=""&No Limits"",1=""Limit M&in"",2=""Limit M&ax"",2=""Min &and Max"")}*; TGNumberFormat::EStylefNumStyle*OPTION={GetMethod=""GetNumStyle"";SetMethod=""SetNumStyle"";Items=(0=""Int"",5=""Real"",6=""Degree"",9=""Hour:Min:Sec"",10=""Day/Month/Year"",12=""Hex"")}*; const TGPicture*fPicDownDown arrow; const TGPicture*fPicUpUp arrow. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGNumberEntry(const TGWindow* parent = 0, Double_t val = 0, Int_t digitwidth = 5, Int_t id = -1, TGNumberFormat::EStyle style = kNESReal, TGNumberFormat::EAttribute attr = kNEAAnyNumber, TGNumberFormat::ELimit limits = kNELNoLimits, Double_t min = 0, Double_t max = 1); Constructs a numeric entry widget. ~TGNumberEntry(); Destructs a numeric entry widget. void Associate(const TGWindow* w); Make w the window that will receive the generated messages. void SetLogStep(Bool_t on = kTRUE); Set log steps. void SetState(Bool_t enable = kTRUE); Set the active state. void SetButtonToNum(Bool_t state); Send button messages to the number field (true) or parent widget (false).; When the message is sent to the parent widget, it is responsible to change; the numerical value accordingly. This can be useful to implement cursors; which move from data point to data point. For the message being sent; see ProcessMessage(). Bool_t ProcessMessage(Long_t msg, Long_t parm1, Long_t parm2); Process the up/down button messages. If fButtonToNum is false the; following message is sent: kC_COMMAND, kCM_BUTTON, widget id, param; param % 100 is the step size; param % 10000 / 100 != 0 indicates log step; param / 10000 != 0 indicates button down. TGLayoutManager * GetLayoutManager() const; Return layout manager. void ValueChanged(Long_t val); Emit ValueChanged(Long_t) signal. This signal is emitted when; fButtonToNum is false. The val has the following meaning:; val % 100 is the step size",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGNumberEntry.html:25211,log,log,25211,root/html528/TGNumberEntry.html,https://root.cern,https://root.cern/root/html528/TGNumberEntry.html,6,['log'],['log']
Testability,"nel algorithms similar to the ones used in the raster graphics community. ; ; voidStreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b); ; Public Member Functions inherited from TH1; ~TH1 () override; Histogram default destructor. ; ; virtual Bool_tAdd (const TH1 *h, const TH1 *h2, Double_t c1=1, Double_t c2=1); Replace contents of this histogram by the addition of h1 and h2. ; ; virtual Bool_tAdd (const TH1 *h1, Double_t c1=1); Performs the operation: this = this + c1*h1 If errors are defined (see TH1::Sumw2), errors are also recalculated. ; ; virtual Bool_tAdd (TF1 *h1, Double_t c1=1, Option_t *option=""""); Performs the operation: this = this + c1*f1 if errors are defined (see TH1::Sumw2), errors are also recalculated. ; ; virtual Double_tAndersonDarlingTest (const TH1 *h2, Double_t &advalue) const; Same function as above but returning also the test statistic value. ; ; virtual Double_tAndersonDarlingTest (const TH1 *h2, Option_t *option="""") const; Statistical test of compatibility in shape between this histogram and h2, using the Anderson-Darling 2 sample test. ; ; voidBrowse (TBrowser *b) override; Browse the Histogram object. ; ; virtual Bool_tCanExtendAllAxes () const; Returns true if all axes are extendable. ; ; virtual Double_tChi2Test (const TH1 *h2, Option_t *option=""UU"", Double_t *res=nullptr) const; \( \chi^{2} \) test for comparing weighted and unweighted histograms. ; ; virtual Double_tChi2TestX (const TH1 *h2, Double_t &chi2, Int_t &ndf, Int_t &igood, Option_t *option=""UU"", Double_t *res=nullptr) const; The computation routine of the Chisquare test. ; ; virtual Double_tChisquare (TF1 *f1, Option_t *option="""") const; Compute and return the chisquare of this histogram with respect to a function The chisquare is computed by weighting each histogram point by the bin error By default the full range of the histogram is used. ; ; virtual voidClearUnderflowAndOverflow (); Remove all the content from the underflow and ove",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTH2C.html:12211,test,test,12211,doc/master/classTH2C.html,https://root.cern,https://root.cern/doc/master/classTH2C.html,12,['test'],['test']
Testability,"nelIter kiter = kNonadaptiveKDE, const TH1* hist = 0, Float_t lower_edge = 0., Float_t upper_edge = 1., TMVA::KDEKernel::EKernelBorder kborder = kNoTreatment, Float_t FineFactor = 1.); TMVA::KDEKernel&operator=(const TMVA::KDEKernel&); voidSetKernelType(TMVA::KDEKernel::EKernelType ktype = kGauss); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). private:. TMVA::MsgLogger&Log() const. Data Members; public:. enum EKernelType { kNone; kGauss; };; enum EKernelIter { kNonadaptiveKDE; kAdaptiveKDE; };; enum EKernelBorder { kNoTreatment; kKernelRenorm; kSampleMirror; };. private:. Float_tfFineFactorfine tuning factor for Adaptive KDE: factor to multiply the ""width"" of the Kernel function; TH1F*fFirstIterHisthistogram to be filled in the hidden iteration; Bool_tfHiddenIterationDefines if whats currently running is the ; TH1F*fHistcopy of input histogram; TMVA::KDEKernel::EKernelIterfIteriteration number; TMVA::KDEKernel::EKernelBorderfKDEborderThe method to take care about ""border"" effects; TF1*fKernel_integthe integral of the Kernel function; TMVA::MsgLogger*fLoggermessage logger; Float_tfLowerEdgethe lower edge of the PDF; Float_tfSigmaWidth of the Kernel function; TH1F*fSigmaHistcontains the Sigmas Widths for adaptive KDE ; Float_tfUpperEdgethe upper edge of the PDF. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; KDEKernel(TMVA::KDEKernel::EKernelIter kiter = kNonadaptiveKDE, const TH1* hist = 0, Float_t lower_edge = 0., Float_t upper_edge = 1., TMVA::KDEKernel::EKernelBorder kborder = kNoTreatment, Float_t FineFactor = 1.); constructor; sanity check. ~KDEKernel(); destructor. void SetKernelType(TMVA::KDEKernel::EKernelType ktype = kGauss); fIter == 1 ---> nonadaptive KDE; fIter == 2 ---> adaptive KDE. Float_t GetBinKernelIntegral(Float_t lowr, Float_t highr, Float_t mean, Int_t binnum); calculates the integral of the Kernel. KDEKernel(TMVA::KDEKernel::EKernel",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMVA__KDEKernel.html:1753,log,logger,1753,root/html528/TMVA__KDEKernel.html,https://root.cern,https://root.cern/root/html528/TMVA__KDEKernel.html,3,['log'],['logger']
Testability,nents created by this object; Double_tRooAbsTestStatistic::_evalCarry! carry of Kahan sum in evaluatePartition; Int_tRooAbsTestStatistic::_extSet! Number of designated set to calculated extended term; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; RooAbsReal*RooAbsTestStatistic::_funcPointer to original input function; RooAbsReal*RooAbsOptTestStatistic::_funcClonePointer to internal clone of input function; RooArgSet*RooAbsOptTestStatistic::_funcCloneSetSet owning all components of internal clone of input function; RooArgSet*RooAbsOptTestStatistic::_funcObsSetList of observables in the pdf expression; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; pRooAbsTestStatistic*RooAbsTestStatistic::_gofArray! Array of sub-contexts representing part of the combined test statistic; RooAbsTestStatistic::GOFOpModeRooAbsTestStatistic::_gofOpModeOperation mode of test statistic instance; vector<RooFit::MPSplit>RooAbsTestStatistic::_gofSplitMode! GOF MP Split mode specified by component (when Auto is active); static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Bool_tRooAbsTestStatistic::_init! Is object initialized; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches; Bool_tRooAbsArg::_isConstant! Cached isConstant status; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; pRooRealMPFE*RooAbsTestStatistic::_mpfeArray! Array of parallel execution frond ends; RooFit::MPSplitRooAbsTestStatistic::_mpinterlUse interleaving strategy rather than N-wise split for partioning of dataset for multiprocessor-split; ,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooDataWeightedAverage.html:39296,test,test,39296,root/html602/RooDataWeightedAverage.html,https://root.cern,https://root.cern/root/html602/RooDataWeightedAverage.html,2,['test'],['test']
Testability,"nerateToyData(RooArgSet& ) const; This method generates a toy data set for the given parameter point taking; global observables into account. RooAbsData* Generate(RooAbsPdf& pdf, RooArgSet& observables, const RooDataSet* protoData = NULL, int forceEvents = 0) const; This is the generate function to use in the context of the ToyMCSampler; instead of the standard RooAbsPdf::generate(...).; It takes into account whether the number of events is given explicitly; or whether it should use the expected number of events. It also takes; into account the option to generate a binned data set (ie RooDataHist). ToyMCSampler(); Proof constructor. Do not use. ToyMCSampler(RooStats::TestStatistic& ts, Int_t ntoys). virtual ~ToyMCSampler(). SamplingDistribution* AppendSamplingDistribution(RooArgSet& allParameters, RooStats::SamplingDistribution* last, Int_t additionalMC); Extended interface to append to sampling distribution more samples. Double_t EvaluateTestStatistic(RooAbsData& data, RooArgSet& nullPOI); Main interface to evaluate the test statistic on a dataset. TestStatistic* GetTestStatistic() const; { return fTestStat; }. Double_t ConfidenceLevel() const; { return 1. - fSize; }. void Initialize(RooAbsArg& , RooArgSet& , RooArgSet& ); { return fNToys; }. void SetNToys(const Int_t ntoy); { fNToys = ntoy; }. void SetNEventsPerToy(const Int_t nevents); Forces n events even for extended PDFs. Set NEvents=0 to; use the Poisson distributed events from the extended PDF. void SetParametersForTestStat(const RooArgSet& nullpoi); specify the values of parameters used when evaluating test statistic. { fNullPOI = (RooArgSet*)nullpoi.snapshot(); }. void SetPdf(RooAbsPdf& pdf); Set the Pdf, add to the the workspace if not already there. { fPdf = &pdf; }. void SetPriorNuisance(RooAbsPdf* pdf); How to randomize the prior. Set to NULL to deactivate randomization. { fPriorNuisance = pdf; }. void SetNuisanceParameters(const RooArgSet& np); specify the nuisance parameters (eg. the rest of the para",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooStats__ToyMCSampler.html:5510,test,test,5510,root/html528/RooStats__ToyMCSampler.html,https://root.cern,https://root.cern/root/html528/RooStats__ToyMCSampler.html,1,['test'],['test']
Testability,"nes=nullptr); Render DrawElements in elementVec with given timeout. ; ; virtual voidRenderHighlight (TGLRnrCtx &rnrCtx, DrawElementPtrVec_t &elVec); ; voidRenderOpaque (TGLRnrCtx &rnrCtx) override; Render opaque elements. ; ; voidRenderSelOpaque (TGLRnrCtx &rnrCtx) override; Render selected opaque elements. ; ; voidRenderSelOpaqueForHighlight (TGLRnrCtx &rnrCtx) override; Render selected opaque elements for highlight. ; ; voidRenderSelTransp (TGLRnrCtx &rnrCtx) override; Render selected transparent elements. ; ; voidRenderSelTranspForHighlight (TGLRnrCtx &rnrCtx) override; Render selected transparent elements for highlight. ; ; voidRenderTransp (TGLRnrCtx &rnrCtx) override; Render transparent elements. ; ; Bool_tResolveSelectRecord (TGLSelectRecord &rec, Int_t curIdx) override; Process selection record rec. ; ; UInt_tSizeOfScene () const; Return memory cost of scene. ; ; voidStreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b); ; virtual voidUpdateLogical (TObject *logid); Drop display-lists for the logical (assume TGLObject/direct rendering). ; ; virtual voidUpdatePhysical (UInt_t phid, Double_t *trans, Color_t cidx=-1, UChar_t transp=0); Reposition/recolor physical shape. ; ; virtual voidUpdatePhysical (UInt_t phid, Double_t *trans, UChar_t *col); Reposition/recolor physical shape. ; ; virtual voidUpdatePhysioLogical (TObject *logid, Double_t *trans, Color_t cidx, UChar_t transp); Reposition/recolor physical for given logical (assume TGLObject and a single physical). ; ; virtual voidUpdatePhysioLogical (TObject *logid, Double_t *trans, UChar_t *col); Reposition/recolor physical for given logical (assume TGLObject and a single physical). ; ; voidUpdateSceneInfo (TGLRnrCtx &rnrCtx) override; Fill scene-info with information needed for rendering, take into account the render-context (viewer state, camera, clipping). ; ; Public Member Functions inherited from TGLSceneBase; TGLSceneBase (); ; ~TGLSceneBase () overr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGLScenePad.html:14702,log,logid,14702,doc/master/classTGLScenePad.html,https://root.cern,https://root.cern/doc/master/classTGLScenePad.html,2,['log'],"['logical', 'logid']"
Testability,"networks; : (TMlpANN, interfaced via TMVA) performed equally well, with however; : a clear speed advantage for the MLP. The Clermont-Ferrand neural ; : net (CFMlpANN) exhibited worse classification performance in these; : tests, which is partly due to the slow convergence of its training; : (at least 10k training cycles are required to achieve approximately; : competitive results).; : ; : [1mOvertraining: [0monly the TMlpANN performs an explicit separation of the; : full training sample into independent training and validation samples.; : We have found that in most high-energy physics applications the ; : available degrees of freedom (training events) are sufficient to ; : constrain the weights of the relatively simple architectures required; : to achieve good performance. Hence no overtraining should occur, and ; : the use of validation samples would only reduce the available training; : information. However, if the performance on the training sample is ; : found to be significantly better than the one found with the inde-; : pendent test sample, caution is needed. The results for these samples ; : are printed to standard output at the end of each training job.; : ; : [1m--- Performance tuning via configuration options:[0m; : ; : The hidden layer architecture for all ANNs is defined by the option; : ""HiddenLayers=N+1,N,..."", where here the first hidden layer has N+1; : neurons and the second N neurons (and so on), and where N is the number ; : of input variables. Excessive numbers of hidden layers should be avoided,; : in favour of more neurons in the first hidden layer.; : ; : The number of cycles should be above 500. As said, if the number of; : adjustable weights is small compared to the training sample size,; : using a large number of training samples should not lead to overtraining.; : ; : <Suppress this message by specifying ""!H"" in the booking option>; : [1m================================================================[0m; : ; TFHandler_MLPBNN : Vari",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVAClassification_8C.html:43540,test,test,43540,doc/master/TMVAClassification_8C.html,https://root.cern,https://root.cern/doc/master/TMVAClassification_8C.html,1,['test'],['test']
Testability,"ne{""myspline"", ""my spline"", x, x0, y0};; ; auto frame = x.frame();; spline.plotOn(frame);; frame->Draw();; RooAbsReal::plotOnvirtual RooPlot * plotOn(RooPlot *frame, const RooCmdArg &arg1={}, const RooCmdArg &arg2={}, const RooCmdArg &arg3={}, const RooCmdArg &arg4={}, const RooCmdArg &arg5={}, const RooCmdArg &arg6={}, const RooCmdArg &arg7={}, const RooCmdArg &arg8={}, const RooCmdArg &arg9={}, const RooCmdArg &arg10={}) constPlot (project) PDF on specified frame.Definition RooAbsReal.cxx:1611; RooPlot::Drawvoid Draw(Option_t *options=nullptr) overrideDraw this plot and all of the elements it contains.Definition RooPlot.cxx:637; RooRealVarVariable that can be changed from the outside.Definition RooRealVar.h:37; RooSplineA RooFit class for creating spline functions.Definition RooSpline.h:27; xDouble_t x[n]Definition legend1.C:17. Definition at line 27 of file RooSpline.h. Public Member Functions; RooSpline ()=default; ; RooSpline (const char *name, const char *title, RooAbsReal &x, const TGraph &gr, int order=3, bool logx=false, bool logy=false); Constructor for creating a spline from a TGraph. ; ; RooSpline (const char *name, const char *title, RooAbsReal &x, std::span< const double > x0, std::span< const double > y0, int order=3, bool logx=false, bool logy=false); Constructor for creating a spline from raw data. ; ; RooSpline (const RooSpline &other, const char *name=nullptr); Copy constructor. ; ; TObject *clone (const char *newname) const override; Virtual copy constructor. ; ; TClass *IsA () const override; ; voidStreamer (TBuffer &) override; Stream an object of class TObject. ; ; voidStreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b); ; Public Member Functions inherited from RooAbsReal; RooAbsReal (); coverity[UNINIT_CTOR] Default constructor ; ; RooAbsReal (const char *name, const char *title, const char *unit=""""); Constructor with unit label. ; ; RooAbsReal (const char *name, const char *title, double minVal, double maxVal,",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooSpline.html:1875,log,logx,1875,doc/master/classRooSpline.html,https://root.cern,https://root.cern/doc/master/classRooSpline.html,2,['log'],"['logx', 'logy']"
Testability,"nf] ; ; boolfHasMode; flag to control if distribution has a pre-computed mode ; ; boolfIsLogPdf; flag to control if function pointer represent log of pdf ; ; doublefMode; mode of the distribution ; ; boolfOwnFunc; flag to indicate if class manages the function pointers ; ; const ROOT::Math::IGenFunction *fPdf; pointer to the pdf ; ; doublefXmax; upper value of the domain ; ; doublefXmin; lower value of the domain ; . #include <TUnuranContDist.h>. Inheritance diagram for TUnuranContDist:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. TUnuranContDist() [1/5]. TUnuranContDist::TUnuranContDist ; (; TF1 *; pdf = nullptr, . TF1 *; deriv = nullptr, . bool; isLogPdf = false. ). explicit . Constructor from a TF1 objects specifying the pdf and optionally from another function representing the derivative of the pdf. ; The flag isLogPdf can be used to pass instead of the pdf (and its derivative) the log (and the derivative of the log) of the pdf. By default the distribution has not domain set (it is defined between [-inf,+inf], no mode, no pdf area and no cdf explicitly defined. UnuRan, if needed, can compute some of this quantities, but the user if they know them can set them in order to speed up the algorithm. For example in case of the Cdf, if the user has not set it, a numerical integration algorithm is used to estimate the Cdf from the Pdf. ; Definition at line 64 of file TUnuranContDist.cxx. TUnuranContDist() [2/5]. TUnuranContDist::TUnuranContDist ; (; TF1 *; pdf, . TF1 *; deriv, . TF1 *; cdf, . bool; isLogPdf = false. ). Constructor as above but with the possibility to pass also the Cdf. ; In case an algorithm requiring only the Cdf (no Pdf), one can use this constructor passing nullptr for Pdf and derivative of the Pdf ; Definition at line 46 of file TUnuranContDist.cxx. TUnuranContDist() [3/5]. TUnuranContDist::TUnuranContDist ; (; const ROOT:",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTUnuranContDist.html:5898,log,log,5898,doc/master/classTUnuranContDist.html,https://root.cern,https://root.cern/doc/master/classTUnuranContDist.html,2,['log'],['log']
Testability,"ng "" << nValidationSamples << "" validation samples."" << Endl;; 1109 Log() << kDEBUG << ""Using "" << nTestSamples << "" training samples."" << Endl;; 1110 ; 1111 fNet.Initialize(fWeightInitialization);; 1112 ; 1113 size_t trainingPhase = 1;; 1114 for (TTrainingSettings & settings : fTrainingSettings) {; 1115 ; 1116 if (fInteractive){; 1117 fInteractive->ClearGraphs();; 1118 }; 1119 ; 1120 Log() << ""Training phase "" << trainingPhase << "" of ""; 1121 << fTrainingSettings.size() << "":"" << Endl;; 1122 trainingPhase++;; 1123 ; 1124 TNet<TCpu<>> net(settings.batchSize, fNet);; 1125 net.SetWeightDecay(settings.weightDecay);; 1126 net.SetRegularization(settings.regularization);; 1127 // Need to convert dropoutprobabilities to conventions used; 1128 // by backend implementation.; 1129 std::vector<Double_t> dropoutVector(settings.dropoutProbabilities);; 1130 for (auto & p : dropoutVector) {; 1131 p = 1.0 - p;; 1132 }; 1133 net.SetDropoutProbabilities(dropoutVector);; 1134 net.InitializeGradients();; 1135 auto testNet = net.CreateClone(settings.batchSize);; 1136 ; 1137 using DataLoader_t = TDataLoader<TMVAInput_t, TCpu<>>;; 1138 ; 1139 // Split training data into training and validation set; 1140 const std::vector<Event *> &allData = GetEventCollection(Types::kTraining);; 1141 const std::vector<Event *> trainingInputData =; 1142 std::vector<Event *>(allData.begin(), allData.begin() + nTrainingSamples);; 1143 const std::vector<Event *> testInputData =; 1144 std::vector<Event *>(allData.begin() + nTrainingSamples, allData.end());; 1145 ; 1146 if (trainingInputData.size() != nTrainingSamples) {; 1147 Log() << kFATAL << ""Inconsistent training sample size"" << Endl;; 1148 }; 1149 if (testInputData.size() != nTestSamples) {; 1150 Log() << kFATAL << ""Inconsistent test sample size"" << Endl;; 1151 }; 1152 ; 1153 size_t nThreads = 1;; 1154 TMVAInput_t trainingTuple = std::tie(trainingInputData, DataInfo());; 1155 TMVAInput_t testTuple = std::tie(testInputData, DataInfo());; 1156 DataLoader_t ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/MethodDNN_8cxx_source.html:40754,test,testNet,40754,doc/master/MethodDNN_8cxx_source.html,https://root.cern,https://root.cern/doc/master/MethodDNN_8cxx_source.html,1,['test'],['testNet']
Testability,"ng = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooMoment*RooAbsReal::mean(RooRealVar& obs); RooMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooMinuit*minuit(); RooMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); static voidRooPrintable::nameFieldLength(Int_t newLen); RooAbsReal&nll(); virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TNamed&TNamed::operator=(const TNamed& rhs); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooProfileLL.html:17519,test,testArg,17519,root/html526/RooProfileLL.html,https://root.cern,https://root.cern/root/html526/RooProfileLL.html,2,['test'],['testArg']
Testability,"ng ONLY the variables specified in ""theVars"". Double_t Fill(const vector<TMVA::Event*>& events, Int_t theType = -1); create the search tree from the events in a TTree; using ALL the variables specified included in the Event. void NormalizeTree(vector<pair<double,const TMVA::Event*>,allocator<pair<double,const TMVA::Event*> > >::iterator , vector<pair<double,const TMVA::Event*>,allocator<pair<double,const TMVA::Event*> > >::iterator , UInt_t ). void NormalizeTree(); Normalisation of tree. void Clear(TMVA::Node* n = 0); clear nodes. Double_t SearchVolume(TMVA::Volume* , vector<const TMVA::BinarySearchTreeNode*>* events = 0); search the whole tree and add up all weigths of events that; lie within the given voluem. Double_t SearchVolume(TMVA::Node* , TMVA::Volume* , Int_t , vector<const TMVA::BinarySearchTreeNode*>* events); recursively walk through the daughter nodes and add up all weigths of events that; lie within the given volume. Bool_t InVolume(const vector<Float_t>& , TMVA::Volume* ) const; test if the data points are in the given volume. void CalcStatistics(TMVA::Node* n = 0); calculate basic statistics (mean, rms for each variable). Int_t SearchVolumeWithMaxLimit(TMVA::Volume* , vector<const TMVA::BinarySearchTreeNode*>* events = 0, Int_t = -1); recursively walk through the daughter nodes and add up all weigths of events that; lie within the given volume a maximum number of events can be given. Node * CreateNode(UInt_t ) const; { return new BinarySearchTreeNode(); }. BinaryTree* CreateTree() const; { return new BinarySearchTree(); }. const char* ClassName() const; { return ""BinarySearchTree""; }. void SetPeriode(Int_t p); set the periode (number of variables). { fPeriod = p; }. UInt_t GetPeriode( void ); return periode (number of variables). { return fPeriod; }. Float_t Mean(TMVA::Types::ESBType sb, UInt_t var); access to mean for signal and background for each variable. { return fMeans[sb==Types::kSignal?0:1][var]; }. Float_t RMS(TMVA::Types::ESBType sb, UInt_t ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMVA__BinarySearchTree.html:7000,test,test,7000,root/html528/TMVA__BinarySearchTree.html,https://root.cern,https://root.cern/root/html528/TMVA__BinarySearchTree.html,2,['test'],['test']
Testability,"ng ONLY the variables specified in ""theVars"". Double_t Fill(const vector<TMVA::Event*>& events, Int_t theType = -1); create the search tree from the events in a TTree; using ALL the variables specified included in the Event. void NormalizeTree(vector<pair<double,const TMVA::Event*>,allocator<pair<double,const TMVA::Event*> > >::iterator , vector<pair<double,const TMVA::Event*>,allocator<pair<double,const TMVA::Event*> > >::iterator , UInt_t ). void NormalizeTree(); Normalisation of tree. void Clear(TMVA::Node* n = 0); clear nodes. Double_t SearchVolume(TMVA::Volume* , vector<const TMVA::BinarySearchTreeNode*>* events = 0); search the whole tree and add up all weigths of events that; lie within the given voluem. Double_t SearchVolume(TMVA::Node* , TMVA::Volume* , Int_t , vector<const TMVA::BinarySearchTreeNode*>* events); recursively walk through the daughter nodes and add up all weigths of events that; lie within the given volume. Bool_t InVolume(const vector<Float_t>& , TMVA::Volume* ) const; test if the data points are in the given volume. void CalcStatistics(TMVA::Node* n = 0, Int_t signalClass = 0); calculate basic statistics (mean, rms for each variable). Int_t SearchVolumeWithMaxLimit(TMVA::Volume* , vector<const TMVA::BinarySearchTreeNode*>* events = 0, Int_t = -1); recursively walk through the daughter nodes and add up all weigths of events that; lie within the given volume a maximum number of events can be given. Node * CreateNode(UInt_t ) const; { return new BinarySearchTreeNode(); }. BinaryTree* CreateTree() const; { return new BinarySearchTree(); }. const char* ClassName() const; { return ""BinarySearchTree""; }. void SetPeriode(Int_t p); set the periode (number of variables). { fPeriod = p; }. UInt_t GetPeriode( void ); return periode (number of variables). { return fPeriod; }. Float_t Mean(TMVA::Types::ESBType sb, UInt_t var); access to mean for signal and background for each variable. { return fMeans[sb==Types::kSignal?0:1][var]; }. Float_t RMS(TMVA::Typ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TMVA__BinarySearchTree.html:7023,test,test,7023,root/html530/TMVA__BinarySearchTree.html,https://root.cern,https://root.cern/root/html530/TMVA__BinarySearchTree.html,2,['test'],['test']
Testability,ng X in Normalized Coordinates (NDC); 215 Double_t GetWNDC() const override { return fWNDC; }; 216 /// Get height of pad along Y in Normalized Coordinates (NDC); 217 Double_t GetHNDC() const override { return fHNDC; }; 218 UInt_t GetWw() const override;; 219 UInt_t GetWh() const override;; 220 Double_t GetAbsXlowNDC() const override { return fAbsXlowNDC; }; 221 Double_t GetAbsYlowNDC() const override { return fAbsYlowNDC; }; 222 Double_t GetAbsWNDC() const override { return fAbsWNDC; }; 223 Double_t GetAbsHNDC() const override { return fAbsHNDC; }; 224 Double_t GetAspectRatio() const override { return fAspectRatio; }; 225 Double_t GetPhi() const override { return fPhi; }; 226 Double_t GetTheta() const override { return fTheta; }; 227 ///Returns the minimum x-coordinate value visible on the pad. If log axis the returned value is in decades.; 228 Double_t GetUxmin() const override { return fUxmin; }; 229 ///Returns the minimum y-coordinate value visible on the pad. If log axis the returned value is in decades.; 230 Double_t GetUymin() const override { return fUymin; }; 231 ///Returns the maximum x-coordinate value visible on the pad. If log axis the returned value is in decades.; 232 Double_t GetUxmax() const override { return fUxmax; }; 233 ///Returns the maximum y-coordinate value visible on the pad. If log axis the returned value is in decades.; 234 Double_t GetUymax() const override { return fUymax; }; 235 Bool_t GetGridx() const override { return fGridx; }; 236 Bool_t GetGridy() const override { return fGridy; }; 237 Int_t GetNumber() const override { return fNumber; }; 238 Int_t GetTickx() const override { return fTickx; }; 239 Int_t GetTicky() const override { return fTicky; }; 240 Double_t GetX1() const override { return fX1; }; 241 Double_t GetX2() const override { return fX2; }; 242 Double_t GetY1() const override { return fY1; }; 243 Double_t GetY2() const override { return fY2; }; 244 static Int_t GetMaxPickDistance();; 245 TList *GetListOfPrimitives() con,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TPad_8h_source.html:12055,log,log,12055,doc/master/TPad_8h_source.html,https://root.cern,https://root.cern/doc/master/TPad_8h_source.html,1,['log'],['log']
Testability,"ng const&) Choose a likelihood evaluation backend: . Backend Description . cpu - default New vectorized evaluation mode, using faster math functions and auto-vectorisation. Since ROOT 6.23, this is the default if EvalBackend() is not passed, succeeding the legacy backend. If all RooAbsArg objects in the model support vectorized evaluation, likelihood computations are 2 to 10 times faster than with the legacy backend; unless your dataset is so small that the vectorization is not worth it. The relative difference of the single log-likelihoods with respect to the legacy mode is usually better than \(10^{-12}\), and for fit parameters it's usually better than \(10^{-6}\). In past ROOT releases, this backend could be activated with the now deprecated BatchMode() option. . cuda Evaluate the likelihood on a GPU that supports CUDA. This backend re-uses code from the cpu backend, but compiled in CUDA kernels. Hence, the results are expected to be identical, modulo some numerical differences that can arise from the different order in which the GPU is summing the log probabilities. This backend can drastically speed up the fit if all RooAbsArg object in the model support it. . legacy The original likelihood evaluation method. Evaluates the PDF for each single data entry at a time before summing the negative log probabilities. . codegen Experimental - Generates and compiles minimal C++ code for the NLL on-the-fly and wraps it in the returned RooAbsReal. Also generates and compiles the code for the gradient using Automatic Differentiation (AD) with Clad. This analytic gradient is passed to the minimizer, which can result in significant speedups for many-parameter fits, even compared to the cpu backend. However, if one of the RooAbsArg objects in the model does not support the code generation, this backend can't be used. . codegen_no_grad Experimental - Same as codegen, but doesn't generate and compile the gradient code and use the regular numerical differentiation instead. This ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsPdf.html:90901,log,log,90901,doc/master/classRooAbsPdf.html,https://root.cern,https://root.cern/doc/master/classRooAbsPdf.html,1,['log'],['log']
Testability,"ng objects. The Illegal overlaps folder is empty but can be filled after performing a geometry validity check (see section: Checking the Geometry). If tracking is performed using TGeo, the folder Tracks might contain user-defined tracks that can be visualized/animated in the geometry context (see section: Creating and Visualizing Tracks). Since for the time being we are interested more in the geometrical hierarchy, we will focus on the last two displayed items TOPand TOP_1. These are the top volume and the corresponding top node in the hierarchy.; Double clicking on the TOP volume will unfold all different volumes contained by the top volume. In the right panel, we will see all the volumes contained by TOP (if the same is positioned 4 times we will get 4 identical items). This rule will apply to any clicked volume in the hierarchy. Note that right clicking a volume item activates the volume context menu containing several specific methods. We will call the volume hierarchy developed in this way as the logical geometry graph. The volume objects are nodes inside this graph and the same volume can be accessed starting from different branches.; On the other hand, the real geometrical objects that are seen when visualizing or tracking the geometry are depicted in the TOP_1 branch. These are the nodes of the physical tree of positioned volumes represented by TGeoNode objects. This hierarchy is a tree since a node can have only one parent and several daughters. For a better understanding of the hierarchy, have a look at https://root.cern.ch/doc/master/classTGeoManager.html.; Just close now the X3D window and focus at the wire frame picture drawn in a pad. Activate Options/Event Status. Moving the mouse in the pad, you will notice that objects are sometimes changing color to red. Volumes are highlighted in this way whenever the mouse pointer is close enough to one of its vertices. When this happens, the corresponding volume is selected and you will see in the bottom righ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:884379,log,logical,884379,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['log'],['logical']
Testability,"ng the fit data points ; CDataWrapperClass maintaining a pointer to external data Using this class avoids copying the data when performing a fit NOTE: this class is not thread-safe and should not be used in parallel fits ; CDummyDeleter; CFcnAdapter; CFitConfigClass describing the configuration of the fit, options and parameter settings using the ROOT::Fit::ParameterSettings class ; CFitDataBase class for all the fit data types ; CFitResultClass containg the result of the fit and all the related information (fitted parameter values, error, covariance matrix and minimizer result information) Contains a pointer also to the fitted (model) function, modified with the fit parameter values ; CFitterFitter class, entry point for performing all type of fits ; CLogLikelihoodFCNLogLikelihoodFCN class for likelihood fits ; CParameterSettingsClass, describing value, limits and step size of the parameters Provides functionality also to set/retrieve values, step sizes, limits and fix the parameters ; CPoissonLikelihoodFCNClass evaluating the log likelihood for binned Poisson likelihood fits it is template to distinguish gradient and non-gradient case ; CSparseData; CUnBinDataClass describing the unbinned data sets (just x coordinates values) of any dimensions ; NInternal; CAxisConfigToTypeConverts a TAxisConfig of whatever kind to the corresponding TAxisBase-derived object ; CAxisConfigToType< TAxisConfig::kEquidistant >; CAxisConfigToType< TAxisConfig::kGrow >; CAxisConfigToType< TAxisConfig::kIrregular >; CAxisConfigToType< TAxisConfig::kLabels >; CFillBinCoord_tFill coord with low bin edge or center or high bin edge of all axes ; CFillBinCoord_t<-1, COORD, AXES >; CFillIterRange_tFill range with begin() and end() of all axes, including under/overflow as specified by over ; CFillIterRange_t<-1, AXES >; CHistImplGen_tGenerate THist::fImpl from THist constructor arguments ; CHistImplGen_t< DIMENSIONS, DIMENSIONS, PRECISION, STATISTICS, PROCESSEDAXISCONFIG.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html606/annotated.html:13008,log,log,13008,root/html606/annotated.html,https://root.cern,https://root.cern/root/html606/annotated.html,1,['log'],['log']
Testability,"ng the split level to 1 will create a branch for each data member in the Event object. First we execute Event and set the split level to 1 and start the browser to examine the split tree:; > Event 400 1 1 1; > root; root[] TFile f(""Event.root""); root[] TBrowser browser. 20.2.2 stress - Test and Benchmark; The executable stress is created by compiling stress.cxx. It completes sixteen tests covering the following capabilities of the ROOT framework. Functions, Random Numbers, Histogram Fits; Size & compression factor of a ROOT file; Purge, Reuse of gaps in TFile; 2D Histograms, Functions, 2D Fits; Graphics & PostScript; Subdirectories in a ROOT file; TNtuple, Selections, TCutG, TEventList; Split and Compression modes for Trees; Analyze Event.root file of stress 8; Create 10 files starting from Event.root; Test chains of Trees using the 10 files; Compare histograms of test 9 and 11; Merging files of a chain; Check correct rebuilt of Event.root in test 13; Divert Tree branches to separate files; Cling test (3 nested loops) with LHCb trigger. The program stress takes one argument, the number of events to process. The default is 1000 events. Be aware that executing stress with 1000 eventswill create several files consuming about 100 MB of disk space; running stress with 30 events will consume about 20 MB. The disk space is released once stress is done.; There are two ways to run stress:; From the system prompt or from the ROOT prompt using the interpreter.; > cd $ROOTSYS/test; > stress // default 1000 events; > stress 30 // test with 30 events; Start ROOT with the batch mode option (-b) to suppress the graphic output.; > root -b; root[] .L stress.cxx; root[] stress(1000)// test with 1000 events; root[] stress(30)// test with 30 events; The output of stress includes a pass/fail conclusion for each test, the total number of bytes read and written, and the elapsed real and CPU time. It also calculates a performance index for your machine relative to a reference machine a DELL ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1083138,test,test,1083138,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,['test'],['test']
Testability,"ng themselves, but not independent of; ; ) quantities . For each component ; make a mutlidimensional fit,; using ; as the variables, thus determing a set of; coefficents ; . To process data, using this parameterisation, do. Test wether the observation ; within the domain of; the parameterization, using the result from the Principal Component; Analysis. Determine ; as before. Detetmine ; as before. Use the result of the fit to determind ; . Transform back to ; from ; , using; the result from the Principal Component Analysis. Testing the parameterization. The class also provides functionality for testing the, over the; training sample, found parameterization; (TMultiDimFit::Fit). This is done by passing; the class a test sample of tuples of the form ; , where ; are the independent; variables, the known, dependent quantity, and is; the square error in ; (TMultiDimFit::AddTestRow). The parameterization is then evaluated at every ; in the; test sample, and. is evaluated. The relative error over the test sample. should not be to low or high compared to from the training; sample. Also, multiple correlation coefficient from both samples should; be fairly close, otherwise one of the samples is not representive of; the problem. A large difference in the reduced over the two; samples indicate an over fit, and the maximum number of terms in the; parameterisation should be reduced. It's possible to use Minuit; [4] to further improve the fit, using the test sample. Christian Holm; November 2000, NBI. Bibliography; 1. PhilipR. Bevington and D.Keith Robinson.; Data Reduction and Error Analysis for the Physical Sciences.; McGraw-Hill, 2 edition, 1992.; 2. Ren Brun etal.; Mudifi.; Long writeup DD/75-23, CERN, 1980.; 3. GeneH. Golub and CharlesF. van Loan.; Matrix Computations.; John Hopkins Univeristy Press, Baltimore, 3 edition, 1996.; 4. F.James.; Minuit.; Long writeup D506, CERN, 1998.; 5. H.Wind.; Function parameterization.; In Proceedings of the 1972 CERN Computing and Da",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMultiDimFit.html:12119,test,test,12119,root/html528/TMultiDimFit.html,https://root.cern,https://root.cern/root/html528/TMultiDimFit.html,3,['test'],['test']
Testability,"ng.; vector<TGLSceneInfo*>fVisScenesVisible scenes.; Float_tfWFLineWOptional override of scene wire-frame line-width. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGLViewerBase(); Constructor. ~TGLViewerBase(); Destructor. const char* LockIdStr() const; Name to print in locking output. FindScene(TGLSceneBase* scene); Find scene-info corresponding to scene. TGLSceneInfo* AddScene(TGLSceneBase* scene); Add new scene, appropriate scene-info is created. void RemoveScene(TGLSceneBase* scene); Remove scene from the viewer, its scene-info is deleted. void RemoveAllScenes(); Remove all scenes from the viewer, their scene-infos are deleted. void SceneDestructing(TGLSceneBase* scene); Remove scene, its scene-info is deleted.; Called from scene that is being destroyed while still holding; viewer references. TGLSceneInfo* GetSceneInfo(TGLSceneBase* scene); Find scene-info corresponding to scene. TGLLogicalShape* FindLogicalInScenes(TObject* id); Find logical-shape representing object id in the list of scenes.; Return 0 if not found. void AddOverlayElement(TGLOverlayElement* el); Add overlay element. void RemoveOverlayElement(TGLOverlayElement* el); Remove overlay element. void DeleteOverlayAnnotations(); Delete overlay elements that are annotations. void DeleteOverlayElements(TGLOverlayElement::ERole r); Delete overlay elements. void ResetSceneInfos(); Force rebuild of view-dependent scene-info structures. This should be called before calling render (draw/select) if; something that affects camera interest has been changed. void MergeSceneBBoxes(TGLBoundingBox& bbox); Merge bounding-boxes of all active registered scenes. void SetupClipObject(); Setup clip-object. Protected virtual method. void PreRender(); Initialize render-context, setup camera, GL, render-area.; Check and lock scenes, determine their visibility. void SubRenderScenes(TGLViewerBase::SubRender_foo render_foo); Call sub-rendering function render_foo on all currently vi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGLViewerBase.html:4757,log,logical-shape,4757,root/html528/TGLViewerBase.html,https://root.cern,https://root.cern/root/html528/TGLViewerBase.html,4,['log'],['logical-shape']
Testability,"ng::Format(""With %s %%s"",; 543 gSystem->GetBuildCompilerVersionStr()));; 544 lines.emplace_back(TString(""Try '.help'/'.?', '.demo', '.license', '.credits', '.quit'/'.q'%s""));; 545 ; 546 // Find the longest line and its length:; 547 auto itLongest = std::max_element(lines.begin(), lines.end(),; 548 [](const TString& left, const TString& right) {; 549 return left.Length() < right.Length(); });; 550 Ssiz_t lenLongest = itLongest->Length();; 551 ; 552 ; 553 Printf("" %s"", TString('-', lenLongest).Data());; 554 for (const auto& line: lines) {; 555 // Print the line, expanded with the necessary spaces at %s, and; 556 // surrounded by some ASCII art.; 557 Printf("" | %s |"",; 558 TString::Format(line.Data(),; 559 TString(' ', lenLongest - line.Length()).Data()).Data());; 560 }; 561 Printf("" %s\n"", TString('-', lenLongest).Data());; 562 }; 563 ; 564#ifdef R__UNIX; 565 // Popdown X logo, only if started with -splash option; 566 for (int i = 0; i < Argc(); i++); 567 if (!strcmp(Argv(i), ""-splash"")); 568 kill(getppid(), SIGUSR1);; 569#endif; 570}; 571 ; 572////////////////////////////////////////////////////////////////////////////////; 573/// Get prompt from interpreter. Either ""root [n]"" or ""end with '}'"".; 574 ; 575char *TRint::GetPrompt(); 576{; 577 char *s = gCling->GetPrompt();; 578 if (s[0]); 579 strlcpy(fPrompt, s, sizeof(fPrompt));; 580 else; 581 snprintf(fPrompt, sizeof(fPrompt), fDefaultPrompt.Data(), fNcmd);; 582 ; 583 return fPrompt;; 584}; 585 ; 586////////////////////////////////////////////////////////////////////////////////; 587/// Set a new default prompt. It returns the previous prompt.; 588/// The prompt may contain a %d which will be replaced by the commend; 589/// number. The default prompt is ""root [%d] "". The maximum length of; 590/// the prompt is 55 characters. To set the prompt in an interactive; 591/// session do:; 592/// root [0] ((TRint*)gROOT->GetApplication())->SetPrompt(""aap> ""); 593/// aap>; 594 ; 595const char *TRint::SetPrompt(const char *newP",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TRint_8cxx_source.html:19879,log,logo,19879,doc/master/TRint_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TRint_8cxx_source.html,1,['log'],['logo']
Testability,"ngBoxTGLLogicalShape::fBoundingBox! Shape's bounding box.; TGLPlotCoordinatesfCoord; UInt_tTGLLogicalShape::fDLBase! display-list id base; Bool_tTGLLogicalShape::fDLCache! use display list caching; Int_tTGLLogicalShape::fDLSize! display-list size for different LODs; UShort_tTGLLogicalShape::fDLValid! display-list validity bit-field; TObject*TGLLogicalShape::fExternalObj! Also plays the role of ID.; TGLPhysicalShape*TGLLogicalShape::fFirstPhysical! first replica; Bool_tTGLObject::fMultiColorAre multiple colors used for object rendering.; Bool_tTGLLogicalShape::fOwnExtObj! External object is a fake; TGLPlotPainter*fPlotPainter; UInt_tTGLLogicalShape::fRef! physical instance ref counting; Bool_tTGLLogicalShape::fRefStrong! Strong ref (delete on 0 ref); not in scene; TGLScene*TGLLogicalShape::fScene! scene where object is stored (can be zero!). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~TGLPlot3D(); Destructor. void SetPainter(TGLPlotPainter* p); Set painter object and destroy the old one. TGLPlot3D* InstantiatePlot(TObject* obj); Instantiate the correct plot-painter for given object.; Protected method. TGLPlot3D* CreatePlot(TObject* obj, Option_t* opt, TVirtualPad* pad); Create GL plot for specified object and options.; Which axes are logarithmic is determined from a pad. TGLPlot3D* CreatePlot(TObject* obj, Option_t* opt, Bool_t logx, Bool_t logy, Bool_t logz); Create GL plot for specified object and options.; Which axes are logarithmic is determined from explicit arguments. TGLPlot3D& operator=(const TGLPlot3D& ). Bool_t KeepDuringSmartRefresh() const; { return kFALSE; }.  Author: Matevz Tadel 2007  Copyright (C) 1995-2007, Rene Brun and Fons Rademakers. *;  Last changed: root/gl:$Id: TGLPlot3D.h 33579 2010-05-19 12:43:08Z rdm $  Last generated: 2010-09-23 20:06; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGLPlot3D.html:4663,log,logarithmic,4663,root/html528/TGLPlot3D.html,https://root.cern,https://root.cern/root/html528/TGLPlot3D.html,5,['log'],"['logarithmic', 'logx', 'logy', 'logz']"
Testability,"ngGetExpFormula(Option_t* option = """") const; virtual Color_tTAttFill::GetFillColor() const; virtual Style_tTAttFill::GetFillStyle() const; virtual TFormula*GetFormula(); virtual const TFormula*GetFormula() const; virtual TH1*GetHistogram() const; virtual const char*TObject::GetIconName() const; virtual const TObject*GetLinearPart(Int_t i) const; virtual Color_tTAttLine::GetLineColor() const; virtual Style_tTAttLine::GetLineStyle() const; virtual Width_tTAttLine::GetLineWidth() const; virtual Color_tTAttMarker::GetMarkerColor() const; virtual Size_tTAttMarker::GetMarkerSize() const; virtual Style_tTAttMarker::GetMarkerStyle() const; virtual Double_tGetMaximum(Double_t xmin = 0, Double_t xmax = 0, Double_t epsilon = 1.0E-10, Int_t maxiter = 100, Bool_t logx = false) const; virtual Double_tGetMaximumStored() const; virtual Double_tGetMaximumX(Double_t xmin = 0, Double_t xmax = 0, Double_t epsilon = 1.0E-10, Int_t maxiter = 100, Bool_t logx = false) const; TMethodCall*GetMethodCall() const; virtual Double_tGetMinimum(Double_t xmin = 0, Double_t xmax = 0, Double_t epsilon = 1.0E-10, Int_t maxiter = 100, Bool_t logx = false) const; virtual Double_tGetMinimumStored() const; virtual Double_tGetMinimumX(Double_t xmin = 0, Double_t xmax = 0, Double_t epsilon = 1.0E-10, Int_t maxiter = 100, Bool_t logx = false) const; virtual const char*TNamed::GetName() const; virtual Int_tGetNDF() const; virtual Int_tGetNdim() const; virtual Int_tGetNpar() const; virtual Int_tGetNpx() const; virtual Int_tGetNumber() const; virtual Int_tGetNumberFitPoints() const; virtual Int_tGetNumberFreeParameters() const; virtual char*GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual Double_tGetParameter(Int_t ipar) const; virtual Double_tGetParameter(const TString& name) const; virtual Double_t*GetParameters() const; virtual voidGetParameters(Double_t* params); TObject*GetParent() const; virtual Double_tGetParError(Int_t i",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TF1.html:9022,log,logx,9022,root/html604/TF1.html,https://root.cern,https://root.cern/root/html604/TF1.html,1,['log'],['logx']
Testability,"ngTNamed::fTitleobject title; RooRealProxyrlife; RooRealProxyrsf; RooRealProxysigma; RooRealProxyssf; RooRealProxyRooResolutionModel::xDependent/convolution variable. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooGExpModel(const char* name, const char* title, RooRealVar& x, RooAbsReal& sigma, RooAbsReal& rlife, Bool_t nlo = kFALSE, RooGExpModel::Type type = Normal). RooGExpModel(const char* name, const char* title, RooRealVar& x, RooAbsReal& sigma, RooAbsReal& rlife, RooAbsReal& srSF, Bool_t nlo = kFALSE, RooGExpModel::Type type = Normal). RooGExpModel(const char* name, const char* title, RooRealVar& x, RooAbsReal& sigma, RooAbsReal& rlife, RooAbsReal& sigmaSF, RooAbsReal& rlifeSF, Bool_t nlo = kFALSE, RooGExpModel::Type type = Normal). RooGExpModel(const RooGExpModel& other, const char* name = 0). ~RooGExpModel(); Destructor. Int_t basisCode(const char* name) const. Double_t evaluate() const. Double_t logErfC(Double_t x) const; Approximation of the log of the complex error function. RooComplex calcSinConv(Double_t sign, Double_t sig, Double_t tau, Double_t omega, Double_t rtau, Double_t fsign) const. Double_t calcSinConv(Double_t sign, Double_t sig, Double_t tau, Double_t rtau, Double_t fsign) const. Double_t calcDecayConv(Double_t sign, Double_t tau, Double_t sig, Double_t rtau, Double_t fsign) const; modified FMV,08/13/03. Int_t getAnalyticalIntegral(RooArgSet& allVars, RooArgSet& analVars, const char* rangeName = 0) const. Double_t analyticalIntegral(Int_t code, const char* rangeName = 0) const. RooComplex calcSinConvNorm(Double_t sign, Double_t tau, Double_t omega, Double_t sig, Double_t rtau, Double_t fsign, const char* rangeName) const; old code (asymptotic normalization only); RooComplex z(1/tau,sign*omega);; return z*2/(omega*omega+1/(tau*tau));. Double_t calcSinConvNorm(Double_t sign, Double_t tau, Double_t sig, Double_t rtau, Double_t fsign, const char* rangeName) const. RooComplex evalCerfInt(Double_t sign,",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooGExpModel.html:43501,log,logErfC,43501,root/html526/RooGExpModel.html,https://root.cern,https://root.cern/root/html526/RooGExpModel.html,8,['log'],"['log', 'logErfC']"
Testability,"ngTNamed::fTitleobject title; RooRealProxyrlife; RooRealProxyrsf; RooRealProxysigma; RooRealProxyssf; RooRealProxyRooResolutionModel::xDependent/convolution variable. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooGExpModel(const char* name, const char* title, RooRealVar& x, RooAbsReal& sigma, RooAbsReal& rlife, Bool_t nlo = kFALSE, RooGExpModel::Type type = Normal). RooGExpModel(const char* name, const char* title, RooRealVar& x, RooAbsReal& sigma, RooAbsReal& rlife, RooAbsReal& srSF, Bool_t nlo = kFALSE, RooGExpModel::Type type = Normal). RooGExpModel(const char* name, const char* title, RooRealVar& x, RooAbsReal& sigma, RooAbsReal& rlife, RooAbsReal& sigmaSF, RooAbsReal& rlifeSF, Bool_t nlo = kFALSE, RooGExpModel::Type type = Normal). RooGExpModel(const RooGExpModel& other, const char* name = 0). ~RooGExpModel(); Destructor. Int_t basisCode(const char* name) const. Double_t evaluate() const. Double_t logErfC(Double_t x) const; Approximation of the log of the complex error function. std::complex<Double_t> calcSinConv(Double_t sign, Double_t sig, Double_t tau, Double_t omega, Double_t rtau, Double_t fsign) const. Double_t calcSinConv(Double_t sign, Double_t sig, Double_t tau, Double_t rtau, Double_t fsign) const. Double_t calcDecayConv(Double_t sign, Double_t tau, Double_t sig, Double_t rtau, Double_t fsign) const; modified FMV,08/13/03. Int_t getAnalyticalIntegral(RooArgSet& allVars, RooArgSet& analVars, const char* rangeName = 0) const. Double_t analyticalIntegral(Int_t code, const char* rangeName = 0) const. std::complex<Double_t> calcSinConvNorm(Double_t sign, Double_t tau, Double_t omega, Double_t sig, Double_t rtau, Double_t fsign, const char* rangeName) const; old code (asymptotic normalization only); std::complex<Double_t> z(1/tau,sign*omega);; return z*2/(omega*omega+1/(tau*tau));. Double_t calcSinConvNorm(Double_t sign, Double_t tau, Double_t sig, Double_t rtau, Double_t fsign, const char* rangeName) const. s",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooGExpModel.html:47360,log,logErfC,47360,root/html534/RooGExpModel.html,https://root.cern,https://root.cern/root/html534/RooGExpModel.html,6,['log'],"['log', 'logErfC']"
Testability,"ng_t timeout = -1, Int_t endtype = -1, Bool_t deactonfail = kFALSE); static Bool_tTQObject::ConnectToClass(TQObject* sender, const char* signal, TClass* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::ConnectToClass(const char* sender_class, const char* signal, TClass* receiver_class, void* receiver, const char* slot); TSlave*TProof::CreateSlave(const char* url, const char* ord, Int_t perf, const char* image, const char* workdir); TSlave*TProof::CreateSubmaster(const char* url, const char* ord, const char* image, const char* msd); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; static Bool_tTProof::GetFileInCmd(const char* cmd, TString& fn); static Int_tTProof::GetInputData(TList* input, const char* cachedir, TString& emsg); TList*TProof::GetListOfActiveSlaves() const; TVirtualProofPlayer*TProof::GetPlayer() const; TPluginHandler*TProof::GetProgressDialog() const; Int_tTProof::GetSandbox(TString& sb, Bool_t assert = kFALSE, const char* rc = 0); virtual void*TQObject::GetSender(); virtual const char*TQObject::GetSenderClassName() const; voidTProof::HandleLibIncPath(const char* what, Bool_t add, const char* dirs); Int_tTProof::Init(const char* masterurl, const char* conffile, const char* confdir, Int_t loglevel, const char* alias = 0); voidTProof::InitMembers(); virtual TVirtualProofPlayer*MakePlayer(const char* player = 0, TSocket* s = 0); voidTObject::MakeZombie(); voidTProof::PrepareInputDataFile(TString& dataFile); Int_tTProof::RemoveWorkers(TList* wrks); static Int_tTProof::SaveInputData(TQueryResult* qr, const char* cachedir, TString& emsg); virtual voidTProof::SaveWorkerInfo(); Int_tTProof::SendFile(const char* file, Int_t opt = (kBinary|kForward|kCp|kCpBin), const char* rfile = 0, TSlave* sl = 0); static Int_tTProof::SendInputData(TQueryResult* qr, TProof* p, TString& emsg); virtual voidTProof::SendInputDataFile(); voidTProof::SetDSet(TDSet* dset); voidTProof::SetPlayer(TVirtualProofPla",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TProofSuperMaster.html:20115,assert,assert,20115,root/html530/TProofSuperMaster.html,https://root.cern,https://root.cern/root/html530/TProofSuperMaster.html,2,['assert'],['assert']
Testability,"nge of an histogram An histogram is created and filled with the bin contents and errors defined in the table below ; na49geomfile.pyBefore executing this macro, the file makegeometry.C must have been executed ; na49view.pyThis macro generates two views of the NA49 detector ; na49visible.pySet visibility attributes for the NA49 geometry Set Shape attributes ; ntuple1.py Ntuple drawing example ; numberEntry.py; parse_CSV_file_with_TTree_ReadStream.pyThis function provides an example of how one might massage a csv data file to read into a ROOT TTree via TTree::ReadStream ; pyroot001_arrayInterface.py This tutorial illustrates the conversion of STL vectors and TVec to numpy arrays without copying the data ; pyroot002_TTreeAsMatrix.py This tutorial shows how a TTree can be quickly converted to a numpy array or a pandas.DataFrame ; qtexample.pyQt example ; ratioplot.py Display two histograms and their ratio ; rootmarks.pyPrints a summary of all ROOT benchmarks (must be run before) The ROOTMARK number printed is by reference to a Pentium IV 2.4 Ghz (with 512 MBytes memory and 120 GBytes IDE disk) taken by definition as 600 ROOTMARKS in batch mode in executing python benchmarks.py ; shapes.py Draw the geometry using the x3d viewver ; staff.py example of macro to read data from an ascii file and create a root file with a Tree ; surfaces.py Surfaces example ; test.py ; tornado.pyTornado example ; tree.py This macro displays the Tree data structures ; zdemo.py This macro is an example of graphs in log scales with annotations ; pythia; pythia8.CPythia8 basic example ; pythiaExample.CUsing Pythia6 with ROOT ; quadp; portfolio.C This macro shows in detail the use of the quadratic programming package quadp ; Quad.cxx; Quad.h; r; DataFrame.C ; example.C Simple example on how to use ROOT-R interface ; Function.C ; Functor.C Example to create class Functor ; GlobalMinimization.C Example based in http://cran.r-project.org/web/packages/DEoptim/DEopti",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v614/files.html:143972,benchmark,benchmarks,143972,doc/v614/files.html,https://root.cern,https://root.cern/doc/v614/files.html,1,['benchmark'],['benchmarks']
Testability,"nge, bool isWeighted = false) :; 163 FitData( range, maxpoints, dataX, dataY, dataZ ),; 164 fWeighted( isWeighted ); 165 {; 166 }; 167 ; 168 /**; 169 constructor for multi-dim external data and a range (data are copied inside according to the range); 170 Uses as argument an iterator of a list (or vector) containing the const double * of the data; 171 An example could be the std::vector<const double *>::begin; 172 */; 173 template<class Iterator>; 174 UnBinData( unsigned int maxpoints, unsigned int dim, Iterator dataItr, const DataRange & range, bool isWeighted = false ) :; 175 FitData( range, maxpoints, dim, dataItr ),; 176 fWeighted( isWeighted ); 177 {; 178 }; 179 ; 180 /// copy constructor; 181 UnBinData(const UnBinData &);; 182 /// assignment operator; 183 UnBinData & operator= (const UnBinData &);; 184 ; 185public:; 186 /**; 187 destructor, delete pointer to internal data or external data wrapper; 188 */; 189 ~UnBinData() override {; 190 }; 191 ; 192 /**; 193 add one dim coordinate data (unweighted); 194 */; 195 void Add(double x); 196 {; 197 assert( !fWeighted );; 198 ; 199 FitData::Add( x );; 200 }; 201 ; 202 ; 203 /**; 204 add 2-dim coordinate data; 205 can also be used to add 1-dim data with a weight; 206 */; 207 void Add(double x, double y); 208 {; 209 assert( fDim == 2 );; 210 double dataTmp[] = { x, y };; 211 ; 212 FitData::Add( dataTmp );; 213 }; 214 ; 215 /**; 216 add 3-dim coordinate data; 217 can also be used to add 2-dim data with a weight; 218 */; 219 void Add(double x, double y, double z); 220 {; 221 assert( fDim == 3 );; 222 double dataTmp[] = { x, y, z };; 223 ; 224 FitData::Add( dataTmp );; 225 }; 226 ; 227 /**; 228 add multi-dim coordinate data; 229 */; 230 void Add( const double* x ); 231 {; 232 FitData::Add( x );; 233 }; 234 ; 235 /**; 236 add multi-dim coordinate data + weight; 237 */; 238 void Add(const double *x, double w); 239 {; 240 assert( fWeighted );; 241 ; 242 std::vector<double> tmpVec(fDim);; 243 std::copy( x, x + fDim - 1, tmpVec.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/UnBinData_8h_source.html:6716,assert,assert,6716,doc/master/UnBinData_8h_source.html,https://root.cern,https://root.cern/doc/master/UnBinData_8h_source.html,4,['assert'],['assert']
Testability,"ngful names for sampling dist. Double_t EvaluateTestStatistic(RooAbsData& data, RooArgSet& allParameters); Main interface to evaluate the test statistic on a dataset. const RooAbsArg* GetTestStatistic() const; Get the TestStatistic. Double_t ConfidenceLevel() const; Get the Confidence level for the test. {return 1.-fSize;}. void Initialize(RooAbsArg& , RooArgSet& , RooArgSet& ); Common Initialization. void SetNEventsPerToy(const Int_t nevents). void SetExtended(const Bool_t isExtended). void SetData(RooAbsData& data); Set the DataSet, add to the the workspace if not already there. void SetPdf(RooAbsPdf& pdf); Set the Pdf, add to the the workspace if not already there. void SetData(const char* name); specify the name of the dataset in the workspace to be used. {fDataName = name;}. void SetPdf(const char* name); specify the name of the PDF in the workspace to be used. {fPdfName = name;}. void SetNuisanceParameters(RooArgSet& set); specify the nuisance parameters (eg. the rest of the parameters). {fNuisParams = &set;}. void SetObservables(RooArgSet& set); specify the observables in the dataset (needed to evaluate the test statistic). {fObservables = &set;}. void SetTestSize(Double_t size); set the size of the test (rate of Type I error) ( Eg. 0.05 for a 95% Confidence Interval). {fSize = size;}. void SetConfidenceLevel(Double_t cl); set the confidence level for the interval (eg. 0.95 for a 95% Confidence Interval). {fSize = 1.-cl;}. void SetTestStatistic(RooAbsArg& ) const; Set the TestStatistic (want the argument to be a function of the data & parameter points. {}.  Author: Kyle Cranmer, Lorenzo Moneta, Gregory Schott, Wouter Verkerke  Copyright (C) 1995-2008, Rene Brun and Fons Rademakers. *;  Last changed: root/roostats:$Id: ToyMCSampler.h 31276 2009-11-18 15:06:42Z moneta $  Last generated: 2009-12-07 13:49; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooStats__ToyMCSampler.html:5547,test,test,5547,root/html526/RooStats__ToyMCSampler.html,https://root.cern,https://root.cern/root/html526/RooStats__ToyMCSampler.html,2,['test'],['test']
Testability,"ngs.; 61 long long GetNumWarnings() const { return fNumWarnings; }; 62 ; 63 /// Returns the current number of errors.; 64 long long GetNumErrors() const { return fNumErrors; }; 65 ; 66 /// Returns the current number of fatal errors.; 67 long long GetNumFatalErrors() const { return fNumFatalErrors; }; 68 ; 69 /// Increase warning or error count.; 70 void Increment(ELogLevel severity); 71 {; 72 switch (severity) {; 73 case ELogLevel::kFatal: ++fNumFatalErrors; break;; 74 case ELogLevel::kError: ++fNumErrors; break;; 75 case ELogLevel::kWarning: ++fNumWarnings; break;; 76 default:;; 77 }; 78 }; 79};; 80 ; 81/**; 82 Abstract RLogHandler base class. ROOT logs everything from info to error; 83 to entities of this class.; 84 */; 85class RLogHandler {; 86public:; 87 virtual ~RLogHandler();; 88 /// Emit a log entry.; 89 /// \param entry - the RLogEntry to be emitted.; 90 /// \returns false if further emission of this Log should be suppressed.; 91 ///; 92 /// \note This function is called concurrently; log emission must be locked; 93 /// if needed. (The default log handler using ROOT's DefaultErrorHandler is locked.); 94 virtual bool Emit(const RLogEntry &entry) = 0;; 95};; 96 ; 97/**; 98 A log configuration for a channel, e.g. ""RHist"".; 99 Each ROOT module has its own log, with potentially distinct verbosity.; 100 */; 101class RLogChannel : public RLogDiagCount {; 102 /// Name as shown in diagnostics; 103 std::string fName;; 104 ; 105 /// Verbosity of this channel. By default, use the global verbosity.; 106 ELogLevel fVerbosity = ELogLevel::kUnset;; 107 ; 108public:; 109 /// Construct an anonymous channel.; 110 RLogChannel() = default;; 111 ; 112 /// Construct an anonymous channel with a default verbosity.; 113 explicit RLogChannel(ELogLevel verbosity) : fVerbosity(verbosity) {}; 114 ; 115 /// Construct a log channel given its name, which is part of the diagnostics.; 116 RLogChannel(const std::string &name) : fName(name) {}; 117 ; 118 ELogLevel SetVerbosity(ELogLevel verbosit",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RLogger_8hxx_source.html:3113,log,log,3113,doc/master/RLogger_8hxx_source.html,https://root.cern,https://root.cern/doc/master/RLogger_8hxx_source.html,1,['log'],['log']
Testability,"ngth () const; ; Bool_tIsAutomatic () const; ; voidSetAutomatic (); ; voidSetPruneStrength (Double_t alpha); . Protected Attributes; Double_tB; ; Double_tfPruneStrength; ! regularization parameter in pruning ; ; Double_tS; . #include <TMVA/IPruneTool.h>. Inheritance diagram for TMVA::IPruneTool:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Member Typedef Documentation. EventSample. typedef std::vector<const Event*> TMVA::IPruneTool::EventSample. Definition at line 74 of file IPruneTool.h. Constructor & Destructor Documentation. IPruneTool(). TMVA::IPruneTool::IPruneTool ; (; ). inline . Definition at line 107 of file IPruneTool.h. ~IPruneTool(). TMVA::IPruneTool::~IPruneTool ; (; ). virtual . Definition at line 58 of file ExpectedErrorPruneTool.cxx. Member Function Documentation. CalculatePruningInfo(). virtual PruningInfo * TMVA::IPruneTool::CalculatePruningInfo ; (; DecisionTree *; dt, . const EventSample *; testEvents = nullptr, . Bool_t; isAutomatic = kFALSE. ). pure virtual . Implemented in TMVA::CostComplexityPruneTool, and TMVA::ExpectedErrorPruneTool. GetPruneStrength(). Double_t TMVA::IPruneTool::GetPruneStrength ; (; ); const. inline . Definition at line 90 of file IPruneTool.h. IsAutomatic(). Bool_t TMVA::IPruneTool::IsAutomatic ; (; ); const. inline . Definition at line 95 of file IPruneTool.h. SetAutomatic(). void TMVA::IPruneTool::SetAutomatic ; (; ). inline . Definition at line 94 of file IPruneTool.h. SetPruneStrength(). void TMVA::IPruneTool::SetPruneStrength ; (; Double_t; alpha). inline . Definition at line 88 of file IPruneTool.h. Member Data Documentation. B. Double_t TMVA::IPruneTool::B. protected . Definition at line 104 of file IPruneTool.h. fPruneStrength. Double_t TMVA::IPruneTool::fPruneStrength. protected . ! regularization parameter in pruning ; Definition at line 101 of file IPruneTool.h. S. Double_t TMVA::IPruneTool::S. protected . Definition a",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1IPruneTool.html:2411,test,testEvents,2411,doc/master/classTMVA_1_1IPruneTool.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1IPruneTool.html,1,['test'],['testEvents']
Testability,"nherited from RooPrintable; static Int_t_nameLength; . #include <RooSpline.h>. Inheritance diagram for RooSpline:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. RooSpline() [1/4]. RooSpline::RooSpline ; (; ). default . RooSpline() [2/4]. RooSpline::RooSpline ; (; const char *; name, . const char *; title, . RooAbsReal &; x, . std::span< const double >; x0, . std::span< const double >; y0, . int; order = 3, . bool; logx = false, . bool; logy = false. ). Constructor for creating a spline from raw data. ; Parameters. [in]nameThe name of the spline. ; [in]titleThe title of the spline. ; [in]xThe independent variable. ; [in]x0The array of x values for the spline points. ; [in]y0The array of y values for the spline points. ; [in]orderThe order of the spline (3 or 5). ; [in]logxIf true, the x values are logarithmically scaled before spline creation. ; [in]logyIf true, the y values are logarithmically scaled before spline creation. . Definition at line 74 of file RooSpline.cxx. RooSpline() [3/4]. RooSpline::RooSpline ; (; const char *; name, . const char *; title, . RooAbsReal &; x, . const TGraph &; gr, . int; order = 3, . bool; logy = false, . bool; logx = false. ). Constructor for creating a spline from a TGraph. ; Parameters. [in]nameThe name of the spline. ; [in]titleThe title of the spline. ; [in]xThe independent variable. ; [in]grThe input TGraph containing the data points. ; [in]orderThe order of the spline (3 or 5). ; [in]logxIf true, the x values are logarithmically scaled before spline creation. ; [in]logyIf true, the y values are logarithmically scaled before spline creation. . Definition at line 58 of file RooSpline.cxx. RooSpline() [4/4]. RooSpline::RooSpline ; (; const RooSpline &; other, . const char *; name = nullptr. ). Copy constructor. ; Parameters. [in]otherThe RooSpline object to copy from. ; [in]nameThe name of the new RooSpline objec",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooSpline.html:62318,log,logyIf,62318,doc/master/classRooSpline.html,https://root.cern,https://root.cern/doc/master/classRooSpline.html,2,['log'],"['logarithmically', 'logyIf']"
Testability,"nhibitDirty; ; static bool_verboseDirty; cache of the list of proxies. Avoids type casting. ; ; Static Protected Attributes inherited from RooPrintable; static Int_t_nameLength; . Private Member Functions; RooChi2Var (const char *name, const char *title, RooAbsReal &func, RooDataHist &data, const RooArgSet &projDeps, FuncMode funcMode, RooAbsTestStatistic::Configuration const &cfg, RooDataHist::ErrorType etype); . Additional Inherited Members; Static Public Member Functions inherited from RooAbsReal; static TClass *Class (); ; static const char *Class_Name (); ; static constexpr Version_tClass_Version (); ; static voidclearEvalErrorLog (); Clear the stack of evaluation error messages. ; ; static const char *DeclFileName (); ; static RooNumIntConfig *defaultIntegratorConfig (); Returns the default numeric integration configuration for all RooAbsReals. ; ; static std::map< constRooAbsArg *, std::pair< std::string, std::list< RooAbsReal::EvalError > > >::iteratorevalErrorIter (); ; static ErrorLoggingModeevalErrorLoggingMode (); Return current evaluation error logging mode. ; ; static boolhideOffset (); ; static voidlogEvalError (const RooAbsReal *originator, const char *origName, const char *message, const char *serverValueString=nullptr); Interface to insert remote error logging messages received by RooRealMPFE into current error logging stream. ; ; static Int_tnumEvalErrorItems (); ; static Int_tnumEvalErrors (); Return the number of logged evaluation errors since the last clearing. ; ; static voidprintEvalErrors (std::ostream &os=std::cout, Int_t maxPerNode=10000000); Print all outstanding logged evaluation error on the given ostream. ; ; static voidsetEvalErrorLoggingMode (ErrorLoggingMode m); Set evaluation error logging mode. ; ; static voidsetHideOffset (bool flag); ; Static Public Member Functions inherited from RooAbsArg; static voidsetDirtyInhibit (bool flag); Control global dirty inhibit mode. ; ; static vo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooChi2Var.html:66586,log,logging,66586,doc/master/classRooChi2Var.html,https://root.cern,https://root.cern/doc/master/classRooChi2Var.html,1,['log'],['logging']
Testability,"nimizer status.; This snapshot contains the values of all constant parameters,; the value of all floating parameters at RooMinimizer construction and; after the last MINUIT operation, the MINUIT status, variance quality,; EDM setting, number of calls with evaluation problems, the minimized; function value and the full correlation matrix. RooPlot* contour(RooRealVar& var1, RooRealVar& var2, Double_t n1 = 1, Double_t n2 = 2, Double_t n3 = 0, Double_t n4 = 0, Double_t n5 = 0, Double_t n6 = 0); Create and draw a TH2 with the error contours in parameters var1 and v2 at up to 6 'sigma' settings; where 'sigma' is calculated as n*n*errorLevel. void profileStart(); Start profiling timer. void profileStop(); Stop profiling timer and report results of last session. void applyCovarianceMatrix(TMatrixDSym& V); Apply results of given external covariance matrix. i.e. propagate its errors; to all RRV parameter representations and give this matrix instead of the; HESSE matrix at the next save() call. RooFitResult* lastMinuitFit(const RooArgList& varList = RooArgList()); Import the results of the last fit performed, interpreting; the fit parameters as the given varList of parameters. RooMinimizer(RooAbsReal& function). void setEvalErrorWall(Bool_t flag); { _fcn->SetEvalErrorWall(flag); }. void setPrintEvalErrors(Int_t numEvalErrors); { _fcn->SetPrintEvalErrors(numEvalErrors); }. void setVerbose(Bool_t flag = kTRUE); { _verbose = flag ; _fcn->SetVerbose(flag); }. void setProfile(Bool_t flag = kTRUE); { _profile = flag ; }. Bool_t setLogFile(const char* logf = 0); { return _fcn->SetLogFile(logf); }. Int_t getNPar() const; { return _fcn->NDim() ; }. ofstream* logfile() const; { return _fcn->GetLogFile(); }. Double_t& maxFCN(); { return _fcn->GetMaxFCN() ; }.  Last changed: Thu Sep 23 20:00:09 2010  Last generated: 2010-09-23 20:00; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooMinimizer.html:12649,log,logf,12649,root/html528/RooMinimizer.html,https://root.cern,https://root.cern/root/html528/RooMinimizer.html,3,['log'],"['logf', 'logfile']"
Testability,"nimizer>; 1640// void Net::preTrain (std::vector<double>& weights,; 1641// std::vector<Pattern>& trainPattern,; 1642// const std::vector<Pattern>& testPattern,; 1643// Minimizer& minimizer, Settings& settings); 1644// {; 1645// auto itWeightGeneral = std::begin (weights);; 1646// std::vector<Pattern> prePatternTrain (trainPattern.size ());; 1647// std::vector<Pattern> prePatternTest (testPattern.size ());; 1648 ; 1649// size_t _inputSize = inputSize ();; 1650 ; 1651// // transform pattern using the created preNet; 1652// auto initializePrePattern = [&](const std::vector<Pattern>& pttrnInput, std::vector<Pattern>& pttrnOutput); 1653// {; 1654// pttrnOutput.clear ();; 1655// std::transform (std::begin (pttrnInput), std::end (pttrnInput),; 1656// std::back_inserter (pttrnOutput),; 1657// [](const Pattern& p); 1658// {; 1659// Pattern pat (p.input (), p.input (), p.weight ());; 1660// return pat;; 1661// });; 1662// };; 1663 ; 1664// initializePrePattern (trainPattern, prePatternTrain);; 1665// initializePrePattern (testPattern, prePatternTest);; 1666 ; 1667// std::vector<double> originalDropFractions = settings.dropFractions ();; 1668 ; 1669// for (auto& _layer : layers ()); 1670// {; 1671// // compute number of weights (as a function of the number of incoming nodes); 1672// // fetch number of nodes; 1673// size_t numNodes = _layer.numNodes ();; 1674// size_t _numWeights = _layer.numWeights (_inputSize);; 1675 ; 1676// // ------------------; 1677// DNN::Net preNet;; 1678// if (!originalDropFractions.empty ()); 1679// {; 1680// originalDropFractions.erase (originalDropFractions.begin ());; 1681// settings.setDropOut (originalDropFractions.begin (), originalDropFractions.end (), settings.dropRepetitions ());; 1682// }; 1683// std::vector<double> preWeights;; 1684 ; 1685// // define the preNet (pretraining-net) for this layer; 1686// // outputSize == inputSize, because this is an autoencoder;; 1687// preNet.setInputSize (_inputSize);; 1688// preNet.addLayer (DNN::Layer (n",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/NeuralNet_8icc_source.html:55290,test,testPattern,55290,doc/master/NeuralNet_8icc_source.html,https://root.cern,https://root.cern/doc/master/NeuralNet_8icc_source.html,1,['test'],['testPattern']
Testability,"ning parameter uncertainties in weighted unbinned maximum likelihood fits. Performing a weighted unbinned maximum likelihood fits can be useful to account for acceptance effects and to statistically subtract background events using the sPlot formalism. It is however well known that the inverse Hessian matrix does not yield parameter uncertainties with correct coverage in the presence of event weights. Three approaches to the determination of parameter uncertainties are compared in this example:. Using the inverse weighted Hessian matrix [SumW2Error(false)]; Using the expression [SumW2Error(true)] ; \[; V_{ij} = H_{ik}^{-1} C_{kl} H_{lj}^{-1}; \]. where H is the weighted Hessian matrix and C is the Hessian matrix with squared weights; The asymptotically correct approach (for details please see https://arxiv.org/abs/1911.01303) [Asymptotic(true)] ; \[; V_{ij} = H_{ik}^{-1} D_{kl} H_{lj}^{-1}; \]. where H is the weighted Hessian matrix and D is given by ; \[; D_{kl} = \sum_{e=1}^{N} w_e^2 \frac{\partial \log(P)}{\partial \lambda_k}\frac{\partial \log(P)}{\partial; \lambda_l}; \]. with the event weight \(w_e\). The example performs the fit of a second order polynomial in the angle cos(theta) [-1,1] to a weighted data set. The polynomial is given by ; \[; P = \frac{ 1 + c_0 \cdot \cos(\theta) + c_1 \cdot \cos(\theta) \cdot \cos(\theta) }{\mathrm{Norm}}; \]. The two coefficients \( c_0 \) and \( c_1 \) and their uncertainties are to be determined in the fit.; The per-event weight is used to correct for an acceptance effect, two different acceptance models can be studied:; acceptancemodel==1: eff = \( 0.3 + 0.7 \cdot \cos(\theta) \cdot \cos(\theta) \); acceptancemodel==2: eff = \( 1.0 - 0.7 \cdot \cos(\theta) \cdot \cos(\theta) \) The data is generated to be flat before the acceptance effect. The performance of the different approaches to determine parameter uncertainties is compared using the pull distributions from a large number of pseudoexperiments. The pull is defined",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf611__weightedfits_8C.html:1496,log,log,1496,doc/master/rf611__weightedfits_8C.html,https://root.cern,https://root.cern/doc/master/rf611__weightedfits_8C.html,2,['log'],['log']
Testability,"ningHistory_PyKeras_'accuracy', Entries= 0, Total sum= 13.4202; TH1.Print Name = TrainingHistory_PyKeras_'loss', Entries= 0, Total sum= 11.959; TH1.Print Name = TrainingHistory_PyKeras_'val_accuracy', Entries= 0, Total sum= 13.2436; TH1.Print Name = TrainingHistory_PyKeras_'val_loss', Entries= 0, Total sum= 12.1109; Factory : === Destroy and recreate all methods via weight files for testing ===; : ; : Reading weight file: [0;36mdataset/weights/TMVA_Higgs_Classification_Likelihood.weights.xml[0m; : Reading weight file: [0;36mdataset/weights/TMVA_Higgs_Classification_Fisher.weights.xml[0m; : Reading weight file: [0;36mdataset/weights/TMVA_Higgs_Classification_BDT.weights.xml[0m; : Reading weight file: [0;36mdataset/weights/TMVA_Higgs_Classification_DNN_CPU.weights.xml[0m; : Reading weight file: [0;36mdataset/weights/TMVA_Higgs_Classification_PyKeras.weights.xml[0m; Factory : [1mTest all methods[0m; Factory : Test method: Likelihood for Classification performance; : ; Likelihood : [dataset] : Evaluation of Likelihood on testing sample (6000 events); : Elapsed time for evaluation of 6000 events: 0.012 sec ; Factory : Test method: Fisher for Classification performance; : ; Fisher : [dataset] : Evaluation of Fisher on testing sample (6000 events); : Elapsed time for evaluation of 6000 events: 0.00146 sec ; : Dataset[dataset] : Evaluation of Fisher on testing sample; Factory : Test method: BDT for Classification performance; : ; BDT : [dataset] : Evaluation of BDT on testing sample (6000 events); : Elapsed time for evaluation of 6000 events: 0.0456 sec ; Factory : Test method: DNN_CPU for Classification performance; : ; : Evaluate deep neural network on CPU using batches with size = 1000; : ; TFHandler_DNN_CPU : Variable Mean RMS [ Min Max ]; : -----------------------------------------------------------; : m_jj: 0.017919 1.0069 [ -3.3498 3.4247 ]; : m_jjj: 0.020352 1.0044 [ -3.2831 3.3699 ]; : m_lv: 0.016356 0.99266 [ -3.2339 3.3958 ]; : m_jlv: -0.018431 0.9824",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVA__Higgs__Classification_8C.html:49804,test,testing,49804,doc/master/TMVA__Higgs__Classification_8C.html,https://root.cern,https://root.cern/doc/master/TMVA__Higgs__Classification_8C.html,1,['test'],['testing']
Testability,"nitialization of module base class. ; Reimplemented in RooChi2MCSModule, RooDLLSignificanceMCSModule, RooRandomizeParamMCSModule, and RooStats::UpperLimitMCSModule.; Definition at line 40 of file RooAbsMCStudyModule.h. initializeRun(). virtual bool RooAbsMCStudyModule::initializeRun ; (; Int_t; ). inlinevirtual . Method called at the beginning of each RooMCStudy run. ; Reimplemented in RooChi2MCSModule, RooDLLSignificanceMCSModule, RooRandomizeParamMCSModule, and RooStats::UpperLimitMCSModule.; Definition at line 45 of file RooAbsMCStudyModule.h. IsA(). TClass * RooAbsMCStudyModule::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TObject.; Reimplemented in RooChi2MCSModule, RooDLLSignificanceMCSModule, RooRandomizeParamMCSModule, and RooStats::UpperLimitMCSModule.; Definition at line 184 of file RooAbsMCStudyModule.h. nllVar(). RooRealVar * RooAbsMCStudyModule::nllVar ; (; ). inlineprotected . Return pointer to RooRealVar holding minimized -log(L) value. ; Definition at line 144 of file RooAbsMCStudyModule.h. numExpGen(). double RooAbsMCStudyModule::numExpGen ; (; ). inlineprotected . Return expected number of events from generator model. ; Definition at line 166 of file RooAbsMCStudyModule.h. processAfterFit(). virtual bool RooAbsMCStudyModule::processAfterFit ; (; Int_t; ). inlinevirtual . Method called after fit has been performed. ; Reimplemented in RooChi2MCSModule, and RooDLLSignificanceMCSModule.; Definition at line 69 of file RooAbsMCStudyModule.h. processBeforeGen(). virtual bool RooAbsMCStudyModule::processBeforeGen ; (; Int_t; ). inlinevirtual . Method called after resetting of generator parameters to initial values and before call to generator context Any modifications to generator parameters will affect next generation operation (only) ; Reimplemented in RooRandomizeParamMCSModule.; Definition at line 57 of file RooAbsMCStudyModule.h. processBetweenGenAndFit(). virtual bool RooAbsM",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsMCStudyModule.html:20181,log,log,20181,doc/master/classRooAbsMCStudyModule.html,https://root.cern,https://root.cern/doc/master/classRooAbsMCStudyModule.html,1,['log'],['log']
Testability,"nition RSha256.hxx:101; TAttAxis::SetLabelSizevirtual void SetLabelSize(Float_t size=0.04)Set size of axis labels.Definition TAttAxis.cxx:203; TAttAxis::SetTickLengthvirtual void SetTickLength(Float_t length=0.03)Set tick mark length.Definition TAttAxis.cxx:284; TAttFill::SetFillColorvirtual void SetFillColor(Color_t fcolor)Set the fill area color.Definition TAttFill.h:37; TAttFill::SetFillStylevirtual void SetFillStyle(Style_t fstyle)Set the fill area style.Definition TAttFill.h:39; TAttLine::SetLineWidthvirtual void SetLineWidth(Width_t lwidth)Set the line width.Definition TAttLine.h:43; TAttLine::SetLineColorvirtual void SetLineColor(Color_t lcolor)Set the line color.Definition TAttLine.h:40; TAttText::SetTextColorvirtual void SetTextColor(Color_t tcolor=1)Set the text color.Definition TAttText.h:44; TAttText::SetTextSizevirtual void SetTextSize(Float_t tsize=1)Set the text size.Definition TAttText.h:47; TAxis::SetMoreLogLabelsvoid SetMoreLogLabels(Bool_t more=kTRUE)Set the kMoreLogLabels bit flag When this option is selected more labels are drawn when in log scale ...Definition TAxis.h:223; TCanvasThe Canvas class.Definition TCanvas.h:23; TGraphA TGraph is an object made of two arrays X and Y with npoints each.Definition TGraph.h:41; TGraph::SetPointvirtual void SetPoint(Int_t i, Double_t x, Double_t y)Set x and y values for point number i.Definition TGraph.cxx:2342; TGraph::SetNamevoid SetName(const char *name="""") overrideSet graph name.Definition TGraph.cxx:2381; TGraph::Drawvoid Draw(Option_t *chopt="""") overrideDraw this graph with its current attributes.Definition TGraph.cxx:831; TGraph::SetTitlevoid SetTitle(const char *title="""") overrideChange (i.e.Definition TGraph.cxx:2397; TH1F1-D histogram with a float per channel (see TH1 documentation)Definition TH1.h:622; TH1TH1 is the base class of all histogram classes in ROOT.Definition TH1.h:59; TH1::SetDirectoryvirtual void SetDirectory(TDirectory *dir)By default, when a histogram is created, it is added to the ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/exclusiongraph2_8C.html:5586,log,log,5586,doc/master/exclusiongraph2_8C.html,https://root.cern,https://root.cern/doc/master/exclusiongraph2_8C.html,1,['log'],['log']
Testability,"nition RooAbsReal.h:276. VisualizeError(const RooFitResult& fitres, const RooArgSet& param, double Z=1, bool linearMethod=true) Visualize the uncertainty on the subset of parameters 'param', as given in fitres, at 'Z' sigma . Reimplemented from RooAbsPdf.; Definition at line 133 of file RooAbsPdf.cxx. plotOn() [5/5]. RooPlot * RooSimultaneous::plotOn ; (; RooPlot *; frame, . RooLinkedList &; cmdList. ); const. overridevirtual . Back-end for plotOn() implementation on RooSimultaneous which needs special handling because a RooSimultaneous PDF cannot project out its index category via integration. ; plotOn() will abort if this is requested without providing a projection dataset. ; Reimplemented from RooAbsPdf.; Definition at line 597 of file RooSimultaneous.cxx. selectNormalization(). void RooSimultaneous::selectNormalization ; (; const RooArgSet *; normSet = nullptr, . bool; force = false. ). overrideprotectedvirtual . Interface function used by test statistics to freeze choice of observables for interpretation of fraction coefficients. ; Needed here because a RooSimultaneous works like a RooAddPdf when plotted ; Reimplemented from RooAbsReal.; Definition at line 938 of file RooSimultaneous.cxx. selectNormalizationRange(). void RooSimultaneous::selectNormalizationRange ; (; const char *; normRange2 = nullptr, . bool; force = false. ). overrideprotectedvirtual . Interface function used by test statistics to freeze choice of range for interpretation of fraction coefficients. ; Needed here because a RooSimultaneous works like a RooAddPdf when plotted ; Reimplemented from RooAbsReal.; Definition at line 950 of file RooSimultaneous.cxx. selfNormalized(). bool RooSimultaneous::selfNormalized ; (; ); const. inlineoverridevirtual . Shows if a PDF is self-normalized, which means that no attempt is made to add a normalization term. ; Always returns false, unless a PDF overrides this function. ; Reimplemented from RooAbsPdf.; Definition at line 68 of file RooSim",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooSimultaneous.html:98443,test,test,98443,doc/master/classRooSimultaneous.html,https://root.cern,https://root.cern/doc/master/classRooSimultaneous.html,1,['test'],['test']
Testability,"nition at line 101 of file MethodPyAdaBoost.cxx. DeclFileName(). static const char * TMVA::MethodPyAdaBoost::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 121 of file MethodPyAdaBoost.h. GetHelpMessage(). void MethodPyAdaBoost::GetHelpMessage ; (; ); const. protectedvirtual . Implements TMVA::IMethod.; Definition at line 428 of file MethodPyAdaBoost.cxx. GetMulticlassValues(). std::vector< Float_t > & MethodPyAdaBoost::GetMulticlassValues ; (; ). virtual . Reimplemented from TMVA::MethodBase.; Definition at line 353 of file MethodPyAdaBoost.cxx. GetMvaValue(). Double_t MethodPyAdaBoost::GetMvaValue ; (; Double_t *; errLower = nullptr, . Double_t *; errUpper = nullptr. ). virtual . Implements TMVA::PyMethodBase.; Definition at line 321 of file MethodPyAdaBoost.cxx. GetMvaValues(). std::vector< Double_t > MethodPyAdaBoost::GetMvaValues ; (; Long64_t; firstEvt = 0, . Long64_t; lastEvt = -1, . Bool_t; logProgress = false. ). virtual . get all the MVA values for the events of the current Data type ; Implements TMVA::PyMethodBase.; Definition at line 263 of file MethodPyAdaBoost.cxx. HasAnalysisType(). Bool_t MethodPyAdaBoost::HasAnalysisType ; (; Types::EAnalysisType; type, . UInt_t; numberClasses, . UInt_t; numberTargets. ). virtual . Implements TMVA::PyMethodBase.; Definition at line 93 of file MethodPyAdaBoost.cxx. Init(). void MethodPyAdaBoost::Init ; (; void; ). virtual . Implements TMVA::PyMethodBase.; Definition at line 182 of file MethodPyAdaBoost.cxx. IsA(). virtual TClass * TMVA::MethodPyAdaBoost::IsA ; (; ); const. inlinevirtual . ReturnsTClass describing current object ; Reimplemented from TMVA::PyMethodBase.; Definition at line 121 of file MethodPyAdaBoost.h. ProcessOptions(). void MethodPyAdaBoost::ProcessOptions ; (; ). virtual . Implements TMVA::PyMethodBase.; Definition at line 138 of file MethodPyAdaBoost.cxx. ReadModelFromFile(). void MethodPyAdaBoost::Re",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1MethodPyAdaBoost.html:32821,log,logProgress,32821,doc/master/classTMVA_1_1MethodPyAdaBoost.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1MethodPyAdaBoost.html,1,['log'],['logProgress']
Testability,"nition at line 104 of file TMultiDimFit.h. fSqError. TVectorD TMultiDimFit::fSqError. protected . Training sample, error in quantity. ; Definition at line 29 of file TMultiDimFit.h. fSumSqAvgQuantity. Double_t TMultiDimFit::fSumSqAvgQuantity. protected . Sum of squares away from mean. ; Definition at line 34 of file TMultiDimFit.h. fSumSqQuantity. Double_t TMultiDimFit::fSumSqQuantity. protected . SumSquare of dependent quantity. ; Definition at line 33 of file TMultiDimFit.h. fSumSqResidual. Double_t TMultiDimFit::fSumSqResidual. protected . Sum of Square residuals. ; Definition at line 77 of file TMultiDimFit.h. fTestCorrelationCoeff. Double_t TMultiDimFit::fTestCorrelationCoeff. protected . Multi Correlation coefficient. ; Definition at line 94 of file TMultiDimFit.h. fTestError. Double_t TMultiDimFit::fTestError. protected . Error from test. ; Definition at line 89 of file TMultiDimFit.h. fTestPrecision. Double_t TMultiDimFit::fTestPrecision. protected . Relative precision of test. ; Definition at line 91 of file TMultiDimFit.h. fTestQuantity. TVectorD TMultiDimFit::fTestQuantity. protected . Test sample, dependent quantity. ; Definition at line 44 of file TMultiDimFit.h. fTestSampleSize. Int_t TMultiDimFit::fTestSampleSize. protected . Size of test sample. ; Definition at line 48 of file TMultiDimFit.h. fTestSqError. TVectorD TMultiDimFit::fTestSqError. protected . Test sample, Error in quantity. ; Definition at line 45 of file TMultiDimFit.h. fTestVariables. TVectorD TMultiDimFit::fTestVariables. protected . Test sample, independent variables. ; Definition at line 46 of file TMultiDimFit.h. fVariables. TVectorD TMultiDimFit::fVariables. protected . Training sample, independent variables. ; Definition at line 36 of file TMultiDimFit.h. Libraries for TMultiDimFit:. [legend]; The documentation for this class was generated from the following files:; hist/hist/inc/TMultiDimFit.h; hist/hist/src/TMultiDimFit.cxx. TMultiDimFit. ROOT master - Re",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMultiDimFit.html:69078,test,test,69078,doc/master/classTMultiDimFit.html,https://root.cern,https://root.cern/doc/master/classTMultiDimFit.html,1,['test'],['test']
Testability,"nition at line 182 of file TGeoShape.cxx. ~TGeoShape(). TGeoShape::~TGeoShape ; (; ). override . Destructor. ; Definition at line 197 of file TGeoShape.cxx. Member Function Documentation. AfterStreamer(). virtual void TGeoShape::AfterStreamer ; (; ). inlinevirtual . Reimplemented in TGeoConeSeg, and TGeoTubeSeg.; Definition at line 93 of file TGeoShape.h. Big(). static Double_t TGeoShape::Big ; (; ). inlinestatic . Definition at line 87 of file TGeoShape.h. Capacity(). virtual Double_t TGeoShape::Capacity ; (; ); const. pure virtual . Implemented in TGeoArb8, TGeoBBox, TGeoCompositeShape, TGeoCone, TGeoConeSeg, TGeoEltu, TGeoHalfSpace, TGeoHype, TGeoPara, TGeoParaboloid, TGeoPcon, TGeoPgon, TGeoScaledShape, TGeoSphere, TGeoTorus, TGeoTrd1, TGeoTrd2, TGeoTube, TGeoTubeSeg, TGeoCtub, TGeoXtru, and TGeoVGShape. CheckShape(). void TGeoShape::CheckShape ; (; Int_t; testNo, . Int_t; nsamples = 10000, . Option_t *; option = """". ). Test for shape navigation methods. ; Summary for test numbers:. 1: DistFromInside/Outside. Sample points inside the shape. Generate directions randomly in cos(theta). Compute DistFromInside and move the point with bigger distance. Compute DistFromOutside back from new point. Plot d-(d1+d2) . Definition at line 211 of file TGeoShape.cxx. Class(). static TClass * TGeoShape::Class ; (; ). static . ReturnsTClass describing this class . Class_Name(). static const char * TGeoShape::Class_Name ; (; ). static . ReturnsName of this class . Class_Version(). static constexpr Version_t TGeoShape::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 171 of file TGeoShape.h. ClearThreadData(). virtual void TGeoShape::ClearThreadData ; (; ); const. inlinevirtual . Reimplemented in TGeoCompositeShape, TGeoPgon, and TGeoXtru.; Definition at line 66 of file TGeoShape.h. ComputeBBox(). virtual void TGeoShape::ComputeBBox ; (; ). pure virtual . Implemented in TGeoArb8, TGeoBBox, TGeoCompositeShape, TG",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoShape.html:27754,test,test,27754,doc/master/classTGeoShape.html,https://root.cern,https://root.cern/doc/master/classTGeoShape.html,1,['test'],['test']
Testability,nition at line 80 of file ClassInfo.h. Log(). MsgLogger & TMVA::ClassInfo::Log ; (; ); const. inlineprivate . Definition at line 77 of file ClassInfo.h. SetCorrelationMatrix(). void TMVA::ClassInfo::SetCorrelationMatrix ; (; TMatrixD *; matrix). inline . Definition at line 60 of file ClassInfo.h. SetCut(). void TMVA::ClassInfo::SetCut ; (; const TCut &; cut). inline . Definition at line 58 of file ClassInfo.h. SetNumber(). void TMVA::ClassInfo::SetNumber ; (; const UInt_t; index). inline . Definition at line 59 of file ClassInfo.h. SetWeight(). void TMVA::ClassInfo::SetWeight ; (; const TString &; weight). inline . Definition at line 57 of file ClassInfo.h. Streamer(). virtual void TMVA::ClassInfo::Streamer ; (; TBuffer &; R__b). virtual . Stream an object of class TObject. ; Reimplemented from TObject. StreamerNVirtual(). void TMVA::ClassInfo::StreamerNVirtual ; (; TBuffer &; ClassDef_StreamerNVirtual_b). inline . Definition at line 80 of file ClassInfo.h. Member Data Documentation. fCorrMatrix. TMatrixD* TMVA::ClassInfo::fCorrMatrix. private . Correlation matrix for this class. ; Definition at line 74 of file ClassInfo.h. fCut. TCut TMVA::ClassInfo::fCut. private . pre-training cut for the class ; Definition at line 71 of file ClassInfo.h. fLogger. MsgLogger* TMVA::ClassInfo::fLogger. mutableprivate . ! message logger ; Definition at line 76 of file ClassInfo.h. fNumber. UInt_t TMVA::ClassInfo::fNumber. private . index in of this class in vectors ; Definition at line 72 of file ClassInfo.h. fWeight. TString TMVA::ClassInfo::fWeight. private . the input formula string that is the weight for the class ; Definition at line 70 of file ClassInfo.h. Libraries for TMVA::ClassInfo:. [legend]; The documentation for this class was generated from the following files:; tmva/tmva/inc/TMVA/ClassInfo.h; tmva/tmva/src/ClassInfo.cxx. TMVAClassInfo. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:45:30 (GVA Time) using Doxygen 1.9.8 ; . ,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1ClassInfo.html:14969,log,logger,14969,doc/master/classTMVA_1_1ClassInfo.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1ClassInfo.html,1,['log'],['logger']
Testability,"nitor for merging sockets; TServerSocket*fMergingSocketSocket used for merging outputs if submerger; Long64_tfMsgSizeHWMHigh-Water-Mark on the size of messages with results; Int_tfNcmdcommand history number; TStringfOrdinalslave ordinal number; TStringfOutputFilepath with the temporary results of the current or last query; TStringfPackageDirdirectory containing packages and user libs; TProofLockPath*fPackageLockpackage dir locker; TVirtualProofPlayer*fPlayeractual player; TStringfPrefixPrefix identifying the node; TProof*fProofPROOF talking to slave servers; Int_tfProtocolprotocol version number; TQueryResultManager*fQMgrQuery-result manager; TMutex*fQMtxTo protect async msg queue; TStringfQueryDirdirectory containing query results and status; TProofLockPath*fQueryLockquery dir locker; Int_tfQuerySeqNumsequential number of the current or last query; TList*fQueuedMsglist of messages waiting to be processed; Float_tfRealTimereal time spent executing commands; Bool_tfRealTimeLogTRUE if log messages should be send back in real-time; TReaperTimer*fReaperTimerTimer used to control children state; TStopwatchfSaveOutputmeasures time spent saving the partial result; Bool_tfSendLogToMasterOn workers, controls logs sending to master; TStringfServiceservice we are running, either ""proofserv"" or ""proofslave""; TStringfSessionDirdirectory containing session dependent files; TStringfSessionTagtag for the server session; TShutdownTimer*fShutdownTimerTimer used to shutdown out-of-control sessions; TSocket*fSocketsocket connection to client; TStringfTopSessionTagtag for the global session; Int_tfTotSessionsTotal number of PROOF sessions on the cluster ; TStringfUseruser as which we run; TList*fWaitingQuerieslist of TProofQueryResult waiting to be processed; TStringfWorkDirdirectory containing all proof related info; static FILE*fgErrorHandlerFileFile where to log; static Int_tfgLogToSysLog>0 sent to syslog too; static Float_tfgMemHWMThreshold fraction of max for warning and finer moni",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TProofServ.html:19977,log,log,19977,root/html534/TProofServ.html,https://root.cern,https://root.cern/root/html534/TProofServ.html,1,['log'],['log']
Testability,"nitor for merging sockets; TServerSocket*fMergingSocketSocket used for merging outputs if submerger; Long64_tfMsgSizeHWMHigh-Water-Mark on the size of messages with results; Int_tfNcmdcommand history number; TStringfOrdinalslave ordinal number; TStringfOutputFilepath with the temporary results of the current or last query; TStringfPackageDirdirectory containing packages and user libs; TProofLockPath*fPackageLockpackage dir locker; TVirtualProofPlayer*fPlayeractual player; TStringfPrefixPrefix identifying the node; TProof*fProofPROOF talking to slave servers; Int_tfProtocolprotocol version number; TQueryResultManager*fQMgrQuery-result manager; TMutex*fQMtxTo protect async msg queue; TStringfQueryDirdirectory containing query results and status; TProofLockPath*fQueryLockquery dir locker; Int_tfQuerySeqNumsequential number of the current or last query; TList*fQueuedMsglist of messages waiting to be processed; Float_tfRealTimereal time spent executing commands; Bool_tfRealTimeLogTRUE if log messages should be send back in real-time; TReaperTimer*fReaperTimerTimer used to control children state; TStopwatchfSaveOutputmeasures time spent saving the partial result; Bool_tfSendLogToMasterOn workers, controls logs sending to master; TStringfServiceservice we are running, either ""proofserv"" or ""proofslave""; TStringfSessionDirdirectory containing session dependent files; TStringfSessionTagtag for the server session; TShutdownTimer*fShutdownTimerTimer used to shutdown out-of-control sessions; TSocket*fSocketsocket connection to client; TStringfTopSessionTagtag for the global session; Int_tfTotSessionsTotal number of PROOF sessions on the cluster; TStringfUseruser as which we run; TList*fWaitingQuerieslist of TProofQueryResult waiting to be processed; TStringfWorkDirdirectory containing all proof related info; static FILE*fgErrorHandlerFileFile where to log; static Int_tfgLogToSysLog>0 sent to syslog too; static Float_tfgMemHWMThreshold fraction of max for warning and finer monit",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TProofServ.html:20724,log,log,20724,root/html602/TProofServ.html,https://root.cern,https://root.cern/root/html602/TProofServ.html,2,['log'],['log']
Testability,"nks:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  TMVA;  TMVA::Ranking. class TMVA::Ranking. Ranking for variables in method (implementation). Function Members (Methods); public:. virtual~Ranking(); virtual voidAddRank(const TMVA::Rank& rank); static TClass*Class(); virtual TClass*IsA() const; TMVA::Ranking&operator=(const TMVA::Ranking&); virtual voidPrint() const; TMVA::RankingRanking(); TMVA::RankingRanking(const TMVA::Ranking&); TMVA::RankingRanking(const TString& context, const TString& rankingDiscriminatorName); voidSetContext(const TString& context); voidSetDiscrName(const TString& discrName); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). private:. TMVA::MsgLogger&Log() const. Data Members; private:. TStringfContextthe ranking context; TMVA::MsgLogger*fLogger! message logger; vector<TMVA::Rank>fRankingvector of ranks; TStringfRankingDiscriminatorNamethe name of the ranking discriminator. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Ranking(); default constructor. Ranking(const TString& context, const TString& rankingDiscriminatorName); constructor. ~Ranking(); destructor. void SetContext(const TString& context). void AddRank(const TMVA::Rank& rank); Add a new rank; take ownership of it. void Print() const; get maximum length of variable names. Ranking(). void SetDiscrName(const TString& discrName); { fRankingDiscriminatorName = discrName; }.  Author: Andreas Hoecker, Joerg Stelzer, Helge Voss, Kai Voss  Copyright (c) 2005: *;  Last changed: root/tmva $Id: Ranking.h 29195 2009-06-24 10:39:49Z brun $  Last generated: 2010-09-23 20:18; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMVA__Ranking.html:1040,log,logger,1040,root/html528/TMVA__Ranking.html,https://root.cern,https://root.cern/root/html528/TMVA__Ranking.html,1,['log'],['logger']
Testability,"nll(); virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TNamed&TNamed::operator=(const TNamed& rhs); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg(), const RooCmdArg& arg9 = RooCmdArg(), const RooCmdArg& arg10 = RooCmdArg()) const; virtual list<Double_t>*RooAbsReal::plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; virtual RooPlot*RooAbsReal::plotSliceOn(RooPlot* frame, const RooArgSet& sliceSet, Option_t* drawOptions = ""L"", Double_t scaleFactor = 1.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooProfileLL.html:18377,test,testArg,18377,root/html526/RooProfileLL.html,https://root.cern,https://root.cern/root/html526/RooProfileLL.html,2,['test'],['testArg']
Testability,"nly a reasonable thing to do when you use; ""YesOrNo"" leafs, while it might loose s.th. if you use the; purity information in the nodes.; --> hence I don't call it automatically in the tree building. Double_t PruneTree(const TMVA::DecisionTree::EventConstList* validationSample = __null); prune (get rid of internal nodes) the Decision tree to avoid overtraining; serveral different pruning methods can be applied as selected by the; variable ""fPruneMethod"". void ApplyValidationSample(const TMVA::DecisionTree::EventConstList* validationSample) const; run the validation sample through the (pruned) tree and fill in the nodes; the variables NSValidation and NBValidadtion (i.e. how many of the Signal; and Background events from the validation sample. This is then later used; when asking for the ""tree quality"" .. Double_t TestPrunedTreeQuality(const TMVA::DecisionTreeNode* dt = __null, Int_t mode = 0) const; return the misclassification rate of a pruned tree; a ""pruned tree"" may have set the variable ""IsTerminal"" to ""arbitrary"" at; any node, hence this tree quality testing will stop there, hence test; the pruned tree (while the full tree is still in place for normal/later use). void CheckEventWithPrunedTree(const TMVA::Event* ) const; pass a single validation event throught a pruned decision tree; on the way down the tree, fill in all the ""intermediate"" information; that would normally be there from training. Double_t GetSumWeights(const TMVA::DecisionTree::EventConstList* validationSample) const; calculate the normalization factor for a pruning validation sample. UInt_t CountLeafNodes(TMVA::Node* n = __null); return the number of terminal nodes in the sub-tree below Node n. void DescendTree(TMVA::Node* n = __null); descend a tree to find all its leaf nodes. void PruneNode(TMVA::DecisionTreeNode* node); prune away the subtree below the node. void PruneNodeInPlace(TMVA::DecisionTreeNode* node); prune a node temporaily (without actually deleting its decendants; which allows tes",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TMVA__DecisionTree.html:11917,test,testing,11917,root/html602/TMVA__DecisionTree.html,https://root.cern,https://root.cern/root/html602/TMVA__DecisionTree.html,4,['test'],"['test', 'testing']"
Testability,"nnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TVirtualViewer3D* Viewer3D(TVirtualPad* pad = 0, Option_t* type = """"); Create a Viewer 3D of specified type. virtual ~TVirtualViewer3D(); {}. Bool_t PreferLocalFrame() const; Viewers must always handle master (absolute) positions - and; buffer producers must be able to supply them. Some viewers may; prefer local frame & translation - and producers can optionally; supply them. Bool_t CanLoopOnPrimitives() const; Viewers can implement their own loop over pad's primitive list. { return kFALSE; }. void PadPaint(TVirtualPad* ); When they can, TPad::Paint() and TPad::PaintModified() simply; call the following function:. {}. void ObjectPaint(TObject* , Option_t* = """"); {}. void BeginScene(); Addition/removal of objects must occur between Begin/EndUpdate calls. Bool_t BuildingScene() const. void EndScene(). Int_t AddObject(const TBuffer3D& buffer, Bool_t* addChildren = 0); Simple object addition - buffer represents a unique single positioned object. Int_t AddObject(UInt_t physicalID, const TBuffer3D& buffer, Bool_t* addChildren = 0); Complex object addition - for adding physical objects which have common logical; shapes. In this case buffer describes template shape (aside from kCore). Bool_t OpenComposite(const TBuffer3D& buffer, Bool_t* addChildren = 0). void CloseComposite(). void AddCompositeOp(UInt_t operation). TObject * SelectObject(Int_t , Int_t ); {return 0;}. void DrawViewer(); {}. void PrintObjects(); {}. void ResetCameras(); {}. void ResetCamerasAfterNextUpdate(); {}.  Author: Olivier Couet 05/10/2004  Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *;  Last changed: root/base:$Id$  Last generated: 2015-03-15 16:41; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TVirtualViewer3D.html:17939,log,logical,17939,root/html534/TVirtualViewer3D.html,https://root.cern,https://root.cern/root/html534/TVirtualViewer3D.html,1,['log'],['logical']
Testability,"nnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TStringTSQLServer::fDBcurrently selected DB; Int_tTSQLServer::fErrorCodeerror code of last operation; TStringTSQLServer::fErrorMsgerror message of last operation; Bool_tTSQLServer::fErrorOutenable error output; TStringTSQLServer::fHosthost to which we are connected; TStringfInfoserver info string; MYSQL*fMySQLconnection to MySQL server; Int_tTSQLServer::fPortport to which we are connected; TStringTSQLServer::fTypetype of DBMS (MySQL, Oracle, SysBase, ...); static const char*TSQLServer::fgFloatFmt! printf argument for floats and doubles, either ""%f"" or ""%e"" or ""%10f"" and so on. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TMySQLServer(const char* db, const char* uid, const char* pw); Open a connection to a MySQL DB server. The db arguments should be; of the form ""mysql://<host>[:<port>][/<database>]"", e.g.:; ""mysql://pcroot.cern.ch:3456/test"". The uid is the username and pw; the password that should be used for the connection. In addition, several parameters can be specified in url after ""?"" symbol:; timeout=N n is connect timeout is seconds; socket=socketname socketname should be name of Unix socket, used; for connection; multi_statements tell the server that the client may send multiple; statements in a single string (separated by ;);; multi_results tell the server that the client can handle multiple; result sets from multiple-statement executions or; stored procedures; reconnect=0|1 enable or disable automatic reconnection to the server; if the connection is found to have been lost; compress use the compressed client/server protocol; cnf_file=filename Read options from the named option file instead of; from my.cnf; cnf_group=groupname Read options from the named group from my.cnf or the; file specified with cnf_file option; If several parameters are specified, they should be separated by ""&"" symbol; Example of con",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMySQLServer.html:8868,test,test,8868,root/html528/TMySQLServer.html,https://root.cern,https://root.cern/root/html528/TMySQLServer.html,4,['test'],['test']
Testability,"nned likelihood is constructed. If the dataset; is binned, a binned likelihood is constructed. See RooAbsPdf::createNLL(RooAbsData& data, RooCmdArg arg1, RooCmdArg arg2, RooCmdArg arg3, RooCmdArg arg4,; RooCmdArg arg5, RooCmdArg arg6, RooCmdArg arg7, RooCmdArg arg8). for documentation of options. RooFitResult* fitTo(RooAbsData& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); Fit PDF to given dataset. If dataset is unbinned, an unbinned maximum likelihood is performed. If the dataset; is binned, a binned maximum likelihood is performed. By default the fit is executed through the MINUIT; commands MIGRAD, HESSE in succession. The following named arguments are supported. Options to control construction of -log(L). ConditionalObservables(const RooArgSet& set) -- Do not normalize PDF over listed observables; Extended(Bool_t flag) -- Add extended likelihood term, off by default; Range(const char* name) -- Fit only data inside range with given name; Range(Double_t lo, Double_t hi) -- Fit only data inside given range. A range named ""fit"" is created on the fly on all observables.; Multiple comma separated range names can be specified.; SumCoefRange(const char* name) -- Set the range in which to interpret the coefficients of RooAddPdf components; NumCPU(int num, int strat) -- Parallelize NLL calculation on num CPUs. Strategy 0 = RooFit::BulkPartition (Default) --> Divide events in N equal chunks; Strategy 1 = RooFit::Interleave --> Process event i%N in process N. Recommended for binned data with; a substantial number of zero-bins, which will be distributed across processes more equitably in this strategy; Strategy 2 = RooFit::SimComponents --> Process each component likelihood of",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAbsPdf.html:53911,log,log,53911,root/html534/RooAbsPdf.html,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html,3,['log'],['log']
Testability,"nning; TSelector*TProof::fSelectorSelector to be processed, if any; TProofMgr::EServTypeTProof::fServTypetype of server: proofd, XrdProofd; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; TList*TProof::fSlaveslist of all slave servers as in config file; TList*TProof::fTerminatedSlaveInfoslist of unique infos of terminated slaves; TStringTNamed::fTitleobject title; Long64_tTProof::fTotalBytesnumber of bytes to be analyzed; TUrlTProof::fUrlUrl of the master; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static TSemaphore*TProof::fgSemaphoresemaphore to control no of parallel startup threads; static TProof::ESlavesTProof::kActive; static TProof::ESlavesTProof::kAll; static TProof::ESlavesTProof::kAllUnique; static TProof::ESlavesTProof::kUnique. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TProofSuperMaster(const char* masterurl, const char* conffile = kPROOF_ConfFile, const char* confdir = kPROOF_ConfDir, Int_t loglevel = 0, const char* alias = 0, TProofMgr* mgr = 0); Start super master PROOF session. Bool_t StartSlaves(Bool_t ); Start up PROOF submasters. Long64_t Process(TDSet* set, const char* selector, Option_t* option = """", Long64_t nentries = -1, Long64_t firstentry = 0); Process a data set (TDSet) using the specified selector (.C) file.; Entry- or event-lists should be set in the data set object using; TDSet::SetEntryList.; The return value is -1 in case of error and TSelector::GetStatus() in; in case of success. void ValidateDSet(TDSet* dset); Validate a TDSet. TVirtualProofPlayer * MakePlayer(const char* player = 0, TSocket* s = 0); Construct a TProofPlayer object. The player string specifies which; player should be created: remote, slave, sm (supermaster) or base.; Default is sm. Socket is needed in case a slave player is created. TProofSuperMaster(const char* masterurl, const char* conffile = kPROOF_ConfFile, const char* confdir = kPROOF_ConfDir, Int_t ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TProofSuperMaster.html:27788,log,loglevel,27788,root/html602/TProofSuperMaster.html,https://root.cern,https://root.cern/root/html602/TProofSuperMaster.html,2,['log'],['loglevel']
Testability,"nnotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). }; ; Protected Types inherited from TObject; enum { kOnlyPrepStep = (1ULL << ( 3 )); }; ; Protected Member Functions inherited from TMVA::Configurable; voidEnableLooseOptions (Bool_t b=kTRUE); ; const TString &GetReferenceFile () const; ; Bool_tLooseOptionCheckingEnabled () const; ; voidResetSetFlag (); resets the IsSet flag for all declare options to be called before options are read from stream ; ; voidWriteOptionsReferenceToFile (); write complete options to output stream ; ; Protected Member Functions inherited from TObject; virtual voidDoError (int level, const char *location, const char *fmt, va_list va) const; Interface to ErrorHandler (protected). ; ; voidMakeZombie (); ; Protected Attributes inherited from TMVA::CvSplit; Bool_tfMakeFoldDataSet; ; UInt_tfNumFolds; ; std::vector< std::vector< TMVA::Event * > >fTestEvents; ; std::vector< std::vector< TMVA::Event * > >fTrainEvents; ; Protected Attributes inherited from TMVA::Configurable; MsgLogger *fLogger; ! message logger ; ; Protected Attributes inherited from TNamed; TStringfName; ; TStringfTitle; . #include <TMVA/CvSplit.h>. Inheritance diagram for TMVA::CvSplitKFolds:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. CvSplitKFolds(). TMVA::CvSplitKFolds::CvSplitKFolds ; (; UInt_t; numFolds, . TString; splitExpr = """", . Bool_t; stratified = kTRUE, . UInt_t; seed = 100. ). Splits a dataset into k folds, ready for use in cross validation. ; Parameters. [in]numFoldsNumber of folds to split data into ; [in]stratifiedIf true, use stratified splitting, balancing the number of events across classes and folds. If false, no such balancing is done. For ; [in]splitExprExpression used to split data into folds. If """" a random assignment will be done. Otherwise the expression is fed into ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1CvSplitKFolds.html:15375,log,logger,15375,doc/master/classTMVA_1_1CvSplitKFolds.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1CvSplitKFolds.html,1,['log'],['logger']
Testability,nometric.cpp; tests; arithmetics.cpp; casts.cpp; const.h; convert-sincos-reference.cpp; deinterleave.cpp; expandandmerge.cpp; gather.cpp; implicit_type_conversion.cpp; implicit_type_conversion_failures.cpp; linkTest0.cpp; linkTest1.cpp; linkTestLib0.cpp; linkTestLib1.cpp; linkTestLib2.cpp; linkTestLib3.cpp; load.cpp; mask.cpp; math.cpp; memory.cpp; scalaraccess.cpp; scatter.cpp; sse_blend.cpp; stlcontainer.cpp; store.cpp; supportfunctions.cpp; swizzles.cpp; ulp.h; unittest.h; utils.cpp; vectormemoryhelper.h; makeTest.py; vdt; include; vdt; asin.h; atan.h; atan2.h; cos.h; exp.h; inv.h; log.h; sin.h; sincos.h; sqrt.h; tan.h; vdtcore_common.h; vdtMath.h; tests; stressVdt.cxx; misc; memstat; inc; LinkDef.h; TMemStat.h; TMemStatBacktrace.h; TMemStatDef.h; TMemStatHelpers.h; TMemStatHook.h; TMemStatMng.h; src; TMemStat.cxx; TMemStatBacktrace.cxx; TMemStatHelpers.cxx; TMemStatHook.cxx; TMemStatMng.cxx; test; leak_test.C; run.C; table; inc; LinkDef.h; tableDescriptor.h; TCernLib.h; TChair.h; TColumnView.h; TDataSet.h; TDataSetIter.h; TDsKey.h; TFileIter.h; TFileSet.h; TGenericTable.h; TIndexTable.h; TObjectSet.h; TPoints3D.h; TPointsArray3D.h; TPolyLineShape.h; TResponseTable.h; TTable.h; TTable3Points.h; TTableDescriptor.h; TTableIter.h; TTableMap.h; TTablePadView3D.h; TTablePoints.h; TTableSorter.h; Ttypes.h; TVolume.h; TVolumePosition.h; TVolumeView.h; TVolumeViewIter.h; src; TCernLib.cxx; TChair.cxx; TColumnView.cxx; TDataSet.cxx; TDataSetIter.cxx; TDsKey.cxx; TFileIter.cxx; TFileSet.cxx; TGenericTable.cxx; TIndexTable.cxx; TObjectSet.cxx; TPoints3D.cxx; TPointsArray3D.cxx; TPolyLineShape.cxx; TResponseTable.cxx; TTable.cxx; TTable3Points.cxx; TTableDescriptor.cxx; TTableIter.cxx; TTableMap.cxx; TTablePadView3D.cxx; TTablePoints.cxx; TTableSorter.cxx; TVolume.cxx; TVolumePosition.cxx; TVolumeView.cxx; TVolumeViewIter.c,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html606/files.html:60128,test,test,60128,root/html606/files.html,https://root.cern,https://root.cern/root/html606/files.html,1,['test'],['test']
Testability,"non-assembly volume candidates overlap/extrude. Returns overlap object. void CheckOverlapsBySampling(TGeoVolume* vol, Double_t ovlp = 0.10000000000000001, Int_t npoints = 1000000) const; Check illegal overlaps for volume VOL within a limit OVLP by sampling npoints; inside the volume shape. Int_t NChecksPerVolume(TGeoVolume* vol); Compute number of overlaps combinations to check per volume. void CheckOverlaps(const TGeoVolume* vol, Double_t ovlp = 0.10000000000000001, Option_t* option = """"); Check illegal overlaps for volume VOL within a limit OVLP. void PrintOverlaps() const; Print the current list of overlaps held by the manager class. void CheckPoint(Double_t x = 0, Double_t y = 0, Double_t z = 0, Option_t* option = """"); --- Draw point (x,y,z) over the picture of the daughers of the volume containing this point.; Generates a report regarding the path to the node containing this point and the distance to; the closest boundary. void CheckShape(TGeoShape* shape, Int_t testNo, Int_t nsamples, Option_t* option); Test for shape navigation methods. Summary for test numbers:; 1: DistFromInside/Outside. Sample points inside the shape. Generate; directions randomly in cos(theta). Compute DistFromInside and move the; point with bigger distance. Compute DistFromOutside back from new point.; Plot d-(d1+d2); 2: Safety test. Sample points inside the bounding and compute safety. Generate; directions randomly in cos(theta) and compute distance to boundary. Check if; Distance to boundary is bigger than safety. void ShapeDistances(TGeoShape* shape, Int_t nsamples, Option_t* option); Test TGeoShape::DistFromInside/Outside. Sample points inside the shape. Generate; directions randomly in cos(theta). Compute d1 = DistFromInside and move the; point on the boundary. Compute DistFromOutside and propagate with d2 making sure that; the shape is not re-entered. Swap direction and call DistFromOutside that; should fall back on the same point on the boundary (at d2). Propagate back on boundary",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGeoChecker.html:15168,test,testNo,15168,root/html602/TGeoChecker.html,https://root.cern,https://root.cern/root/html602/TGeoChecker.html,2,['test'],['testNo']
Testability,"non-shared sides. Fiddling with; the size of the `alittlebit' parameter may help. void FindHull(); Finds those points which make up the convex hull of the set. If the xy; plane were a sheet of wood, and the points were nails hammered into it; at the respective coordinates, then if an elastic band were stretched; over all the nails it would form the shape of the convex hull. Those; nails in contact with it are the points that make up the hull. Bool_t InHull(Int_t E, Int_t X) const; Is point e inside the hull defined by all points apart from x ?. Double_t InterpolateOnPlane(Int_t TI1, Int_t TI2, Int_t TI3, Int_t E) const; Finds the z-value at point e given that it lies; on the plane defined by t1,t2,t3. Double_t Interpolate(Double_t x, Double_t y); Finds the Delaunay triangle that the point (xi,yi) sits in (if any) and; calculate a z-value for it by linearly interpolating the z-values that; make up that triangle. void SetMaxIter(Int_t n = 100000); Defines the number of triangles tested for a Delaunay triangle; (number of iterations) before abandoning the search. void SetMarginBinsContent(Double_t z = 0.); Sets the histogram bin height for points lying outside the convex hull ie:; the bins in the margin. TGraphDelaunay(const TGraphDelaunay& ). TGraphDelaunay& operator=(const TGraphDelaunay& ). TGraph2D * GetGraph2D() const; {return fGraph2D;}. Double_t GetMarginBinsContent() const; {return fZout;}. Int_t GetNdt() const; {return fNdt;}. Int_t * GetPTried() const; {return fPTried;}. Int_t * GetNTried() const; {return fNTried;}. Int_t * GetMTried() const; {return fMTried;}. Double_t * GetXN() const; {return fXN;}. Double_t * GetYN() const; {return fYN;}. Double_t GetXNmin() const; {return fXNmin;}. Double_t GetXNmax() const; {return fXNmax;}. Double_t GetYNmin() const; {return fYNmin;}. Double_t GetYNmax() const; {return fYNmax;}.  Author: Olivier Couet, Luke Jones (Royal Holloway, University of London)  Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *;  Last ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGraphDelaunay.html:11014,test,tested,11014,root/html528/TGraphDelaunay.html,https://root.cern,https://root.cern/root/html528/TGraphDelaunay.html,6,['test'],['tested']
Testability,"non-zero and if hist_vyy is set, defines the inverse of the data covariance matrix; Return value: number of bins with bad error; +10000*number of unconstrained output bins; Note: return values>=10000 are fatal errors,; for the given input, the unfolding can not be done!; Data members modified:; fY, fVyy, , fBiasScale; Data members cleared; fVyyInv, fNdf; + see ClearResults. Double_t DoUnfold(Double_t tau); Unfold with given value of regularisation parameter tau; tau: new tau parameter; required data members:; fA: matrix to relate x and y; fY: measured data points; fX0: bias on x; fBiasScale: scale factor for fX0; fV: inverse of covariance matrix for y; fL: regularisation conditions; modified data members:; fTauSquared and those documented in DoUnfold(void). Int_t ScanLcurve(Int_t nPoint, Double_t tauMin, Double_t tauMax, TGraph** lCurve, TSpline** logTauX = 0, TSpline** logTauY = 0); scan the L curve; nPoint: number of points on the resulting curve; tauMin: smallest tau value to study; tauMax: largest tau value to study; lCurve: the L curve as graph; logTauX: output spline of x-coordinates vs tau for the L curve; logTauY: output spline of y-coordinates vs tau for the L curve; return value: the coordinate number (0..nPoint-1) with the ""best"" choice; of tau. void GetNormalisationVector(TH1* s, const Int_t* binMap = 0) const; get vector of normalisation factors; out: output histogram; binMap: for each bin of the original output distribution; specify the destination bin. A value of -1 means that the bin; is discarded. 0 means underflow bin, 1 first bin, ...; binMap[0] : destination of underflow bin; binMap[1] : destination of first bin. void GetBias(TH1* bias, const Int_t* binMap = 0) const; get bias distribution, possibly with bin remapping; out: output histogram; binMap: for each bin of the original output distribution; specify the destination bin. A value of -1 means that the bin; is discarded. 0 means underflow bin, 1 first bin, ...; binMap[0] : destination of underf",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TUnfold.html:26368,log,logTauX,26368,root/html534/TUnfold.html,https://root.cern,https://root.cern/root/html534/TUnfold.html,12,['log'],"['logTauX', 'logTauY']"
Testability,"not a uniquely defined statistical technique, it requires that one specify an ordering rule ; or ordering principle, which is usually incoded by choosing a specific test statistic and limits of integration ; (corresponding to upper/lower/central limits). As a result, this class must be configured with the corresponding; information before it can produce an interval. Common configurations, such as the Feldman-Cousins approach, can be ; enforced by other light weight classes. The Neyman Construction considers every point in the parameter space independently, no assumptions are ; made that the interval is connected or of a particular shape. As a result, the PointSetInterval class is used to ; represent the result. The user indicate which points in the parameter space to perform the constrution by providing; a PointSetInterval instance with the desired points. This class is fairly light weight, because the choice of parameter points to be considered is factorized and so is the ; creation of the sampling distribution of the test statistic (which is done by a concrete class implementing the DistributionCreator interface). As a result, this class basically just drives the construction by:. using a DistributionCreator to create the SamplingDistribution of a user-defined test statistic for each parameter point of interest,; defining the acceptance region in the data by finding the thresholds on the test statistic such that the integral of the sampling distribution is of the appropriate size and consistent with the limits of integration (eg. upper/lower/central limits), ; and finally updating the PointSetInterval based on whether the value of the test statistic evaluated on the data are in the acceptance region. Function Members (Methods); public:. virtual~NeymanConstruction(); voidAdditionalNToysFactor(double fact); static TClass*Class(); virtual Double_tConfidenceLevel() const; voidCreateConfBelt(bool flag = true); RooStats::ConfidenceBelt*GetConfidenceBelt(); virtual RooSta",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooStats__NeymanConstruction.html:1690,test,test,1690,root/html528/RooStats__NeymanConstruction.html,https://root.cern,https://root.cern/root/html528/RooStats__NeymanConstruction.html,6,['test'],['test']
Testability,"not a uniquely defined statistical technique, it requires that one specify an ordering rule ; or ordering principle, which is usually incoded by choosing a specific test statistic and limits of integration ; (corresponding to upper/lower/central limits). As a result, this class must be configured with the corresponding; information before it can produce an interval. Common configurations, such as the Feldman-Cousins approach, can be ; enforced by other light weight classes. The Neyman Construction considers every point in the parameter space independently, no assumptions are ; made that the interval is connected or of a particular shape. As a result, the PointSetInterval class is used to ; represent the result. The user indicate which points in the parameter space to perform the constrution by providing; a PointSetInterval instance with the desired points. This class is fairly light weight, because the choice of parameter points to be considered is factorized and so is the ; creation of the sampling distribution of the test statistic (which is done by a concrete class implementing the DistributionCreator interface). As a result, this class basically just drives the construction by:. using a DistributionCreator to create the SamplingDistribution of a user-defined test statistic for each parameter point of interest,; defining the acceptance region in the data by finding the thresholds on the test statistic such that the integral of the sampling distribution is of the appropriate size and consistent with the limits of integration (eg. upper/lower/central limits), ; and finally updating the PointSetInterval based on whether the value of the test statistic evaluated on the data are in the acceptance region. Function Members (Methods); public:. virtual~NeymanConstruction(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject:",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooStats__NeymanConstruction.html:1705,test,test,1705,root/html526/RooStats__NeymanConstruction.html,https://root.cern,https://root.cern/root/html526/RooStats__NeymanConstruction.html,1,['test'],['test']
Testability,"not attempt to modify the axis. This is different than FindBin. Int_t FindFixBin(Double_t x) const; Find bin number corresponding to abscissa x. Identical to TAxis::FindBin except that if x is an underflow/overflow; no attempt is made to extend the axis. const char * GetBinLabel(Int_t bin) const; Return label for bin. Int_t GetFirst() const; return first bin on the axis; ie 1 if no range defined; NOTE: in some cases a zero is returned (see TAxis::SetRange). Int_t GetLast() const; return last bin on the axis; ie fNbins if no range defined; NOTE: in some cases a zero is returned (see TAxis::SetRange). Double_t GetBinCenter(Int_t bin) const; Return center of bin. Double_t GetBinCenterLog(Int_t bin) const; Return center of bin in log; With a log-equidistant binning for a bin with low and up edges, the mean is :; 0.5*(ln low + ln up) i.e. sqrt(low*up) in logx (e.g. sqrt(10^0*10^2) = 10).; Imagine a bin with low=1 and up=100 :; - the center in lin is (100-1)/2=50.5; - the center in log would be sqrt(1*100)=10 (!=log(50.5)); NB: if the low edge of the bin is negative, the function returns the bin center; as computed by TAxis::GetBinCenter. Double_t GetBinLowEdge(Int_t bin) const; Return low edge of bin. Double_t GetBinUpEdge(Int_t bin) const; Return up edge of bin. Double_t GetBinWidth(Int_t bin) const; Return bin width. void GetCenter(Double_t* center) const; Return an array with the center of all bins. void GetLowEdge(Double_t* edge) const; Return an array with the lod edge of all bins. const char * GetTimeFormatOnly() const; Return *only* the time format from the string fTimeFormat. const char * GetTicks() const; Return the ticks option (see SetTicks). Bool_t HasBinWithoutLabel() const; this helper function checks if there is a bin without a label; if all bins have labels, the axis can / will become alphanumeric. void LabelsOption(Option_t* option = ""h""); Set option(s) to draw axis with labels; option = ""a"" sort by alphabetic order; = "">"" sort by decreasing values; = ""<""",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TAxis.html:15660,log,log,15660,root/html602/TAxis.html,https://root.cern,https://root.cern/root/html602/TAxis.html,4,['log'],['log']
Testability,"not changed.; CMAKE_CXX_STANDARD, i.e.the C++ standard ROOT is built with, now defaults to the compiler default (or C++11 if the compiler default is older than that) rather than always defaulting to C++11. In turn this means that v6.24 is the first ROOT release for which ROOTs pre-compiled binaries are not compiled with C++11 but with the default standard in use by the default system compiler. On Ubuntu 20.04, for example, the v6.24 pre-compiled binaries are now compiled with C++14 rather than C++11 as it happened for previous ROOT versions. Also see ROOT-10692. The following builtins have been updated:. VecCore 0.7.0; LZ4 1.9.3; openui5; Xrootd 4.12.8; Zstd 1.4.8. PyROOT. Deprecate TTree.AsMatrix in this release and mark for removal in v6.26. Please use instead RDataFrame.AsNumpy. Bugs and Issues fixed in this release. [ROOT-9790] - [DF] Lazy jitting of Cache and Snapshot; [ROOT-3579] - RooTreeDataStore not Cloning the tree properly (and const correctness); [ROOT-3635] - integration for PDF value in binned fit; [ROOT-3874] - problem with binned likelihood fit in RooFit; [ROOT-5334] - RooFit RooAbsPdf::getLogVal() returns log((double)0) (==inf !). [ROOT-5380] - 2D fit not converging when using RooProdPDF and RooFFTConvPdf; [ROOT-5464] - GetEntries reports warning when friend chain with index; [ROOT-6505] - ROOT fails to read a file with particular branch names interactively; [ROOT-6892] - Memory leak in TSocket::SendProcessIDs; [ROOT-7182] - gSystem->cd has negative effect on TFile with relative path; [ROOT-7199] - Clang error dumping Expr originated by a typo at the prompt; [ROOT-7506] - Problem with axis in TMVAMultiClassGui when showing Classifier Output Distributions; [ROOT-7507] - Setting number of signal or background events by hand does not update the numbers; [ROOT-7720] - Bug in the caching optimisation when fitting with a RooProdPdf; [ROOT-7894] - hadd bug for TProfile with alphanumeric bin labels; [ROOT-8095] - TGraph::GetHistogram needlessly removes ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v624/release-notes.html:30880,log,log,30880,doc/v624/release-notes.html,https://root.cern,https://root.cern/doc/v624/release-notes.html,1,['log'],['log']
Testability,"not implemented in this case; 406 if (!extended) {; 407 MATH_WARN_MSG(""Fitter::DoBinnedLikelihoodFit"",; 408 ""Not-extended binned fit with gradient not yet supported - do an extended fit"");; 409 extended = true;; 410 }; 411 if (fFunc_v) {; 412 // create a chi2 function to be used for the equivalent chi-square; 413 Chi2FCN<BaseFunc, IModelFunction_v> chi2(data, fFunc_v);; 414 std::shared_ptr<IGradModelFunction_v> gradFun = std::dynamic_pointer_cast<IGradModelFunction_v>(fFunc_v);; 415 if (!gradFun) {; 416 MATH_ERROR_MSG(""Fitter::DoBinnedLikelihoodFit"", ""wrong type of function - it does not provide gradient"");; 417 return false;; 418 }; 419 auto logl = std::make_unique<PoissonLikelihoodFCN<BaseGradFunc, IModelFunction_v>>(data, gradFun, useWeight, extended, executionPolicy);; 420 // do minimization; 421 return (useWeight) ? DoWeightMinimization(std::move(logl),&chi2) : DoMinimization(std::move(logl),&chi2);; 422 } else {; 423 // create a chi2 function to be used for the equivalent chi-square; 424 Chi2FCN<BaseFunc> chi2(data, fFunc);; 425 // check if fFunc provides gradient; 426 std::shared_ptr<IGradModelFunction> gradFun = std::dynamic_pointer_cast<IGradModelFunction>(fFunc);; 427 if (!gradFun) {; 428 MATH_ERROR_MSG(""Fitter::DoBinnedLikelihoodFit"", ""wrong type of function - it does not provide gradient"");; 429 return false;; 430 }; 431 // use gradient for minimization; 432 auto logl = std::make_unique<PoissonLikelihoodFCN<BaseGradFunc>>(data, gradFun, useWeight, extended, executionPolicy);; 433 // do minimization; 434 return (useWeight) ? DoWeightMinimization(std::move(logl),&chi2) : DoMinimization(std::move(logl),&chi2);; 435 }; 436 }; 437 return false;; 438}; 439 ; 440bool Fitter::DoUnbinnedLikelihoodFit(bool extended, const ROOT::EExecutionPolicy &executionPolicy) {; 441 // perform a likelihood fit on a set of unbinned data; 442 ; 443 std::shared_ptr<UnBinData> data = std::dynamic_pointer_cast<UnBinData>(fData);; 444 assert(data);; 445 ; 446 bool useWeight = fConfig.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/Fitter_8cxx_source.html:16253,log,logl,16253,doc/master/Fitter_8cxx_source.html,https://root.cern,https://root.cern/doc/master/Fitter_8cxx_source.html,4,"['assert', 'log']","['assert', 'logl']"
Testability,"not in the list of labels, add it.; If the number of labels exceeds the number of bins, double the number; of bins via TH1::LabelsInflate (if the histogram can be rebinned). Int_t FindFixBin(Double_t x) const; Find bin number corresponding to abscissa x. const char * GetBinLabel(Int_t bin) const; Return label for bin. Int_t GetFirst() const; return first bin on the axis; ie 1 if no range defined; NOTE: in some cases a zero is returned (see TAxis::SetRange). Int_t GetLast() const; return last bin on the axis; ie fNbins if no range defined; NOTE: in some cases a zero is returned (see TAxis::SetRange). Double_t GetBinCenter(Int_t bin) const; Return center of bin. Double_t GetBinCenterLog(Int_t bin) const; Return center of bin in log; With a log-equidistant binning for a bin with low and up edges, the mean is :; 0.5*(ln low + ln up) i.e. sqrt(low*up) in logx (e.g. sqrt(10^0*10^2) = 10).; Imagine a bin with low=1 and up=100 :; - the center in lin is (100-1)/2=50.5; - the center in log would be sqrt(1*100)=10 (!=log(50.5)); NB: if the low edge of the bin is negative, the function returns the bin center; as computed by TAxis::GetBinCenter. Double_t GetBinLowEdge(Int_t bin) const; Return low edge of bin. Double_t GetBinUpEdge(Int_t bin) const; Return up edge of bin. Double_t GetBinWidth(Int_t bin) const; Return bin width. void GetCenter(Double_t* center) const; Return an array with the center of all bins. void GetLowEdge(Double_t* edge) const; Return an array with the lod edge of all bins. const char * GetTimeFormatOnly() const; Return *only* the time format from the string fTimeFormat. const char * GetTicks() const; Return the ticks option (see SetTicks). void LabelsOption(Option_t* option = ""h""); Set option(s) to draw axis with labels; option = ""a"" sort by alphabetic order; = "">"" sort by decreasing values; = ""<"" sort by increasing values; = ""h"" draw labels horizonthal; = ""v"" draw labels vertical; = ""u"" draw labels up (end of label right adjusted); = ""d"" draw labels down (s",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/TAxis.html:13728,log,log,13728,root/html526/TAxis.html,https://root.cern,https://root.cern/root/html526/TAxis.html,4,['log'],['log']
Testability,"noting the drop-out probabilities for each layer ; endend of an array or vector denoting the drop-out probabilities for each layer ; _dropRepetitionsdenotes after how many repetitions the drop-out setting (which nodes are dropped out exactly) is changed . Definition at line 759 of file NeuralNet.h. setMonitoring(). void TMVA::DNN::Settings::setMonitoring ; (; std::shared_ptr< Monitoring >; ptrMonitoring). inline . prepared for monitoring ; Definition at line 764 of file NeuralNet.h. setProgressLimits(). virtual void TMVA::DNN::Settings::setProgressLimits ; (; double; minProgress = 0, . double; maxProgress = 100. ). inlinevirtual . Parameters. maxProgressfor monitoring and logging (set the current ""progress"" limits for the display of the progress); minProgressminimum value; maxProgressmaximum value . Definition at line 790 of file NeuralNet.h. startTestCycle(). virtual void TMVA::DNN::Settings::startTestCycle ; (; ). inlinevirtual . callback for monitoring and loggging ; Reimplemented in TMVA::DNN::ClassificationSettings.; Definition at line 804 of file NeuralNet.h. startTrainCycle(). virtual void TMVA::DNN::Settings::startTrainCycle ; (; ). inlinevirtual . Reimplemented in TMVA::DNN::ClassificationSettings.; Definition at line 782 of file NeuralNet.h. startTraining(). virtual void TMVA::DNN::Settings::startTraining ; (; ). inlinevirtual . Definition at line 795 of file NeuralNet.h. testIteration(). virtual void TMVA::DNN::Settings::testIteration ; (; ). inlinevirtual . callback for monitoring and loggging ; Reimplemented in TMVA::DNN::ClassificationSettings.; Definition at line 806 of file NeuralNet.h. testRepetitions(). size_t TMVA::DNN::Settings::testRepetitions ; (; ); const. inline . how often is the test data tested ; Definition at line 768 of file NeuralNet.h. testSample(). virtual void TMVA::DNN::Settings::testSample ; (; double; , . double; , . double; , . double; . ). inlinevirtual . virtual function to be used for monitoring (callba",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1DNN_1_1Settings.html:11781,log,loggging,11781,doc/master/classTMVA_1_1DNN_1_1Settings.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1DNN_1_1Settings.html,1,['log'],['loggging']
Testability,"npoints each.Definition TGraph.h:41; TGraph::Drawvoid Draw(Option_t *chopt="""") overrideDraw this graph with its current attributes.Definition TGraph.cxx:831; TH1D1-D histogram with a double per channel (see TH1 documentation)Definition TH1.h:670; TH1TH1 is the base class of all histogram classes in ROOT.Definition TH1.h:59; TH1::SetDirectoryvirtual void SetDirectory(TDirectory *dir)By default, when a histogram is created, it is added to the list of histogram objects in the current ...Definition TH1.cxx:8937; TH1::GetBinCentervirtual Double_t GetBinCenter(Int_t bin) constReturn bin center for 1D histogram.Definition TH1.cxx:9141; TH1::DistancetoPrimitiveInt_t DistancetoPrimitive(Int_t px, Int_t py) overrideCompute distance from point px,py to a line.Definition TH1.cxx:2823; TH1::SetTitlevoid SetTitle(const char *title) overrideChange/set the title.Definition TH1.cxx:6718; TH1::GetMinimumStoredvirtual Double_t GetMinimumStored() constDefinition TH1.h:293; TH1::Classstatic TClass * Class(); TH1::kLogX@ kLogXX-axis in log scale.Definition TH1.h:168; TH1::kNoStats@ kNoStatsDon't draw stats box.Definition TH1.h:165; TH1::kIsZoomed@ kIsZoomedBit set when zooming on Y axis.Definition TH1.h:169; TH1::GetXaxisTAxis * GetXaxis()Definition TH1.h:324; TH1::Printvoid Print(Option_t *option="""") const overridePrint some global quantities for this histogram.Definition TH1.cxx:7009; TH1::GetMaximumvirtual Double_t GetMaximum(Double_t maxval=FLT_MAX) constReturn maximum value smaller than maxval of bins in the range, unless the value has been overridden b...Definition TH1.cxx:8545; TH1::SetMaximumvirtual void SetMaximum(Double_t maximum=-1111)Definition TH1.h:404; TH1::GetYaxisTAxis * GetYaxis()Definition TH1.h:325; TH1::SetMinimumvirtual void SetMinimum(Double_t minimum=-1111)Definition TH1.h:405; TH1::SetBinContentvirtual void SetBinContent(Int_t bin, Double_t content)Set bin content see convention for numbering bins in TH1::GetBin In case the bin number is greater th...Definition TH",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TF1_8cxx_source.html:193930,log,log,193930,doc/master/TF1_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html,1,['log'],['log']
Testability,"nputHandler &DataInput (); ; TH2 *GetCorrelationMatrix (const TString &className); returns the correlation matrix of datasets ; ; DataSetInfo &GetDataSetInfo (); ; const DataSetInfo &GetDefaultDataSetInfo (); ; virtual TClass *IsA () const; ; DataLoader *MakeCopy (TString name); Copy method use in VI and CV. ; ; voidMakeKFoldDataSet (CvSplit &s); Function required to split the training and testing datasets into a number of folds. ; ; voidPrepareFoldDataSet (CvSplit &s, UInt_t foldNumber, Types::ETreeType tt=Types::kTraining); Function for assigning the correct folds to the testing or training set. ; ; voidPrepareTrainingAndTestTree (const TCut &cut, const TString &splitOpt); prepare the training and test trees -> same cuts for signal and background ; ; voidPrepareTrainingAndTestTree (const TCut &cut, Int_t NsigTrain, Int_t NbkgTrain, Int_t NsigTest, Int_t NbkgTest, const TString &otherOpt=""SplitMode=Random:!V""); prepare the training and test trees ; ; voidPrepareTrainingAndTestTree (const TCut &cut, Int_t Ntrain, Int_t Ntest=-1); prepare the training and test trees kept for backward compatibility ; ; voidPrepareTrainingAndTestTree (TCut sigcut, TCut bkgcut, const TString &splitOpt); prepare the training and test trees ; ; voidRecombineKFoldDataSet (CvSplit &s, Types::ETreeType tt=Types::kTraining); Recombines the dataset. ; ; voidSetBackgroundTree (TTree *background, Double_t weight=1.0); ; voidSetBackgroundWeightExpression (const TString &variable); ; voidSetCut (const TCut &cut, const TString &className=""""); ; voidSetCut (const TString &cut, const TString &className=""""); ; voidSetInputTrees (const TString &signalFileName, const TString &backgroundFileName, Double_t signalWeight=1.0, Double_t backgroundWeight=1.0); ; voidSetInputTrees (TTree *inputTree, const TCut &SigCut, const TCut &BgCut); define the input trees for signal and background from single input tree, containing both signal and background events distinguis",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1DataLoader.html:4812,test,test,4812,doc/master/classTMVA_1_1DataLoader.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1DataLoader.html,4,['test'],['test']
Testability,"ns ""FlushBaskets"", TTree::FlushBaskets is called and all; 1451/// the current basket are closed-out and written to disk individually.; 1452///; 1453/// By default the previous header is deleted after having written the new header.; 1454/// if option contains ""Overwrite"", the previous Tree header is deleted; 1455/// before written the new header. This option is slightly faster, but; 1456/// the default option is safer in case of a problem (disk quota exceeded); 1457/// when writing the new header.; 1458///; 1459/// The function returns the number of bytes written to the file.; 1460/// if the number of bytes is null, an error has occurred while writing; 1461/// the header to the file.; 1462///; 1463/// ## How to write a Tree in one process and view it from another process; 1464///; 1465/// The following two scripts illustrate how to do this.; 1466/// The script treew.C is executed by process1, treer.C by process2; 1467///; 1468/// script treew.C:; 1469/// ~~~ {.cpp}; 1470/// void treew() {; 1471/// TFile f(""test.root"",""recreate"");; 1472/// TNtuple *ntuple = new TNtuple(""ntuple"",""Demo"",""px:py:pz:random:i"");; 1473/// Float_t px, py, pz;; 1474/// for ( Int_t i=0; i<10000000; i++) {; 1475/// gRandom->Rannor(px,py);; 1476/// pz = px*px + py*py;; 1477/// Float_t random = gRandom->Rndm(1);; 1478/// ntuple->Fill(px,py,pz,random,i);; 1479/// if (i%1000 == 1) ntuple->AutoSave(""SaveSelf"");; 1480/// }; 1481/// }; 1482/// ~~~; 1483/// script treer.C:; 1484/// ~~~ {.cpp}; 1485/// void treer() {; 1486/// TFile f(""test.root"");; 1487/// TTree *ntuple = (TTree*)f.Get(""ntuple"");; 1488/// TCanvas c1;; 1489/// Int_t first = 0;; 1490/// while(1) {; 1491/// if (first == 0) ntuple->Draw(""px>>hpx"", """","""",10000000,first);; 1492/// else ntuple->Draw(""px>>+hpx"","""","""",10000000,first);; 1493/// first = (Int_t)ntuple->GetEntries();; 1494/// c1.Update();; 1495/// gSystem->Sleep(1000); //sleep 1 second; 1496/// ntuple->Refresh();; 1497/// }; 1498/// }; 1499/// ~~~; 1500 ; 1501Long64_t TTree::AutoSave",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTree_8cxx_source.html:54740,test,test,54740,doc/master/TTree_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html,1,['test'],['test']
Testability,ns iterator to the end of the deltas (back-propagation); 593 ; 594 const_iterator_type deltasBegin () const { return begin (m_deltas); } ///< returns const iterator to the begin of the deltas (back-propagation); 595 const_iterator_type deltasEnd () const { return end (m_deltas); } ///< returns const iterator to the end of the deltas (back-propagation); 596 ; 597 iterator_type valueGradientsBegin () { return begin (m_valueGradients); } ///< returns iterator to the begin of the gradients of the node values; 598 iterator_type valueGradientsEnd () { return end (m_valueGradients); } ///< returns iterator to the end of the gradients of the node values; 599 ; 600 const_iterator_type valueGradientsBegin () const { return begin (m_valueGradients); } ///< returns const iterator to the begin of the gradients; 601 const_iterator_type valueGradientsEnd () const { return end (m_valueGradients); } ///< returns const iterator to the end of the gradients; 602 ; 603 iterator_type gradientsBegin () { assert (m_hasGradients); return m_itGradientBegin; } ///< returns iterator to the begin of the gradients; 604 const_iterator_type gradientsBegin () const { assert (m_hasGradients); return m_itGradientBegin; } ///< returns const iterator to the begin of the gradients; 605 const_iterator_type weightsBegin () const { assert (m_hasWeights); return m_itConstWeightBegin; } ///< returns const iterator to the begin of the weights for this layer; 606 ; 607 std::shared_ptr<std::function<double(double)>> activationFunction () const { return m_activationFunction; }; 608 std::shared_ptr<std::function<double(double)>> inverseActivationFunction () const { return m_inverseActivationFunction; }; 609 ; 610 /*! \brief set the drop-out info for this layer; 611 *; 612 */; 613 template <typename Iterator>; 614 void setDropOut (Iterator itDrop) { m_itDropOut = itDrop; m_hasDropOut = true; }; 615 ; 616 /*! \brief clear the drop-out-data for this layer; 617 *; 618 *; 619 */; 620 void clearDropOut () { m_hasDropOut,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/NeuralNet_8h_source.html:20231,assert,assert,20231,doc/master/NeuralNet_8h_source.html,https://root.cern,https://root.cern/doc/master/NeuralNet_8h_source.html,1,['assert'],['assert']
Testability,"ns of type C by CINT. WARNING! A function created with this constructor cannot be Cloned. TF1(const char* name, void* fcn, Double_t xmin, Double_t xmax, Int_t npar); F1 constructor using pointer to an interpreted function. See TFormula constructor for explanation of the formula syntax. Creates a function of type C between xmin and xmax.; The function is defined with npar parameters; fcn must be a function of type:; Double_t fcn(Double_t *x, Double_t *params). see tutorial; myfit for an example of use; also test/stress.cxx (see function stress1). This constructor is called for functions of type C by CINT. WARNING! A function created with this constructor cannot be Cloned. TF1(const char* name, ROOT::Math::ParamFunctor f, Double_t xmin = 0, Double_t xmax = 1, Int_t npar = 0); F1 constructor using a pointer to a real function. npar is the number of free parameters used by the function. This constructor creates a function of type C when invoked; with the normal C++ compiler. see test program test/stress.cxx (function stress1) for an example.; note the interface with an intermediate pointer. WARNING! A function created with this constructor cannot be Cloned. TF1(const char *name,Double_t (*fcn)(const Double_t *, const Double_t *), Double_t xmin, Double_t xmax, Int_t npar); F1 constructor using a pointer to real function. npar is the number of free parameters used by the function. This constructor creates a function of type C when invoked; with the normal C++ compiler. see test program test/stress.cxx (function stress1) for an example.; note the interface with an intermediate pointer. WARNING! A function created with this constructor cannot be Cloned. TF1(const char* name, ROOT::Math::ParamFunctor f, Double_t xmin = 0, Double_t xmax = 1, Int_t npar = 0); F1 constructor using the Functor class. xmin and xmax define the plotting range of the function; npar is the number of free parameters used by the function. This constructor can be used only in compiled code. WARNING! A f",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TF1.html:28272,test,test,28272,root/html528/TF1.html,https://root.cern,https://root.cern/root/html528/TF1.html,8,['test'],['test']
Testability,"ns to be used in conjuction with TExecutor::Map and TExecutor::MapReduce ; NCocoaTutorials; NDetail; NExecutorUtils; NExperimental; NDetail; NHist; NInternal; NFitNamespace for the fitting classes ; NFitUtilNamespace defining utility free functions using in Fit for evaluating the various fit method functions (chi2, likelihood, etc..) given the data and the model function ; NHFitInterface; NGLTutorials; NInternal; NExecutorUtils; NTThreadedObjectUtils; NMacOSX; NDetails; NOpenGL; NUtil; NX11; NDetail; NMath; NBlas; NBrentMethods; NCephes; NChebyshevTemplate recursive functions for defining evaluation of Chebyshev polynomials T_n(x) and the series S(x) = Sum_i c_i* T_i(x) ; NCholeskyDecompHelpersHelpers for CholeskyDecomp ; Ndetail; NGenAlgoOptUtil; NGenVector; NGenVector_detail; NGSLRootHelperHelper functions to test convergence of Root-Finding algorithms ; NGSLSimAn; Ngv_detail; NImpl; NIntegMultiDim; NIntegOneDim; NIntegOptionsUtil; NIntegration; NIntegrationMultiDim; NIntegrationOneDim; NInterpolation; NMCIntegration; NMinim; NMinim1D; NRootsRoot-Finding Algorithms ; NrowOffsetsUtils; NSampler; Ntest; NUtilNamespace defining Utility functions needed by mathcore ; NVectorUtilGlobal Helper functions for generic Vector classes ; NMathMore; NMeta; NSelection; NMinuit; NMinuit2; NQuartz; NTF1Helper; NTMetaUtils; NAST2SourceTools; NpropNames; NTreeUtils; NTThreadedObjectUtils; Nv5; NTFastFun; Nrootmarks; NROOTwriter; NSelectionRulesUtils; Nshapes; Nsqlio; Nstaff; NstdSTL namespace ; N__ROOT; Ndetail; Nsurfaces; NTClassEdit; Ntest; NTMath; NTMatrixTCramerInv; NTMatrixTSymCramerInv; NTMVAAbstract ClassifierFactory template that handles arbitrary types ; NDNN; NBlas; NkNN; NTMVAGlob; Ntornado; Ntree; NTStreamerInfoActions; Nvdt; Ndetails; Nwriter; Nxmlio; NXPD; NXrdCl; Nzdemo. ROOT 6.08/07 - Reference Guide Generated on Thu May 31 2018 21:48:30 using Doxygen 1.8.13. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v608/namespaces.html:2309,test,test,2309,doc/v608/namespaces.html,https://root.cern,https://root.cern/doc/v608/namespaces.html,1,['test'],['test']
Testability,"ns |; Private Attributes |; List of all members ; TMVA::LDA Class ReferenceTMVA. . Definition at line 44 of file LDA.h. Public Member Functions; LDA (Float_t tolerence=1.0e-5, Bool_t debug=false); constructor ; ; ~LDA (); destructor ; ; Float_tGetLogLikelihood (const std::vector< Float_t > &x, Int_t k); Log likelihood function with Gaussian approximation. ; ; Float_tGetProb (const std::vector< Float_t > &x, Int_t k); Signal probability with Gaussian approximation. ; ; voidInitialize (const LDAEvents &inputSignal, const LDAEvents &inputBackground); Create LDA matrix using local events found by knn method. ; . Private Member Functions; Float_tFSub (const std::vector< Float_t > &x, Int_t k); Probability value using Gaussian approximation. ; ; MsgLogger &Log () const; . Private Attributes; Bool_tfDebug; documentation! ; ; std::map< Int_t, Float_t >fEventFraction; documentation! ; ; MsgLogger *fLogger; ! message logging service ; ; std::map< Int_t, std::vector< Float_t > >fMu; documentation! ; ; UInt_tfNumParams; documentation! ; ; TMatrixF *fSigma; documentation! ; ; TMatrixF *fSigmaInverse; documentation! ; ; Float_tfTolerence; documentation! ; . #include <TMVA/LDA.h>; Constructor & Destructor Documentation. LDA(). TMVA::LDA::LDA ; (; Float_t; tolerence = 1.0e-5, . Bool_t; debug = false. ). constructor ; Definition at line 45 of file LDA.cxx. ~LDA(). TMVA::LDA::~LDA ; (; ). destructor ; Definition at line 58 of file LDA.cxx. Member Function Documentation. FSub(). Float_t TMVA::LDA::FSub ; (; const std::vector< Float_t > &; x, . Int_t; k. ). private . Probability value using Gaussian approximation. ; Definition at line 209 of file LDA.cxx. GetLogLikelihood(). Float_t TMVA::LDA::GetLogLikelihood ; (; const std::vector< Float_t > &; x, . Int_t; k. ). Log likelihood function with Gaussian approximation. ; Definition at line 250 of file LDA.cxx. GetProb(). Float_t TMVA::LDA::GetProb ; (; const std::vector< Float_",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1LDA.html:1137,log,logging,1137,doc/master/classTMVA_1_1LDA.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1LDA.html,1,['log'],['logging']
Testability,"ns(""e"");; 556 Bool_t logy = gPad ? gPad->GetLogy() : kFALSE;; 557 Double_t themin = std::numeric_limits<Double_t>::max();; 558 Int_t nhists = fHists->GetSize();; 559 ; 560 auto check_error = [logy, &themin](TH1 *h) {; 561 Int_t first = h->GetXaxis()->GetFirst();; 562 Int_t last = h->GetXaxis()->GetLast();; 563 for (Int_t j = first; j <= last; j++) {; 564 Double_t e1 = h->GetBinError(j);; 565 Double_t c1 = h->GetBinContent(j);; 566 if (!logy || (c1 - e1 > 0)); 567 themin = TMath::Min(themin, c1 - e1);; 568 }; 569 };; 570 ; 571 if (!opt.Contains(""nostack"")) {; 572 BuildStack();; 573 auto h = (TH1*)fStack->At(nhists-1);; 574 themin = h->GetMinimum(minval);; 575 if (themin <= 0 && logy); 576 themin = h->GetMinimum(0);; 577 if (lerr); 578 check_error(h);; 579 } else {; 580 for (Int_t i = 0; i < nhists; i++) {; 581 auto h = (TH1 *)fHists->At(i);; 582 Double_t them = h->GetMinimum(minval);; 583 if (them <= 0 && logy); 584 them = h->GetMinimum(0);; 585 if (them < themin); 586 themin = them;; 587 if (lerr); 588 check_error(h);; 589 }; 590 }; 591 ; 592 return themin;; 593}; 594 ; 595////////////////////////////////////////////////////////////////////////////////; 596/// Return the number of histograms in the stack; 597 ; 598Int_t THStack::GetNhists() const; 599{; 600 if (fHists) return fHists->GetSize();; 601 return 0;; 602}; 603 ; 604////////////////////////////////////////////////////////////////////////////////; 605/// Return pointer to Stack. Build it if not yet done.; 606 ; 607TObjArray *THStack::GetStack(); 608{; 609 BuildStack();; 610 return fStack;; 611}; 612 ; 613////////////////////////////////////////////////////////////////////////////////; 614/// Get the x-axis of the histogram used to draw the stack.; 615///; 616/// IMPORTANT NOTE; 617/// You must call Draw before calling this function. The returned histogram; 618/// depends on the selected Draw options.; 619 ; 620TAxis *THStack::GetXaxis() const; 621{; 622 TH1 *h = GetHistogram();; 623 return h ? h->GetXaxis() :",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/THStack_8cxx_source.html:19729,log,logy,19729,doc/master/THStack_8cxx_source.html,https://root.cern,https://root.cern/doc/master/THStack_8cxx_source.html,2,['log'],['logy']
Testability,"ns.CHistogram consumer script ; hprod.CHistogram producer script ; hserv.CServer program which waits for two clients to connect ; hserv2.CThis script shows how to make a simple iterative server that can accept connections while handling currently open connections ; hserv2bonj.CThis script shows how to make a simple iterative server that can accept connections while handling currently open connections ; LDAPExample.C; parallelMergeClient.CClient program which creates and fills 2 histograms and a TTree ; parallelMergeServer.CThis script shows how to make a simple iterative server that can accept connections while handling currently open connections ; parallelMergeTest.C; pclient.CClient program to test parallel sockets ; pserv.CServer program to test parallel sockets ; spy.CClient program which allows the snooping of objects from a spyserv process ; spyserv.CServer program which allows clients, ""spies"", to connect and snoop objects ; TestAuth.CMacro test authentication methods stand alone ; testTUDPSocket.CAs test echo server use udpserver.c in the same directory ; treeClient.CClient program which creates and fills 2 histograms and a TTree ; TUriTest.CRudimentary TUri test macro ; udpserver.c; physics; PhaseSpace.C Example of use of TGenPhaseSpace ; proof; EmptyInclude.hEmpty file to test TProof::Load in runProof.C and StressProof.cxx in conjunction with ProcFileElements and ProofEventProc ; finalizeProof.CMacro to finalize queries run with the macro tutorials/runProof ; getProof.CAttaches to a PROOF session, possibly at the indicated URL ; ProcFileElements.CClass to hold information about the processed elements of a file ; ProcFileElements.hClass to hold information about the processed elements of a file ; ProofAux.CSelector used for auxiliary actions in the PROOF tutorials ; ProofAux.hSelector used for auxiliary actions in the PROOF tutorials ; ProofEvent.CSelector for generic processing with Event ; ProofEvent.hSelector for generic p",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v608/files.html:135137,test,test,135137,doc/v608/files.html,https://root.cern,https://root.cern/doc/v608/files.html,10,['test'],"['test', 'testTUDPSocket']"
Testability,ns.cxx; TQpLinSolverSparse.cxx; TQpProbBase.cxx; TQpProbDens.cxx; TQpProbSparse.cxx; TQpResidual.cxx; TQpSolverBase.cxx; TQpVar.cxx; rtools; inc; Math; RMinimizer.h; src; RMinimizer.cxx; smatrix; inc; Math; BinaryOperators.h; BinaryOpPolicy.h; CholeskyDecomp.hHeader file containing the templated implementation of matrix inversion routines for use with ROOT's SMatrix classes (symmetric positive definite case) ; CramerInversion.icc; CramerInversionSym.icc; Dfact.h; Dfactir.h; Dfinv.h; Dinv.h; Dsfact.h; Dsinv.h; Expression.h; Functions.h; HelperOps.h; MatrixFunctions.h; MatrixInversion.icc; MatrixRepresentationsStatic.h; MConfig.h; SMatrix.h; SMatrix.icc; SMatrixDfwd.h; SMatrixFfwd.h; StaticCheck.h; SVector.h; SVector.icc; UnaryOperators.h; LinkDefAll.h; LinkDefD32.h; src; Dict.h; test; kalman.C; matrix_op.h; matrix_util.h; matrixOperations.C; stressKalman.cxx; stressOperations.cxx; testInversion.cxx; testIO.cxx; testKalman.cxx; testOperations.cxx; testSMatrix.cxx; TestTimer.h; Track.h; TrackLinkDef.h; splot; inc; TSPlot.h; src; TSPlot.cxx; unuran; inc; TUnuran.h; TUnuranBaseDist.h; TUnuranContDist.h; TUnuranDiscrDist.h; TUnuranEmpDist.h; TUnuranMultiContDist.h; TUnuranSampler.h; src; TUnuran.cxx; TUnuranContDist.cxx; TUnuranDiscrDist.cxx; TUnuranEmpDist.cxx; TUnuranMultiContDist.cxx; TUnuranSampler.cxx; UnuranDistr.h; UnuranDistrAdapter.h; UnuranRng.h; test; unuranDiscrete.cxx; unuranDistr.cxx; unuranHist.cxx; unuranMulti2D.cxx; unuranMultiDim.cxx; unuranSimple.cxx; misc; memstat; inc; TMemStat.h; TMemStatBacktrace.h; TMemStatDef.h; TMemStatHelpers.h; TMemStatHook.h; TMemStatMng.h; src; TMemStat.cxx; TMemStatBacktrace.cxx; TMemStatHelpers.cxx; TMemStatHook.cxx; TMemStatMng.cxx; test; leak_test.C; run.C; table; inc; tableDescriptor.h; TCernLib.h; TChair.h; TColumnView.h; TDataSet.h; TDataSetIter.h; TDsKey.h;,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v610/files.html:55897,test,testKalman,55897,doc/v610/files.html,https://root.cern,https://root.cern/doc/v610/files.html,1,['test'],['testKalman']
Testability,"ns; geometrical functions. For more details, see the reference documentation of TMath at <http://root.cern.ch/root/htmldoc/TMath.html>.; 13.3.1 Numerical Constants; TMath offers a wide range of constants in the form of inline functions. Notice that they are not defined as C/C++ preprocessor macros. This set of functions includes one or more definitions for the following constants:. Pi.; Base of natural logarithm.; Velocity of light.; Gravitational constant (G).; Standard acceleration of gravity (g).; Standard acceleration of Gravity.; Planks contant.; Boltzmanns and Steffan-Boltzmanns constants.; Avogadros number.; Universal gas constant.; Molecular weight of dry air.; Dry air gas constant.; Euler-Mascheroni Constant.; Elementary charge. 13.3.2 Elementary Functions; A set of miscellaneous elementary mathematical functions is provided along with a set of basic trigonometrical functions. Some of this functions refer to basic mathematical functions like the square root, the power to a number of the calculus of a logarithm, while others are used for number treatment, like rounding.; Although there are some functions that are not in the standard C math library (like Factorial), most of the functionality offered here is just a wrapper of the first ones. Nevertheless, some of the them also offer some security checks or a better precision, like the trigonometrical functions ASin(x), ACos(x) or ATan(x).; // Generate a vector with 10 random numbers; vector<double> v(10);; std::generate(v.begin(), v.end(), rand);. // Find the minimum value of the vector (iterator version); vector<double>::iterator it;; it = TMath::LocMin(v.begin(), v.end());; std::cout << *it << std::endl;. // The same with the old-style version; int i;; i = TMath::LocMin(10, &v[0]);; std::cout << v[i] << std::endl;; Another example of these functions can be found in $ROOTSYS/tutorials/permute.C.; 13.3.3 Statistic Functions Operating on Arrays.; This set of functions processes arrays to calculate:. Mean.; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:662272,log,logarithm,662272,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['log'],['logarithm']
Testability,"ns; static Double_tGetSigmaN (const std::vector< size_t > &ns, size_t N); Computation of sigma_N as described in (1) ; ; static Double_tInterpolatePValues (int nsamples, Double_t A2); Linear interpolation used in GoFTest::PValueAD2Samples. ; . Private Attributes; std::unique_ptr< IGenFunction >fCDF; Pointer to CDF used in 1-sample test. ; ; std::vector< Double_t >fCombinedSamples; The combined data. ; ; EDistributionfDist; Type of distribution. ; ; std::vector< Double_t >fParams; The distribution parameters (e.g. fParams[0] = mean, fParams[1] = sigma for a Gaussian) ; ; std::vector< std::vector< Double_t > >fSamples; The input data. ; ; Bool_tfTestSampleFromH0; . #include <Math/GoFTest.h>; Member Enumeration Documentation. EDistribution. enum ROOT::Math::GoFTest::EDistribution. H0 distributions for using only with 1-sample tests. ; One should provide the distribution parameters otherwise the default values will be used . EnumeratorkUndefined; kUserDefinedDefault value for non templated 1-sample test. Set with SetDistribution. . kGaussianFor internal use only within the class's template constructor. . kLogNormalGaussian distribution with default mean=0, sigma=1. . kExponentialLognormal distribution with default meanlog=0, sigmalog=1. ; Exponential distribution with default rate=1 . Definition at line 70 of file GoFTest.h. ETestType. enum ROOT::Math::GoFTest::ETestType. Goodness of Fit test types for using with the class's unary functions as a shorthand for the in-built methods. . EnumeratorkAD; kAD2sAnderson-Darling Test. Default value. . kKSAnderson-Darling 2-Samples Test. . kKS2sKolmogorov-Smirnov Test. ; Kolmogorov-Smirnov 2-Samples Test . Definition at line 85 of file GoFTest.h. EUserDistribution. enum ROOT::Math::GoFTest::EUserDistribution. User input distribution option. . EnumeratorkCDF; kPDFInput distribution is a CDF : cumulative distribution function. ; Input distribution is a PDF (Default value) . Definition at line 7",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1GoFTest.html:8197,test,test,8197,doc/master/classROOT_1_1Math_1_1GoFTest.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1GoFTest.html,1,['test'],['test']
Testability,"nsform?; Bool_tfIsScaleForRnr! cache; const TGLLogicalShape*fLogicalShape! the associated logical shape; TGLPhysicalShape::EManipfManip! permitted manipulation bitflags - see EManip; Bool_tfModified! has been modified - retain across scene rebuilds; TGLPhysicalShape*fNextPhysical! pointer to next replica; UChar_tfSelected! selected state; TGLMatrixfTransform! transform (placement) of physical instance. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGLPhysicalShape(UInt_t ID, const TGLLogicalShape& logicalShape, const TGLMatrix& transform, Bool_t invertedWind, const Float_t[4] rgba); Construct a physical shape using arguments:; ID - unique drawable id.; logicalShape - bound logical shape; transform - transform for placement of logical drawing; invertedWind - use inverted face polygon winding?; rgba - basic four component (RGBA) diffuse color. TGLPhysicalShape(UInt_t ID, const TGLLogicalShape& logicalShape, const double* transform, Bool_t invertedWind, const Float_t[4] rgba); Construct a physical shape using arguments:; id - unique drawable id.; logicalShape - bound logical shape; transform - 16 Double_t component transform for placement of logical drawing; invertedWind - use inverted face polygon winding?; rgba - basic four component (RGBA) diffuse color. ~TGLPhysicalShape(); Destroy the physical shape. void AddReference(TGLPShapeRef* ref); Add reference ref. void RemoveReference(TGLPShapeRef* ref); Remove reference ref. void Modified(); Call this after modifying the physical so that the information; can be propagated to the object referencing it. void UpdateBoundingBox(); Update our internal bounding box (in global frame). void InitColor(const Float_t[4] rgba); Initialise the colors, using basic RGBA diffuse material color supplied. void SetColor(const Float_t[17] rgba); Set full color attributes - see OpenGL material documentation; for full description.; 0->3 diffuse, 4->7 ambient, 8->11 specular, 12->15 emission, 16 shin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGLPhysicalShape.html:5305,log,logicalShape,5305,root/html602/TGLPhysicalShape.html,https://root.cern,https://root.cern/root/html602/TGLPhysicalShape.html,2,['log'],['logicalShape']
Testability,"nsp); virtual Double_tSize() const; virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); voidUseAdaptiveSampling(bool flag = true). private:. voidCreateParameterPoints() const; voidCreateTestStatSampler() const. Data Members; private:. Bool_tfAdaptiveSamplingcontrols use of adaptive sampling algorithm; Double_tfAdditionalNToysFactorgive user ability to ask for more toys; RooStats::ConfidenceBelt*fConfBelt; Bool_tfCreateBeltcontrols use if ConfidenceBelt should be saved to a TFile; RooAbsData&fDatadata set ; Bool_tfDoProfileConstructioninstead of full construction over nuisance parametrs, do profile; Bool_tfFluctuateDatatell ToyMCSampler to fluctuate number of entries in dataset; RooStats::ModelConfig&fModel; Int_tfNbinsnumber of samples per variable; RooAbsData*fPointsToTestpoints to perform the construction; Bool_tfSaveBeltToFilecontrols use if ConfidenceBelt should be saved to a TFile; Double_tfSizesize of the test (eg. specified rate of Type I error); RooStats::ToyMCSampler*fTestStatSamplerthe test statistic sampler. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; FeldmanCousins(RooAbsData& data, RooStats::ModelConfig& model); standard constructor. ~FeldmanCousins(); destructor; if(fOwnsWorkspace && fWS) delete fWS;. void SetModel(const RooStats::ModelConfig& ); set the model. TestStatSampler* GetTestStatSampler() const. void CreateTestStatSampler() const; specify the Test Statistic and create a ToyMC test statistic sampler. void CreateParameterPoints() const; specify the parameter points to perform the construction.; allow ability to profile on some nuisance paramters. PointSetInterval* GetInterval() const; Main interface to get a RooStats::ConfInterval.; It constructs a RooStats::PointSetInterval. FeldmanCousins(RooAbsData& data, RooStats::ModelConfig& model); FeldmanCousins();; Common constructor. Double_t Size() const; Get the size of the test (eg. rate of Type I error). {return fSize;}. Double_t Confi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooStats__FeldmanCousins.html:3797,test,test,3797,root/html528/RooStats__FeldmanCousins.html,https://root.cern,https://root.cern/root/html528/RooStats__FeldmanCousins.html,1,['test'],['test']
Testability,"nst &logs_dir); HeatmapAnalyzer Constructor. ; ; ~HeatmapAnalyzer (); ; std::unique_ptr< TH2I >analyze (int analyzed_gradient); This method is the main functionality in this class. ; ; std::vector< std::string > constgetMetadata (); ; std::vector< std::string > constgetPartitionNames (); ; std::vector< std::string > constgetTaskNames (); . Private Attributes; std::vector< std::string >eval_partitions_names_; ; std::unique_ptr< Detail::HeatmapAnalyzerJsonData >jsonData_; ; TH2Imatrix_; ; std::vector< std::string >tasks_names_; . #include <RooFit/MultiProcess/HeatmapAnalyzer.h>; Constructor & Destructor Documentation. HeatmapAnalyzer(). RooFit::MultiProcess::HeatmapAnalyzer::HeatmapAnalyzer ; (; std::string const &; logs_dir). HeatmapAnalyzer Constructor. ; This method reads the input files in the folder specified by the user and creates internal attributes used by the other methods in this class. Parameters. [in]logs_dirDirectory where log files are stored in the format outputted by RooFit::MultiProcess::ProcessTimer. There can be other files in this directory as well. . Definition at line 95 of file HeatmapAnalyzer.cxx. ~HeatmapAnalyzer(). RooFit::MultiProcess::HeatmapAnalyzer::~HeatmapAnalyzer ; (; ). default . Member Function Documentation. analyze(). std::unique_ptr< TH2I > RooFit::MultiProcess::HeatmapAnalyzer::analyze ; (; int; analyzed_gradient). This method is the main functionality in this class. ; It does the heavy lifting of matching duration timestamps to tasks and partition evaluations. Parameters. [in]analyzed_gradientGradient to analyze. For example, setting to 1 analyzes the first gradient (ordered by time) in the logs. . Definition at line 144 of file HeatmapAnalyzer.cxx. getMetadata(). std::vector< std::string > const RooFit::MultiProcess::HeatmapAnalyzer::getMetadata ; (; ). Definition at line 226 of file HeatmapAnalyzer.cxx. getPartitionNames(). std::vector< std::string > const RooFit::MultiProcess::HeatmapAnalyzer",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooFit_1_1MultiProcess_1_1HeatmapAnalyzer.html:2216,log,log,2216,doc/master/classRooFit_1_1MultiProcess_1_1HeatmapAnalyzer.html,https://root.cern,https://root.cern/doc/master/classRooFit_1_1MultiProcess_1_1HeatmapAnalyzer.html,1,['log'],['log']
Testability,"nst RooArgSet& nset); Int_tRooAbsPdf::minDimNormValueCaching() const; virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tRooAbsPdf::mustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); const char*RooAbsPdf::normRange() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TNamed&TNamed::operator=(const TNamed& rhs); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsPdf::paramOn(RooPlot* frame, const RooAbsData* data, const char* label = """", Int_t sigDigits = 2, Option_t* options = ""NELU"", Double_t xmin = 0.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/Roo2DKeysPdf.html:21786,test,testArg,21786,root/html528/Roo2DKeysPdf.html,https://root.cern,https://root.cern/root/html528/Roo2DKeysPdf.html,68,['test'],['testArg']
Testability,"nst RooArgSet& set); virtual voidRooStats::HypoTestCalculator::SetCommonModel(const RooStats::ModelConfig& model); virtual voidSetConfidenceLevel(Double_t cl); virtual voidSetData(RooAbsData& data); virtual voidSetModel(const RooStats::ModelConfig& model); virtual voidSetNuisanceParameters(const RooArgSet& set); virtual voidSetNullModel(const RooStats::ModelConfig&); virtual voidSetNullParameters(const RooArgSet& set); virtual voidSetParameters(const RooArgSet& set); virtual voidSetPdf(RooAbsPdf& pdf); virtual voidSetTestSize(Double_t size); virtual voidShowMembers(TMemberInspector& insp, char* parent); virtual Double_tSize() const; virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). protected:. RooAbsData*GetData() const; RooAbsPdf*GetPdf() const. Data Members; protected:. RooArgSetfAlternateParamsRooArgSet specifying alternate parameters for hypothesis test // Is it used ????; RooAbsData*fData; RooArgSetfNuisParamsRooArgSet specifying nuisance parameters for interval; RooArgSetfNullParamsRooArgSet specifying null parameters for hypothesis test; RooArgSetfPOIRooArgSet specifying parameters of interest for interval; RooAbsPdf*fPdf; Double_tfSizesize of the test (eg. specified rate of Type I error). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SetTestSize(Double_t size). SetModel(const RooStats::ModelConfig& model). virtual ~CombinedCalculator(); destructor. { }. ConfInterval* GetInterval() const; Main interface to get a ConfInterval, pure virtual. HypoTestResult* GetHypoTest() const; main interface to get a HypoTestResult, pure virtual. void SetConfidenceLevel(Double_t cl); set the confidence level for the interval (eg. 0.95 for a 95% Confidence Interval). {fSize = 1.-cl;}. Double_t Size() const; Get the size of the test (eg. rate of Type I error). {return fSize;}. Double_t ConfidenceLevel() const; Get the Confidence level for the test. {return 1.-fSize;}. void SetData(RooAbsData& data); Set the DataSet, ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooStats__CombinedCalculator.html:3233,test,test,3233,root/html526/RooStats__CombinedCalculator.html,https://root.cern,https://root.cern/root/html526/RooStats__CombinedCalculator.html,3,['test'],['test']
Testability,"nst RooArgSet&) const; virtual RooAbsGenContext*RooResolutionModel::modelGenContext(const RooAbsAnaConvPdf&, const RooArgSet&, const RooDataSet*, const RooArgSet*, Bool_t) const; RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tRooAbsPdf::mustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; virtual voidRooResolutionModel::normLeafServerList(RooArgSet& list) const; const char*RooAbsPdf::normRange() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TNamed&TNamed::operator=(const TNamed& rhs); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& te",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAddModel.html:23925,test,testArg,23925,root/html534/RooAddModel.html,https://root.cern,https://root.cern/root/html534/RooAddModel.html,3,['test'],['testArg']
Testability,"nst RooArgSet&) const; virtual RooAbsGenContext*RooResolutionModel::modelGenContext(const RooAbsAnaConvPdf&, const RooArgSet&, const RooDataSet*, const RooArgSet*, Bool_t) const; RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tRooAbsPdf::mustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; virtual voidRooResolutionModel::normLeafServerList(RooArgSet& list) const; const char*RooAbsPdf::normRange() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooAddModel&operator=(const RooAddModel&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFAL",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooAddModel.html:23711,test,testArg,23711,root/html602/RooAddModel.html,https://root.cern,https://root.cern/root/html602/RooAddModel.html,2,['test'],['testArg']
Testability,"nst RooArgSet&) const; virtual RooAbsGenContext*RooResolutionModel::modelGenContext(const RooAbsAnaConvPdf&, const RooArgSet&, const RooDataSet*, const RooArgSet*, Bool_t) const; RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tRooAbsPdf::mustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; virtual voidRooResolutionModel::normLeafServerList(RooArgSet& list) const; const char*RooAbsPdf::normRange() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooGExpModel&operator=(const RooGExpModel&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kF",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooGExpModel.html:23125,test,testArg,23125,root/html602/RooGExpModel.html,https://root.cern,https://root.cern/root/html602/RooGExpModel.html,2,['test'],['testArg']
Testability,"nst RooArgSet&) const; virtual RooAbsGenContext*RooResolutionModel::modelGenContext(const RooAbsAnaConvPdf&, const RooArgSet&, const RooDataSet*, const RooArgSet*, Bool_t) const; RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tRooAbsPdf::mustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; virtual voidRooResolutionModel::normLeafServerList(RooArgSet& list) const; const char*RooAbsPdf::normRange() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooGaussModel&operator=(const RooGaussModel&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooGaussModel.html:23053,test,testArg,23053,root/html602/RooGaussModel.html,https://root.cern,https://root.cern/root/html602/RooGaussModel.html,2,['test'],['testArg']
Testability,"nst RooArgSet* projDeps, const char* rangeName, const char* addCoefRangeName); Initialize simultaneous p.d.f processing mode. Strip simultaneous; p.d.f into individual components, split dataset in subset; matching each component and create component test statistics for; each of them. Bool_t setData(RooAbsData& data, Bool_t cloneData = kTRUE); Change dataset that is used to given one. If cloneData is kTRUE, a clone of; in the input dataset is made. If the test statistic was constructed with; a range specification on the data, the cloneData argument is ignore and; the data is always cloned. RooAbsTestStatistic* create(const char* name, const char* title, RooAbsReal& real, RooAbsData& data, const RooArgSet& projDeps, const char* rangeName = 0, const char* addCoefRangeName = 0, Int_t nCPU = 1, Bool_t interleave = kFALSE, Bool_t verbose = kTRUE, Bool_t splitCutRange = kFALSE). Double_t combinedValue(RooAbsReal** gofArray, Int_t nVal) const. Double_t globalNormalization() const; Default value of global normalization factor is 1.0. Double_t evaluatePartition(Int_t firstEvent, Int_t lastEvent, Int_t stepSize) const. void setSimCount(Int_t simCount); Store total number of components p.d.f. of a RooSimultaneous in this component test statistic. void setEventCount(Int_t nEvents); Store total number of events in this component test statistic. Int_t numSets() const; Return total number of sets for parallel calculation. Int_t setNum() const; Return parallel calculation set number for this instance. GOFOpMode operMode() const; Return test statistic operation mode of this instance (SimMaster, MPMaster or Slave). Bool_t setDataSlave(RooAbsData& , Bool_t = kTRUE, Bool_t = kFALSE); { return kTRUE ; }. Bool_t processEmptyDataSets() const; { return kTRUE ; }.  Last changed: Fri Dec 2 14:26:39 2011  Last generated: 2011-12-02 14:26; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooAbsTestStatistic.html:39658,test,test,39658,root/html532/RooAbsTestStatistic.html,https://root.cern,https://root.cern/root/html532/RooAbsTestStatistic.html,3,['test'],['test']
Testability,"nst TFormula*GetFormula() const; virtual TH1*GetHistogram() const; virtual const char*TObject::GetIconName() const; virtual const TObject*GetLinearPart(Int_t i) const; virtual Color_tTAttLine::GetLineColor() const; virtual Style_tTAttLine::GetLineStyle() const; virtual Width_tTAttLine::GetLineWidth() const; virtual Color_tTAttMarker::GetMarkerColor() const; virtual Size_tTAttMarker::GetMarkerSize() const; virtual Style_tTAttMarker::GetMarkerStyle() const; virtual Double_tGetMaximum(Double_t xmin = 0, Double_t xmax = 0, Double_t epsilon = 1.0E-10, Int_t maxiter = 100, Bool_t logx = false) const; virtual Double_tGetMaximumStored() const; virtual Double_tGetMaximumX(Double_t xmin = 0, Double_t xmax = 0, Double_t epsilon = 1.0E-10, Int_t maxiter = 100, Bool_t logx = false) const; TMethodCall*GetMethodCall() const; virtual Double_tGetMinimum(Double_t xmin = 0, Double_t xmax = 0, Double_t epsilon = 1.0E-10, Int_t maxiter = 100, Bool_t logx = false) const; virtual Double_tGetMinimumStored() const; virtual Double_tGetMinimumX(Double_t xmin = 0, Double_t xmax = 0, Double_t epsilon = 1.0E-10, Int_t maxiter = 100, Bool_t logx = false) const; virtual const char*TNamed::GetName() const; virtual Int_tGetNDF() const; virtual Int_tGetNdim() const; virtual Int_tGetNpar() const; virtual Int_tGetNpx() const; virtual Int_tGetNumber() const; virtual Int_tGetNumberFitPoints() const; virtual Int_tGetNumberFreeParameters() const; virtual char*GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual Double_tGetParameter(Int_t ipar) const; virtual Double_tGetParameter(const TString& name) const; virtual Double_t*GetParameters() const; virtual voidGetParameters(Double_t* params); TObject*GetParent() const; virtual Double_tGetParError(Int_t ipar) const; virtual const Double_t*GetParErrors() const; virtual voidGetParLimits(Int_t ipar, Double_t& parmin, Double_t& parmax) const; virtual const char*GetParName(Int_t ipar) co",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TF1.html:9199,log,logx,9199,root/html604/TF1.html,https://root.cern,https://root.cern/root/html604/TF1.html,1,['log'],['logx']
Testability,"nst TString& theOpt, TList& loo) const. Data Members; public:. static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. private:. TStringfConfigDescriptiondescription of this configurable; TStringfConfigNamethe name of this configurable; TMVA::OptionBase*fLastDeclaredOption! last declared option; TListfListOfOptions! option list; TMVA::MsgLogger*fLogger! message logger; Bool_tfLooseOptionCheckingEnabled! checker for option string; TStringfOptions! options string; TStringfReferenceFilereference file for options writing. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Configurable(const TString& theOption = """"); constructor. ~Configurable(); default destructur. void SplitOptions(const TString& theOpt, TList& loo) const; splits the option string at ':' and fills the list 'loo' with the primitive strings. void ResetSetFlag(); resets the IsSet falg for all declare options; to be called before options are read from stream. void ParseOptions(); options parser. void CheckForUnusedOptions() const; checks for unused options in option string. void PrintOptions() const; prints out the options set in the options string and the defaults. void WriteOptionsToStream(ostream& o, const TString& prefix) const; write options to output stream (e.g. in writing the MVA weight files. void",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TMVA__Configurable.html:6739,log,logger,6739,root/html602/TMVA__Configurable.html,https://root.cern,https://root.cern/root/html602/TMVA__Configurable.html,2,['log'],['logger']
Testability,"nst TTable*fRefTable; Long_tTTable::fSizeSize of the one element (row) of the table; Char_t*TTable::fTableArray of (fN*fSize) longs; TStringTNamed::fTitleobject title; static TTableDescriptor*fgColDescriptors; static TDataSet*TDataSet::fgMainSetpointer the main dataset;. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void Dictionary(); to be documented. TIndexTable(const TTable* table); to be documented. TTableDescriptor * CreateDescriptor(); to be documented. TTableDescriptor * GetDescriptorPointer() const; return column descriptor. void SetDescriptorPointer(TTableDescriptor* list); set table descriptor. const TTable * Table() const; to be documented. int * GetTable(Int_t i = 0). { return ((int *)GetArray())+i;}. const int * GetTable(Int_t i = 0) const. { return ((int *)GetArray())+i;}. Bool_t IsValid() const. void push_back(Long_t next). { AddAt(&next); }. TIndexTable(const TTable* table). TIndexTable(const TIndexTable& indx); {}. iterator begin(); { return ((const TIndexTable *)this)->begin();}. iterator begin() const; { return GetNRows() ? iterator(*Table(),*GetTable(0)):end();}. iterator end(); { return ((const TIndexTable *)this)->end(); }. iterator end() const; {Long_t i = GetNRows(); return i? iterator(*Table(), *GetTable(i)):iterator(*this);}. TIndexTable(); {SetType(""int"");}. TIndexTable(const char* name); {SetType(""int"");}. TIndexTable(Int_t n); {SetType(""int"");}. virtual ~TIndexTable(); {}. int & operator[](Int_t i); { assert(i>=0 && i < GetNRows()); return *GetTable(i); }. const int & operator[](Int_t i) const; { assert(i>=0 && i < GetNRows()); return *((const int *)(GetTable(i))); }.  Author: Valery Fine(fine@bnl.gov) 01/03/2001  Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *;  Last changed: root/table:$Id$  Last generated: 2015-03-14 16:42; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TIndexTable.html:16430,assert,assert,16430,root/html534/TIndexTable.html,https://root.cern,https://root.cern/root/html534/TIndexTable.html,2,['assert'],['assert']
Testability,"nst TTableDescriptor& dsc); {}. virtual ~TTableDescriptor(). Int_t AddAt(const void* c). void AddAt(const void* c, Int_t i). void AddAt(const tableDescriptor_st& element, const char* comment, Int_t indx). void AddAt(TDataSet* dataset, Int_t idx = 0). TString CreateLeafList() const. void LearnTable(const TTable* parentTable). void LearnTable(TClass* classPtr). Int_t ColumnByName(const Char_t* columnName = 0) const. UInt_t Offset(Int_t column) const. UInt_t ColumnSize(Int_t column) const. UInt_t TypeSize(Int_t column) const. UInt_t Dimensions(Int_t column) const. Int_t Sizeof() const. Int_t UpdateOffsets(const TTableDescriptor* newDesciptor). TTableDescriptor * MakeDescriptor(const char* structName). TDataSet * MakeCommentField(Bool_t createFlag = kTRUE). TTableDescriptor * GetDescriptorPointer() const. void SetDescriptorPointer(TTableDescriptor* list). TTableDescriptor(); {SetType(""tableDescriptor_st"");}. TTableDescriptor(const char* name); {SetType(""tableDescriptor_st"");}. TTableDescriptor(Int_t n); {SetType(""tableDescriptor_st"");}. TTableDescriptor(const char* name, Int_t n); {SetType(""tableDescriptor_st"");}. tableDescriptor_st * GetTable(Int_t i = 0) const; { return ((tableDescriptor_st *)GetArray())+i;}. tableDescriptor_st & operator[](Int_t i); { assert(i>=0 && i < GetNRows()); return *GetTable(i); }. const tableDescriptor_st & operator[](Int_t i) const; { assert(i>=0 && i < GetNRows()); return *((const tableDescriptor_st *)(GetTable(i))); }. tableDescriptor_st * begin() const; { return GetNRows()? GetTable(0):0;}. tableDescriptor_st * end() const; {Long_t i = GetNRows(); return i? GetTable(i):0;}. const char * TableDictionary().  Author: Valery Fine 09/08/99 (E-mail: fine@bnl.gov)  Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *;  Last changed: root/table:$Id$  Last generated: 2015-09-08 17:05; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TTableDescriptor.html:18530,assert,assert,18530,root/html534/TTableDescriptor.html,https://root.cern,https://root.cern/root/html534/TTableDescriptor.html,2,['assert'],['assert']
Testability,"nst TTree* T, const char* majorname, const char* minorname); Build the index for the tree (see TTree::BuildIndex). TTree * CopyTree(const char* selection, Option_t* option, Long64_t nentries, Long64_t firstentry); copy a Tree with selection; make a clone of this Tree header.; then copy the selected entries. selection is a standard selection expression (see TTreePlayer::Draw); option is reserved for possible future use; nentries is the number of entries to process (default is all); first is the first entry to process (default is 0). IMPORTANT: The copied tree stays connected with this tree until this tree; is deleted. In particular, any changes in branch addresses; in this tree are forwarded to the clone trees. Any changes; made to the branch addresses of the copied trees are over-ridden; anytime this tree changes its branch addresses.; Once this tree is deleted, all the addresses of the copied tree; are reset to their default values. The following example illustrates how to copy some events from the Tree; generated in $ROOTSYS/test/Event. gSystem->Load(""libEvent"");; TFile f(""Event.root"");; TTree *T = (TTree*)f.Get(""T"");; Event *event = new Event();; T->SetBranchAddress(""event"",&event);; TFile f2(""Event2.root"",""recreate"");; TTree *T2 = T->CopyTree(""fNtrack<595"");; T2->Write();. void DeleteSelectorFromFile(); Delete any selector created by this object.; The selector has been created using TSelector::GetSelector(file). Long64_t DrawScript(const char* wrapperPrefix, const char* macrofilename, const char* cutfilename, Option_t* option, Long64_t nentries, Long64_t firstentry); Draw the result of a C++ script. The macrofilename and optionally cutfilename are assumed to contain; at least a method with the same name as the file. The method; should return a value that can be automatically cast to; respectively a double and a boolean. Both methods will be executed in a context such that the; branch names can be used as C++ variables. This is; accomplished by generating a TTreeP",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TTreePlayer.html:17177,test,test,17177,root/html528/TTreePlayer.html,https://root.cern,https://root.cern/root/html528/TTreePlayer.html,6,['test'],['test']
Testability,"nst bp, Int_t nb, Int_t ncolsb, Element *cp)Elementary routine to calculate matrix multiplication A^T*B.Definition TMatrixT.cxx:3104; TMatrixTAutoloadOps::operator>=TMatrixT< Element > operator>=(const TMatrixT< Element > &source1, const TMatrixT< Element > &source2)logical operation source1 >= source2Definition TMatrixT.cxx:2649; TMatrixTAutoloadOps::ElementMultTMatrixT< Element > & ElementMult(TMatrixT< Element > &target, const TMatrixT< Element > &source)Multiply target by the source, element-by-element.Definition TMatrixT.cxx:2985; TMatrixTAutoloadOps::operator||TMatrixT< Element > operator||(const TMatrixT< Element > &source1, const TMatrixT< Element > &source2)Logical OR.Definition TMatrixT.cxx:2525; TMatrixTAutoloadOps::operator<TMatrixT< Element > operator<(const TMatrixT< Element > &source1, const TMatrixT< Element > &source2)logical operation source1 < source2Definition TMatrixT.cxx:2779; TMatrixTAutoloadOps::operator>TMatrixT< Element > operator>(const TMatrixT< Element > &source1, const TMatrixT< Element > &source2)logical operation source1 > source2Definition TMatrixT.cxx:2584; TMatrixTAutoloadOps::AddTMatrixT< Element > & Add(TMatrixT< Element > &target, Element scalar, const TMatrixT< Element > &source)Modify addition: target += scalar * source.Definition TMatrixT.cxx:2936; TMatrixTAutoloadOps::ElementDivTMatrixT< Element > & ElementDiv(TMatrixT< Element > &target, const TMatrixT< Element > &source)Divide target by the source, element-by-element.Definition TMatrixT.cxx:3025; TMatrixTAutoloadOps::MultElement1 Mult(const TVectorT< Element1 > &v1, const TMatrixT< Element2 > &m, const TVectorT< Element3 > &v2)Perform v1 * M * v2, a scalar result.Definition TVectorT.cxx:1542; TMatrixTAutoloadOps::operator-TMatrixT< Element > operator-(const TMatrixT< Element > &source1, const TMatrixT< Element > &source2)operation this = source1-source2Definition TMatrixT.cxx:2354; TMatrixTAutoloadOps::operator<=TMatrixT< Element > operator<=(const TMatrixT< Element > &sou",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMatrixT_8cxx_source.html:140478,log,logical,140478,doc/master/TMatrixT_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TMatrixT_8cxx_source.html,1,['log'],['logical']
Testability,"nst char *entry="""", Bool_t system=kFALSE); Load a shared library. ; ; virtual UInt_tLoadAllLibraries (); Load all libraries known to ROOT via the rootmap system. ; ; virtual intMakeDirectory (const char *name); Make a directory. ; ; virtual intmkdir (const char *name, Bool_t recursive=kFALSE); Make a file system directory. ; ; virtual Long_tNextTimeOut (Bool_t mode); Time when next timer of mode (synchronous=kTRUE or asynchronous=kFALSE) will time-out (in ms). ; ; virtual voidNotifyApplicationCreated (); Hook to tell TSystem that the TApplication object has been created. ; ; virtual TTimeNow (); Get current time in milliseconds since 0:00 Jan 1 1995. ; ; virtual intOpenConnection (const char *server, int port, int tcpwindowsize=-1, const char *protocol=""tcp""); Open a connection to another host. ; ; virtual void *OpenDirectory (const char *name); Open a directory. Returns 0 if directory does not exist. ; ; virtual voidOpenlog (const char *name, Int_t options, ELogFacility facility); Open connection to system log daemon. ; ; virtual FILE *OpenPipe (const char *command, const char *mode); Open a pipe. ; ; virtual const char *PrependPathName (const char *dir, TString &name); Concatenate a directory and a file name. ; ; virtual Bool_tProcessEvents (); Process pending events (GUI, timers, sockets). ; ; const char *pwd (); ; virtual intRecvBuf (int sock, void *buffer, int length); Receive a buffer headed by a length indicator. ; ; virtual intRecvRaw (int sock, void *buffer, int length, int flag); Receive exactly length bytes into buffer. ; ; virtual Int_tRedirectOutput (const char *name, const char *mode=""a"", RedirectHandle_t *h=nullptr); Redirect standard output (stdout, stderr) to the specified file. ; ; virtual TFileHandler *RemoveFileHandler (TFileHandler *fh); Remove a file handler from the list of file handlers. ; ; voidRemoveOnExit (TObject *obj); Objects that should be deleted on exit of the OS interface. ; ; vi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSystem.html:14158,log,log,14158,doc/master/classTSystem.html,https://root.cern,https://root.cern/doc/master/classTSystem.html,1,['log'],['log']
Testability,"nst char* message, const char* serverValueString = 0); const RooArgList&lowList() const; virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooAbsMoment*RooAbsReal::mean(RooRealVar& obs); RooAbsMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TNamed&TNamed::operator=(const TNamed& rhs); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, Roo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/PiecewiseInterpolation.html:18670,test,testArg,18670,root/html534/PiecewiseInterpolation.html,https://root.cern,https://root.cern/root/html534/PiecewiseInterpolation.html,1,['test'],['testArg']
Testability,"nst char* message, const char* serverValueString = 0); const RooArgList&lowList() const; virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooAbsMoment*RooAbsReal::mean(RooRealVar& obs); RooAbsMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); PiecewiseInterpolation&operator=(const PiecewiseInterpolation&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/PiecewiseInterpolation.html:18356,test,testArg,18356,root/html602/PiecewiseInterpolation.html,https://root.cern,https://root.cern/root/html602/PiecewiseInterpolation.html,2,['test'],['testArg']
Testability,"nst char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual voidTNamed::Copy(TObject& named) const; static voidRooAbsArg::copyList(TList& dest, const TList& source); static UInt_tRooAbsArg::crc32(const char* data); virtual RooAbsArg*RooAbsCategory::createFundamental(const char* newname = 0) const; Roo1DTable*RooAbsCategory::createTable(const char* label) const; virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; Bool_tdefineType(const char* label); Bool_tdefineType(const char* label, Int_t index); virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTO",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooCategory.html:3162,test,testArg,3162,root/html526/RooCategory.html,https://root.cern,https://root.cern/root/html526/RooCategory.html,3,['test'],['testArg']
Testability,"nst method, map<TString,TMVA::Interval> tuneParameters, TString fomType = ""Separation"", TString optimizationType = ""GA""); virtual voidTMVA::IFitterTarget::ProgressNotifier(TString, TString); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). private:. virtual Double_tEstimatorFunction(vector<Double_t>&); Double_tGetFOM(); TMVA::MethodBase*GetMethod(); voidGetMVADists(); Double_tGetROCIntegral(); Double_tGetSeparation(); Double_tGetSigEffAt(Double_t bkgEff = 0.1); TMVA::MsgLogger&Log() const; voidoptimizeFit(); voidoptimizeScan(). Data Members; private:. map<std::vector<Double_t>,Double_t>fAlreadyTrainedParCombinationsave parameters for which the FOM is already known (GA seems to evaluate the same parameters several times); TStringfFOMTypethe FOM type (Separation, ROC integra.. whaeter you implemented..; vector<Float_t>fFOMvsItergraph showing the develompment of the Figure Of Merit values during the fit; TMVA::MsgLogger*fLoggermessage logger; TMVA::MethodBase *constfMethodThe MVA method to be evaluated; TH1D*fMvaBkgMVA distrituion for bakgr. events, used for spline fit; TH1D*fMvaBkgFineBinMVA distrituion for bakgr. events; TH1D*fMvaSigMVA distrituion for signal events, used for spline fit; TH1D*fMvaSigFineBinMVA distrituion for signal events; TStringfOptimizationFitTypewhich type of optimisation procedure to be used ; map<TString,TMVA::Interval>fTuneParametersparameters included in the tuning; map<TString,Double_t>fTunedParametersparameters included in the tuning. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; OptimizeConfigParameters(TMVA::MethodBase *const method, map<TString,TMVA::Interval> tuneParameters, TString fomType = ""Separation"", TString optimizationType = ""GA""); Constructor which sets either ""Classification or Regression"". ~OptimizeConfigParameters(); the destructor (delete the OptimizeConfigParameters, store the graph and .. delete it). std::map<T",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMVA__OptimizeConfigParameters.html:1776,log,logger,1776,root/html528/TMVA__OptimizeConfigParameters.html,https://root.cern,https://root.cern/root/html528/TMVA__OptimizeConfigParameters.html,1,['log'],['logger']
Testability,"nst; Bool_tTProof::IsProofd() const; virtual Bool_tTNamed::IsSortable() const; Bool_tTProof::IsValid() const; Bool_tTProof::IsWaiting() const; Bool_tTObject::IsZombie() const; virtual Int_tTProof::Load(const char* macro, Bool_t notOnClient = kFALSE, Bool_t uniqueOnly = kTRUE, TList* wrks = 0); static voidTQObject::LoadRQ_OBJECT(); voidTProof::LogMessage(const char* msg, Bool_t all)SIGNAL ; static voidTProof::LogViewer(const char* url = 0, Int_t sessionidx = 0); virtual voidTQObject::LowPriority(const char* signal_name, const char* slot_name = 0); virtual voidTNamed::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual voidTQObject::Message(const char* msg)SIGNAL ; static TProofMgr*TProof::Mgr(const char* url); virtual Bool_tTObject::Notify(); virtual Int_tTQObject::NumberOfConnections() const; virtual Int_tTQObject::NumberOfSignals() const; static TProof*TProof::Open(const char* url = 0, const char* conffile = 0, const char* confdir = 0, Int_t loglevel = 0); static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TNamed&TNamed::operator=(const TNamed& rhs); virtual voidTObject::Paint(Option_t* option = """"); Int_tTProof::Ping(); virtual voidTObject::Pop(); virtual voidTProof::Print(Option_t* option = """") const; virtual Long64_tProcess(const char* sel, Long64_t nent, Option_t* o = """"); virtual Long64_tProcess(TDSet* set, const char* selector, Option_t* option = """", Long64_t nentries = -1, Long64_t firstentry = 0); virtual Long64_tProcess(TFileCollection* fc, const char* sel, Option_t* o = """", Long64_t nent = -1, Long64_t fst = 0); virtual Long64_tProcess(const char* dsname, const char* sel, Option_",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TProofSuperMaster.html:11830,log,loglevel,11830,root/html528/TProofSuperMaster.html,https://root.cern,https://root.cern/root/html528/TProofSuperMaster.html,1,['log'],['loglevel']
Testability,"nst; Bool_tTProof::IsProofd() const; virtual Bool_tTNamed::IsSortable() const; Bool_tTProof::IsValid() const; Bool_tTProof::IsWaiting() const; Bool_tTObject::IsZombie() const; virtual Int_tTProof::Load(const char* macro, Bool_t notOnClient = kFALSE, Bool_t uniqueOnly = kTRUE, TList* wrks = 0); static voidTQObject::LoadRQ_OBJECT(); voidTProof::LogMessage(const char* msg, Bool_t all)SIGNAL ; static voidTProof::LogViewer(const char* url = 0, Int_t sessionidx = 0); virtual voidTQObject::LowPriority(const char* signal_name, const char* slot_name = 0); virtual voidTNamed::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual voidTQObject::Message(const char* msg)SIGNAL ; static TProofMgr*TProof::Mgr(const char* url); virtual Bool_tTObject::Notify(); virtual Int_tTQObject::NumberOfConnections() const; virtual Int_tTQObject::NumberOfSignals() const; static TProof*TProof::Open(const char* url = 0, const char* conffile = 0, const char* confdir = 0, Int_t loglevel = 0); static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TNamed&TNamed::operator=(const TNamed& rhs); virtual voidTObject::Paint(Option_t* option = """"); Int_tTProof::Ping(); virtual voidTObject::Pop(); virtual voidTProof::Print(Option_t* option = """") const; virtual Long64_tTProof::Process(const char* selector, Long64_t nentries, Option_t* option = """"); virtual Long64_tTProof::Process(TDSet* dset, const char* selector, Option_t* option = """", Long64_t nentries = -1, Long64_t firstentry = 0); virtual Long64_tTProof::Process(TFileCollection* fc, const char* selector, Option_t* option = """", Long64_t nentries = -1, Long64_t firstentry = 0); virtual ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TProofCondor.html:11794,log,loglevel,11794,root/html528/TProofCondor.html,https://root.cern,https://root.cern/root/html528/TProofCondor.html,1,['log'],['loglevel']
Testability,"nst; Bool_tisConvolved(); virtual Bool_tRooAbsArg::isDerived() const; virtual Bool_tRooAbsPdf::isDirectGenSafe(const RooAbsArg& arg) const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; virtual Bool_tRooAbsArg::isFundamental() const; virtual Bool_tRooAbsArg::isLValue() const; Bool_tTObject::IsOnHeap() const; Bool_tRooAbsArg::isShapeDirty() const; Bool_tRooAbsArg::isShapeServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isShapeServer(const char* name) const; virtual Bool_tRooAbsArg::IsSortable() const; Bool_tRooAbsArg::isValueDirty() const; Bool_tRooAbsArg::isValueDirtyAndClear() const; Bool_tRooAbsArg::isValueOrShapeDirtyAndClear() const; Bool_tRooAbsArg::isValueServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isValueServer(const char* name) const; Bool_tTObject::IsZombie() const; voidRooAbsArg::leafNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; voidRooAbsReal::logEvalError(const char* message, const char* serverValueString = 0) const; static voidRooAbsReal::logEvalError(const RooAbsReal* originator, const char* origName, const char* message, const char* serverValueString = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooMoment*RooAbsReal::mean(RooRealVar& obs); RooMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); Int_tRooAbsPdf::minDimNormValueCaching() const; virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tRooAbsPdf::mustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; virtual voidnormLeafServerList(Ro",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooResolutionModel.html:22054,log,logEvalError,22054,root/html532/RooResolutionModel.html,https://root.cern,https://root.cern/root/html532/RooResolutionModel.html,1,['log'],['logEvalError']
Testability,"nst; Return function value at current upper bound of the minimization interval. . bool Minimize(int maxIter, double absTol = 1.E-8, double relTol = 1.E-10); Find minimum position iterating until convergence specified by the absolute and relative tolerance or; the maximum number of iteration is reached.; Return true if iterations converged successfully; \@param maxIter maximum number of iterations.; \@param absTol desired absolute error in the minimum position (default 1.E-8); \@param absTol desired relative error in the minimum position (default = 1.E-10). int Iterations() const; Return number of iteration used to find minimum . { return fNIter; }. const char * Name() const; Return name of minimization algorithm (""BrentMinimizer1D"") . void SetFunction(const ROOT::Math::IGenFunction& f, double xlow, double xup); Sets function to be minimized. \@param f Function to be minimized.; \@param xlow Lower bound of the search interval.; \@param xup Upper bound of the search interval. void SetNpx(int npx); Set the number of point used to bracket root using a grid . { fNpx = npx; }. void SetLogScan(bool on). Set a log grid scan (default is equidistant bins); will work only if xlow > 0. { fLogScan = on; }. int Status() const; Returns status of last estimate. If = 0 is OK . { return fStatus; }. void SetDefaultNpx(int npx); static function used to modify the default parameters; set number of default Npx used at construction time (when SetNpx is not called); Default value is 100. void SetDefaultNSearch(int n); set number of times the bracketing search in combination with is done to find a good interval; Default value is 10.  Author: David Gonzalez Maline 2/2008  Copyright (c) 2004 Maline, CERN/PH-SFT *;  Last changed: root/mathcore:$Id: BrentMinimizer1D.h 36905 2010-11-24 15:44:34Z moneta $  Last generated: 2010-11-25 07:08; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/ROOT__Math__BrentMinimizer1D.html:4663,log,log,4663,root/html528/ROOT__Math__BrentMinimizer1D.html,https://root.cern,https://root.cern/root/html528/ROOT__Math__BrentMinimizer1D.html,1,['log'],['log']
Testability,"nst; Return function value at current upper bound of the minimization interval. . bool Minimize(int maxIter, double absTol = 1.E-8, double relTol = 1.E-10); Find minimum position iterating until convergence specified by the absolute and relative tolerance or; the maximum number of iteration is reached.; Return true if iterations converged successfully; \@param maxIter maximum number of iterations.; \@param absTol desired absolute error in the minimum position (default 1.E-8); \@param absTol desired relative error in the minimum position (default = 1.E-10). int Iterations() const; Return number of iteration used to find minimum . { return fNIter; }. const char * Name() const; Return name of minimization algorithm (""BrentMinimizer1D"") . void SetFunction(const ROOT::Math::IGenFunction& f, double xlow, double xup); Sets function to be minimized. \@param f Function to be minimized.; \@param xlow Lower bound of the search interval.; \@param xup Upper bound of the search interval. void SetNpx(int npx); Set the number of point used to bracket root using a grid . { fNpx = npx; }. void SetLogScan(bool on). Set a log grid scan (default is equidistant bins); will work only if xlow > 0. { fLogScan = on; }. int Status() const; Returns status of last estimate. If = 0 is OK . { return fStatus; }. void SetDefaultNpx(int npx); static function used to modify the default parameters; set number of default Npx used at construction time (when SetNpx is not called); Default value is 100. void SetDefaultNSearch(int n); set number of times the bracketing search in combination with is done to find a good interval; Default value is 10.  Author: David Gonzalez Maline 2/2008  Copyright (c) 2004 Maline, CERN/PH-SFT *;  Last changed: root/mathcore:$Id: BrentMinimizer1D.h 36905 2010-11-24 15:44:34Z moneta $  Last generated: 2011-07-04 15:19; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/ROOT__Math__BrentMinimizer1D.html:4665,log,log,4665,root/html530/ROOT__Math__BrentMinimizer1D.html,https://root.cern,https://root.cern/root/html530/ROOT__Math__BrentMinimizer1D.html,1,['log'],['log']
Testability,"nst; TIterator*clientIterator() const; virtual TObject*clone(const char* newname = 0) const; virtual TObject*Clone(const char* newname = 0) const; virtual RooAbsArg*cloneTree(const char* newname = 0) const; virtual Int_tCompare(const TObject* other) const; virtual voidconstOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; static UInt_tcrc32(const char* data); static UInt_tcrc32(const char* data, ULong_t sz, UInt_t crc = 0); virtual RooAbsArg*createFundamental(const char* newname = 0) const; virtual Int_tdefaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tdependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tdependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tdependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tdependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tdependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tdependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAbsArg.html:3551,test,testArg,3551,root/html534/RooAbsArg.html,https://root.cern,https://root.cern/root/html534/RooAbsArg.html,3,['test'],['testArg']
Testability,"nst; boolHasCdf() const; boolHasMode() const; boolHasPdfArea() const; virtual TClass*IsA() const; boolIsLogPdf() const; doubleMode() const; TUnuranContDist&operator=(const TUnuranContDist& rhs); doublePdf(double x) const; doublePdfArea() const; voidSetCdf(TF1* cdf); voidSetCdf(const ROOT::Math::IGenFunction& cdf); voidSetDomain(double xmin, double xmax); voidSetMode(double mode); voidSetPdfArea(double area); virtual voidShowMembers(TMemberInspector&); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). Data Members; private:. doublefAreaarea below pdf; const ROOT::Math::IBaseFunctionOneDim*fCdfpointer to the cdf (cumulative dist.); const ROOT::Math::IBaseFunctionOneDim*fDPdfpointer to the derivative of the pdf; boolfHasAreaflag to control if distribution has a pre-computed area below the pdf; boolfHasDomainflag to control if distribution has a defined domain (otherwise is [-inf,+inf]; boolfHasModeflag to control if distribution has a pre-computed mode; boolfIsLogPdfflag to control if function pointer represent log of pdf; doublefModemode of the distribution; boolfOwnFuncflag to indicate if class manages the function pointers; const ROOT::Math::IBaseFunctionOneDim*fPdfpointer to the pdf ; doublefXmaxupper value of the domain; doublefXminlower value of the domain . Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TUnuranContDist(const ROOT::Math::IGenFunction& pdf, const ROOT::Math::IGenFunction* dpdf = 0, bool isLogPdf = false, bool copyFunc = false); Constructor from generic function interfaces; manage the functions and clone them if flag copyFunc is true. TUnuranContDist(TF1* pdf = 0, TF1* deriv = 0, bool isLogPdf = false); Constructor from a TF1 objects; function pointers are managed by class. TUnuranContDist(const TUnuranContDist& ); Implementation of copy constructor. ~TUnuranContDist(); destructor implementation. void SetCdf(const ROOT::Math::IGenFunction& cdf); set cdf distributi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TUnuranContDist.html:1860,log,log,1860,root/html534/TUnuranContDist.html,https://root.cern,https://root.cern/root/html534/TUnuranContDist.html,1,['log'],['log']
Testability,"nst; const RooAbsReal*RooAbsReal::createPlotProjection(const RooArgSet& dependentVars, const RooArgSet* projectedVars, RooArgSet*& cloneSet, const char* rangeName = 0, const RooArgSet* condObs = 0) const; virtual RooAbsReal*RooAbsReal::createProfile(const RooArgSet& paramsOfInterest); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooCmdArg arg1, const RooCmdArg arg2 = RooCmdArg::none(), const RooCmdArg arg3 = RooCmdArg::none(), const RooCmdArg arg4 = RooCmdArg::none(), const RooCmdArg arg5 = RooCmdArg::none(), const RooCmdArg arg6 = RooCmdArg::none(), const RooCmdArg arg7 = RooCmdArg::none(), const RooCmdArg arg8 = RooCmdArg::none()); RooAbsReal*RooAbsReal::createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); virtual Double_tdefaultErrorLevel() const; static RooNumIntConfig*RooAbsReal::defaultIntegratorConfig(); virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; RooDerivative*RooAbsReal::derivative(RooRealVar& obs, Int_t order = 1, Double_t eps = 0.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAddition.html:8468,test,testArg,8468,root/html526/RooAddition.html,https://root.cern,https://root.cern/root/html526/RooAddition.html,6,['test'],['testArg']
Testability,"nst; const RooAbsReal*RooAbsReal::createPlotProjection(const RooArgSet& dependentVars, const RooArgSet* projectedVars, RooArgSet*& cloneSet, const char* rangeName = 0, const RooArgSet* condObs = 0) const; virtual RooAbsReal*createProfile(const RooArgSet& paramsOfInterest); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooCmdArg arg1, const RooCmdArg arg2 = RooCmdArg::none(), const RooCmdArg arg3 = RooCmdArg::none(), const RooCmdArg arg4 = RooCmdArg::none(), const RooCmdArg arg5 = RooCmdArg::none(), const RooCmdArg arg6 = RooCmdArg::none(), const RooCmdArg arg7 = RooCmdArg::none(), const RooCmdArg arg8 = RooCmdArg::none()); RooAbsReal*RooAbsReal::createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); virtual Double_tRooAbsReal::defaultErrorLevel() const; static RooNumIntConfig*RooAbsReal::defaultIntegratorConfig(); virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; RooDerivative*RooAbsReal::derivative(RooRealVar& obs, Int_t order = 1, Double_t eps = 0.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooProfileLL.html:8622,test,testArg,8622,root/html526/RooProfileLL.html,https://root.cern,https://root.cern/root/html526/RooProfileLL.html,2,['test'],['testArg']
Testability,"nst; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooMoment*RooAbsReal::mean(RooRealVar& obs); RooMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; virtual Bool_tTObject::Notify(); virtual Int_tRooAbsRealLValue::numBins(const char* rangeName = 0) const; virtual Int_tRooAbsRealLValue::numBins(const RooAbsBinning& binning) const; Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); virtual RooAbsArg&RooAbsRealLValue::operator=(const RooAbsReal& other); virtual RooAbsArg&RooAbsRealLValue::operator=(Double_t newValue); virtual RooAbsArg&RooAbsRealLValue::operator=(Int_t ival); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooErrorVar.html:21311,test,testArg,21311,root/html532/RooErrorVar.html,https://root.cern,https://root.cern/root/html532/RooErrorVar.html,2,['test'],['testArg']
Testability,"nst; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*RooAbsArg::clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); virtual RooAbsArg*createFundamental(const char* newname = 0) const; virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTO",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooAbsString.html:3017,test,testArg,3017,root/html532/RooAbsString.html,https://root.cern,https://root.cern/root/html532/RooAbsString.html,1,['test'],['testArg']
Testability,"nst; voidTMVA::Configurable::WriteOptionsReferenceToFile(). private:. voidCalculateMulticlassValues(const TMVA::Event*& evt, vector<Double_t>& parameters, vector<Float_t>& values); voidClearAll(); voidCreateFormula(); virtual voidDeclareOptions(); Double_tInterpretFormula(const TMVA::Event*, vector<double>::iterator begin, vector<double>::iterator end); voidPrintResults(const TString&, vector<Double_t>&, const Double_t) const; virtual voidProcessOptions(). Data Members; public:. Bool_tTMVA::MethodBase::fSetupCompletedis method setup; const TMVA::Event*TMVA::MethodBase::fTmpEvent! temporary event when testing on a different DataSet than the own one; static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TMVA::MethodBase::EWeightFileTypeTMVA::MethodBase::kROOT; static TObject::(anonymous)TObject::kSingleKey; static TMVA::MethodBase::EWeightFileTypeTMVA::MethodBase::kTEXT; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TMVA::Types::EAnalysisTypeTMVA::MethodBase::fAnalysisTypemethod-mode : true --> regression, false --> classification; UInt_tTMVA::MethodBase::fBackgroundClassindex of the Background-class; vector<TString>*TMVA::MethodBase::fInputVarsvector of input variables used in MVA; vector<Float_t>*TMVA::MethodBase::fMulticlassReturnValholds the return-values for the multiclass classification; Int_tTMVA::MethodBase::fNbinsnumber of bins in input variable histograms; Int_tTMVA::",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TMVA__MethodFDA.html:16258,test,testing,16258,root/html602/TMVA__MethodFDA.html,https://root.cern,https://root.cern/root/html602/TMVA__MethodFDA.html,2,['test'],['testing']
Testability,"nst; voidTObject::MayNotUse(const char* method) const; RooMoment*RooAbsReal::mean(RooRealVar& obs); RooMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); static voidRooPrintable::nameFieldLength(Int_t newLen); virtual Bool_tTObject::Notify(); virtual Int_tRooAbsRealLValue::numBins(const char* rangeName = 0) const; virtual Int_tRooAbsRealLValue::numBins(const RooAbsBinning& binning) const; Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); virtual RooAbsArg&RooAbsRealLValue::operator=(const RooAbsReal& other); virtual RooAbsArg&RooAbsRealLValue::operator=(Double_t newValue); virtual RooAbsArg&RooAbsRealLValue::operator=(Int_t ival); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAb",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooErrorVar.html:20597,test,testArg,20597,root/html526/RooErrorVar.html,https://root.cern,https://root.cern/root/html526/RooErrorVar.html,6,['test'],['testArg']
Testability,"nst; voidTObject::MayNotUse(const char* method) const; RooMoment*RooAbsReal::mean(RooRealVar& obs); RooMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); static voidRooPrintable::nameFieldLength(Int_t newLen); virtual Bool_tTObject::Notify(); virtual Int_tRooAbsRealLValue::numBins(const char* rangeName = 0) const; virtual Int_tRooAbsRealLValue::numBins(const RooAbsBinning& binning) const; Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); virtual RooAbsArg&RooAbsRealLValue::operator=(const RooAbsReal& other); virtual RooAbsArg&RooAbsRealLValue::operator=(Double_t newValue); virtual RooAbsArg&RooAbsRealLValue::operator=(Int_t ival); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& obs",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooErrorVar.html:20964,test,testArg,20964,root/html530/RooErrorVar.html,https://root.cern,https://root.cern/root/html530/RooErrorVar.html,4,['test'],['testArg']
Testability,"nstMENU ; virtual voidTObject::SavePrimitive(basic_ostream<char,char_traits<char> >& out, Option_t* option = """"); virtual voidTMVA::MethodBase::SetAnalysisType(TMVA::Types::EAnalysisType type); voidTMVA::MethodBase::SetBaseDir(TDirectory* methodDir); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTMVA::Configurable::SetConfigDescription(const char* d); voidTMVA::Configurable::SetConfigName(const char* n); virtual voidTMVA::MethodBase::SetCurrentEvent(Long64_t ievt) const; virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTMVA::MethodBase::SetMethodBaseDir(TDirectory* methodDir); voidTMVA::MethodBase::SetMethodDir(TDirectory* methodDir); voidTMVA::Configurable::SetMsgType(TMVA::EMsgType t); static voidTObject::SetObjectStat(Bool_t stat); voidTMVA::Configurable::SetOptions(const TString& s); voidTMVA::MethodBase::SetSignalReferenceCut(Double_t cut); voidTMVA::MethodBase::SetTestTime(Double_t testTime); voidTMVA::MethodBase::SetTestvarName(const TString& v = """"); voidTMVA::MethodBase::SetTrainTime(Double_t trainTime); virtual voidTMVA::MethodBase::SetTuneParameters(map<TString,Double_t> tuneParameters); virtual voidTObject::SetUniqueID(UInt_t uid); voidTMVA::MethodBase::SetupMethod(); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTMVA::MethodBase::TestClassification(); virtual voidTMVA::MethodBase::TestMulticlass(); virtual voidTMVA::MethodBase::TestRegression(Double_t& bias, Double_t& biasT, Double_t& dev, Double_t& devT, Double_t& rms, Double_t& rmsT, Double_t& mInf, Double_t& mInfT, Double_t& corr, TMVA::Types::ETreeType type); Double_tTestTreeQuality(TMVA::DecisionTree* dt); virtual voidTrain(); voidTMVA::MethodBase::TrainMethod(); virtual",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMVA__MethodDT.html:13788,test,testTime,13788,root/html528/TMVA__MethodDT.html,https://root.cern,https://root.cern/root/html528/TMVA__MethodDT.html,1,['test'],['testTime']
Testability,"nstMENU ; virtual voidTObject::SavePrimitive(basic_ostream<char,char_traits<char> >& out, Option_t* option = """"); virtual voidTMVA::MethodBase::SetAnalysisType(TMVA::Types::EAnalysisType type); voidTMVA::MethodBase::SetBaseDir(TDirectory* methodDir); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTMVA::Configurable::SetConfigDescription(const char* d); voidTMVA::Configurable::SetConfigName(const char* n); virtual voidTMVA::MethodBase::SetCurrentEvent(Long64_t ievt) const; virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTMVA::MethodBase::SetMethodBaseDir(TDirectory* methodDir); voidTMVA::MethodBase::SetMethodDir(TDirectory* methodDir); voidTMVA::Configurable::SetMsgType(TMVA::EMsgType t); static voidTObject::SetObjectStat(Bool_t stat); voidTMVA::Configurable::SetOptions(const TString& s); voidTMVA::MethodBase::SetSignalReferenceCut(Double_t cut); voidTMVA::MethodBase::SetTestTime(Double_t testTime); voidTMVA::MethodBase::SetTestvarName(const TString& v = """"); voidTMVA::MethodBase::SetTrainTime(Double_t trainTime); virtual voidTMVA::MethodBase::SetTuneParameters(map<TString,Double_t> tuneParameters); virtual voidTObject::SetUniqueID(UInt_t uid); voidTMVA::MethodBase::SetupMethod(); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTMVA::MethodBase::TestClassification(); virtual voidTMVA::MethodBase::TestMulticlass(); virtual voidTMVA::MethodBase::TestRegression(Double_t& bias, Double_t& biasT, Double_t& dev, Double_t& devT, Double_t& rms, Double_t& rmsT, Double_t& mInf, Double_t& mInfT, Double_t& corr, TMVA::Types::ETreeType type); static TMVA::MethodCFMlpANN*This(); virtual voidTrain(); voidTMVA::MethodBase::TrainMethod(); virtual voidTObject:",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMVA__MethodCFMlpANN.html:12157,test,testTime,12157,root/html528/TMVA__MethodCFMlpANN.html,https://root.cern,https://root.cern/root/html528/TMVA__MethodCFMlpANN.html,1,['test'],['testTime']
Testability,"nstMENU ; virtual voidTObject::SavePrimitive(basic_ostream<char,char_traits<char> >& out, Option_t* option = """"); virtual voidTMVA::MethodBase::SetAnalysisType(TMVA::Types::EAnalysisType type); voidTMVA::MethodBase::SetBaseDir(TDirectory* methodDir); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTMVA::Configurable::SetConfigDescription(const char* d); voidTMVA::Configurable::SetConfigName(const char* n); virtual voidTMVA::MethodBase::SetCurrentEvent(Long64_t ievt) const; virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTMVA::MethodBase::SetMethodBaseDir(TDirectory* methodDir); voidTMVA::MethodBase::SetMethodDir(TDirectory* methodDir); voidTMVA::Configurable::SetMsgType(TMVA::EMsgType t); static voidTObject::SetObjectStat(Bool_t stat); voidTMVA::Configurable::SetOptions(const TString& s); voidTMVA::MethodBase::SetSignalReferenceCut(Double_t cut); voidTMVA::MethodBase::SetTestTime(Double_t testTime); voidTMVA::MethodBase::SetTestvarName(const TString& v = """"); voidTMVA::MethodBase::SetTrainTime(Double_t trainTime); virtual voidTMVA::MethodBase::SetTuneParameters(map<TString,Double_t> tuneParameters); virtual voidTObject::SetUniqueID(UInt_t uid); voidTMVA::MethodBase::SetupMethod(); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTMVA::MethodBase::TestClassification(); virtual voidTMVA::MethodBase::TestMulticlass(); virtual voidTMVA::MethodBase::TestRegression(Double_t& bias, Double_t& biasT, Double_t& dev, Double_t& devT, Double_t& rms, Double_t& rmsT, Double_t& mInf, Double_t& mInfT, Double_t& corr, TMVA::Types::ETreeType type); static TMVA::MethodPDERS*ThisPDERS(); virtual voidTrain(); voidTMVA::MethodBase::TrainMethod(); virtual voidTObjec",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMVA__MethodPDERS.html:12174,test,testTime,12174,root/html528/TMVA__MethodPDERS.html,https://root.cern,https://root.cern/root/html528/TMVA__MethodPDERS.html,1,['test'],['testTime']
Testability,"nstMENU ; virtual voidTObject::SavePrimitive(basic_ostream<char,char_traits<char> >& out, Option_t* option = """"); virtual voidTMVA::MethodBase::SetAnalysisType(TMVA::Types::EAnalysisType type); voidTMVA::MethodBase::SetBaseDir(TDirectory* methodDir); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTMVA::Configurable::SetConfigDescription(const char* d); voidTMVA::Configurable::SetConfigName(const char* n); virtual voidTMVA::MethodBase::SetCurrentEvent(Long64_t ievt) const; virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTMVA::MethodBase::SetMethodBaseDir(TDirectory* methodDir); voidTMVA::MethodBase::SetMethodDir(TDirectory* methodDir); voidTMVA::Configurable::SetMsgType(TMVA::EMsgType t); static voidTObject::SetObjectStat(Bool_t stat); voidTMVA::Configurable::SetOptions(const TString& s); voidTMVA::MethodBase::SetSignalReferenceCut(Double_t cut); voidTMVA::MethodBase::SetTestTime(Double_t testTime); voidTMVA::MethodBase::SetTestvarName(const TString& v = """"); voidTMVA::MethodBase::SetTrainTime(Double_t trainTime); virtual voidTMVA::MethodBase::SetTuneParameters(map<TString,Double_t> tuneParameters); virtual voidTObject::SetUniqueID(UInt_t uid); voidTMVA::MethodBase::SetupMethod(); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTMVA::MethodBase::TestClassification(); virtual voidTMVA::MethodBase::TestMulticlass(); virtual voidTMVA::MethodBase::TestRegression(Double_t& bias, Double_t& biasT, Double_t& dev, Double_t& devT, Double_t& rms, Double_t& rmsT, Double_t& mInf, Double_t& mInfT, Double_t& corr, TMVA::Types::ETreeType type); virtual voidTrain(); voidTMVA::MethodBase::TrainMethod(); Bool_tUseBoost() const; virtual voidTObject::UseCurrentS",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMVA__MethodRuleFit.html:11487,test,testTime,11487,root/html528/TMVA__MethodRuleFit.html,https://root.cern,https://root.cern/root/html528/TMVA__MethodRuleFit.html,1,['test'],['testTime']
Testability,"nstMENU ; virtual voidTObject::SavePrimitive(basic_ostream<char,char_traits<char> >& out, Option_t* option = """"); virtual voidTMVA::MethodBase::SetAnalysisType(TMVA::Types::EAnalysisType type); voidTMVA::MethodBase::SetBaseDir(TDirectory* methodDir); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTMVA::Configurable::SetConfigDescription(const char* d); voidTMVA::Configurable::SetConfigName(const char* n); virtual voidTMVA::MethodBase::SetCurrentEvent(Long64_t ievt) const; virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTMVA::MethodBase::SetMethodBaseDir(TDirectory* methodDir); voidTMVA::MethodBase::SetMethodDir(TDirectory* methodDir); voidTMVA::Configurable::SetMsgType(TMVA::EMsgType t); static voidTObject::SetObjectStat(Bool_t stat); voidTMVA::Configurable::SetOptions(const TString& s); voidTMVA::MethodBase::SetSignalReferenceCut(Double_t cut); voidTMVA::MethodBase::SetTestTime(Double_t testTime); voidTMVA::MethodBase::SetTestvarName(const TString& v = """"); voidTMVA::MethodBase::SetTrainTime(Double_t trainTime); virtual voidTMVA::MethodBase::SetTuneParameters(map<TString,Double_t> tuneParameters); virtual voidTObject::SetUniqueID(UInt_t uid); voidTMVA::MethodBase::SetupMethod(); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTMVA::MethodBase::TestClassification(); virtual voidTMVA::MethodBase::TestMulticlass(); virtual voidTMVA::MethodBase::TestRegression(Double_t& bias, Double_t& biasT, Double_t& dev, Double_t& devT, Double_t& rms, Double_t& rmsT, Double_t& mInf, Double_t& mInfT, Double_t& corr, TMVA::Types::ETreeType type); virtual voidTrain(); voidTMVA::MethodBase::TrainMethod(); virtual voidTObject::UseCurrentStyle(); virtual voidTObj",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMVA__MethodBayesClassifier.html:10745,test,testTime,10745,root/html528/TMVA__MethodBayesClassifier.html,https://root.cern,https://root.cern/root/html528/TMVA__MethodBayesClassifier.html,11,['test'],['testTime']
Testability,"nstMENU ; virtual voidTObject::SavePrimitive(basic_ostream<char,char_traits<char> >& out, Option_t* option = """"); virtual voidTMVA::MethodBase::SetAnalysisType(TMVA::Types::EAnalysisType type); voidTMVA::MethodBase::SetBaseDir(TDirectory* methodDir); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTMVA::Configurable::SetConfigDescription(const char* d); voidTMVA::Configurable::SetConfigName(const char* n); virtual voidTMVA::MethodBase::SetCurrentEvent(Long64_t ievt) const; virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTMVA::MethodBase::SetMethodBaseDir(TDirectory* methodDir); voidTMVA::MethodBase::SetMethodDir(TDirectory* methodDir); voidTMVA::Configurable::SetMsgType(TMVA::EMsgType t); static voidTObject::SetObjectStat(Bool_t stat); voidTMVA::Configurable::SetOptions(const TString& s); voidTMVA::MethodBase::SetSignalReferenceCut(Double_t cut); voidTMVA::MethodBase::SetTestTime(Double_t testTime); voidTMVA::MethodBase::SetTestvarName(const TString& v = """"); voidTMVA::MethodBase::SetTrainTime(Double_t trainTime); virtual voidTMVA::MethodBase::SetTuneParameters(map<TString,Double_t> tuneParameters); virtual voidTObject::SetUniqueID(UInt_t uid); voidTMVA::MethodBase::SetupMethod(); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; UInt_tTargetSelectionToUInt(TMVA::ETargetSelection ts) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTMVA::MethodBase::TestClassification(); virtual voidTMVA::MethodBase::TestMulticlass(); virtual voidTMVA::MethodBase::TestRegression(Double_t& bias, Double_t& biasT, Double_t& dev, Double_t& devT, Double_t& rms, Double_t& rmsT, Double_t& mInf, Double_t& mInfT, Double_t& corr, TMVA::Types::ETreeType type); virtual voidTrain(); voidTMVA::MethodBase::TrainMeth",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMVA__MethodPDEFoam.html:10639,test,testTime,10639,root/html528/TMVA__MethodPDEFoam.html,https://root.cern,https://root.cern/root/html528/TMVA__MethodPDEFoam.html,1,['test'],['testTime']
Testability,"nstructor . ClassBuilderImpl(Class* cl). virtual ~ClassBuilderImpl(); destructor . void AddBase(const Reflex::Type& bas, Reflex::OffsetFunction offsFP, unsigned int modifiers = 0). * AddBase will add the information about one BaseAt class; * @param Name of the BaseAt class; * @param OffsetFP function pointer for Offset calculation; * @param modifiers the modifiers of the class. void AddFunctionMember(const char* nam, const Reflex::Type& typ, Reflex::StubFunction stubFP, void* stubCtx = 0, const char* params = 0, unsigned int modifiers = 0); AddDataMember will add the information about one data; * MemberAt of the class; *; * @param Name of the data MemberAt; * @param At of the data MemberAt; * @param Offset of the data MemberAt; * @param modifiers the modifiers of the data MemberAt. AddFunctionMember will add the information about one; * function MemberAt of the class; *; * @param Name of the function MemberAt; * @param At of the function MemberAt; * @param stubFP Stub function pointer for the function; * @param stubCxt Stub user context for the stub function; * @param params parameter names and default values (semi-colon separated); * @param modifiers the modifiers of the function MemberAt. void AddEnum(const char* nam, const char* values, const type_info* ti, unsigned int modifiers = 0); This is for anonymous union support.; void addUnion(const char* nam, const char* values, const std::type_info& ti, unsigned int modifiers = 0);; AddProperty will add a PropertyNth to the PropertyNth stack; * which will be emtpied with the next call of a builder; * class and attached to the item built with this call; *; * @param key the PropertyNth key; * @param value the value of the PropertyNth. void AddProperty(const char* key, const char* value). * Register an on demand builder for data members with this class. void AddOnDemandFunctionMemberBuilder(Reflex::OnDemandBuilderForScope* odb). * Register an on demand builder for function members with this class. void SetSizeOf(size_t si",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/Reflex__ClassBuilderImpl.html:2931,stub,stubFP,2931,root/html526/Reflex__ClassBuilderImpl.html,https://root.cern,https://root.cern/root/html526/Reflex__ClassBuilderImpl.html,3,['stub'],"['stub', 'stubCxt', 'stubFP']"
Testability,"nstructor . ClassBuilderImpl(Class* cl). virtual ~ClassBuilderImpl(); destructor . void AddBase(const Reflex::Type& bas, Reflex::OffsetFunction offsFP, unsigned int modifiers = 0). * AddBase will add the information about one BaseAt class; * @param Name of the BaseAt class; * @param OffsetFP function pointer for Offset calculation; * @param modifiers the modifiers of the class. void AddFunctionMember(const char* nam, const Reflex::Type& typ, Reflex::StubFunction stubFP, void* stubCtx = 0, const char* params = 0, unsigned int modifiers = 0); AddDataMember will add the information about one data; * MemberAt of the class; *; * @param Name of the data MemberAt; * @param At of the data MemberAt; * @param Offset of the data MemberAt; * @param modifiers the modifiers of the data MemberAt. AddFunctionMember will add the information about one; * function MemberAt of the class; *; * @param Name of the function MemberAt; * @param At of the function MemberAt; * @param stubFP Stub function pointer for the function; * @param stubCxt Stub user context for the stub function; * @param params parameter names and default values (semi-colon separated); * @param modifiers the modifiers of the function MemberAt. void AddEnum(const char* nam, const char* values, const type_info* ti, unsigned int modifiers = 0); This is for anonymous union support.; void addUnion(const char* nam, const char* values, const std::type_info& ti, unsigned int modifiers = 0);; AddProperty will add a PropertyNth to the PropertyNth stack; * which will be emtpied with the next call of a builder; * class and attached to the item built with this call; *; * @param key the PropertyNth key; * @param value the value of the PropertyNth. void AddProperty(const char* key, const char* value); { AddProperty(key, (const char*)value); }. void AddOnDemandDataMemberBuilder(Reflex::OnDemandBuilderForScope* odb). * Register an on demand builder for data members with this class. void AddOnDemandFunctionMemberBuilder(Reflex::OnDemandB",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/Reflex__ClassBuilderImpl.html:2995,stub,stubFP,2995,root/html528/Reflex__ClassBuilderImpl.html,https://root.cern,https://root.cern/root/html528/Reflex__ClassBuilderImpl.html,12,['stub'],"['stub', 'stubCxt', 'stubFP']"
Testability,"nt -f $@ -c $(CXXFLAGS) -p $^. libMyLib.so: MyDict.cxx $(SOURCES); [TAB] g++ -shared -o$@ `root-config --ldflags` $(CXXFLAGS) -I$(ROOTSYS)/include $^. See Interacting with Shared Libraries: rootcint for more details. ; . How can I fix the problem leading to :Error: Can't call vector<...>::push_back . This usually indicates that some classes dictionary refer and/or use this particular instance of std::vector. To solve the problem, you will need to generate a dictionary for this particular instance. With ROOT v5.27/06 and above this can be done by executing:gInterpreter->GenerateDictionary(""vector<Track&gt"",""Track.h;vector"");. With older version of ROOT ; this can simply be done using ACLiC and a simple loader.C script:// File loader.C; #include ; #include ; #ifdef __MAKECINT__; #pragma link C++ class vector<Track>+;; #endifI am defining a vector for my custom type (for example Track) in a root macro but when I push_back a Track object in the vector, CINT complains. e.g.; vector testVector;; Track obj;; ...; testVector.push_back(obj);; gives:Error: Can't call vector::push_back(timeStamp) in current scope MyAnalysisMasterTreeMaker.C:358:; Possible candidates are...; (in vector); *** Interpreter error recovered ***. Although, if I use a vector or vector or vector push_back works fine.; ; . What is the difference between a TFolder and a TDirectory? . TFolder manages a hierrachy of objects in memory.; TDirectory is doing it for a file.; One can save the TFolder structure to a directory in a file.; ; . Ubuntu: No backtrace (stacktrace) when ROOT crashes . Enable /proc/sys/kernel/yama/ptrace_scope or edit /etc/sysctl.d/10-ptrace.conf. See this blog entry for details. ; . Can I integrate ROOT into my CMake build? . Absolutely. The CMake command find_package() will set all needed ROOT related variables, which can be used to compile and link one's own code. An example from the ROOT Event example (found in root/test) can be downloaded here. Just un-tar the attached file and run:",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/faq-page.html:3974,test,testVector,3974,d/faq-page.html,https://root.cern,https://root.cern/d/faq-page.html,1,['test'],['testVector']
Testability,"nt and max number of points (to pre-allocate vector); 52 */; 53 ; 54 explicit UnBinData( unsigned int maxpoints = 0, unsigned int dim = 1,; 55 bool isWeighted = false ) :; 56 FitData( maxpoints, isWeighted ? dim + 1 : dim ),; 57 fWeighted(isWeighted); 58 {; 59 assert( dim >= 1 );; 60 assert( !fWeighted || dim >= 2 );; 61 }; 62 ; 63 ; 64 /**; 65 constructor from range and default option; 66 */; 67 explicit UnBinData ( const DataRange & range, unsigned int maxpoints = 0,; 68 unsigned int dim = 1, bool isWeighted = false ) :; 69 FitData( range, maxpoints, isWeighted ? dim + 1 : dim ),; 70 fWeighted(isWeighted); 71 {; 72 assert( dim >= 1 );; 73 assert( !fWeighted || dim >= 2 );; 74 }; 75 ; 76 /**; 77 constructor from options and range; 78 */; 79 UnBinData (const DataOptions & opt, const DataRange & range,; 80 unsigned int maxpoints = 0, unsigned int dim = 1, bool isWeighted = false ) :; 81 FitData( opt, range, maxpoints, isWeighted ? dim + 1 : dim ),; 82 fWeighted(isWeighted); 83 {; 84 assert( dim >= 1 );; 85 assert( !fWeighted || dim >= 2 );; 86 }; 87 ; 88 /**; 89 constructor for 1D external data (data are not copied inside); 90 */; 91 UnBinData(unsigned int n, const double * dataX ) :; 92 FitData( n, dataX ),; 93 fWeighted( false ); 94 {; 95 }; 96 ; 97 /**; 98 constructor for 2D external data (data are not copied inside); 99 or 1D data with a weight (if isWeighted = true); 100 */; 101 UnBinData(unsigned int n, const double * dataX, const double * dataY,; 102 bool isWeighted = false ) :; 103 FitData( n, dataX, dataY ),; 104 fWeighted( isWeighted ); 105 {; 106 }; 107 ; 108 /**; 109 constructor for 3D external data (data are not copied inside); 110 or 2D data with a weight (if isWeighted = true); 111 */; 112 UnBinData(unsigned int n, const double * dataX, const double * dataY,; 113 const double * dataZ, bool isWeighted = false ) :; 114 FitData( n, dataX, dataY, dataZ ),; 115 fWeighted( isWeighted ); 116 {; 117 }; 118 ; 119 /**; 120 constructor for multi-dim external data ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/UnBinData_8h_source.html:2941,assert,assert,2941,doc/master/UnBinData_8h_source.html,https://root.cern,https://root.cern/doc/master/UnBinData_8h_source.html,1,['assert'],['assert']
Testability,"nt is designed to support following features:; - usage of basic data types (like int or double) as parameters; in SQL statements; - bulk operation when inserting/updating/selecting data in database; - uasge of basic data types when accessing result set of executed query. 1. Creation of statement. To create an instance of the TSQLStatement class, the TSQLServer::Statement() method; should be used. Depending on the driver used for an ODBC connection,; the appropriate object instance will be created. For the moment there are; six different implementations of the TSQLStatement class: for MySQL,; Oracle, SAPDB, PostgreSQL, SQLite3 and ODBC. Hopefully, support of ODBC will allow usage of; statements for most existing RDBMS. // first, connect to the database; TSQLServer* serv = TSQLServer::Connect(""mysql://hostname.domain:3306/test"",; ""user"", ""pass"");; // check if connection is ok; if ((serv!=0) && serv->IsConnected()) {; // create instance of sql-statement; TSQLStatement* stmt = serv->Statement(""CREATE TABLE TESTTABLE (ID1 INT, ID2 INT, FFIELD VARCHAR(255), FVALUE VARCHAR(255))"";; // process statement; stmt->Process();; // destroy object; delete stmt;; }; delete serv;. 2. Insert data to data base. There is a special syntax of SQL queries which allows to use values; provided as parameters. For instance, to insert one row into the TESTTABLE created; with the previous example, one can simply execute a query like:. serv->Query(""INSERT INTO TESTTABLE VALUES (1, 2, \""name1\"", \""value1\"""");. However, when many (100-1000) rows should be inserted, each call of; TSQLServer::Query() method will cause communication loop with database; server, and the statement has to be evaluated each time instead of using a prepared statement.; As a result, insertion of data takes too much time. TSQLStatement provides a mechanism to insert many rows at once.; First of all, an appropriate statement should be created:. TSQLStatement* stmt = serv->Statement(""INSERT INTO TESTTABLE (ID1, ID2, FFIELD, FVAL",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TSQLStatement.html:1380,test,test,1380,root/html534/TSQLStatement.html,https://root.cern,https://root.cern/root/html534/TSQLStatement.html,3,['test'],['test']
Testability,"nt regmode=kRegModeNone in the constructor) ; Definition at line 2059 of file TUnfold.cxx. RegularizeSize(). Int_t TUnfold::RegularizeSize ; (; int; bin, . Double_t; scale = 1.0. ). add a regularisation condition on the magnitude of a truth bin ; Parameters. [in]binbin number ; [in]scale(default=1) scale factor. this adds one row to L, where the element bin takes the value scale; return value: 0 if ok, 1 if the condition has not been added. Conditions which are not added typically correspond to bin numbers where the truth can not be unfolded (either response matrix is empty or the data do not constrain).; The RegularizeXXX() methods can be used to set up a custom matrix of regularisation conditions. In this case, start with an empty matrix L (argument regmode=kRegModeNone in the constructor) ; Definition at line 2025 of file TUnfold.cxx. ScanLcurve(). Int_t TUnfold::ScanLcurve ; (; Int_t; nPoint, . Double_t; tauMin, . Double_t; tauMax, . TGraph **; lCurve, . TSpline **; logTauX = nullptr, . TSpline **; logTauY = nullptr, . TSpline **; logTauCurvature = nullptr. ). virtual . scan the L curve, determine tau and unfold at the final value of tau ; Parameters. [in]nPointnumber of points used for the scan ; [in]tauMinsmallest tau value to study ; [in]tauMaxlargest tau value to study. If tauMin=tauMax=nullptr, a scan interval is determined automatically. ; [out]lCurveif nonzero, a new TGraph is returned, containing the L-curve ; [out]logTauXif nonzero, a new TSpline is returned, to parameterize the L-curve's x-coordinates as a function of log10(tau) ; [out]logTauYif nonzero, a new TSpline is returned, to parameterize the L-curve's y-coordinates as a function of log10(tau) ; [out]logTauCurvatureif nonzero, a new TSpline is returned of the L-curve curvature as a function of log10(tau). return value: the coordinate number in the logTauX,logTauY graphs corresponding to the ""final"" choice of tau; Recommendation: always check logTauCurvature, it should be a peaked",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTUnfold.html:54449,log,logTauX,54449,doc/master/classTUnfold.html,https://root.cern,https://root.cern/doc/master/classTUnfold.html,1,['log'],['logTauX']
Testability,"nt text. The macro requires OpenGL or Web-based canvas. ; //Includes for ACLiC (cling does not need them).; #include ""TPaveText.h""; #include ""TCanvas.h""; #include ""TRandom.h""; #include ""TError.h""; #include ""TColor.h""; #include ""TStyle.h""; #include ""TH1F.h""; ; void transp_text(bool gl = true); {; // 1. Create special transparent colors for both pavetext fill color and text color.; auto grayColorIndex = TColor::GetColor((Float_t) 0.8, 0.8, 0.8, 0.85);; auto blackColorIndex = TColor::GetColor((Float_t) 0., 0., 0., 0.5);; ; // 2. Create a TCanvas.; gStyle->SetCanvasPreferGL(gl);; ; auto c1 = new TCanvas(""transp_text"",""transparent text demo"", 10, 10, 900, 500);; if (!c1->UseGL() && !c1->IsWeb()); ::Warning(""transp_text"", ""to use this macro you need either OpenGL or Web"");; ; c1->SetGrid();; c1->SetBottomMargin(0.15);; ; const Int_t nx = 20;; const char *people[nx] = {""Jean"",""Pierre"",""Marie"",""Odile"",; ""Sebastien"",""Fons"",""Rene"",""Nicolas"",""Xavier"",""Greg"",; ""Bjarne"",""Anton"",""Otto"",""Eddy"",""Peter"",""Pasha"",; ""Philippe"",""Suzanne"",""Jeff"",""Valery""};; ; auto h = new TH1F(""h4"", ""test"", nx, 0, nx);; ; h->SetFillColor(38);; for (Int_t i = 0; i < 5000; ++i); h->Fill(gRandom->Gaus(0.5 * nx, 0.2 * nx));; ; h->SetStats(false);; for (Int_t i = 1; i <= nx; ++i); h->GetXaxis()->SetBinLabel(i, people[i - 1]);; ; h->Draw();; ; auto pt = new TPaveText(0.3, 0.3, 0.98, 0.98, ""brNDC"");; //Transparent 'rectangle' with transparent text.; pt->SetFillColor(grayColorIndex);; pt->SetTextColor(blackColorIndex);; ; pt->SetTextSize(0.5);; pt->SetTextAlign(12);; ; pt->AddText(""Hello"");; pt->Draw();; }; h#define h(i)Definition RSha256.hxx:106; Int_tint Int_tDefinition RtypesCore.h:45; Float_tfloat Float_tDefinition RtypesCore.h:57; TCanvas.h; TColor.h; TError.h; Warningvoid Warning(const char *location, const char *msgfmt,...)Use this function in warning situations.Definition TError.cxx:229; TH1F.h; TPaveText.h; TRandom.h; gRandomR__EXTERN TRandom * gRandomDefinition TRandom.h:62; TStyle.h; gStyleR__EXTERN T",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/gl_2transp__text_8C.html:1384,test,test,1384,doc/master/gl_2transp__text_8C.html,https://root.cern,https://root.cern/doc/master/gl_2transp__text_8C.html,1,['test'],['test']
Testability,"nt(""u"");; 686 ; 687 // enable again intput handler; 688 fInputHandler->Activate();; 689 ; 690 if (!sline.BeginsWith("".reset"")); 691 gCling->EndOfLineAction();; 692 ; 693 gTabCom->ClearAll();; 694 Getlinem(kInit, GetPrompt());; 695 }; 696 return kTRUE;; 697}; 698 ; 699////////////////////////////////////////////////////////////////////////////////; 700/// Handle signals (kSigBus, kSigSegmentationViolation,; 701/// kSigIllegalInstruction and kSigFloatingException) trapped in TSystem.; 702/// Specific TApplication implementations may want something different here.; 703 ; 704void TRint::HandleException(Int_t sig); 705{; 706 fCaughtSignal = sig;; 707 if (TROOT::Initialized()) {; 708 if (gException) {; 709 Getlinem(kCleanUp, nullptr);; 710 Getlinem(kInit, ""Root > "");; 711 }; 712 }; 713 TApplication::HandleException(sig);; 714}; 715 ; 716////////////////////////////////////////////////////////////////////////////////; 717/// Terminate the application. Reset the terminal to sane mode and call; 718/// the logoff macro defined via Rint.Logoff environment variable.; 719/// @note The function does not return, unless the class has; 720/// been told to return from Run(), by a call to SetReturnFromRun().; 721 ; 722void TRint::Terminate(Int_t status); 723{; 724 Getlinem(kCleanUp, nullptr);; 725 ; 726 if (ReturnFromRun()) {; 727 gSystem->ExitLoop();; 728 } else {; 729 delete gTabCom;; 730 gTabCom = nullptr;; 731 ; 732 //Execute logoff macro; 733 const char *logoff;; 734 logoff = gEnv->GetValue(""Rint.Logoff"", (char*)nullptr);; 735 if (logoff && !NoLogOpt()) {; 736 char *mac = gSystem->Which(TROOT::GetMacroPath(), logoff, kReadPermission);; 737 if (mac); 738 ProcessFile(logoff);; 739 delete [] mac;; 740 }; 741 ; 742 TApplication::Terminate(status);; 743 }; 744}; 745 ; 746////////////////////////////////////////////////////////////////////////////////; 747/// Set console mode:; 748///; 749/// mode = kTRUE - echo input symbols; 750/// mode = kFALSE - noecho input symbols; 751 ; 752void ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TRint_8cxx_source.html:24597,log,logoff,24597,doc/master/TRint_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TRint_8cxx_source.html,1,['log'],['logoff']
Testability,"nt(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tRooAbsPdf::mustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; const char*RooAbsPdf::normRange() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooBifurGauss&operator=(const RooBifurGauss&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsPdf::paramOn(RooPlot* frame, const RooAbsData* data, const char* label = """", Int_t sigDigits = 2, Option_t* options = ""NELU"", Double_t xmin = 0.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooBifurGauss.html:23118,test,testArg,23118,root/html602/RooBifurGauss.html,https://root.cern,https://root.cern/root/html602/RooBifurGauss.html,2,['test'],['testArg']
Testability,"nt(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tRooAbsPdf::mustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; const char*RooAbsPdf::normRange() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooEfficiency&operator=(const RooEfficiency&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsPdf::paramOn(RooPlot* frame, const RooAbsData* data, const char* label = """", Int_t sigDigits = 2, Option_t* options = ""NELU"", Double_t xmin = 0.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooEfficiency.html:23442,test,testArg,23442,root/html602/RooEfficiency.html,https://root.cern,https://root.cern/root/html602/RooEfficiency.html,2,['test'],['testArg']
Testability,"nt(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tRooAbsPdf::mustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; const char*RooAbsPdf::normRange() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooFFTConvPdf&operator=(const RooFFTConvPdf&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsPdf::paramOn(RooPlot* frame, const RooAbsData* data, const char* label = """", Int_t sigDigits = 2, Option_t* options = ""NELU"", Double_t xmin = 0.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooFFTConvPdf.html:27957,test,testArg,27957,root/html602/RooFFTConvPdf.html,https://root.cern,https://root.cern/root/html602/RooFFTConvPdf.html,2,['test'],['testArg']
Testability,"nt(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tRooAbsPdf::mustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; const char*RooAbsPdf::normRange() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooGenericPdf&operator=(const RooGenericPdf&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsPdf::paramOn(RooPlot* frame, const RooAbsData* data, const char* label = """", Int_t sigDigits = 2, Option_t* options = ""NELU"", Double_t xmin = 0.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooGenericPdf.html:23835,test,testArg,23835,root/html602/RooGenericPdf.html,https://root.cern,https://root.cern/root/html602/RooGenericPdf.html,2,['test'],['testArg']
Testability,"nt(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tRooAbsPdf::mustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; const char*RooAbsPdf::normRange() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooNumConvPdf&operator=(const RooNumConvPdf&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsPdf::paramOn(RooPlot* frame, const RooAbsData* data, const char* label = """", Int_t sigDigits = 2, Option_t* options = ""NELU"", Double_t xmin = 0.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooNumConvPdf.html:25476,test,testArg,25476,root/html602/RooNumConvPdf.html,https://root.cern,https://root.cern/root/html602/RooNumConvPdf.html,2,['test'],['testArg']
Testability,"nt(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tRooAbsPdf::mustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; const char*RooAbsPdf::normRange() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooPolynomial&operator=(const RooPolynomial&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsPdf::paramOn(RooPlot* frame, const RooAbsData* data, const char* label = """", Int_t sigDigits = 2, Option_t* options = ""NELU"", Double_t xmin = 0.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooPolynomial.html:23298,test,testArg,23298,root/html602/RooPolynomial.html,https://root.cern,https://root.cern/root/html602/RooPolynomial.html,2,['test'],['testArg']
Testability,"nt(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tRooAbsPdf::mustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; const char*RooAbsPdf::normRange() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooRealSumPdf&operator=(const RooRealSumPdf&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsPdf::paramOn(RooPlot* frame, const RooAbsData* data, const char* label = """", Int_t sigDigits = 2, Option_t* options = ""NELU"", Double_t xmin = 0.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooRealSumPdf.html:23620,test,testArg,23620,root/html602/RooRealSumPdf.html,https://root.cern,https://root.cern/root/html602/RooRealSumPdf.html,2,['test'],['testArg']
Testability,"nt); virtual Bool_tTGWindow::HandleExpose(Event_t* event); virtual Bool_tHandleFocusChange(Event_t* event); virtual Bool_tTGWindow::HandleIdleEvent(TGIdleHandler*); virtual Bool_tHandleKey(Event_t* event); virtual Bool_tTGTextEntry::HandleMotion(Event_t* event); virtual Bool_tTGTextEntry::HandleSelection(Event_t* event); virtual Bool_tTGTextEntry::HandleSelectionClear(Event_t* event); virtual Bool_tTGTextEntry::HandleSelectionRequest(Event_t* event); virtual Bool_tTGTextEntry::HandleTimer(TTimer* t); virtual Bool_tTQObject::HasConnection(const char* signal_name) const; Bool_tTGWidget::HasFocus() const; virtual ULong_tTGObject::Hash() const; Bool_tTGTextEntry::HasMarkedText() const; Bool_tTGTextEntry::HasOwnFont() const; virtual voidTQObject::HighPriority(const char* signal_name, const char* slot_name = 0); voidTGTextEntry::Home(Bool_t mark = kFALSE); virtual voidTGWindow::IconifyWindow(); virtual voidIncreaseNumber(TGNumberFormat::EStepSize step = kNSSSmall, Int_t sign = 1, Bool_t logstep = kFALSE); virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTGTextEntry::Insert(const char*); virtual voidTGTextEntry::InsertText(const char* text, Int_t pos); virtual voidTGFrame::Inspect() const; virtual voidInvalidInput(const char* instr)SIGNAL ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTGFrame::IsActive() const; virtual Bool_tTGFrame::IsComposite() const; Bool_tTGFrame::IsDNDSource() const; Bool_tTGFrame::IsDNDTarget() const; virtual Bool_tIsEditable() const; Bool_tTGTextEntry::IsEdited() const; Bool_tTGWidget::IsEnabled() const; virtual Bool_tTGObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTGTextEntry::IsFrameDrawn() const; virtual Bool_tTGFrame::IsLayoutBroken() const; virtual Bool_tIsLogStep() const; virtual Bool_tTGWindow::IsMapped(); v",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGNumberEntryField.html:13206,log,logstep,13206,root/html528/TGNumberEntryField.html,https://root.cern,https://root.cern/root/html528/TGNumberEntryField.html,6,['log'],['logstep']
Testability,"nt, Double_t x, Double_t y); Insert a new point with coordinates (x,y) before the point number ipoint. ; ; virtual Double_tIntegral (Int_t first=0, Int_t last=-1) const; Integrate the TGraph data within a given (index) range. ; ; virtual Bool_tIsEditable () const; ; virtual Bool_tIsHighlight () const; ; virtual Int_tIsInside (Double_t x, Double_t y) const; Return 1 if the point (x,y) is inside the polygon defined by the graph vertices 0 otherwise. ; ; virtual voidLeastSquareFit (Int_t m, Double_t *a, Double_t xmin=0, Double_t xmax=0); Least squares polynomial fitting without weights. ; ; virtual voidLeastSquareLinearFit (Int_t n, Double_t &a0, Double_t &a1, Int_t &ifail, Double_t xmin=0, Double_t xmax=0); Least square linear fit without weights. ; ; virtual Int_tMerge (TCollection *list); Adds all graphs from the collection to this graph. ; ; virtual voidMovePoints (Double_t dx, Double_t dy, Bool_t logx=kFALSE, Bool_t logy=kFALSE); Move all graph points on specified values dx,dy If log argument specified, calculation done in logarithmic scale like: new_value = exp( log(old_value) + delta );. ; ; TGraph &operator= (const TGraph &); Equal operator for this graph. ; ; voidPaint (Option_t *chopt="""") override; Draw this graph with its current attributes. ; ; voidPaintGraph (Int_t npoints, const Double_t *x, const Double_t *y, Option_t *chopt); Draw the (x,y) as a graph. ; ; voidPaintGrapHist (Int_t npoints, const Double_t *x, const Double_t *y, Option_t *chopt); Draw the (x,y) as a histogram. ; ; virtual voidPaintStats (TF1 *fit); Draw the stats. ; ; voidPrint (Option_t *chopt="""") const override; Print graph values. ; ; voidRecursiveRemove (TObject *obj) override; Recursively remove object from the list of functions. ; ; virtual Int_tRemovePoint (); Delete point close to the mouse position Returns index of removed point (or -1 if nothing was changed) ; ; virtual Int_tRemovePoint (Int_t ipoint); Delete point number ipoint R",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGraphQQ.html:12286,log,logx,12286,doc/master/classTGraphQQ.html,https://root.cern,https://root.cern/doc/master/classTGraphQQ.html,5,['log'],"['log', 'logarithmic', 'logx', 'logy']"
Testability,"nt, Double_t x, Double_t y); Insert a new point with coordinates (x,y) before the point number ipoint. ; ; virtual Double_tIntegral (Int_t first=0, Int_t last=-1) const; Integrate the TGraph data within a given (index) range. ; ; virtual Bool_tIsEditable () const; ; virtual Bool_tIsHighlight () const; ; virtual Int_tIsInside (Double_t x, Double_t y) const; Return 1 if the point (x,y) is inside the polygon defined by the graph vertices 0 otherwise. ; ; virtual voidLeastSquareFit (Int_t m, Double_t *a, Double_t xmin=0, Double_t xmax=0); Least squares polynomial fitting without weights. ; ; virtual voidLeastSquareLinearFit (Int_t n, Double_t &a0, Double_t &a1, Int_t &ifail, Double_t xmin=0, Double_t xmax=0); Least square linear fit without weights. ; ; virtual Int_tMerge (TCollection *list); Adds all graphs from the collection to this graph. ; ; virtual voidMovePoints (Double_t dx, Double_t dy, Bool_t logx=kFALSE, Bool_t logy=kFALSE); Move all graph points on specified values dx,dy If log argument specified, calculation done in logarithmic scale like: new_value = exp( log(old_value) + delta );. ; ; TGraph &operator= (const TGraph &); Equal operator for this graph. ; ; voidPaint (Option_t *chopt="""") override; Draw this graph with its current attributes. ; ; voidPaintGraph (Int_t npoints, const Double_t *x, const Double_t *y, Option_t *chopt); Draw the (x,y) as a graph. ; ; voidPaintGrapHist (Int_t npoints, const Double_t *x, const Double_t *y, Option_t *chopt); Draw the (x,y) as a histogram. ; ; virtual voidPaintStats (TF1 *fit); Draw the stats. ; ; voidRecursiveRemove (TObject *obj) override; Recursively remove object from the list of functions. ; ; virtual Int_tRemovePoint (); Delete point close to the mouse position Returns index of removed point (or -1 if nothing was changed) ; ; virtual Int_tRemovePoint (Int_t ipoint); Delete point number ipoint Returns index of removed point (or -1 if nothing was changed) ; ; voidSav",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGraphBentErrors.html:12491,log,logx,12491,doc/master/classTGraphBentErrors.html,https://root.cern,https://root.cern/doc/master/classTGraphBentErrors.html,10,['log'],"['log', 'logarithmic', 'logx', 'logy']"
Testability,"nt, const char* childname = 0); get child node. void* GetNextChild(void* prevchild, const char* childname = 0); XML helpers. const char* GetContent(void* node); XML helpers. const char* GetName(void* node); XML helpers. Bool_t AddRawLine(void* node, const char* raw); XML helpers. std::vector<TString> SplitString(const TString& theOpt, const char separator) const; splits the option string at 'separator' and fills the list; 'splitV' with the primitive strings. TString StringFromInt(Long_t i); string tools. TString StringFromDouble(Double_t d); string tools. void WriteTMatrixDToXML(void* node, const char* name, TMatrixD* mat); XML helpers. void WriteTVectorDToXML(void* node, const char* name, TVectorD* vec). void ReadTVectorDFromXML(void* node, const char* name, TVectorD* vec). void ReadTMatrixDFromXML(void* node, const char* name, TMatrixD* mat). void TMVAWelcomeMessage(); direct output, eg, when starting ROOT session -> no use of Logger here. void TMVAVersionMessage(TMVA::MsgLogger& logger); prints the TMVA release number and date. void ROOTVersionMessage(TMVA::MsgLogger& logger); prints the ROOT release number and date. void TMVAWelcomeMessage(TMVA::MsgLogger& logger, TMVA::Tools::EWelcomeMessage m = kStandardWelcomeMsg); various kinds of welcome messages; ASCII text generated by this site: http://www.network-science.de/ascii. void TMVACitation(TMVA::MsgLogger& logger, TMVA::Tools::ECitation citType = kPlainText); kinds of TMVA citation. Bool_t HistoHasEquidistantBins(const TH1& h). CalcCovarianceMatrices( const std::vector<const Event*>& events, Int_t maxCls, VariableTransformBase* transformBase ). CalcCovarianceMatrices( const std::vector<Event*>& events, Int_t maxCls, VariableTransformBase* transformBase ); compute covariance matrices. TH1* GetCumulativeDist(TH1* h); get the cumulative distribution of a histogram. Double_t ComputeVariance(Double_t sumx2, Double_t sumx, Int_t nx). Tools(). TXMLEngine& xmlengine(); { return *fXMLEngine; }. int xmlenginebuffersize();",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TMVA__Tools.html:11872,log,logger,11872,root/html534/TMVA__Tools.html,https://root.cern,https://root.cern/root/html534/TMVA__Tools.html,3,['log'],['logger']
Testability,"nt, const char* childname = 0); get child node. void* GetNextChild(void* prevchild, const char* childname = 0); XML helpers. const char* GetContent(void* node); XML helpers. const char* GetName(void* node); XML helpers. Bool_t AddRawLine(void* node, const char* raw); XML helpers. std::vector<TString> SplitString(const TString& theOpt, const char separator) const; splits the option string at 'separator' and fills the list; 'splitV' with the primitive strings. TString StringFromInt(Long_t i); string tools. TString StringFromDouble(Double_t d); string tools. void WriteTMatrixDToXML(void* node, const char* name, TMatrixD* mat); XML helpers. void WriteTVectorDToXML(void* node, const char* name, TVectorD* vec). void ReadTVectorDFromXML(void* node, const char* name, TVectorD* vec). void ReadTMatrixDFromXML(void* node, const char* name, TMatrixD* mat). void TMVAWelcomeMessage(); direct output, eg, when starting ROOT session -> no use of Logger here. void TMVAVersionMessage(TMVA::MsgLogger& logger); prints the TMVA release number and date. void ROOTVersionMessage(TMVA::MsgLogger& logger); prints the ROOT release number and date. void TMVAWelcomeMessage(TMVA::MsgLogger& logger, TMVA::Tools::EWelcomeMessage m = kStandardWelcomeMsg); various kinds of welcome messages; ASCII text generated by this site: http://www.network-science.de/ascii. void TMVACitation(TMVA::MsgLogger& logger, TMVA::Tools::ECitation citType = kPlainText); kinds of TMVA citation. Bool_t HistoHasEquidistantBins(const TH1& h). CalcCovarianceMatrices(const vector<TMVA::Event*,allocator<TMVA::Event*> >& events, Int_t maxCls, TMVA::VariableTransformBase* transformBase = 0); compute covariance matrices. Double_t ComputeVariance(Double_t sumx2, Double_t sumx, Int_t nx). Tools(). TXMLEngine& xmlengine(); { return *fXMLEngine; }.  Author: Andreas Hoecker, Joerg Stelzer, Helge Voss, Kai Voss  Copyright (c) 2005: *;  Last changed: root/tmva $Id: Tools.h 40005 2011-06-27 15:29:10Z stelzer $  Last generated: 2011-11-0",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TMVA__Tools.html:11638,log,logger,11638,root/html532/TMVA__Tools.html,https://root.cern,https://root.cern/root/html532/TMVA__Tools.html,1,['log'],['logger']
Testability,"nt, const char* childname = 0); get child node. void* GetNextChild(void* prevchild, const char* childname = 0); XML helpers. const char* GetContent(void* node); XML helpers. const char* GetName(void* node); XML helpers. Bool_t AddRawLine(void* node, const char* raw); XML helpers. std::vector<TString> SplitString(const TString& theOpt, const char separator) const; splits the option string at 'separator' and fills the list; 'splitV' with the primitive strings. TString StringFromInt(Long_t i); string tools. TString StringFromDouble(Double_t d); string tools. void WriteTMatrixDToXML(void* node, const char* name, TMatrixD* mat); XML helpers. void WriteTVectorDToXML(void* node, const char* name, TVectorD* vec). void ReadTVectorDFromXML(void* node, const char* name, TVectorD* vec). void ReadTMatrixDFromXML(void* node, const char* name, TMatrixD* mat). void TMVAWelcomeMessage(); direct output, eg, when starting ROOT session -> no use of Logger here. void TMVAVersionMessage(TMVA::MsgLogger& logger); prints the TMVA release number and date. void ROOTVersionMessage(TMVA::MsgLogger& logger); prints the ROOT release number and date. void TMVAWelcomeMessage(TMVA::MsgLogger& logger, TMVA::Tools::EWelcomeMessage m = kStandardWelcomeMsg); various kinds of welcome messages; ASCII text generated by this site: http://www.network-science.de/ascii. void TMVACitation(TMVA::MsgLogger& logger, TMVA::Tools::ECitation citType = kPlainText); kinds of TMVA citation. Bool_t HistoHasEquidistantBins(const TH1& h). CalcCovarianceMatrices(const vector<TMVA::Event*,allocator<TMVA::Event*> >& events, Int_t maxCls, TMVA::VariableTransformBase* transformBase = 0); compute covariance matrices. Double_t ComputeVariance(Double_t sumx2, Double_t sumx, Int_t nx). Tools(). TXMLEngine& xmlengine(); { return *fXMLEngine; }.  Author: Andreas Hoecker, Joerg Stelzer, Helge Voss, Kai Voss  Copyright (c) 2005: *;  Last changed: root/tmva $Id: Tools.h 40012 2011-06-27 16:03:11Z stelzer $  Last generated: 2011-07-0",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TMVA__Tools.html:11638,log,logger,11638,root/html530/TMVA__Tools.html,https://root.cern,https://root.cern/root/html530/TMVA__Tools.html,1,['log'],['logger']
Testability,nt.h; src; TODBCResult.cxx; TODBCRow.cxx; TODBCServer.cxx; TODBCStatement.cxx; oracle; inc; TOracleResult.h; TOracleRow.h; TOracleServer.h; TOracleStatement.h; src; TOracleResult.cxx; TOracleRow.cxx; TOracleServer.cxx; TOracleStatement.cxx; pgsql; inc; TPgSQLResult.h; TPgSQLRow.h; TPgSQLServer.h; TPgSQLStatement.h; src; TPgSQLResult.cxx; TPgSQLRow.cxx; TPgSQLServer.cxx; TPgSQLStatement.cxx; sapdb; inc; TSapDBResult.h; TSapDBRow.h; TSapDBServer.h; src; TSapDBResult.cxx; TSapDBRow.cxx; TSapDBServer.cxx; sqlite; inc; TSQLiteResult.h; TSQLiteRow.h; TSQLiteServer.h; TSQLiteStatement.h; src; TSQLiteResult.cxx; TSQLiteRow.cxx; TSQLiteServer.cxx; TSQLiteStatement.cxx; tmva; pymva; inc; TMVA; MethodPyAdaBoost.h; MethodPyGTB.h; MethodPyKeras.h; MethodPyRandomForest.h; PyMethodBase.h; src; MethodPyAdaBoost.cxx; MethodPyGTB.cxx; MethodPyKeras.cxx; MethodPyRandomForest.cxx; PyMethodBase.cxx; test; Classification.C; testPyAdaBoostClassification.C; testPyAdaBoostMulticlass.C; testPyGTBClassification.C; testPyGTBMulticlass.C; testPyKerasClassification.C; testPyKerasMulticlass.C; testPyKerasRegression.C; testPyRandomForestClassification.C; testPyRandomForestMulticlass.C; rmva; inc; TMVA; MethodC50.h; MethodRSNNS.h; MethodRSVM.h; MethodRXGB.h; RMethodBase.h; src; MethodC50.cxx; MethodRSNNS.cxx; MethodRSVM.cxx; MethodRXGB.cxx; RMethodBase.cxx; test; Classification.C; tmva; inc; TMVA; DNN; Architectures; Cpu; Blas.h; CpuBuffer.h; CpuMatrix.h; Cuda; CudaBuffers.h; CudaMatrix.h; Device.h; Cpu.h; Cuda.h; Reference.h; DataLoader.h; Functions.h; Layer.h; Minimizers.h; Net.h; BDTEventWrapper.h; BinarySearchTree.h; BinarySearchTreeNode.h; BinaryTree.h; CCPruner.h; CCTreeWrapper.h; ClassifierFactory.h; ClassInfo.h; Config.h; Configurable.h; ConvergenceTest.h; CostComplexityPruneTool.h; CrossEntropy.h; CrossVali,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v610/files.html:85074,test,test,85074,doc/v610/files.html,https://root.cern,https://root.cern/doc/v610/files.html,1,['test'],['test']
Testability,"ntCheckSum); 1014 || info->MatchLegacyCheckSum(fCheckSum); 1015 || GetCheckSum(TClass::kCurrentCheckSum) == info->fCheckSum; 1016 || MatchLegacyCheckSum(info->GetCheckSum()); 1017 || GetCheckSum(TClass::kCurrentCheckSum) == info->GetCheckSum(TClass::kCurrentCheckSum)); 1018 {; 1019 match = kTRUE;; 1020 }; 1021 if (fOldVersion <= 2) {; 1022 // Names of STL base classes was modified in vers==3. Allocators removed; 1023 // (We could be more specific (see test for the same case below); 1024 match = kTRUE;; 1025 }; 1026 if (!match && CompareContent(0,info,kFALSE,kFALSE,file)) {; 1027 match = kTRUE;; 1028 }; 1029 }; 1030 }; 1031 if (info->IsBuilt()) {; 1032 SetBit(kCanDelete);; 1033 fNumber = info->GetNumber();; 1034 Int_t nel = fElements->GetEntriesFast();; 1035 TObjArray* elems = info->GetElements();; 1036 TStreamerElement* e1 = 0;; 1037 TStreamerElement* e2 = 0;; 1038 for (Int_t i = 0; i < nel; ++i) {; 1039 e1 = (TStreamerElement*) fElements->UncheckedAt(i);; 1040 e2 = (TStreamerElement*) elems->At(i);; 1041 if (!e1 || !e2) {; 1042 continue;; 1043 }; 1044 if (strlen(e1->GetTitle()) != strlen(e2->GetTitle())) {; 1045 e2->SetTitle(e1->GetTitle());; 1046 }; 1047 }; 1048 ; 1049 done = kTRUE;; 1050 } else {; 1051 fClass->RemoveStreamerInfo(fClassVersion);; 1052 info = 0;; 1053 }; 1054 TString origin;; 1055 if (!match && !fClass->TestBit(TClass::kWarned)) {; 1056 if (oldIsNonVersioned) {; 1057 if (file) {; 1058 Warning(""BuildCheck"", ""\n\; 1059 The class %s transitioned from not having a specified class version\n\; 1060 to having a specified class version (the current class version is %d).\n\; 1061 However too many different non-versioned layouts of the class have been\n\; 1062 loaded so far. This prevent the proper reading of objects written with\n\; 1063 the class layout version %d, in particular from the file:\n\; 1064 %s.\n\; 1065 To work around this issue, load fewer 'old' files in the same ROOT session."",; 1066 GetName(),fClass->GetClassVersion(),fClassVersion,file->GetN",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html:38302,test,test,38302,doc/master/TStreamerInfo_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html,1,['test'],['test']
Testability,"ntCompactTreeHook(ostream& os, const char* indent = """"); Add extra information on component test statistics when printing; itself as part of a tree structure. void constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); Forward constant term optimization management calls to component; test statistics. void setMPSet(Int_t setNum, Int_t numSets); Set MultiProcessor set number identification of this instance. void initMPMode(RooAbsReal* real, RooAbsData* data, const RooArgSet* projDeps, const char* rangeName, const char* addCoefRangeName); Initialize multi-processor calculation mode. Create component test statistics in separate; processed that are connected to this process through a RooAbsRealMPFE front-end class. void initSimMode(RooSimultaneous* pdf, RooAbsData* data, const RooArgSet* projDeps, const char* rangeName, const char* addCoefRangeName); Initialize simultaneous p.d.f processing mode. Strip simultaneous; p.d.f into individual components, split dataset in subset; matching each component and create component test statistics for; each of them. Bool_t setData(RooAbsData& data, Bool_t cloneData = kTRUE); Change dataset that is used to given one. If cloneData is kTRUE, a clone of; in the input dataset is made. If the test statistic was constructed with; a range specification on the data, the cloneData argument is ignore and; the data is always cloned. RooAbsTestStatistic* create(const char* name, const char* title, RooAbsReal& real, RooAbsData& data, const RooArgSet& projDeps, const char* rangeName = 0, const char* addCoefRangeName = 0, Int_t nCPU = 1, Bool_t interleave = kFALSE, Bool_t verbose = kTRUE, Bool_t splitCutRange = kFALSE). Double_t combinedValue(RooAbsReal** gofArray, Int_t nVal) const. Double_t globalNormalization() const; Default value of global normalization factor is 1.0. Double_t evaluatePartition(Int_t firstEvent, Int_t lastEvent, Int_t stepSize) const. void setSimCount(Int_t simCount); Store total number of components p.d.f. of a RooSimultane",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooAbsTestStatistic.html:37915,test,test,37915,root/html530/RooAbsTestStatistic.html,https://root.cern,https://root.cern/root/html530/RooAbsTestStatistic.html,1,['test'],['test']
Testability,"ntCompactTreeHook(ostream& os, const char* indent = """"); Add extra information on component test statistics when printing; itself as part of a tree structure. void constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); Forward constant term optimization management calls to component; test statistics. void setMPSet(Int_t setNum, Int_t numSets); Set MultiProcessor set number identification of this instance. void initMPMode(RooAbsReal* real, RooAbsData* data, const RooArgSet* projDeps, const char* rangeName, const char* addCoefRangeName); Initialize multi-processor calculation mode. Create component test statistics in separate; processed that are connected to this process through a RooAbsRealMPFE front-end class. void initSimMode(RooSimultaneous* pdf, RooAbsData* data, const RooArgSet* projDeps, const char* rangeName, const char* addCoefRangeName); Initialize simultaneous p.d.f processing mode. Strip simultaneous; p.d.f into individual components, split dataset in subset; matching each component and create component test statistics for; each of them. RooAbsTestStatistic* create(const char* name, const char* title, RooAbsReal& real, RooAbsData& data, const RooArgSet& projDeps, const char* rangeName = 0, const char* addCoefRangeName = 0, Int_t nCPU = 1, Bool_t interleave = kFALSE, Bool_t verbose = kTRUE, Bool_t splitCutRange = kFALSE). Double_t combinedValue(RooAbsReal** gofArray, Int_t nVal) const. Double_t globalNormalization() const; Default value of global normalization factor is 1.0. Double_t evaluatePartition(Int_t firstEvent, Int_t lastEvent, Int_t stepSize) const. void setSimCount(Int_t simCount); Store total number of components p.d.f. of a RooSimultaneous in this component test statistic. void setEventCount(Int_t nEvents); Store total number of events in this component test statistic. Int_t numSets() const; Return total number of sets for parallel calculation. Int_t setNum() const; Return parallel calculation set number for this instance. GOFOpMode operMode",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAbsTestStatistic.html:37097,test,test,37097,root/html526/RooAbsTestStatistic.html,https://root.cern,https://root.cern/root/html526/RooAbsTestStatistic.html,2,['test'],['test']
Testability,"ntCounts.nEvAfterCut++;; 976 classEventCounts.nWeEvAfterCut += weight;; 977 ; 978 // event accepted, fill temporary ntuple; 979 event_v.push_back(new Event(vars, tgts , vis, cl , weight));; 980 }; 981 }; 982 currentInfo.GetTree()->ResetBranchAddresses();; 983 }; 984 }; 985 ; 986 if (!nanInfWarnings.empty()) {; 987 Log() << kWARNING << ""Found events with NaN and/or +-inf values"" << Endl;; 988 for (const auto &warning : nanInfWarnings) {; 989 auto &log = Log() << kWARNING << warning.first;; 990 if (warning.second > 1) log << "" ("" << warning.second << "" times)"";; 991 log << Endl;; 992 }; 993 Log() << kWARNING << ""These NaN and/or +-infs were all removed by the specified cut, continuing."" << Endl;; 994 Log() << Endl;; 995 }; 996 ; 997 if (!nanInfErrors.empty()) {; 998 Log() << kWARNING << ""Found events with NaN and/or +-inf values (not removed by cut)"" << Endl;; 999 for (const auto &error : nanInfErrors) {; 1000 auto &log = Log() << kWARNING << error.first;; 1001 if (error.second > 1) log << "" ("" << error.second << "" times)"";; 1002 log << Endl;; 1003 }; 1004 Log() << kFATAL << ""How am I supposed to train a NaN or +-inf?!"" << Endl;; 1005 }; 1006 ; 1007 // for output format, get the maximum class name length; 1008 Int_t maxL = dsi.GetClassNameMaxLength();; 1009 ; 1010 Log() << kHEADER << Form(""[%s] : "",dsi.GetName()) << ""Number of events in input trees"" << Endl;; 1011 Log() << kDEBUG << ""(after possible flattening of arrays):"" << Endl;; 1012 ; 1013 ; 1014 for (UInt_t cl = 0; cl < dsi.GetNClasses(); cl++) {; 1015 Log() << kDEBUG //<< Form(""[%s] : "",dsi.GetName()); 1016 << "" ""; 1017 << setiosflags(ios::left) << std::setw(maxL) << dsi.GetClassInfo(cl)->GetName(); 1018 << "" -- number of events : ""; 1019 << std::setw(5) << eventCounts[cl].nEvBeforeCut; 1020 << "" / sum of weights: "" << std::setw(5) << eventCounts[cl].nWeEvBeforeCut << Endl;; 1021 }; 1022 ; 1023 for (UInt_t cl = 0; cl < dsi.GetNClasses(); cl++) {; 1024 Log() << kDEBUG //<< Form(""Dataset[%s] : "",dsi.GetName()); 10",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/DataSetFactory_8cxx_source.html:42581,log,log,42581,doc/master/DataSetFactory_8cxx_source.html,https://root.cern,https://root.cern/doc/master/DataSetFactory_8cxx_source.html,1,['log'],['log']
Testability,"ntDescent< Architecture_t > Class Template Reference. ; ROOT ; . master. Reference Guide ; . . Loading...; Searching...; No Matches. List of all members |; Public Types |; Public Member Functions |; Private Attributes |; List of all members ; TMVA::DNN::TDLGradientDescent< Architecture_t > Class Template Reference. ; template<typename Architecture_t>; class TMVA::DNN::TDLGradientDescent< Architecture_t >; Definition at line 65 of file DLMinimizers.h. Public Types; usingDeepNet_t = TDeepNet< Architecture_t >; ; usingMatrix_t = typename Architecture_t::Matrix_t; ; usingScalar_t = typename Architecture_t::Scalar_t; . Public Member Functions; TDLGradientDescent (); ; TDLGradientDescent (Scalar_t learningRate, size_t convergenceSteps, size_t testInterval); ; size_tGetConvergenceCount () const; Getters. ; ; size_tGetConvergenceSteps () const; ; Scalar_tGetTestError () const; ; size_tGetTestInterval () const; ; Scalar_tGetTrainingError () const; ; boolHasConverged (); Increases the minimization step counter by the test error evaluation period and uses the current internal value of the test error to determine if the minimization has converged. ; ; boolHasConverged (Scalar_t testError); Increases the minimization step counter by the test error evaluation period and uses the provided test error value to determine if the minimization has converged. ; ; voidReset (); Reset minimizer object to default state. ; ; voidSetBatchSize (Scalar_t rate); ; voidSetConvergenceSteps (size_t steps); Setters. ; ; voidSetLearningRate (Scalar_t rate); ; voidSetTestInterval (size_t interval); ; voidStep (DeepNet_t &deepNet, std::vector< Matrix_t > &input, const Matrix_t &output, const Matrix_t &weights); Perform a single optimization step on a given batch. ; ; voidStep (DeepNet_t &master, std::vector< DeepNet_t > &nets, std::vector< TTensorBatch< Architecture_t > > &batches); Perform multiple optimization steps simultaneously. ; ; Scalar_tStepLoss ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1DNN_1_1TDLGradientDescent.html:1076,test,test,1076,doc/master/classTMVA_1_1DNN_1_1TDLGradientDescent.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1DNN_1_1TDLGradientDescent.html,2,['test'],['test']
Testability,"ntDist(TF1* func = 0, unsigned int dim = 0, bool isLogPdf = false); virtual~TUnuranMultiContDist(); static TClass*Class(); virtual TUnuranMultiContDist*Clone() const; doubleDerivative(const double* x, int icoord) const; const double*GetLowerDomain() const; const double*GetMode() const; const double*GetUpperDomain() const; voidGradient(const double* x, double* grad) const; virtual TClass*IsA() const; boolIsLogPdf() const; unsigned intNDim() const; TUnuranMultiContDist&operator=(const TUnuranMultiContDist& rhs); doublePdf(const double* x) const; voidSetDomain(const double* xmin, const double* xmax); voidSetMode(const double* x); virtual voidShowMembers(TMemberInspector&); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). Data Members; private:. boolfIsLogPdfflag to control if function pointer represent log of pdf; vector<double>fModevector representing the x coordinates of the maximum of the pdf ; boolfOwnFuncflag to indicate if class manages the function pointers; const ROOT::Math::IBaseFunctionMultiDim*fPdfpointer to the pdf; vector<double>fXmaxvector with upper x values of the domain ; vector<double>fXminvector with lower x values of the domain. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TUnuranMultiContDist(TF1* func = 0, unsigned int dim = 0, bool isLogPdf = false). Constructor from a TF1 object representing the Probability density function.; The derivatives of the Pdf are estimated, when required by the UNURAN algorithm,; using numerical derivation.; If a value of dim 0 is passed , the dimension of the function is taken from TF1::GetNdim().; This works only for 2D and 3D (for TF2 and TF3 objects). TUnuranMultiContDist(const ROOT::Math::IMultiGenFunction& pdf, bool isLogPdf = false). Constructor as before but from a generic function object interface for multi-dim functions. virtual ~TUnuranMultiContDist(). Destructor. TUnuranMultiContDist(const TUnuranMultiContDist& ). Copy ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TUnuranMultiContDist.html:2296,log,log,2296,root/html534/TUnuranMultiContDist.html,https://root.cern,https://root.cern/root/html534/TUnuranMultiContDist.html,1,['log'],['log']
Testability,"ntSampleDiscr(); boolSampleMulti(double* x); boolSetLogLevel(unsigned int iflag = 1); boolSetLogStream(); voidSetRandom(TRandom* r); voidSetSeed(unsigned int seed). protected:. boolSetContDistribution(const TUnuranContDist& dist); boolSetDiscreteDistribution(const TUnuranDiscrDist& dist); boolSetEmpiricalDistribution(const TUnuranEmpDist& dist); boolSetMethodAndInit(); boolSetMultiDistribution(const TUnuranMultiContDist& dist); boolSetRandomGenerator(). private:. TUnuran(const TUnuran&); TUnuran&operator=(const TUnuran& rhs). Data Members; protected:. auto_ptr<TUnuranBaseDist>fDistpointer for distribution wrapper; unur_gen*fGenpointer to the UnuRan C generator struct; stringfMethodstring representing the method; TRandom*fRngpointer to ROOT random number generator; unur_distr*fUdistrpointer to the UnuRan C distribution struct; unur_urng*fUrngpointer to Unuran C random generator struct . Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TUnuran(TRandom* r = 0, unsigned int log = 0). Constructor with a generator instance and given level of log output. ~TUnuran(). Destructor. TUnuran(const TUnuran& ); usually copying is non trivial, so we make this unaccessible. Copy constructor. bool Init(const std::string & distr, const std::string & method). initialize with Unuran string interface. bool Init(const TUnuranContDist& distr, const string& method = ""auto""). Initialize method for continuous one-dimensional distribution.; User must provide a distribution object (which is copied inside) and a string for a method.; For the list of available method for 1D cont. distribution see the; <A href=""http://statmath.wu-wien.ac.at/unuran/doc/unuran.html#Methods_005ffor_005fCONT"">UnuRan doc</A>.; A re-initialization is needed whenever distribution parameters have been changed. bool Init(const TUnuranMultiContDist& distr, const string& method = ""hitro""). Initialize method for continuous multi-dimensional distribution.; User must provide a distributi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TUnuran.html:3463,log,log,3463,root/html528/TUnuran.html,https://root.cern,https://root.cern/root/html528/TUnuran.html,4,['log'],['log']
Testability,"ntVectorTesting.erase( std::remove( eventVectorTesting.begin(), eventVectorTesting.end(), (void*)NULL ), eventVectorTesting.end() );; 1336 }; 1337 }; 1338 else { // erase at end if size larger than requested; 1339 if( eventVectorTraining.size() < UInt_t(requestedTraining) ); 1340 Log() << kWARNING << Form(""Dataset[%s] : "",dsi.GetName())<< ""DataSetFactory/requested number of training samples larger than size of eventVectorTraining.\n""; 1341 << ""There is probably an issue. Please contact the TMVA developers."" << Endl;; 1342 else if (eventVectorTraining.size() > UInt_t(requestedTraining)) {; 1343 std::for_each( eventVectorTraining.begin()+requestedTraining, eventVectorTraining.end(), DeleteFunctor<Event>() );; 1344 eventVectorTraining.erase(eventVectorTraining.begin()+requestedTraining,eventVectorTraining.end());; 1345 }; 1346 if( eventVectorTesting.size() < UInt_t(requestedTesting) ); 1347 Log() << kWARNING << Form(""Dataset[%s] : "",dsi.GetName())<< ""DataSetFactory/requested number of testing samples larger than size of eventVectorTesting.\n""; 1348 << ""There is probably an issue. Please contact the TMVA developers."" << Endl;; 1349 else if ( eventVectorTesting.size() > UInt_t(requestedTesting) ) {; 1350 std::for_each( eventVectorTesting.begin()+requestedTesting, eventVectorTesting.end(), DeleteFunctor<Event>() );; 1351 eventVectorTesting.erase(eventVectorTesting.begin()+requestedTesting,eventVectorTesting.end());; 1352 }; 1353 }; 1354 }; 1355 ; 1356 TMVA::DataSetFactory::RenormEvents( dsi, tmpEventVector, eventCounts, normMode );; 1357 ; 1358 Int_t trainingSize = 0;; 1359 Int_t testingSize = 0;; 1360 ; 1361 // sum up number of training and testing events; 1362 for( UInt_t cls = 0; cls < dsi.GetNClasses(); ++cls ){; 1363 trainingSize += tmpEventVector[Types::kTraining].at(cls).size();; 1364 testingSize += tmpEventVector[Types::kTesting].at(cls).size();; 1365 }; 1366 ; 1367 // --- collect all training (testing) events into the training (testing) eventvector; 1368 ; 1369 /",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/DataSetFactory_8cxx_source.html:60371,test,testing,60371,doc/master/DataSetFactory_8cxx_source.html,https://root.cern,https://root.cern/doc/master/DataSetFactory_8cxx_source.html,1,['test'],['testing']
Testability,"nt_t TMVA::DataLoader::fATreeType = 0. private . type of event (=classIndex) ; Definition at line 206 of file DataLoader.h. fATreeWeight. Float_t TMVA::DataLoader::fATreeWeight = 0.0. private . weight of the event ; Definition at line 207 of file DataLoader.h. fDataAssignType. DataAssignType TMVA::DataLoader::fDataAssignType. private . flags for data assigning ; Definition at line 202 of file DataLoader.h. fDataInputHandler. DataInputHandler* TMVA::DataLoader::fDataInputHandler. private . -> ; Definition at line 189 of file DataLoader.h. fDataSetManager. DataSetManager* TMVA::DataLoader::fDataSetManager. private . Definition at line 186 of file DataLoader.h. fDefaultTrfs. std::vector<TMVA::VariableTransformBase*> TMVA::DataLoader::fDefaultTrfs. private . list of transformations on default DataSet ; Definition at line 191 of file DataLoader.h. fOptions. TString TMVA::DataLoader::fOptions. private . option string given by construction (presently only ""V"") ; Definition at line 194 of file DataLoader.h. fTestAssignTree. std::vector<TTree*> TMVA::DataLoader::fTestAssignTree. private . for each class: tmp tree if user wants to assign the events directly ; Definition at line 204 of file DataLoader.h. fTrainAssignTree. std::vector<TTree*> TMVA::DataLoader::fTrainAssignTree. private . for each class: tmp tree if user wants to assign the events directly ; Definition at line 203 of file DataLoader.h. fTransformations. TString TMVA::DataLoader::fTransformations. private . List of transformations to test. ; Definition at line 195 of file DataLoader.h. fVerbose. Bool_t TMVA::DataLoader::fVerbose. private . verbose mode ; Definition at line 196 of file DataLoader.h. Libraries for TMVA::DataLoader:. [legend]; The documentation for this class was generated from the following files:; tmva/tmva/inc/TMVA/DataLoader.h; tmva/tmva/src/DataLoader.cxx. TMVADataLoader. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:45:31 (GVA Time) using Doxygen 1.9.8 ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1DataLoader.html:37792,test,test,37792,doc/master/classTMVA_1_1DataLoader.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1DataLoader.html,1,['test'],['test']
Testability,"nt_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). private:. voidUpdatePValue(const RooStats::SamplingDistribution* distr, Double_t& pvalue, Double_t& perror, Bool_t pIsRightTail). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. RooStats::SamplingDistribution*fAltDistr; Double_tfAlternatePValuep-value for the alternate hypothesis (small number means disfavored); Double_tfAlternatePValueErrorerror of p-value for the alternate hypothesis (small number means disfavored); Bool_tfBackgroundIsAlt; TStringTNamed::fNameobject identifier; RooStats::SamplingDistribution*fNullDistr; Double_tfNullPValuep-value for the null hypothesis (small number means disfavored); Double_tfNullPValueErrorerror of p-value for the null hypothesis (small number means disfavored); Bool_tfPValueIsRightTail; Double_tfTestStatisticDataresult of the test statistic evaluated on data; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; HypoTestResult(const char* name = 0); Default constructor. HypoTestResult(const char* name, Double_t nullp, Double_t altp); Alternate constructor. ~HypoTestResult(); Destructor. void Append(const RooStats::HypoTestResult* other); Add additional toy-MC experiments to the current results.; Use the data test statistics of the added object if it is not already; set (otherwise, ignore the new one). void SetAltDistribution(RooStats::SamplingDistribution* alt). void SetNullDistribution(RooStats::SamplingDistribution* null). void SetTestStatisticData(const Double_t tsd). void ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooStats__HypoTestResult.html:7803,test,test,7803,root/html530/RooStats__HypoTestResult.html,https://root.cern,https://root.cern/root/html530/RooStats__HypoTestResult.html,2,['test'],['test']
Testability,"nt_t level) constTF2virtual; GetCurrent()TF1static; GetDrawOption() constTObjectvirtual; GetDtorOnly()TObjectstatic; GetExpFormula(Option_t *option="""") constTF1inlinevirtual; GetFillColor() constTAttFillinlinevirtual; GetFillStyle() constTAttFillinlinevirtual; GetFormula()TF1inlinevirtual; GetFormula() constTF1inlinevirtual; GetHistogram() constTF1virtual; GetIconName() constTObjectvirtual; GetLinearPart(Int_t i) constTF1inlinevirtual; GetLineColor() constTAttLineinlinevirtual; GetLineStyle() constTAttLineinlinevirtual; GetLineWidth() constTAttLineinlinevirtual; GetMarkerColor() constTAttMarkerinlinevirtual; GetMarkerLineWidth(Style_t style)TAttMarkerstatic; GetMarkerSize() constTAttMarkerinlinevirtual; GetMarkerStyle() constTAttMarkerinlinevirtual; GetMarkerStyleBase(Style_t style)TAttMarkerstatic; GetMaximum(Double_t *x) constTF2virtual; GetMaximum(Double_t xmin=0, Double_t xmax=0, Double_t epsilon=1.E-10, Int_t maxiter=100, Bool_t logx=false) constTF2virtual; GetMaximumStored() constTF1inlinevirtual; GetMaximumX(Double_t xmin=0, Double_t xmax=0, Double_t epsilon=1.E-10, Int_t maxiter=100, Bool_t logx=false) constTF1virtual; GetMaximumXY(Double_t &x, Double_t &y) constTF2virtual; GetMethodCall() constTF1inline; GetMinimum(Double_t *x) constTF2virtual; GetMinimum(Double_t xmin=0, Double_t xmax=0, Double_t epsilon=1.E-10, Int_t maxiter=100, Bool_t logx=false) constTF2virtual; GetMinimumStored() constTF1inlinevirtual; GetMinimumX(Double_t xmin=0, Double_t xmax=0, Double_t epsilon=1.E-10, Int_t maxiter=100, Bool_t logx=false) constTF1virtual; GetMinimumXY(Double_t &x, Double_t &y) constTF2virtual; GetMinMaxNDim(Double_t *x, Bool_t findmax, Double_t epsilon=0, Int_t maxiter=0) constTF1protectedvirtual; GetName() const overrideTNamedinlinevirtual; GetNDF() constTF1virtual; GetNdim() constTF1inlinevirtual; GetNpar() constTF1inlinevirtual; GetNpx() constTF1inlinevirtual; GetNpy() constTF2inline; GetNumber() constTF1inlinevirtual; GetNumberFitPoints() constTF1inlinevirtual",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTF2-members.html:6264,log,logx,6264,doc/master/classTF2-members.html,https://root.cern,https://root.cern/doc/master/classTF2-members.html,1,['log'],['logx']
Testability,"nt_t niter=20, Option_t *option=""same"") override; This function calculates the background spectrum in this histogram. ; ; Int_tShowPeaks (Double_t sigma=2, Option_t *option="""", Double_t threshold=0.05) override; Interface to TSpectrum2::Search the function finds peaks in this histogram where the width is > sigma and the peak maximum greater than threshold*maximum bin content of this. ; ; voidSmooth (Int_t ntimes=1, Option_t *option="""") override; Smooth bin contents of this 2-d histogram using kernel algorithms similar to the ones used in the raster graphics community. ; ; voidStreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b); ; Public Member Functions inherited from TH1; ~TH1 () override; Histogram default destructor. ; ; virtual Double_tAndersonDarlingTest (const TH1 *h2, Double_t &advalue) const; Same function as above but returning also the test statistic value. ; ; virtual Double_tAndersonDarlingTest (const TH1 *h2, Option_t *option="""") const; Statistical test of compatibility in shape between this histogram and h2, using the Anderson-Darling 2 sample test. ; ; voidBrowse (TBrowser *b) override; Browse the Histogram object. ; ; virtual Bool_tCanExtendAllAxes () const; Returns true if all axes are extendable. ; ; virtual Double_tChi2Test (const TH1 *h2, Option_t *option=""UU"", Double_t *res=nullptr) const; \( \chi^{2} \) test for comparing weighted and unweighted histograms. ; ; virtual Double_tChi2TestX (const TH1 *h2, Double_t &chi2, Int_t &ndf, Int_t &igood, Option_t *option=""UU"", Double_t *res=nullptr) const; The computation routine of the Chisquare test. ; ; virtual Double_tChisquare (TF1 *f1, Option_t *option="""") const; Compute and return the chisquare of this histogram with respect to a function The chisquare is computed by weighting each histogram point by the bin error By default the full range of the histogram is used. ; ; virtual voidClearUnderflowAndOverflow (); Remove all the content from the underflow and ove",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTH2Poly.html:19910,test,test,19910,doc/master/classTH2Poly.html,https://root.cern,https://root.cern/doc/master/classTH2Poly.html,6,['test'],['test']
Testability,"nt_t phid, Double_t* trans, Color_t cidx = -1, UChar_t transp = 0); Reposition/recolor physical shape. void UpdatePhysioLogical(TObject* logid, Double_t* trans, UChar_t* col); Reposition/recolor physical for given logical (assume TGLObject and; a single physical). void UpdatePhysioLogical(TObject* logid, Double_t* trans, Color_t cidx, UChar_t transp); Reposition/recolor physical for given logical (assume TGLObject and; a single physical). UInt_t BeginSmartRefresh(); Moves logicals that support smart-refresh to intermediate cache.; Destroys the others and returns the number of destroyed ones. void EndSmartRefresh(); Wipes logicals in refresh-cache. TGLLogicalShape * FindLogicalSmartRefresh(TObject* ID) const; Find and return logical shape identified by unqiue 'ID' in refresh-cache.; Returns 0 if not found. UInt_t SizeOfScene() const; Return memory cost of scene.; Warning: NOT CORRECT at present - doesn't correctly calculate size.; of logical shapes with dynamic internal contents. void DumpMapSizes() const; Print sizes of logical nad physical-shape maps. void RGBAFromColorIdx(Float_t* rgba, Color_t ci, Char_t transp = 0); Fill rgba color from ROOT color-index ci and transparency (0->100). Bool_t IsOutside(const TGLBoundingBox& box, const TGLPlaneSet_t& planes); Check if box is outside of all planes. TGLScene(const TGLScene& ). TGLScene& operator=(const TGLScene& ). TSceneInfo* CreateSceneInfo(TGLViewerBase* view). LogicalShapeMap_t& RefLogicalShapes(); Temporary export for setting selected-state of physical shapes. { return fLogicalShapes; }. TGLContextIdentity* GetGLCtxIdentity() const. GL-context holding display-list definitions. { return fGLCtxIdentity; }.  Author: Matevz Tadel, Feb 2007  Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *;  Last changed: root/gl:$Id$  Last generated: 2015-03-13 19:26; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGLScene.html:14576,log,logical,14576,root/html534/TGLScene.html,https://root.cern,https://root.cern/root/html534/TGLScene.html,1,['log'],['logical']
Testability,"nt_t uid); virtual voidShowMembers(TMemberInspector& insp) const; virtual Int_tTNamed::Sizeof() const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; TQueryResult(); TQueryResult(const TQueryResult&); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. voidAddInput(TObject* obj); voidAddLogLine(const char* logline); TQueryResult*CloneInfo(); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(); virtual voidRecordEnd(TQueryResult::EQueryStatus status, TList* outlist = 0); voidSaveSelector(const char* selec); voidSetArchived(const char* archfile); virtual voidSetFinalized(); virtual voidSetInputList(TList* in, Bool_t adopt = kTRUE); virtual voidSetOutputList(TList* out, Bool_t adopt = kTRUE); virtual voidSetProcessInfo(Long64_t ent, Float_t cpu = 0., Long64_t siz = -1, Float_t inittime = 0., Float_t proctime = 0.); TQueryResult(Int_t seqnum, const char* opt, TList* inlist, Long64_t entries, Long64_t first, const char* selec). Data Members; public:. static TQueryResult::EQueryStatuskAborted; static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TQueryResult::EQueryStatuskCompleted; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObj",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TQueryResult.html:5805,log,logline,5805,root/html602/TQueryResult.html,https://root.cern,https://root.cern/root/html602/TQueryResult.html,1,['log'],['logline']
Testability,"nt_t uid); voidsetVerbose(Bool_t flag = kTRUE); Int_tsetWarnLevel(Int_t newLevel); virtual voidShowMembers(TMemberInspector& insp); Int_tsimplex(); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. voidapplyCovarianceMatrix(TMatrixDSym& V); voidbackProp(); voidclearPdfParamAsymErr(Int_t index); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; Int_tgetNPar() const; Double_tgetPdfParamErr(Int_t index); Double_tgetPdfParamVal(Int_t index); ofstream*logfile() const; voidTObject::MakeZombie(); Double_t&maxFCN(); voidprofileStart(); voidprofileStop(); voidsetPdfParamErr(Int_t index, Double_t value); voidsetPdfParamErr(Int_t index, Double_t loVal, Double_t hiVal); virtual Bool_tsetPdfParamVal(Int_t index, Double_t value, Bool_t verbose = kFALSE); Bool_tsynchronize(Bool_t verbose). private:. RooMinuit(const RooMinuit&). Data Members; public:. enum Strategy { Speed; Balance; Robustness; };; enum PrintLevel { None; Reduced; Normal; ExtraForProblem; Maximum; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. private:. RooArgList*_constParamList; TStopwatch_cumulTimer; Bool_t_doEvalErrorWall; TMatrixDSym*_extV; RooArgList*_floatParamList; RooAbsReal*_func; Bool_t_handleLocalErrors; RooArgList*_initConstParamList; RooArgList*_initFloatParamList; ofstrea",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooMinuit.html:6566,log,logfile,6566,root/html528/RooMinuit.html,https://root.cern,https://root.cern/root/html528/RooMinuit.html,1,['log'],['logfile']
Testability,"nt_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Chisquare method; The ""I""ntegral method is used; for each point the cache contains the following info; -1D : bc,e, xc,xw (bin content, error, x of center of bin, x bin width of bin); -2D : bc,e, xc,xw,yc,yw; -3D : bc,e, xc,xw,yc,yw,zc,zw. void FitLikelihood(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Likelihood method*-*-*-*-*-*; Basically, it forms the likelihood by determining the Poisson; probability that given a number of entries in a particular bin,; the fit would predict it's value. This is then done for each bin,; and the sum of the logs is taken as the likelihood.; Default method (function evaluated at center of bin); for each point the cache contains the following info; -1D : bc,e, xc (bin content, error, x of center of bin); -2D : bc,e, xc,yc; -3D : bc,e, xc,yc,zc. void FitLikelihoodI(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Likelihood method*-*-*-*-*-*; Basically, it forms the likelihood by determining the Poisson; probability that given a number of entries in a particular bin,; the fit would predict it's value. This is then done for each bin,; and the sum of the logs is taken as the likelihood.; The ""I""ntegral method is used; for each point the cache contains the following info; -1D : bc,e, xc,xw (bin content, error, x of center of bin, x bin width of bin); -2D : bc,e, xc,xw,yc,yw; -3D : bc,e, xc,xw,yc,yw,zc,zw. TFitter(const TFitter& ). TFitter& operator=(const TFitter& ). TMinuit * GetMinuit() const; {return fMinuit;}.  Author: Rene Brun 31/08/99  Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *;  Last changed: root/minuit:$Id$  Last generated: 2015-03-13 19:23; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TFitter.html:16949,log,logs,16949,root/html534/TFitter.html,https://root.cern,https://root.cern/root/html534/TFitter.html,1,['log'],['logs']
Testability,"nt_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Chisquare method; The ""I""ntegral method is used; for each point the cache contains the following info; -1D : bc,e, xc,xw (bin content, error, x of center of bin, x bin width of bin); -2D : bc,e, xc,xw,yc,yw; -3D : bc,e, xc,xw,yc,yw,zc,zw. void FitLikelihood(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Likelihood method*-*-*-*-*-*; Basically, it forms the likelihood by determining the Poisson; probability that given a number of entries in a particular bin,; the fit would predict it's value. This is then done for each bin,; and the sum of the logs is taken as the likelihood.; Default method (function evaluated at center of bin); for each point the cache contains the following info; -1D : bc,e, xc (bin content, error, x of center of bin); -2D : bc,e, xc,yc; -3D : bc,e, xc,yc,zc. void FitLikelihoodI(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Likelihood method*-*-*-*-*-*; Basically, it forms the likelihood by determining the Poisson; probability that given a number of entries in a particular bin,; the fit would predict it's value. This is then done for each bin,; and the sum of the logs is taken as the likelihood.; The ""I""ntegral method is used; for each point the cache contains the following info; -1D : bc,e, xc,xw (bin content, error, x of center of bin, x bin width of bin); -2D : bc,e, xc,xw,yc,yw; -3D : bc,e, xc,xw,yc,yw,zc,zw. TFitter(const TFitter& ). TFitter& operator=(const TFitter& ). TMinuit * GetMinuit() const; {return fMinuit;}.  Author: Rene Brun 31/08/99  Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *;  Last changed: root/minuit:$Id$  Last generated: 2015-06-02 15:48; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TFitter.html:17522,log,logs,17522,root/html604/TFitter.html,https://root.cern,https://root.cern/root/html604/TFitter.html,1,['log'],['logs']
Testability,"nt_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Chisquare method; The ""I""ntegral method is used; for each point the cache contains the following info; -1D : bc,e, xc,xw (bin content, error, x of center of bin, x bin width of bin); -2D : bc,e, xc,xw,yc,yw; -3D : bc,e, xc,xw,yc,yw,zc,zw. void FitLikelihood(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Likelihood method*-*-*-*-*-*; Basically, it forms the likelihood by determining the Poisson; probability that given a number of entries in a particular bin,; the fit would predict it's value. This is then done for each bin,; and the sum of the logs is taken as the likelihood.; Default method (function evaluated at center of bin); for each point the cache contains the following info; -1D : bc,e, xc (bin content, error, x of center of bin); -2D : bc,e, xc,yc; -3D : bc,e, xc,yc,zc. void FitLikelihoodI(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Likelihood method*-*-*-*-*-*; Basically, it forms the likelihood by determining the Poisson; probability that given a number of entries in a particular bin,; the fit would predict it's value. This is then done for each bin,; and the sum of the logs is taken as the likelihood.; The ""I""ntegral method is used; for each point the cache contains the following info; -1D : bc,e, xc,xw (bin content, error, x of center of bin, x bin width of bin); -2D : bc,e, xc,xw,yc,yw; -3D : bc,e, xc,xw,yc,yw,zc,zw. TFitter(const TFitter& ). TFitter& operator=(const TFitter& ). TMinuit * GetMinuit() const; {return fMinuit;}.  Author: Rene Brun 31/08/99  Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *;  Last changed: root/minuit:$Id$  Last generated: 2015-06-30 14:49; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TFitter.html:17522,log,logs,17522,root/html602/TFitter.html,https://root.cern,https://root.cern/root/html602/TFitter.html,1,['log'],['logs']
Testability,"nt_tTGFrame::fDNDStateEDNDFlags; UInt_tTGWindow::fEditDisabledflags used for ""guibuilding""; TGCheckButton*fEditableset pad editable; UInt_tTGFrame::fEventMaskcurrenty active event mask; TList*TGedFrame::fExtraTabsaddtional tabs in ged editor; TGFrameElement*TGFrame::fFEpointer to frame element; TGCheckButton*fFixedARset fixed aspect ratio; TGedEditor*TGedFrame::fGedEditormanager of this frame; TGCheckButton*fGridXset grid on X; TGCheckButton*fGridYset grid on Y; UInt_tTGFrame::fHeightframe height; Handle_tTGObject::fIdX11/Win32 Window identifier; Bool_tTGedFrame::fInitinit flag for setting signals/slots; Bool_tTGCompositeFrame::fLayoutBrokenno layout manager is used; TGLayoutManager*TGCompositeFrame::fLayoutManagerlayout manager; TList*TGCompositeFrame::fListcontainer of frame elements; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; TGCheckButton*fLogXset log scale on X; TGCheckButton*fLogYset log scale on Y; TGCheckButton*fLogZset log scale on Z; Bool_tTGCompositeFrame::fMapSubwindowskTRUE - map subwindows; UInt_tTGFrame::fMaxHeightmaximal frame height; UInt_tTGFrame::fMaxWidthmaximal frame width; UInt_tTGFrame::fMinHeightminimal frame height; UInt_tTGFrame::fMinWidthminimal frame width; TClass*TGedFrame::fModelClassclass corresponding to instantiated GedFrame; Int_tTGCompositeFrame::fMustCleanupcleanup mode (see EFrameCleanup); TStringTGWindow::fNamename of the window used in SavePrimitive(); Bool_tTGWindow::fNeedRedrawkTRUE if window needs to be redrawn; UInt_tTGFrame::fOptionsframe options; TPad*fPadPointerTPad object; const TGWindow*TGWindow::fParentParent window; Int_tTGedFrame::fPrioritylocation in GedEditor; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; TGCheckButton*fTickXset ticks on X; TGCheckButton*fTickYset ticks on Y; UInt_tTGFrame::fWidthframe width; Int_tTGFrame::fXframe x position; Int_tTGFrame::fYframe y position; static Bool_tTQObjec",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TPadEditor.html:19197,log,log,19197,root/html528/TPadEditor.html,https://root.cern,https://root.cern/root/html528/TPadEditor.html,6,['log'],['log']
Testability,"nt_t_debugCode; RooWorkspace*_debugWorkspace; ostream*_devnull; Int_t_errorCount; map<std::string,std::ostream*>_files; RooFit::MsgLevel_globMinLevel; static RooMsgService*_instance; RooFit::MsgLevel_lastMsgLevel; Bool_t_showPid; Bool_t_silentMode; vector<StreamConfig>_streams; stack<std::vector<StreamConfig> >_streamsSaved. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void cleanup(); Cleanup function called by atexit() handler installed by RooSentinel; to delete all global object upon program termination. RooMsgService(); Constructor. Defines names of message levels; and mapping of topic codes to topic names; Install default message streams. ~RooMsgService(); Destructor. Bool_t anyDebug(); Returns true if any debug level stream is active. RooWorkspace* debugWorkspace(). Int_t addStream(RooFit::MsgLevel level, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg()); Add a message logging stream for message with given RooFit::MsgLevel or higher (i.e. more severe); This method accepts the following arguments to configure the stream. Output Style options. Prefix(Bool_t flag=kTRUE) -- Prefix all messages in this stream with Topic/Originator information. Filtering options. Topic(const char*) -- Restrict stream to messages on given topic; ObjectName(const char*) -- Restrict stream to messages from object with given name; ClassName(const char*) -- Restrict stream to messages from objects with given class name; BaseClassName(const char*)-- Restrict stream to messages from objects with given base class name; LabelName(const chat*) -- Restrict stream to messages from objects setAtrribute(const char*) tag with given name. Output redirection options. OutputFile(const char*) -- Send output to file with given name. Multiple streams can write to same file.; OutputStream(os",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooMsgService.html:8817,log,logging,8817,root/html528/RooMsgService.html,https://root.cern,https://root.cern/root/html528/RooMsgService.html,4,['log'],['logging']
Testability,nt_tfCompressMsgCompression level for messages; TStopwatchfComputemeasures time spend processing a packet; TStringfConfDirdirectory containing cluster config information; TStringfConfFilefile containing config information; Float_tfCpuTimeCPU time spent executing commands; TStringfDataDirdirectory containing data files produced during queries; TStringfDataSetDirdirectory containing info about known data sets; TDataSetManager*fDataSetManagerdataset manager; Float_tfEffSessionsEffective Number of PROOF sessions on the assigned machines; TList*fEnabledPackageslist of enabled packages; Bool_tfEndMastertrue for a master in direct contact only with workers; THashList*fGlobalPackageDirListlist of directories containing global packages libs; TStringfGroupgroup the user belongs to; Int_tfGroupIdslave unique id in the active slave group; Int_tfGroupPrioritypriority of group the user belongs to (0 - 100); Int_tfGroupSizesize of the active slave group; Long64_tfHWMBoxSizeHigh-Water-Mark on the sandbox size; Bool_tfIdleTRUE if idle; TIdleTOTimer*fIdleTOTimerTimer used to control children state; TStringfImageimage name of the session; Int_tfInflateFactorFactor in 1/1000 to inflate the CPU time; TFileHandler*fInputHandlerInput socket handler; Bool_tfInterruptif true macro execution will be stopped; TStopwatchfLatencymeasures latency of packet requests; FILE*fLogFilelog file; Int_tfLogFileDeslog file descriptor; Int_tfLogLeveldebug logging level; Bool_tfMasterServtrue if we are a master server; Long64_tfMaxBoxSizeMax size of the sandbox; Int_tfMaxQueriesMax number of queries fully kept; Int_tfMergedWorkersNumber of workers merged; TMonitor*fMergingMonitorMonitor for merging sockets; TServerSocket*fMergingSocketSocket used for merging outputs if submerger; Long64_tfMsgSizeHWMHigh-Water-Mark on the size of messages with results; Int_tfNcmdcommand history number; TStringfOrdinalslave ordinal number; TStringfPackageDirdirectory containing packages and user libs; TProofLockPath*fPackageL,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TProofServ.html:17498,sandbox,sandbox,17498,root/html528/TProofServ.html,https://root.cern,https://root.cern/root/html528/TProofServ.html,1,['sandbox'],['sandbox']
Testability,nt_tfCompressMsgCompression level for messages; TStopwatchfComputemeasures time spend processing a packet; TStringfConfDirdirectory containing cluster config information; TStringfConfFilefile containing config information; Float_tfCpuTimeCPU time spent executing commands; TStringfDataDirdirectory containing data files produced during queries; TStringfDataSetDirdirectory containing info about known data sets; TDataSetManager*fDataSetManagerdataset manager; Float_tfEffSessionsEffective Number of PROOF sessions on the assigned machines; TList*fEnabledPackageslist of enabled packages; Bool_tfEndMastertrue for a master in direct contact only with workers; THashList*fGlobalPackageDirListlist of directories containing global packages libs; TStringfGroupgroup the user belongs to; Int_tfGroupIdslave unique id in the active slave group; Int_tfGroupPrioritypriority of group the user belongs to (0 - 100); Int_tfGroupSizesize of the active slave group; Long64_tfHWMBoxSizeHigh-Water-Mark on the sandbox size; Bool_tfIdleTRUE if idle; TIdleTOTimer*fIdleTOTimerTimer used to control children state; TStringfImageimage name of the session; Int_tfInflateFactorFactor in 1/1000 to inflate the CPU time; TFileHandler*fInputHandlerInput socket handler; Bool_tfInterruptif true macro execution will be stopped; TStopwatchfLatencymeasures latency of packet requests; FILE*fLogFilelog file; Int_tfLogFileDeslog file descriptor; Long64_tfLogFileMaxSizemax size for log files (enabled if > 0); Int_tfLogLeveldebug logging level; Bool_tfMasterServtrue if we are a master server; Long64_tfMaxBoxSizeMax size of the sandbox; Int_tfMaxQueriesMax number of queries fully kept; Int_tfMergedWorkersNumber of workers merged; TMonitor*fMergingMonitorMonitor for merging sockets; TServerSocket*fMergingSocketSocket used for merging outputs if submerger; Long64_tfMsgSizeHWMHigh-Water-Mark on the size of messages with results; Int_tfNcmdcommand history number; TStringfOrdinalslave ordinal number; TStringfPackageDirdirec,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TProofServ.html:17707,sandbox,sandbox,17707,root/html530/TProofServ.html,https://root.cern,https://root.cern/root/html530/TProofServ.html,2,['sandbox'],['sandbox']
Testability,"nt_v.push_back(new Event(vars, tgts , vis, cl , weight));; 980 }; 981 }; 982 currentInfo.GetTree()->ResetBranchAddresses();; 983 }; 984 }; 985 ; 986 if (!nanInfWarnings.empty()) {; 987 Log() << kWARNING << ""Found events with NaN and/or +-inf values"" << Endl;; 988 for (const auto &warning : nanInfWarnings) {; 989 auto &log = Log() << kWARNING << warning.first;; 990 if (warning.second > 1) log << "" ("" << warning.second << "" times)"";; 991 log << Endl;; 992 }; 993 Log() << kWARNING << ""These NaN and/or +-infs were all removed by the specified cut, continuing."" << Endl;; 994 Log() << Endl;; 995 }; 996 ; 997 if (!nanInfErrors.empty()) {; 998 Log() << kWARNING << ""Found events with NaN and/or +-inf values (not removed by cut)"" << Endl;; 999 for (const auto &error : nanInfErrors) {; 1000 auto &log = Log() << kWARNING << error.first;; 1001 if (error.second > 1) log << "" ("" << error.second << "" times)"";; 1002 log << Endl;; 1003 }; 1004 Log() << kFATAL << ""How am I supposed to train a NaN or +-inf?!"" << Endl;; 1005 }; 1006 ; 1007 // for output format, get the maximum class name length; 1008 Int_t maxL = dsi.GetClassNameMaxLength();; 1009 ; 1010 Log() << kHEADER << Form(""[%s] : "",dsi.GetName()) << ""Number of events in input trees"" << Endl;; 1011 Log() << kDEBUG << ""(after possible flattening of arrays):"" << Endl;; 1012 ; 1013 ; 1014 for (UInt_t cl = 0; cl < dsi.GetNClasses(); cl++) {; 1015 Log() << kDEBUG //<< Form(""[%s] : "",dsi.GetName()); 1016 << "" ""; 1017 << setiosflags(ios::left) << std::setw(maxL) << dsi.GetClassInfo(cl)->GetName(); 1018 << "" -- number of events : ""; 1019 << std::setw(5) << eventCounts[cl].nEvBeforeCut; 1020 << "" / sum of weights: "" << std::setw(5) << eventCounts[cl].nWeEvBeforeCut << Endl;; 1021 }; 1022 ; 1023 for (UInt_t cl = 0; cl < dsi.GetNClasses(); cl++) {; 1024 Log() << kDEBUG //<< Form(""Dataset[%s] : "",dsi.GetName()); 1025 << "" "" << std::setw(maxL) << dsi.GetClassInfo(cl)->GetName(); 1026 <<"" tree -- total number of entries: ""; 1027 << std::setw(5)",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/DataSetFactory_8cxx_source.html:42629,log,log,42629,doc/master/DataSetFactory_8cxx_source.html,https://root.cern,https://root.cern/doc/master/DataSetFactory_8cxx_source.html,1,['log'],['log']
Testability,"ntable::nameFieldLength(Int_t newLen); virtual Bool_tTObject::Notify(); Int_tnumCaches() const; Bool_tobservableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tobservableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TNamed&TNamed::operator=(const TNamed& rhs); virtual Bool_toperator==(const RooAbsArg& other); RooAbsArg::OperModeoperMode() const; virtual voidoptimizeCacheMode(const RooArgSet& observables); virtual voidoptimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_toverlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidPrint(Option_t* options = 0) const; virtual voidprintAddress(ostream& os) const; virtual voidprintArgs(ostream& os) const; virtual voidprintClassName(ostream& os) const; voidprintCompactTree(const char* indent = """", const char* fileName = 0, const char* namePat = 0, RooAbsArg* client = 0); voidprintCompactTree(ostream& os, const char* indent = """", const char* namePat = 0, RooAbsArg* client = 0); virtual voidprintCompactTreeHook(ostream& os, const char* ind = """"); voidprintComponentTree(const char* indent = """", const char* namePat = 0); voidprintDirty(Bool_t depth = kTRUE) const; virtual voidRooPrintable::printExtras(ostream& os) const; virtual voidprintMetaArgs(ostream&) const; virtual voidprintMultiline(ostream& os, Int_t contents, Bool_t verbose = kFALSE, TString indent = """") const; virtual voidprintName(ostream& os",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAbsArg.html:9168,test,testArg,9168,root/html526/RooAbsArg.html,https://root.cern,https://root.cern/root/html526/RooAbsArg.html,1,['test'],['testArg']
Testability,"ntable::nameFieldLength(Int_t newLen); virtual Bool_tTObject::Notify(); Int_tnumCaches() const; Bool_tobservableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tobservableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TNamed&TNamed::operator=(const TNamed& rhs); virtual Bool_toperator==(const RooAbsArg& other); RooAbsArg::OperModeoperMode() const; virtual voidoptimizeCacheMode(const RooArgSet& observables); virtual voidoptimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_toverlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidPrint(Option_t* options = 0) const; virtual voidprintAddress(ostream& os) const; virtual voidprintArgs(ostream& os) const; virtual voidprintClassName(ostream& os) const; voidprintCompactTree(const char* indent = """", const char* fileName = 0, const char* namePat = 0, RooAbsArg* client = 0); voidprintCompactTree(ostream& os, const char* indent = """", const char* namePat = 0, RooAbsArg* client = 0); virtual voidprintCompactTreeHook(ostream& os, const char* ind = """"); voidprintComponentTree(const char* indent = """", const char* namePat = 0, Int_t nLevel = 999); voidprintDirty(Bool_t depth = kTRUE) const; virtual voidRooPrintable::printExtras(ostream& os) const; virtual voidprintMetaArgs(ostream&) const; virtual voidprintMultiline(ostream& os, Int_t contents, Bool_t verbose = kFALSE, TString indent = """") const; virtual voidp",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooAbsArg.html:9261,test,testArg,9261,root/html528/RooAbsArg.html,https://root.cern,https://root.cern/root/html528/RooAbsArg.html,1,['test'],['testArg']
Testability,"ntainer& outputContainer) const; 1080 {; 1081 std::vector<double> nothing; // empty gradients; no backpropagation is done, just forward; 1082 assert (numWeights () == weights.size ());; 1083 double error = forward_backward(m_layers, settingsAndBatch, std::begin (weights), std::end (weights), std::begin (nothing), std::end (nothing), 10000, outputContainer, true);; 1084 return error;; 1085 }; 1086 ; 1087 ; 1088 template <typename Weights, typename Gradients, typename PassThrough>; 1089 double Net::operator() (PassThrough& settingsAndBatch, Weights& weights, Gradients& gradients) const; 1090 {; 1091 std::vector<double> nothing;; 1092 assert (numWeights () == weights.size ());; 1093 assert (weights.size () == gradients.size ());; 1094 double error = forward_backward(m_layers, settingsAndBatch, std::begin (weights), std::end (weights), std::begin (gradients), std::end (gradients), 0, nothing, false);; 1095 return error;; 1096 }; 1097 ; 1098 template <typename Weights, typename Gradients, typename PassThrough, typename OutContainer>; 1099 double Net::operator() (PassThrough& settingsAndBatch, Weights& weights, Gradients& gradients, ModeOutput eFetch, OutContainer& outputContainer) const; 1100 {; 1101 MATH_UNUSED(eFetch);; 1102 assert (numWeights () == weights.size ());; 1103 assert (weights.size () == gradients.size ());; 1104 double error = forward_backward(m_layers, settingsAndBatch, std::begin (weights), std::end (weights), std::begin (gradients), std::end (gradients), 0, outputContainer, true);; 1105 return error;; 1106 }; 1107 ; 1108 ; 1109 ; 1110 template <typename LayerContainer, typename DropContainer, typename ItWeight, typename ItGradient>; 1111 std::vector<std::vector<LayerData>> Net::prepareLayerData (LayerContainer& _layers,; 1112 Batch& batch,; 1113 const DropContainer& dropContainer,; 1114 ItWeight itWeightBegin,; 1115 ItWeight /*itWeightEnd*/,; 1116 ItGradient itGradientBegin,; 1117 ItGradient itGradientEnd,; 1118 size_t& totalNumWeights) const; 1119 {; 11",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/NeuralNet_8icc_source.html:35374,assert,assert,35374,doc/master/NeuralNet_8icc_source.html,https://root.cern,https://root.cern/doc/master/NeuralNet_8icc_source.html,1,['assert'],['assert']
Testability,"ntation of this file. 1/// \file; 2/// \ingroup tutorial_tmva; 3/// \notebook -nodraw; 4/// This macro provides a simple example for the training and testing of the TMVA; 5/// multiclass classification; 6/// - Project : TMVA - a Root-integrated toolkit for multivariate data analysis; 7/// - Package : TMVA; 8/// - Root Macro: TMVAMulticlass; 9///; 10/// \macro_output; 11/// \macro_code; 12/// \author Andreas Hoecker; 13 ; 14#include <cstdlib>; 15#include <iostream>; 16#include <map>; 17#include <string>; 18 ; 19#include ""TFile.h""; 20#include ""TTree.h""; 21#include ""TString.h""; 22#include ""TSystem.h""; 23#include ""TROOT.h""; 24 ; 25 ; 26#include ""TMVA/Tools.h""; 27#include ""TMVA/Factory.h""; 28#include ""TMVA/DataLoader.h""; 29#include ""TMVA/TMVAMultiClassGui.h""; 30 ; 31 ; 32using namespace TMVA;; 33 ; 34void TMVAMulticlass( TString myMethodList = """" ); 35{; 36 ; 37 // This loads the library; 38 TMVA::Tools::Instance();; 39 ; 40 // to get access to the GUI and all tmva macros; 41 //; 42 // TString tmva_dir(TString(gRootDir) + ""/tmva"");; 43 // if(gSystem->Getenv(""TMVASYS"")); 44 // tmva_dir = TString(gSystem->Getenv(""TMVASYS""));; 45 // gROOT->SetMacroPath(tmva_dir + ""/test/:"" + gROOT->GetMacroPath() );; 46 // gROOT->ProcessLine("".L TMVAMultiClassGui.C"");; 47 ; 48 ; 49 //---------------------------------------------------------------; 50 // Default MVA methods to be trained + tested; 51 std::map<std::string,int> Use;; 52 Use[""MLP""] = 1;; 53 Use[""BDTG""] = 1;; 54#ifdef R__HAS_TMVAGPU; 55 Use[""DL_CPU""] = 1;; 56 Use[""DL_GPU""] = 1;; 57#else; 58 Use[""DL_CPU""] = 1;; 59 Use[""DL_GPU""] = 0;; 60#endif; 61 Use[""FDA_GA""] = 0;; 62 Use[""PDEFoam""] = 1;; 63 ; 64 //---------------------------------------------------------------; 65 ; 66 std::cout << std::endl;; 67 std::cout << ""==> Start TMVAMulticlass"" << std::endl;; 68 ; 69 if (myMethodList != """") {; 70 for (std::map<std::string,int>::iterator it = Use.begin(); it != Use.end(); it++) it->second = 0;; 71 ; 72 std::vector<TString> mlist = TMVA::",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVAMulticlass_8C_source.html:1344,test,test,1344,doc/master/TMVAMulticlass_8C_source.html,https://root.cern,https://root.cern/doc/master/TMVAMulticlass_8C_source.html,1,['test'],['test']
Testability,"ntegral of the function over one or more observables listed in iset. ; ; template<typename... CmdArgs_t> ; RooFit::OwningPtr< RooAbsReal >createNLL (RooAbsData &data, CmdArgs_t const &... cmdArgs); Construct representation of -log(L) of PDF with given dataset. ; ; virtual RooAbsPdf *createProjection (const RooArgSet &iset); Return a p.d.f that represent a projection of this p.d.f integrated over given observables. ; ; RooFit::OwningPtr< RooAbsReal >createScanCdf (const RooArgSet &iset, const RooArgSet &nset, Int_t numScanBins, Int_t intOrder); ; doubleexpectedEvents (const RooArgSet &nset) const; Return expected number of events to be used in calculation of extended likelihood. ; ; doubleextendedTerm (double sumEntries, double expected, double sumEntriesW2=0.0, bool doOffset=false) const; ; doubleextendedTerm (double sumEntries, RooArgSet const *nset, double sumEntriesW2=0.0, bool doOffset=false) const; Return the extended likelihood term ( \( N_\mathrm{expect} - N_\mathrm{observed} \cdot \log(N_\mathrm{expect} \)) of this PDF for the given number of observed events. ; ; doubleextendedTerm (RooAbsData const &data, bool weightSquared, bool doOffset=false) const; Return the extended likelihood term ( \( N_\mathrm{expect} - N_\mathrm{observed} \cdot \log(N_\mathrm{expect} \)) of this PDF for the given number of observed events. ; ; template<typename... CmdArgs_t> ; RooFit::OwningPtr< RooFitResult >fitTo (RooAbsData &data, CmdArgs_t const &... cmdArgs); Fit PDF to given dataset. ; ; RooFit::OwningPtr< RooDataSet >generate (const RooArgSet &whatVars, const RooCmdArg &arg1={}, const RooCmdArg &arg2={}, const RooCmdArg &arg3={}, const RooCmdArg &arg4={}, const RooCmdArg &arg5={}, const RooCmdArg &arg6={}); Generate a new dataset containing the specified variables with events sampled from our distribution. ; ; RooFit::OwningPtr< RooDataSet >generate (const RooArgSet &whatVars, const RooDataSet &prototype, Int_t nEvents=0, bool verbose=false, bool ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classRooAddPdf.html:9022,log,log,9022,doc/v632/classRooAddPdf.html,https://root.cern,https://root.cern/doc/v632/classRooAddPdf.html,3,['log'],['log']
Testability,"ntegral of the function over one or more observables listed in iset. ; ; template<typename... CmdArgs_t> ; RooFit::OwningPtr< RooAbsReal >createNLL (RooAbsData &data, CmdArgs_t const &... cmdArgs); Construct representation of -log(L) of PDF with given dataset. ; ; virtual RooAbsPdf *createProjection (const RooArgSet &iset); Return a p.d.f that represent a projection of this p.d.f integrated over given observables. ; ; RooFit::OwningPtr< RooAbsReal >createScanCdf (const RooArgSet &iset, const RooArgSet &nset, Int_t numScanBins, Int_t intOrder); ; doubleexpectedEvents (const RooArgSet &nset) const; Return expected number of events to be used in calculation of extended likelihood. ; ; doubleextendedTerm (double sumEntries, double expected, double sumEntriesW2=0.0, bool doOffset=false) const; ; doubleextendedTerm (double sumEntries, RooArgSet const *nset, double sumEntriesW2=0.0, bool doOffset=false) const; Return the extended likelihood term ( \( N_\mathrm{expect} - N_\mathrm{observed} \cdot \log(N_\mathrm{expect} \)) of this PDF for the given number of observed events. ; ; doubleextendedTerm (RooAbsData const &data, bool weightSquared, bool doOffset=false) const; Return the extended likelihood term ( \( N_\mathrm{expect} - N_\mathrm{observed} \cdot \log(N_\mathrm{expect} \)) of this PDF for the given number of observed events. ; ; template<typename... CmdArgs_t> ; RooFit::OwningPtr< RooFitResult >fitTo (RooAbsData &data, CmdArgs_t const &... cmdArgs); Fit PDF to given dataset. ; ; virtual RooAbsGenContext *genContext (const RooArgSet &vars, const RooDataSet *prototype=nullptr, const RooArgSet *auxProto=nullptr, bool verbose=false) const; Interface function to create a generator context from a p.d.f. ; ; RooFit::OwningPtr< RooDataSet >generate (const RooArgSet &whatVars, const RooCmdArg &arg1={}, const RooCmdArg &arg2={}, const RooCmdArg &arg3={}, const RooCmdArg &arg4={}, const RooCmdArg &arg5={}, const RooCmdArg &arg6={}); Generate a new d",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classRooRealSumPdf.html:8217,log,log,8217,doc/v632/classRooRealSumPdf.html,https://root.cern,https://root.cern/doc/v632/classRooRealSumPdf.html,7,['log'],['log']
Testability,ntegratorOptions.cxx; MersenneTwisterEngine.cxx; MinimizerOptions.cxx; MinimizerVariableTransformation.cxx; MinimTransformFunction.cxx; mixmax.h; mixmax.icc; mixmax_skip_N17.icc; mixmax_skip_N240.icc; mixmax_skip_N256.icc; mixmax_skip_N256.oldS.icc; MixMaxEngineImpl.h; MixMaxEngineImpl17.cxx; MixMaxEngineImpl240.cxx; MixMaxEngineImpl256.cxx; ParameterSettings.cxx; PdfFuncMathCore.cxx; ProbFuncMathCore.cxx; QuantFuncMathCore.cxx; RandomFunctions.cxx; RichardsonDerivator.cxx; RootFinder.cxx; SparseData.cxx; SpecFuncCephes.cxx; SpecFuncCephes.h; SpecFuncCephesInv.cxx; SpecFuncMathCore.cxx; StdEngine.cxx; TComplex.cxx; TKDTree.cxx; TKDTreeBinning.cxx; TMath.cxx; TRandom.cxx; TRandom1.cxx; TRandom2.cxx; TRandom3.cxx; TRandomGen.cxx; triangle.c; triangle.h; TStatistic.cxx; UnBinData.cxx; test; fit; GaussFunction.h; MinimizerTypes.h; SparseDataComparer.cxx; SparseFit3.cxx; SparseFit4.cxx; testFit.cxx; testFitPerf.cxx; testGraphFit.cxx; testMinim.cxx; testRooFit.cxx; WrapperRooPdf.h; binarySearchTime.cxx; kDTreeTest.cxx; newKDTreeTest.cxx; stdsort.cxx; stressGoFTest.cxx; stressTF1.cxx; stressTMath.cxx; testAnalyticalIntegrals.cxx; testBinarySearch.cxx; testDistSampler.cxx; testIntegration.cxx; testIntegrationMultiDim.cxx; testKahan.cxx; testkdTreeBinning.cxx; testMathRandom.cxx; testRootFinder.cxx; testSampleQuantiles.cxx; testSortOrder.cxx; testSpecFuncBeta.cxx; testSpecFuncBetaI.cxx; testSpecFuncErf.cxx; testSpecFuncGamma.cxx; testSpecFuncSiCi.cxx; testTMath.cxx; testTStatistic.cxx; v7; inc; ROOT; TFit.hxx; mathmore; inc; Math; ChebyshevApprox.h; Derivator.h; DistFuncMathMore.h; GSLFunctionAdapter.h; GSLIntegrator.h; GSLMCIntegrator.h; GSLMinimizer.h; GSLMinimizer1D.h; GSLMultiRootFinder.h; GSLNLSMinimizer.h; GSLQuasiRandom.h; GSLRandom.h; GSLRandomFunctions.h; GSLRndmEngines.h; GSLRootFinder.h; GSLRootFinderDeriv.h; GSLRootHelper.h; GSLSimAnMinimizer.h; ,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v610/files.html:44856,test,testMinim,44856,doc/v610/files.html,https://root.cern,https://root.cern/doc/v610/files.html,1,['test'],['testMinim']
Testability,ntegratorOptions.cxx; MersenneTwisterEngine.cxx; MinimizerOptions.cxx; MinimizerVariableTransformation.cxx; MinimTransformFunction.cxx; mixmax.h; mixmax.icc; mixmax_skip_N17.icc; mixmax_skip_N240.icc; mixmax_skip_N256.icc; mixmax_skip_N256.oldS.icc; MixMaxEngineImpl.h; MixMaxEngineImpl17.cxx; MixMaxEngineImpl240.cxx; MixMaxEngineImpl256.cxx; ParameterSettings.cxx; PdfFuncMathCore.cxx; ProbFuncMathCore.cxx; QuantFuncMathCore.cxx; RandomFunctions.cxx; RichardsonDerivator.cxx; RootFinder.cxx; SparseData.cxx; SpecFuncCephes.cxx; SpecFuncCephes.h; SpecFuncCephesInv.cxx; SpecFuncMathCore.cxx; StdEngine.cxx; TComplex.cxx; TKDTree.cxx; TKDTreeBinning.cxx; TMath.cxx; TRandom.cxx; TRandom1.cxx; TRandom2.cxx; TRandom3.cxx; TRandomGen.cxx; triangle.c; triangle.h; TStatistic.cxx; UnBinData.cxx; test; fit; GaussFunction.h; MinimizerTypes.h; SparseDataComparer.cxx; SparseFit3.cxx; SparseFit4.cxx; testFit.cxx; testFitPerf.cxx; testGraphFit.cxx; testMinim.cxx; testRooFit.cxx; WrapperRooPdf.h; binarySearchTime.cxx; kDTreeTest.cxx; newKDTreeTest.cxx; stdsort.cxx; stressGoFTest.cxx; stressTF1.cxx; stressTMath.cxx; testAnalyticalIntegrals.cxx; testBinarySearch.cxx; testDistSampler.cxx; testIntegration.cxx; testIntegrationMultiDim.cxx; testkdTreeBinning.cxx; testMathRandom.cxx; testRootFinder.cxx; testSampleQuantiles.cxx; testSortOrder.cxx; testSpecFuncBeta.cxx; testSpecFuncBetaI.cxx; testSpecFuncErf.cxx; testSpecFuncGamma.cxx; testSpecFuncSiCi.cxx; testTMath.cxx; testTStatistic.cxx; v7; inc; ROOT; TFit.hxx; mathmore; inc; Math; ChebyshevApprox.h; Derivator.h; DistFuncMathMore.h; GSLFunctionAdapter.h; GSLIntegrator.h; GSLMCIntegrator.h; GSLMinimizer.h; GSLMinimizer1D.h; GSLMultiRootFinder.h; GSLNLSMinimizer.h; GSLQuasiRandom.h; GSLRandom.h; GSLRandomFunctions.h; GSLRndmEngines.h; GSLRootFinder.h; GSLRootFinderDeriv.h; GSLRootHelper.h; GSLSimAnMinimizer.h; GSLSimAnnealing,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v608/files.html:46282,test,testMinim,46282,doc/v608/files.html,https://root.cern,https://root.cern/doc/v608/files.html,1,['test'],['testMinim']
Testability,"nter if transformation has been found; otherwise 0;. void Paint(Option_t* option = """"); -*-*-*-*-*-*-*-*Paint Referenced node with current parameters; *-* ==============================================; -; *-* vis = 1 (default) shape is drawn; *-* vis = 0 shape is not drawn but its sons may be not drawn; *-* vis = -1 shape is not drawn. Its sons are not drawn; *-* vis = -2 shape is drawn. Its sons are not drawn; -; *. It draw the TVolumeView layers from the iFirst one (form the zero) till; iLast one reached. restrict the levels for ""range"" option. void PaintShape(Option_t* option); Paint shape of the node; To be called from the TObject::Paint method only. TString PathP() const; return the full path of this data set. void SavePrimitive(ostream& out, Option_t* option = """"); to be documented. void SetLineAttributes(); to be documented. void SetVisibility(Int_t vis = 1); to be documented. void Sizeof3D() const; -*-*-*-*Return total size of this 3-D Node with its attributes; *-* ==========================================================. void Add(TDataSet* dataset); { assert(0);}. void Add(TVolumeView* node); { TDataSet::Add(node);}. Bool_t IsMarked() const; { return TestBit(kMark); }. TList * GetListOfShapes() const; {return fListOfShapes;}. TShape * GetShape() const; {return fListOfShapes ? (TShape *)fListOfShapes->First():0;}. Int_t GetVisibility() const; {return GetNode() ? GetNode()->GetVisibility():0;}. TVolumeView(TVolumeView& viewNode). TVolumePosition * GetPosition() const; { return (TVolumePosition *)GetObject();}. Bool_t Is3D() const; {return kTRUE;}. TList * Nodes(); { return GetList();}.  Author: Valery Fine(fine@bnl.gov) 25/12/98  Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *;  Last changed: root/table:$Id: TVolumeView.h 27157 2009-01-15 14:05:12Z brun $  Last generated: 2010-10-09 20:48; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TVolumeView.html:17209,assert,assert,17209,root/html528/TVolumeView.html,https://root.cern,https://root.cern/root/html528/TVolumeView.html,1,['assert'],['assert']
Testability,"nter if transformation has been found; otherwise 0;. void Paint(Option_t* option = """"); -*-*-*-*-*-*-*-*Paint Referenced node with current parameters; *-* ==============================================; -; *-* vis = 1 (default) shape is drawn; *-* vis = 0 shape is not drawn but its sons may be not drawn; *-* vis = -1 shape is not drawn. Its sons are not drawn; *-* vis = -2 shape is drawn. Its sons are not drawn; -; *. It draw the TVolumeView layers from the iFirst one (form the zero) till; iLast one reached. restrict the levels for ""range"" option. void PaintShape(Option_t* option); Paint shape of the node; To be called from the TObject::Paint method only. TString PathP() const; return the full path of this data set. void SavePrimitive(ostream& out, Option_t* option = """"); to be documented. void SetLineAttributes(); to be documented. void SetVisibility(Int_t vis = 1); to be documented. void Sizeof3D() const; -*-*-*-*Return total size of this 3-D Node with its attributes; *-* ==========================================================. void Add(TDataSet* dataset); { assert(0);}. void Add(TVolumeView* node); { TDataSet::Add(node);}. Bool_t IsMarked() const; { return TestBit(kMark); }. TList * GetListOfShapes() const; {return fListOfShapes;}. TShape * GetShape() const; {return fListOfShapes ? (TShape *)fListOfShapes->First():0;}. Int_t GetVisibility() const; {return GetNode() ? GetNode()->GetVisibility():0;}. TVolumeView(TVolumeView& viewNode). TVolumePosition * GetPosition() const; { return (TVolumePosition *)GetObject();}. Bool_t Is3D() const; {return kTRUE;}. TList * Nodes(); { return GetList();}.  Author: Valery Fine(fine@bnl.gov) 25/12/98  Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *;  Last changed: root/table:$Id: TVolumeView.h 27157 2009-01-15 14:05:12Z brun $  Last generated: 2011-07-04 15:39; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TVolumeView.html:17309,assert,assert,17309,root/html530/TVolumeView.html,https://root.cern,https://root.cern/root/html530/TVolumeView.html,1,['assert'],['assert']
Testability,"nter if transformation has been found; otherwise 0;. void Paint(Option_t* option = """"); -*-*-*-*-*-*-*-*Paint Referenced node with current parameters; *-* ==============================================; -; *-* vis = 1 (default) shape is drawn; *-* vis = 0 shape is not drawn but its sons may be not drawn; *-* vis = -1 shape is not drawn. Its sons are not drawn; *-* vis = -2 shape is drawn. Its sons are not drawn; -; *. It draw the TVolumeView layers from the iFirst one (form the zero) till; iLast one reached. restrict the levels for ""range"" option. void PaintShape(Option_t* option); Paint shape of the node; To be called from the TObject::Paint method only. TString PathP() const; return the full path of this data set. void SavePrimitive(ostream& out, Option_t* option = """"); to be documented. void SetLineAttributes(); to be documented. void SetVisibility(Int_t vis = 1); to be documented. void Sizeof3D() const; -*-*-*-*Return total size of this 3-D Node with its attributes; *-* ==========================================================. void Add(TDataSet* dataset); { assert(0);}. void Add(TVolumeView* node); { TDataSet::Add(node);}. Bool_t IsMarked() const; { return TestBit(kMark); }. TList * GetListOfShapes() const; {return fListOfShapes;}. TShape * GetShape() const; {return fListOfShapes ? (TShape *)fListOfShapes->First():0;}. Int_t GetVisibility() const; {return GetNode() ? GetNode()->GetVisibility():0;}. TVolumeView(TVolumeView& viewNode). TVolumePosition * GetPosition() const; { return (TVolumePosition *)GetObject();}. Bool_t Is3D() const; {return kTRUE;}. TList * Nodes(); { return GetList();}.  Author: Valery Fine(fine@bnl.gov) 25/12/98  Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *;  Last changed: root/table:$Id: TVolumeView.h 27157 2009-01-15 14:05:12Z brun $  Last generated: 2011-11-03 20:24; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TVolumeView.html:17309,assert,assert,17309,root/html532/TVolumeView.html,https://root.cern,https://root.cern/root/html532/TVolumeView.html,1,['assert'],['assert']
Testability,nterface that calculates the profile likelihood ratio at a particular parameter point given a dataset ; CProofConfigHolds configuration options for proof and proof-lite ; CProposalFunctionProposalFunction is an interface for all proposal functions that would be used with a Markov Chain Monte Carlo algorithm ; CProposalHelper; CRatioOfProfiledLikelihoodsTestStatTestStatistic that returns the ratio of profiled likelihoods ; CSamplingDistPlotThis class provides simple and straightforward utilities to plot SamplingDistribution objects ; CSamplingDistributionThis class simply holds a sampling distribution of some test statistic ; CSamplingSummary; CSamplingSummaryLookup; CSequentialProposalClass implementing a proposal function that samples the parameter space by moving only in one coordinate (chosen randomly) at each step ; CSimpleIntervalSimpleInterval is a concrete implementation of the ConfInterval interface ; CSimpleLikelihoodRatioTestStatTestStatistic class that returns -log(L[null] / L[alt]) where L is the likelihood ; CSPlotThis class calculates sWeights used to create an sPlot ; CTestStatisticTestStatistic is an interface class to provide a facility for construction test statistics distributions to the NeymanConstruction class ; CTestStatSamplerTestStatSampler is an interface class for a tools which produce RooStats SamplingDistributions ; CToyMCImportanceSamplerToyMCImportanceSampler is an extension of the ToyMCSampler for Importance Sampling ; CToyMCPayload; CToyMCSamplerToyMCSampler is an implementation of the TestStatSampler interface ; CToyMCStudyToyMCStudy is an implementation of RooAbsStudy for toy Monte Carlo sampling ; CUniformProposalUniformProposal is a concrete implementation of the ProposalFunction interface for use with a Markov Chain Monte Carlo algorithm ; CUpperLimitMCSModuleThis class allow to compute in the ToyMcStudy framework the ProfileLikelihood upper limit for each toy-MC sample generated ; NROOTNamespace for new ROO,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v610/annotated.html:9530,log,log,9530,doc/v610/annotated.html,https://root.cern,https://root.cern/doc/v610/annotated.html,5,['log'],['log']
Testability,"nterface; 548//==============================================================================; 549template <class T, unsigned int D>; 550inline T* SVector<T,D>::begin() { return fArray; }; 551 ; 552template <class T, unsigned int D>; 553inline const T* SVector<T,D>::begin() const { return fArray; }; 554 ; 555template <class T, unsigned int D>; 556inline T* SVector<T,D>::end() { return fArray + Dim(); }; 557 ; 558template <class T, unsigned int D>; 559inline const T* SVector<T,D>::end() const { return fArray + Dim(); }; 560 ; 561template <class T, unsigned int D>; 562template <class InputIterator>; 563void SVector<T,D>::SetElements(InputIterator ibegin, InputIterator iend) {; 564 // iterator size must match vector size; 565 assert( ibegin + D == iend);; 566 std::copy(ibegin, iend, fArray);; 567}; 568 ; 569template <class T, unsigned int D>; 570template <class InputIterator>; 571void SVector<T,D>::SetElements(InputIterator ibegin, unsigned int size) {; 572 // size <= vector size; 573 assert( size <= D);; 574 std::copy(ibegin, ibegin+size, fArray);; 575}; 576 ; 577 ; 578//==============================================================================; 579// Operators; 580//==============================================================================; 581template <class T, unsigned int D>; 582inline const T& SVector<T,D>::operator[](unsigned int i) const { return fArray[i]; }; 583 ; 584template <class T, unsigned int D>; 585inline const T& SVector<T,D>::operator()(unsigned int i) const { return fArray[i]; }; 586 ; 587template <class T, unsigned int D>; 588inline T& SVector<T,D>::operator[](unsigned int i) { return fArray[i]; }; 589 ; 590template <class T, unsigned int D>; 591inline T& SVector<T,D>::operator()(unsigned int i) { return fArray[i]; }; 592//==============================================================================; 593// Element access with At(); 594//==============================================================================; 595template <class T, uns",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/SVector_8icc_source.html:18514,assert,assert,18514,doc/master/SVector_8icc_source.html,https://root.cern,https://root.cern/doc/master/SVector_8icc_source.html,1,['assert'],['assert']
Testability,"nterleaving strategy rather than N-wise split for partioning of dataset for multiprocessor-split; Int_t_nCPUNumber of processors to use in parallel calculation mode; Int_t_nEventsTotal number of events in test statistic calculation; Int_t_nGofNumber of sub-contexts ; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; Int_t_numSetsTotal number of partitions in parallel calculation mode; Double_t_offset! Offset; Double_t_offsetCarry! avoids loss of precision; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; RooSetProxy_paramSetParameters of the test statistic (=parameters of the input function); Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; const RooArgSet*_projDepsPointer to set with projected observables; RooRefArrayRooAbsArg::_proxyListlist of proxies; string_rangeNameName of range in which to calculate test statistic; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Int_t_setNumPartition number of this instance in parallel calculation mode; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; Int_t_simCountTotal number of component p.d.f.s in RooSimultaneous (if any); RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; Bool_t_splitRangeSplit rangeName in RooSimultaneous index labels if true; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAbsTestStatistic.html:37250,test,test,37250,root/html534/RooAbsTestStatistic.html,https://root.cern,https://root.cern/root/html534/RooAbsTestStatistic.html,2,['test'],['test']
Testability,"nterpolate(Double_t x); illegal for a TH2. Double_t Interpolate(Double_t x, Double_t y); Given a point P(x,y), Interpolate approximates the value via bilinear; interpolation based on the four nearest bin centers; see Wikipedia, Bilinear Interpolation; Andy Mastbaum 10/8/2008; vaguely based on R.Raja 6-Sep-2008. Double_t Interpolate(Double_t x, Double_t y, Double_t z); illegal for a TH2. Double_t KolmogorovTest(const TH1* h2, Option_t* option = """") const; Statistical test of compatibility in shape between; THIS histogram and h2, using Kolmogorov test.; Default: Ignore under- and overflow bins in comparison. option is a character string to specify options; ""U"" include Underflows in test; ""O"" include Overflows; ""N"" include comparison of normalizations; ""D"" Put out a line of ""Debug"" printout; ""M"" Return the Maximum Kolmogorov distance instead of prob. The returned function value is the probability of test; (much less than one means NOT compatible). The KS test uses the distance between the pseudo-CDF's obtained; from the histogram. Since in 2D the order for generating the pseudo-CDF is; arbitrary, two pairs of pseudo-CDF are used, one starting from the x axis the; other from the y axis and the maximum distance is the average of the two maximum; distances obtained. Code adapted by Rene Brun from original HBOOK routine HDIFF. Long64_t Merge(TCollection* list); Add all histograms in the collection to this histogram.; This function computes the min/max for the axes,; compute a new number of bins, if necessary,; add bin contents, errors and statistics.; If overflows are present and limits are different the function will fail.; The function returns the total number of entries in the result histogram; if the merge is successfull, -1 otherwise. IMPORTANT remark. The 2 axis x and y may have different number; of bins and different limits, BUT the largest bin width must be; a multiple of the smallest bin width and the upper limit must also; be a multiple of the bin width. TH2 * Reb",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TH2.html:40047,test,test,40047,root/html528/TH2.html,https://root.cern,https://root.cern/root/html528/TH2.html,6,['test'],['test']
Testability,"nterpretation of number depends on code:; 1551/// - Relative: relative adjustment factor for a normalized function,; 1552/// - NumEvent: scale to match given number of events.; 1553/// - Raw: relative adjustment factor for an un-normalized function.; 1554///; 1555/// <tr><td> `Name(const chat* name)` <td> Give curve specified name in frame. Useful if curve is to be referenced later; 1556///; 1557/// <tr><td> `Asymmetry(const RooCategory& c)` <td> Show the asymmetry of the PDF in given two-state category [F(+)-F(-)] / [F(+)+F(-)] rather than; 1558/// the PDF projection. Category must have two states with indices -1 and +1 or three states with; 1559/// indices -1,0 and +1.; 1560///; 1561/// <tr><td> `ShiftToZero(bool flag)` <td> Shift entire curve such that lowest visible point is at exactly zero. Mostly useful when plotting \f$ -\log(L) \f$ or \f$ \chi^2 \f$ distributions; 1562///; 1563/// <tr><td> `AddTo(const char* name, double_t wgtSelf, double_t wgtOther)` <td> Add constructed projection to already existing curve with given name and relative weight factors; 1564/// <tr><td> `Components(const char* names)` <td> When plotting sums of PDFs, plot only the named components (*e.g.* only; 1565/// the signal of a signal+background model).; 1566/// <tr><td> `Components(const RooArgSet& compSet)` <td> As above, but pass a RooArgSet of the components themselves.; 1567///; 1568/// <tr><th><th> Plotting control; 1569/// <tr><td> `DrawOption(const char* opt)` <td> Select ROOT draw option for resulting TGraph object. Currently supported options are ""F"" (fill), ""L"" (line), and ""P"" (points).; 1570/// \note Option ""P"" will cause RooFit to plot (and treat) this pdf as if it were data! This is intended for plotting ""corrected data""-type pdfs such as ""data-minus-background"" or unfolded datasets.; 1571///; 1572/// <tr><td> `LineStyle(Int_t style)` <td> Select line style by ROOT line style code, default is solid; 1573///; 1574/// <tr><td> `LineColor(Int_t color)` <td> Select line color",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RooAbsReal_8cxx_source.html:65911,log,log,65911,doc/master/RooAbsReal_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html,1,['log'],['log']
Testability,"nterpreter only dictionaries; 5368 if (interpreteronly); 5369 argvVector.push_back(string2charptr(""-interpreteronly""));; 5370 ; 5371 // Split dictionaries; 5372 if (doSplit); 5373 argvVector.push_back(string2charptr(""-split""));; 5374 ; 5375 // Targetlib; 5376 if (!targetLibName.empty()) {; 5377 argvVector.push_back(string2charptr(""-s""));; 5378 argvVector.push_back(string2charptr(targetLibName));; 5379 }; 5380 ; 5381 // Multidict support; 5382 if (multiDict); 5383 argvVector.push_back(string2charptr(""-multiDict""));; 5384 ; 5385 // Don't declare ""using namespace std""; 5386 if (noGlobalUsingStd); 5387 argvVector.push_back(string2charptr(""-noGlobalUsingStd""));; 5388 ; 5389 ; 5390 AddToArgVectorSplit(argvVector, pcmsNames, ""-m"");; 5391 ; 5392 // Inline the input header; 5393 argvVector.push_back(string2charptr(""-inlineInputHeader""));; 5394 ; 5395 // Write empty root pcms; 5396 if (writeEmptyRootPCM); 5397 argvVector.push_back(string2charptr(""-writeEmptyRootPCM""));; 5398 ; 5399 // Just test the syntax of the selection file; 5400 if (selSyntaxOnly); 5401 argvVector.push_back(string2charptr(""-selSyntaxOnly""));; 5402 ; 5403 // No include paths; 5404 if (noIncludePaths); 5405 argvVector.push_back(string2charptr(""-noIncludePaths""));; 5406 ; 5407 // Fail on warnings; 5408 if (failOnWarnings); 5409 argvVector.push_back(string2charptr(""-failOnWarnings""));; 5410 ; 5411 // Clingargs; 5412 AddToArgVector(argvVector, includes, ""-I"");; 5413 AddToArgVector(argvVector, preprocDefines, ""-D"");; 5414 AddToArgVector(argvVector, preprocUndefines, ""-U"");; 5415 AddToArgVector(argvVector, warnings, ""-W"");; 5416 ; 5417 AddToArgVector(argvVector, headersNames);; 5418 ; 5419 if (!selectionFileName.empty()) {; 5420 argvVector.push_back(string2charptr(selectionFileName));; 5421 }; 5422 ; 5423 const int argc = argvVector.size();; 5424 ; 5425 // Output commandline for rootcling; 5426 if (genreflex::verbose || printRootclingInvocation) {; 5427 std::string cmd;; 5428 for (int i = 0; i < argc; i++) {; 54",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rootcling__impl_8cxx_source.html:217493,test,test,217493,doc/master/rootcling__impl_8cxx_source.html,https://root.cern,https://root.cern/doc/master/rootcling__impl_8cxx_source.html,1,['test'],['test']
Testability,"nters.; TGLPlotCoordinates Auxilary class, holds plot dimensions.; TGLPlotPainter Base for gl plots; TGLPolyLine a polyline logical shape; TGLPolyMarker a polymarker logical shape; TGLQuadric GL quadric object; TGLRect GL rect helper/wrapper class; TGLRnrCtx Collection of objects and data passes along all rendering calls.; TGLRotateManip GL rotation manipulator widget; TGLSAFrame GUI frame for standalone viewer; TGLSAViewer Standalone GL viewer.; TGLScaleManip GL scaling manipulator widget; TGLScene Standard ROOT OpenGL scene with logial/physical shapes.; TGLScene::TSceneInfo ; TGLSceneBase Base-class for OpenGL scenes.; TGLSceneInfo Data about a scene within a viewer context.; TGLScenePad GL-scene filled via TPad-TVirtualViewer interface.; TGLSelectBuffer OpenGL select buffer with depth sorting.; TGLSelectRecord Standard GL selection record.; TGLSelectRecordBase Base class for GL selection records.; TGLSelectionBuffer Holds color buffer content for selection; TGLSphere a spherical logical shape; TGLStopwatch a GL stopwatch utility class; TGLSurfacePainter Surface painter.; TGLTF3Painter GL TF3 painter.; TGLTH3Composition Composition of TH3 objects.; TGLTH3CompositionPainter Painter to draw several TH3.; TGLTH3Slice TH3 slice; TGLText a GL text; TGLTransManip GL translation manipulator widget; TGLUtil Wrapper class for misc GL pieces; TGLUtil::TColorLocker Lock/unlock color in constructor/destructor.; TGLUtil::TDrawQualityModifier Set/restore draw quality in constructor/destructor.; TGLUtil::TDrawQualityScaler Multiply/restore draw quality in constructor/destructor.; TGLVContainer Listview container; TGLVEntry Item that goes into a TGListView container; TGLVector3 GL 3 component vector helper/wrapper class; TGLVertex3 GL 3 component vertex helper/wrapper class; TGLViewer Standard ROOT GL viewer.; TGLViewerBase GL Viewer base-class.; TGLViewerEditor GUI for editing TGLViewer attributes; TGLVoxelPainter Voxel painter; TGLWidget Window (widget) version of TGLPaintDevice",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/ClassIndex.html:80332,log,logical,80332,root/html530/ClassIndex.html,https://root.cern,https://root.cern/root/html530/ClassIndex.html,5,['log'],['logical']
Testability,"nters.; TGLPlotCoordinates Auxilary class, holds plot dimensions.; TGLPlotPainter Base for gl plots; TGLPolyLine a polyline logical shape; TGLPolyMarker a polymarker logical shape; TGLQuadric GL quadric object; TGLRect GL rect helper/wrapper class; TGLRnrCtx Collection of objects and data passes along all rendering calls.; TGLRotateManip GL rotation manipulator widget; TGLSAFrame GUI frame for standalone viewer; TGLSAViewer Standalone GL viewer.; TGLScaleManip GL scaling manipulator widget; TGLScene Standard ROOT OpenGL scene with logial/physical shapes.; TGLScene::TSceneInfo ; TGLSceneBase Base-class for OpenGL scenes.; TGLSceneInfo Data about a scene within a viewer context.; TGLScenePad GL-scene filled via TPad-TVirtualViewer interface.; TGLSelectBuffer OpenGL select buffer with depth sorting.; TGLSelectRecord Standard GL selection record.; TGLSelectRecordBase Base class for GL selection records.; TGLSelectionBuffer Holds color buffer content for selection; TGLSphere a spherical logical shape; TGLStopwatch a GL stopwatch utility class; TGLSurfacePainter Surface painter.; TGLTF3Painter GL TF3 painter.; TGLTH3Composition Composition of TH3 objects.; TGLTH3CompositionPainter Painter to draw several TH3.; TGLTH3Slice TH3 slice; TGLText a GL text; TGLTransManip GL translation manipulator widget; TGLUtil Wrapper class for misc GL pieces; TGLUtil::TColorLocker Lock/unlock color in constructor/destructor.; TGLUtil::TDrawQualityModifier Set/restore draw quality in constructor/destructor.; TGLUtil::TDrawQualityScaler Multiply/restore draw quality in constructor/destructor.; TGLVContainer Listview container; TGLVEntry Item that goes into a TGListView container; TGLVector3 GL 3 component vector helper/wrapper class; TGLVertex3 GL 3 component vertex helper/wrapper class; TGLViewer Standard ROOT GL viewer.; TGLViewerBase GL Viewer base-class.; TGLViewerEditor GUI for editing TGLViewer attributes; TGLWidget Window (widget) version of TGLPaintDevice; TGLabel A label GUI element; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ClassIndex.html:76304,log,logical,76304,root/html526/ClassIndex.html,https://root.cern,https://root.cern/root/html526/ClassIndex.html,2,['log'],['logical']
Testability,"nters.; TGLPlotCoordinates Auxilary class, holds plot dimensions.; TGLPlotPainter Base for gl plots; TGLPolyLine a polyline logical shape; TGLPolyMarker a polymarker logical shape; TGLQuadric GL quadric object; TGLRect GL rect helper/wrapper class; TGLRnrCtx Collection of objects and data passes along all rendering calls.; TGLRotateManip GL rotation manipulator widget; TGLSAFrame GUI frame for standalone viewer; TGLSAViewer Standalone GL viewer.; TGLScaleManip GL scaling manipulator widget; TGLScene Standard ROOT OpenGL scene with logial/physical shapes.; TGLScene::TSceneInfo ; TGLSceneBase Base-class for OpenGL scenes.; TGLSceneInfo Data about a scene within a viewer context.; TGLScenePad GL-scene filled via TPad-TVirtualViewer interface.; TGLSelectBuffer OpenGL select buffer with depth sorting.; TGLSelectRecord Standard GL selection record.; TGLSelectRecordBase Base class for GL selection records.; TGLSelectionBuffer Holds color buffer content for selection; TGLSphere a spherical logical shape; TGLStopwatch a GL stopwatch utility class; TGLSurfacePainter Surface painter.; TGLTF3Painter GL TF3 painter.; TGLTH3Slice TH3 slice; TGLText a GL text; TGLTransManip GL translation manipulator widget; TGLUtil Wrapper class for misc GL pieces; TGLUtil::TColorLocker Lock/unlock color in constructor/destructor.; TGLUtil::TDrawQualityModifier Set/restore draw quality in constructor/destructor.; TGLUtil::TDrawQualityScaler Multiply/restore draw quality in constructor/destructor.; TGLVContainer Listview container; TGLVEntry Item that goes into a TGListView container; TGLVector3 GL 3 component vector helper/wrapper class; TGLVertex3 GL 3 component vertex helper/wrapper class; TGLViewer Standard ROOT GL viewer.; TGLViewerBase GL Viewer base-class.; TGLViewerEditor GUI for editing TGLViewer attributes; TGLWidget Window (widget) version of TGLPaintDevice; TGLabel A label GUI element; TGLayoutHints Class describing GUI layout hints; TGLayoutManager Layout manager abstract base class; T",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html524/ClassIndex.html:74491,log,logical,74491,root/html524/ClassIndex.html,https://root.cern,https://root.cern/root/html524/ClassIndex.html,1,['log'],['logical']
Testability,"ntf(defhist, sizeof(defhist), ""%s/.root_hist"", gSystem->HomeDirectory());; 259 logon = gEnv->GetValue(""Rint.History"", defhist);; 260 // In the code we had HistorySize and HistorySave, in the rootrc and doc; 261 // we have HistSize and HistSave. Keep the doc as it is and check; 262 // now also for HistSize and HistSave in case the user did not use; 263 // the History versions; 264 int hist_size = gEnv->GetValue(""Rint.HistorySize"", 500);; 265 if (hist_size == 500); 266 hist_size = gEnv->GetValue(""Rint.HistSize"", 500);; 267 int hist_save = gEnv->GetValue(""Rint.HistorySave"", 400);; 268 if (hist_save == 400); 269 hist_save = gEnv->GetValue(""Rint.HistSave"", 400);; 270 const char *envHist = gSystem->Getenv(""ROOT_HIST"");; 271 if (envHist) {; 272 hist_size = atoi(envHist);; 273 envHist = strchr(envHist, ':');; 274 if (envHist); 275 hist_save = atoi(envHist+1);; 276 }; 277 Gl_histsize(hist_size, hist_save);; 278 Gl_histinit((char *)logon);; 279 ; 280 // black on white or white on black?; 281 static const char* defaultColorsBW[] = {; 282 ""bold blue"", ""magenta"", ""bold green"", ""bold red underlined"", ""default""; 283 };; 284 static const char* defaultColorsWB[] = {; 285 ""yellow"", ""magenta"", ""bold green"", ""bold red underlined"", ""default""; 286 };; 287 ; 288 const char** defaultColors = defaultColorsBW;; 289 TString revColor = gEnv->GetValue(""Rint.ReverseColor"", ""no"");; 290 if (revColor.Contains(""yes"", TString::kIgnoreCase)) {; 291 defaultColors = defaultColorsWB;; 292 }; 293 TString colorType = gEnv->GetValue(""Rint.TypeColor"", defaultColors[0]);; 294 TString colorTabCom = gEnv->GetValue(""Rint.TabComColor"", defaultColors[1]);; 295 TString colorBracket = gEnv->GetValue(""Rint.BracketColor"", defaultColors[2]);; 296 TString colorBadBracket = gEnv->GetValue(""Rint.BadBracketColor"", defaultColors[3]);; 297 TString colorPrompt = gEnv->GetValue(""Rint.PromptColor"", defaultColors[4]);; 298 Gl_setColors(colorType, colorTabCom, colorBracket, colorBadBracket, colorPrompt);; 299 ; 300 Gl_windowchang",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TRint_8cxx_source.html:9413,log,logon,9413,doc/master/TRint_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TRint_8cxx_source.html,1,['log'],['logon']
Testability,"ntless. */; 15360 if ((fi.access.fp == NULL); 15361 && (conn->phys_ctx->callbacks.log_access == NULL)) {; 15362 return;; 15363 }; 15364 ; 15365 /* If we did not get a log message from Lua, create it here. */; 15366 if (!log_buf[0]) {; 15367 tm = localtime(&conn->conn_birth_time);; 15368 if (tm != NULL) {; 15369 strftime(date, sizeof(date), ""%d/%b/%Y:%H:%M:%S %z"", tm);; 15370 } else {; 15371 mg_strlcpy(date, ""01/Jan/1970:00:00:00 +0000"", sizeof(date));; 15372 date[sizeof(date) - 1] = '\0';; 15373 }; 15374 ; 15375 ri = &conn->request_info;; 15376 ; 15377 sockaddr_to_string(src_addr, sizeof(src_addr), &conn->client.rsa);; 15378 referer = header_val(conn, ""Referer"");; 15379 user_agent = header_val(conn, ""User-Agent"");; 15380 ; 15381 mg_snprintf(conn,; 15382 NULL, /* Ignore truncation in access log */; 15383 log_buf,; 15384 sizeof(log_buf),; 15385 ""%s - %s [%s] \""%s %s%s%s HTTP/%s\"" %d %"" INT64_FMT; 15386 "" %s %s"",; 15387 src_addr,; 15388 (ri->remote_user == NULL) ? ""-"" : ri->remote_user,; 15389 date,; 15390 ri->request_method ? ri->request_method : ""-"",; 15391 ri->request_uri ? ri->request_uri : ""-"",; 15392 ri->query_string ? ""?"" : """",; 15393 ri->query_string ? ri->query_string : """",; 15394 ri->http_version,; 15395 conn->status_code,; 15396 conn->num_bytes_sent,; 15397 referer,; 15398 user_agent);; 15399 }; 15400 ; 15401 /* Here we have a log message in log_buf. Call the callback */; 15402 if (conn->phys_ctx->callbacks.log_access) {; 15403 if (conn->phys_ctx->callbacks.log_access(conn, log_buf)) {; 15404 /* do not log if callack returns non-zero */; 15405 if (fi.access.fp) {; 15406 mg_fclose(&fi.access);; 15407 }; 15408 return;; 15409 }; 15410 }; 15411 ; 15412 /* Store in file */; 15413 if (fi.access.fp) {; 15414 int ok = 1;; 15415 flockfile(fi.access.fp);; 15416 if (fprintf(fi.access.fp, ""%s\n"", log_buf) < 1) {; 15417 ok = 0;; 15418 }; 15419 if (fflush(fi.access.fp) != 0) {; 15420 ok = 0;; 15421 }; 15422 funlockfile(fi.access.fp);; 15423 if (mg_fclose(&fi.access) != 0)",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:454824,log,log,454824,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,2,['log'],['log']
Testability,"ntless. */; 15361 if ((fi.access.fp == NULL); 15362 && (conn->phys_ctx->callbacks.log_access == NULL)) {; 15363 return;; 15364 }; 15365 ; 15366 /* If we did not get a log message from Lua, create it here. */; 15367 if (!log_buf[0]) {; 15368 tm = localtime(&conn->conn_birth_time);; 15369 if (tm != NULL) {; 15370 strftime(date, sizeof(date), ""%d/%b/%Y:%H:%M:%S %z"", tm);; 15371 } else {; 15372 mg_strlcpy(date, ""01/Jan/1970:00:00:00 +0000"", sizeof(date));; 15373 date[sizeof(date) - 1] = '\0';; 15374 }; 15375 ; 15376 ri = &conn->request_info;; 15377 ; 15378 sockaddr_to_string(src_addr, sizeof(src_addr), &conn->client.rsa);; 15379 referer = header_val(conn, ""Referer"");; 15380 user_agent = header_val(conn, ""User-Agent"");; 15381 ; 15382 mg_snprintf(conn,; 15383 NULL, /* Ignore truncation in access log */; 15384 log_buf,; 15385 sizeof(log_buf),; 15386 ""%s - %s [%s] \""%s %s%s%s HTTP/%s\"" %d %"" INT64_FMT; 15387 "" %s %s"",; 15388 src_addr,; 15389 (ri->remote_user == NULL) ? ""-"" : ri->remote_user,; 15390 date,; 15391 ri->request_method ? ri->request_method : ""-"",; 15392 ri->request_uri ? ri->request_uri : ""-"",; 15393 ri->query_string ? ""?"" : """",; 15394 ri->query_string ? ri->query_string : """",; 15395 ri->http_version,; 15396 conn->status_code,; 15397 conn->num_bytes_sent,; 15398 referer,; 15399 user_agent);; 15400 }; 15401 ; 15402 /* Here we have a log message in log_buf. Call the callback */; 15403 if (conn->phys_ctx->callbacks.log_access) {; 15404 if (conn->phys_ctx->callbacks.log_access(conn, log_buf)) {; 15405 /* do not log if callack returns non-zero */; 15406 if (fi.access.fp) {; 15407 mg_fclose(&fi.access);; 15408 }; 15409 return;; 15410 }; 15411 }; 15412 ; 15413 /* Store in file */; 15414 if (fi.access.fp) {; 15415 int ok = 1;; 15416 flockfile(fi.access.fp);; 15417 if (fprintf(fi.access.fp, ""%s\n"", log_buf) < 1) {; 15418 ok = 0;; 15419 }; 15420 if (fflush(fi.access.fp) != 0) {; 15421 ok = 0;; 15422 }; 15423 funlockfile(fi.access.fp);; 15424 if (mg_fclose(&fi.access) != 0)",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:454857,log,log,454857,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,2,['log'],['log']
Testability,"ntral, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tRooAbsPdf::mustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; const char*RooAbsPdf::normRange() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooJeffreysPrior&operator=(const RooJeffreysPrior&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); const RooArgList&paramList() const; virtual RooPlot*RooAbsPdf::paramOn(RooPlot* frame, const RooAbsData* data, const char* label = """", Int_t sigDigits = 2, Option_t* options = ""NELU"", Double_t xmin = 0.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooJeffreysPrior.html:23099,test,testArg,23099,root/html602/RooJeffreysPrior.html,https://root.cern,https://root.cern/root/html602/RooJeffreysPrior.html,2,['test'],['testArg']
Testability,"ntributors see $ROOTSYS/README/CREDITS. *; 10 *************************************************************************/; 11 ; 12/**; 13 ; 14\class TRandom; 15 ; 16@ingroup Random; 17 ; 18This is the base class for the ROOT Random number generators.; 19This class defines the ROOT Random number interface and it should not be instantiated directly but used via its derived; 20classes. The generator provided in TRandom itself is a LCG (Linear Congruential Generator), the <a; 21href=""https://www.gnu.org/software/gsl/manual/html_node/Unix-random-number-generators.html"">BSD `rand` generator</a>,; 22that it should not be used because its period is only 2**31, i.e. approximately 2 billion events, that can be generated; 23in just few seconds.; 24 ; 25To generate random numbers, one should use one of the derived classes, which are:; 26- TRandom3: it is based on the ""Mersenne Twister generator"",; 27it is fast and a very long period of about \f$10^{6000}\f$. However it fails some of the most stringent tests of the; 28<a href=""http://simul.iro.umontreal.ca/testu01/tu01.html"">TestU01 suite</a>.; 29In addition this generator provide only numbers with 32 random bits, which might be not sufficient for some application; 30based on double or extended precision. This generator is however used in ROOT used to instantiate the global pointer to; 31the ROOT generator, *gRandom*.; 32- ::TRandomRanluxpp : New implementation of the Ranlux generator algorithm based on a fast modular multiplication of; 33576 bits. This new implementation is built on the idea and the original code of Alexei Sibidanov, described in his; 34<a href=""https://arxiv.org/abs/1705.03123"">paper </a>. It generates random numbers with 52 bit precision (double; 35precision) and it has an higher luxury level than the original Ranlux generator (`p = 2048` instead of `p=794`).; 36- ::TRandomMixMax: Generator based on the family of the MIXMAX matrix generators (see the; 37<a href=""https://mixmax.hepforge.org"">MIXMAX HEPFORGE Web ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TRandom_8cxx_source.html:1517,test,tests,1517,doc/master/TRandom_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TRandom_8cxx_source.html,1,['test'],['tests']
Testability,"nts (minimal expected frequency equal to one) and the weighted histogram with 500 events (minimal expected frequency equal to 25); ///. Fig 2. An example of comparison of the unweighted histogram with 217 events and the weighted histogram with 500 events:; unweighted histogram;; weighted histogram;; normalized residuals plot;; normal Q-Q plot of residuals. The value of the test statistic \( \chi^{2} \) is equal to 32.33 with p-value equal to 0.029, therefore the hypothesis of identity of the two histograms is rejected for 0.05 significant level. The behavior of the normalized residuals plot (see Fig. 2c) and the normal Q-Q plot (see Fig. 2d) of residuals are not regular and we can identify the outlier or bin with a big influence on \( \chi^{2} \).; References:. [1] Pearson, K., 1904. On the Theory of Contingency and Its Relation to Association and Normal Correlation. Drapers' Co. Memoirs, Biometric Series No. 1, London.; [2] Gagunashvili, N., 2006. \( \sigma^{2} \) test for comparison of weighted and unweighted histograms. Statistical Problems in Particle Physics, Astrophysics and Cosmology, Proceedings of PHYSTAT05, Oxford, UK, 12-15 September 2005, Imperial College Press, London, 43-44. Gagunashvili,N., Comparison of weighted and unweighted histograms, arXiv:physics/0605123, 2006.; [3] Cramer, H., 1946. Mathematical methods of statistics. Princeton University Press, Princeton.; [4] Haberman, S.J., 1973. The analysis of residuals in cross-classified tables. Biometrics 29, 205-220.; [5] Lewontin, R.C. and Felsenstein, J., 1965. The robustness of homogeneity test in 2xN tables. Biometrics 21, 19-33.; [6] Seber, G.A.F., Lee, A.J., 2003, Linear Regression Analysis. John Wiley & Sons Inc., New York. . Definition at line 2008 of file TH1.cxx. Chi2TestX(). Double_t TH1::Chi2TestX ; (; const TH1 *; h2, . Double_t &; chi2, . Int_t &; ndf, . Int_t &; igood, . Option_t *; option = ""UU"", . Double_t *; res = nullptr. ); const. virtual . The computation routine of the C",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTH1.html:98174,test,test,98174,doc/master/classTH1.html,https://root.cern,https://root.cern/doc/master/classTH1.html,1,['test'],['test']
Testability,"nts (to pre-allocate vector); 52 */; 53 ; 54 explicit UnBinData( unsigned int maxpoints = 0, unsigned int dim = 1,; 55 bool isWeighted = false ) :; 56 FitData( maxpoints, isWeighted ? dim + 1 : dim ),; 57 fWeighted(isWeighted); 58 {; 59 assert( dim >= 1 );; 60 assert( !fWeighted || dim >= 2 );; 61 }; 62 ; 63 ; 64 /**; 65 constructor from range and default option; 66 */; 67 explicit UnBinData ( const DataRange & range, unsigned int maxpoints = 0,; 68 unsigned int dim = 1, bool isWeighted = false ) :; 69 FitData( range, maxpoints, isWeighted ? dim + 1 : dim ),; 70 fWeighted(isWeighted); 71 {; 72 assert( dim >= 1 );; 73 assert( !fWeighted || dim >= 2 );; 74 }; 75 ; 76 /**; 77 constructor from options and range; 78 */; 79 UnBinData (const DataOptions & opt, const DataRange & range,; 80 unsigned int maxpoints = 0, unsigned int dim = 1, bool isWeighted = false ) :; 81 FitData( opt, range, maxpoints, isWeighted ? dim + 1 : dim ),; 82 fWeighted(isWeighted); 83 {; 84 assert( dim >= 1 );; 85 assert( !fWeighted || dim >= 2 );; 86 }; 87 ; 88 /**; 89 constructor for 1D external data (data are not copied inside); 90 */; 91 UnBinData(unsigned int n, const double * dataX ) :; 92 FitData( n, dataX ),; 93 fWeighted( false ); 94 {; 95 }; 96 ; 97 /**; 98 constructor for 2D external data (data are not copied inside); 99 or 1D data with a weight (if isWeighted = true); 100 */; 101 UnBinData(unsigned int n, const double * dataX, const double * dataY,; 102 bool isWeighted = false ) :; 103 FitData( n, dataX, dataY ),; 104 fWeighted( isWeighted ); 105 {; 106 }; 107 ; 108 /**; 109 constructor for 3D external data (data are not copied inside); 110 or 2D data with a weight (if isWeighted = true); 111 */; 112 UnBinData(unsigned int n, const double * dataX, const double * dataY,; 113 const double * dataZ, bool isWeighted = false ) :; 114 FitData( n, dataX, dataY, dataZ ),; 115 fWeighted( isWeighted ); 116 {; 117 }; 118 ; 119 /**; 120 constructor for multi-dim external data (data are not copied ins",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/UnBinData_8h_source.html:2965,assert,assert,2965,doc/master/UnBinData_8h_source.html,https://root.cern,https://root.cern/doc/master/UnBinData_8h_source.html,1,['assert'],['assert']
Testability,"nts, . std::function< void(unsigned int)> &&; f. ). Definition at line 1033 of file RLoopManager.cxx. Report(). void RLoopManager::Report ; (; ROOT::RDF::RCutFlowReport &; rep); const. finalvirtual . Call FillReport on all booked filters. ; Implements ROOT::Detail::RDF::RNodeBase.; Definition at line 1012 of file RLoopManager.cxx. Run(). void RLoopManager::Run ; (; bool; jit = true). Start the event loop with a different mechanism depending on IMT/no IMT, data source/no data source. ; Also perform a few setup and clean-up operations (jit actions if necessary, clear booked actions after the loop...). The jitting phase is skipped if the jit parameter is false (unsafe, use with care). ; Definition at line 889 of file RLoopManager.cxx. RunAndCheckFilters(). void RLoopManager::RunAndCheckFilters ; (; unsigned int; slot, . Long64_t; entry. ). private . Execute actions and make sure named filters are called for each event. ; Named filters must be called even if the analysis logic would not require it, lest they report confusing results. ; Definition at line 708 of file RLoopManager.cxx. RunDataSource(). void RLoopManager::RunDataSource ; (; ). private . Run event loop over data accessed through a DataSource, in sequence. ; Definition at line 635 of file RLoopManager.cxx. RunDataSourceMT(). void RLoopManager::RunDataSourceMT ; (; ). private . Run event loop over data accessed through a DataSource, in parallel. ; Definition at line 666 of file RLoopManager.cxx. RunEmptySource(). void RLoopManager::RunEmptySource ; (; ). private . Run event loop with no source files, in sequence. ; Definition at line 505 of file RLoopManager.cxx. RunEmptySourceMT(). void RLoopManager::RunEmptySourceMT ; (; ). private . Run event loop with no source files, in parallel. ; Definition at line 458 of file RLoopManager.cxx. RunTreeProcessorMT(). void RLoopManager::RunTreeProcessorMT ; (; ). private . Run event loop over one or multiple ROOT files, in parallel. ; Definition at",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Detail_1_1RDF_1_1RLoopManager.html:24339,log,logic,24339,doc/master/classROOT_1_1Detail_1_1RDF_1_1RLoopManager.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Detail_1_1RDF_1_1RLoopManager.html,1,['log'],['logic']
Testability,"nts. This is useful for example in signal plus background fit, where one can fit directly the number of signal and background events, without the need to use something like TF1::IntegralError. See the tutorial tutorials/fit/fitNormSum.C as an example on how to use the TF1NormSum and perform such a fit. TF1Convolution. Another helper functor class for performing numerical convolution of functions, expressed as TF1 objects, using Fast Fourier Transform. The class requires the FFTW package installed in ROOT. The tutorial tutorials/fit/fitConvolution.C provides an example on how to create a TF1 based on the convolution of two others TF1 objects and used it to fit some data. TGraph2DPainter. In some case and extra point was drawn in the center od the plot when a TGRaph2dwas drawn with P, P0, or PCOL options. THistPainter. It was possible to interactively zoom outside the histograms limits. Protections have been added.; When an histogram was drawn with the option E0 and log scale along the Y axis, some additional markers were drawn at the bottom line of the plot. This was reported <a href=http://root.cern.ch/phpBB3/viewtopic.php?f=3&t=18778>here.; Implement the option 0 combined with the option COL as requested <a href=https://root.cern.ch/phpBB3/viewtopic.php?f=3&t=19046>here. When the minimum of the histogram is set to a greater value than the real minimum, the bins having a value between the real minimum and the new minimum are not drawn unless the option 0 is set.; Example:; {; TCanvas *c1 = new TCanvas(""c1"",""c1"",600,600);; c1->Divide(1,2);; TH2F *hcol21 = new TH2F(""hcol21"",""Option COLZ"",40,-4,4,40,-20,20);; TH2F *hcol22 = new TH2F(""hcol22"",""Option COLZ0"",40,-4,4,40,-20,20);; Float_t px, py;; for (Int_t i = 0; i < 25000; i++) {; gRandom->Rannor(px,py);; hcol21->Fill(px,5*py);; hcol22->Fill(px,5*py);; }; hcol21->SetBit(TH1::kNoStats);; hcol22->SetBit(TH1::kNoStats);; gStyle->SetPalette(1);; c1->cd(1); hcol21->Draw(""COLZ"");; c1->cd(2); hcol22->Draw(""COLZ0"");; hcol22",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v604/release-notes.html:17122,log,log,17122,doc/v604/release-notes.html,https://root.cern,https://root.cern/doc/v604/release-notes.html,1,['log'],['log']
Testability,"nts.; Bool_tTEveElement::fPickable; list<TEveProjected*>TEveProjectable::fProjectedListreferences to projected instances.; Bool_tTEveElement::fRnrChildrenRender children of this element.; Bool_tTEveElement::fRnrSelfRender this element.; Bool_tTEveElement::fSelected!; TRefTEveElement::fSourceExternal object that is represented by this element.; TStringTNamed::fTitleobject title; Int_tTEveElement::fTopItemCnt! Counter for top-level list-tree items that prevent automatic destruction.; void*TEveElement::fUserData! Externally assigned and controlled user data.; TEveElement*TEveElement::fVizModel! Element used as model from VizDB.; TStringTEveElement::fVizTagTag used to query VizDB for model element. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TEveSceneList(const char* n = ""TEveSceneList"", const char* t = """"); Constructor. void DestroyScenes(); Destroy all scenes and their contents.; Tho object with non-zero deny-destroy will still survive. void RepaintChangedScenes(Bool_t dropLogicals); Repaint scenes that are tagged as changed. void RepaintAllScenes(Bool_t dropLogicals); Repaint all scenes. void DestroyElementRenderers(TEveElement* element); Loop over all scenes and remove all instances of element from; them. void ProcessSceneChanges(Bool_t dropLogicals, TExMap* stampMap); Loop over all scenes and update them accordingly:; a) if scene is marked as changed, it is repainted;; b) otherwise iteration is done over the set of stamped elements and; their physical/logical shapes are updated accordingly. This allows much finer update granularity without resetting of; complex GL-viewer and GL-scene state. TEveScene& operator=(const TEveSceneList& ). TEveSceneList(const TEveSceneList& ). virtual ~TEveSceneList(); {}.  Last changed: root/eve:$Id$  Last generated: 2015-03-13 19:22; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TEveSceneList.html:20622,log,logical,20622,root/html534/TEveSceneList.html,https://root.cern,https://root.cern/root/html534/TEveSceneList.html,1,['log'],['logical']
Testability,"nts.; This version is maintained for backward compatability reasons. Bool_t CheckNetrc(TString& user, TString& passwd, Bool_t& pwhash, Bool_t srppwd); Try to get user name and passwd from the ~/.rootnetrc or; ~/.netrc files. First ~/.rootnetrc is tried, after that ~/.netrc.; These files will only be used when their access masks are 0600.; Returns kTRUE if user and passwd were found for the machine; specified in the URL. If kFALSE, user and passwd are """".; If srppwd == kTRUE then a SRP ('secure') pwd is searched for in; the files.; The boolean pwhash is set to kTRUE if the returned passwd is to; be understood as password hash, i.e. if the 'password-hash' keyword; is found in the 'machine' lines; not implemented for 'secure'; and the .netrc file.; The format of these files are:. # this is a comment line; machine <machine fqdn> login <user> password <passwd>; machine <machine fqdn> login <user> password-hash <passwd>. and in addition ~/.rootnetrc also supports:. secure <machine fqdn> login <user> password <passwd>. <machine fqdn> may be a domain name or contain the wild card '*'. for the secure protocols. All lines must start in the first column. const char * GetGlobalUser(); Static method returning the global user. Bool_t GetGlobalPwHash(); Static method returning the global password hash flag. Bool_t GetGlobalSRPPwd(); Static method returning the global SRP password flag. TDatime GetGlobalExpDate(); Static method returning default expiring date for new validity contexts. const char * GetDefaultUser(); Static method returning the default user information. const char * GetKrb5Principal(); Static method returning the principal to be used to init Krb5 tickets. Bool_t GetAuthReUse(); Static method returning the authentication reuse settings. Bool_t GetPromptUser(); Static method returning the prompt user settings. const char * GetAuthMethod(Int_t idx); Static method returning the method corresponding to idx. Int_t GetAuthMethodIdx(const char* meth); Static method returnin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/TAuthenticate.html:12815,log,login,12815,root/html526/TAuthenticate.html,https://root.cern,https://root.cern/root/html526/TAuthenticate.html,7,['log'],['login']
Testability,"nts: 0.877 sec ; BDT : [dataset] : Evaluation of BDT on training sample (1600 events); : Elapsed time for evaluation of 1600 events: 0.0172 sec ; : Creating xml weight file: [0;36mdataset/weights/TMVA_CNN_Classification_BDT.weights.xml[0m; : Creating standalone class: [0;36mdataset/weights/TMVA_CNN_Classification_BDT.class.C[0m; : TMVA_CNN_ClassificationOutput.root:/dataset/Method_BDT/BDT; Factory : Training finished; : ; Factory : Train method: TMVA_DNN_CPU for Classification; : ; : Start of deep neural network training on CPU using MT, nthreads = 4; : ; : ***** Deep Learning Network *****; DEEP NEURAL NETWORK: Depth = 8 Input = ( 1, 1, 256 ) Batch size = 100 Loss function = C; Layer 0 DENSE Layer: ( Input = 256 , Width = 100 ) Output = ( 1 , 100 , 100 ) Activation Function = Relu; Layer 1 BATCH NORM Layer: Input/Output = ( 100 , 100 , 1 ) Norm dim = 100 axis = -1; ; Layer 2 DENSE Layer: ( Input = 100 , Width = 100 ) Output = ( 1 , 100 , 100 ) Activation Function = Relu; Layer 3 BATCH NORM Layer: Input/Output = ( 100 , 100 , 1 ) Norm dim = 100 axis = -1; ; Layer 4 DENSE Layer: ( Input = 100 , Width = 100 ) Output = ( 1 , 100 , 100 ) Activation Function = Relu; Layer 5 BATCH NORM Layer: Input/Output = ( 100 , 100 , 1 ) Norm dim = 100 axis = -1; ; Layer 6 DENSE Layer: ( Input = 100 , Width = 100 ) Output = ( 1 , 100 , 100 ) Activation Function = Relu; Layer 7 DENSE Layer: ( Input = 100 , Width = 1 ) Output = ( 1 , 100 , 1 ) Activation Function = Identity; : Using 1280 events for training and 320 for testing; : Compute initial loss on the validation data ; : Training phase 1 of 1: Optimizer ADAM (beta1=0.9,beta2=0.999,eps=1e-07) Learning rate = 0.001 regularization 0 minimum error = 119.005; : --------------------------------------------------------------; : Epoch | Train Err. Val. Err. t(s)/epoch t(s)/Loss nEvents/s Conv. Steps; : --------------------------------------------------------------; : Start epoch iteration ...; : 1 Minimum Test error found - save the co",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVA__CNN__Classification_8C.html:11127,test,testing,11127,doc/master/TMVA__CNN__Classification_8C.html,https://root.cern,https://root.cern/doc/master/TMVA__CNN__Classification_8C.html,1,['test'],['testing']
Testability,"ntzVector (const ForeignLorentzVector &v); Construct from a foreign 4D vector type, for example, HepLorentzVector Precondition: v must implement methods x(), y(), z(), and t() ; ; template<class Coords > ; constexprLorentzVector (const LorentzVector< Coords > &v); constructor from a LorentzVector expressed in different coordinates, or using a different Scalar type ; ; LorentzVector (const Scalar &a, const Scalar &b, const Scalar &c, const Scalar &d); generic constructors from four scalar values. ; ; ScalarBeta () const; Return beta scalar value. ; ; BetaVectorBoostToCM () const; The beta vector for the boost that would bring this vector into its center of mass frame (zero momentum) ; ; template<class Other4Vector > ; BetaVectorBoostToCM (const Other4Vector &v) const; The beta vector for the boost that would bring this vector into its center of mass frame (zero momentum) ; ; ScalarColinearRapidity () const; Rapidity in the direction of travel: atanh (|P|/E)=.5 log[(E+P)/(E-P)]. ; ; const CoordSystem &Coordinates () const; Retrieve a const reference to the coordinates object. ; ; unsigned intDimension () const; dimension ; ; template<class OtherLorentzVector > ; ScalarDot (const OtherLorentzVector &q) const; scalar (Dot) product of two LorentzVector vectors (metric is -,-,-,+) Enable the product using any other LorentzVector implementing the x(), y() , y() and t() member functions ; ; ScalarE () const; return 4-th component (time, or energy for a 4-momentum vector) ; ; Scalare () const; ; Scalarenergy () const; ; ScalarEt () const; return the transverse energy ; ; ScalarEt2 () const; return the transverse energy squared ; ; ScalarEta () const; pseudorapidity ; ; Scalareta () const; ; ScalarGamma () const; Return Gamma scalar value. ; ; template<class IT > ; voidGetCoordinates (IT begin) const; get internal data into 4 Scalars at *begin ; ; template<class IT > ; voidGetCoordinates (IT begin, IT end) const; get inter",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1LorentzVector.html:3316,log,log,3316,doc/master/classROOT_1_1Math_1_1LorentzVector.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1LorentzVector.html,1,['log'],['log']
Testability,"nu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). }; . Public Member Functions; TMultiLayerPerceptron (); Default constructor. ; ; TMultiLayerPerceptron (const char *layout, const char *weight, TTree *data, TEventList *training, TEventList *test, TNeuron::ENeuronType type=TNeuron::kSigmoid, const char *extF="""", const char *extD=""""); The network is described by a simple string: The input/output layers are defined by giving the branch names separated by comas. ; ; TMultiLayerPerceptron (const char *layout, const char *weight, TTree *data=nullptr, const char *training=""Entry$%2==0"", const char *test="""", TNeuron::ENeuronType type=TNeuron::kSigmoid, const char *extF="""", const char *extD=""""); The network is described by a simple string: The input/output layers are defined by giving the branch names separated by comas. ; ; TMultiLayerPerceptron (const char *layout, TTree *data, TEventList *training, TEventList *test, TNeuron::ENeuronType type=TNeuron::kSigmoid, const char *extF="""", const char *extD=""""); The network is described by a simple string: The input/output layers are defined by giving the branch names separated by comas. ; ; TMultiLayerPerceptron (const char *layout, TTree *data=nullptr, const char *training=""Entry$%2==0"", const char *test="""", TNeuron::ENeuronType type=TNeuron::kSigmoid, const char *extF="""", const char *extD=""""); The network is described by a simple string: The input/output layers are defined by giving the branch names separated by comas. ; ; ~TMultiLayerPerceptron () override; Destructor. ; ; voidComputeDEDw () const; Compute the DEDw = sum on all training events of dedw for each weight normalized by the number of events. ; ; voidDraw (Option_t *option="""") override; Draws the network structure. ; ; voidDrawResult (Int_t index=0, Option_t *option=""test"") const; Draws the neural net output It produces an histogram with the output for the two datasets. ; ; Bool_tDumpWeights (Option_t *filename=""-"") const; Dumps t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMultiLayerPerceptron.html:10857,test,test,10857,doc/master/classTMultiLayerPerceptron.html,https://root.cern,https://root.cern/doc/master/classTMultiLayerPerceptron.html,1,['test'],['test']
Testability,"nu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). }; ; Protected Types inherited from TObject; enum { kOnlyPrepStep = (1ULL << ( 3 )); }; ; Protected Member Functions inherited from TObject; virtual voidDoError (int level, const char *location, const char *fmt, va_list va) const; Interface to ErrorHandler (protected). ; ; voidMakeZombie (); . #include <TRandom1.h>. Inheritance diagram for TRandom1:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. TRandom1() [1/3]. TRandom1::TRandom1 ; (; ). Default constructor. ; Definition at line 284 of file TRandom1.cxx. TRandom1() [2/3]. TRandom1::TRandom1 ; (; UInt_t; seed, . Int_t; lux = 3. ). Luxury level is set in the same way as the original FORTRAN routine. . level 0 (p=24): equivalent to the original RCARRY of Marsaglia and Zaman, very long period, but fails many tests.; level 1 (p=48): considerable improvement in quality over level 0, now passes the gap test, but still fails spectral test.; level 2 (p=97): passes all known tests, but theoretically still defective.; level 3 (p=223): DEFAULT VALUE. Any theoretically possible correlations have very small chance of being observed.; level 4 (p=389): highest possible luxury, all 24 bits chaotic. . Definition at line 263 of file TRandom1.cxx. TRandom1() [3/3]. TRandom1::TRandom1 ; (; Int_t; rowIndex, . Int_t; colIndex, . Int_t; lux. ). Constructor. ; Definition at line 310 of file TRandom1.cxx. ~TRandom1(). TRandom1::~TRandom1 ; (; ). override . Destructor. ; Definition at line 336 of file TRandom1.cxx. Member Function Documentation. Class(). static TClass * TRandom1::Class ; (; ). static . ReturnsTClass describing this class . Class_Name(). static const char * TRandom1::Class_Name ; (; ). static . ReturnsName of this class . Class_Version(). static constexpr Version_t TRandom1::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTRandom1.html:16712,test,test,16712,doc/master/classTRandom1.html,https://root.cern,https://root.cern/doc/master/classTRandom1.html,2,['test'],['test']
Testability,"nu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Double_t*TMVA::PDEFoam::fAlpha[fDim] Internal parameters of the hyperrectangle; TMVA::PDEFoamCell**TMVA::PDEFoam::fCells[fNCells] Array of ALL cells; TMVA::EDTSeparationTMVA::PDEFoam::fDTSeparationBACKWARDS COMPATIBILITY: split cells according to decision tree logic; Int_tTMVA::PDEFoam::fDimDimension of the integration/simulation space; TMVA::PDEFoamDensityBase*TMVA::PDEFoam::fDistr! distribution of training events; Int_tTMVA::PDEFoam::fEvPerBinMaximum number of effective (wt=1) events per bin; Bool_tTMVA::PDEFoam::fFillFoamWithOrigWeightsBACKWARDS COMPATIBILITY: fill the foam with boost or orig. weights; TMVA::EFoamTypeTMVA::PDEFoam::fFoamTypeBACKWARDS COMPATIBILITY: type of foam; TObjArray*TMVA::PDEFoam::fHistEdgHistograms of wt, one for each cell edge; Int_t*TMVA::PDEFoam::fInhiDiv! [fDim] Flags for inhibiting cell division; Int_tTMVA::PDEFoam::fLastCeIndex of the last cell; TMVA::MsgLogger*TMVA::PDEFoam::fLogger! message logger; Int_t*TMVA::PDEFoam::fMaskDiv! [fDim] Dynamic Mask for cell division; UInt_tTMVA::PDEFoam::fMaxDepthmaximum depth of cell tree; Int_tTMVA::PDEFoam::fNBinNo. of bins in the edge histogram for cell MC exploration; Int_tTMVA::PDEFoam::fNCellsMaximum number of cells; UInt_tTMVA::PDEFoam::fNElementsBACKWARDS COMPATIBILITY: number of variables in every cell; Int_tTMVA::PDEFoam::fNSamplNo. of MC events, when dividing (exploring) cell; TStringTMVA::PDEFoam::fNameName of a given instance of the FOAM class; UInt_tTMVA::PDEFoam::fNminminimal number of events in cell to split cell; Int_tTMVA::PDEFoam::fNoActNumber of active cells; Bool_tTMVA::PDEFoam::fPeekMaxBACKWARDS COMPATIBILITY: peek up cell with max. driver integral for split; TRandom3*TMVA::PDEFoam::fPseRanPointer to user-defined generator of pseudorandom numbers; Double_t*TMVA::PDEFoam::fRvec[fDim] random number vector from r.n. generator fDim+1 m",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TMVA__PDEFoamEvent.html:10421,log,logger,10421,root/html530/TMVA__PDEFoamEvent.html,https://root.cern,https://root.cern/root/html530/TMVA__PDEFoamEvent.html,9,['log'],['logger']
Testability,"nuit) can be changed by callinga ROOT::Math::Minimizer::SetDefaultMinimizerType("".."") Other option for the minimizer can be set using the static method of the MinimizerOptions class ; Reimplemented in TF3.; Definition at line 363 of file TF2.cxx. GetContour(). Int_t TF2::GetContour ; (; Double_t *; levels = nullptr). virtual . Return contour values into array levels. ; The number of contour levels can be returned by getContourLevel ; Definition at line 326 of file TF2.cxx. GetContourLevel(). Double_t TF2::GetContourLevel ; (; Int_t; level); const. virtual . Return the number of contour levels. ; Definition at line 338 of file TF2.cxx. GetMaximum() [1/2]. Double_t TF2::GetMaximum ; (; Double_t *; x); const. virtual . Return maximum value of the function See TF2::GetMinimum. ; Definition at line 474 of file TF2.cxx. GetMaximum() [2/2]. Double_t TF1::GetMaximum ; (; Double_t; xmin = 0, . Double_t; xmax = 0, . Double_t; epsilon = 1.E-10, . Int_t; maxiter = 100, . Bool_t; logx = false. ); const. virtual . Returns the maximum value of the function. ; Method: First, the grid search is used to bracket the maximum with the step size = (xmax-xmin)/fNpx. This way, the step size can be controlled via the SetNpx() function. If the function is unimodal or if its extrema are far apart, setting the fNpx to a small value speeds the algorithm up many times. Then, Brent's method is applied on the bracketed interval epsilon (default = 1.E-10) controls the relative accuracy (if |x| > 1 ) and absolute (if |x| < 1) and maxiter (default = 100) controls the maximum number of iteration of the Brent algorithm If the flag logx is set the grid search is done in log step size This is done automatically if the log scale is set in the current Pad; NOTE: see also TF1::GetMaximumX and TF1::GetX ; Reimplemented from TF1.; Definition at line 497 of file TF1.cxx. GetMaximumXY(). Double_t TF2::GetMaximumXY ; (; Double_t &; x, . Double_t &; y. ); const. virtual . Compute the X and Y",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTF2.html:56788,log,logx,56788,doc/master/classTF2.html,https://root.cern,https://root.cern/doc/master/classTF2.html,1,['log'],['logx']
Testability,"null, Bool_t isAutomatic = kFALSE); TMVA::CostComplexityPruneToolCostComplexityPruneTool(TMVA::SeparationBase* qualityIndex = __null); TMVA::CostComplexityPruneToolCostComplexityPruneTool(const TMVA::CostComplexityPruneTool&); Double_tTMVA::IPruneTool::GetPruneStrength() const; TMVA::IPruneToolTMVA::IPruneTool::IPruneTool(); TMVA::IPruneToolTMVA::IPruneTool::IPruneTool(const TMVA::IPruneTool&); Bool_tTMVA::IPruneTool::IsAutomatic() const; TMVA::CostComplexityPruneTool&operator=(const TMVA::CostComplexityPruneTool&); voidTMVA::IPruneTool::SetAutomatic(); voidTMVA::IPruneTool::SetPruneStrength(Double_t alpha). private:. voidInitTreePruningMetaData(TMVA::DecisionTreeNode* n); TMVA::MsgLogger&Log() const; voidOptimize(TMVA::DecisionTree* dt, Double_t weights). Data Members; protected:. Double_tTMVA::IPruneTool::B; Double_tTMVA::IPruneTool::S; Double_tTMVA::IPruneTool::fPruneStrength. private:. TMVA::MsgLogger*fLogger! output stream to save logging information; Int_tfOptimalK! the optimal index of the prune sequence; vector<TMVA::DecisionTreeNode*>fPruneSequence! map of weakest links (i.e., branches to prune) -> pruning index; vector<Double_t>fPruneStrengthList! map of alpha -> pruning index; vector<Double_t>fQualityIndexList! map of R(T) -> pruning index; TMVA::SeparationBase*fQualityIndexTool! the quality index used to calculate R(t), R(T) = sum[t in ~T]{ R(t) }. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; CostComplexityPruneTool( SeparationBase* qualityIndex ); the constructor for the cost complexity prunig. ~CostComplexityPruneTool(); the destructor for the cost complexity prunig. CalculatePruningInfo(TMVA::DecisionTree* dt, const TMVA::IPruneTool::EventSample* testEvents = __null, Bool_t isAutomatic = kFALSE). void InitTreePruningMetaData(TMVA::DecisionTreeNode* n); initialise ""meta data"" for the pruning, like the ""costcomplexity"", the; critical alpha, the minimal alpha down the tree, etc... for each node!!. void Optimiz",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TMVA__CostComplexityPruneTool.html:1494,log,logging,1494,root/html602/TMVA__CostComplexityPruneTool.html,https://root.cern,https://root.cern/root/html602/TMVA__CostComplexityPruneTool.html,2,['log'],['logging']
Testability,"number and date; 1324 ; 1325void TMVA::Tools::ROOTVersionMessage( MsgLogger& logger ); 1326{; 1327 static const char * const months[] = { ""Jan"",""Feb"",""Mar"",""Apr"",""May"",; 1328 ""Jun"",""Jul"",""Aug"",""Sep"",""Oct"",; 1329 ""Nov"",""Dec"" };; 1330 Int_t idatqq = gROOT->GetVersionDate();; 1331 Int_t iday = idatqq%100;; 1332 Int_t imonth = (idatqq/100)%100;; 1333 Int_t iyear = (idatqq/10000);; 1334 TString versionDate = TString::Format(""%s %d, %4d"",months[imonth-1],iday,iyear);; 1335 ; 1336 logger << kHEADER ;; 1337 logger << ""You are running ROOT Version: "" << gROOT->GetVersion() << "", "" << versionDate << Endl;; 1338}; 1339 ; 1340////////////////////////////////////////////////////////////////////////////////; 1341/// various kinds of welcome messages; 1342/// ASCII text generated by this site: http://www.network-science.de/ascii/; 1343 ; 1344void TMVA::Tools::TMVAWelcomeMessage( MsgLogger& logger, EWelcomeMessage msgType ); 1345{; 1346 switch (msgType) {; 1347 ; 1348 case kStandardWelcomeMsg:; 1349 logger << Color(""white"") << ""TMVA -- Toolkit for Multivariate Analysis"" << Color(""reset"") << Endl;; 1350 logger << ""Copyright (C) 2005-2006 CERN, LAPP & MPI-K Heidelberg and Victoria U."" << Endl;; 1351 logger << ""Home page https://root.cern/manual/tmva/"" << Endl;; 1352 break;; 1353 ; 1354 case kIsometricWelcomeMsg:; 1355 logger << "" ___ ___ ___ ___ "" << Endl;; 1356 logger << "" /\\ \\ /\\__\\ /\\__\\ /\\ \\ "" << Endl;; 1357 logger << "" \\:\\ \\ /::| | /:/ / /::\\ \\ "" << Endl;; 1358 logger << "" \\:\\ \\ /:|:| | /:/ / /:/\\:\\ \\ "" << Endl;; 1359 logger << "" /::\\ \\ /:/|:|__|__ /:/__/ ___ /::\\~\\:\\ \\ "" << Endl;; 1360 logger << "" /:/\\:\\__\\ /:/ |::::\\__\\ |:| | /\\__\\ /:/\\:\\ \\:\\__\\ "" << Endl;; 1361 logger << "" /:/ \\/__/ \\/__/~~/:/ / |:| |/:/ / \\/__\\:\\/:/ / "" << Endl;; 1362 logger << ""/:/ / /:/ / |:|__/:/ / \\::/ / "" << Endl;; 1363 logger << ""\\/__/ /:/ / \\::::/__/ /:/ / "" << Endl;; 1364 logger << "" /:/ / ~~~~ /:/ / "" << Endl;; 1365 logger << "" \\/__/ \\/__/ "" << Endl << E",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/Tools_8cxx_source.html:47123,log,logger,47123,doc/master/Tools_8cxx_source.html,https://root.cern,https://root.cern/doc/master/Tools_8cxx_source.html,3,['log'],['logger']
Testability,"number for training and testing; columns = ROOT.std.vector[""string""](variables); df.Filter(""event % 2 == 0"", ""Select events with even event number for training"")\; .Snapshot(""Events"", ""train_"" + label + "".root"", columns); df.Filter(""event % 2 == 1"", ""Select events with odd event number for training"")\; .Snapshot(""Events"", ""test_"" + label + "".root"", columns); ; # Print cutflow report; report.Print(); formatOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid window const char font_name cursor keysym reg const char only_if_exist regb h Point_t winding char text const char depth char const char Int_t count const char ColorStruct_t color const char Pixmap_t Pixmap_t PictureAttributes_t attr const char char ret_data h unsigned char height h Atom_t Int_t ULong_t ULong_t unsigned char prop_list Atom_t Atom_t Atom_t Time_t formatDefinition TGWin32VirtualXProxy.cxx:249; ROOT::RDataFrameROOT's RDataFrame offers a modern, high-level interface for analysis of data stored in TTree ,...Definition RDataFrame.hxx:41; At least two electrons and two muons: pass=45352 all=299973 -- eff=15.12 % cumulative eff=15.12 %; At least two electrons and two muons: pass=262776 all=1497445 -- eff=17.55 % cumulative eff=17.55 %; >>> Extract the training and testing events for signal from the SMHiggsToZZTo4L.root dataset.; >>> Extract the training and testing events for background from the ZZTo2e2mu.root dataset.; DateAugust 2019 ; AuthorStefan Wunsch ; Definition in file tmva100_DataPreparation.py. tutorialstmvatmva100_DataPreparation.py. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:31 (GVA Time) using Doxygen 1.9.8 ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/tmva100__DataPreparation_8py.html:3197,test,testing,3197,doc/master/tmva100__DataPreparation_8py.html,https://root.cern,https://root.cern/doc/master/tmva100__DataPreparation_8py.html,2,['test'],['testing']
Testability,"number; TStringfOrdinalslave ordinal number; TStringfPackageDirdirectory containing packages and user libs; TProofLockPath*fPackageLockpackage dir locker; TVirtualProofPlayer*fPlayeractual player; TStringfPrefixPrefix identifying the node; TProof*fProofPROOF talking to slave servers; Int_tfProtocolprotocol version number; TQueryResultManager*fQMgrQuery-result manager; TMutex*fQMtxTo protect async msg queue; TStringfQueryDirdirectory containing query results and status; TProofLockPath*fQueryLockquery dir locker; Int_tfQuerySeqNumsequential number of the current or last query; TList*fQueuedMsglist of messages waiting to be processed; Float_tfRealTimereal time spent executing commands; Bool_tfRealTimeLogTRUE if log messages should be send back in real-time; TReaperTimer*fReaperTimerTimer used to control children state; Bool_tfSendLogToMasterOn workers, controls logs sending to master; TStringfServiceservice we are running, either ""proofserv"" or ""proofslave""; TStringfSessionDirdirectory containing session dependent files; TStringfSessionTagtag for the server session; TShutdownTimer*fShutdownTimerTimer used to shutdown out-of-control sessions; TSocket*fSocketsocket connection to client; TStringfTopSessionTagtag for the global session; Int_tfTotSessionsTotal number of PROOF sessions on the cluster ; TStringfUseruser as which we run; TList*fWaitingQuerieslist of TProofQueryResult waiting to be processed; TStringfWorkDirdirectory containing all proof related info; static FILE*fgErrorHandlerFileFile where to log; static Int_tfgLogToSysLog>0 sent to syslog too; static Float_tfgMemHWMThreshold fraction of max for warning and finer monitoring; static Float_tfgMemStopFraction of max for stop processing; static Int_tfgRecursiveKeep track of recursive inputs during processing; static Long_tfgResMemMaxHard limit on the resident memory checked; static TStringfgSysLogEntitylogging entity (<user>:<group>); static TStringfgSysLogServicename of the syslog service (eg: proofm-0, proofw-0.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TProofServ.html:19895,log,log,19895,root/html528/TProofServ.html,https://root.cern,https://root.cern/root/html528/TProofServ.html,3,['log'],['log']
Testability,"numerator=wrap_pdf=-6.32705, denominator=wrap_pdf_Int[pTV]=46316; ; RooAbsMinimizerFcn: Minimized function has error status.; Returning maximum FCN so far (86348.3) to force MIGRAD to back out of this region. Error log follows.; Parameter values: cHDD=0.218731 cHl3=0.37397 cHq3=-2.08166; RooAbsPdf::wrap_pdf_over_wrap_pdf_Int[pTV][ numerator=wrap_pdf denominator=wrap_pdf_Int[pTV] ]; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=38.6705, denominator=wrap_pdf_Int[pTV]=90131.3; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=38.6705, denominator=wrap_pdf_Int[pTV]=90131.3; getLogVal() top-level p.d.f evaluates to NaN @ numerator=wrap_pdf=38.6705, denominator=wrap_pdf_Int[pTV]=90131.3; getLogVal() top-level p.d.f evaluates to NaN @ numerator=wrap_pdf=38.6705, denominator=wrap_pdf_Int[pTV]=90131.3; ; RooAbsMinimizerFcn: Minimized function has error status.; Returning maximum FCN so far (86348.3) to force MIGRAD to back out of this region. Error log follows.; Parameter values: cHDD=3.22694 cHl3=-7.04051 cHq3=0.54016; RooAbsPdf::wrap_pdf_over_wrap_pdf_Int[pTV][ numerator=wrap_pdf denominator=wrap_pdf_Int[pTV] ]; getLogVal() top-level p.d.f evaluates to NaN @ numerator=wrap_pdf=-2.21831, denominator=wrap_pdf_Int[pTV]=89722.5; ; RooAbsMinimizerFcn: Minimized function has error status.; Returning maximum FCN so far (86348.3) to force MIGRAD to back out of this region. Error log follows.; Parameter values: cHDD=3.44258 cHl3=4.96668 cHq3=0.0273884; RooAbsPdf::wrap_pdf_over_wrap_pdf_Int[pTV][ numerator=wrap_pdf denominator=wrap_pdf_Int[pTV] ]; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=0.403042, denominator=wrap_pdf_Int[pTV]=242.998; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=0.403042, denominator=wrap_pdf_Int[pTV]=242.998; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=0.403042, denominator=wrap_pdf_Int[pTV]=242.998; p.d.f value is less than zero, trying to re",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf712__lagrangianmorphfit_8C.html:12002,log,log,12002,doc/master/rf712__lagrangianmorphfit_8C.html,https://root.cern,https://root.cern/doc/master/rf712__lagrangianmorphfit_8C.html,2,['log'],['log']
Testability,"nv' the value of double RC env variable 'rcenv' on node 'ord'. ; Definition at line 6691 of file TProof.cxx. GetRC() [2/3]. Int_t TProof::GetRC ; (; const char *; RCenv, . Int_t &; env, . const char *; ord = ""0"". ). Get into 'env' the value of integer RC env variable 'rcenv' on node 'ord'. ; Definition at line 6665 of file TProof.cxx. GetRC() [3/3]. Int_t TProof::GetRC ; (; const char *; RCenv, . TString &; env, . const char *; ord = ""0"". ). Get into 'env' the value of string RC env variable 'rcenv' on node 'ord'. ; Definition at line 6717 of file TProof.cxx. GetRealTime(). Float_t TProof::GetRealTime ; (; ); const. inline . Definition at line 930 of file TProof.h. GetRemoteProtocol(). Int_t TProof::GetRemoteProtocol ; (; ); const. inline . Definition at line 913 of file TProof.h. GetRunStatus(). ERunStatus TProof::GetRunStatus ; (; ); const. inline . Definition at line 943 of file TProof.h. GetSandbox(). Int_t TProof::GetSandbox ; (; TString &; sb, . Bool_t; assert = kFALSE, . const char *; rc = 0. ). protected . Set the sandbox path from ' Proof.Sandbox' or the alternative var 'rc'. ; Use the existing setting or the default if nothing is found. If 'assert' is kTRUE, make also sure that the path exists. Return 0 on success, -1 on failure ; Definition at line 1016 of file TProof.cxx. GetSeqNum(). Int_t TProof::GetSeqNum ; (; ); const. inline . Definition at line 918 of file TProof.h. GetSessionID(). Int_t TProof::GetSessionID ; (; ); const. inline . Definition at line 919 of file TProof.h. GetSessionTag(). const char * TProof::GetSessionTag ; (; ); const. inline . Definition at line 909 of file TProof.h. GetStagingStatusDataSet(). TFileCollection * TProof::GetStagingStatusDataSet ; (; const char *; dataset). virtual . Obtains a TFileCollection showing the staging status of the specified dataset. ; A valid dataset manager and dataset staging requests repository must be present on the endpoint. ; Reimplemented in TProofLite.; Definitio",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProof.html:105542,assert,assert,105542,doc/master/classTProof.html,https://root.cern,https://root.cern/doc/master/classTProof.html,1,['assert'],['assert']
Testability,"nvas = this;; 2231 if (v>7) b.ClassBegin(TCanvas::IsA());; 2232 if (v>7) b.ClassMember(""TPad"");; 2233 TPad::Streamer(b);; 2234 gPad = this;; 2235 //restore the colors; 2236 auto colors = dynamic_cast<TObjArray *>(fPrimitives->FindObject(""ListOfColors""));; 2237 if (colors) {; 2238 auto root_colors = dynamic_cast<TObjArray *>(gROOT->GetListOfColors());; 2239 ; 2240 TIter next(colors);; 2241 while (auto colold = static_cast<TColor *>(next())) {; 2242 Int_t cn = colold->GetNumber();; 2243 TColor *colcur = gROOT->GetColor(cn);; 2244 if (colcur && (colcur->IsA() == TColor::Class()) && (colold->IsA() == TColor::Class())) {; 2245 colcur->SetName(colold->GetName());; 2246 colcur->SetRGB(colold->GetRed(), colold->GetGreen(), colold->GetBlue());; 2247 colcur->SetAlpha(colold->GetAlpha());; 2248 } else {; 2249 if (colcur) {; 2250 if (root_colors) root_colors->Remove(colcur);; 2251 delete colcur;; 2252 }; 2253 colors->Remove(colold);; 2254 if (root_colors) {; 2255 if (colcur) {; 2256 root_colors->AddAtAndExpand(colold, cn);; 2257 }; 2258 else {; 2259 // Copy to current session; 2260 // do not use copy constructor which does not update highest color index; 2261 [[maybe_unused]] TColor* const colnew = new TColor(cn, colold->GetRed(), colold->GetGreen(), colold->GetBlue(), colold->GetName(), colold->GetAlpha());; 2262 delete colold;; 2263 // No need to delete colnew, as the constructor adds it to global list of colors; 2264 assert(root_colors->At(cn) == colnew);; 2265 }; 2266 }; 2267 }; 2268 }; 2269 //restore the palette if needed; 2270 auto palette = dynamic_cast<TObjArray *>(fPrimitives->FindObject(""CurrentColorPalette""));; 2271 if (palette) {; 2272 TIter nextcol(palette);; 2273 Int_t number = palette->GetEntries();; 2274 TArrayI palcolors(number);; 2275 Int_t i = 0;; 2276 while (auto col = static_cast<TColor *>(nextcol())); 2277 palcolors[i++] = col->GetNumber();; 2278 gStyle->SetPalette(number, palcolors.GetArray());; 2279 fPrimitives->Remove(palette);; 2280 delete palette;; 228",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCanvas_8cxx_source.html:72689,assert,assert,72689,doc/master/TCanvas_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TCanvas_8cxx_source.html,1,['assert'],['assert']
Testability,"nvas destructor. ; ; voidBrowse (TBrowser *b) override; Browse. ; ; TVirtualPad *cd (Int_t subpadnumber=0) override; Set current canvas & pad. ; ; voidClear (Option_t *option="""") override; Remove all primitives from the canvas. ; ; virtual voidCleared (TVirtualPad *pad); Emit pad Cleared signal. ; ; voidClearPadSave (); ; voidClose (Option_t *option="""") override; Close canvas. ; ; voidClosed () override; Emit Closed signal. ; ; voidConstructor (); Canvas default constructor. ; ; voidConstructor (const char *name, const char *title, Int_t form); Create a new canvas with a predefined size form. ; ; voidConstructor (const char *name, const char *title, Int_t wtopx, Int_t wtopy, Int_t ww, Int_t wh); Create a new canvas. ; ; voidConstructor (const char *name, const char *title, Int_t ww, Int_t wh); Create a new canvas at a random position. ; ; voidDelete (Option_t *="""") override; Delete this object. ; ; voidDeleteCanvasPainter (); assert on IsBatch() == false? ; ; voidDestructor (); Actual canvas destructor. ; ; voidDisconnectWidget (); Used by friend class TCanvasImp. ; ; voidDraw (Option_t *option="""") override; Draw a canvas. ; ; TObject *DrawClone (Option_t *option="""") const override; Draw a clone of this canvas A new canvas is created that is a clone of this canvas. ; ; virtual TObject *DrawClonePad (); Draw a clone of this canvas into the current pad In an interactive session, select the destination/current pad with the middle mouse button, then point to the canvas area to select the canvas context menu item DrawClonePad. ; ; virtual voidEditorBar (); Get editor bar. ; ; voidEmbedInto (Int_t winid, Int_t ww, Int_t wh); Embedded a canvas into a TRootEmbeddedCanvas. ; ; voidEnterLeave (TPad *prevSelPad, TObject *prevSelObj); Generate kMouseEnter and kMouseLeave events depending on the previously selected object and the currently selected object. ; ; voidFeedbackMode (Bool_t set); Turn rubberband feedback ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTCanvas.html:5404,assert,assert,5404,doc/v632/classTCanvas.html,https://root.cern,https://root.cern/doc/v632/classTCanvas.html,4,['assert'],['assert']
Testability,"nvas.cxx. ToggleEditor(). void TCanvas::ToggleEditor ; (; ). virtual . Toggle editor. ; Definition at line 2440 of file TCanvas.cxx. ToggleEventStatus(). void TCanvas::ToggleEventStatus ; (; ). virtual . Toggle event statusbar. ; Definition at line 2418 of file TCanvas.cxx. ToggleToolBar(). void TCanvas::ToggleToolBar ; (; ). virtual . Toggle toolbar. ; Definition at line 2429 of file TCanvas.cxx. ToggleToolTips(). void TCanvas::ToggleToolTips ; (; ). virtual . Toggle tooltip display. ; Definition at line 2451 of file TCanvas.cxx. Update(). void TCanvas::Update ; (; ). overridevirtual . Update canvas pad buffers. ; Implements TVirtualPad.; Definition at line 2476 of file TCanvas.cxx. UpdateAsync(). void TCanvas::UpdateAsync ; (; ). overridevirtual . Asynchronous pad update. ; In case of web-based canvas triggers update of the canvas on the client side, but does not wait that real update is completed. Avoids blocking of caller thread. Have to be used if called from other web-based widget to avoid logical dead-locks. In case of normal canvas just canvas->Update() is performed. ; Implements TVirtualPad.; Definition at line 2532 of file TCanvas.cxx. UseCurrentStyle(). void TCanvas::UseCurrentStyle ; (; ). overridevirtual . Force a copy of current style for all objects in canvas. ; Reimplemented from TObject.; Definition at line 1183 of file TCanvas.cxx. UseGL(). Bool_t TCanvas::UseGL ; (; ); const. inline . Definition at line 228 of file TCanvas.h. Friends And Related Symbol Documentation. TCanvasImp. friend class TCanvasImp. friend . Definition at line 25 of file TCanvas.h. TInterpreter. friend class TInterpreter. friend . Definition at line 28 of file TCanvas.h. TThread. friend class TThread. friend . Definition at line 27 of file TCanvas.h. TWebCanvas. friend class TWebCanvas. friend . Definition at line 26 of file TCanvas.h. Member Data Documentation. fBatch. Bool_t TCanvas::fBatch. protected . ! True when in batchmode ; Definition at line 5",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTCanvas.html:93447,log,logical,93447,doc/v632/classTCanvas.html,https://root.cern,https://root.cern/doc/v632/classTCanvas.html,1,['log'],['logical']
Testability,"nvas.cxx. ToggleEditor(). void TCanvas::ToggleEditor ; (; ). virtual . Toggle editor. ; Definition at line 2453 of file TCanvas.cxx. ToggleEventStatus(). void TCanvas::ToggleEventStatus ; (; ). virtual . Toggle event statusbar. ; Definition at line 2431 of file TCanvas.cxx. ToggleToolBar(). void TCanvas::ToggleToolBar ; (; ). virtual . Toggle toolbar. ; Definition at line 2442 of file TCanvas.cxx. ToggleToolTips(). void TCanvas::ToggleToolTips ; (; ). virtual . Toggle tooltip display. ; Definition at line 2464 of file TCanvas.cxx. Update(). void TCanvas::Update ; (; ). overridevirtual . Update canvas pad buffers. ; Implements TVirtualPad.; Definition at line 2489 of file TCanvas.cxx. UpdateAsync(). void TCanvas::UpdateAsync ; (; ). overridevirtual . Asynchronous pad update. ; In case of web-based canvas triggers update of the canvas on the client side, but does not wait that real update is completed. Avoids blocking of caller thread. Have to be used if called from other web-based widget to avoid logical dead-locks. In case of normal canvas just canvas->Update() is performed. ; Implements TVirtualPad.; Definition at line 2545 of file TCanvas.cxx. UseCurrentStyle(). void TCanvas::UseCurrentStyle ; (; ). overridevirtual . Force a copy of current style for all objects in canvas. ; Reimplemented from TObject.; Definition at line 1185 of file TCanvas.cxx. UseGL(). Bool_t TCanvas::UseGL ; (; ); const. inline . Definition at line 228 of file TCanvas.h. Friends And Related Symbol Documentation. TCanvasImp. friend class TCanvasImp. friend . Definition at line 25 of file TCanvas.h. TInterpreter. friend class TInterpreter. friend . Definition at line 28 of file TCanvas.h. TThread. friend class TThread. friend . Definition at line 27 of file TCanvas.h. TWebCanvas. friend class TWebCanvas. friend . Definition at line 26 of file TCanvas.h. Member Data Documentation. fBatch. Bool_t TCanvas::fBatch. protected . ! True when in batchmode ; Definition at line 5",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTCanvas.html:93892,log,logical,93892,doc/master/classTCanvas.html,https://root.cern,https://root.cern/doc/master/classTCanvas.html,1,['log'],['logical']
Testability,nvergence for edm < 1 strategy 1; RooAbsMinimizerFcn: Minimized function has error status.; Returning maximum FCN so far (10415.9) to force MIGRAD to back out of this region. Error log follows.; Parameter values: Abkg=1 Asig=1 p_ph_sig2_gamma_bin_0=7.28945 p_ph_sig2_gamma_bin_1=1 p_ph_sig2_gamma_bin_10=1 p_ph_sig2_gamma_bin_11=1 p_ph_sig2_gamma_bin_12=1 p_ph_sig2_gamma_bin_13=1 p_ph_sig2_gamma_bin_14=1 p_ph_sig2_gamma_bin_15=1 p_ph_sig2_gamma_bin_16=1 p_ph_sig2_gamma_bin_17=1 p_ph_sig2_gamma_bin_18=1 p_ph_sig2_gamma_bin_19=1 p_ph_sig2_gamma_bin_2=1 p_ph_sig2_gamma_bin_20=1 p_ph_sig2_gamma_bin_21=1 p_ph_sig2_gamma_bin_22=1 p_ph_sig2_gamma_bin_23=1 p_ph_sig2_gamma_bin_24=1 p_ph_sig2_gamma_bin_3=1 p_ph_sig2_gamma_bin_4=1 p_ph_sig2_gamma_bin_5=1 p_ph_sig2_gamma_bin_6=1 p_ph_sig2_gamma_bin_7=1 p_ph_sig2_gamma_bin_8=1 p_ph_sig2_gamma_bin_9=1; ; RooAbsMinimizerFcn: Minimized function has error status.; Returning maximum FCN so far (10415.9) to force MIGRAD to back out of this region. Error log follows.; Parameter values: Abkg=1 Asig=1 p_ph_sig2_gamma_bin_0=1 p_ph_sig2_gamma_bin_1=7.28945 p_ph_sig2_gamma_bin_10=1 p_ph_sig2_gamma_bin_11=1 p_ph_sig2_gamma_bin_12=1 p_ph_sig2_gamma_bin_13=1 p_ph_sig2_gamma_bin_14=1 p_ph_sig2_gamma_bin_15=1 p_ph_sig2_gamma_bin_16=1 p_ph_sig2_gamma_bin_17=1 p_ph_sig2_gamma_bin_18=1 p_ph_sig2_gamma_bin_19=1 p_ph_sig2_gamma_bin_2=1 p_ph_sig2_gamma_bin_20=1 p_ph_sig2_gamma_bin_21=1 p_ph_sig2_gamma_bin_22=1 p_ph_sig2_gamma_bin_23=1 p_ph_sig2_gamma_bin_24=1 p_ph_sig2_gamma_bin_3=1 p_ph_sig2_gamma_bin_4=1 p_ph_sig2_gamma_bin_5=1 p_ph_sig2_gamma_bin_6=1 p_ph_sig2_gamma_bin_7=1 p_ph_sig2_gamma_bin_8=1 p_ph_sig2_gamma_bin_9=1; ; RooAbsMinimizerFcn: Minimized function has error status.; Returning maximum FCN so far (10415.9) to force MIGRAD to back out of this region. Error log follows.; Parameter values: Abkg=1 Asig=1 p_ph_sig2_gamma_bin_0=1 p_ph_sig2_gamma_bin_1=1 p_ph_sig2_gamma_bin_10=7.28945 p_ph_sig2_gamma_bin_11=1 p_ph_sig2_gamma_bin_12=1 p_ph_sig2_g,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf709__BarlowBeeston_8C.html:20991,log,log,20991,doc/master/rf709__BarlowBeeston_8C.html,https://root.cern,https://root.cern/doc/master/rf709__BarlowBeeston_8C.html,2,['log'],['log']
Testability,"nvironemnt variables. ; ; static TObject *GetOutput (const char *name, TList *out); Find object 'name' in list 'out' or in the files specified in there. ; ; static Int_tGetParameter (TCollection *c, const char *par, Double_t &value); Get the value from the specified parameter from the specified collection. ; ; static Int_tGetParameter (TCollection *c, const char *par, Int_t &value); Get the value from the specified parameter from the specified collection. ; ; static Int_tGetParameter (TCollection *c, const char *par, Long64_t &value); Get the value from the specified parameter from the specified collection. ; ; static Int_tGetParameter (TCollection *c, const char *par, Long_t &value); Get the value from the specified parameter from the specified collection. ; ; static Int_tGetParameter (TCollection *c, const char *par, TString &value); Get the value from the specified parameter from the specified collection. ; ; static voidLogViewer (const char *url=0, Int_t sessionidx=0); Start the log viewer window usign the plugin manager. ; ; static TProofMgr *Mgr (const char *url); Get instance of the effective manager for 'url' Return 0 on failure. ; ; static TProof *Open (const char *url=0, const char *conffile=0, const char *confdir=0, Int_t loglevel=0); Start a PROOF session on a specific cluster. ; ; static voidReset (const char *url, Bool_t hard=kFALSE); Wrapper around TProofMgr::Reset(...). ; ; static voidResetEnvVars (); Clear the list of environment variables passed to proofserv on the master and slaves. ; ; Static Public Member Functions inherited from TNamed; static TClass *Class (); ; static const char *Class_Name (); ; static constexpr Version_tClass_Version (); ; static const char *DeclFileName (); ; Static Public Member Functions inherited from TObject; static TClass *Class (); ; static const char *Class_Name (); ; static constexpr Version_tClass_Version (); ; static const char *DeclFileName (); ; static Longptr_",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProof.html:33916,log,log,33916,doc/master/classTProof.html,https://root.cern,https://root.cern/doc/master/classTProof.html,4,['log'],['log']
Testability,"ny elements are contained in the; array in the node.; Vsize - the 'virtual' size; if the node is pointed to by; element 0 of the parent node, then Vsize == Psize;; otherwise the element in the parent item that points to this; node 'belongs' to this node, and Vsize == Psize+1;. Parent nodes are always InnerNodes. These are the primitive operations on Nodes:; >; Append(elt) - adds an element to the end of the array of elements in a; node. It must never be called where appending the element; would fill the node.; Split() - divide a node in two, and create two new nodes.; SplitWith(sib) - create a third node between this node and the sib node,; divvying up the elements of their arrays.; PushLeft(n) - move n elements into the left sibling; PushRight(n) - move n elements into the right sibling; BalanceWithRight() - even up the number of elements in the two nodes.; BalanceWithLeft() - ditto. To allow this implementation of btrees to also be an implementation of; sorted arrays/lists, the overhead is included to allow O(log n) access; of elements by their rank (`give me the 5th largest element').; Therefore, each Item keeps track of the number of keys in and below it; in the tree (remember, each item's tree is all keys to the RIGHT of the; item's own key).; >; [ [ < 0 1 2 3 > 4 < 5 6 7 > 8 < 9 10 11 12 > ] 13 [ < 14 15 16 > 17 < 18 19 20 > ] ]; 4 1 1 1 1 4 1 1 1 5 1 1 1 1 7 3 1 1 1 4 1 1 1. Function Members (Methods); public:. TBtree(Int_t ordern = 3); virtual~TBtree(); voidTObject::AbstractMethod(const char* method) const; virtual voidAdd(TObject* obj); virtual voidAddAfter(const TObject*, TObject* obj); virtual voidTCollection::AddAll(const TCollection* col); virtual voidAddAt(TObject* obj, Int_t); virtual voidAddBefore(const TObject*, TObject* obj); virtual voidAddFirst(TObject* obj); virtual voidAddLast(TObject* obj); voidTCollection::AddVector(TObject* obj1); virtual TObject*After(const TObject* obj) const; virtual voidTObject::AppendPad(Option_t* option = """"); Bool_tTCo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/TBtree.html:7198,log,log,7198,root/html526/TBtree.html,https://root.cern,https://root.cern/root/html526/TBtree.html,5,['log'],['log']
Testability,"ny elements are contained in the; array in the node.; Vsize - the 'virtual' size; if the node is pointed to by; element 0 of the parent node, then Vsize == Psize;; otherwise the element in the parent item that points to this; node 'belongs' to this node, and Vsize == Psize+1;. Parent nodes are always InnerNodes. These are the primitive operations on Nodes:; >; Append(elt) - adds an element to the end of the array of elements in a; node. It must never be called where appending the element; would fill the node.; Split() - divide a node in two, and create two new nodes.; SplitWith(sib) - create a third node between this node and the sib node,; divvying up the elements of their arrays.; PushLeft(n) - move n elements into the left sibling; PushRight(n) - move n elements into the right sibling; BalanceWithRight() - even up the number of elements in the two nodes.; BalanceWithLeft() - ditto. To allow this implementation of btrees to also be an implementation of; sorted arrays/lists, the overhead is included to allow O(log n) access; of elements by their rank (`give me the 5th largest element').; Therefore, each Item keeps track of the number of keys in and below it; in the tree (remember, each item's tree is all keys to the RIGHT of the; item's own key).; >; [ [ < 0 1 2 3 > 4 < 5 6 7 > 8 < 9 10 11 12 > ] 13 [ < 14 15 16 > 17 < 18 19 20 > ] ]; 4 1 1 1 1 4 1 1 1 5 1 1 1 1 7 3 1 1 1 4 1 1 1. Function Members (Methods); public:. virtual~TBtree(); voidTObject::AbstractMethod(const char* method) const; virtual voidAdd(TObject* obj); virtual voidAddAfter(const TObject*, TObject* obj); virtual voidTCollection::AddAll(const TCollection* col); virtual voidAddAt(TObject* obj, Int_t); virtual voidAddBefore(const TObject*, TObject* obj); virtual voidAddFirst(TObject* obj); virtual voidAddLast(TObject* obj); voidTCollection::AddVector(TObject* obj1); virtual TObject*After(const TObject* obj) const; virtual voidTObject::AppendPad(Option_t* option = """"); Bool_tTCollection::AssertClass(TCla",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TBtree.html:7198,log,log,7198,root/html602/TBtree.html,https://root.cern,https://root.cern/root/html602/TBtree.html,2,['log'],['log']
Testability,"ny nested loops that force CLING to disable its optimization. If run interpreted one would not benchmark THnSparse but CLING.; Run as: root[0] .L $ROOTSYS/tutorials/hist/sparsehist.C+; root[1] sparsehist(); ; #include ""TH1.h""; #include ""TH2.h""; #include ""TH3.h""; #include ""THn.h""; #include ""THnSparse.h""; #include ""TStopwatch.h""; #include ""TRandom.h""; #include ""TCanvas.h""; #include ""TFile.h""; #include ""TStyle.h""; #include ""TSystem.h""; ; #ifndef INT_MAX; #define INT_MAX std::numeric_limits<int>::max(); #endif; ; class TTimeHists {; public:; enum EHist { kHist, kSparse, kNumHist };; enum ETime { kReal, kCPU, kNumTime };; TTimeHists(Int_t dim, Int_t bins, Long_t num):; fValue(nullptr), fDim(dim), fBins(bins), fNum(num),; fSparse(nullptr), fHist(nullptr), fHn(nullptr) {}; ~TTimeHists();; bool Run();; Double_t GetTime(EHist hist, ETime time) const {; if (time == kReal) return fTime[hist][0];; return fTime[hist][1]; }; static void SetDebug(Int_t lvl) { fgDebug = lvl; }; THnSparse* GetSparse() const { return fSparse; }; ; protected:; void Fill(EHist hist);; Double_t Check(EHist hist);; void SetupHist(EHist hist);; void NextValues();; void SetupValues();; ; private:; Double_t* fValue;; Int_t fDim;; Int_t fBins;; Long_t fNum;; Double_t fTime[2][2];; THnSparse* fSparse;; TH1* fHist;; THn* fHn;; static Int_t fgDebug;; };; ; Int_t TTimeHists::fgDebug = 0;; ; TTimeHists::~TTimeHists(); {; delete [] fValue;; delete fSparse;; delete fHist;; delete fHn;; }; ; bool TTimeHists::Run(); {; // run all tests with current settings, and check for identity of content.; ; Double_t check[2];; Long64_t rep[2];; for (int h = 0; h < 2; ++h) {; rep[h] = 0;; SetupValues();; try {; TStopwatch w;; w.Start();; SetupHist((EHist) h);; w.Stop();; do {; w.Start(kFALSE);; Fill((EHist) h);; check[h] = Check((EHist) h);; w.Stop();; ++rep[h];; } while ((!h && w.RealTime() < 0.1); || (h && rep[0] > 0 && rep[1] < rep[0]));; ; fTime[h][0] = (1.* fNum * rep[h]) / w.RealTime() / 1E6;; fTime[h][1] = (1.* fNum * rep[",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/sparsehist_8C.html:2749,test,tests,2749,doc/master/sparsehist_8C.html,https://root.cern,https://root.cern/doc/master/sparsehist_8C.html,1,['test'],['tests']
Testability,"ny other kind of requests like root.json or exe.json will be refused completely. Combined with connection tokens and https protocol, this makes usage of webgui components in public networks more secure.; Enabled WLCG Bearer Tokens support in RDavix; Bearer tokens are part of WLCG capability-based infrastructure with capability-based scheme which uses an infrastructure that describes what the bearer is allowed to do as opposed to who that bearer is. Token discovery procedure are developed according to the WLCG Bearer Token Discovery specification document. Short overview:. If the BEARER_TOKEN environment variable is set, then the value is taken to be the token contents.; If the BEARER_TOKEN_FILE environment variable is set, then its value is interpreted as a filename. The contents of the specified file are taken to be the token contents.; If the XDG_RUNTIME_DIR environment variable is set, then take the token from the contents of $XDG_RUNTIME_DIR/bt_u$ID(this additional location is intended to provide improved security for shared login environments as $XDG_RUNTIME_DIR is defined to be user-specific as opposed to a system-wide directory.).; Otherwise, take the token from /tmp/bt_u$ID. Xrootd client support; ROOT can now be built with Xrootd 5 client libraries.; GUI Libraries; RBrowser improvements. central factory methods to handle browsing, editing and drawing of different classes; simple possibility to extend RBrowser on user-defined classes; support of web-based geometry viewer; better support of TTree drawing; server-side handling of code editor and image viewer widgets; rbrowser content is fully recovered when web-browser is reloaded; load of widgets code only when really required (shorter startup time for RBrowser). JavaScript ROOT; Major JSROOT update to version 6. update all used libraries d3.js, three.js, MathJax.js, openui5; change to Promise based interface for all async methods, remove call-back arguments; change scripts names, core scripts name now JSRoot.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v624/release-notes.html:27867,log,login,27867,doc/v624/release-notes.html,https://root.cern,https://root.cern/doc/v624/release-notes.html,1,['log'],['login']
Testability,"nymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. Double_tTGeoBBox::fDXX half-length; Double_tTGeoBBox::fDYY half-length; Double_tTGeoBBox::fDZZ half-length; TStringTNamed::fNameobject identifier; Double_tTGeoBBox::fOrigin[3]box origin; UInt_tTGeoShape::fShapeBitsshape bits; Int_tTGeoShape::fShapeIdshape id; TStringTNamed::fTitleobject title. private:. Double_tfN[3]; Double_tfP[3]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoHalfSpace(); Dummy constructor. TGeoHalfSpace(const char* name, Double_t* p, Double_t* n); Constructor with name, point on the plane and normal. TGeoHalfSpace(Double_t* params); Default constructor specifying minimum and maximum radius. ~TGeoHalfSpace(); destructor. void ComputeNormal(const Double_t* point, const Double_t* dir, Double_t* norm); Compute normal to closest surface from POINT. Bool_t Contains(const Double_t* point) const; test if point is inside the half-space. Int_t DistancetoPrimitive(Int_t px, Int_t py); A half-space does not have a mesh primitive. Double_t DistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from inside point to the plane. Double_t DistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from inside point to the plane. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); Divide the shape along one axis. void GetMeshNumbers(Int_t& nvert, Int_t& nsegs, Int_t& npols) const; Returns numbers of vertices, segments and polygons composing the shape mesh. void InspectShape() const; print shape parameters. Double_t Safety(const Double_t* point, Bool_t in = kTRUE) const; computes the closest distance from given point to this shape, ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGeoHalfSpace.html:14490,test,test,14490,root/html602/TGeoHalfSpace.html,https://root.cern,https://root.cern/root/html602/TGeoHalfSpace.html,2,['test'],['test']
Testability,"nzip.h. FillBuffer(). bool TTreeCacheUnzip::FillBuffer ; (; ). overridevirtual . Fill the cache buffer with the branches in the cache. ; Reimplemented from TTreeCache.; Definition at line 267 of file TTreeCacheUnzip.cxx. GetNFound(). Int_t TTreeCacheUnzip::GetNFound ; (; ). inline . Definition at line 154 of file TTreeCacheUnzip.h. GetNMissed(). Int_t TTreeCacheUnzip::GetNMissed ; (; ). inline . Definition at line 153 of file TTreeCacheUnzip.h. GetNUnzip(). Int_t TTreeCacheUnzip::GetNUnzip ; (; ). inline . Definition at line 152 of file TTreeCacheUnzip.h. GetParallelUnzip(). TTreeCacheUnzip::EParUnzipMode TTreeCacheUnzip::GetParallelUnzip ; (; ). static . Static function that returns the parallel option (to indicate an additional thread) ; Definition at line 407 of file TTreeCacheUnzip.cxx. GetRecordHeader(). Int_t TTreeCacheUnzip::GetRecordHeader ; (; char *; buf, . Int_t; maxbytes, . Int_t &; nbytes, . Int_t &; objlen, . Int_t &; keylen. ). Read the logical record header from the buffer buf. ; That must be the pointer tho the header part not the object by itself and must contain data of at least maxbytes Returns nread;; In output arguments:. nbytes : number of bytes in record if negative, this is a deleted record if 0, cannot read record, wrong value of argument first; objlen : uncompressed object size; keylen : length of logical record header. Note that the arguments objlen and keylen are returned only if maxbytes >=16 Note: This was adapted from TFile... so some things dont apply ; Definition at line 469 of file TTreeCacheUnzip.cxx. GetUnzipBuffer(). Int_t TTreeCacheUnzip::GetUnzipBuffer ; (; char **; buf, . Long64_t; pos, . Int_t; len, . bool *; free. ). overridevirtual . We try to read a buffer that has already been unzipped Returns -1 in case of read failure, 0 in case it's not in the cache and n>0 in case read from cache (number of bytes copied). ; pos and len are the original values as were passed to ReadBuffer but instead we will r",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTTreeCacheUnzip.html:29940,log,logical,29940,doc/v632/classTTreeCacheUnzip.html,https://root.cern,https://root.cern/doc/v632/classTTreeCacheUnzip.html,1,['log'],['logical']
Testability,"nzip.h. FillBuffer(). bool TTreeCacheUnzip::FillBuffer ; (; ). overridevirtual . Fill the cache buffer with the branches in the cache. ; Reimplemented from TTreeCache.; Definition at line 267 of file TTreeCacheUnzip.cxx. GetNFound(). Int_t TTreeCacheUnzip::GetNFound ; (; ). inline . Definition at line 154 of file TTreeCacheUnzip.h. GetNMissed(). Int_t TTreeCacheUnzip::GetNMissed ; (; ). inline . Definition at line 153 of file TTreeCacheUnzip.h. GetNUnzip(). Int_t TTreeCacheUnzip::GetNUnzip ; (; ). inline . Definition at line 152 of file TTreeCacheUnzip.h. GetParallelUnzip(). TTreeCacheUnzip::EParUnzipMode TTreeCacheUnzip::GetParallelUnzip ; (; ). static . Static function that returns the parallel option (to indicate an additional thread) ; Definition at line 408 of file TTreeCacheUnzip.cxx. GetRecordHeader(). Int_t TTreeCacheUnzip::GetRecordHeader ; (; char *; buf, . Int_t; maxbytes, . Int_t &; nbytes, . Int_t &; objlen, . Int_t &; keylen. ). Read the logical record header from the buffer buf. ; That must be the pointer tho the header part not the object by itself and must contain data of at least maxbytes Returns nread;; In output arguments:. nbytes : number of bytes in record if negative, this is a deleted record if 0, cannot read record, wrong value of argument first; objlen : uncompressed object size; keylen : length of logical record header. Note that the arguments objlen and keylen are returned only if maxbytes >=16 Note: This was adapted from TFile... so some things dont apply ; Definition at line 470 of file TTreeCacheUnzip.cxx. GetUnzipBuffer(). Int_t TTreeCacheUnzip::GetUnzipBuffer ; (; char **; buf, . Long64_t; pos, . Int_t; len, . bool *; free. ). overridevirtual . We try to read a buffer that has already been unzipped Returns -1 in case of read failure, 0 in case it's not in the cache and n>0 in case read from cache (number of bytes copied). ; pos and len are the original values as were passed to ReadBuffer but instead we will r",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTTreeCacheUnzip.html:29944,log,logical,29944,doc/master/classTTreeCacheUnzip.html,https://root.cern,https://root.cern/doc/master/classTTreeCacheUnzip.html,1,['log'],['logical']
Testability,"o be initialized by other TLorentzRotation, by a pure TRotation or by a boost:; TLorentzRotation l; // l is initialized as identity; TLorentzRotation m(l);// m = l; TRotation r;; TLorentzRotation lr(r);; TLorentzRotation lb1(bx,by,bz);; TVector3 b;; TLorentzRotation lb2(b);; The Matrix for a Lorentz boosts is:; \[; \left|; \begin{array}{cccc}; 1+gamma'*bx*bx & gamma'*bx*by & gamma'*bx*bz & gamma*bx \\; gamma'*bx*bz & 1+gamma'*by*by & gamma'*by*by & gamma*by \\; gamma'*bz*bx & gamma'*bz*by & 1+gamma'*bz*bz & gamma*bz \\; gamma*bx & gamma*by & gamma*bz & gamma; \end{array}; \right|; \]; with the boost vector b=(bx,by,bz); gamma=1/Sqrt(1-beta*beta);gamma'=(gamma-1)/beta*beta.; 17.5.2 Access to the Matrix Components/Comparisons; The access to the matrix components is possible with the methods XX(), XY()  TT(), and with the operator(int,int):; Double_t xx;; TLorentzRotation l;; xx = l.XX(); // gets the xx component; xx = l(0,0); // gets the xx component; if (l == m) {...} // test for equality; if (l != m) {...} // test for inequality; if (l.IsIdentity()) {...} // test for identity; 17.5.3 Transformations of a Lorentz Rotation; There are four possibilities to find the product of two TLorentzRotation transformations:; TLorentzRotation a,b,c;; c = b*a; // product; c = a.MatrixMultiplication(b); // a is unchanged; a *= b; // a=a*b; c = a.Transform(b) // a=b*a then c=a; Lorentz boosts:; Double_t bx, by, bz;; TVector3 v(bx,by,bz);; TLorentzRotation l;; l.Boost(v);; l.Boost(bx,by,bz);; Rotations:; TVector3 axis;; l.RotateX(TMath::Pi()); // rotation around x-axis; l.Rotate(.5,axis); // rotation around specified vector; Inverse transformation: use the method Inverse()to return the inverse transformation keeping the current one unchanged. The method Invert() inverts the current TLorentzRotation:; l1 = l2.Inverse(); // l1 is inverse of l2, l2 unchanged; l1 = l2.Invert(); // invert l2, then l1=l2; The matrix for the inverse transformation of a TLorentzRotation is as follows:; \[; \",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:872644,test,test,872644,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['test'],['test']
Testability,"o be used when copying the variable to the output buffer. The line below describes ntrack to be written as a 16-bit integer (rather than a 32-bit integer).; ""ntrack/I2""; With this Branch method, you can also add a leaf that holds an entire array of variables. To add an array of floats use the f[n] notation when describing the leaf.; Float_t f[10];; tree->Branch(""fBranch"",f,""f[10]/F"");; You can also add an array of variable length:; {; TFile *f = new TFile(""peter.root"",""recreate"");; Int_t nPhot;; Float_t E[500];; TTree* nEmcPhotons = new TTree(""nEmcPhotons"",""EMC Photons"");; nEmcPhotons->Branch(""nPhot"",&nPhot,""nPhot/I"");; nEmcPhotons->Branch(""E"",E,""E[nPhot]/F"");; }; See Example 2: A Tree with a C Structure below ($ROOTSYS/tutorials/tree/tree2.C) and staff.C at the beginning of this chapter.; 12.10 Adding a TBranch to Hold an Object; To write a branch to hold an event object, we need to load the definition of the Event class, which is in $ROOTSYS/test/libEvent.so (if it doesnt exist type make in $ROOTSYS/test). An object can be saved in a tree if a ROOT dictionary for its class has been generated and loaded.; root[] .L libEvent.so; First, we need to open a file and create a tree.; root[] TFile *f = new TFile(""AFile.root"",""RECREATE""); root[] TTree *tree = new TTree(""T"",""A Root Tree""); We need to create a pointer to an Event object that will be used as a reference in the TTree::Branch method. Then we create a branch with the TTree::Branch method.; root[] Event *event = new Event(); root[] tree->Branch(""EventBranch"",""Event"",&event,32000,99); To add a branch to hold an object we use the signature above. The first parameter is the name of the branch. The second parameter is the name of the class of the object to be stored. The third parameter is the address of a pointer to the object to be stored.; Note that it is an address of a pointer to the object, not just a pointer to the object.; The fourth parameter is the buffer size and is by default 32000 bytes. It is the numb",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:541359,test,test,541359,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['test'],['test']
Testability,"o compRes = fInterpreter->declare(fwdDecl.c_str(), &T);; 2062 assert(cling::Interpreter::kSuccess == compRes &&; 2063 ""A fwd declaration could not be compiled"");; 2064 if (compRes!=cling::Interpreter::kSuccess){; 2065 Warning(""TCling::RegisterModule"",; 2066 ""Problems in declaring string '%s' were encountered."",; 2067 fwdDecl.c_str()) ;; 2068 continue;; 2069 }; 2070 ; 2071 // Drill through namespaces recursively until the template is found; 2072 if(ClassTemplateDecl* TD = FindTemplateInNamespace(T->getFirstDecl().getSingleDecl())){; 2073 fNormalizedCtxt->AddTemplAndNargsToKeep(TD->getCanonicalDecl(), nArgsToSkip);; 2074 }; 2075 ; 2076 }; 2077 ; 2078 // FIXME: Remove #define __ROOTCLING__ once PCMs are there.; 2079 // This is used to give Sema the same view on ACLiC'ed files (which; 2080 // are then #included through the dictionary) as rootcling had.; 2081 TString code = gNonInterpreterClassDef;; 2082 if (payloadCode); 2083 code += payloadCode;; 2084 ; 2085 std::string dyLibName = cling::DynamicLibraryManager::getSymbolLocation(triggerFunc);; 2086 assert(!llvm::sys::fs::is_symlink_file(dyLibName));; 2087 ; 2088 if (dyLibName.empty()) {; 2089 ::Error(""TCling::RegisterModule"", ""Dictionary trigger function for %s not found"", modulename);; 2090 return;; 2091 }; 2092 ; 2093 // The triggerFunc may not be in a shared object but in an executable.; 2094 bool isSharedLib = cling::DynamicLibraryManager::isSharedLibrary(dyLibName);; 2095 ; 2096 bool wasDlopened = false;; 2097 ; 2098 // If this call happens after dlopen has finished (i.e. late registration); 2099 // there is no need to dlopen the library recursively. See ROOT-8437 where; 2100 // the dyLibName would correspond to the binary.; 2101 if (!lateRegistration) {; 2102 ; 2103 if (isSharedLib) {; 2104 // We need to open the dictionary shared library, to resolve symbols; 2105 // requested by the JIT from it: as the library is currently being dlopen'ed,; 2106 // its symbols are not yet reachable from the process.; 2107 // Recu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCling_8cxx_source.html:79786,assert,assert,79786,doc/master/TCling_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html,1,['assert'],['assert']
Testability,"o demonstrate message stream; igauss = gauss.createIntegral({x}); igauss.Print(); ; # Print streams configuration in verbose, also shows inactive streams; ROOT.RooMsgService.instance().Print(); ; # Remove stream; ROOT.RooMsgService.instance().getStream(1).removeTopic(ROOT.RooFit.Integration); ; # Examples of pdf value tracing; # -----------------------------------------------------------------------; ; # Show DEBUG level message on function tracing, ROOT.RooGaussian only; ROOT.RooMsgService.instance().addStream(ROOT.RooFit.DEBUG, Topic=ROOT.RooFit.Tracing, ClassName=""RooGaussian""); ; # Perform a fit to generate some tracing messages; model.fitTo(data, Verbose=True); ; # Reset message service to default stream configuration; ROOT.RooMsgService.instance().reset(); ; # Show DEBUG level message on function tracing on all objects, output to; # file; ROOT.RooMsgService.instance().addStream(ROOT.RooFit.DEBUG, Topic=ROOT.RooFit.Tracing, OutputFile=""rf506_debug.log""); ; # Perform a fit to generate some tracing messages; model.fitTo(data, Verbose=True); ; # Reset message service to default stream configuration; ROOT.RooMsgService.instance().reset(); ; # Example of another debugging stream; # ---------------------------------------------------------------------; ; # Show DEBUG level messages on client/server link state management; ROOT.RooMsgService.instance().addStream(ROOT.RooFit.DEBUG, Topic=ROOT.RooFit.LinkStateMgmt); ROOT.RooMsgService.instance().Print(""v""); ; # Clone composite pdf g to trigger some link state management activity; gprime = gauss.cloneTree(); gprime.Print(); ; # Reset message service to default stream configuration; ROOT.RooMsgService.instance().reset(); Printvoid Print(GNN_Data &d, std::string txt="""")Definition TMVA_SOFIE_GNN_Application.C:59; [#0] WARNING:InputArguments -- The parameter 's' with range [-10, 10] of the RooGaussian 'g' exceeds the safe range of (0, inf). Advise to limit its range.; Active Message streams; [0] MinLevel = PROGRESS Topic = Ge",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf506__msgservice_8py.html:2375,log,log,2375,doc/master/rf506__msgservice_8py.html,https://root.cern,https://root.cern/doc/master/rf506__msgservice_8py.html,1,['log'],['log']
Testability,"o end of distribution.; w = 2; whisker is drawn to max 1.5*iqr; a = 0; no anchor drawn; a = 1; the anchors are drawn; p = 0; no points drawn; p = 1; only outliers are drawn; p = 2; all datapoints are drawn; p = 3: all datapoints are drawn scattered; h = 0; no histogram is drawn; h = 1; histogram at the left or bottom side is drawn; h = 2; histogram at the right or top side is drawn; h = 3; histogram at left and right or top and bottom (violin-style) is drawn; z = 0; no zero indicator line is drawn; z = 1; zero indicator line is drawn. As one can see all individual options for both candle and violin plots can be accessed by this mechanism. In deed the keywords CANDLE(<option-string>) and VIOLIN(<option-string>) have the same meaning. So you can parametrise an option-string for a candle plot and use the keywords VIOLIN and vice versa, if you wish.; Using a logarithmic x- or y-axis is possible for candle and violin charts.; SinceROOT version 6.11/01; a logarithmic z-axis is possible, too but will only affect violin charts of course.; The CANDLE option; A Candle plot (also known as a ""box plot"" or ""whisker plot"") was invented in 1977 by John Tukey. It is a convenient way to describe graphically a data distribution (D) with only five numbers:. The minimum value of the distribution D (bottom or left whisker).; The lower quartile (Q1): 25% of the data points in D are less than Q1 (bottom of the box).; The median (M): 50% of the data points in D are less than M.; The upper quartile (Q3): 75% of the data points in D are less than Q3 (top of the box).; The maximum value of the distribution D (top or right whisker). In this implementation a TH2 is considered as a collection of TH1 along X (option CANDLE or CANDLEX) or Y (option CANDLEY). Each TH1 is represented as one candle.; ; void candleplotwhiskers() {; auto c1 = new TCanvas(""c1"",""Candle Presets"",700,800);; c1->Divide(1,2);; ; auto rng = new TRandom();; auto h1 = new TH2I(""h1"",""Gaus"",100,-5,5,1,0,1);; auto h2 = new TH1I(""h",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTHistPainter.html:51631,log,logarithmic,51631,doc/master/classTHistPainter.html,https://root.cern,https://root.cern/doc/master/classTHistPainter.html,1,['log'],['logarithmic']
Testability,"o fetch the object from the TDirectory. TKey * NextEventKey(UInt_t eventNumber = UInt_t(-1), UInt_t runNumber = UInt_t(-1), const char* name = ""*""). TObject * NextEventGet(UInt_t eventNumber = UInt_t(-1), UInt_t runNumber = UInt_t(-1), const char* name = ""*""); reads, creates and returns the object by TKey name that matches; the ""name"" .""runNumber"" ."" eventNumber"" schema; Attention: This method does create a new TObject and it is the user; code responsibility to take care (delete) this object to avoid; memory leak. TObject * ReadObj(const TKey* key) const; Read the next TObject from for the TDirectory by TKey provided. Int_t NextEventPut(TObject* obj, UInt_t eventNum, UInt_t runNumber, const char* name = 0); Create a special TKey name with obj provided and write it out. TString MapName(const char* name, const char* localSystemKey = 0, const char* mountedFileSystemKey = 0). MapName(const char *name, const char *localSystemKey,const char *mountedFileSystemKey). Substitute the logical name with the real one if any; 1. add a line into system.rootrc or ~/.rootrc or ./.rootrc. TFileIter.ForeignFileMap mapFile // the name of the file; to map the local name; to the global file service. If this line is omitted then TFileIter class seeks for; the default mapping file in the current directory ""io.config"". const char * GetResourceName(). {return ""ForeignFileMap"";}. const char * GetDefaultMapFileName(). {return ""io.config"";}. const char * GetLocalFileNameKey(). {return ""LocalFileSystem"";}. const char * GetForeignFileSystemKey(). {return ""MountedFileSystem"";}. Int_t CurrentCursorPosition() const. const TFile * GetTFile() const. { return GetTDirectory()->GetFile(); }. const TDirectory * GetTDirectory() const. { return fNestedIterator ? fNestedIterator->GetTDirectory() : fRootFile; }. TObject * Next(). void Rewind(). void SetCursorPosition(Int_t cursorPosition). TFileIter & operator=(const char* keyNameToFind). TFileIter & operator=(Int_t cursorPosition). TFileIter & operator+=(Int_t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TFileIter.html:10230,log,logical,10230,root/html528/TFileIter.html,https://root.cern,https://root.cern/root/html528/TFileIter.html,4,['log'],['logical']
Testability,"o fetch the object from the TDirectory. TKey * NextEventKey(UInt_t eventNumber = UInt_t(-1), UInt_t runNumber = UInt_t(-1), const char* name = ""*""). TObject * NextEventGet(UInt_t eventNumber = UInt_t(-1), UInt_t runNumber = UInt_t(-1), const char* name = ""*""); reads, creates and returns the object by TKey name that matches; the ""name"" .""runNumber"" ."" eventNumber"" schema; Attention: This method does create a new TObject and it is the user; code responsibility to take care (delete) this object to avoid; memory leak. TObject * ReadObj(const TKey* key) const; Read the next TObject from for the TDirectory by TKey provided. Int_t NextEventPut(TObject* obj, UInt_t eventNum, UInt_t runNumber, const char* name = 0); Create a special TKey name with obj provided and write it out. TString MapName(const char* name, const char* localSystemKey = 0, const char* mountedFileSystemKey = 0). MapName(const char *name, const char *localSystemKey,const char *mountedFileSystemKey). Substitute the logical name with the real one if any; 1. add a line into system.rootrc or ~/.rootrc or ./.rootrc. TFileIter.ForeignFileMap mapFile // the name of the file; to map the local name; to the global file service. If this line is omitted then TFileIter class seeks for; the default mapping file in the current directory ""io.config"". const char * GetResourceName(). {return ""ForeignFileMap"";}. const char * GetDefaultMapFileName(). {return ""io.config"";}. const char * GetLocalFileNameKey(). {return ""LocalFileSystem"";}. const char * GetForeignFileSystemKey(). {return ""MountedFileSystem"";}. Int_t CurrentCursorPosition() const. const TFile * GetTFile() const. { return GetTDirectory()->GetFile(); }. const TDirectory * GetTDirectory() const. { return fNestedIterator ? fNestedIterator->GetTDirectory() : fRootFile; }. TObject * Next(). void Rewind(). void SetCursorPosition(Int_t cursorPosition). TFileIter & operator=(const char* keyNameToFind). TFileIter & operator=(Int_t cursorPosition). inline operator const TDirec",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TFileIter.html:10140,log,logical,10140,root/html602/TFileIter.html,https://root.cern,https://root.cern/root/html602/TFileIter.html,2,['log'],['logical']
Testability,"o generates two views of the NA49 detector. ; ; na49visible.py; Set visibility attributes for the NA49 geometry Set Shape attributes. ; ; ntuple1.py;  Ntuple drawing example. ; ; numberEntry.py; Example frame with one box where the user can increase or decrease a number and the shown value will be updated accordingly. ; ; parse_CSV_file_with_TTree_ReadStream.py; This function provides an example of how one might massage a csv data file to read into a ROOT TTree via TTree::ReadStream. ; ; pyroot001_arrayInterface.py;  This tutorial illustrates the conversion of STL vectors and TVec to numpy arrays without copying the data. ; ; pyroot002_pythonizationDecorator.py;  This tutorial shows how to use the @pythonization decorator to add extra behaviour to C++ user classes that are used from Python via PyROOT. ; ; pyroot003_prettyPrinting.py;  This tutorial illustrates the pretty printing feature of PyROOT, which reveals the content of the object if a string representation is requested, e.g., by Python's print statement. ; ; pyroot004_NumbaDeclare.py;  This tutorial illustrates how PyROOT supports declaring C++ callables from Python callables making them, for example, usable with RDataFrame. ; ; pyroot005_tfile_context_manager.py;  This tutorial demonstrates the usage of the TFile class as a Python context manager. ; ; pyroot006_tcontext_context_manager.py;  This tutorial demonstrates the usage of the TContext class as a Python context manager. ; ; ratioplot.py;  Display two histograms and their ratio. ; ; shapes.py;  Draw the geometry using the x3d viewver. ; ; staff.py;  example of macro to read data from an ascii file and create a root file with a Tree. ; ; surfaces.py;  Surfaces example ; ; tornado.py; Tornado example. ; ; zdemo.py;  This macro is an example of graphs in log scales with annotations. ; . tutorialspyroot. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:45:50 (GVA Time) using Doxygen 1.9.8 ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/dir_d39463c0be040a84eab8424485bc26d4.html:2917,log,log,2917,doc/master/dir_d39463c0be040a84eab8424485bc26d4.html,https://root.cern,https://root.cern/doc/master/dir_d39463c0be040a84eab8424485bc26d4.html,1,['log'],['log']
Testability,"o itInputBegin = begin (input);; 1043 auto itInputEnd = end (input);; 1044 layerData.push_back (LayerData (itInputBegin, itInputEnd));; 1045 size_t numNodesPrev = input.size ();; 1046 ; 1047 // -------------------- prepare layer data with one pattern -------------------------------; 1048 for (auto& layer: m_layers); 1049 {; 1050 layerData.push_back (LayerData (layer.numNodes (), itWeight,; 1051 layer.activationFunction (),; 1052 layer.modeOutputValues ()));; 1053 size_t _numWeights = layer.numWeights (numNodesPrev);; 1054 itWeight += _numWeights;; 1055 numNodesPrev = layer.numNodes ();; 1056 }; 1057 ; 1058 ; 1059 // --------- forward -------------; 1060 forwardPattern (m_layers, layerData);; 1061 ; 1062 // ------------- fetch output ------------------; 1063 std::vector<double> output;; 1064 fetchOutput (layerData.back (), output);; 1065 return output;; 1066 }; 1067 ; 1068 ; 1069 template <typename Weights, typename PassThrough>; 1070 double Net::operator() (PassThrough& settingsAndBatch, const Weights& weights) const; 1071 {; 1072 std::vector<double> nothing; // empty gradients; no backpropagation is done, just forward; 1073 assert (numWeights () == weights.size ());; 1074 double error = forward_backward(m_layers, settingsAndBatch, std::begin (weights), std::end (weights), std::begin (nothing), std::end (nothing), 10000, nothing, false);; 1075 return error;; 1076 }; 1077 ; 1078 template <typename Weights, typename PassThrough, typename OutContainer>; 1079 double Net::operator() (PassThrough& settingsAndBatch, const Weights& weights, ModeOutput /*eFetch*/, OutContainer& outputContainer) const; 1080 {; 1081 std::vector<double> nothing; // empty gradients; no backpropagation is done, just forward; 1082 assert (numWeights () == weights.size ());; 1083 double error = forward_backward(m_layers, settingsAndBatch, std::begin (weights), std::end (weights), std::begin (nothing), std::end (nothing), 10000, outputContainer, true);; 1084 return error;; 1085 }; 1086 ; 1087 ; 1088 ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/NeuralNet_8icc_source.html:33688,assert,assert,33688,doc/master/NeuralNet_8icc_source.html,https://root.cern,https://root.cern/doc/master/NeuralNet_8icc_source.html,1,['assert'],['assert']
Testability,"o not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooSimultaneous(const char* name, const char* title, RooAbsCategoryLValue& indexCat); Constructor with index category. PDFs associated with indexCat; states can be added after construction with the addPdf() function. RooSimultaneous can function without having a PDF associated; with every single state. The normalization in such cases is taken; from the number of registered PDFs, but getVal() will assert if; when called for an unregistered index state. RooSimultaneous(const char* name, const char* title, const RooArgList& pdfList, RooAbsCategoryLValue& indexCat); Constructor from index category and full list of PDFs.; In this constructor form, a PDF must be supplied for each indexCat state; to avoid ambiguities. The PDFS are associated in order with the state of the; index category as listed by the index categories type iterator. PDFs may not overlap (i.e. share any variables) with the index category (function). RooSimultaneous(const char* name, const char* title, map<string,RooAbsPdf*> pdfMap, RooAbsCategoryLValue& inIndexCat). void initialize(RooAbsCategoryLValue& inIndexCat, map<string,RooAbsPdf*> pdfMap); First see if there are any RooSimultaneous input components. RooSimultaneous(const RooSimultaneous& other, const char* name = 0); Copy constructor. ~RooSimultaneous(); Destructor. RooAbsPdf* getPdf(const char* catName) const; Return the p.d.f associated",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooSimultaneous.html:46487,assert,assert,46487,root/html602/RooSimultaneous.html,https://root.cern,https://root.cern/root/html602/RooSimultaneous.html,2,['assert'],['assert']
Testability,"o not send anything back to client, until we buffer in all; 11446 * HTTP headers. */; 11447 data_len = 0;; 11448 buf = (char *)mg_malloc_ctx(buflen, conn->phys_ctx);; 11449 if (buf == NULL) {; 11450 mg_send_http_error(conn,; 11451 500,; 11452 ""Error: Not enough memory for CGI buffer (%u bytes)"",; 11453 (unsigned int)buflen);; 11454 mg_cry_internal(; 11455 conn,; 11456 ""Error: CGI program \""%s\"": Not enough memory for buffer (%u ""; 11457 ""bytes)"",; 11458 prog,; 11459 (unsigned int)buflen);; 11460 goto done;; 11461 }; 11462 ; 11463 DEBUG_TRACE(""CGI: %s"", ""wait for response"");; 11464 headers_len = read_message(out, conn, buf, (int)buflen, &data_len);; 11465 DEBUG_TRACE(""CGI: response: %li"", (signed long)headers_len);; 11466 ; 11467 if (headers_len <= 0) {; 11468 ; 11469 /* Could not parse the CGI response. Check if some error message on; 11470 * stderr. */; 11471 i = pull_all(err, conn, buf, (int)buflen);; 11472 if (i > 0) {; 11473 /* CGI program explicitly sent an error */; 11474 /* Write the error message to the internal log */; 11475 mg_cry_internal(conn,; 11476 ""Error: CGI program \""%s\"" sent error ""; 11477 ""message: [%.*s]"",; 11478 prog,; 11479 i,; 11480 buf);; 11481 /* Don't send the error message back to the client */; 11482 mg_send_http_error(conn,; 11483 500,; 11484 ""Error: CGI program \""%s\"" failed."",; 11485 prog);; 11486 } else {; 11487 /* CGI program did not explicitly send an error, but a broken; 11488 * respon header */; 11489 mg_cry_internal(conn,; 11490 ""Error: CGI program sent malformed or too big ""; 11491 ""(>%u bytes) HTTP headers: [%.*s]"",; 11492 (unsigned)buflen,; 11493 data_len,; 11494 buf);; 11495 ; 11496 mg_send_http_error(conn,; 11497 500,; 11498 ""Error: CGI program sent malformed or too big ""; 11499 ""(>%u bytes) HTTP headers: [%.*s]"",; 11500 (unsigned)buflen,; 11501 data_len,; 11502 buf);; 11503 }; 11504 ; 11505 /* in both cases, abort processing CGI */; 11506 goto done;; 11507 }; 11508 ; 11509 pbuf = buf;; 11510 buf[headers_len - 1] = '\0';; 11",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:332163,log,log,332163,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,1,['log'],['log']
Testability,"o not send anything back to client, until we buffer in all; 11447 * HTTP headers. */; 11448 data_len = 0;; 11449 buf = (char *)mg_malloc_ctx(buflen, conn->phys_ctx);; 11450 if (buf == NULL) {; 11451 mg_send_http_error(conn,; 11452 500,; 11453 ""Error: Not enough memory for CGI buffer (%u bytes)"",; 11454 (unsigned int)buflen);; 11455 mg_cry_internal(; 11456 conn,; 11457 ""Error: CGI program \""%s\"": Not enough memory for buffer (%u ""; 11458 ""bytes)"",; 11459 prog,; 11460 (unsigned int)buflen);; 11461 goto done;; 11462 }; 11463 ; 11464 DEBUG_TRACE(""CGI: %s"", ""wait for response"");; 11465 headers_len = read_message(out, conn, buf, (int)buflen, &data_len);; 11466 DEBUG_TRACE(""CGI: response: %li"", (signed long)headers_len);; 11467 ; 11468 if (headers_len <= 0) {; 11469 ; 11470 /* Could not parse the CGI response. Check if some error message on; 11471 * stderr. */; 11472 i = pull_all(err, conn, buf, (int)buflen);; 11473 if (i > 0) {; 11474 /* CGI program explicitly sent an error */; 11475 /* Write the error message to the internal log */; 11476 mg_cry_internal(conn,; 11477 ""Error: CGI program \""%s\"" sent error ""; 11478 ""message: [%.*s]"",; 11479 prog,; 11480 i,; 11481 buf);; 11482 /* Don't send the error message back to the client */; 11483 mg_send_http_error(conn,; 11484 500,; 11485 ""Error: CGI program \""%s\"" failed."",; 11486 prog);; 11487 } else {; 11488 /* CGI program did not explicitly send an error, but a broken; 11489 * respon header */; 11490 mg_cry_internal(conn,; 11491 ""Error: CGI program sent malformed or too big ""; 11492 ""(>%u bytes) HTTP headers: [%.*s]"",; 11493 (unsigned)buflen,; 11494 data_len,; 11495 buf);; 11496 ; 11497 mg_send_http_error(conn,; 11498 500,; 11499 ""Error: CGI program sent malformed or too big ""; 11500 ""(>%u bytes) HTTP headers: [%.*s]"",; 11501 (unsigned)buflen,; 11502 data_len,; 11503 buf);; 11504 }; 11505 ; 11506 /* in both cases, abort processing CGI */; 11507 goto done;; 11508 }; 11509 ; 11510 pbuf = buf;; 11511 buf[headers_len - 1] = '\0';; 11",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:332196,log,log,332196,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,1,['log'],['log']
Testability,"o outputMatrix = batch.GetOutput();; 1239 auto weightMatrix = batch.GetWeights();; 1240 trainingError += net.Loss(inputMatrix, outputMatrix, weightMatrix);; 1241 }; 1242 trainingError /= (Double_t) (nTrainingSamples / settings.batchSize);; 1243 ; 1244 //Log the loss value; 1245 fTrainHistory.AddValue(""trainingError"",stepCount,trainingError);; 1246 ; 1247 if (fInteractive){; 1248 fInteractive->AddPoint(stepCount, trainingError, testError);; 1249 fIPyCurrentIter = 100*(double)minimizer.GetConvergenceCount() /(double)settings.convergenceSteps;; 1250 if (fExitFromTraining) break;; 1251 }; 1252 ; 1253 // Compute numerical throughput.; 1254 std::chrono::duration<double> elapsed_seconds = end - start;; 1255 double seconds = elapsed_seconds.count();; 1256 double nFlops = (double) (settings.testInterval * batchesInEpoch);; 1257 nFlops *= net.GetNFlops() * 1e-9;; 1258 ; 1259 converged = minimizer.HasConverged(testError);; 1260 start = std::chrono::system_clock::now();; 1261 ; 1262 if (fInteractive) {; 1263 fInteractive->AddPoint(stepCount, trainingError, testError);; 1264 fIPyCurrentIter = 100.0 * minimizer.GetConvergenceCount(); 1265 / minimizer.GetConvergenceSteps ();; 1266 if (fExitFromTraining) break;; 1267 } else {; 1268 Log() << std::setw(10) << stepCount << "" | ""; 1269 << std::setw(12) << trainingError; 1270 << std::setw(12) << testError; 1271 << std::setw(12) << nFlops / seconds; 1272 << std::setw(12) << minimizer.GetConvergenceCount() << Endl;; 1273 if (converged) {; 1274 Log() << Endl;; 1275 }; 1276 }; 1277 }; 1278 }; 1279 ; 1280 ; 1281 for (size_t l = 0; l < net.GetDepth(); l++) {; 1282 auto & layer = fNet.GetLayer(l);; 1283 layer.GetWeights() = (TMatrixT<Scalar_t>) net.GetLayer(l).GetWeights();; 1284 layer.GetBiases() = (TMatrixT<Scalar_t>) net.GetLayer(l).GetBiases();; 1285 }; 1286 }; 1287 ; 1288#else // DNNCPU flag not set.; 1289 Log() << kFATAL << ""Multi-core CPU backend not enabled. Please make sure ""; 1290 ""you have a BLAS implementation and it was successfull",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/MethodDNN_8cxx_source.html:45462,test,testError,45462,doc/master/MethodDNN_8cxx_source.html,https://root.cern,https://root.cern/doc/master/MethodDNN_8cxx_source.html,2,['test'],['testError']
Testability,"o program ; labels1.C Setting alphanumeric labels in a 1-d histogram ; labels2.C Setting alphanumeric labels ; motorcycle.C Macro to test scatterplot smoothers: ksmooth, lowess, supsmu as described in: ; multigraph.C Create and Draw a TMultiGraph ; multigraphpalettecolor.C Palette coloring for multi-graphs is activated thanks to the options PFC (Palette Fill Color), PLC (Palette Line Color) and AMC (Palette Marker Color) ; multipalette.C Draw color plots using different color palettes ; seism.C Strip chart example ; splines_test.C Examples of use of the spline classes ; surfaces.C Draw 2-Dim functions ; timeonaxis.C This macro illustrates the use of the time mode on the axis with different time intervals and time formats ; timeonaxis2.C Define the time offset as 2003, January 1st ; timeonaxis3.C This example compares what the system time function gmtime and localtime give with what gives TGaxis ; waves.C Hint: Spherical waves ; zdemo.C This macro is an example of graphs in log scales with annotations ; zones.C Example of script showing how to divide a canvas into adjacent subpads + axis labels on the top and right side of the pads ; gui; buttonChangelabel.CThis macro gives an example for changing text button labels anytime the Start or Pause buttons are clicked ; buttongroupState.CA simple example that shows the enabled and disabled state of a button group with radio and check buttons ; buttonsLayout.CThis macro gives an example of different buttons' layout ; buttonTest.CThis macro gives an example of how to set/change text button attributes ; calendar.CThis macro gives an example of how to use html widget to display tabular data ; CPUMeter.CSimple macro showing capabilities of the TGSpeedo widget ; customContextMenu.CExample showing how to add a function to the class context menu ; customTH1Fmenu.CExample showing how to customize a context menu for a class ; drag_and_drop.CThis tutorial illustrates how to use drag and drop within ROOT ; e",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v610/files.html:118128,log,log,118128,doc/v610/files.html,https://root.cern,https://root.cern/doc/v610/files.html,1,['log'],['log']
Testability,"o proofd. void SetGlobalExpDate(TDatime expdate); Set default expiring date for new validity contexts. void SetDefaultUser(const char* defaultuser); Set default user name. void SetTimeOut(Int_t to); Set timeout (active if > 0). void SetAuthReUse(Bool_t authreuse); Set global AuthReUse flag. void SetPromptUser(Bool_t promptuser); Set global PromptUser flag. void SetSecureAuthHook(SecureAuth_t func); Set secure authorization function. Automatically called when libSRPAuth; is loaded. void SetKrb5AuthHook(Krb5Auth_t func); Set kerberos5 authorization function. Automatically called when; libKrb5Auth is loaded. void SetGlobusAuthHook(GlobusAuth_t func); Set Globus authorization function. Automatically called when; libGlobusAuth is loaded. Int_t SshError(const char* errfile); SSH error parsing: returns; 0 : no error or fatal; 1 : should retry (eg 'connection closed by remote host'). Int_t SshAuth(TString& user); SSH client authentication code. const char * GetSshUser(TString user) const; Method returning the user to be used for the ssh login.; Looks first at SSH.Login and finally at env USER.; If SSH.LoginPrompt is set to 'yes' it prompts for the 'login name'. Bool_t CheckHost(const char* Host, const char* host); Check if 'host' matches 'href':; this means either equal or ""containing"" it, even with wild cards *; in the first field (in the case 'href' is a name, ie not IP address); Returns kTRUE if the two matches. Int_t RfioAuth(TString& user); UidGid client authentication code.; Returns 0 in case authentication failed; 1 in case of success; <0 in case of system error. Int_t ClearAuth(TString& user, TString& passwd, Bool_t& pwhash); UsrPwd client authentication code.; Returns 0 in case authentication failed; 1 in case of success. THostAuth * GetHostAuth(const char* host, const char* user = """", Option_t* opt = ""R"", Int_t* Exact = 0); Sets fUser=user and search fgAuthInfo for the entry pertaining to; (host,user), setting fHostAuth accordingly.; If opt = ""P"" use fgProofAuthInf",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/TAuthenticate.html:16950,log,login,16950,root/html526/TAuthenticate.html,https://root.cern,https://root.cern/root/html526/TAuthenticate.html,7,['log'],['login']
Testability,"o provide a convenience function, SetAABoundingBox(),; for simpler case of setting an axis aligned bounding box. Master/Local Reference Frames; The Core section of TBuffer3D contains two members relating to reference; frames:; fLocalFrame & fLocalMaster. fLocalFrame indicates; if any positions in the buffer (bounding box and tessellation vertexes) are; in local or master (world; frame). fLocalMaster is a standard 4x4 translation matrix (OpenGL; colum major ordering) for placing the object into the 3D master frame.; If fLocalFrame is kFALSE, fLocalMaster should contain an; identity matrix. This is set by default, and can be reset using SetLocalMasterIdentity() function.; Logical & Physical Objects; There are two cases of object addition:. Add this object as a single independent entity in the world reference; frame.; Add; a physical placement (copy) of this logical object (described in local; reference frame). The second case is very typical in geometry packages, GEANT4, where we have; very large number repeated placements of relatively few logical (unique) shapes.; Some viewers (OpenGL only at present) are able to take advantage of this by; identifying unique logical shapes from the fID logical ID member of; TBuffer3D. If repeated addition of the same fID is found, the shape; is cached already - and the costly tessellation does not need to be sent again.; The viewer can; also perform internal GL specific caching with considerable performance gains; in these cases.; For this to work correctly the logical object in must be described in TBuffer3D; in the local reference frame, complete with the local/master translation. The; viewer indicates this through the interface method; PreferLocalFrame(); If this returns kTRUE you can make repeated calls to AddObject(), with TBuffer3D; containing the same fID, and different fLocalMaster placements.; For viewers supporting logical/physical objects, the TBuffer3D content refers; to the properties of logical object, with the fLocalM",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/TBuffer3D.html:5071,log,logical,5071,root/html526/TBuffer3D.html,https://root.cern,https://root.cern/root/html526/TBuffer3D.html,13,['log'],['logical']
Testability,o read into a ROOT TTree via TTree::ReadStream ; pyroot001_arrayInterface.py This tutorial illustrates the conversion of STL vectors and TVec to numpy arrays without copying the data ; pyroot002_TTreeAsMatrix.py This tutorial shows how a TTree can be quickly converted to a numpy array or a pandas.DataFrame ; qtexample.pyQt example ; ratioplot.py Display two histograms and their ratio ; rootmarks.pyPrints a summary of all ROOT benchmarks (must be run before) The ROOTMARK number printed is by reference to a Pentium IV 2.4 Ghz (with 512 MBytes memory and 120 GBytes IDE disk) taken by definition as 600 ROOTMARKS in batch mode in executing python benchmarks.py ; shapes.py Draw the geometry using the x3d viewver ; staff.py example of macro to read data from an ascii file and create a root file with a Tree ; surfaces.py Surfaces example ; test.py ; tornado.pyTornado example ; tree.py This macro displays the Tree data structures ; zdemo.py This macro is an example of graphs in log scales with annotations ; pythia; pythia8.CPythia8 basic example ; pythiaExample.CUsing Pythia6 with ROOT ; quadp; portfolio.C This macro shows in detail the use of the quadratic programming package quadp ; Quad.cxx; Quad.h; r; DataFrame.C ; example.C Simple example on how to use ROOT-R interface ; Function.C ; Functor.C Example to create class Functor ; GlobalMinimization.C Example based in http://cran.r-project.org/web/packages/DEoptim/DEoptim.pdf Please install the R package DEoptim before run this example ; Integration.C Numerical integration using R passing the function from ROOT ; Interpolation.C More Information for R interpolation in http://stat.ethz.ch/R-manual/R-patched/library/stats/html/approxfun.html NOTE: this example illustrates an interpolation with random points given from ROOT and procedures made in R's environment ; Minimization.C Example based in http://root.cern.ch/root/html/tutorials/fit/NumericalMinimization.C.html http://stat.ethz.ch/R-manua,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v614/files.html:144533,log,log,144533,doc/v614/files.html,https://root.cern,https://root.cern/doc/v614/files.html,1,['log'],['log']
Testability,"o servers; charfMode'e' (def) or 'i' (internal - proofsrv); Int_tfPid; Int_tfPortRemote port; Bool_tfRDInterruptTo interrupt waiting for messages; TObject*fReferenceGeneric object reference of this socket; kXR_int32fSendOptOptions for sending messages; Short_tfSessionIDproofsrv: remote ID of connected session; TStringfUserUsername used for login; Int_tfXrdProofdVersion; static Bool_tfgInitDoneAvoid initializing more than once; static TStringfgLocLocation string; static TXSockPipefgPipePipe for input monitoring; static TMutexfgSMtxTo protect spare list; static list<TXSockBuf*>fgSQuelist of spare buffers. Class Charts. Inheritance Chart:. TObject. ; TNamed. ; TSocket. XrdClientAbsUnsolMsgHandler. ; TXSocket. . TXUnixSocket. Function documentation; void DoError(int level, const char* location, const char* fmt, va_list va) const; Interface to ErrorHandler (protected). TXSocket(const char* url, Char_t mode = 'M', Int_t psid = -1, Char_t ver = -1, const char* logbuf = 0, Int_t loglevel = -1, TXHandler* handler = 0); Constructor; Open the connection to a remote XrdProofd instance and start a PROOF; session.; The mode 'm' indicates the role of this connection:; 'a' Administrator; used by an XPD to contact the head XPD; 'i' Internal; used by a TXProofServ to call back its creator; (see XrdProofUnixConn); 'C' PROOF manager: open connection only (do not start a session); 'M' Client creating a top master; 'A' Client attaching to top master; 'm' Top master creating a submaster; 's' Master creating a slave; The buffer 'logbuf' is a null terminated string to be sent over at; login. TXSocket(const TXSocket& ); TXSocket copy ctor. TXSocket& operator=(const TXSocket& ); TXSocket assignment operator. ~TXSocket(); Destructor. void SetLocation(const char* loc = """"); Set location string. void SetSessionID(Int_t id); Set session ID to 'id'. If id < 0, disable also the asynchronous handler. void DisconnectSession(Int_t id, Option_t* opt = """"); Disconnect a session. Use opt= ""S"" or ""s"" t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TXSocket.html:13563,log,logbuf,13563,root/html602/TXSocket.html,https://root.cern,https://root.cern/root/html602/TXSocket.html,2,['log'],"['logbuf', 'loglevel']"
Testability,"o split the training dataset into a training set and a validation set is implemented but not currently used. ; Definition at line 662 of file DataLoader.cxx. PrepareFoldDataSet(). void TMVA::DataLoader::PrepareFoldDataSet ; (; CvSplit &; s, . UInt_t; foldNumber, . Types::ETreeType; tt = Types::kTraining. ). Function for assigning the correct folds to the testing or training set. ; Definition at line 670 of file DataLoader.cxx. PrepareTrainingAndTestTree() [1/4]. void TMVA::DataLoader::PrepareTrainingAndTestTree ; (; const TCut &; cut, . const TString &; splitOpt. ). prepare the training and test trees -> same cuts for signal and background ; Definition at line 632 of file DataLoader.cxx. PrepareTrainingAndTestTree() [2/4]. void TMVA::DataLoader::PrepareTrainingAndTestTree ; (; const TCut &; cut, . Int_t; NsigTrain, . Int_t; NbkgTrain, . Int_t; NsigTest, . Int_t; NbkgTest, . const TString &; otherOpt = ""SplitMode=Random:!V"". ). prepare the training and test trees ; Definition at line 602 of file DataLoader.cxx. PrepareTrainingAndTestTree() [3/4]. void TMVA::DataLoader::PrepareTrainingAndTestTree ; (; const TCut &; cut, . Int_t; Ntrain, . Int_t; Ntest = -1. ). prepare the training and test trees kept for backward compatibility ; Definition at line 618 of file DataLoader.cxx. PrepareTrainingAndTestTree() [4/4]. void TMVA::DataLoader::PrepareTrainingAndTestTree ; (; TCut; sigcut, . TCut; bkgcut, . const TString &; splitOpt. ). prepare the training and test trees ; Definition at line 644 of file DataLoader.cxx. RecombineKFoldDataSet(). void TMVA::DataLoader::RecombineKFoldDataSet ; (; CvSplit &; s, . Types::ETreeType; tt = Types::kTraining. ). Recombines the dataset. ; The precise semantics depend on the actual split.; Similar to the inverse operation of MakeKFoldDataSet but will differ. See documentation for each particular split for more information. ; Definition at line 683 of file DataLoader.cxx. SetBackgroundTree(). void TMVA::D",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1DataLoader.html:31396,test,test,31396,doc/master/classTMVA_1_1DataLoader.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1DataLoader.html,1,['test'],['test']
Testability,"o testNet = net.CreateClone(settings.batchSize);; 943 ; 944 Log() << kINFO << ""Training phase "" << trainingPhase << "" of ""; 945 << fTrainingSettings.size() << "":"" << Endl;; 946 trainingPhase++;; 947 ; 948 using DataLoader_t = TDataLoader<TMVAInput_t, TCuda<>>;; 949 ; 950 // Split training data into training and validation set; 951 const std::vector<Event *> &allData = GetEventCollection(Types::kTraining);; 952 const std::vector<Event *> trainingInputData =; 953 std::vector<Event *>(allData.begin(), allData.begin() + nTrainingSamples);; 954 const std::vector<Event *> testInputData =; 955 std::vector<Event *>(allData.begin() + nTrainingSamples, allData.end());; 956 ; 957 if (trainingInputData.size() != nTrainingSamples) {; 958 Log() << kFATAL << ""Inconsistent training sample size"" << Endl;; 959 }; 960 if (testInputData.size() != nTestSamples) {; 961 Log() << kFATAL << ""Inconsistent test sample size"" << Endl;; 962 }; 963 ; 964 size_t nThreads = 1;; 965 TMVAInput_t trainingTuple = std::tie(trainingInputData, DataInfo());; 966 TMVAInput_t testTuple = std::tie(testInputData, DataInfo());; 967 DataLoader_t trainingData(trainingTuple, nTrainingSamples,; 968 net.GetBatchSize(), net.GetInputWidth(),; 969 net.GetOutputWidth(), nThreads);; 970 DataLoader_t testData(testTuple, nTestSamples, testNet.GetBatchSize(),; 971 net.GetInputWidth(), net.GetOutputWidth(),; 972 nThreads);; 973 DNN::TGradientDescent<TCuda<>> minimizer(settings.learningRate,; 974 settings.convergenceSteps,; 975 settings.testInterval);; 976 ; 977 std::vector<TNet<TCuda<>>> nets{};; 978 std::vector<TBatch<TCuda<>>> batches{};; 979 nets.reserve(nThreads);; 980 for (size_t i = 0; i < nThreads; i++) {; 981 nets.push_back(net);; 982 for (size_t j = 0; j < net.GetDepth(); j++); 983 {; 984 auto &masterLayer = net.GetLayer(j);; 985 auto &layer = nets.back().GetLayer(j);; 986 TCuda<>::Copy(layer.GetWeights(),; 987 masterLayer.GetWeights());; 988 TCuda<>::Copy(layer.GetBiases(),; 989 masterLayer.GetBiases());; 990 }; 991",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/MethodDNN_8cxx_source.html:34533,test,test,34533,doc/master/MethodDNN_8cxx_source.html,https://root.cern,https://root.cern/doc/master/MethodDNN_8cxx_source.html,3,['test'],"['test', 'testInputData', 'testTuple']"
Testability,"o that buffer (so we shall not delete that pointer), although we get a new buffer in case it's not found in the cache. There is a lot of code duplication but it was necessary to assure the expected behavior when there is no cache. ; Definition at line 464 of file TBasket.cxx. ReadBasketBuffersUncompressedCase(). Int_t TBasket::ReadBasketBuffersUncompressedCase ; (; ). private . By-passing buffer unzipping has been requested and is possible (only 1 entry in this basket). ; Definition at line 358 of file TBasket.cxx. ReadBasketBuffersUnzip(). Int_t TBasket::ReadBasketBuffersUnzip ; (; char *; buffer, . Int_t; size, . bool; mustFree, . TFile *; file. ). private . We always create the TBuffer for the basket but it hold the buffer from the cache. ; Definition at line 380 of file TBasket.cxx. ReadBasketBytes(). Int_t TBasket::ReadBasketBytes ; (; Long64_t; pos, . TFile *; file. ). Read basket buffers in memory and cleanup. ; Read first bytes of a logical record starting at position pos return record length (first 4 bytes of record). ; Definition at line 698 of file TBasket.cxx. ReadResetBuffer(). void TBasket::ReadResetBuffer ; (; Int_t; basketnumber). protectedvirtual . Reset the read basket TBuffer memory allocation if needed. ; This allows to reduce the number of memory allocation while avoiding to always use the maximum size. ; Definition at line 733 of file TBasket.cxx. ResetEntryOffset(). void TBasket::ResetEntryOffset ; (; ). private . Definition at line 441 of file TBasket.cxx. SetBranch(). void TBasket::SetBranch ; (; TBranch *; branch). inline . Definition at line 148 of file TBasket.h. SetNevBufSize(). void TBasket::SetNevBufSize ; (; Int_t; n). inline . Definition at line 149 of file TBasket.h. SetReadMode(). void TBasket::SetReadMode ; (; ). virtual . Set read mode of basket. ; Definition at line 925 of file TBasket.cxx. SetWriteMode(). void TBasket::SetWriteMode ; (; ). virtual . Set write mode of basket. ; Definition at line 934",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTBasket.html:28132,log,logical,28132,doc/master/classTBasket.html,https://root.cern,https://root.cern/doc/master/classTBasket.html,1,['log'],['logical']
Testability,"o your local repository on the master branch, and you realize (perhaps because your project is turning out to be a bit more involved than you thought, or because a slew of changes have just appeared upstream) that you might have been better using NoSY. It's actually quite easy to swap to using NoSY without any disruption to your already-committed changes. Starting from your current position on the master branch:; Stash your current changes if appropriate:; git stash. Create (but do not switch to) a branch which will contain all your local commits up to this point:; git branch <local-branch>. Download the latest metadata from the remote:; git fetch origin. Now, reset your local master branch directly to the current state of origin/master:; git reset --hard origin/master. Note that you have not lost your local commits: they are on your local branch already.; Switch to your local branch:; git checkout <local-branch>. Do an initial sync between your local branch and the remote, resolving conflicts if necessary:; git rebase origin/master. Apply your stash, again, resolving conflicts if necessary:; git stash pop. Pick up at step 2 of the NoSY workflow above.; Reproduced with permission from the following page: https://cdcvs.fnal.gov/redmine/projects/cet-is-public/wiki/GitTipsAndTricks by Chris Green. Sitemap. DownloadDownload ROOT; All Releases. DocumentationReference Manual; User's Guides; HowTo; Courses; Building ROOT; Tutorials; Javascript Root; ROOT and Spark; Publications; FAQ. NewsBlog; Workshops. SupportForum; Bug submission guidelines; Submit a Bug; Discourse Mailing List Mode; RootTalk Digest. AboutLicence; Contact Us; Project Founders; Team; Previous Developers. DevelopmentProgram of Work; Code Owners; Release Checklist; Coding Conventions; Shifter's Instructions; Git Primer; Browse Sources; Meetings; ROOT 7; Run the tests; Jenkins; Setup externals from AFS/CVMFS; Doxygen; Benchmarks. ContributeCollaborate with Us.  Copyright CERN 2014-18. All rights reserved. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/git-how-tos.html:5432,test,tests,5432,d/git-how-tos.html,https://root.cern,https://root.cern/d/git-how-tos.html,1,['test'],['tests']
Testability,"o(""Double_t"")) {; 3079 t.SetBranchAddress(cleanName, &_value);; 3080 }; 3081 else {; 3082 coutE(InputArguments) << ""RooAbsReal::attachToTree("" << GetName() << "") data type "" << typeName << "" is not supported."" << std::endl ;; 3083 }; 3084 }; 3085 } else {; 3086 ; 3087 TString format(cleanName);; 3088 format.Append(""/D"");; 3089 branch = t.Branch(cleanName, &_value, (const Text_t*)format, bufSize);; 3090 }; 3091 ; 3092}; 3093 ; 3094 ; 3095 ; 3096////////////////////////////////////////////////////////////////////////////////; 3097/// Fill the tree branch that associated with this object with its current value; 3098 ; 3099void RooAbsReal::fillTreeBranch(TTree& t); 3100{; 3101 // First determine if branch is taken; 3102 TBranch* branch = t.GetBranch(cleanBranchName()) ;; 3103 if (!branch) {; 3104 coutE(Eval) << ""RooAbsReal::fillTreeBranch("" << GetName() << "") ERROR: not attached to tree: "" << cleanBranchName() << std::endl ;; 3105 assert(0) ;; 3106 }; 3107 branch->Fill() ;; 3108 ; 3109}; 3110 ; 3111 ; 3112 ; 3113////////////////////////////////////////////////////////////////////////////////; 3114/// (De)Activate associated tree branch; 3115 ; 3116void RooAbsReal::setTreeBranchStatus(TTree& t, bool active); 3117{; 3118 TBranch* branch = t.GetBranch(cleanBranchName()) ;; 3119 if (branch) {; 3120 t.SetBranchStatus(cleanBranchName(),active?true:false) ;; 3121 }; 3122}; 3123 ; 3124 ; 3125 ; 3126////////////////////////////////////////////////////////////////////////////////; 3127/// Create a RooRealVar fundamental object with our properties. The new; 3128/// object will be created without any fit limits.; 3129 ; 3130RooFit::OwningPtr<RooAbsArg> RooAbsReal::createFundamental(const char* newname) const; 3131{; 3132 auto fund = std::make_unique<RooRealVar>(newname?newname:GetName(),GetTitle(),_value,getUnit());; 3133 fund->removeRange();; 3134 fund->setPlotLabel(getPlotLabel());; 3135 fund->setAttribute(""fundamentalCopy"");; 3136 return RooFit::makeOwningPtr<RooAbsArg>(std::move",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RooAbsReal_8cxx_source.html:135141,assert,assert,135141,doc/master/RooAbsReal_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html,1,['assert'],['assert']
Testability,"o.Browse. ; TMacro.Browse can be set in the system.rootrc or .rootrc file like: TMacro.Browse : Action; TMacro::Browsevoid Browse(TBrowser *b) overrideWhen clicking in the browser, the following action is performed on this macro, depending the content ...Definition TMacro.cxx:171; or set via gEnv->SetValue, eg gEnv->SetValue(""TMacro.Browse"",""Print"");; gEnvR__EXTERN TEnv * gEnvDefinition TEnv.h:170; TEnv::SetValuevirtual void SetValue(const char *name, const char *value, EEnvLevel level=kEnvChange, const char *type=nullptr)Set the value of a resource or create a new resource.Definition TEnv.cxx:736; By default TMacro.Browse="""" -if TMacro.Browse ="""" the macro is executed -if TMacro.Browse =""Print"" the macro is printed in stdout -if TMacro.Browse is of the form ""mymacro.C"" the macro void mymacro.C(TMacro *m) is called where m=this macro An example of macro.C saving the macro into a file and viewing it with emacs is shown below: void mymacro(TMacro *m) {; m->SaveSource(""xx.log"");; gSystem->Exec(""emacs xx.log&"");; }; gSystemR__EXTERN TSystem * gSystemDefinition TSystem.h:561; TSystem::Execvirtual Int_t Exec(const char *shellcmd)Execute a command.Definition TSystem.cxx:653. Reimplemented from TObject.; Definition at line 171 of file TMacro.cxx. Checksum(). TMD5 * TMacro::Checksum ; (; ). virtual . Returns checksum of the current content. ; The returned TMD5 object must be deleted by the user. Returns 0 in case of error. ; Definition at line 192 of file TMacro.cxx. Class(). static TClass * TMacro::Class ; (; ). static . ReturnsTClass describing this class . Class_Name(). static const char * TMacro::Class_Name ; (; ). static . ReturnsName of this class . Class_Version(). static constexpr Version_t TMacro::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 59 of file TMacro.h. DeclFileName(). static const char * TMacro::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definit",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMacro.html:16435,log,log,16435,doc/master/classTMacro.html,https://root.cern,https://root.cern/doc/master/classTMacro.html,1,['log'],['log']
Testability,"o:. TF1 *f1 = (TF1*)h->GetListOfFunctions()->FindObject(name);. or. TF1 *f1 = h->GetFunction(name);. Associated functions are automatically painted when an histogram is drawn.; To avoid the painting of the associated functions the option HIST; should be added to the list of the options used to paint the histogram.; Drawing using OpenGL; The class TGLHistPainter allows to paint data set using the OpenGL 3D; graphics library. The plotting options start with GL keyword.; In addition, in order to inform canvases that OpenGL should be used to render; 3D representations, the following option should be set:. gStyle->SetCanvasPreferGL(true);. General information: plot types and supported options; The following types of plots are provided:; For lego plots the supported options are:. ""GLLEGO""; Draw a lego plot. It works also for TH2Poly. ""GLLEGO2; Bins with color levels. ""GLLEGO3; Cylindrical bars. Lego painter in cartesian supports logarithmic scales for X, Y, Z.; In polar only Z axis can be logarithmic, in cylindrical only Y.; For surface plots (TF2 and TH2) the supported options are:. ""GLSURF"" ; Draw a surface. ""GLSURF1""; Surface with color levels. ""GLSURF2""; The same as ""GLSURF1"" but without polygon outlines. ""GLSURF3""; Color level projection on top of plot (works only in cartesian coordinate; system). ""GLSURF4""; Same as ""GLSURF"" but without polygon outlines. The surface painting in cartesian coordinates supports logarithmic scales along; X, Y, Z axis. In polar coordinates only the Z axis can be logarithmic,; in cylindrical coordinates only the Y axis.; Additional options to SURF and LEGO - Coordinate systems:. "" ""; Default, cartesian coordinates system. ""POL""; Polar coordinates system. ""CYL""; Cylindrical coordinates system. ""SPH""; Spherical coordinates system. TH3 as boxes (spheres); The supported options are:. GLBOX"" ; TH3 as a set of boxes, size of box is proportional to bin content. GLBOX1""; The same as ""glbox"", but spheres are drawn instead of boxes. TH3 as iso-surfac",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/THistPainter.html:69666,log,logarithmic,69666,root/html528/THistPainter.html,https://root.cern,https://root.cern/root/html528/THistPainter.html,3,['log'],['logarithmic']
Testability,"o:. TF1 *f1 = (TF1*)h->GetListOfFunctions()->FindObject(name);. or. TF1 *f1 = h->GetFunction(name);. Associated functions are automatically painted when an histogram is drawn.; To avoid the painting of the associated functions the option HIST; should be added to the list of the options used to paint the histogram.; Drawing using OpenGL; The class TGLHistPainter allows to paint data set using the OpenGL 3D; graphics library. The plotting options start with GL keyword.; In addition, in order to inform canvases that OpenGL should be used to render; 3D representations, the following option should be set:. gStyle->SetCanvasPreferGL(true);. General information: plot types and supported options; The following types of plots are provided:; For lego plots the supported options are:. ""GLLEGO""; Draw a lego plot. It works also for TH2Poly. ""GLLEGO2; Bins with color levels. ""GLLEGO3; Cylindrical bars. Lego painter in cartesian supports logarithmic scales for X, Y, Z.; In polar only Z axis can be logarithmic, in cylindrical only Y.; For surface plots (TF2 and TH2) the supported options are:. ""GLSURF"" ; Draw a surface. ""GLSURF1""; Surface with color levels. ""GLSURF2""; The same as ""GLSURF1"" but without polygon outlines. ""GLSURF3""; Color level projection on top of plot (works only in cartesian coordinate; system). ""GLSURF4""; Same as ""GLSURF"" but without polygon outlines. The surface painting in cartesian coordinates supports logarithmic scales along; X, Y, Z axis. In polar coordinates only the Z axis can be logarithmic,; in cylindrical coordinates only the Y axis.; Additional options to SURF and LEGO - Coordinate systems:. "" ""; Default, cartesian coordinates system. ""POL""; Polar coordinates system. ""CYL""; Cylindrical coordinates system. ""SPH""; Spherical coordinates system. TH3 as color boxes; The supported option is:. ""GLCOL"" ; H3 is drawn using semi-transparent colored boxes.; See $ROOTSYS/tutorials/gl/glvox1.C. TH3 as boxes (spheres); The supported options are:. ""GLBOX"" ; TH3 as a s",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/THistPainter.html:79196,log,logarithmic,79196,root/html604/THistPainter.html,https://root.cern,https://root.cern/root/html604/THistPainter.html,1,['log'],['logarithmic']
Testability,"o:. TF1 *f1 = (TF1*)h->GetListOfFunctions()->FindObject(name);. or. TF1 *f1 = h->GetFunction(name);. Associated functions are automatically painted when an histogram is drawn.; To avoid the painting of the associated functions the option HIST; should be added to the list of the options used to paint the histogram.; Drawing using OpenGL; The class TGLHistPainter allows to paint data set using the OpenGL 3D; graphics library. The plotting options start with GL keyword.; In addition, in order to inform canvases that OpenGL should be used to render; 3D representations, the following option should be set:. gStyle->SetCanvasPreferGL(true);. General information: plot types and supported options; The following types of plots are provided:; For lego plots the supported options are:. ""GLLEGO""; Draw a lego plot. It works also for TH2Poly. ""GLLEGO2; Bins with color levels. ""GLLEGO3; Cylindrical bars. Lego painter in cartesian supports logarithmic scales for X, Y, Z.; In polar only Z axis can be logarithmic, in cylindrical only Y.; For surface plots (TF2 and TH2) the supported options are:. ""GLSURF"" ; Draw a surface. ""GLSURF1""; Surface with color levels. ""GLSURF2""; The same as ""GLSURF1"" but without polygon outlines. ""GLSURF3""; Color level projection on top of plot (works only in cartesian coordinate; system). ""GLSURF4""; Same as ""GLSURF"" but without polygon outlines. The surface painting in cartesian coordinates supports logarithmic scales along; X, Y, Z axis. In polar coordinates only the Z axis can be logarithmic,; in cylindrical coordinates only the Y axis.; Additional options to SURF and LEGO - Coordinate systems:. "" ""; Default, cartesian coordinates system. ""POL""; Polar coordinates system. ""CYL""; Cylindrical coordinates system. ""SPH""; Spherical coordinates system. TH3 as color boxes; The supported option is:. ""GLCOL"" ; H3 is drawn using semi-transparent colored boxes.; See $ROOTSYS/tutorials/gl/glvox1.C. TH3 as boxes (spheres); The supported options are:. GLBOX"" ; TH3 as a se",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/THistPainter.html:74868,log,logarithmic,74868,root/html534/THistPainter.html,https://root.cern,https://root.cern/root/html534/THistPainter.html,2,['log'],['logarithmic']
Testability,"o::GetListOfVariablesstd::vector< TString > GetListOfVariables() constreturns list of variablesDefinition DataSetInfo.cxx:406; TMVA::DataSetInfo::GetClassInfoClassInfo * GetClassInfo(Int_t clNum) constDefinition DataSetInfo.cxx:146; TMVA::DataSetInfo::GetCutconst TCut & GetCut(Int_t i) constDefinition DataSetInfo.h:168; TMVA::DataSetInfo::GetVariableInfoVariableInfo & GetVariableInfo(Int_t i)Definition DataSetInfo.h:105; TMVA::DataSetInfo::IsSignalBool_t IsSignal(const Event *ev) constDefinition DataSetInfo.cxx:167; TMVA::DataSetInfo::GetDataSetManagerDataSetManager * GetDataSetManager()Definition DataSetInfo.h:194; TMVA::DataSetManager::DataInputDataInputHandler & DataInput()Definition DataSetManager.h:76; TMVA::DataSetClass that contains all the data information.Definition DataSet.h:58; TMVA::DataSet::GetNEvtSigTestLong64_t GetNEvtSigTest()return number of signal test events in datasetDefinition DataSet.cxx:427; TMVA::DataSet::GetTreeTTree * GetTree(Types::ETreeType type)create the test/trainings tree with all the variables, the weights, the classes, the targets,...Definition DataSet.cxx:609; TMVA::DataSet::GetEventconst Event * GetEvent() constreturns event without transformationsDefinition DataSet.cxx:202; TMVA::DataSet::GetNEventsLong64_t GetNEvents(Types::ETreeType type=Types::kMaxTreeType) constDefinition DataSet.h:206; TMVA::DataSet::GetResultsResults * GetResults(const TString &, Types::ETreeType type, Types::EAnalysisType analysistype)Definition DataSet.cxx:265; TMVA::DataSet::GetNTrainingEventsLong64_t GetNTrainingEvents() constDefinition DataSet.h:68; TMVA::DataSet::SetCurrentTypevoid SetCurrentType(Types::ETreeType type) constDefinition DataSet.h:89; TMVA::DataSet::GetEventCollectionconst std::vector< Event * > & GetEventCollection(Types::ETreeType type=Types::kMaxTreeType) constDefinition DataSet.h:216; TMVA::DataSet::GetNEvtBkgdTestLong64_t GetNEvtBkgdTest()return number of background test events in datasetDefinition DataSet.cxx:435; TMVA::EventDefinit",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/tmva_2tmva_2src_2Factory_8cxx_source.html:118652,test,test,118652,doc/master/tmva_2tmva_2src_2Factory_8cxx_source.html,https://root.cern,https://root.cern/doc/master/tmva_2tmva_2src_2Factory_8cxx_source.html,1,['test'],['test']
Testability,"o::Streamer ; (; TBuffer &; R__b). virtual . Stream an object of class TObject. ; Reimplemented from TObject. StreamerNVirtual(). void TMVA::DataSetInfo::StreamerNVirtual ; (; TBuffer &; ClassDef_StreamerNVirtual_b). inline . Definition at line 244 of file DataSetInfo.h. Friends And Related Symbol Documentation. DataSetManager. friend class DataSetManager. friend . Definition at line 199 of file DataSetInfo.h. Member Data Documentation. fClasses. std::vector<ClassInfo*> TMVA::DataSetInfo::fClasses. mutableprivate . name and other infos of the classes ; Definition at line 220 of file DataSetInfo.h. fDataSet. DataSet* TMVA::DataSetInfo::fDataSet. mutableprivate . dataset, owned by this datasetinfo object ; Definition at line 208 of file DataSetInfo.h. fDataSetManager. TMVA::DataSetManager* TMVA::DataSetInfo::fDataSetManager. private . Definition at line 197 of file DataSetInfo.h. fLogger. MsgLogger* TMVA::DataSetInfo::fLogger. mutableprivate . ! message logger ; Definition at line 239 of file DataSetInfo.h. fName. TString TMVA::DataSetInfo::fName. private . name of the dataset info object ; Definition at line 206 of file DataSetInfo.h. fNeedsRebuilding. Bool_t TMVA::DataSetInfo::fNeedsRebuilding. mutableprivate . flag if rebuilding of dataset is needed (after change of cuts, vars, etc.) ; Definition at line 209 of file DataSetInfo.h. fNormalization. TString TMVA::DataSetInfo::fNormalization. private . Definition at line 222 of file DataSetInfo.h. fOwnRootDir. TDirectory* TMVA::DataSetInfo::fOwnRootDir. private . ROOT output dir. ; Definition at line 232 of file DataSetInfo.h. fSignalClass. UInt_t TMVA::DataSetInfo::fSignalClass. private . index of the class with the name signal ; Definition at line 235 of file DataSetInfo.h. fSpectators. std::vector<VariableInfo> TMVA::DataSetInfo::fSpectators. private . list of spectators expressions/internal names ; Definition at line 214 of file DataSetInfo.h. fSplitOptions. TString TMVA::DataSetInfo::fSp",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1DataSetInfo.html:31494,log,logger,31494,doc/master/classTMVA_1_1DataSetInfo.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1DataSetInfo.html,1,['log'],['logger']
Testability,o; TMVA::MethodCuts::EEffMethodfEffMethodchosen efficiency calculation method; TStringfEffMethodSchosen efficiency calculation method (string); Double_tfEffRefreference efficiency; Double_tfEffSMaxused to test optimized signal efficiency; Double_tfEffSMinused to test optimized signal efficiency; TMVA::MethodCuts::EFitMethodTypefFitMethodchosen fit method; TStringfFitMethodSchosen fit method (string); vector<TMVA::MethodCuts::EFitParameters>*fFitParamsvector for series of fit methods; vector<Double_t>*fMeanBmeans of variables (background); vector<Double_t>*fMeanSmeans of variables (signal); Bool_tfNegEffWarningflag risen in case of negative efficiency warning; Int_tfNparnumber of parameters in fit (default: 2*Nvar); TRandom*fRandomrandom generator for MC optimisation method; vector<Int_t>*fRangeSignused to match cuts to fit parameters (and vice versa); vector<Double_t>*fRmsBRMSs of variables (background); vector<Double_t>*fRmsSRMSs of variables (signal); Double_tfTestSignalEffused to test optimized signal efficiency; Double_t*fTmpCutMaxtemporary maximum requirement; Double_t*fTmpCutMintemporary minimum requirement; vector<TH1*>*fVarHistBreference histograms (background); vector<TH1*>*fVarHistB_smoothsmoothed reference histograms (background); vector<TH1*>*fVarHistSreference histograms (signal); vector<TH1*>*fVarHistS_smoothsmoothed reference histograms (signal); vector<TMVA::PDF*>*fVarPdfBreference PDFs (background); vector<TMVA::PDF*>*fVarPdfSreference PDFs (signal); static TMVA::MethodCuts::EFitParameterskForceMax; static TMVA::MethodCuts::EFitParameterskForceMin; static TMVA::MethodCuts::EFitParameterskForceSmart; static TMVA::MethodCuts::EFitParameterskNotEnforced; static TMVA::MethodCuts::EFitMethodTypekUseEventScan; static TMVA::MethodCuts::EEffMethodkUseEventSelection; static TMVA::MethodCuts::EFitMethodTypekUseGeneticAlgorithm; static TMVA::MethodCuts::EFitMethodTypekUseMinuit; static TMVA::MethodCuts::EFitMethodTypekUseMonteCarlo; static TMVA::MethodCuts::EFi,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TMVA__MethodCuts.html:21613,test,test,21613,root/html602/TMVA__MethodCuts.html,https://root.cern,https://root.cern/root/html602/TMVA__MethodCuts.html,2,['test'],['test']
Testability,"oAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); virtual RooAbsArg&operator=(const RooAbsReal& other); virtual RooAbsArg&operator=(Double_t newValue); virtual RooAbsArg&operator=(Int_t ival); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, RooLinkedList& cmdList) const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg(), const RooCmdArg& arg9 = RooCmdArg(), const RooCmdArg& arg10 = RooCmdArg()) const; virtual list<Double_t>*RooAbsReal::plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; virtual RooPlot*RooAbsReal::plotSliceOn(RooPlot* frame, const RooArgSet& sliceSet, Option_t* drawOptions = ""L"", Double_t scaleFactor = 1.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAbsRealLValue.html:23124,test,testArg,23124,root/html534/RooAbsRealLValue.html,https://root.cern,https://root.cern/root/html534/RooAbsRealLValue.html,1,['test'],['testArg']
Testability,oAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Double_tRooAbsTestStatistic::_evalCarry! carry of Kahan sum in evaluatePartition; Int_tRooAbsTestStatistic::_extSet! Number of designated set to calculated extended term; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; RooAbsReal*RooAbsTestStatistic::_funcPointer to original input function; RooAbsReal*_funcClonePointer to internal clone of input function; RooArgSet*_funcCloneSetSet owning all components of internal clone of input function; RooArgSet*_funcObsSetList of observables in the pdf expression; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; pRooAbsTestStatistic*RooAbsTestStatistic::_gofArray! Array of sub-contexts representing part of the combined test statistic; RooAbsTestStatistic::GOFOpModeRooAbsTestStatistic::_gofOpModeOperation mode of test statistic instance; vector<RooFit::MPSplit>RooAbsTestStatistic::_gofSplitMode! GOF MP Split mode specified by component (when Auto is active); static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Bool_tRooAbsTestStatistic::_init! Is object initialized; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches; Bool_tRooAbsArg::_isConstant! Cached isConstant status; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; pRooRealMPFE*RooAbsTestStatistic::_mpfeArray! Array of parallel execution frond ends; RooFit::MPSplitRooAbsTestStatistic::_mpinterlUse interleaving strategy rather than N-wise split for partioning of dataset for multiprocessor-split; ,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooAbsOptTestStatistic.html:39336,test,test,39336,root/html602/RooAbsOptTestStatistic.html,https://root.cern,https://root.cern/root/html602/RooAbsOptTestStatistic.html,2,['test'],['test']
Testability,"oAbsArg::isValueDirtyAndClear() const; Bool_tRooAbsArg::isValueOrShapeDirtyAndClear() const; Bool_tRooAbsArg::isValueServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isValueServer(const char* name) const; Bool_tTObject::IsZombie() const; voidRooAbsArg::leafNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; const RooCatType*lookupType(Int_t index, Bool_t printError = kFALSE) const; const RooCatType*lookupType(const char* label, Bool_t printError = kFALSE) const; const RooCatType*lookupType(const RooCatType& type, Bool_t printError = kFALSE) const; virtual voidTNamed::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; Int_tnumTypes(const char* = 0) const; Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); Bool_toperator!=(Int_t index); Bool_toperator!=(const char* label); Bool_toperator!=(const RooAbsArg& other); TNamed&TNamed::operator=(const TNamed& rhs); Bool_toperator==(Int_t index) const; Bool_toperator==(const char* label) const; virtual Bool_toperator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooAbsCategory.html:9667,test,testArg,9667,root/html532/RooAbsCategory.html,https://root.cern,https://root.cern/root/html532/RooAbsCategory.html,1,['test'],['testArg']
Testability,"oAbsArg::isValueServer(const char* name) const; Bool_tTObject::IsZombie() const; voidRooAbsArg::leafNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; Bool_tRooAbsArg::localNoDirtyInhibit() const; const RooCatType*RooAbsCategory::lookupType(Int_t index, Bool_t printError = kFALSE) const; const RooCatType*RooAbsCategory::lookupType(const char* label, Bool_t printError = kFALSE) const; const RooCatType*RooAbsCategory::lookupType(const RooCatType& type, Bool_t printError = kFALSE) const; virtual voidTNamed::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; virtual Bool_tTObject::Notify(); virtual Int_tnumBins(const char* rangeName) const; Int_tRooAbsArg::numCaches() const; Int_tRooAbsCategory::numTypes(const char* = 0) const; Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); Bool_tRooAbsCategory::operator!=(Int_t index); Bool_tRooAbsCategory::operator!=(const char* label); Bool_tRooAbsCategory::operator!=(const RooAbsArg& other); RooAbsArg&operator=(int index); RooAbsArg&operator=(const char* label); RooAbsArg&operator=(const RooAbsCategory& other); Bool_tRooAbsCategory::operator==(Int_t index) const; Bool_tRooAbsCategory::operator==(const char* label) const; virtu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAbsCategoryLValue.html:10916,test,testArg,10916,root/html534/RooAbsCategoryLValue.html,https://root.cern,https://root.cern/root/html534/RooAbsCategoryLValue.html,1,['test'],['testArg']
Testability,"oAbsArg::isValueServer(const char* name) const; Bool_tTObject::IsZombie() const; voidRooAbsArg::leafNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; Bool_tRooAbsArg::localNoDirtyInhibit() const; const RooCatType*RooAbsCategory::lookupType(Int_t index, Bool_t printError = kFALSE) const; const RooCatType*RooAbsCategory::lookupType(const char* label, Bool_t printError = kFALSE) const; const RooCatType*RooAbsCategory::lookupType(const RooCatType& type, Bool_t printError = kFALSE) const; virtual voidTNamed::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; virtual Bool_tTObject::Notify(); virtual Int_tnumBins(const char* rangeName) const; Int_tRooAbsArg::numCaches() const; Int_tRooAbsCategory::numTypes(const char* = 0) const; Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); Bool_tRooAbsCategory::operator!=(Int_t index); Bool_tRooAbsCategory::operator!=(const char* label); Bool_tRooAbsCategory::operator!=(const RooAbsArg& other); RooAbsArg&operator=(int index); RooAbsArg&operator=(const char* label); RooAbsArg&operator=(const RooAbsCategory& other); RooAbsCategoryLValue&operator=(const RooAbsCategoryLValue&); Bool_tRooAbsCategory::operator==(Int_t index) const; Bool_tRooAbsCategory::operator=",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooAbsCategoryLValue.html:10906,test,testArg,10906,root/html602/RooAbsCategoryLValue.html,https://root.cern,https://root.cern/root/html602/RooAbsCategoryLValue.html,2,['test'],['testArg']
Testability,"oAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TNamed&TNamed::operator=(const TNamed& rhs); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); const RooArgList&paramList() const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, RooLinkedList& cmdList) const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg(), const RooCmdArg& arg9 = RooCmdArg(), const RooCmdArg& arg10 = RooCmdArg()) const; virtual list<Double_t>*plotSamplingHint(RooAbsRealLValue& obs, Double_t xlo, Double_t xhi) const; virtual RooPlot*RooAbsReal::plotSliceOn(RooPlot* frame, const RooArgSet& sliceSet, Option_t* drawOptions = ""L"", Double_t scaleFactor = 1.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/ParamHistFunc.html:20113,test,testArg,20113,root/html534/ParamHistFunc.html,https://root.cern,https://root.cern/root/html534/ParamHistFunc.html,3,['test'],['testArg']
Testability,"oAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; Bool_tRooAbsArg::localNoDirtyInhibit() const; const RooCatType*RooAbsCategory::lookupType(Int_t index, Bool_t printError = kFALSE) const; const RooCatType*RooAbsCategory::lookupType(const char* label, Bool_t printError = kFALSE) const; const RooCatType*RooAbsCategory::lookupType(const RooCatType& type, Bool_t printError = kFALSE) const; virtual voidTNamed::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; virtual Bool_tTObject::Notify(); virtual Int_tRooAbsCategoryLValue::numBins(const char* rangeName) const; Int_tRooAbsArg::numCaches() const; Int_tRooAbsCategory::numTypes(const char* = 0) const; Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); Bool_tRooAbsCategory::operator!=(Int_t index); Bool_tRooAbsCategory::operator!=(const char* label); Bool_tRooAbsCategory::operator!=(const RooAbsArg& other); RooAbsArg&RooAbsCategoryLValue::operator=(int index); RooAbsArg&RooAbsCategoryLValue::operator=(const char* label); RooAbsArg&RooAbsCategoryLValue::operator=(const RooAbsCategory& other); Bool_tRooAbsCategory::operator==(Int_t index) const; Bool_tRooAbsCategory::operator==(const char* label) const; virtual Bool_tRooAbsCategory::oper",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooCategory.html:11099,test,testArg,11099,root/html534/RooCategory.html,https://root.cern,https://root.cern/root/html534/RooCategory.html,1,['test'],['testArg']
Testability,"oAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; Bool_tRooAbsArg::localNoDirtyInhibit() const; const RooCatType*RooAbsCategory::lookupType(Int_t index, Bool_t printError = kFALSE) const; const RooCatType*RooAbsCategory::lookupType(const char* label, Bool_t printError = kFALSE) const; const RooCatType*RooAbsCategory::lookupType(const RooCatType& type, Bool_t printError = kFALSE) const; virtual voidTNamed::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; virtual Bool_tTObject::Notify(); virtual Int_tRooAbsCategoryLValue::numBins(const char* rangeName) const; Int_tRooAbsArg::numCaches() const; Int_tRooAbsCategory::numTypes(const char* = 0) const; Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); Bool_tRooAbsCategory::operator!=(Int_t index); Bool_tRooAbsCategory::operator!=(const char* label); Bool_tRooAbsCategory::operator!=(const RooAbsArg& other); RooCategory&operator=(const RooCategory&); Bool_tRooAbsCategory::operator==(Int_t index) const; Bool_tRooAbsCategory::operator==(const char* label) const; virtual Bool_tRooAbsCategory::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooCategory.html:10963,test,testArg,10963,root/html602/RooCategory.html,https://root.cern,https://root.cern/root/html602/RooCategory.html,2,['test'],['testArg']
Testability,"oAbsReal* originator, const char* origName, const char* message, const char* serverValueString = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooMoment*RooAbsReal::mean(RooRealVar& obs); RooMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TNamed&TNamed::operator=(const TNamed& rhs); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/ParamHistFunc.html:18053,test,testArg,18053,root/html532/ParamHistFunc.html,https://root.cern,https://root.cern/root/html532/ParamHistFunc.html,8,['test'],['testArg']
Testability,"oAbsReal* originator, const char* origName, const char* message, const char* serverValueString = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooMoment*RooAbsReal::mean(RooRealVar& obs); RooMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TNamed&TNamed::operator=(const TNamed& rhs); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg&",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooAbsOptTestStatistic.html:18782,test,testArg,18782,root/html532/RooAbsOptTestStatistic.html,https://root.cern,https://root.cern/root/html532/RooAbsOptTestStatistic.html,3,['test'],['testArg']
Testability,"oAbsReal* originator, const char* origName, const char* message, const char* serverValueString = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tmaxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooAbsMoment*RooAbsReal::mean(RooRealVar& obs); RooAbsMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TNamed&TNamed::operator=(const TNamed& rhs); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, Roo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooHistFunc.html:18761,test,testArg,18761,root/html534/RooHistFunc.html,https://root.cern,https://root.cern/root/html534/RooHistFunc.html,3,['test'],['testArg']
Testability,"oAbsReal* originator, const char* origName, const char* message, const char* serverValueString = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tmaxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooAbsMoment*RooAbsReal::mean(RooRealVar& obs); RooAbsMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooHistFunc&operator=(const RooHistFunc&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedLis",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooHistFunc.html:18411,test,testArg,18411,root/html602/RooHistFunc.html,https://root.cern,https://root.cern/root/html602/RooHistFunc.html,2,['test'],['testArg']
Testability,"oAbsReal* originator, const char* origName, const char* message, const char* serverValueString = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tmaxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooAbsMoment*RooAbsReal::mean(RooRealVar& obs); RooAbsMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooLegendre&operator=(const RooLegendre&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedLis",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooLegendre.html:18207,test,testArg,18207,root/html602/RooLegendre.html,https://root.cern,https://root.cern/root/html602/RooLegendre.html,2,['test'],['testArg']
Testability,"oAbsReal* originator, const char* origName, const char* message, const char* serverValueString = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tmaxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooAbsMoment*RooAbsReal::mean(RooRealVar& obs); RooAbsMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooSpHarmonic&operator=(const RooSpHarmonic&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinke",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooSpHarmonic.html:19370,test,testArg,19370,root/html602/RooSpHarmonic.html,https://root.cern,https://root.cern/root/html602/RooSpHarmonic.html,2,['test'],['testArg']
Testability,"oAbsReal** gofArray, Int_t nVal) const; Method to combined test statistic results calculated into partitions into; the global result. This default implementation adds the partition return; values. Bool_t redirectServersHook(const RooAbsCollection& newServerList, Bool_t mustReplaceAll, Bool_t nameChange, Bool_t isRecursive); Catch server redirect calls and forward to internal clone of function. void printCompactTreeHook(ostream& os, const char* indent = """"); Catch print hook function and forward to function clone. void constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); Driver function to propagate constant term optimizations in test statistic.; If code Activate is sent, constant term optimization will be executed.; If code Deacivate is sent, any existing constant term optimizations will; be abanoned. If codes ConfigChange or ValueChange are sent, any existing; constant term optimizations will be redone. void optimizeCaching(); This method changes the value caching logic for all nodes that depends on any of the observables; as defined by the given dataset. When evaluating a test statistic constructed from the RooAbsReal; with a dataset the observables are guaranteed to change with every call, thus there is no point; in tracking these changes which result in a net overhead. Thus for observable-dependent nodes,; the evaluation mechanism is changed from being dependent on a 'valueDirty' flag to guaranteed evaluation.; On the dataset side, the observables objects are modified to no longer send valueDirty messages; to their client. void optimizeConstantTerms(Bool_t ); Driver function to activate global constant term optimization.; If activated constant terms are found and cached with the dataset; The operation mode of cached nodes is set to AClean meaning that; their getVal() call will never result in an evaluate call.; Finally the branches in the dataset that correspond to observables; that are exclusively used in constant terms are disabled as; they serve no more ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAbsOptTestStatistic.html:36403,log,logic,36403,root/html526/RooAbsOptTestStatistic.html,https://root.cern,https://root.cern/root/html526/RooAbsOptTestStatistic.html,3,['log'],['logic']
Testability,"oAbsReal.cxx:3146; RooAbsReal::fillTreeBranchvoid fillTreeBranch(TTree &t) overrideFill the tree branch that associated with this object with its current value.Definition RooAbsReal.cxx:3099; RooAbsReal::createIntegralRooFit::OwningPtr< RooAbsReal > createIntegral(const RooArgSet &iset, const RooArgSet &nset, const char *rangeName=nullptr) constCreate integral over observables in iset in range named rangeName with integrand normalized over obse...Definition RooAbsReal.h:211; RooAbsReal::printMultilinevoid printMultiline(std::ostream &os, Int_t contents, bool verbose=false, TString indent="""") const overrideStructure printing.Definition RooAbsReal.cxx:455; RooAbsReal::plotAsymOnvirtual RooPlot * plotAsymOn(RooPlot *frame, const RooAbsCategoryLValue &asymCat, PlotOpt o) constDefinition RooAbsReal.cxx:2199; RooAbsReal::operator==bool operator==(double value) constEquality operator comparing to a double.Definition RooAbsReal.cxx:250; RooAbsReal::evalErrorLoggingModestatic ErrorLoggingMode evalErrorLoggingMode()Return current evaluation error logging mode.Definition RooAbsReal.cxx:4302; RooAbsReal::redirectServersHookbool redirectServersHook(const RooAbsCollection &newServerList, bool mustReplaceAll, bool nameChange, bool isRecursiveStep) overrideFunction that is called at the end of redirectServers().Definition RooAbsReal.cxx:4474; RooAbsReal::minTrialSamplesvirtual Int_t minTrialSamples(const RooArgSet &) constDefinition RooAbsReal.h:241; RooAbsReal::isValidRealvirtual bool isValidReal(double, bool printError=false) constInterface function to check if given value is a valid value for this object. Returns true unless over...Definition RooAbsReal.h:447; RooAbsReal::setIntegratorConfigvoid setIntegratorConfig()Remove the specialized numeric integration configuration associated with this object.Definition RooAbsReal.cxx:3346; RooAbsReal::syncCachevoid syncCache(const RooArgSet *set=nullptr) overrideDefinition RooAbsReal.h:456; RooAbsReal::printValuevoid printValue(std::ostr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RooAbsReal_8h_source.html:41188,log,logging,41188,doc/master/RooAbsReal_8h_source.html,https://root.cern,https://root.cern/doc/master/RooAbsReal_8h_source.html,1,['log'],['logging']
Testability,"oAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<string,string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; RooRealProxyk; RooRealProxym0; RooRealProxyx. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooLognormal(const char* name, const char* title, RooAbsReal& _x, RooAbsReal& _m0, RooAbsReal& _k). RooLognormal(const RooLognormal& other, const char* name = 0). Double_t evaluate() const; ln(k)<1 would correspond to sigma < 0 in the parametrization; resulting by transforming a normal random variable in its; standard parametrization to a lognormal random variable; => treat ln(k) as -ln(k) for k<1. Int_t getAnalyticalIntegral(RooArgSet& allVars, RooArgSet& analVars, const char* rangeName = 0) const. Double_t analyticalIntegral(Int_t code, const char* rangeName = 0) const. Int_t getGenerator(const RooArgSet& directVars, RooArgSet& generateVars, Bool_t staticInitOK = kTRUE) const. void generateEvent(Int_t code). RooLognormal(); {}. TObject* clone(const char* newname) const; { return new RooLognormal(*this,newname); }. virtual ~RooLognormal(); { }.  Last changed: Tue Jun 30 14:33:51 2015  Last generated: 2015-06-30 14:33; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooLognormal.html:45398,log,lognormal,45398,root/html602/RooLognormal.html,https://root.cern,https://root.cern/root/html602/RooLognormal.html,1,['log'],['lognormal']
Testability,"oArgSet &nset={}) const; Propagates parameter uncertainties to an uncertainty estimate for this RooAbsReal. ; ; TStringgetTitle (bool appendUnit=false) const; Return this variable's title string. ; ; const Text_t *getUnit () const; ; doublegetVal (const RooArgSet &normalisationSet) const; Like getVal(const RooArgSet*), but always requires an argument for normalisation. ; ; doublegetVal (const RooArgSet *normalisationSet=nullptr) const; Evaluate object. ; ; virtual doublegetValV (const RooArgSet *normalisationSet=nullptr) const; Return value of object. ; ; virtual voidgradient (double *) const; ; virtual boolhasGradient () const; ; virtual boolisBinnedDistribution (const RooArgSet &) const; Tests if the distribution is binned. Unless overridden by derived classes, this always returns false. ; ; boolisIdentical (const RooAbsArg &other, bool assumeSameType=false) const override; ; virtual boolisOffsetting () const; ; boolisSelectedComp () const; If true, the current pdf is a selected component (for use in plotting) ; ; voidlogEvalError (const char *message, const char *serverValueString=nullptr) const; Log evaluation error message. ; ; RooAbsMoment *mean (RooRealVar &obs); ; RooAbsMoment *mean (RooRealVar &obs, const RooArgSet &nset); ; virtual Int_tminTrialSamples (const RooArgSet &) const; ; RooAbsMoment *moment (RooRealVar &obs, const RooArgSet &normObs, Int_t order, bool central, bool takeRoot, bool intNormObs); Return function representing moment of p.d.f (normalized w.r.t given observables) of given order. ; ; RooAbsMoment *moment (RooRealVar &obs, Int_t order, bool central, bool takeRoot); Return function representing moment of function of given order. ; ; virtual doubleoffset () const; ; booloperator== (const RooAbsArg &other) const override; Equality operator when comparing to another RooAbsArg. ; ; booloperator== (double value) const; Equality operator comparing to a double. ; ; virtual RooPlot *plotOn (Ro",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooLegendre.html:14091,log,logEvalError,14091,doc/master/classRooLegendre.html,https://root.cern,https://root.cern/doc/master/classRooLegendre.html,2,['log'],['logEvalError']
Testability,"oArgSet &nset={}) const; Propagates parameter uncertainties to an uncertainty estimate for this RooAbsReal. ; ; TStringgetTitle (bool appendUnit=false) const; Return this variable's title string. ; ; const Text_t *getUnit () const; ; doublegetVal (const RooArgSet &normalisationSet) const; Like getVal(const RooArgSet*), but always requires an argument for normalisation. ; ; doublegetVal (const RooArgSet *normalisationSet=nullptr) const; Evaluate object. ; ; virtual doublegetValV (const RooArgSet *normalisationSet=nullptr) const; Return value of object. ; ; virtual voidgradient (double *) const; ; virtual boolhasGradient () const; ; virtual boolisBinnedDistribution (const RooArgSet &) const; Tests if the distribution is binned. Unless overridden by derived classes, this always returns false. ; ; boolisIdentical (const RooAbsArg &other, bool assumeSameType=false) const override; ; virtual boolisOffsetting () const; ; boolisSelectedComp () const; If true, the current pdf is a selected component (for use in plotting) ; ; voidlogEvalError (const char *message, const char *serverValueString=nullptr) const; Log evaluation error message. ; ; virtual doublemaxVal (Int_t code) const; Return maximum value for set of observables identified by code assigned in getMaxVal. ; ; RooAbsMoment *mean (RooRealVar &obs); ; RooAbsMoment *mean (RooRealVar &obs, const RooArgSet &nset); ; virtual Int_tminTrialSamples (const RooArgSet &) const; ; RooAbsMoment *moment (RooRealVar &obs, const RooArgSet &normObs, Int_t order, bool central, bool takeRoot, bool intNormObs); Return function representing moment of p.d.f (normalized w.r.t given observables) of given order. ; ; RooAbsMoment *moment (RooRealVar &obs, Int_t order, bool central, bool takeRoot); Return function representing moment of function of given order. ; ; virtual doubleoffset () const; ; booloperator== (const RooAbsArg &other) const override; Equality operator when comparing to ano",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooCFunction1Binding.html:14309,log,logEvalError,14309,doc/master/classRooCFunction1Binding.html,https://root.cern,https://root.cern/doc/master/classRooCFunction1Binding.html,32,['log'],['logEvalError']
Testability,"oArgSet& o); voidRooStats::ToyMCSampler::SetMaxToys(Double_t t); virtual voidRooStats::ToyMCSampler::SetNEventsPerToy(const Int_t nevents); virtual voidRooStats::ToyMCSampler::SetNToys(const Int_t ntoy); virtual voidRooStats::ToyMCSampler::SetNuisanceParameters(const RooArgSet& np); virtual voidRooStats::ToyMCSampler::SetObservables(const RooArgSet& o); virtual voidSetParametersForTestStat(const RooArgSet& nullpoi); virtual voidSetPdf(RooAbsPdf& pdf); virtual voidRooStats::ToyMCSampler::SetPriorNuisance(RooAbsPdf* pdf); voidRooStats::ToyMCSampler::SetProofConfig(RooStats::ProofConfig* pc = NULL); voidRooStats::ToyMCSampler::SetProtoData(const RooDataSet* d); voidSetReuseNLL(bool r = true); virtual voidRooStats::ToyMCSampler::SetSamplingDistName(const char* name); virtual voidRooStats::ToyMCSampler::SetTestSize(Double_t size); virtual voidRooStats::ToyMCSampler::SetTestStatistic(RooStats::TestStatistic* t); virtual voidRooStats::ToyMCSampler::SetTestStatistic(RooStats::TestStatistic* testStatistic, unsigned int i); voidRooStats::ToyMCSampler::SetToysBothTails(Double_t toys, Double_t low_threshold, Double_t high_threshold); voidRooStats::ToyMCSampler::SetToysLeftTail(Double_t toys, Double_t threshold); voidRooStats::ToyMCSampler::SetToysRightTail(Double_t toys, Double_t threshold); voidRooStats::ToyMCSampler::SetUseMultiGen(Bool_t flag); virtual voidShowMembers(TMemberInspector&); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); RooStats::ToyMCImportanceSamplerToyMCImportanceSampler(); RooStats::ToyMCImportanceSamplerToyMCImportanceSampler(const RooStats::ToyMCImportanceSampler&); RooStats::ToyMCImportanceSamplerToyMCImportanceSampler(RooStats::TestStatistic& ts, Int_t ntoys); RooStats::ToyMCSamplerRooStats::ToyMCSampler::ToyMCSampler(); RooStats::ToyMCSamplerRooStats::ToyMCSampler::ToyMCSampler(const RooStats::ToyMCSampler&); RooStats::ToyMCSamplerRooStats::ToyMCSampler::ToyMCSampler(RooStats::TestStatistic& ts, Int_t ntoys).",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooStats__ToyMCImportanceSampler.html:4655,test,testStatistic,4655,root/html534/RooStats__ToyMCImportanceSampler.html,https://root.cern,https://root.cern/root/html534/RooStats__ToyMCImportanceSampler.html,1,['test'],['testStatistic']
Testability,"oArgSet& set); virtual voidSetParameters(RooArgSet& set); virtual voidSetPdf(RooAbsPdf& pdf); virtual voidSetPdf(const char* name); virtual voidSetTestSize(Double_t size); virtual voidSetTestStatistic(RooAbsArg&) const; virtual voidShowMembers(TMemberInspector& insp, char* parent); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); RooStats::ToyMCSamplerToyMCSampler(RooStats::TestStatistic& ts); RooStats::ToyMCSamplerToyMCSampler(const RooStats::ToyMCSampler&). Data Members; private:. Int_tfCountercounter for naming sampling dist objects; const char*fDataNamename of data set in workspace; Bool_tfExtendedif nEvents should fluctuate; RooDataSet*fLastDataSetwork around for memory issues in nllvar->setData(data, noclone); Int_tfNeventsnumber of events per toy (may be ignored depending on settings); Int_tfNtoysnumber of toys to generate; RooArgSet*fNuisParamsRooArgSet specifying nuisance parameters for interval; RooArgSet*fObservablesRooArgSet specifying the observables in the dataset (needed to evaluate the test statistic); Bool_tfOwnsWorkspaceflag if this object owns its workspace; RooArgSet*fPOIRooArgSet specifying parameters of interest for interval; const char*fPdfNamename of common PDF in workspace; TRandom*fRandrandom generator; Double_tfSize; RooStats::TestStatistic*fTestStatpointer to the test statistic that is being sampled; TStringfVarNamename of test statistic; RooWorkspace*fWSa workspace that owns all the components to be used by the calculator. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ToyMCSampler(TestStatistic &ts). virtual ~ToyMCSampler(). SamplingDistribution* AppendSamplingDistribution(RooArgSet& allParameters, RooStats::SamplingDistribution* last, Int_t additionalMC); Extended interface to append to sampling distribution more samples. SamplingDistribution* GetSamplingDistribution(RooArgSet& allParameters); Main interface to get a SamplingDistribution. RooAbsData* GenerateToyData(RooArgS",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooStats__ToyMCSampler.html:3256,test,test,3256,root/html526/RooStats__ToyMCSampler.html,https://root.cern,https://root.cern/root/html526/RooStats__ToyMCSampler.html,3,['test'],['test']
Testability,"oClass(const char* sender_class, const char* signal, TClass* receiver_class, void* receiver, const char* slot); Int_tCopyMacroToCache(const char* macro, Int_t headerRequired = 0, TSelector** selector = 0, Int_t opt = 0, TList* wrks = 0); TSlave*TProof::CreateSlave(const char* url, const char* ord, Int_t perf, const char* image, const char* workdir); TSlave*TProof::CreateSubmaster(const char* url, const char* ord, const char* image, const char* msd, Int_t nwk = 1); Int_tCreateSymLinks(TList* files, TList* wrks = 0); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; TList*TProof::GetEnabledPackages() const; static Bool_tTProof::GetFileInCmd(const char* cmd, TString& fn); static Int_tTProof::GetInputData(TList* input, const char* cachedir, TString& emsg); TList*TProof::GetListOfActiveSlaves() const; TVirtualProofPlayer*TProof::GetPlayer() const; TPluginHandler*TProof::GetProgressDialog() const; Int_tTProof::GetSandbox(TString& sb, Bool_t assert = kFALSE, const char* rc = 0); virtual void*TQObject::GetSender(); virtual const char*TQObject::GetSenderClassName() const; voidTProof::HandleLibIncPath(const char* what, Bool_t add, const char* dirs); Int_tTProof::HandleOutputOptions(TString& opt, TString& target, Int_t action); Int_tInit(const char* masterurl, const char* conffile, const char* confdir, Int_t loglevel, const char* alias = 0); voidTProof::InitMembers(); virtual TVirtualProofPlayer*TProof::MakePlayer(const char* player = 0, TSocket* s = 0); TProofQueryResult*MakeQueryResult(Long64_t nent, const char* opt, Long64_t fst, TDSet* dset, const char* selec); voidTObject::MakeZombie(); virtual Int_tPollForNewWorkers(); voidTProof::PrepareInputDataFile(TString& dataFile); Int_tTProof::RemoveWorkers(TList* wrks); static Int_tTProof::SaveInputData(TQueryResult* qr, const char* cachedir, TString& emsg); virtual voidTProof::SaveWorkerInfo(); Int_tTProof::SendFile(const char* file, Int_t opt = (kBinary | kForward | kCp | kCpBin), ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TProofLite.html:21376,assert,assert,21376,root/html604/TProofLite.html,https://root.cern,https://root.cern/root/html604/TProofLite.html,1,['assert'],['assert']
Testability,"oCone(const char* name, Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2); Default constructor specifying minimum and maximum radius. TGeoCone(Double_t* params); Default constructor specifying minimum and maximum radius; param[0] = dz; param[1] = Rmin1; param[2] = Rmax1; param[3] = Rmin2; param[4] = Rmax2. Double_t Capacity() const; Computes capacity of the shape in [length^3]. Double_t Capacity(Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2); Computes capacity of the shape in [length^3]. ~TGeoCone(); destructor. void ComputeBBox(); compute bounding box of the sphere. void ComputeNormal(const Double_t* point, const Double_t* dir, Double_t* norm); Compute normal to closest surface from POINT. void ComputeNormalS(const Double_t* point, const Double_t* dir, Double_t* norm, Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2); Compute normal to closest surface from POINT. Bool_t Contains(const Double_t* point) const; test if point is inside this cone. Double_t DistFromInsideS(const Double_t* point, const Double_t* dir, Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2); Compute distance from inside point to surface of the cone (static); Boundary safe algorithm. Double_t DistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from inside point to surface of the cone; Boundary safe algorithm. Double_t DistFromOutsideS(const Double_t* point, const Double_t* dir, Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2); Compute distance from outside point to surface of the tube; Boundary safe algorithm.; compute distance to Z planes. Double_t DistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from outside point to surface of the tube; compute safe radius.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoCone.html:14700,test,test,14700,root/html534/TGeoCone.html,https://root.cern,https://root.cern/root/html534/TGeoCone.html,3,['test'],['test']
Testability,"oContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. private:. TStopwatch_cumulTimer; TMatrixDSym*_extV; RooMinimizerFcn*_fcn; RooAbsReal*_func; string_minimizerType; Bool_t_optConst; Int_t_printLevel; Bool_t_profile; Bool_t_profileStart; Int_t_status; vector<pair<string,int> >_statusHistory; static ROOT::Fit::Fitter*_theFitter; TStopwatch_timer; Bool_t_verbose. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void cleanup(); Cleanup method called by atexit handler installed by RooSentinel; to delete all global heap objects when the program is terminated. RooMinimizer(RooAbsReal& function); Construct MINUIT interface to given function. Function can be anything,; but is typically a -log(likelihood) implemented by RooNLLVar or a chi^2; (implemented by RooChi2Var). Other frequent use cases are a RooAddition; of a RooNLLVar plus a penalty or constraint term. This class propagates; all RooFit information (floating parameters, their values and errors); to MINUIT before each MINUIT call and propagates all MINUIT information; back to the RooFit object at the end of each call (updated parameter; values, their (asymmetric errors) etc. The default MINUIT error level; for HESSE and MINOS error analysis is taken from the defaultErrorLevel(); value of the input function. ~RooMinimizer(); Destructor. void setStrategy(Int_t strat); Change MINUIT strategy to istrat. Accepted codes; are 0,1,2 and represent MINUIT strategies for dealing; most efficiently with fast FCNs (0), expensive FCNs (2); and 'intermediate' FCNs (1). void setMaxIterations(Int_t n); Change maximum number of MINUIT iterations; (RooMinimizer default 500 * #parameters). void setMaxFunctionCalls(Int_t n); Change maximum number of l",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooMinimizer.html:8921,log,log,8921,root/html602/RooMinimizer.html,https://root.cern,https://root.cern/root/html602/RooMinimizer.html,2,['log'],['log']
Testability,"oFTest::PValueAD2Samples. . KolmogorovSmirnov2SamplesTest() [1/2]. Double_t ROOT::Math::GoFTest::KolmogorovSmirnov2SamplesTest ; (; const Char_t *; option = ""p""); const. Kolmogorov-Smirnov 2-Samples Test. ; Returns by default the p-value; option ""t"" returns the test statistic value ""Dn"". ; Definition at line 913 of file GoFTest.cxx. KolmogorovSmirnov2SamplesTest() [2/2]. void ROOT::Math::GoFTest::KolmogorovSmirnov2SamplesTest ; (; Double_t &; pvalue, . Double_t &; testStat. ); const. Kolmogorov-Smirnov 2-Samples Test. ; The Kolmogorov-Smirnov 2-Samples Test algorithm is described at http://www.itl.nist.gov/div898/software/dataplot/refman1/auxillar/ks2samp.htm and described and taken from https://root.cern/doc/master/namespaceTMath.html ; Definition at line 896 of file GoFTest.cxx. KolmogorovSmirnovTest() [1/2]. Double_t ROOT::Math::GoFTest::KolmogorovSmirnovTest ; (; const Char_t *; option = ""p""); const. Kolmogorov-Smirnov 1-Sample Test. ; Returns default p-value; option ""t"" returns the test statistic value ""Dn"". ; Definition at line 945 of file GoFTest.cxx. KolmogorovSmirnovTest() [2/2]. void ROOT::Math::GoFTest::KolmogorovSmirnovTest ; (; Double_t &; pvalue, . Double_t &; testStat. ); const. Kolmogorov-Smirnov 1-Sample Test. ; The Kolmogorov-Smirnov 1-Sample Test algorithm for a specific distribution is described at http://www.itl.nist.gov/div898/software/dataplot/refman1/auxillar/kstest.htm and described and taken from (4) Press W. H., Teukolsky S.A., Vetterling W.T., Flannery B.P. (2007), Numerical Recipes - The Art of Scientific Computing (Third Edition), Cambridge University Press ; Definition at line 921 of file GoFTest.cxx. LogNormalCDF(). Double_t ROOT::Math::GoFTest::LogNormalCDF ; (; Double_t; x); const. private . LogSample(). void ROOT::Math::GoFTest::LogSample ; (; ). private . Applies the logarithm to the sample when the specified distribution to test is LogNormal. ; Definition at line 303 of file GoFTest.cxx. operator()() [1/2]. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1GoFTest.html:15220,test,test,15220,doc/master/classROOT_1_1Math_1_1GoFTest.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1GoFTest.html,1,['test'],['test']
Testability,"oFit warning message (which go straight through RooMsgService) because evaluation errors can occur in very large numbers in the use of likelihood evaluations. In logEvalError mode, controlled by global method enableEvalErrorLogging() messages reported through this function are not printed but all stored in a list, along with server values at the time of reporting. Error messages logged in this way can be printed in a structured way, eliminating duplicates and with the ability to truncate the list by printEvalErrors. This is the standard mode of error logging during MINUIT operations. If enableEvalErrorLogging() is false, all errors reported through this method are passed for immediate printing through RooMsgService. A string with server names and values is constructed automatically for error logging purposes, unless a custom string with similar information is passed as argument. ; Definition at line 3464 of file RooAbsReal.cxx. logEvalError() [2/2]. void RooAbsReal::logEvalError ; (; const RooAbsReal *; originator, . const char *; origName, . const char *; message, . const char *; serverValueString = nullptr. ). static . Interface to insert remote error logging messages received by RooRealMPFE into current error logging stream. ; Definition at line 3408 of file RooAbsReal.cxx. makeProjectionSet(). void RooAbsReal::makeProjectionSet ; (; const RooAbsArg *; plotVar, . const RooArgSet *; allVars, . RooArgSet &; projectedVars, . bool; silent. ); const. protected . Utility function for plotOn() that constructs the set of observables to project when plotting ourselves as function of 'plotVar'. ; 'allVars' is the list of variables that must be projected, but may contain variables that we do not depend on. If 'silent' is cleared, warnings about inconsistent input parameters will be printed. ; Definition at line 2903 of file RooAbsReal.cxx. matchArgs() [1/5]. bool RooAbsReal::matchArgs ; (; const RooArgSet &; allDeps, . RooArgSet &; analDeps, . const RooArg",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsReal.html:121017,log,logEvalError,121017,doc/master/classRooAbsReal.html,https://root.cern,https://root.cern/doc/master/classRooAbsReal.html,1,['log'],['logEvalError']
Testability,"oFit warning message (which go straight through RooMsgService) because evaluation errors can occur in very large numbers in the use of likelihood evaluations. In logEvalError mode, controlled by global method enableEvalErrorLogging() messages reported through this function are not printed but all stored in a list, along with server values at the time of reporting. Error messages logged in this way can be printed in a structured way, eliminating duplicates and with the ability to truncate the list by printEvalErrors. This is the standard mode of error logging during MINUIT operations. If enableEvalErrorLogging() is false, all errors reported through this method are passed for immediate printing through RooMsgService. A string with server names and values is constructed automatically for error logging purposes, unless a custom string with similar information is passed as argument. ; Definition at line 3545 of file RooAbsReal.cxx. logEvalError() [2/2]. void RooAbsReal::logEvalError ; (; const RooAbsReal *; originator, . const char *; origName, . const char *; message, . const char *; serverValueString = nullptr. ). static . Interface to insert remote error logging messages received by RooRealMPFE into current error logging stream. ; Definition at line 3490 of file RooAbsReal.cxx. makeProjectionSet(). void RooAbsReal::makeProjectionSet ; (; const RooAbsArg *; plotVar, . const RooArgSet *; allVars, . RooArgSet &; projectedVars, . bool; silent. ); const. protected . Utility function for plotOn() that constructs the set of observables to project when plotting ourselves as function of 'plotVar'. ; 'allVars' is the list of variables that must be projected, but may contain variables that we do not depend on. If 'silent' is cleared, warnings about inconsistent input parameters will be printed. ; Definition at line 2988 of file RooAbsReal.cxx. matchArgs() [1/5]. bool RooAbsReal::matchArgs ; (; const RooArgSet &; allDeps, . RooArgSet &; analDeps, . const RooArg",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classRooAbsReal.html:122347,log,logEvalError,122347,doc/v632/classRooAbsReal.html,https://root.cern,https://root.cern/doc/v632/classRooAbsReal.html,1,['log'],['logEvalError']
Testability,"oManager *manager);; 80 ~TGeoPainter() override;; 81 ; 82 void AddSize3D(Int_t numpoints, Int_t numsegs, Int_t numpolys) override;; 83 TVirtualGeoTrack *AddTrack(Int_t id, Int_t pdgcode, TObject *part) override;; 84 void AddTrackPoint(Double_t *point, Double_t *box, Bool_t reset = kFALSE) override;; 85 void BombTranslation(const Double_t *tr, Double_t *bombtr) override;; 86 void CheckBoundaryErrors(Int_t ntracks = 1000000, Double_t radius = -1.) override;; 87 void CheckBoundaryReference(Int_t icheck = -1) override;; 88 void CheckGeometryFull(Bool_t checkoverlaps = kTRUE, Bool_t checkcrossings = kTRUE, Int_t nrays = 10000,; 89 const Double_t *vertex = nullptr) override;; 90 void CheckGeometry(Int_t nrays, Double_t startx, Double_t starty, Double_t startz) const override;; 91 void CheckEdit();; 92 void CheckPoint(Double_t x = 0, Double_t y = 0, Double_t z = 0, Option_t *option = """", Double_t safety = 0.) override;; 93 void CheckShape(TGeoShape *shape, Int_t testNo, Int_t nsamples, Option_t *option) override;; 94 void CheckOverlaps(const TGeoVolume *vol, Double_t ovlp = 0.1, Option_t *option = """") const override;; 95 Int_t CountNodes(TGeoVolume *vol, Int_t level) const;; 96 Int_t CountVisibleNodes() override;; 97 void DefaultAngles() override;; 98 void DefaultColors() override;; 99 Int_t DistanceToPrimitiveVol(TGeoVolume *vol, Int_t px, Int_t py) override;; 100 void Draw(Option_t *option = """") override;; 101 void DrawBatemanSol(TGeoBatemanSol *sol, Option_t *option = """") override;; 102 void DrawOverlap(void *ovlp, Option_t *option = """") override;; 103 void DrawCurrentPoint(Int_t color) override;; 104 void DrawOnly(Option_t *option = """") override;; 105 void DrawPanel() override;; 106 void DrawPath(const char *path, Option_t *option = """") override;; 107 void DrawPolygon(const TGeoPolygon *poly) override;; 108 void DrawShape(TGeoShape *shape, Option_t *option = """") override;; 109 void DrawVolume(TGeoVolume *vol, Option_t *option = """") override;; 110 void EditGeometry(Opti",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGeoPainter_8h_source.html:4096,test,testNo,4096,doc/master/TGeoPainter_8h_source.html,https://root.cern,https://root.cern/doc/master/TGeoPainter_8h_source.html,1,['test'],['testNo']
Testability,"oMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); Int_tminDimNormValueCaching() const; virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tmustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); const char*normRange() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TNamed&TNamed::operator=(const TNamed& rhs); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*paramOn(RooPlot* frame, const RooAbsData* data, const char* label = """", Int_t sigDigits = 2, Option_t* options = ""NELU"", Double_t xmin = 0.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooAbsPdf.html:25033,test,testArg,25033,root/html528/RooAbsPdf.html,https://root.cern,https://root.cern/root/html528/RooAbsPdf.html,1,['test'],['testArg']
Testability,"oRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tRooAbsPdf::mustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; virtual voidRooResolutionModel::normLeafServerList(RooArgSet& list) const; const char*RooAbsPdf::normRange() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TNamed&TNamed::operator=(const TNamed& rhs); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsPdf::paramOn(RooPlot* frame, const RooAbsData* data, const char* label = """", Int_t sigDigits = 2, Option_t* options = ""NELU"", Double_t xmin = 0.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAddModel.html:24927,test,testArg,24927,root/html534/RooAddModel.html,https://root.cern,https://root.cern/root/html534/RooAddModel.html,4,['test'],['testArg']
Testability,"oStats::ModelConfig&); voidSetNBins(Int_t bins); virtual voidSetNuisanceParameters(const RooArgSet&); voidSetParameterPointsToTest(RooAbsData& pointsToTest); virtual voidSetParameters(const RooArgSet&); virtual voidSetPdf(RooAbsPdf&); voidSetPOIPointsToTest(RooAbsData& poiToTest); virtual voidSetTestSize(Double_t size); virtual voidShowMembers(TMemberInspector& insp); virtual Double_tSize() const; virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); voidUseAdaptiveSampling(bool flag = true). private:. voidCreateParameterPoints() const; voidCreateTestStatSampler() const. Data Members; private:. Bool_tfAdaptiveSamplingcontrols use of adaptive sampling algorithm; Double_tfAdditionalNToysFactorgive user ability to ask for more toys; RooStats::ConfidenceBelt*fConfBelt; Bool_tfCreateBeltcontrols use if ConfidenceBelt should be saved to a TFile; RooAbsData&fDatadata set ; Bool_tfDoProfileConstructioninstead of full construction over nuisance parametrs, do profile; Bool_tfFluctuateDatatell ToyMCSampler to fluctuate number of entries in dataset; RooStats::ModelConfig&fModel; Int_tfNbinsnumber of samples per variable; RooAbsData*fPOIToTestvalue of POI points to perform the construction; RooAbsData*fPointsToTestpoints to perform the construction; Bool_tfSaveBeltToFilecontrols use if ConfidenceBelt should be saved to a TFile; Double_tfSizesize of the test (eg. specified rate of Type I error); RooStats::ToyMCSampler*fTestStatSamplerthe test statistic sampler. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; FeldmanCousins(RooAbsData& data, RooStats::ModelConfig& model); standard constructor. ~FeldmanCousins(); destructor; if(fOwnsWorkspace && fWS) delete fWS;. void SetModel(const RooStats::ModelConfig& ); set the model. TestStatSampler* GetTestStatSampler() const. void CreateTestStatSampler() const; specify the Test Statistic and create a ToyMC test statistic sampler. void CreateParameterPoints() const; specify the paramet",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooStats__FeldmanCousins.html:3884,test,test,3884,root/html530/RooStats__FeldmanCousins.html,https://root.cern,https://root.cern/root/html530/RooStats__FeldmanCousins.html,2,['test'],['test']
Testability,"oTubeSeg; kGeoCone; kGeoConeSeg; kGeoPcon; kGeoPgon; kGeoArb8; kGeoEltu; kGeoTrap; kGeoCtub; kGeoTrd1; kGeoTrd2; kGeoComb; kGeoClosedShape; kGeoXtru; kGeoParaboloid; kGeoHalfSpace; kGeoHype; kGeoSavePrimitive; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TStringTNamed::fNameobject identifier; UInt_tfShapeBitsshape bits; Int_tfShapeIdshape id; TStringTNamed::fTitleobject title. private:. static Double_tfgEpsMchMachine round-off error; static TGeoMatrix*fgTransformcurrent transformation matrix that applies to shape. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~TGeoShape(); Destructor. void CheckShape(Int_t testNo, Int_t nsamples = 10000, Option_t* option = """"); Test for shape navigation methods. Summary for test numbers:; 1: DistFromInside/Outside. Sample points inside the shape. Generate; directions randomly in cos(theta). Compute DistFromInside and move the; point with bigger distance. Compute DistFromOutside back from new point.; Plot d-(d1+d2). Double_t ComputeEpsMch(); Compute machine round-off double precision error as the smallest number that; if added to 1.0 is different than 1.0. Double_t EpsMch(); static function returning the machine round-off error. const char * GetName() const; Get the shape name. Int_t ShapeDistancetoPrimitive(Int_t numpoints, Int_t px, Int_t py) const; Returns distance to shape primitive mesh. Bool_t IsCloseToPhi(Double_t epsil, Double_t* point, Double_t c1, Double_t s1, Double_t c2, Double_t s2); True if point is closer than epsil to one of the phi planes defined by c1,s1 or c2,s2. Bool_t IsInPhiRange(Double_t* point, Double_t phi1, Double_t phi2); Static method to check if a point is in the phi range (phi1, phi2) [degrees]. Bool_t IsCrossingSemiplane(Double_t* point, D",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TGeoShape.html:16157,test,test,16157,root/html530/TGeoShape.html,https://root.cern,https://root.cern/root/html530/TGeoShape.html,2,['test'],['test']
Testability,"oTubeSeg; kGeoCone; kGeoConeSeg; kGeoPcon; kGeoPgon; kGeoArb8; kGeoEltu; kGeoTrap; kGeoCtub; kGeoTrd1; kGeoTrd2; kGeoComb; kGeoClosedShape; kGeoXtru; kGeoParaboloid; kGeoHalfSpace; kGeoHype; kGeoSavePrimitive; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TStringTNamed::fNameobject identifier; UInt_tfShapeBitsshape bits; Int_tfShapeIdshape id; TStringTNamed::fTitleobject title. private:. static Double_tfgEpsMchMachine round-off error; static TGeoMatrix*fgTransformcurrent transformation matrix that applies to shape. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~TGeoShape(); Destructor. void CheckShape(Int_t testNo, Int_t nsamples = 10000, Option_t* option = """"); Test for shape navigation methods. Summary for test numbers:; 1: DistFromInside/Outside. Sample points inside the shape. Generate; directions randomly in cos(theta). Compute DistFromInside and move the; point with bigger distance. Compute DistFromOutside back from new point.; Plot d-(d1+d2). Double_t ComputeEpsMch(); Compute machine round-off double precision error as the smallest number that; if added to 1.0 is different than 1.0. Double_t EpsMch(); static function returning the machine round-off error. const char * GetName() const; Get the shape name. Int_t ShapeDistancetoPrimitive(Int_t numpoints, Int_t px, Int_t py) const; Returns distance to shape primitive mesh. Bool_t IsCloseToPhi(Double_t epsil, const Double_t* point, Double_t c1, Double_t s1, Double_t c2, Double_t s2); True if point is closer than epsil to one of the phi planes defined by c1,s1 or c2,s2. Bool_t IsInPhiRange(const Double_t* point, Double_t phi1, Double_t phi2); Static method to check if a point is in the phi range (phi1, phi2) [degrees]. Bool_t IsCrossingSemiplane(const ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoShape.html:16942,test,test,16942,root/html534/TGeoShape.html,https://root.cern,https://root.cern/root/html534/TGeoShape.html,1,['test'],['test']
Testability,oats; TArrayI Array of ints; TArrayL Array of longs; TArrayL64 Array of long64s; TArrayS Array of shorts; TArrow An arrow (line with a arrowhead); TArrowEditor GUI for editing arrow attributes; TAtomicCount ; TAtt3D 3D attributes; TAttAxis Axis attributes; TAttBBox Helper for management of bounding-box information; TAttCanvas Canvas attributes; TAttFill Fill area attributes; TAttFillEditor GUI for editing fill attributes; TAttImage Image attributes; TAttLine Line attributes; TAttLineEditor GUI for editing line attributes; TAttMarker Marker attributes; TAttMarkerEditor GUI for editing marker attributes; TAttPad Pad attributes; TAttParticle Particle definition; TAttText Text attributes; TAttTextEditor GUI for editing text attributes; TAuthenticate Class providing remote authentication service; TAxis Axis class; TAxis3D 3-D ruler painting class; TAxisEditor axis editor; TBRIK TBRIK shape; TBackCompFitter Class providing backward compatibility for fitting by implementing the TVirtualFitter interface; TBase64 Base64 encoding/decoding; TBaseClass Description of a base class; TBasket the TBranch buffers; TBasketSQL the TBranch buffers; TBenchmark ROOT utility to help benchmarking applications; TBinomialEfficiencyFitter Binomial Fitter for the division of two histograms; TBits Bit container; TBits::TReference ; TBox Box class; TBranch Branch descriptor; TBranchClones Branch in case of an array of clone objects; TBranchElement Branch in case of an object; TBranchObject Branch in case of an object; TBranchRef to support referenced objects on other branches; TBranchSTL Branch handling STL collection of pointers; TBrowser ROOT Object Browser; TBrowserImp ABC describing browser implementation protocol; TBrowserPlugin basic plugin description class; TBtree A B-tree; TBtreeIter B-tree iterator; TBuffer Buffer base class used for serializing objects; TBuffer3D 3D primitives description; TBufferFile concrete implementation of TBuffer for writing/reading to/from a ROOT file or socket.,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html524/ClassIndex.html:48215,benchmark,benchmarking,48215,root/html524/ClassIndex.html,https://root.cern,https://root.cern/root/html524/ClassIndex.html,3,['benchmark'],['benchmarking']
Testability,obBase.cxx; TQpProbDens.cxx; TQpProbSparse.cxx; TQpResidual.cxx; TQpSolverBase.cxx; TQpVar.cxx; rtools; inc; Math; RMinimizer.h; src; RMinimizer.cxx; smatrix; inc; Math; BinaryOperators.h; BinaryOpPolicy.h; CholeskyDecomp.hHeader file containing the templated implementation of matrix inversion routines for use with ROOT's SMatrix classes (symmetric positive definite case) ; CramerInversion.icc; CramerInversionSym.icc; Dfact.h; Dfactir.h; Dfinv.h; Dinv.h; Dsfact.h; Dsinv.h; Expression.h; Functions.h; HelperOps.h; MatrixFunctions.h; MatrixInversion.icc; MatrixRepresentationsStatic.h; MConfig.h; SMatrix.h; SMatrix.icc; SMatrixDfwd.h; SMatrixFfwd.h; StaticCheck.h; SVector.h; SVector.icc; UnaryOperators.h; LinkDefAll.h; LinkDefD32.h; src; Dict.h; test; kalman.C; matrix_op.h; matrix_util.h; matrixOperations.C; stressKalman.cxx; stressOperations.cxx; testInversion.cxx; testIO.cxx; testKalman.cxx; testOperations.cxx; testSMatrix.cxx; TestTimer.h; Track.h; TrackLinkDef.h; splot; inc; TSPlot.h; src; TSPlot.cxx; unuran; inc; TUnuran.h; TUnuranBaseDist.h; TUnuranContDist.h; TUnuranDiscrDist.h; TUnuranEmpDist.h; TUnuranMultiContDist.h; TUnuranSampler.h; src; TUnuran.cxx; TUnuranContDist.cxx; TUnuranDiscrDist.cxx; TUnuranEmpDist.cxx; TUnuranMultiContDist.cxx; TUnuranSampler.cxx; UnuranDistr.h; UnuranDistrAdapter.h; UnuranRng.h; test; unuranDiscrete.cxx; unuranDistr.cxx; unuranHist.cxx; unuranMulti2D.cxx; unuranMultiDim.cxx; unuranSimple.cxx; misc; memstat; inc; TMemStat.h; TMemStatBacktrace.h; TMemStatDef.h; TMemStatHelpers.h; TMemStatHook.h; TMemStatMng.h; src; TMemStat.cxx; TMemStatBacktrace.cxx; TMemStatHelpers.cxx; TMemStatHook.cxx; TMemStatMng.cxx; test; leak_test.C; run.C; table; inc; tableDescriptor.h; TCernLib.h; TChair.h; TColumnView.h; TDataSet.h; TDataSetIter.h; TDsKey.h; TFileIter.h; TFileSet.h; TGenericT,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v610/files.html:55935,test,testSMatrix,55935,doc/v610/files.html,https://root.cern,https://root.cern/doc/v610/files.html,1,['test'],['testSMatrix']
Testability,"obSum values.; output; - return value nq (<=nprobSum) with the number of quantiles computed; - array q filled with nq quantiles. Getting quantiles from two histograms and storing results in a TGraph,; a so-called QQ-plot. TGraph *gr = new TGraph(nprob);; f1->GetQuantiles(nprob,gr->GetX());; f2->GetQuantiles(nprob,gr->GetY());; gr->Draw(""alp"");. Double_t GetRandom(); Return a random number following this function shape. The distribution contained in the function fname (TF1) is integrated; over the channel contents.; It is normalized to 1.; For each bin the integral is approximated by a parabola.; The parabola coefficients are stored as non persistent data members; Getting one random number implies:; - Generating a random number between 0 and 1 (say r1); - Look in which bin in the normalized integral r1 corresponds to; - Evaluate the parabolic curve in the selected bin to find; the corresponding X value.; if the ratio fXmax/fXmin > fNpx the integral is tabulated in log scale in x; The parabolic approximation is very good as soon as the number; of bins is greater than 50. Double_t GetRandom(Double_t xmin, Double_t xmax); Return a random number following this function shape in [xmin,xmax]. The distribution contained in the function fname (TF1) is integrated; over the channel contents.; It is normalized to 1.; For each bin the integral is approximated by a parabola.; The parabola coefficients are stored as non persistent data members; Getting one random number implies:; - Generating a random number between 0 and 1 (say r1); - Look in which bin in the normalized integral r1 corresponds to; - Evaluate the parabolic curve in the selected bin to find; the corresponding X value.; The parabolic approximation is very good as soon as the number; of bins is greater than 50. IMPORTANT NOTE; The integral of the function is computed at fNpx points. If the function; has sharp peaks, you should increase the number of points (SetNpx); such that the peak is correctly tabulated at severa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TF1.html:46233,log,log,46233,root/html528/TF1.html,https://root.cern,https://root.cern/root/html528/TF1.html,6,['log'],['log']
Testability,"objective function; and the fitter class have not been deleted.; To be used only after fitting.; The pointer should not be stored and will be invalided after performing a new fitting.; In this case a new instance of ROOT::Math::Minimizer will be re-created and can be; obtained calling again GetMinimizer(). { return fMinimizer.get(); }. ROOT::Math::IMultiGenFunction * GetFCN() const. return pointer to last used objective function; (is NULL in case fit is not yet done); This pointer will be valid as far as the data and the fitter class; have not been deleted. To be used after the fitting.; The pointer should not be stored and will be invalided after performing a new fitting.; In this case a new instance of the function pointer will be re-created and can be; obtained calling again GetFCN(). { return fObjFunction.get(); }. bool ApplyWeightCorrection(const ROOT::Math::IMultiGenFunction& loglw2). apply correction in the error matrix for the weights for likelihood fits; This method can be called only after a fit and it assumes now that the; passed function (loglw2) is a log-likelihood function impelemented using the; sum of weight squared. bool DoLinearFit(const ROOT::Fit::BinData& data); linear least square fit. bool DoInitMinimizer(); initialize the minimizer. bool DoMinimization(const ROOT::Fit::Fitter::BaseFunc& f, const ROOT::Math::IMultiGenFunction* chifunc = 0); do minimization. bool DoMinimization(const ROOT::Math::IMultiGenFunction* chifunc = 0); do minimization after having set obj function. void DoUpdateFitConfig(); update config after fit. int GetNCallsFromFCN(); get function calls from the FCN.  Author: L. Moneta Wed Aug 30 11:05:19 2006  Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *;  Last changed: root/mathcore:$Id: Fitter.h 39382 2011-05-26 08:31:43Z moneta $  Last generated: 2011-07-04 15:19; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/ROOT__Fit__Fitter.html:12411,log,log-likelihood,12411,root/html530/ROOT__Fit__Fitter.html,https://root.cern,https://root.cern/root/html530/ROOT__Fit__Fitter.html,1,['log'],['log-likelihood']
Testability,"observables, int order=1, std::vector< double > const &observableValues={}, double eps1=1e-6, double eps2=1e-3); Taylor expanding given function in terms of observables around observableValues. ; ; Static Public Member Functions inherited from RooAbsReal; static TClass *Class (); ; static const char *Class_Name (); ; static constexpr Version_tClass_Version (); ; static voidclearEvalErrorLog (); Clear the stack of evaluation error messages. ; ; static const char *DeclFileName (); ; static RooNumIntConfig *defaultIntegratorConfig (); Returns the default numeric integration configuration for all RooAbsReals. ; ; static std::map< constRooAbsArg *, std::pair< std::string, std::list< RooAbsReal::EvalError > > >::iteratorevalErrorIter (); ; static ErrorLoggingModeevalErrorLoggingMode (); Return current evaluation error logging mode. ; ; static boolhideOffset (); ; static voidlogEvalError (const RooAbsReal *originator, const char *origName, const char *message, const char *serverValueString=nullptr); Interface to insert remote error logging messages received by RooRealMPFE into current error logging stream. ; ; static Int_tnumEvalErrorItems (); ; static Int_tnumEvalErrors (); Return the number of logged evaluation errors since the last clearing. ; ; static voidprintEvalErrors (std::ostream &os=std::cout, Int_t maxPerNode=10000000); Print all outstanding logged evaluation error on the given ostream. ; ; static voidsetEvalErrorLoggingMode (ErrorLoggingMode m); Set evaluation error logging mode. ; ; static voidsetHideOffset (bool flag); ; Static Public Member Functions inherited from RooAbsArg; static voidsetDirtyInhibit (bool flag); Control global dirty inhibit mode. ; ; static voidverboseDirty (bool flag); Activate verbose messaging related to dirty flag propagation. ; ; Static Public Member Functions inherited from TNamed; static TClass *Class (); ; static const char *Class_Name (); ; static constexpr Version_tClass_Versi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooPolyFunc.html:46749,log,logEvalError,46749,doc/master/classRooPolyFunc.html,https://root.cern,https://root.cern/doc/master/classRooPolyFunc.html,3,['log'],"['logEvalError', 'logging']"
Testability,"ocal machine. Then after making the commit, we pushed the change to origin. Optionally, we can pull down the last changes from upstream and rebase our branch onto the current master and force-push this to origin. After this, we create a pull request on GitHub from origin. It is important to note that it is not necessary to fork and clone for each contribution.; Merging a pull request locally; If the pull request does not have any conflicts with the master branch, it is possible to apply the changes locally by downloading a patch and piping it to git am with; wget -qO- https://github.com/root-project/root/pull/<PR#>.patch | git am; If you have conflicts, the preferred method is to rebase your branch onto master:; git remote update && git checkout master && git pull && git rebase master <your branch>; When a conflict exists with a commit, git will interrupt the rebase and let you resolve them by editing your files. Once the conflict is resolved, use; git add <conflicting files> && git rebase --continue; to continue the rebasing process. After all conflicts have been resolved, you can check that your changes are really what you want with git log -p master..<your branch> then push the result (without using --force).; Resources. Git How Tos; Git Tips and Tricks; GitHub and Git Foundations (YouTube). Sitemap. DownloadDownload ROOT; All Releases. DocumentationReference Manual; User's Guides; HowTo; Courses; Building ROOT; Tutorials; Javascript Root; ROOT and Spark; Publications; FAQ. NewsBlog; Workshops. SupportForum; Bug submission guidelines; Submit a Bug; Discourse Mailing List Mode; RootTalk Digest. AboutLicence; Contact Us; Project Founders; Team; Previous Developers. DevelopmentProgram of Work; Code Owners; Release Checklist; Coding Conventions; Shifter's Instructions; Git Primer; Browse Sources; Meetings; ROOT 7; Run the tests; Jenkins; Setup externals from AFS/CVMFS; Doxygen; Benchmarks. ContributeCollaborate with Us.  Copyright CERN 2014-18. All rights reserved. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/creating-pull-request.html:5640,log,log,5640,d/creating-pull-request.html,https://root.cern,https://root.cern/d/creating-pull-request.html,2,"['log', 'test']","['log', 'tests']"
Testability,"ocated; and owned by us:. TFile* f1 = new TFile(""myfile_original.root"");; TTree* t1 = (TTree*) f->Get(""MyTree"");; TFile* f2 = new TFile(""myfile_copy.root"", ""recreate"");; TTree* t2 = t1->Clone(0);; for (Int_t i = 0; i < 10; ++i) {; t1->GetEntry(i);; t2->Fill();; }; t2->Write(); delete f2;; f2 = 0;; delete f1;; f1 = 0;. An example of a branch with an object allocated by us,; but owned by the caller:. TFile* f = new TFile(""myfile.root"", ""recreate"");; TTree* t = new TTree(""t"", ""A test tree.""); Event* event = 0;; TBranchElement* br = t->Branch(""event."", &event);; for (Int_t i = 0; i < 10; ++i) {; ... Fill event with meaningful data in some way.; t->Fill();; }; t->Write();; delete event;; event = 0;; delete f;; f = 0;. Notice that the only difference between this example; and the following example is that the event pointer; is zero when the branch is created. An example of a branch with an object allocated and; owned by the caller:. TFile* f = new TFile(""myfile.root"", ""recreate"");; TTree* t = new TTree(""t"", ""A test tree.""); Event* event = new Event();; TBranchElement* br = t->Branch(""event."", &event);; for (Int_t i = 0; i < 10; ++i) {; ... Fill event with meaningful data in some way.; t->Fill();; }; t->Write();; delete event;; event = 0;; delete f;; f = 0;. If AutoDelete is on (see TBranch::SetAutoDelete),; the top level objet will be deleted and recreate; each time an entry is read, whether or not the; TTree owns the object. void SetBasketSize(Int_t buffsize); -- Reset the basket size for all sub-branches of this branch element. void SetBranchCount(TBranchElement* bre); -- Set the branch counter for this branch. Bool_t SetMakeClass(Bool_t decomposeObj = kTRUE); Set the branch in a mode where the object are decomposed; (Also known as MakeClass mode).; Return whether the setting was possible (it is not possible for; TBranch and TBranchObject). void SetObject(void* objadd); Set object this branch is pointing to. void SetOffset(Int_t offset); Set offset of the object (to whi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TBranchElement.html:29353,test,test,29353,root/html528/TBranchElement.html,https://root.cern,https://root.cern/root/html528/TBranchElement.html,6,['test'],['test']
Testability,"ocated; and owned by us:. TFile* f1 = new TFile(""myfile_original.root"");; TTree* t1 = (TTree*) f->Get(""MyTree"");; TFile* f2 = new TFile(""myfile_copy.root"", ""recreate"");; TTree* t2 = t1->Clone(0);; for (Int_t i = 0; i < 10; ++i) {; t1->GetEntry(i);; t2->Fill();; }; t2->Write(); delete f2;; f2 = 0;; delete f1;; f1 = 0;. An example of a branch with an object allocated by us,; but owned by the caller:. TFile* f = new TFile(""myfile.root"", ""recreate"");; TTree* t = new TTree(""t"", ""A test tree.""); Event* event = 0;; TBranchElement* br = t->Branch(""event."", &event);; for (Int_t i = 0; i < 10; ++i) {; ... Fill event with meaningful data in some way.; t->Fill();; }; t->Write();; delete event;; event = 0;; delete f;; f = 0;. Notice that the only difference between this example; and the following example is that the event pointer; is zero when the branch is created. An example of a branch with an object allocated and; owned by the caller:. TFile* f = new TFile(""myfile.root"", ""recreate"");; TTree* t = new TTree(""t"", ""A test tree.""); Event* event = new Event();; TBranchElement* br = t->Branch(""event."", &event);; for (Int_t i = 0; i < 10; ++i) {; ... Fill event with meaningful data in some way.; t->Fill();; }; t->Write();; delete event;; event = 0;; delete f;; f = 0;. If AutoDelete is on (see TBranch::SetAutoDelete),; the top level objet will be deleted and recreate; each time an entry is read, whether or not the; TTree owns the object. void SetBasketSize(Int_t buffsize); -- Reset the basket size for all sub-branches of this branch element. void SetBranchCount(TBranchElement* bre); -- Set the branch counter for this branch. void SetObject(void* objadd); Set object this branch is pointing to. void SetTargetClassName(const char* name); Set the name of the class of the in-memory object into which the data will; loaded. void SetupAddresses(); -- If the branch address is not set, we set all addresses starting with; the top level parent branch. This is required to be done in order for; Ge",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/TBranchElement.html:26086,test,test,26086,root/html526/TBranchElement.html,https://root.cern,https://root.cern/root/html526/TBranchElement.html,1,['test'],['test']
Testability,"ocessAfterFit(Int_t ); Method called after fit has been performed. RooFitResult* refit(RooAbsData* inGenSample = 0); Interface methods to RooMCStudy objects,; which are only functional after module has been attached to a RooMCStudy object. RooAbsData* genSample(); Return generate sample. RooAbsPdf* genModel(); Return generator pdf. RooAbsGenContext* genContext(); Accessor for generator context, generator parameters,	prototype data and projected dependents. RooArgSet* genInitParams(); Return initial value of generator model parameters. RooArgSet* genParams(); Return current value of generator model parameters. const RooDataSet* genProtoData(); Return generator prototype data provided by user. RooArgSet* projDeps(); Return projected observables. RooArgSet* dependents(); Accessors for fit observables, fit model, current and initial fit parameters and NLL value. RooArgSet* allDependents(); Returna all observables. RooAbsPdf* fitModel(); Return fit model. RooArgSet* fitInitParams(); Return initial value of parameters of fit model. RooArgSet* fitParams(); Return current value of parameters of fit model. RooRealVar* nllVar(); Return pointer to RooRealVar holding minimized -log(L) value. const char* fitOptions(); Accessors for fit options, generator annd MCstudy configuration flags. RooLinkedList* fitOptList(); Return list of fit options provided by user. Bool_t extendedGen(); If true extended mode generation is requested. Bool_t binGenData(); If true binning of data between generating and fitting is requested. Double_t numExpGen(); Return expected number of events from generator model. Bool_t randProto(); If true randomization of prototype data order is requested. Bool_t verboseGen(); If true verbose message in the generation step is requested.  Last changed: Thu Sep 23 19:58:12 2010  Last generated: 2010-09-23 19:58; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooAbsMCStudyModule.html:9564,log,log,9564,root/html528/RooAbsMCStudyModule.html,https://root.cern,https://root.cern/root/html528/RooAbsMCStudyModule.html,1,['log'],['log']
Testability,"ocessAfterFit(Int_t ); Method called after fit has been performed. RooFitResult* refit(RooAbsData* inGenSample = 0); Interface methods to RooMCStudy objects,; which are only functional after module has been attached to a RooMCStudy object. RooAbsData* genSample(); Return generate sample. RooAbsPdf* genModel(); Return generator pdf. RooAbsGenContext* genContext(); Accessor for generator context, generator parameters,	prototype data and projected dependents. RooArgSet* genInitParams(); Return initial value of generator model parameters. RooArgSet* genParams(); Return current value of generator model parameters. const RooDataSet* genProtoData(); Return generator prototype data provided by user. RooArgSet* projDeps(); Return projected observables. RooArgSet* dependents(); Accessors for fit observables, fit model, current and initial fit parameters and NLL value. RooArgSet* allDependents(); Returna all observables. RooAbsPdf* fitModel(); Return fit model. RooArgSet* fitInitParams(); Return initial value of parameters of fit model. RooArgSet* fitParams(); Return current value of parameters of fit model. RooRealVar* nllVar(); Return pointer to RooRealVar holding minimized -log(L) value. const char* fitOptions(); Accessors for fit options, generator annd MCstudy configuration flags. RooLinkedList* fitOptList(); Return list of fit options provided by user. Bool_t extendedGen(); If true extended mode generation is requested. Bool_t binGenData(); If true binning of data between generating and fitting is requested. Double_t numExpGen(); Return expected number of events from generator model. Bool_t randProto(); If true randomization of prototype data order is requested. Bool_t verboseGen(); If true verbose message in the generation step is requested.  Last changed: Tue Jun 30 14:30:12 2015  Last generated: 2015-06-30 14:30; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooAbsMCStudyModule.html:10113,log,log,10113,root/html602/RooAbsMCStudyModule.html,https://root.cern,https://root.cern/root/html602/RooAbsMCStudyModule.html,1,['log'],['log']
Testability,"ocessAfterFit(Int_t ); Method called after fit has been performed. RooFitResult* refit(RooAbsData* inGenSample = 0); Interface methods to RooMCStudy objects,; which are only functional after module has been attached to a RooMCStudy object. RooAbsData* genSample(); Return generate sample. RooAbsPdf* genModel(); Return generator pdf. RooAbsGenContext* genContext(); Accessor for generator context, generator parameters,	prototype data and projected dependents. RooArgSet* genInitParams(); Return initial value of generator model parameters. RooArgSet* genParams(); Return current value of generator model parameters. const RooDataSet* genProtoData(); Return generator prototype data provided by user. RooArgSet* projDeps(); Return projected observables. RooArgSet* dependents(); Accessors for fit observables, fit model, current and initial fit parameters and NLL value. RooArgSet* allDependents(); Returna all observables. RooAbsPdf* fitModel(); Return fit model. RooArgSet* fitInitParams(); Return initial value of parameters of fit model. RooArgSet* fitParams(); Return current value of parameters of fit model. RooRealVar* nllVar(); Return pointer to RooRealVar holding minimized -log(L) value. const char* fitOptions(); Accessors for fit options, generator annd MCstudy configuration flags. RooLinkedList* fitOptList(); Return list of fit options provided by user. Bool_t extendedGen(); If true extended mode generation is requested. Bool_t binGenData(); If true binning of data between generating and fitting is requested. Double_t numExpGen(); Return expected number of events from generator model. Bool_t randProto(); If true randomization of prototype data order is requested. Bool_t verboseGen(); If true verbose message in the generation step is requested.  Last changed: Tue Mar 10 17:14:01 2015  Last generated: 2015-03-10 17:14; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAbsMCStudyModule.html:9652,log,log,9652,root/html534/RooAbsMCStudyModule.html,https://root.cern,https://root.cern/root/html534/RooAbsMCStudyModule.html,1,['log'],['log']
Testability,"ochs where the direction is reset to the steepest descent. How to use it...; TMLP is build from 3 classes: TNeuron, TSynapse and TMultiLayerPerceptron. Only TMultiLayerPerceptron should be used explicitly by the user.; TMultiLayerPerceptron will take examples from a TTree given in the constructor. The network is described by a simple string: The input/output layers are defined by giving the expression for each neuron, separated by comas. Hidden layers are just described by the number of neurons. The layers are separated by colons. In addition, input/output layer formulas can be preceded by '@' (e.g ""@out"") if one wants to also normalize the data from the TTree. Input and outputs are taken from the TTree given as second argument. Expressions are evaluated as for TTree::Draw(), arrays are expended in distinct neurons, one for each index. This can only be done for fixed-size arrays. If the formula ends with ""!"", softmax functions are used for the output layer. One defines the training and test datasets by TEventLists.; Example: TMultiLayerPerceptron(""x,y:10:5:f"",inputTree);; TMultiLayerPerceptron::TMultiLayerPerceptronTMultiLayerPerceptron()Default constructor.Definition TMultiLayerPerceptron.cxx:264; Both the TTree and the TEventLists can be defined in the constructor, or later with the suited setter method. The lists used for training and test can be defined either explicitly, or via a string containing the formula to be used to define them, exactly as for a TCut.; The learning method is defined using the TMultiLayerPerceptron::SetLearningMethod() . Learning methods are :. TMultiLayerPerceptron::kStochastic,; TMultiLayerPerceptron::kBatch,; TMultiLayerPerceptron::kSteepestDescent,; TMultiLayerPerceptron::kRibierePolak,; TMultiLayerPerceptron::kFletcherReeves,; TMultiLayerPerceptron::kBFGS. A weight can be assigned to events, either in the constructor, either with TMultiLayerPerceptron::SetEventWeight(). In addition, the TTree weight is taken into account.; Finally, on",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMultiLayerPerceptron.html:6937,test,test,6937,doc/master/classTMultiLayerPerceptron.html,https://root.cern,https://root.cern/doc/master/classTMultiLayerPerceptron.html,1,['test'],['test']
Testability,"ockedflag used for suppression of all signals; static TList*TApplication::fgApplicationsList of available applications. private:. TStringfDefaultPromptdefault prompt: ""root [%d] ""; TFileHandler*fInputHandlerterminal input handler; Bool_tfInterruptif true macro execution will be stopped; Int_tfNcmdcommand history number; charfPrompt[64]interpreter prompt. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TRint(const char* appClassName, int* argc, char** argv, void* options = 0, int numOptions = 0, Bool_t noLogo = kFALSE); Create an application environment. The TRint environment provides an; interface to the WM manager functionality and eventloop via inheritance; of TApplication and in addition provides interactive access to; the CINT C++ interpreter via the command line. ~TRint(); Destructor. void ExecLogon(); Execute logon macro's. There are three levels of logon macros that; will be executed: the system logon etc/system.rootlogon.C, the global; user logon ~/.rootlogon.C and the local ./.rootlogon.C. For backward; compatibility also the logon macro as specified by the Rint.Logon; environment setting, by default ./rootlogon.C, will be executed.; No logon macros will be executed when the system is started with; the -n option. void Run(Bool_t retrn = kFALSE); Main application eventloop. First process files given on the command; line and then go into the main application event loop, unless the -q; command line option was specfied in which case the program terminates.; When retrun is true this method returns even when -q was specified. When QuitOpt is true and retrn is false, terminate the application with; an error code equal to either the ProcessLine error (if any) or the; return value of the command casted to a long. void PrintLogo(Bool_t lite = kFALSE); Print the ROOT logo on standard output. char * GetPrompt(); Get prompt from interpreter. Either ""root [n]"" or ""end with '}'"". const char * SetPrompt(const char* newPrompt); Set ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TRint.html:12909,log,logon,12909,root/html528/TRint.html,https://root.cern,https://root.cern/root/html528/TRint.html,4,['log'],['logon']
Testability,"ockedflag used for suppression of all signals; static TSemaphore*TProof::fgSemaphoresemaphore to control no of parallel startup threads. private:. TStringfCacheDirDirectory containing cache of user files; TProofLockPath*fCacheLockCache dir locker; TStringfDataSetDirDirectory containing info about known data sets; TDataSetManager*fDataSetManagerDataset manager; Bool_tfForkStartupStartup N-1 workers forking the first worker; Int_tfNWorkersNumber of workers; TQueryResultManager*fQMgrQuery-result manager; TStringfQueryDirDirectory containing query results and status; TProofLockPath*fQueryLockQuery dir locker; TStringfSandboxPROOF sandbox root dir; TServerSocket*fServSockServer socket to accept call backs; TStringfSockPathUNIX socket path for communication with workers; static Int_tfgWrksMaxMax number of workers. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TProofLite(const char* masterurl, const char* conffile = kPROOF_ConfFile, const char* confdir = kPROOF_ConfDir, Int_t loglevel = 0, const char* alias = 0, TProofMgr* mgr = 0); Create a PROOF environment. Starting PROOF involves either connecting; to a master server, which in turn will start a set of slave servers, or; directly starting as master server (if master = """"). Masterurl is of; the form: [proof[s]://]host[:port]. Conffile is the name of the config; file describing the remote PROOF cluster (this argument alows you to; describe different cluster configurations).; The default is proof.conf. Confdir is the directory where the config; file and other PROOF related files are (like motd and noproof files).; Loglevel is the log level (default = 1). User specified custom config; files will be first looked for in $HOME/.conffile. Int_t Init(const char* masterurl, const char* conffile, const char* confdir, Int_t loglevel, const char* alias = 0); Start the PROOF environment. Starting PROOF involves either connecting; to a master server, which in turn will start a set of slave ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TProofLite.html:24906,log,loglevel,24906,root/html528/TProofLite.html,https://root.cern,https://root.cern/root/html528/TProofLite.html,1,['log'],['loglevel']
Testability,"ocumentation . ; Reference Manual . ; User's Guides . ; HowTo . ; Courses . ; Building ROOT . ; Tutorials . ; Javascript Root . ; ROOT and Spark . ; Publications . ; FAQ . ; News . ; Blog . ; Workshops . ; Support . ; Forum . ; Bug submission guidelines . ; Submit a Bug . ; RootTalk Digest . ; Discourse Mailing List Mode . ; About . ; Licence . ; Contact Us . ; Project Founders . ; Team . ; Previous Developers . ; Development . ; Program of Work . ; Code Owners . ; Release Checklist . ; Coding Conventions . ; Shifter's Instructions . ; Git Primer . ; Creating a Pull Request . ; Github ssh key . ; Git Tips and Tricks . ; Git How Tos . ; A suggested work flow for distributed projects: NoSY . ; Browse Sources . ; Meetings . ; ROOT 7 . ; Run the tests . ; Setup externals from AFS/CVMFS . ; Jenkins . ; Doxygen . ; Benchmarks . ; Contribute . ; Collaborate with Us . You are hereHome  Development Run the tests. Running the ROOT battery of tests; Running all ROOT tests on at least a platform before sending a PR or before pushing anything to the ROOT repository is mandatory.; The ROOT continuous integration infrastructure allows to automatically check the PR also on a battery of platform, for example including macos and linux boxes.; In order to be able to run all tests, the simple steps below need to be followed; Prepare your development area and build ROOT; mkdir RootDevelopment; cd RootDevelopment; git clone https://github.com/root-project/root; git clone https://github.com/root-project/roottest; mkdir build; cd build; echo Note the cmake options; cmake -DCMAKE_BUILD_TYPE=Debug -Dtesting=ON -Droottest=ON ../root. Inspect and run the tests; From within the build directory. List all tests: ctest -N; List all test matching a regex: ctest -N -R myregex; Run all tests on N cores: ctest -j N. Sitemap. DownloadDownload ROOT; All Releases. DocumentationReference Manual; User's Guides; HowTo; Courses; Building ROOT; Tutorials; Javascript Root; ROOT and Spark; Publications; FAQ. Ne",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/run-tests.html:1905,test,tests,1905,d/run-tests.html,https://root.cern,https://root.cern/d/run-tests.html,2,['test'],['tests']
Testability,"odBase::SetNormalised(Bool_t norm); voidTMVA::MethodBase::SetWeightFileDir(TString fileDir); voidTMVA::MethodBase::SetWeightFileName(TString); voidTMVA::MethodBase::Statistics(TMVA::Types::ETreeType treeType, const TString& theVarName, Double_t&, Double_t&, Double_t&, Double_t&, Double_t&, Double_t&); Bool_tTMVA::MethodBase::TxtWeightsOnly() const; Bool_tTMVA::MethodBase::Verbose() const; voidTMVA::Configurable::WriteOptionsReferenceToFile(). private:. voidGetLDCoeff(); voidGetSum(); voidGetSumVal(); virtual voidInit(); voidInitMatrices(); voidPrintCoefficients(). Data Members; public:. enum TMVA::MethodBase::EWeightFileType { kROOT; kTEXT; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. public:. Bool_tTMVA::MethodBase::fSetupCompletedis method setup; const TMVA::Event*TMVA::MethodBase::fTmpEvent! temporary event when testing on a different DataSet than the own one. protected:. TMVA::Types::EAnalysisTypeTMVA::MethodBase::fAnalysisTypemethod-mode : true --> regression, false --> classification; UInt_tTMVA::MethodBase::fBackgroundClassindex of the Background-class; vector<TString>*TMVA::MethodBase::fInputVarsvector of input variables used in MVA; vector<Float_t>*TMVA::MethodBase::fMulticlassReturnValholds the return-values for the multiclass classification; Int_tTMVA::MethodBase::fNbinsnumber of bins in input variable histograms; Int_tTMVA::MethodBase::fNbinsHnumber of bins in evaluation histograms; Int_tTMVA::MethodBase::fNbinsMVAoutputnumber of bins in MVA output histograms; TMVA::Ranking*TMVA::MethodBase::fRankingpointer to ranking object (created by derived classifiers); vector<Float_t>*TMVA::MethodBase::fRegressionReturnValholds the return-values for the regression; UInt_tTMVA::MethodBase::fSignalClassindex of the Signal-class. private:. TMatrixD*fCoeffMatxMa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TMVA__MethodLD.html:15019,test,testing,15019,root/html530/TMVA__MethodLD.html,https://root.cern,https://root.cern/root/html530/TMVA__MethodLD.html,3,['test'],['testing']
Testability,"odBase::SetNormalised(Bool_t norm); voidTMVA::MethodBase::SetWeightFileDir(TString fileDir); voidTMVA::MethodBase::SetWeightFileName(TString); voidTMVA::MethodBase::Statistics(TMVA::Types::ETreeType treeType, const TString& theVarName, Double_t&, Double_t&, Double_t&, Double_t&, Double_t&, Double_t&); Bool_tTMVA::MethodBase::TxtWeightsOnly() const; Bool_tTMVA::MethodBase::Verbose() const; voidTMVA::Configurable::WriteOptionsReferenceToFile(). private:. voidGetLDCoeff(); voidGetSum(); voidGetSumVal(); virtual voidInit(); voidInitMatrices(); voidPrintCoefficients(). Data Members; public:. enum TMVA::MethodBase::EWeightFileType { kROOT; kTEXT; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. public:. Bool_tTMVA::MethodBase::fSetupCompletedis method setup; const TMVA::Event*TMVA::MethodBase::fTmpEvent! temporary event when testing on a different DataSet than the own one. protected:. TMVA::Types::EAnalysisTypeTMVA::MethodBase::fAnalysisTypemethod-mode : true --> regression, false --> classification; UInt_tTMVA::MethodBase::fBackgroundClassindex of the Background-class; vector<TString>*TMVA::MethodBase::fInputVarsvector of input variables used in MVA; vector<Float_t>*TMVA::MethodBase::fMulticlassReturnValholds the return-values for the multiclass classification; Int_tTMVA::MethodBase::fNbinsnumber of bins in representative histograms; Int_tTMVA::MethodBase::fNbinsHnumber of bins in evaluation histograms; TMVA::Ranking*TMVA::MethodBase::fRankingpointer to ranking object (created by derived classifiers); vector<Float_t>*TMVA::MethodBase::fRegressionReturnValholds the return-values for the regression; UInt_tTMVA::MethodBase::fSignalClassindex of the Signal-class. private:. TMatrixD*fCoeffMatxMatrix of coefficients; vector<std::vector<Double_t>*>*fLDCoeffLD coefficients; I",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMVA__MethodLD.html:14478,test,testing,14478,root/html528/TMVA__MethodLD.html,https://root.cern,https://root.cern/root/html528/TMVA__MethodLD.html,1,['test'],['testing']
Testability,"odBase::SetWeightFileName(TString); voidSetXminXmax(TMVA::PDEFoam*); voidTMVA::MethodBase::Statistics(TMVA::Types::ETreeType treeType, const TString& theVarName, Double_t&, Double_t&, Double_t&, Double_t&, Double_t&, Double_t&); Bool_tTMVA::MethodBase::TxtWeightsOnly() const; Bool_tTMVA::MethodBase::Verbose() const; voidTMVA::Configurable::WriteOptionsReferenceToFile(). private:. virtual voidDeclareCompatibilityOptions(); virtual voidDeclareOptions(); virtual voidInit(); voidPrintCoefficients(); virtual voidProcessOptions(). Data Members; public:. enum EKernel { kNone; kGaus; kLinN; };; enum TMVA::MethodBase::EWeightFileType { kROOT; kTEXT; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. public:. Bool_tTMVA::MethodBase::fSetupCompletedis method setup; const TMVA::Event*TMVA::MethodBase::fTmpEvent! temporary event when testing on a different DataSet than the own one. protected:. TMVA::Types::EAnalysisTypeTMVA::MethodBase::fAnalysisTypemethod-mode : true --> regression, false --> classification; UInt_tTMVA::MethodBase::fBackgroundClassindex of the Background-class; vector<TString>*TMVA::MethodBase::fInputVarsvector of input variables used in MVA; vector<Float_t>*TMVA::MethodBase::fMulticlassReturnValholds the return-values for the multiclass classification; Int_tTMVA::MethodBase::fNbinsnumber of bins in input variable histograms; Int_tTMVA::MethodBase::fNbinsHnumber of bins in evaluation histograms; Int_tTMVA::MethodBase::fNbinsMVAoutputnumber of bins in MVA output histograms; TMVA::Ranking*TMVA::MethodBase::fRankingpointer to ranking object (created by derived classifiers); vector<Float_t>*TMVA::MethodBase::fRegressionReturnValholds the return-values for the regression; UInt_tTMVA::MethodBase::fSignalClassindex of the Signal-class. private:. Bool_tfCompresscompre",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TMVA__MethodPDEFoam.html:16647,test,testing,16647,root/html530/TMVA__MethodPDEFoam.html,https://root.cern,https://root.cern/root/html530/TMVA__MethodPDEFoam.html,3,['test'],['testing']
Testability,"odBase::SetWeightFileName(TString); voidTMVA::MethodBase::Statistics(TMVA::Types::ETreeType treeType, const TString& theVarName, Double_t&, Double_t&, Double_t&, Double_t&, Double_t&, Double_t&); Bool_tTMVA::MethodBase::TxtWeightsOnly() const; Bool_tTMVA::MethodBase::Verbose() const; voidTMVA::Configurable::WriteOptionsReferenceToFile(). private:. voidCreateMLPOptions(TString); virtual voidDeclareOptions(); virtual voidInit(); virtual voidProcessOptions(). Data Members; public:. Bool_tTMVA::MethodBase::fSetupCompletedis method setup; const TMVA::Event*TMVA::MethodBase::fTmpEvent! temporary event when testing on a different DataSet than the own one; static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TMVA::MethodBase::EWeightFileTypeTMVA::MethodBase::kROOT; static TObject::(anonymous)TObject::kSingleKey; static TMVA::MethodBase::EWeightFileTypeTMVA::MethodBase::kTEXT; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TMVA::Types::EAnalysisTypeTMVA::MethodBase::fAnalysisTypemethod-mode : true --> regression, false --> classification; UInt_tTMVA::MethodBase::fBackgroundClassindex of the Background-class; vector<TString>*TMVA::MethodBase::fInputVarsvector of input variables used in MVA; vector<Float_t>*TMVA::MethodBase::fMulticlassReturnValholds the return-values for the multiclass classification; Int_tTMVA::MethodBase::fNbinsnumber of bins in input variable histograms; Int_tTMVA::",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TMVA__MethodTMlpANN.html:15782,test,testing,15782,root/html602/TMVA__MethodTMlpANN.html,https://root.cern,https://root.cern/root/html602/TMVA__MethodTMlpANN.html,2,['test'],['testing']
Testability,"odBase::Statistics(TMVA::Types::ETreeType treeType, const TString& theVarName, Double_t&, Double_t&, Double_t&, Double_t&, Double_t&, Double_t&); Bool_tTMVA::MethodBase::TxtWeightsOnly() const; Bool_tTMVA::MethodBase::Verbose() const; voidTMVA::Configurable::WriteOptionsReferenceToFile(). private:. voidComputeCovariance(Bool_t, TMatrixD*); virtual voidDeclareOptions(); Double_tGetChi2(TMVA::Types::ESBType); virtual voidInit(); virtual voidProcessOptions(). Data Members; public:. Bool_tTMVA::MethodBase::fSetupCompletedis method setup; const TMVA::Event*TMVA::MethodBase::fTmpEvent! temporary event when testing on a different DataSet than the own one; static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TMVA::MethodBase::EWeightFileTypeTMVA::MethodBase::kROOT; static TObject::(anonymous)TObject::kSingleKey; static TMVA::MethodBase::EWeightFileTypeTMVA::MethodBase::kTEXT; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TMVA::Types::EAnalysisTypeTMVA::MethodBase::fAnalysisTypemethod-mode : true --> regression, false --> classification; UInt_tTMVA::MethodBase::fBackgroundClassindex of the Background-class; vector<TString>*TMVA::MethodBase::fInputVarsvector of input variables used in MVA; vector<Float_t>*TMVA::MethodBase::fMulticlassReturnValholds the return-values for the multiclass classification; Int_tTMVA::MethodBase::fNbinsnumber of bins in input variable histograms; Int_tTMVA::",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TMVA__MethodHMatrix.html:16240,test,testing,16240,root/html602/TMVA__MethodHMatrix.html,https://root.cern,https://root.cern/root/html602/TMVA__MethodHMatrix.html,2,['test'],['testing']
Testability,"odTag, const TString &weightfile)read method name from weight fileDefinition Reader.cxx:368; TMVA::Reader::EvaluateMulticlassconst std::vector< Float_t > & EvaluateMulticlass(const TString &methodTag, Double_t aux=0)evaluates MVA for given set of input variablesDefinition Reader.cxx:630; TMVA::Reader::GetMVAErrorUpperDouble_t GetMVAErrorUpper() constDefinition Reader.h:96; TMVA::Reader::LogMsgLogger & Log() constDefinition Reader.h:162; TMVA::Reader::GetMVAErrorLowerDouble_t GetMVAErrorLower() constDefinition Reader.h:95; TMVA::Reader::DataInfoDataSetInfo & DataInfo()Definition Reader.h:118; TMVA::Reader::fDataInputHandlerDataInputHandler fDataInputHandlerDefinition Reader.h:138; TMVA::Reader::DecodeVarNamesvoid DecodeVarNames(const std::string &varNames)decodes ""name1:name2:..."" formDefinition Reader.cxx:772; TMVA::Reader::fSilentBool_t fSilentsilent modeDefinition Reader.h:150; TMVA::Reader::DeclareOptionsvoid DeclareOptions()declaration of configuration optionsDefinition Reader.cxx:264; TMVA::Reader::AddSpectatorvoid AddSpectator(const TString &expression, Float_t *)Add a float spectator or expression to the reader.Definition Reader.cxx:321; TMVA::Reader::AddVariablevoid AddVariable(const TString &expression, Float_t *)Add a float variable or expression to the reader.Definition Reader.cxx:303; TMVA::Reader::~Readervirtual ~Reader(void)destructorDefinition Reader.cxx:277; TMVA::Reader::fLoggerMsgLogger * fLogger! message loggerDefinition Reader.h:161; TMVA::Reader::DataInfoconst DataSetInfo & DataInfo() constDefinition Reader.h:117; TMVA::Reader::GetMVAErrorDouble_t GetMVAError() constDefinition Reader.h:94; TMVA::Types::EMVAEMVADefinition Types.h:76; TStringBasic string class.Definition TString.h:139; bool; double; int; TMVAcreate variable transformationsDefinition GeneticMinimizer.h:22; v@ vDefinition rootcling_impl.cxx:3699; Types.h. tmvatmvaincTMVAReader.h. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:40:58 (GVA Time) using Doxygen 1.9.8 ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/Reader_8h_source.html:12377,log,loggerDefinition,12377,doc/master/Reader_8h_source.html,https://root.cern,https://root.cern/doc/master/Reader_8h_source.html,1,['log'],['loggerDefinition']
Testability,"ode << Endl;; 1612 }; 1613 ; 1614 // ---------------------------------; 1615 // now apply the normalization factors; 1616 Int_t maxL = dsi.GetClassNameMaxLength();; 1617 for (UInt_t cls = 0, clsEnd = dsi.GetNClasses(); cls<clsEnd; ++cls) {; 1618 Log() << kDEBUG //<< Form(""Dataset[%s] : "",dsi.GetName()); 1619 << ""--> Rescale "" << setiosflags(ios::left) << std::setw(maxL); 1620 << dsi.GetClassInfo(cls)->GetName() << "" event weights by factor: "" << renormFactor.at(cls) << Endl;; 1621 for (EventVector::iterator it = tmpEventVector[Types::kTraining].at(cls).begin(),; 1622 itEnd = tmpEventVector[Types::kTraining].at(cls).end(); it != itEnd; ++it){; 1623 (*it)->SetWeight ((*it)->GetWeight() * renormFactor.at(cls));; 1624 }; 1625 ; 1626 }; 1627 ; 1628 ; 1629 // print out the result; 1630 // (same code as before --> this can be done nicer ); 1631 //; 1632 ; 1633 Log() << kINFO //<< Form(""Dataset[%s] : "",dsi.GetName()); 1634 << ""Number of training and testing events"" << Endl;; 1635 Log() << kDEBUG << ""\tafter rescaling:"" << Endl;; 1636 Log() << kINFO //<< Form(""Dataset[%s] : "",dsi.GetName()); 1637 << ""---------------------------------------------------------------------------"" << Endl;; 1638 ; 1639 trainingSumSignalWeights = 0;; 1640 trainingSumBackgrWeights = 0; // Backgr. includes all classes that are not signal; 1641 testingSumSignalWeights = 0;; 1642 testingSumBackgrWeights = 0; // Backgr. includes all classes that are not signal; 1643 ; 1644 for( UInt_t cls = 0, clsEnd = dsi.GetNClasses(); cls < clsEnd; ++cls ){; 1645 trainingSumWeightsPerClass.at(cls) =; 1646 std::accumulate(tmpEventVector[Types::kTraining].at(cls).begin(),; 1647 tmpEventVector[Types::kTraining].at(cls).end(),; 1648 Double_t(0), [](Double_t w, const TMVA::Event *E) { return w + E->GetOriginalWeight(); });; 1649 ; 1650 testingSumWeightsPerClass.at(cls) =; 1651 std::accumulate(tmpEventVector[Types::kTesting].at(cls).begin(),; 1652 tmpEventVector[Types::kTesting].at(cls).end(),; 1653 Double_t(0), [](Double",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/DataSetFactory_8cxx_source.html:75935,test,testing,75935,doc/master/DataSetFactory_8cxx_source.html,https://root.cern,https://root.cern/doc/master/DataSetFactory_8cxx_source.html,1,['test'],['testing']
Testability,ode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; RooAbsReal*RooAbsTestStatistic::_funcPointer to original input function; RooAbsReal*_funcClonePointer to internal clone of input function; RooArgSet*_funcCloneSetSet owning all components of internal clone of input function; RooArgSet*_funcObsSetList of observables in the pdf expression; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; pRooAbsTestStatistic*RooAbsTestStatistic::_gofArray! Array of sub-contexts representing part of the combined test statistic; RooAbsTestStatistic::GOFOpModeRooAbsTestStatistic::_gofOpModeOperation mode of test statistic instance; vector<RooFit::MPSplit>RooAbsTestStatistic::_gofSplitMode! GOF MP Split mode specified by component (when Auto is active); static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Bool_tRooAbsTestStatistic::_init! Is object initialized; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches; Bool_tRooAbsArg::_isConstant! Cached isConstant status; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; pRooRealMPFE*RooAbsTestStatistic::_mpfeArray! Array of parallel execution frond ends; RooFit::MPSplitRooAbsTestStatistic::_mpinterlUse interleaving strategy rather than N-wise split for partioning of dataset for multiprocessor-split; Int_tRooAbsTestStatistic::_nCPUNumber of processors to use in parallel calculation mode; Int_tRooAbsTestStatistic::_nEventsTotal number of events in test statistic calculation; Int_tRooAbsTestStatistic::_nGofNumber of sub-contexts; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist.,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooAbsOptTestStatistic.html:40488,test,test,40488,root/html602/RooAbsOptTestStatistic.html,https://root.cern,https://root.cern/root/html602/RooAbsOptTestStatistic.html,2,['test'],['test']
Testability,"ode of last operation; TStringTSQLServer::fErrorMsgerror message of last operation; Bool_tTSQLServer::fErrorOutenable error output; TStringTSQLServer::fHosthost to which we are connected; Int_tTSQLServer::fPortport to which we are connected; TStringTSQLServer::fTypetype of DBMS (MySQL, Oracle, SysBase, ...); static const char*TSQLServer::fgFloatFmt! printf argument for floats and doubles, either ""%f"" or ""%e"" or ""%10f"" and so on. private:. Connection*fConnconnection to Oracle server; Environment*fEnvenvironment of Oracle access; TStringfInfoinfo string with Oracle version information; static const char*fgDatimeFormat! format for converting date and time stamps into string . Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TOracleServer(const char* db, const char* uid, const char* pw); Open a connection to a Oracle DB server. The db arguments should be; of the form ""oracle://connection_identifier[/<database>]"", e.g.:; ""oracle://cmscald.fnal.gov/test"". The uid is the username and pw; the password that should be used for the connection. ~TOracleServer(); Close connection to Oracle DB server. void Close(Option_t* opt = """"); Close connection to Oracle DB server. TSQLStatement * Statement(const char* sql, Int_t niter = 100). TSQLResult * Query(const char* sql); Execute SQL command. Result object must be deleted by the user.; Returns a pointer to a TSQLResult object if successful, 0 otherwise. Bool_t Exec(const char* sql); Execute sql command wich does not produce any result set.; Return kTRUE if succesfull. TSQLResult * GetTables(const char* dbname, const char* wild = 0); List all tables in the specified database. Wild is for wildcarding; ""t%"" list all tables starting with ""t"".; Returns a pointer to a TSQLResult object if successful, 0 otherwise.; The result object must be deleted by the user. TList* GetTablesList(const char* wild = 0). TSQLTableInfo * GetTableInfo(const char* tablename); Produces SQL table info; Object must be del",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TOracleServer.html:9617,test,test,9617,root/html528/TOracleServer.html,https://root.cern,https://root.cern/root/html528/TOracleServer.html,1,['test'],['test']
Testability,"ode only for classes starting with Ali; classes = ""myClass"" generate code for class MyClass only.; . Reimplemented from TFile.; Definition at line 232 of file TSQLFile.h. MakeSelectQuery(). TString TSQLFile::MakeSelectQuery ; (; TClass *; cl). Produce SELECT statement which can be used to get all data of class cl in one SELECT statement. ; This statement also can be used to create VIEW by command like mysql> CREATE VIEW TH1I_view AS $CLASSSELECT$ Where $CLASSSELECT$ argument should be produced by call f->MakeSelectQuery(TH1I::Class()); VIEWs supported by latest MySQL 5 and Oracle ; Definition at line 1215 of file TSQLFile.cxx. Map() [1/2]. void TSQLFile::Map ; (; ). inlinefinalvirtual . Reimplemented from TFile.; Definition at line 234 of file TSQLFile.h. Map() [2/2]. void TSQLFile::Map ; (; Option_t *; opt). inlinefinalvirtual . List the contents of a file sequentially. ; For each logical record found, it prints: Date/Time Record_Adress Logical_Record_Length ClassName CompressionFactor; Example of output 20010404/150437 At:64 N=150 TFile; 20010404/150440 At:214 N=28326 TBasket CX = 1.13; 20010404/150440 At:28540 N=29616 TBasket CX = 1.08; 20010404/150440 At:58156 N=29640 TBasket CX = 1.08; 20010404/150440 At:87796 N=29076 TBasket CX = 1.10; 20010404/150440 At:116872 N=10151 TBasket CX = 3.15; 20010404/150441 At:127023 N=28341 TBasket CX = 1.13; 20010404/150441 At:155364 N=29594 TBasket CX = 1.08; 20010404/150441 At:184958 N=29616 TBasket CX = 1.08; 20010404/150441 At:214574 N=29075 TBasket CX = 1.10; 20010404/150441 At:243649 N=9583 TBasket CX = 3.34; 20010404/150442 At:253232 N=28324 TBasket CX = 1.13; 20010404/150442 At:281556 N=29641 TBasket CX = 1.08; 20010404/150442 At:311197 N=29633 TBasket CX = 1.08; 20010404/150442 At:340830 N=29091 TBasket CX = 1.10; 20010404/150442 At:369921 N=10341 TBasket CX = 3.09; 20010404/150442 At:380262 N=509 TH1F CX = 1.93; 20010404/150442 At:380771 N=1769 TH2F CX = 4.32; 20010404/150442 At:382540 N=1849 TProfile CX = 1.65;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSQLFile.html:79217,log,logical,79217,doc/master/classTSQLFile.html,https://root.cern,https://root.cern/doc/master/classTSQLFile.html,1,['log'],['logical']
Testability,"ode to support creation of a standalone I/O library. Concepts; At the logical layer, the user defines a data model using the RNTupleModel class. The data model is a collection of serializable C++ types with associated names, similar to branches in a TTree. The data model can contain (nested) collections, e.g., a type can be std::vector<std::vector<float>>.; Each serializable type is represented by a field, concretely by a templated version of RField, e.g. RField<double>. A field can generate or adopt an associated value, which represents a memory location storing a value of the given C++ type. These distinguished memory locations are the destinations and sources for the deserialization and serialization.; The (de-)serialization is a mapping from the C++ type to the more simple column type system. A column contains an arbitrary number of fixed-sized elements of a well-defined set of types: integers and floats of different bit sizes. A C++ type may be mapped to multiple columns. For instance, an std::vector<float> maps to two columns, an offset column indicating the size of the vector per entry, and a payload column with the float data.; Columns are partitioned into pages (roughly: TTree baskets) of a few kB  a few tens of kB each. The physical layer (only) needs to provide the means to store and retrieve pages. The physical layer is decoupled from the high-level C++ logic. The physical layer implements an abstract page storage interface, so that dedicated implementations for key-value stores and other storage systems are conceivable. At this point, the only provided backend stores the pages in ROOT files.; RNTuples are further grouped into clusters, which are, like TTree clusters, self-contained blocks of consecutive entries. Clusters provide a unit of writing and will provide the means for parallel writing of data in a future version of RNTuple. Related classes. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:32 (GVA Time) using Doxygen 1.9.8 ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/md_tree_2ntuple_2v7_2doc_2README.html:2879,log,logic,2879,doc/master/md_tree_2ntuple_2v7_2doc_2README.html,https://root.cern,https://root.cern/doc/master/md_tree_2ntuple_2v7_2doc_2README.html,1,['log'],['logic']
Testability,"ode, like ""fork:--headless --private-window --no-remote $profile $url""; WebGui.FirefoxInteractive: command to start Firefox in interactive mode, like ""$prog --private-window \'$url\' &""; WebGui.FirefoxProfile: name of Firefox profile to use; WebGui.FirefoxProfilePath: file path to Firefox profile; WebGui.FirefoxRandomProfile: usage of random Firefox profile -1 never, 0 - only for headless mode (dflt), 1 - always; WebGui.LaunchTmout: time required to start process in seconds (default 30 s); WebGui.OperationTmout: time required to perform WebWindow operation like execute command or update drawings; WebGui.RecordData: if specified enables data recording for each web window 0 - off, 1 - on; WebGui.JsonComp: compression factor for JSON conversion, if not specified - each widget uses own default values; WebGui.ForceHttp: 0 - off (default), 1 - always create real http server to run web window; WebGui.Console: -1 - output only console.error(), 0 - add console.warn(), 1 - add console.log() output; WebGui.ConnCredits: 10 - number of packets which can be send by server or client without acknowledge from receiving side; WebGui.openui5src: alternative location for openui5 like https://openui5.hana.ondemand.com/1.128.0/; WebGui.openui5libs: list of pre-loaded ui5 libs like sap.m, sap.ui.layout, sap.ui.unified; WebGui.openui5theme: openui5 theme like sap_belize (default) or sap_fiori_3; THttpServer-related parameters documented in CreateServer method ; Definition at line 778 of file RWebWindowsManager.cxx. Terminate(). void RWebWindowsManager::Terminate ; (; ). Terminate http server and ROOT application. ; Definition at line 937 of file RWebWindowsManager.cxx. Unregister(). void RWebWindowsManager::Unregister ; (; RWebWindow &; win). private . Release all references to specified window Called from RWebWindow destructor. ; Definition at line 674 of file RWebWindowsManager.cxx. WaitFor(). int RWebWindowsManager::WaitFor ; (; RWebWindow &; win, . WebWindowWaitFunc_t; check, .",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1RWebWindowsManager.html:20095,log,log,20095,doc/master/classROOT_1_1RWebWindowsManager.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1RWebWindowsManager.html,1,['log'],['log']
Testability,"ode, like ""fork:--headless --private-window --no-remote $profile $url""; WebGui.FirefoxInteractive: command to start Firefox in interactive mode, like ""$prog --private-window \'$url\' &""; WebGui.FirefoxProfile: name of Firefox profile to use; WebGui.FirefoxProfilePath: file path to Firefox profile; WebGui.FirefoxRandomProfile: usage of random Firefox profile -1 never, 0 - only for headless mode (dflt), 1 - always; WebGui.LaunchTmout: time required to start process in seconds (default 30 s); WebGui.OperationTmout: time required to perform WebWindow operation like execute command or update drawings; WebGui.RecordData: if specified enables data recording for each web window 0 - off, 1 - on; WebGui.JsonComp: compression factor for JSON conversion, if not specified - each widget uses own default values; WebGui.ForceHttp: 0 - off (default), 1 - always create real http server to run web window; WebGui.Console: -1 - output only console.error(), 0 - add console.warn(), 1 - add console.log() output; WebGui.ConnCredits: 10 - number of packets which can be send by server or client without acknowledge from receiving side; WebGui.openui5src: alternative location for openui5 like https://openui5.hana.ondemand.com/; WebGui.openui5libs: list of pre-loaded ui5 libs like sap.m, sap.ui.layout, sap.ui.unified; WebGui.openui5theme: openui5 theme like sap_belize (default) or sap_fiori_3; THttpServer-related parameters documented in CreateServer method ; Definition at line 692 of file RWebWindowsManager.cxx. Terminate(). void RWebWindowsManager::Terminate ; (; ). Terminate http server and ROOT application. ; Definition at line 851 of file RWebWindowsManager.cxx. Unregister(). void RWebWindowsManager::Unregister ; (; RWebWindow &; win). private . Release all references to specified window Called from RWebWindow destructor. ; Definition at line 591 of file RWebWindowsManager.cxx. WaitFor(). int RWebWindowsManager::WaitFor ; (; RWebWindow &; win, . WebWindowWaitFunc_t; check, . bool; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1RWebWindowsManager.html:17656,log,log,17656,doc/v632/classROOT_1_1RWebWindowsManager.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1RWebWindowsManager.html,1,['log'],['log']
Testability,"ode: %u"",; 4318 response_code);; 4319 }; 4320 ; 4321 /* Return at least a category according to RFC 2616 Section 10. */; 4322 if (response_code >= 100 && response_code < 200) {; 4323 /* Unknown informational status code */; 4324 return ""Information"";; 4325 }; 4326 if (response_code >= 200 && response_code < 300) {; 4327 /* Unknown success code */; 4328 return ""Success"";; 4329 }; 4330 if (response_code >= 300 && response_code < 400) {; 4331 /* Unknown redirection code */; 4332 return ""Redirection"";; 4333 }; 4334 if (response_code >= 400 && response_code < 500) {; 4335 /* Unknown request error code */; 4336 return ""Client Error"";; 4337 }; 4338 if (response_code >= 500 && response_code < 600) {; 4339 /* Unknown server error code */; 4340 return ""Server Error"";; 4341 }; 4342 ; 4343 /* Response code not even within reasonable range */; 4344 return """";; 4345 }; 4346}; 4347 ; 4348 ; 4349static int; 4350mg_send_http_error_impl(struct mg_connection *conn,; 4351 int status,; 4352 const char *fmt,; 4353 va_list args); 4354{; 4355 char errmsg_buf[MG_BUF_LEN];; 4356 va_list ap;; 4357 int has_body;; 4358 ; 4359#if !defined(NO_FILESYSTEMS); 4360 char path_buf[UTF8_PATH_MAX];; 4361 int len, i, page_handler_found, scope, truncated;; 4362 const char *error_handler = NULL;; 4363 struct mg_file error_page_file = STRUCT_FILE_INITIALIZER;; 4364 const char *error_page_file_ext, *tstr;; 4365#endif /* NO_FILESYSTEMS */; 4366 int handled_by_callback = 0;; 4367 ; 4368 if ((conn == NULL) || (fmt == NULL)) {; 4369 return -2;; 4370 }; 4371 ; 4372 /* Set status (for log) */; 4373 conn->status_code = status;; 4374 ; 4375 /* Errors 1xx, 204 and 304 MUST NOT send a body */; 4376 has_body = ((status > 199) && (status != 204) && (status != 304));; 4377 ; 4378 /* Prepare message in buf, if required */; 4379 if (has_body; 4380 || (!conn->in_error_handler; 4381 && (conn->phys_ctx->callbacks.http_error != NULL))) {; 4382 /* Store error message in errmsg_buf */; 4383 va_copy(ap, args);; 4384 mg_vsnprintf(co",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:130505,log,log,130505,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,1,['log'],['log']
Testability,"ode: %u"",; 4319 response_code);; 4320 }; 4321 ; 4322 /* Return at least a category according to RFC 2616 Section 10. */; 4323 if (response_code >= 100 && response_code < 200) {; 4324 /* Unknown informational status code */; 4325 return ""Information"";; 4326 }; 4327 if (response_code >= 200 && response_code < 300) {; 4328 /* Unknown success code */; 4329 return ""Success"";; 4330 }; 4331 if (response_code >= 300 && response_code < 400) {; 4332 /* Unknown redirection code */; 4333 return ""Redirection"";; 4334 }; 4335 if (response_code >= 400 && response_code < 500) {; 4336 /* Unknown request error code */; 4337 return ""Client Error"";; 4338 }; 4339 if (response_code >= 500 && response_code < 600) {; 4340 /* Unknown server error code */; 4341 return ""Server Error"";; 4342 }; 4343 ; 4344 /* Response code not even within reasonable range */; 4345 return """";; 4346 }; 4347}; 4348 ; 4349 ; 4350static int; 4351mg_send_http_error_impl(struct mg_connection *conn,; 4352 int status,; 4353 const char *fmt,; 4354 va_list args); 4355{; 4356 char errmsg_buf[MG_BUF_LEN];; 4357 va_list ap;; 4358 int has_body;; 4359 ; 4360#if !defined(NO_FILESYSTEMS); 4361 char path_buf[UTF8_PATH_MAX];; 4362 int len, i, page_handler_found, scope, truncated;; 4363 const char *error_handler = NULL;; 4364 struct mg_file error_page_file = STRUCT_FILE_INITIALIZER;; 4365 const char *error_page_file_ext, *tstr;; 4366#endif /* NO_FILESYSTEMS */; 4367 int handled_by_callback = 0;; 4368 ; 4369 if ((conn == NULL) || (fmt == NULL)) {; 4370 return -2;; 4371 }; 4372 ; 4373 /* Set status (for log) */; 4374 conn->status_code = status;; 4375 ; 4376 /* Errors 1xx, 204 and 304 MUST NOT send a body */; 4377 has_body = ((status > 199) && (status != 204) && (status != 304));; 4378 ; 4379 /* Prepare message in buf, if required */; 4380 if (has_body; 4381 || (!conn->in_error_handler; 4382 && (conn->phys_ctx->callbacks.http_error != NULL))) {; 4383 /* Store error message in errmsg_buf */; 4384 va_copy(ap, args);; 4385 mg_vsnprintf(co",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:130537,log,log,130537,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,1,['log'],['log']
Testability,"odel.reference_data(; ""uniform"", [x.GetName() for x in x_vars], [mu.GetName() for mu in mu_vars], n_samples_train, ""uniform_help""; ); model.preprocessing(); ; # Train the neural network classifier; model.train_classifier(); sbi_model = model; ; ; # Function to compute the likelihood ratio using the trained classifier; def learned_likelihood_ratio(*args):; n = max(*(len(a) for a in args)); X = np.zeros((n, len(args))); for i in range(len(args)):; X[:, i] = args[i]; prob = sbi_model.classifier.predict_proba(X)[:, 1]; return prob / (1.0 - prob); ; ; # Create combined variable list for ROOT; combined_vars = ROOT.RooArgList(); for var in x_vars + mu_vars:; combined_vars.add(var); ; # Create a custom likelihood ratio function using the trained classifier; lhr_learned = ROOT.RooFit.bindFunction(""MyBinFunc"", learned_likelihood_ratio, combined_vars); ; # Calculate the 'analytical' likelihood ratio; lhr_calc = ROOT.RooFormulaVar(""lhr_calc"", ""x[0] / x[1]"", [ws[""gauss""], ws[""uniform""]]); ; # Define the 'analytical' negative logarithmic likelihood ratio; nll_gauss = ws[""gauss""].createNLL(ws[""obs_data""]); ; # Create the learned pdf and NLL sum based on the learned likelihood ratio; pdf_learned = ROOT.RooWrapperPdf(""learned_pdf"", ""learned_pdf"", lhr_learned, True); ; nllr_learned = pdf_learned.createNLL(ws[""obs_data""]); ; # Plot the learned and analytical summed negativelogarithmic likelihood; frame1 = mu_vars[0].frame(; Title=""NLL of SBI vs. Morphing;#mu_{1};NLL"",; Range=(mu_observed[0] - 1, mu_observed[0] + 1),; ); nll_gauss.plotOn(frame1, ShiftToZero=True, LineColor=""kP6Blue+1"", Name=""gauss""); ROOT.RooAbsReal.setEvalErrorLoggingMode(""Ignore"") # Silence some warnings; nll_morph.plotOn(frame1, ShiftToZero=True, LineColor=""kP6Blue+2"", Name=""morph""); ROOT.RooAbsReal.setEvalErrorLoggingMode(""PrintErrors""); nllr_learned.plotOn(frame1, LineColor=""kP6Blue"", ShiftToZero=True, Name=""learned""); ; ; # Declare a helper function in ROOT to dereference unique_ptr; ROOT.gInterpreter.Declare(; """"",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf617__simulation__based__inference__multidimensional_8py.html:8816,log,logarithmic,8816,doc/master/rf617__simulation__based__inference__multidimensional_8py.html,https://root.cern,https://root.cern/doc/master/rf617__simulation__based__inference__multidimensional_8py.html,1,['log'],['logarithmic']
Testability,"odel.summary()"");; ; m.SaveSource(""make_higgs_model.py"");; // execute; auto ret = (TString *)gROOT->ProcessLine(""TMVA::Python_Executable()"");; TString python_exe = (ret) ? *(ret) : ""python"";; gSystem->Exec(python_exe + "" make_higgs_model.py"");; ; if (gSystem->AccessPathName(""Higgs_model.h5"")) {; Warning(""TMVA_Higgs_Classification"", ""Error creating Keras model file - skip using Keras"");; } else {; // book PyKeras method only if Keras model could be created; Info(""TMVA_Higgs_Classification"", ""Booking tf.Keras Dense model"");; factory.BookMethod(; loader, TMVA::Types::kPyKeras, ""PyKeras"",; ""H:!V:VarTransform=None:FilenameModel=Higgs_model.h5:tf.keras:""; ""FilenameTrainedModel=Higgs_trained_model.h5:NumEpochs=20:BatchSize=100:""; ""GpuOptions=allow_growth=True""); // needed for RTX NVidia card and to avoid TF allocates all GPU memory; }; }; ; /**; ## Train Methods; ; Here we train all the previously booked methods.; ; */; ; factory.TrainAllMethods();; ; /**; ## Test all methods; ; Now we test and evaluate all methods using the test data set; */; ; factory.TestAllMethods();; ; factory.EvaluateAllMethods();; ; /// after we get the ROC curve and we display; ; auto c1 = factory.GetROCCurve(loader);; c1->Draw();; ; /// at the end we close the output file which contains the evaluation result of all methods and it can be used by TMVAGUI; /// to display additional plots; ; outputFile->Close();; ; ; }; Double_tdouble Double_tDefinition RtypesCore.h:59; Infovoid Info(const char *location, const char *msgfmt,...)Use this function for informational messages.Definition TError.cxx:218; Errorvoid Error(const char *location, const char *msgfmt,...)Use this function in case an error occurred.Definition TError.cxx:185; Warningvoid Warning(const char *location, const char *msgfmt,...)Use this function in warning situations.Definition TError.cxx:229; gROOT#define gROOTDefinition TROOT.h:406; gSystemR__EXTERN TSystem * gSystemDefinition TSystem.h:561; TCutA specialized string object used for TTr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVA__Higgs__Classification_8C.html:69239,test,test,69239,doc/master/TMVA__Higgs__Classification_8C.html,https://root.cern,https://root.cern/doc/master/TMVA__Higgs__Classification_8C.html,2,['test'],['test']
Testability,"odes=0, Long64_t nevents=1000000, Int_t ntries=2, Int_t start=1, Int_t stop=-1, Int_t step=1, Int_t draw=0, Int_t debug=0); Default constructor. ; ; ~TProofBenchRunCPU () override; Destructor. ; ; voidDrawPerfPlots (); Draw Performance plots. ; ; TCanvas *GetCanvas () const; ; Int_tGetDebug () const; ; TDirectory *GetDirProofBench () const; ; Int_tGetDraw () const; ; TPBHistType *GetHistType () const; ; TList *GetListPerfPlots () const; ; const char *GetName () const override; Returns name of object. ; ; TStringGetNameStem () const; Get name for this run. ; ; Long64_tGetNEvents () const; ; Int_tGetNHists () const; ; Int_tGetNTries () const; ; Int_tGetStart () const; ; Int_tGetStep () const; ; Int_tGetStop () const; ; TClass *IsA () const override; ; voidPrint (Option_t *option="""") const override; Show settings. ; ; voidRun (const char *, Int_t, Int_t, Int_t, Int_t, Int_t, Int_t) override; ; voidRun (Long64_t nevents, Int_t start, Int_t stop, Int_t step, Int_t ntries, Int_t debug, Int_t draw) override; Run benchmark Input parameters nevents: Number of events to run per file. ; ; voidSetDebug (Int_t debug); ; voidSetDirProofBench (TDirectory *dir); ; voidSetDraw (Int_t draw); ; voidSetHistType (TPBHistType *histtype); Set histogram type. ; ; voidSetNEvents (Long64_t nevents); ; voidSetNHists (Int_t nhists); ; voidSetNTries (Int_t ntries); ; voidSetStart (Int_t start); ; voidSetStep (Int_t step); ; voidSetStop (Int_t stop); ; voidStreamer (TBuffer &) override; Stream an object of class TObject. ; ; voidStreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b); ; Public Member Functions inherited from TProofBenchRun; TProofBenchRun (TProof *proof=0, const char *sel=0); Constructor: check PROOF and load selectors PAR. ; ; ~TProofBenchRun () override; destructor ; ; virtual const char *GetParList (); ; virtual const char *GetSelName (); ; virtual voidSetParList (const char *pars); ; virtua",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProofBenchRunCPU.html:1765,benchmark,benchmark,1765,doc/master/classTProofBenchRunCPU.html,https://root.cern,https://root.cern/doc/master/classTProofBenchRunCPU.html,1,['benchmark'],['benchmark']
Testability,"odnamename of the method. ; methodtitlemethod title. . ReturnsTMVA::Experimental::ClassificationResult object for the method. ; Definition at line 970 of file Classification.cxx. GetROC() [1/2]. TMVA::ROCCurve * TMVA::Experimental::Classification::GetROC ; (; TMVA::MethodBase *; method, . UInt_t; iClass = 0, . TMVA::Types::ETreeType; type = TMVA::Types::kTesting. ). protected . Method to get TMVA::ROCCurve Object. ; Parameters. methodTMVA::MethodBase object ; iClasscategory, default 0 then signal ; typetrain/test tree, default test. . ReturnsTMVA::ROCCurve object. ; Definition at line 993 of file Classification.cxx. GetROC() [2/2]. TMVA::ROCCurve * TMVA::Experimental::Classification::GetROC ; (; TString; methodname, . TString; methodtitle, . UInt_t; iClass = 0, . TMVA::Types::ETreeType; type = TMVA::Types::kTesting. ). protected . Method to get TMVA::ROCCurve Object. ; Parameters. methodnameml method name. ; methodtitleml method title. ; iClasscategory, default 0 then signal ; typetrain/test tree, default test. . ReturnsTMVA::ROCCurve object. ; Definition at line 1060 of file Classification.cxx. GetROCIntegral(). Double_t TMVA::Experimental::Classification::GetROCIntegral ; (; TString; methodname, . TString; methodtitle, . UInt_t; iClass = 0. ). protected . Method to get ROC-Integral value from mvas. ; Parameters. methodnameml method name. ; methodtitleml method title. ; iClasscategory, default 0 then signal . ReturnsDouble_t with the ROC-Integral value. ; Definition at line 1074 of file Classification.cxx. HasMethodObject(). Bool_t TMVA::Experimental::Classification::HasMethodObject ; (; TString; methodname, . TString; methodtitle, . Int_t &; index. ). protected . Allows to check if the TMVA::MethodBase was created and return the index in the vector. ; Parameters. methodnamename of the method. ; methodtitlemethod title. ; indexrefrence to Int_t with the position of the method into the vector fIMethods . Returnsboolean true if the method was ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1Experimental_1_1Classification.html:24232,test,test,24232,doc/master/classTMVA_1_1Experimental_1_1Classification.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1Experimental_1_1Classification.html,2,['test'],['test']
Testability,"ods (in particular via the string API). The sampling is provided via these methods:; - TUnuran::Sample() returns a double for all one-dimensional distribution; - TUnuran::SampleDiscr() returns an integer for one-dimensional discrete distribution; - TUnuran::Sample(double *) sample a multi-dimensional distribution. A pointer to a vector with; size at least equal to the distribution dimension must be passed. In addition is possible to set the random number generator in the constructor of the class, its seed; via the TUnuran::SetSeed() method. Function Members (Methods); public:. TUnuran(TRandom* r = 0, unsigned int log = 0); ~TUnuran(); TRandom*GetRandom(); boolInit(const string& distr, const string& method); boolInit(const TUnuranContDist& distr, const string& method = ""auto""); boolInit(const TUnuranMultiContDist& distr, const string& method = ""hitro""); boolInit(const TUnuranDiscrDist& distr, const string& method = ""auto""); boolInit(const TUnuranEmpDist& distr, const string& method = ""empk""); boolInitBinomial(unsigned int ntot, double prob, const string& method = ""dstd""); boolInitPoisson(double mu, const string& method = ""dstd""); const string&MethodName() const; boolReInitDiscrDist(unsigned int npar, double* params); doubleSample(); intSampleDiscr(); boolSampleMulti(double* x); boolSetLogLevel(unsigned int iflag = 1); boolSetLogStream(); voidSetRandom(TRandom* r); voidSetSeed(unsigned int seed). protected:. boolSetContDistribution(const TUnuranContDist& dist); boolSetDiscreteDistribution(const TUnuranDiscrDist& dist); boolSetEmpiricalDistribution(const TUnuranEmpDist& dist); boolSetMethodAndInit(); boolSetMultiDistribution(const TUnuranMultiContDist& dist); boolSetRandomGenerator(). private:. TUnuran(const TUnuran&); TUnuran&operator=(const TUnuran& rhs). Data Members; protected:. auto_ptr<TUnuranBaseDist>fDistpointer for distribution wrapper; unur_gen*fGenpointer to the UnuRan C generator struct; stringfMethodstring representing the method; TRandom*fRngpointer to RO",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TUnuran.html:1804,log,log,1804,root/html528/TUnuran.html,https://root.cern,https://root.cern/root/html528/TUnuran.html,4,['log'],['log']
Testability,"ods. . EnumeratorkAD; kAD2sAnderson-Darling Test. Default value. . kKSAnderson-Darling 2-Samples Test. . kKS2sKolmogorov-Smirnov Test. ; Kolmogorov-Smirnov 2-Samples Test . Definition at line 85 of file GoFTest.h. EUserDistribution. enum ROOT::Math::GoFTest::EUserDistribution. User input distribution option. . EnumeratorkCDF; kPDFInput distribution is a CDF : cumulative distribution function. ; Input distribution is a PDF (Default value) . Definition at line 79 of file GoFTest.h. Constructor & Destructor Documentation. GoFTest() [1/6]. ROOT::Math::GoFTest::GoFTest ; (; size_t; sample1Size, . const Double_t *; sample1, . size_t; sample2Size, . const Double_t *; sample2. ). Constructor for 2-samples tests. ; Definition at line 134 of file GoFTest.cxx. GoFTest() [2/6]. ROOT::Math::GoFTest::GoFTest ; (; size_t; sampleSize, . const Double_t *; sample, . EDistribution; dist = kUndefined, . const std::vector< double > &; distParams = {}. ). Constructor for 1-sample tests with a specified distribution. ; If a specific distribution is not specified it can be set later using SetDistribution. ; Definition at line 161 of file GoFTest.cxx. GoFTest() [3/6]. template<class Dist > . ROOT::Math::GoFTest::GoFTest ; (; size_t; sampleSize, . const Double_t *; sample, . Dist &; dist, . EUserDistribution; userDist = kPDF, . Double_t; xmin = 1, . Double_t; xmax = 0. ). inline . Templated constructor for 1-sample tests with a user specified distribution as a functor object implementing double operator()(double x). ; Definition at line 101 of file GoFTest.h. GoFTest() [4/6]. ROOT::Math::GoFTest::GoFTest ; (; size_t; sampleSize, . const Double_t *; sample, . const IGenFunction &; dist, . EUserDistribution; userDist = kPDF, . Double_t; xmin = 1, . Double_t; xmax = 0. ). inline . Constructor for 1-sample tests with a user specified distribution implementing the ROOT::Math::IGenFunction interface. ; Definition at line 109 of file GoFTest.h. ~GoFTest(). ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1GoFTest.html:9684,test,tests,9684,doc/master/classROOT_1_1Math_1_1GoFTest.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1GoFTest.html,1,['test'],['tests']
Testability,"oduct operator construction. ; Reimplemented from RooAbsArg.; Definition at line 702 of file RooAddModel.cxx. resetErrorCounters(). void RooAddModel::resetErrorCounters ; (; Int_t; resetValue = 10). overridevirtual . Reset error counter to given value, limiting the number of future error messages for this pdf to 'resetValue'. ; Reimplemented from RooAbsPdf.; Definition at line 420 of file RooAddModel.cxx. selectNormalization(). void RooAddModel::selectNormalization ; (; const RooArgSet *; depSet = nullptr, . bool; force = false. ). overrideprotectedvirtual . Interface function used by test statistics to freeze choice of observables for interpretation of fraction coefficients. ; Reimplemented from RooAbsReal.; Definition at line 599 of file RooAddModel.cxx. selectNormalizationRange(). void RooAddModel::selectNormalizationRange ; (; const char *; rangeName = nullptr, . bool; force = false. ). overrideprotectedvirtual . Interface function used by test statistics to freeze choice of range for interpretation of fraction coefficients. ; Reimplemented from RooAbsReal.; Definition at line 621 of file RooAddModel.cxx. selfNormalized(). bool RooAddModel::selfNormalized ; (; ); const. inlineoverridevirtual . Model is self normalized when used as p.d.f. ; Reimplemented from RooAbsPdf.; Definition at line 52 of file RooAddModel.h. Streamer(). void RooAddModel::Streamer ; (; TBuffer &; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from RooAbsPdf. StreamerNVirtual(). void RooAddModel::StreamerNVirtual ; (; TBuffer &; ClassDef_StreamerNVirtual_b). inline . Definition at line 131 of file RooAddModel.h. updateCoefficients(). void RooAddModel::updateCoefficients ; (; AddCacheElem &; cache, . const RooArgSet *; nset. ); const. protected . Update the coefficient values in the given cache element: calculate new remainder fraction, normalize fractions obtained from extended ML terms to unity, and multiply the various range and dimens",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAddModel.html:89779,test,test,89779,doc/master/classRooAddModel.html,https://root.cern,https://root.cern/doc/master/classRooAddModel.html,1,['test'],['test']
Testability,odule(). UpperLimitMCSModule::~UpperLimitMCSModule ; (; ). override . Destructor. ; Definition at line 64 of file UpperLimitMCSModule.cxx. Member Function Documentation. Class(). static TClass * RooStats::UpperLimitMCSModule::Class ; (; ). static . ReturnsTClass describing this class . Class_Name(). static const char * RooStats::UpperLimitMCSModule::Class_Name ; (; ). static . ReturnsName of this class . Class_Version(). static constexpr Version_t RooStats::UpperLimitMCSModule::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 54 of file UpperLimitMCSModule.h. DeclFileName(). static const char * RooStats::UpperLimitMCSModule::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 54 of file UpperLimitMCSModule.h. finalizeRun(). RooDataSet * UpperLimitMCSModule::finalizeRun ; (; ). overridevirtual . Return auxiliary dataset with results of delta(-log(L)) calculations of this module so that it is merged with RooMCStudy::fitParDataSet() by RooMCStudy. ; Reimplemented from RooAbsMCStudyModule.; Definition at line 128 of file UpperLimitMCSModule.cxx. initializeInstance(). bool UpperLimitMCSModule::initializeInstance ; (; ). overridevirtual . Initialize module after attachment to RooMCStudy object. ; Reimplemented from RooAbsMCStudyModule.; Definition at line 87 of file UpperLimitMCSModule.cxx. initializeRun(). bool UpperLimitMCSModule::initializeRun ; (; Int_t; ). overridevirtual . Initialize module at beginning of RooCMStudy run. ; Reimplemented from RooAbsMCStudyModule.; Definition at line 117 of file UpperLimitMCSModule.cxx. IsA(). TClass * RooStats::UpperLimitMCSModule::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from RooAbsMCStudyModule.; Definition at line 54 of file UpperLimitMCSModule.h. processBetweenGenAndFit(). bool UpperLimitMCSModule::processBetweenGenAndFit ; (; Int_t; ). overridev,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooStats_1_1UpperLimitMCSModule.html:16303,log,log,16303,doc/master/classRooStats_1_1UpperLimitMCSModule.html,https://root.cern,https://root.cern/doc/master/classRooStats_1_1UpperLimitMCSModule.html,1,['log'],['log']
Testability,"of ""; 1121 << fTrainingSettings.size() << "":"" << Endl;; 1122 trainingPhase++;; 1123 ; 1124 TNet<TCpu<>> net(settings.batchSize, fNet);; 1125 net.SetWeightDecay(settings.weightDecay);; 1126 net.SetRegularization(settings.regularization);; 1127 // Need to convert dropoutprobabilities to conventions used; 1128 // by backend implementation.; 1129 std::vector<Double_t> dropoutVector(settings.dropoutProbabilities);; 1130 for (auto & p : dropoutVector) {; 1131 p = 1.0 - p;; 1132 }; 1133 net.SetDropoutProbabilities(dropoutVector);; 1134 net.InitializeGradients();; 1135 auto testNet = net.CreateClone(settings.batchSize);; 1136 ; 1137 using DataLoader_t = TDataLoader<TMVAInput_t, TCpu<>>;; 1138 ; 1139 // Split training data into training and validation set; 1140 const std::vector<Event *> &allData = GetEventCollection(Types::kTraining);; 1141 const std::vector<Event *> trainingInputData =; 1142 std::vector<Event *>(allData.begin(), allData.begin() + nTrainingSamples);; 1143 const std::vector<Event *> testInputData =; 1144 std::vector<Event *>(allData.begin() + nTrainingSamples, allData.end());; 1145 ; 1146 if (trainingInputData.size() != nTrainingSamples) {; 1147 Log() << kFATAL << ""Inconsistent training sample size"" << Endl;; 1148 }; 1149 if (testInputData.size() != nTestSamples) {; 1150 Log() << kFATAL << ""Inconsistent test sample size"" << Endl;; 1151 }; 1152 ; 1153 size_t nThreads = 1;; 1154 TMVAInput_t trainingTuple = std::tie(trainingInputData, DataInfo());; 1155 TMVAInput_t testTuple = std::tie(testInputData, DataInfo());; 1156 DataLoader_t trainingData(trainingTuple, nTrainingSamples,; 1157 net.GetBatchSize(), net.GetInputWidth(),; 1158 net.GetOutputWidth(), nThreads);; 1159 DataLoader_t testData(testTuple, nTestSamples, testNet.GetBatchSize(),; 1160 net.GetInputWidth(), net.GetOutputWidth(),; 1161 nThreads);; 1162 DNN::TGradientDescent<TCpu<>> minimizer(settings.learningRate,; 1163 settings.convergenceSteps,; 1164 settings.testInterval);; 1165 ; 1166 std::vector<TNet<T",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/MethodDNN_8cxx_source.html:41187,test,testInputData,41187,doc/master/MethodDNN_8cxx_source.html,https://root.cern,https://root.cern/doc/master/MethodDNN_8cxx_source.html,1,['test'],['testInputData']
Testability,"of a tree using selections.Definition TTree.cxx:7498; TVectorT< Double_t >; TXMLEngineDefinition TXMLEngine.h:26; TXMLEngine::NewChildXMLNodePointer_t NewChild(XMLNodePointer_t parent, XMLNsPointer_t ns, const char *name, const char *content=nullptr)create new child element for parent nodeDefinition TXMLEngine.cxx:715; TXMLEngine::NewAttrXMLAttrPointer_t NewAttr(XMLNodePointer_t xmlnode, XMLNsPointer_t, const char *name, const char *value)creates new attribute for xmlnode, namespaces are not supported for attributesDefinition TXMLEngine.cxx:586; TXMLEngine::AddCommentBool_t AddComment(XMLNodePointer_t parent, const char *comment)Adds comment line to the node.Definition TXMLEngine.cxx:878; bool; double; int; unsigned int; yDouble_t y[n]Definition legend1.C:17; xDouble_t x[n]Definition legend1.C:17; nconst Int_t nDefinition legend1.C:16; TMVA::gConfigConfig & gConfig(); TMVA::gToolsTools & gTools(); TMVA::EndlMsgLogger & Endl(MsgLogger &ml)Definition MsgLogger.h:148; TMath::RMSDouble_t RMS(Long64_t n, const T *a, const Double_t *w=nullptr)Returns the Standard Deviation of an array a with length n.Definition TMath.h:1188; TMath::MaxShort_t Max(Short_t a, Short_t b)Returns the largest of a and b.Definition TMathBase.h:250; TMath::LogDouble_t Log(Double_t x)Returns the natural logarithm of x.Definition TMath.h:756; TMath::SqrtDouble_t Sqrt(Double_t x)Returns the square root of x.Definition TMath.h:662; TMath::MeanDouble_t Mean(Long64_t n, const T *a, const Double_t *w=nullptr)Returns the weighted mean of an array a with length n.Definition TMath.h:1089; TMath::AbsShort_t Abs(Short_t d)Returns the absolute value of parameter Short_t d.Definition TMathBase.h:123; v@ vDefinition rootcling_impl.cxx:3699; vecDefinition civetweb.c:1855; mTMarker mDefinition textangle.C:8; Config.h; Types.h; sumstatic uint64_t sum(uint64_t i)Definition Factory.cxx:2345. tmvatmvasrcTools.cxx. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:01 (GVA Time) using Doxygen 1.9.8 ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/Tools_8cxx_source.html:86459,log,logarithm,86459,doc/master/Tools_8cxx_source.html,https://root.cern,https://root.cern/doc/master/Tools_8cxx_source.html,1,['log'],['logarithm']
Testability,"of available applications. private:. TStringfDefaultPromptdefault prompt: ""root [%d] ""; TFileHandler*fInputHandlerterminal input handler; Bool_tfInterruptif true macro execution will be stopped; Int_tfNcmdcommand history number; charfPrompt[64]interpreter prompt. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TRint(const char* appClassName, int* argc, char** argv, void* options = 0, int numOptions = 0, Bool_t noLogo = kFALSE); Create an application environment. The TRint environment provides an; interface to the WM manager functionality and eventloop via inheritance; of TApplication and in addition provides interactive access to; the CINT C++ interpreter via the command line. ~TRint(); Destructor. void ExecLogon(); Execute logon macro's. There are three levels of logon macros that; will be executed: the system logon etc/system.rootlogon.C, the global; user logon ~/.rootlogon.C and the local ./.rootlogon.C. For backward; compatibility also the logon macro as specified by the Rint.Logon; environment setting, by default ./rootlogon.C, will be executed.; No logon macros will be executed when the system is started with; the -n option. void Run(Bool_t retrn = kFALSE); Main application eventloop. First process files given on the command; line and then go into the main application event loop, unless the -q; command line option was specfied in which case the program terminates.; When retrun is true this method returns even when -q was specified. When QuitOpt is true and retrn is false, terminate the application with; an error code equal to either the ProcessLine error (if any) or the; return value of the command casted to a long. void PrintLogo(Bool_t lite = kFALSE); Print the ROOT logo on standard output. char * GetPrompt(); Get prompt from interpreter. Either ""root [n]"" or ""end with '}'"". const char * SetPrompt(const char* newPrompt); Set a new default prompt. It returns the previous prompt.; The prompt may contain a %d which will",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TRint.html:12997,log,logon,12997,root/html528/TRint.html,https://root.cern,https://root.cern/root/html528/TRint.html,4,['log'],['logon']
Testability,"of background ax parameter;  Double_t; fAyInit; //initial value of background ay; parameter(backgroud is estimated as a0+ax*x+ay*y);  Double_t; fAyCalc; //calculated value of background ay parameter;  Double_t fAyErr;; error value of background ay parameter ;  Bool_t; *fFixPositionX; //[fNPeaks] array of logical values which; allow to fix appropriate x positions of 2D peaks (not fit). However they are; present in the estimated functional;  Bool_t; *fFixPositionY; //[fNPeaks] array of logical values which; allow to fix appropriate y positions of 2D peaks (not fit). However they are; present in the estimated functional;  Bool_t; *fFixPositionX1; //[fNPeaks] array of logical values which; allow to fix appropriate x positions of 1D ridges (not fit). However they are; present in the estimated functional;  Bool_t; *fFixPositionY1; //[fNPeaks] array of logical values which; allow to fix appropriate y positions of 1D ridges (not fit). However they are; present in the estimated functional;  Bool_t; *fFixAmp; //[fNPeaks] array of logical values which; allow to fix appropriate amplitudes of 2D peaks (not fit). However they are; present in the estimated functional;  Bool_t; *fFixAmpX1; //[fNPeaks] array of logical values which; allow to fix appropriate amplitudes of 1D ridges in x direction (not fit).; However they are present in the estimated functional;  Bool_t; *fFixAmpY1; //[fNPeaks] array of logical values which; allow to fix appropriate amplitudes of 1D ridges in y direction (not fit).; However they are present in the estimated functional;  Bool_t; fFixSigmaX; //logical value of sigma x parameter, which; allows to fix the parameter (not to fit).;  Bool_t; fFixSigmaY; //logical value of si",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TSpectrum2Fit.html:47974,log,logical,47974,root/html528/TSpectrum2Fit.html,https://root.cern,https://root.cern/root/html528/TSpectrum2Fit.html,6,['log'],['logical']
Testability,"of bin contents in range [binx1,binx2],[biny1,biny2],[binz1,binz2] for a 3-D histogram By default the integral is computed as the sum of bin contents in the range. ; ; Double_tIntegral (Option_t *option="""") const override; Return integral of bin contents. ; ; virtual Double_tIntegralAndError (Int_t binx1, Int_t binx2, Int_t biny1, Int_t biny2, Int_t binz1, Int_t binz2, Double_t &err, Option_t *option="""") const; Return integral of bin contents in range [binx1,binx2],[biny1,biny2],[binz1,binz2] for a 3-D histogram. ; ; Double_tInterpolate (Double_t x, Double_t y, Double_t z) const override; Given a point P(x,y,z), Interpolate approximates the value via trilinear interpolation based on the 8 nearest bin center points (corner of the cube surrounding the points) The Algorithm is described in http://en.wikipedia.org/wiki/Trilinear_interpolation The given values (x,y,z) must be between first bin center and last bin center for each coordinate: ; ; TClass *IsA () const override; ; Double_tKolmogorovTest (const TH1 *h2, Option_t *option="""") const override; Statistical test of compatibility in shape between THIS histogram and h2, using Kolmogorov test. ; ; virtual TH1 *Project3D (Option_t *option=""x"") const; Project a 3-d histogram into 1 or 2-d histograms depending on the option parameter, which may contain a combination of the characters x,y,z,e. ; ; virtual TProfile2D *Project3DProfile (Option_t *option=""xy"") const; Project a 3-d histogram into a 2-d profile histograms depending on the option parameter option may contain a combination of the characters x,y,z option = ""xy"" return the x versus y projection into a TProfile2D histogram option = ""yx"" return the y versus x projection into a TProfile2D histogram option = ""xz"" return the x versus z projection into a TProfile2D histogram option = ""zx"" return the z versus x projection into a TProfile2D histogram option = ""yz"" return the y versus z projection into a TProfile2D histogram option = ""zy"" return the z v",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTH3.html:7317,test,test,7317,doc/master/classTH3.html,https://root.cern,https://root.cern/doc/master/classTH3.html,2,['test'],['test']
Testability,"of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static Int_tTGScrollBar::fgScrollBarWidth; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel; static TGFrame::(anonymous)TGFrame::kDeleteWindowCalled. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGVScrollBar(const TGWindow* p = 0, UInt_t w = 2, UInt_t h = 4, UInt_t options = kVerticalFrame, Pixel_t back = GetDefaultFrameBackground()); Create a vertical scrollbar. void Layout(); Layout and move vertical scrollbar components. Bool_t HandleButton(Event_t* event); Handle mouse button event in vertical scrollbar. Bool_t HandleMotion(Event_t* event); Handle mouse motion in a vertical scrollbar. void SetRange(Int_t range, Int_t page_size); Set range of vertical scrollbar. void SetPosition(Int_t pos); Set logical slider position of vertical scrollbar. void SavePrimitive(ostream& out, Option_t* option = """"); Save an vertical scrollbar as a C++ statement(s) on output stream out. TGScrollBarElement& operator=(const TGVScrollBar& ). TGDimension GetDefaultSize() const; { return TGDimension(fWidth, GetScrollBarWidth()); }. TGVScrollBar(const TGWindow* p = 0, UInt_t w = 2, UInt_t h = 4, UInt_t options = kVerticalFrame, Pixel_t back = GetDefaultFrameBackground()); { }.  Author: Fons Rademakers 10/01/98  Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *;  Last changed: root/gui:$Id$  Last generated: 2015-06-02 15:58; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TGVScrollBar.html:21728,log,logical,21728,root/html604/TGVScrollBar.html,https://root.cern,https://root.cern/root/html604/TGVScrollBar.html,1,['log'],['logical']
Testability,"of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static Int_tTGScrollBar::fgScrollBarWidth; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel; static TGFrame::(anonymous)TGFrame::kDeleteWindowCalled. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGVScrollBar(const TGWindow* p = 0, UInt_t w = 2, UInt_t h = 4, UInt_t options = kVerticalFrame, Pixel_t back = GetDefaultFrameBackground()); Create a vertical scrollbar. void Layout(); Layout and move vertical scrollbar components. Bool_t HandleButton(Event_t* event); Handle mouse button event in vertical scrollbar. Bool_t HandleMotion(Event_t* event); Handle mouse motion in a vertical scrollbar. void SetRange(Int_t range, Int_t page_size); Set range of vertical scrollbar. void SetPosition(Int_t pos); Set logical slider position of vertical scrollbar. void SavePrimitive(ostream& out, Option_t* option = """"); Save an vertical scrollbar as a C++ statement(s) on output stream out. TGScrollBarElement& operator=(const TGVScrollBar& ). TGDimension GetDefaultSize() const; { return TGDimension(fWidth, GetScrollBarWidth()); }. TGVScrollBar(const TGWindow* p = 0, UInt_t w = 2, UInt_t h = 4, UInt_t options = kVerticalFrame, Pixel_t back = GetDefaultFrameBackground()); { }.  Author: Fons Rademakers 10/01/98  Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *;  Last changed: root/gui:$Id$  Last generated: 2015-06-30 14:58; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGVScrollBar.html:21728,log,logical,21728,root/html602/TGVScrollBar.html,https://root.cern,https://root.cern/root/html602/TGVScrollBar.html,1,['log'],['logical']
Testability,"of events per file; Int_tfNTriesnumber of tries; TStringfNamename of this run; TProofNodes*fNodeslist of nodes information; TProfile*fNorm_queryresult_IO; TProfile*fNorm_queryresult_event; TProfile*fProfile_perfstat_IO; TProfile*fProfile_perfstat_event; TProfile*fProfile_queryresult_IO; TProfile*fProfile_queryresult_event; TProof*fProofpointer to proof; TPBReadType*fReadTyperead type; Int_tfStartstart number of workers; Int_tfSteptest to be performed every fStep workers; Int_tfStopstop number of workers. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TProofBenchRunDataRead(TProofBenchDataSet* pbds, TPBReadType* readtype = 0, TDirectory* dirproofbench = 0, TProof* proof = 0, TProofNodes* nodes = 0, Long64_t nevents = -1, Int_t ntries = 2, Int_t start = 1, Int_t stop = -1, Int_t step = 1, Int_t debug = 0). ~TProofBenchRunDataRead(); Destructor. void Run(const char* dset, Int_t start, Int_t stop, Int_t step, Int_t ntries, Int_t debug, Int_t ); Run benchmark; Input parameters; dset: Dataset on which to run; start: Start scan with 'start' workers.; stop: Stop scan at 'stop workers.; step: Scan every 'step' workers.; ntries: Number of tries. When it is -1, data member fNTries is used.; debug: debug switch.; Int_t: Ignored; Returns; Nothing. TFileCollection * GetDataSet(const char* dset, Int_t nact, Bool_t nx); Get a subsample of dsname suited to run with 'nact' and option 'nx'. void FillPerfStatProfiles(TTree* t, Int_t nactive). void Print(Option_t* option = """") const; Print the content of this object. void DrawPerfProfiles(); Get canvas. TString GetNameStem() const; Get name for this run. Int_t SetParameters(); Set parameters. Int_t DeleteParameters(); Delete parameters set for this run. void BuildHistos(Int_t start, Int_t stop, Int_t step, Bool_t nx); Build histograms, profiles and graphs needed for this run. TProofBenchRunDataRead(TProofBenchDataSet* pbds, TPBReadType* readtype = 0, TDirectory* dirproofbench = 0, TProof* proo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TProofBenchRunDataRead.html:8460,benchmark,benchmark,8460,root/html530/TProofBenchRunDataRead.html,https://root.cern,https://root.cern/root/html530/TProofBenchRunDataRead.html,2,['benchmark'],['benchmark']
Testability,"of file TStatistic.h. GetRMS(). Double_t TStatistic::GetRMS ; (; ); const. inline . Definition at line 60 of file TStatistic.h. GetVar(). Double_t TStatistic::GetVar ; (; ); const. inline . Definition at line 61 of file TStatistic.h. GetW(). Double_t TStatistic::GetW ; (; ); const. inline . Definition at line 62 of file TStatistic.h. GetW2(). Double_t TStatistic::GetW2 ; (; ); const. inline . Definition at line 63 of file TStatistic.h. Hash(). ULong_t TStatistic::Hash ; (; ); const. inlineoverridevirtual . Return hash value for this object. ; Note: If this routine is overloaded in a derived class, this derived class should also add ROOT::CallRecursiveRemoveIfNeeded(*this); ROOT::CallRecursiveRemoveIfNeededvoid CallRecursiveRemoveIfNeeded(TObject &obj)call RecursiveRemove for obj if gROOT is valid and obj.TestBit(kMustCleanup) is true.Definition TROOT.h:395; Otherwise, when RecursiveRemove is called (by ~TObject or example) for this type of object, the transversal of THashList and THashTable containers will will have to be done without call Hash (and hence be linear rather than logarithmic complexity). You will also see warnings like Error in <ROOT::Internal::TCheckHashRecursiveRemoveConsistency::CheckRecursiveRemove>: The class SomeName overrides TObject::Hash but does not call TROOT::RecursiveRemove in its destructor.; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TROOT::RecursiveRemovevoid RecursiveRemove(TObject *obj) overrideRecursively remove this object from the list of Cleanups.Definition TROOT.cxx:2498; TStatistic::HashULong_t Hash() const overrideReturn hash value for this object.Definition TStatistic.h:53. Reimplemented from TObject.; Definition at line 53 of file TStatistic.h. IsA(). TClass * TStatistic::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented fr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTStatistic.html:15582,log,logarithmic,15582,doc/master/classTStatistic.html,https://root.cern,https://root.cern/doc/master/classTStatistic.html,1,['log'],['logarithmic']
Testability,"of function for given set of observables. ; ; const char *getPlotLabel () const; Get the label associated with the variable. ; ; doublegetPropagatedError (const RooFitResult &fr, const RooArgSet &nset={}) const; Propagates parameter uncertainties to an uncertainty estimate for this RooAbsReal. ; ; TStringgetTitle (bool appendUnit=false) const; Return this variable's title string. ; ; const Text_t *getUnit () const; ; doublegetVal (const RooArgSet &normalisationSet) const; Like getVal(const RooArgSet*), but always requires an argument for normalisation. ; ; doublegetVal (const RooArgSet *normalisationSet=nullptr) const; Evaluate object. ; ; virtual doublegetValV (const RooArgSet *normalisationSet=nullptr) const; Return value of object. ; ; virtual voidgradient (double *) const; ; virtual boolhasGradient () const; ; TClass *IsA () const override; ; boolisIdentical (const RooAbsArg &other, bool assumeSameType=false) const override; ; virtual boolisOffsetting () const; ; boolisSelectedComp () const; If true, the current pdf is a selected component (for use in plotting) ; ; voidlogEvalError (const char *message, const char *serverValueString=nullptr) const; Log evaluation error message. ; ; virtual doublemaxVal (Int_t code) const; Return maximum value for set of observables identified by code assigned in getMaxVal. ; ; RooAbsMoment *mean (RooRealVar &obs); ; RooAbsMoment *mean (RooRealVar &obs, const RooArgSet &nset); ; virtual Int_tminTrialSamples (const RooArgSet &) const; ; RooAbsMoment *moment (RooRealVar &obs, const RooArgSet &normObs, Int_t order, bool central, bool takeRoot, bool intNormObs); Return function representing moment of p.d.f (normalized w.r.t given observables) of given order. ; ; RooAbsMoment *moment (RooRealVar &obs, Int_t order, bool central, bool takeRoot); Return function representing moment of function of given order. ; ; virtual doubleoffset () const; ; booloperator== (const RooAbsArg &other",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classParamHistFunc.html:15547,log,logEvalError,15547,doc/master/classParamHistFunc.html,https://root.cern,https://root.cern/doc/master/classParamHistFunc.html,2,['log'],['logEvalError']
Testability,"of peaks ; ; Double_t *fAreaErr; [fNPeaks] array of errors of peak areas ; ; Double_tfBCalc; calculated value of b parameter ; ; Double_tfBErr; error value of b parameter ; ; Double_tfBInit; initial value of b parameter (slope), for details see html manual and references ; ; Double_tfChi; here the fitting functions return resulting chi square ; ; Int_tfFitTaylor; order of Taylor expansion, possible values kFitTaylorOrderFirst, kFitTaylorOrderSecond. It applies only for Awmi fitting function. ; ; Bool_tfFixA0; logical value of a0 parameter, which allows to fix the parameter (not to fit). ; ; Bool_tfFixA1; logical value of a1 parameter, which allows to fix the parameter (not to fit). ; ; Bool_tfFixA2; logical value of a2 parameter, which allows to fix the parameter (not to fit). ; ; Bool_t *fFixAmp; [fNPeaks] array of logical values which allow to fix appropriate amplitudes (not fit). However they are present in the estimated functional ; ; Bool_tfFixB; logical value of b parameter, which allows to fix the parameter (not to fit). ; ; Bool_t *fFixPosition; [fNPeaks] array of logical values which allow to fix appropriate positions (not fit). However they are present in the estimated functional ; ; Bool_tfFixS; logical value of s parameter, which allows to fix the parameter (not to fit). ; ; Bool_tfFixSigma; logical value of sigma parameter, which allows to fix the parameter (not to fit). ; ; Bool_tfFixT; logical value of t parameter, which allows to fix the parameter (not to fit). ; ; Int_tfNPeaks; number of peaks present in fit, input parameter, it should be > 0 ; ; Int_tfNumberIterations; number of iterations in fitting procedure, input parameter, it should be > 0 ; ; Double_t *fPositionCalc; [fNPeaks] array of calculated values of fitted positions, output parameters ; ; Double_t *fPositionErr; [fNPeaks] array of position errors ; ; Double_t *fPositionInit; [fNPeaks] array of initial values of peaks positions,",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSpectrumFit.html:19811,log,logical,19811,doc/master/classTSpectrumFit.html,https://root.cern,https://root.cern/doc/master/classTSpectrumFit.html,1,['log'],['logical']
Testability,"of signals from this object; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static TList*TApplication::fgApplicationsList of available applications. private:. TStringfDefaultPromptdefault prompt: ""root [%d] ""; TFileHandler*fInputHandlerterminal input handler; Bool_tfInterruptif true macro execution will be stopped; Int_tfNcmdcommand history number; charfPrompt[64]interpreter prompt. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TRint(const char* appClassName, int* argc, char** argv, void* options = 0, int numOptions = 0, Bool_t noLogo = kFALSE); Create an application environment. The TRint environment provides an; interface to the WM manager functionality and eventloop via inheritance; of TApplication and in addition provides interactive access to; the CINT C++ interpreter via the command line. ~TRint(); Destructor. void ExecLogon(); Execute logon macro's. There are three levels of logon macros that; will be executed: the system logon etc/system.rootlogon.C, the global; user logon ~/.rootlogon.C and the local ./.rootlogon.C. For backward; compatibility also the logon macro as specified by the Rint.Logon; environment setting, by default ./rootlogon.C, will be executed.; No logon macros will be executed when the system is started with; the -n option. void Run(Bool_t retrn = kFALSE); Main application eventloop. First process files given on the command; line and then go into the main application event loop, unless the -q; command line option was specfied in which case the program terminates.; When retrun is true this method returns even when -q was specified. When QuitOpt is true and retrn is false, terminate the application with; an error code equal to either the ProcessLine error (if any) or the; return value of the command casted to a long. void PrintLogo(Bool_t lite = kFALSE); Print the ROOT logo on standard output. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TRint.html:12773,log,logon,12773,root/html528/TRint.html,https://root.cern,https://root.cern/root/html528/TRint.html,4,['log'],['logon']
Testability,"of the analysis: select relevant; // tree entries, run algorithms on the tree entry and typically fill histograms.; ; // *** 1. *** Tell the reader to load the data for this entry:; fReader.SetEntry(entry);; ; // *** 2. *** Do the actual analysis; int tagMuon = gRandom->Integer(fRaPt.GetSize());; ; if (fRaTriggered[tagMuon]) {; for (int iMuon = 0, nMuons = fRaPt.GetSize(); iMuon < nMuons; ++iMuon) {; // All but the tag muon can be probe muons; if (iMuon != tagMuon) {; 	 // Fill the efficiency object with; 	 // - whether this muon has triggered; 	 // - the pT of this muon.; 	 fEff->Fill(fRaTriggered[iMuon], fRaPt[iMuon]);; }; }; }; ; return kTRUE;; }; ; void TutorialSelector::Terminate(); {; // The Terminate() function is the last function to be called during the; // analysis of a tree with a selector. It always runs on the client, it can; // be used to present the results graphically or save the results to file.; ; fEff->Print();; }. . .  10. Go Parallel!; up; 11. Done! . Navigate through this book; 0. Setting up ROOT; 1. Extracting an object from a TFile; 2. Running code in ROOT; 4. Histogramming; 3. Examining a TTree's data; 5. Fitting; 6. Multivariate Analysis; 7. Using the TTreeReader; 8. Efficiency Calculation; 9. Fitting By Coding; 10. Go Parallel!; TutorialSelector.C; 11. Done!. Sitemap. DownloadDownload ROOT; All Releases. DocumentationReference Manual; User's Guides; HowTo; Courses; Building ROOT; Tutorials; Javascript Root; ROOT and Spark; Publications; FAQ. NewsBlog; Workshops. SupportForum; Bug submission guidelines; Submit a Bug; Discourse Mailing List Mode; RootTalk Digest. AboutLicence; Contact Us; Project Founders; Team; Previous Developers. DevelopmentProgram of Work; Code Owners; Release Checklist; Coding Conventions; Shifter's Instructions; Git Primer; Browse Sources; Meetings; ROOT 7; Run the tests; Jenkins; Setup externals from AFS/CVMFS; Doxygen; Benchmarks. ContributeCollaborate with Us.  Copyright CERN 2014-18. All rights reserved. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/tutorialselectorc.html:6671,test,tests,6671,d/tutorialselectorc.html,https://root.cern,https://root.cern/d/tutorialselectorc.html,1,['test'],['tests']
Testability,"of the minimization interval. . double FValUpper() const; Return function value at current upper bound of the minimization interval. . bool Minimize(int maxIter, double absTol = 1.0E-8, double relTol = 1.0E-10); Find minimum position iterating until convergence specified by the absolute and relative tolerance or; the maximum number of iteration is reached.; Return true if iterations converged successfully; \@param maxIter maximum number of iterations.; \@param absTol desired absolute error in the minimum position (default 1.E-8); \@param absTol desired relative error in the minimum position (default = 1.E-10). int Iterations() const; Return number of iteration used to find minimum . { return fNIter; }. const char * Name() const; Return name of minimization algorithm (""BrentMinimizer1D"") . void SetFunction(const ROOT::Math::IGenFunction& f, double xlow, double xup); Sets function to be minimized. \@param f Function to be minimized.; \@param xlow Lower bound of the search interval.; \@param xup Upper bound of the search interval. void SetNpx(int npx); Set the number of point used to bracket root using a grid . { fNpx = npx; }. void SetLogScan(bool on). Set a log grid scan (default is equidistant bins); will work only if xlow > 0. { fLogScan = on; }. int Status() const; Returns status of last estimate. If = 0 is OK . { return fStatus; }. void SetDefaultNpx(int npx); static function used to modify the default parameters; set number of default Npx used at construction time (when SetNpx is not called); Default value is 100. void SetDefaultNSearch(int n); set number of times the bracketing search in combination with is done to find a good interval; Default value is 10.  Author: David Gonzalez Maline 2/2008  Copyright (c) 2004 Maline, CERN/PH-SFT *;  Last changed: root/mathcore:$Id$  Last generated: 2015-06-30 14:21; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/ROOT__Math__BrentMinimizer1D.html:4814,log,log,4814,root/html602/ROOT__Math__BrentMinimizer1D.html,https://root.cern,https://root.cern/root/html602/ROOT__Math__BrentMinimizer1D.html,1,['log'],['log']
Testability,"of the minimization interval. . double FValUpper() const; Return function value at current upper bound of the minimization interval. . bool Minimize(int maxIter, double absTol = 1.0E-8, double relTol = 1.0E-10); Find minimum position iterating until convergence specified by the absolute and relative tolerance or; the maximum number of iteration is reached.; Return true if iterations converged successfully; \@param maxIter maximum number of iterations.; \@param absTol desired absolute error in the minimum position (default 1.E-8); \@param absTol desired relative error in the minimum position (default = 1.E-10). int Iterations() const; Return number of iteration used to find minimum . { return fNIter; }. const char * Name() const; Return name of minimization algorithm (""BrentMinimizer1D"") . void SetFunction(const ROOT::Math::IGenFunction& f, double xlow, double xup); Sets function to be minimized. \@param f Function to be minimized.; \@param xlow Lower bound of the search interval.; \@param xup Upper bound of the search interval. void SetNpx(int npx); Set the number of point used to bracket root using a grid . { fNpx = npx; }. void SetLogScan(bool on). Set a log grid scan (default is equidistant bins); will work only if xlow > 0. { fLogScan = on; }. int Status() const; Returns status of last estimate. If = 0 is OK . { return fStatus; }. void SetDefaultNpx(int npx); static function used to modify the default parameters; set number of default Npx used at construction time (when SetNpx is not called); Default value is 100. void SetDefaultNSearch(int n); set number of times the bracketing search in combination with is done to find a good interval; Default value is 10.  Author: David Gonzalez Maline 2/2008  Copyright (c) 2004 Maline, CERN/PH-SFT *;  Last changed: root/mathcore:$Id$  Last generated: 2015-09-08 17:33; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/ROOT__Math__BrentMinimizer1D.html:4814,log,log,4814,root/html604/ROOT__Math__BrentMinimizer1D.html,https://root.cern,https://root.cern/root/html604/ROOT__Math__BrentMinimizer1D.html,1,['log'],['log']
Testability,"of this class ; Definition at line 39 of file TASImagePlugin.h. DeclFileName(). static const char * TASImagePlugin::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 39 of file TASImagePlugin.h. File2ASImage(). virtual ASImage * TASImagePlugin::File2ASImage ; (; const char *; ). inlinevirtual . Reimplemented in TASPluginGS.; Definition at line 36 of file TASImagePlugin.h. Hash(). ULong_t TASImagePlugin::Hash ; (; ); const. inlineoverridevirtual . Return hash value for this object. ; Note: If this routine is overloaded in a derived class, this derived class should also add ROOT::CallRecursiveRemoveIfNeeded(*this); ROOT::CallRecursiveRemoveIfNeededvoid CallRecursiveRemoveIfNeeded(TObject &obj)call RecursiveRemove for obj if gROOT is valid and obj.TestBit(kMustCleanup) is true.Definition TROOT.h:395; Otherwise, when RecursiveRemove is called (by ~TObject or example) for this type of object, the transversal of THashList and THashTable containers will will have to be done without call Hash (and hence be linear rather than logarithmic complexity). You will also see warnings like Error in <ROOT::Internal::TCheckHashRecursiveRemoveConsistency::CheckRecursiveRemove>: The class SomeName overrides TObject::Hash but does not call TROOT::RecursiveRemove in its destructor.; TASImagePlugin::HashULong_t Hash() const overrideReturn hash value for this object.Definition TASImagePlugin.h:32; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TROOT::RecursiveRemovevoid RecursiveRemove(TObject *obj) overrideRecursively remove this object from the list of Cleanups.Definition TROOT.cxx:2498. Reimplemented from TObject.; Reimplemented in TASPluginGS.; Definition at line 32 of file TASImagePlugin.h. IsA(). TClass * TASImagePlugin::IsA ; (; ); const. inlineoverridevirtual . ReturnsTCla",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTASImagePlugin.html:12813,log,logarithmic,12813,doc/master/classTASImagePlugin.html,https://root.cern,https://root.cern/doc/master/classTASImagePlugin.html,1,['log'],['logarithmic']
Testability,"of::ShowDataSets ; (; const char *; uri = """", . const char *; optStr = """". ). virtual . Shows datasets in locations that match the uri. ; By default shows the user's datasets and global ones ; Reimplemented in TProofLite.; Definition at line 10846 of file TProof.cxx. ShowEnabledPackages(). void TProof::ShowEnabledPackages ; (; Bool_t; all = kFALSE). List which packages are enabled. ; If all is true show enabled packages for all active slaves. If everything is ok all active slaves should have the same packages enabled. ; Definition at line 7818 of file TProof.cxx. ShowFeedback(). void TProof::ShowFeedback ; (; ); const. Show items in feedback list. ; Definition at line 10020 of file TProof.cxx. ShowLog() [1/2]. void TProof::ShowLog ; (; const char *; queryref). Display on screen the content of the temporary log file for query in reference. ; Definition at line 10338 of file TProof.cxx. ShowLog() [2/2]. void TProof::ShowLog ; (; Int_t; qry = -1). Display on screen the content of the temporary log file. ; If qry == -2 show messages from the last (current) query. If qry == -1 all the messages not yet displayed are shown (default). If qry == 0, all the messages in the file are shown. If qry > 0, only the messages related to query 'qry' are shown. For qry != -1 the original file offset is restored at the end ; Definition at line 10371 of file TProof.cxx. ShowMissingFiles(). void TProof::ShowMissingFiles ; (; TQueryResult *; qr = 0). Show information about missing files during query described by 'qr' or the last query if qr is null (default). ; A short summary is printed in the end. ; Definition at line 12522 of file TProof.cxx. ShowPackages(). void TProof::ShowPackages ; (; Bool_t; all = kFALSE, . Bool_t; redirlog = kFALSE. ). List contents of package directory. ; If all is true show all package directories also on slaves. If everything is ok all package directories should be the same. If redir is kTRUE the result is redirected to the log file (option",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProof.html:150104,log,log,150104,doc/master/classTProof.html,https://root.cern,https://root.cern/doc/master/classTProof.html,1,['log'],['log']
Testability,"ofMgr::AttachSession ; (; TProofDesc *; d, . Bool_t; = kFALSE. ). virtual . Dummy version provided for completeness. ; Just returns a pointer to existing session 'id' (as shown by TProof::QuerySessions) or 0 if 'id' is not valid. ; Definition at line 139 of file TProofMgr.cxx. Class(). static TClass * TProofMgr::Class ; (; ). static . ReturnsTClass describing this class . Class_Name(). static const char * TProofMgr::Class_Name ; (; ). static . ReturnsName of this class . Class_Version(). static constexpr Version_t TProofMgr::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 136 of file TProofMgr.h. Close(). void TProofMgr::Close ; (; ). inline . Definition at line 79 of file TProofMgr.h. Cp(). virtual Int_t TProofMgr::Cp ; (; const char *; , . const char *; = 0, . const char *; = 0. ). inlinevirtual . Definition at line 112 of file TProofMgr.h. Create(). TProofMgr * TProofMgr::Create ; (; const char *; url, . Int_t; loglevel = -1, . const char *; alias = 0, . Bool_t; xpd = kTRUE. ). static . Static method returning the appropriate TProofMgr object using the plugin manager. ; Definition at line 499 of file TProofMgr.cxx. CreateSession(). TProof * TProofMgr::CreateSession ; (; const char *; cfg = 0, . const char *; cfgdir = 0, . Int_t; loglevel = -1. ). virtual . Create a new remote session (master and associated workers). ; Reimplemented in TProofMgrLite.; Definition at line 387 of file TProofMgr.cxx. DeclFileName(). static const char * TProofMgr::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 136 of file TProofMgr.h. DetachSession() [1/2]. void TProofMgr::DetachSession ; (; Int_t; id, . Option_t *; opt = """". ). virtual . Detach session with 'id' from its proofserv. ; The 'id' is the number shown by QuerySessions. The correspondent TProof object is deleted. If id == 0 all the known sessions are detached. Option opt=""S"" o",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProofMgr.html:18855,log,loglevel,18855,doc/master/classTProofMgr.html,https://root.cern,https://root.cern/doc/master/classTProofMgr.html,1,['log'],['loglevel']
Testability,"og10(Hparam.ymax);; 10605 }; 10606 ; 10607 ; 10608 // ----------------- Compute Z axis parameters; 10609 Double_t bigp = TMath::Power(10,32);; 10610 zmax = -bigp;; 10611 zmin = bigp;; 10612 Double_t c1, e1;; 10613 Double_t allchan = 0;; 10614 for (Int_t j=Hparam.yfirst; j<=Hparam.ylast;j++) {; 10615 for (Int_t i=Hparam.xfirst; i<=Hparam.xlast;i++) {; 10616 c1 = fH->GetBinContent(i,j);; 10617 zmax = TMath::Max(zmax,c1);; 10618 if (Hoption.Error) {; 10619 e1 = fH->GetBinError(i,j);; 10620 zmax = TMath::Max(zmax,c1+e1);; 10621 }; 10622 zmin = TMath::Min(zmin,c1);; 10623 allchan += c1;; 10624 }; 10625 }; 10626 ; 10627 // Take into account maximum , minimum; 10628 ; 10629 if (maximum) zmax = fH->GetMaximumStored();; 10630 if (minimum) zmin = fH->GetMinimumStored();; 10631 if (Hoption.Logz && zmax < 0) {; 10632 if (!Hoption.Same) Error(where, ""log scale is requested but maximum is less or equal 0 (%f)"", zmax);; 10633 return 0;; 10634 } else if (Hoption.Logz && zmin>=0 && zmax==0) { // empty histogram in log scale; 10635 zmin = 0.01;; 10636 zmax = 10.;; 10637 }; 10638 if (zmin >= zmax) {; 10639 if (Hoption.Logz) {; 10640 if (zmax > 0) zmin = 0.001*zmax;; 10641 else {; 10642 if (!Hoption.Same) Error(where, ""log scale is requested but maximum is less or equal 0 (%f)"", zmax);; 10643 return 0;; 10644 }; 10645 }; 10646 }; 10647 ; 10648 // take into account normalization factor; 10649 Hparam.allchan = allchan;; 10650 Double_t factor = allchan;; 10651 if (fH->GetNormFactor() > 0) factor = fH->GetNormFactor();; 10652 if (allchan) factor /= allchan;; 10653 if (factor == 0) factor = 1;; 10654 Hparam.factor = factor;; 10655 zmax = factor*zmax;; 10656 zmin = factor*zmin;; 10657 c1 = zmax;; 10658 if (TMath::Abs(zmin) > TMath::Abs(c1)) c1 = zmin;; 10659 ; 10660 // For log scales, histogram coordinates are log10(ymin) and; 10661 // log10(ymax). Final adjustment (if not option ""Same""); 10662 // or ""+"" for ymax) of ymax and ymin for logarithmic scale, if; 10663 // Maximum and Minimum are n",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/THistPainter_8cxx_source.html:382177,log,log,382177,doc/master/THistPainter_8cxx_source.html,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html,1,['log'],['log']
Testability,ogger ; (; const MsgLogger &; parent). copy constructor ; Definition at line 108 of file MsgLogger.cxx. ~MsgLogger(). TMVA::MsgLogger::~MsgLogger ; (; ). destructor ; Definition at line 121 of file MsgLogger.cxx. Member Function Documentation. Class(). static TClass * TMVA::MsgLogger::Class ; (; ). static . ReturnsTClass describing this class . Class_Name(). static const char * TMVA::MsgLogger::Class_Name ; (; ). static . ReturnsName of this class . Class_Version(). static constexpr Version_t TMVA::MsgLogger::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 121 of file MsgLogger.h. DeclFileName(). static const char * TMVA::MsgLogger::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 121 of file MsgLogger.h. EnableOutput(). void TMVA::MsgLogger::EnableOutput ; (; ). static . Definition at line 68 of file MsgLogger.cxx. Endmsg(). TMVA::MsgLogger & TMVA::MsgLogger::Endmsg ; (; MsgLogger &; logger). static . end line ; Definition at line 261 of file MsgLogger.cxx. GetFormattedSource(). std::string TMVA::MsgLogger::GetFormattedSource ; (; ); const. make sure the source name is no longer than fgMaxSourceSize: ; Definition at line 143 of file MsgLogger.cxx. GetMaxSourceSize(). UInt_t TMVA::MsgLogger::GetMaxSourceSize ; (; ). static . returns the maximum source size ; Definition at line 165 of file MsgLogger.cxx. GetMinType(). EMsgType TMVA::MsgLogger::GetMinType ; (; ); const. inline . Definition at line 69 of file MsgLogger.h. GetPrintedSource(). std::string TMVA::MsgLogger::GetPrintedSource ; (; ); const. the full logger prefix ; Definition at line 173 of file MsgLogger.cxx. GetSource(). std::string TMVA::MsgLogger::GetSource ; (; ); const. inline . Definition at line 71 of file MsgLogger.h. InhibitOutput(). void TMVA::MsgLogger::InhibitOutput ; (; ). static . Definition at line 67 of file MsgLogger.cxx. InitMaps(). void TMVA::MsgLo,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1MsgLogger.html:14069,log,logger,14069,doc/master/classTMVA_1_1MsgLogger.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1MsgLogger.html,1,['log'],['logger']
Testability,"ogger << "" \\:\\ \\ /::| | /:/ / /::\\ \\ "" << Endl;; 1358 logger << "" \\:\\ \\ /:|:| | /:/ / /:/\\:\\ \\ "" << Endl;; 1359 logger << "" /::\\ \\ /:/|:|__|__ /:/__/ ___ /::\\~\\:\\ \\ "" << Endl;; 1360 logger << "" /:/\\:\\__\\ /:/ |::::\\__\\ |:| | /\\__\\ /:/\\:\\ \\:\\__\\ "" << Endl;; 1361 logger << "" /:/ \\/__/ \\/__/~~/:/ / |:| |/:/ / \\/__\\:\\/:/ / "" << Endl;; 1362 logger << ""/:/ / /:/ / |:|__/:/ / \\::/ / "" << Endl;; 1363 logger << ""\\/__/ /:/ / \\::::/__/ /:/ / "" << Endl;; 1364 logger << "" /:/ / ~~~~ /:/ / "" << Endl;; 1365 logger << "" \\/__/ \\/__/ "" << Endl << Endl;; 1366 break;; 1367 ; 1368 case kBlockWelcomeMsg:; 1369 logger << Endl;; 1370 logger << ""_|_|_|_|_| _| _| _| _| _|_| "" << Endl;; 1371 logger << "" _| _|_| _|_| _| _| _| _| "" << Endl;; 1372 logger << "" _| _| _| _| _| _| _|_|_|_| "" << Endl;; 1373 logger << "" _| _| _| _| _| _| _| "" << Endl;; 1374 logger << "" _| _| _| _| _| _| "" << Endl << Endl;; 1375 break;; 1376 ; 1377 case kLeanWelcomeMsg:; 1378 logger << Endl;; 1379 logger << ""_/_/_/_/_/ _/ _/ _/ _/ _/_/ "" << Endl;; 1380 logger << "" _/ _/_/ _/_/ _/ _/ _/ _/ "" << Endl;; 1381 logger << "" _/ _/ _/ _/ _/ _/ _/_/_/_/ "" << Endl;; 1382 logger << "" _/ _/ _/ _/ _/ _/ _/ "" << Endl;; 1383 logger << ""_/ _/ _/ _/ _/ _/ "" << Endl << Endl;; 1384 break;; 1385 ; 1386 case kLogoWelcomeMsg:; 1387 logger << Endl;; 1388 logger << ""_/_/_/_/_/ _| _| _| _| _|_| "" << Endl;; 1389 logger << "" _/ _|_| _|_| _| _| _| _| "" << Endl;; 1390 logger << "" _/ _| _| _| _| _| _|_|_|_| "" << Endl;; 1391 logger << "" _/ _| _| _| _| _| _| "" << Endl;; 1392 logger << ""_/ _| _| _| _| _| "" << Endl << Endl;; 1393 break;; 1394 ; 1395 case kSmall1WelcomeMsg:; 1396 logger << "" _____ __ ____ ___ "" << Endl;; 1397 logger << ""|_ _| \\/ \\ \\ / /_\\ "" << Endl;; 1398 logger << "" | | | |\\/| |\\ V / _ \\ "" << Endl;; 1399 logger << "" |_| |_| |_| \\_/_/ \\_\\"" << Endl << Endl;; 1400 break;; 1401 ; 1402 case kSmall2WelcomeMsg:; 1403 logger << "" _____ __ ____ ___ "" << Endl;; 1404 logger << ""|_ _| \\/ \\ \\ / / \\ ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/Tools_8cxx_source.html:48659,log,logger,48659,doc/master/Tools_8cxx_source.html,https://root.cern,https://root.cern/doc/master/Tools_8cxx_source.html,1,['log'],['logger']
Testability,ogger::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 121 of file MsgLogger.h. EnableOutput(). void TMVA::MsgLogger::EnableOutput ; (; ). static . Definition at line 68 of file MsgLogger.cxx. Endmsg(). TMVA::MsgLogger & TMVA::MsgLogger::Endmsg ; (; MsgLogger &; logger). static . end line ; Definition at line 261 of file MsgLogger.cxx. GetFormattedSource(). std::string TMVA::MsgLogger::GetFormattedSource ; (; ); const. make sure the source name is no longer than fgMaxSourceSize: ; Definition at line 143 of file MsgLogger.cxx. GetMaxSourceSize(). UInt_t TMVA::MsgLogger::GetMaxSourceSize ; (; ). static . returns the maximum source size ; Definition at line 165 of file MsgLogger.cxx. GetMinType(). EMsgType TMVA::MsgLogger::GetMinType ; (; ); const. inline . Definition at line 69 of file MsgLogger.h. GetPrintedSource(). std::string TMVA::MsgLogger::GetPrintedSource ; (; ); const. the full logger prefix ; Definition at line 173 of file MsgLogger.cxx. GetSource(). std::string TMVA::MsgLogger::GetSource ; (; ); const. inline . Definition at line 71 of file MsgLogger.h. InhibitOutput(). void TMVA::MsgLogger::InhibitOutput ; (; ). static . Definition at line 67 of file MsgLogger.cxx. InitMaps(). void TMVA::MsgLogger::InitMaps ; (; ). private . Create the message type and color maps. ; Definition at line 270 of file MsgLogger.cxx. IsA(). virtual TClass * TMVA::MsgLogger::IsA ; (; ); const. inlinevirtual . ReturnsTClass describing current object ; Reimplemented from TObject.; Definition at line 121 of file MsgLogger.h. operator<<() [1/5]. MsgLogger & TMVA::MsgLogger::operator<< ; (; EMsgType; type). inline . Definition at line 141 of file MsgLogger.h. operator<<() [2/5]. MsgLogger & TMVA::MsgLogger::operator<< ; (; MsgLogger &(*)(MsgLogger &); _f). inline . Definition at line 124 of file MsgLogger.h. operator<<() [3/5]. MsgLogger & TMVA::MsgLogger::operator<< ; (; std::ios &(*)(std::i,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1MsgLogger.html:14712,log,logger,14712,doc/master/classTMVA_1_1MsgLogger.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1MsgLogger.html,1,['log'],['logger']
Testability,"ogram with box sizes proportional to histogram bin entries.; This plot shows that for lower pT most muons are not triggered, while for higher pT most muons are triggered. The efficiency is thus rising with pT. We will study this in more detail in the following steps.; Multivariate Analysis with TMVA; Now let's assume we want to see whether the muon trigger also depends on the muon X position, i.e. whether it fires more often for instance when the muon was created farther away from the beam pipe. This would mean that there is e.g. a linear correlation between the muon trigger and the position.; ROOT offers TMVA, a tool widely used in physics analyses for analyzing higher dimensional dependencies. We recommend that you put the following statements into a source file that you then run in ROOT; // Put into the file trigParam.C; // which #includes do you need?; #include ...; void trigParam() {; // The location of the input data; TFile* infile = TFile::Open(""http://root.cern.ch/root/files/tutorials/mockupx.root"");; TTree* tree = 0;; infile->GetObject(""MyTree"", tree);. // The output file, it will hold the results of TMVA's work.; TFile* outputFile = TFile::Open(""mutrig.root"", ""RECREATE"" );. // Create a TMVA analysis; TMVA::Factory *factory = new TMVA::Factory(""MuonTrigger"", outputFile,; ""!V:!Silent:Color:DrawProgressBar:Transformations=I;D;P;G,D:AnalysisType=Classification"" );. // Add a few variables to study - let's see which one TMVA finds relevant:; factory->AddVariable( ""muons.fPt"", 'F' );; factory->AddVariable( ""muons.fE"", 'F' );; factory->AddVariable( ""muons.fVertex.fX"", 'F' );; factory->AddVariable( ""muons.fTriggered"", 'F' );. // Usually TMVA can predict whether an event belongs to ""signal"" or ""background"":; // it determines that based on the valued of the parameters we selected above.; // We don't really want to know that ""signal"" / ""background"" thing: we just ""mis""-use; // TMVA to analyze the parameter correlations. Nonetheless, let's just define signal; // and ba",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/6-multivariate-analysis.html:3647,mock,mockupx,3647,d/6-multivariate-analysis.html,https://root.cern,https://root.cern/d/6-multivariate-analysis.html,1,['mock'],['mockupx']
Testability,"ograms.; 1759///; 1760/// #### Overview:; 1761///; 1762/// Comparison of two histograms expect hypotheses that two histograms; 1763/// represent identical distributions. To make a decision p-value should; 1764/// be calculated. The hypotheses of identity is rejected if the p-value is; 1765/// lower then some significance level. Traditionally significance levels; 1766/// 0.1, 0.05 and 0.01 are used. The comparison procedure should include an; 1767/// analysis of the residuals which is often helpful in identifying the; 1768/// bins of histograms responsible for a significant overall \f$ \chi^{2} \f$ value.; 1769/// Residuals are the difference between bin contents and expected bin; 1770/// contents. Most convenient for analysis are the normalized residuals. If; 1771/// hypotheses of identity are valid then normalized residuals are; 1772/// approximately independent and identically distributed random variables; 1773/// having N(0,1) distribution. Analysis of residuals expect test of above; 1774/// mentioned properties of residuals. Notice that indirectly the analysis; 1775/// of residuals increase the power of \f$ \chi^{2} \f$ test.; 1776///; 1777/// #### Methods of comparison:; 1778///; 1779/// \f$ \chi^{2} \f$ test for comparison two (unweighted) histograms:; 1780/// Let us consider two histograms with the same binning and the number; 1781/// of bins equal to r. Let us denote the number of events in the ith bin; 1782/// in the first histogram as ni and as mi in the second one. The total; 1783/// number of events in the first histogram is equal to:; 1784/// \f[; 1785/// N = \sum_{i=1}^{r} n_{i}; 1786/// \f]; 1787/// and; 1788/// \f[; 1789/// M = \sum_{i=1}^{r} m_{i}; 1790/// \f]; 1791/// in the second histogram. The hypothesis of identity (homogeneity) [3]; 1792/// is that the two histograms represent random values with identical; 1793/// distributions. It is equivalent that there exist r constants p1,...,pr,; 1794/// such that; 1795/// \f[; 1796///\sum_{i=1}^{r} p_{i}",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TH1_8cxx_source.html:69375,test,test,69375,doc/master/TH1_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html,1,['test'],['test']
Testability,"ogressDialog *d, Int_t w=700, Int_t h=600); Create a window frame for log messages. ; ; ~TProofProgressLog () override; Destructor. ; ; voidAddBuffer (const char *buffer); Add text to the window. ; ; voidBuildLogList (Bool_t create=kFALSE); Build the list of workers. ; ; voidClear (Option_t *=nullptr) override; Clear log window. ; ; voidCloseWindow () override; Handle close button or when closed via window manager action. ; ; voidDoLog (Bool_t grep=kFALSE); Display logs. ; ; TClass *IsA () const override; ; voidLoadBuffer (const char *buffer); Load a text buffer in the window. ; ; voidLoadFile (const char *file); Load a file in the window. ; ; voidLogMessage (const char *msg, Bool_t all); Load/append a log msg in the log frame, if open. ; ; voidNoLineEntry (); Enable/disable the line number entry. ; ; voidPopup (); Show log window. ; ; voidRebuild (); Rebuild the log info for a new entered session. ; ; voidSaveToFile (); Save the logs to a file Only the name of the file is taken, no expansion. ; ; voidSelect (Int_t id, Bool_t all=kTRUE); actions of select all/clear all button ; ; voidSetGrepView (); Sets the view of grep filters according to the value of checkboxes. ; ; voidSetUrl (const char *url); ; voidStreamer (TBuffer &) override; Stream an object of class TObject. ; ; voidStreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b); ; Public Member Functions inherited from TGTransientFrame; TGTransientFrame (const TGWindow *p=nullptr, const TGWindow *main=nullptr, UInt_t w=1, UInt_t h=1, UInt_t options=kVerticalFrame); Create a transient window. ; ; virtual voidCenterOnParent (Bool_t croot=kTRUE, EPlacement pos=kCenter); Position transient frame centered relative to the parent frame. ; ; const TGWindow *GetMain () const; ; voidSavePrimitive (std::ostream &out, Option_t *option="""") override; Save a transient frame widget as a C++ statement(s) on output stream out. ; ; voidSaveSource (const char *fi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProofProgressLog.html:1717,log,logs,1717,doc/master/classTProofProgressLog.html,https://root.cern,https://root.cern/doc/master/classTProofProgressLog.html,1,['log'],['logs']
Testability,"oid TProof::SetPlayer ; (; TVirtualProofPlayer *; player). protected . Set a new PROOF player. ; Definition at line 10199 of file TProof.cxx. SetPrintProgress(). void TProof::SetPrintProgress ; (; PrintProgress_t; pp). inline . Definition at line 1046 of file TProof.h. SetProgressDialog(). void TProof::SetProgressDialog ; (; Bool_t; on = kTRUE). Enable/Disable the graphic progress dialog. ; By default the dialog is enabled ; Definition at line 12509 of file TProof.cxx. SetQueryMode(). void TProof::SetQueryMode ; (; EQueryMode; mode). Change query running mode to the one specified by 'mode'. ; Definition at line 6107 of file TProof.cxx. SetRealTimeLog(). void TProof::SetRealTimeLog ; (; Bool_t; on = kTRUE). Switch ON/OFF the real-time logging facility. ; When this option is ON, log messages from processing are sent back as they come, instead of being sent back at the end in one go. This may help debugging or monitoring in some cases, but, depending on the amount of log, it may have significant consequencies on the load over the network, so it must be used with care. ; Definition at line 7096 of file TProof.cxx. SetRunStatus(). void TProof::SetRunStatus ; (; ERunStatus; rst). inlineprivate . Definition at line 672 of file TProof.h. SetupWorkersEnv(). void TProof::SetupWorkersEnv ; (; TList *; wrks, . Bool_t; increasingpool = kFALSE. ). protected . Set up packages, loaded macros, include and lib paths ... ; Definition at line 1528 of file TProof.cxx. ShowCache(). void TProof::ShowCache ; (; Bool_t; all = kFALSE). virtual . List contents of file cache. ; If all is true show all caches also on slaves. If everything is ok all caches are to be the same. ; Reimplemented in TProofLite.; Definition at line 7691 of file TProof.cxx. ShowData(). void TProof::ShowData ; (; ). virtual . List contents of the data directory in the sandbox. ; This is the place where files produced by the client queries are kept ; Reimplemented in TProofLite.; Definition at l",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProof.html:147325,log,log,147325,doc/master/classTProof.html,https://root.cern,https://root.cern/doc/master/classTProof.html,1,['log'],['log']
Testability,"oid UpdateListOfProofs(); Update list of existing Proof sessions. void UpdateListOfSessions(); Update list of existing Proof sessions. void WriteConfiguration(const char* filename = 0); Save actual configuration in config file ""filename"". void Build(); Build main session viewer frame and subframes. ~TSessionViewer(); Destructor. void OnListTreeClicked(TGListTreeItem* entry, Int_t btn, Int_t x, Int_t y); Handle mouse clicks in list tree. void OnListTreeDoubleClicked(TGListTreeItem* entry, Int_t btn); Handle mouse double clicks in list tree (connect to server). void Terminate(); Terminate Session : save configuration, clean temporary files and close; Proof connections. void CloseWindow(); Close main Session Viewer window. void ChangeRightLogo(const char* name); Change the right logo (used for animation). void EnableTimer(); Enable animation timer. void DisableTimer(); Disable animation timer. Bool_t HandleTimer(TTimer* ); Handle animation timer. void LogMessage(const char* msg, Bool_t all); Load/append a log msg in the log frame. void QueryResultReady(char* query); Handle signal ""query result ready"" coming from Proof session. void CleanupSession(); Clean-up Proof session. void ResetSession(); Reset Proof session. void DeleteQuery(); Delete query from list tree and ask user if he wants do delete it also; from server. void EditQuery(); Edit currently selected query. void StartViewer(); Start TreeViewer from selected TChain. void ShowPackages(); Query the list of uploaded packages from proof and display it; into a new text window. void UpdateListOfPackages(); Update the list of packages. void ShowEnabledPackages(); Query list of enabled packages from proof and display it; into a new text window. void ShowLog(const char* queryref); Display the content of the temporary log file for queryref; into a new text window. void ShowInfo(const char* txt); Display text in status bar. void ShowStatus(); Retrieve and display Proof status. void StartupMessage(char* msg, Bool_t stat, In",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TSessionViewer.html:26816,log,log,26816,root/html528/TSessionViewer.html,https://root.cern,https://root.cern/root/html528/TSessionViewer.html,8,['log'],['log']
Testability,"oid UpdateListOfProofs(); Update list of existing Proof sessions. void UpdateListOfSessions(); Update list of existing Proof sessions. void WriteConfiguration(const char* filename = 0); Save actual configuration in config file ""filename"". void Build(); Build main session viewer frame and subframes. ~TSessionViewer(); Destructor. void OnListTreeClicked(TGListTreeItem* entry, Int_t btn, Int_t x, Int_t y); Handle mouse clicks in list tree. void OnListTreeDoubleClicked(TGListTreeItem* entry, Int_t btn); Handle mouse double clicks in list tree (connect to server). void Terminate(); Terminate Session : save configuration, clean temporary files and close; Proof connections. void CloseWindow(); Close main Session Viewer window. void ChangeRightLogo(const char* name); Change the right logo (used for animation). void EnableTimer(); Enable animation timer. void DisableTimer(); Disable animation timer. Bool_t HandleTimer(TTimer* ); Handle animation timer. void LogMessage(const char* msg, Bool_t all); Load/append a log msg in the log frame. void QueryResultReady(char* query); Handle signal ""query result ready"" coming from Proof session. void CleanupSession(); Clean-up Proof session. void ResetSession(); Reset Proof session. void DeleteQuery(); Delete query from list tree and ask user if they want to delete it also; from server. void EditQuery(); Edit currently selected query. void StartViewer(); Start TreeViewer from selected TChain. void ShowPackages(); Query the list of uploaded packages from proof and display it; into a new text window. void UpdateListOfPackages(); Update the list of packages. void ShowEnabledPackages(); Query list of enabled packages from proof and display it; into a new text window. void ShowLog(const char* queryref); Display the content of the temporary log file for queryref; into a new text window. void ShowInfo(const char* txt); Display text in status bar. void ShowStatus(); Retrieve and display Proof status. void StartupMessage(char* msg, Bool_t stat, I",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TSessionViewer.html:27979,log,log,27979,root/html602/TSessionViewer.html,https://root.cern,https://root.cern/root/html602/TSessionViewer.html,4,['log'],['log']
Testability,"oid getLogProbabilities(std::span< const double > pdfValues, double *output) constDefinition RooAbsPdf.cxx:671; RooAbsPdf::_normRangeOverridestatic TString _normRangeOverrideDefinition RooAbsPdf.h:343; RooAbsPdf::_verboseEvalstatic Int_t _verboseEvalDefinition RooAbsPdf.h:314; RooAbsPdf::extendedTermdouble extendedTerm(double sumEntries, double expected, double sumEntriesW2=0.0, bool doOffset=false) constDefinition RooAbsPdf.cxx:730; RooAbsPdf::getGeneratorvirtual Int_t getGenerator(const RooArgSet &directVars, RooArgSet &generateVars, bool staticInitOK=true) constLoad generatedVars with the subset of directVars that we can generate events for, and return a code t...Definition RooAbsPdf.cxx:1522; RooAbsPdf::createProjectionvirtual RooAbsPdf * createProjection(const RooArgSet &iset)Return a p.d.f that represent a projection of this p.d.f integrated over given observables.Definition RooAbsPdf.cxx:2446; RooAbsPdf::getLogValvirtual double getLogVal(const RooArgSet *set=nullptr) constReturn the log of the current value with given normalization An error message is printed if the argum...Definition RooAbsPdf.cxx:620; RooAbsRealAbstract base class for objects that represent a real value and implements functionality common to al...Definition RooAbsReal.h:59; RooAbsReal::maxValvirtual double maxVal(Int_t code) constReturn maximum value for set of observables identified by code assigned in getMaxVal.Definition RooAbsReal.cxx:3397; RooAbsReal::plotOnvirtual RooPlot * plotOn(RooPlot *frame, const RooCmdArg &arg1={}, const RooCmdArg &arg2={}, const RooCmdArg &arg3={}, const RooCmdArg &arg4={}, const RooCmdArg &arg5={}, const RooCmdArg &arg6={}, const RooCmdArg &arg7={}, const RooCmdArg &arg8={}, const RooCmdArg &arg9={}, const RooCmdArg &arg10={}) constPlot (project) PDF on specified frame.Definition RooAbsReal.cxx:1611; RooArgListRooArgList is a container object that can hold multiple RooAbsArg objects.Definition RooArgList.h:22; RooArgSetRooArgSet is a container object that can",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RooAbsPdf_8h_source.html:33721,log,log,33721,doc/master/RooAbsPdf_8h_source.html,https://root.cern,https://root.cern/doc/master/RooAbsPdf_8h_source.html,1,['log'],['log']
Testability,"oid getLogProbabilities(std::span< const double > pdfValues, double *output) constDefinition RooAbsPdf.cxx:671; RooAbsPdf::_normRangeOverridestatic TString _normRangeOverrideDefinition RooAbsPdf.h:343; RooAbsPdf::_verboseEvalstatic Int_t _verboseEvalDefinition RooAbsPdf.h:314; RooAbsPdf::extendedTermdouble extendedTerm(double sumEntries, double expected, double sumEntriesW2=0.0, bool doOffset=false) constDefinition RooAbsPdf.cxx:730; RooAbsPdf::getGeneratorvirtual Int_t getGenerator(const RooArgSet &directVars, RooArgSet &generateVars, bool staticInitOK=true) constLoad generatedVars with the subset of directVars that we can generate events for, and return a code t...Definition RooAbsPdf.cxx:1522; RooAbsPdf::createProjectionvirtual RooAbsPdf * createProjection(const RooArgSet &iset)Return a p.d.f that represent a projection of this p.d.f integrated over given observables.Definition RooAbsPdf.cxx:2446; RooAbsPdf::getLogValvirtual double getLogVal(const RooArgSet *set=nullptr) constReturn the log of the current value with given normalization An error message is printed if the argum...Definition RooAbsPdf.cxx:620; RooAbsRealLValue::hasRangebool hasRange(const char *name) const overrideCheck if variable has a binning with given name.Definition RooAbsRealLValue.h:97; RooAbsRealLValue::getRangestd::pair< double, double > getRange(const char *name=nullptr) constGet low and high bound of the variable.Definition RooAbsRealLValue.h:88; RooAbsRealAbstract base class for objects that represent a real value and implements functionality common to al...Definition RooAbsReal.h:59; RooAbsReal::fillDataHistRooDataHist * fillDataHist(RooDataHist *hist, const RooArgSet *nset, double scaleFactor, bool correctForBinVolume=false, bool showProgress=false) constFill a RooDataHist with values sampled from this function at the bin centers.Definition RooAbsReal.cxx:1124; RooAbsReal::plotOnCompSelectvoid plotOnCompSelect(RooArgSet *selNodes) constHelper function for plotting of composite p.d.fs.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RooAbsPdf_8cxx_source.html:155076,log,log,155076,doc/master/RooAbsPdf_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RooAbsPdf_8cxx_source.html,1,['log'],['log']
Testability,"oid* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); Bool_tRooAbsCategory::operator!=(Int_t index); Bool_tRooAbsCategory::operator!=(const char* label); Bool_tRooAbsCategory::operator!=(const RooAbsArg& other); RooAbsArg&operator=(int index); RooAbsArg&operator=(const char* label); RooAbsArg&operator=(const RooAbsCategory& other); Bool_tRooAbsCategory::operator==(Int_t index) const; Bool_tRooAbsCategory::operator==(const char* label) const; virtual Bool_tRooAbsCategory::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidRooAbsArg::Print(Option_t* options = 0) const; virtual voidRooAbsArg::printAddress(ostream& os) const; virtual voidRooAbsArg::printArgs(ostream& os) const; virtual voidRooAbsArg::printClassName(ostream& os) const; voidRooAbsArg::printCompactTree(const char* indent = """", const char* fileName = 0, const char* namePat = 0, RooAbsArg* client = 0); voidRooAbsArg::printCompactTree(ostream& os, const char* indent = """", const char* namePat = 0, RooAbsArg* client = 0); virtual voidRooAbsArg::printCompactTreeHook(ostream& os, const char* ind = """"); voidRooAbsArg::printComponentTree(const char* indent = """", const char* namePat = 0); voidRooAbsArg::printDirty(Bool_t depth = kTRUE) const; virtual voidRooPrintable::printExtras(ostream& os) const; virtual voidRooAbsArg::printMetaArgs(ostream&) const; virtual voidRooAbsCat",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAbsCategoryLValue.html:11118,test,testArg,11118,root/html526/RooAbsCategoryLValue.html,https://root.cern,https://root.cern/root/html526/RooAbsCategoryLValue.html,1,['test'],['testArg']
Testability,"oid* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); Bool_tRooAbsCategory::operator!=(Int_t index); Bool_tRooAbsCategory::operator!=(const char* label); Bool_tRooAbsCategory::operator!=(const RooAbsArg& other); RooAbsArg&operator=(int index); RooAbsArg&operator=(const char* label); RooAbsArg&operator=(const RooAbsCategory& other); Bool_tRooAbsCategory::operator==(Int_t index) const; Bool_tRooAbsCategory::operator==(const char* label) const; virtual Bool_tRooAbsCategory::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidRooAbsArg::Print(Option_t* options = 0) const; virtual voidRooAbsArg::printAddress(ostream& os) const; virtual voidRooAbsArg::printArgs(ostream& os) const; virtual voidRooAbsArg::printClassName(ostream& os) const; voidRooAbsArg::printCompactTree(const char* indent = """", const char* fileName = 0, const char* namePat = 0, RooAbsArg* client = 0); voidRooAbsArg::printCompactTree(ostream& os, const char* indent = """", const char* namePat = 0, RooAbsArg* client = 0); virtual voidRooAbsArg::printCompactTreeHook(ostream& os, const char* ind = """"); voidRooAbsArg::printComponentTree(const char* indent = """", const char* namePat = 0, Int_t nLevel = 999); voidRooAbsArg::printDirty(Bool_t depth = kTRUE) const; virtual voidRooPrintable::printExtras(ostream& os) const; virtual voidRooAbsArg::printMetaArgs(ostream&) const; v",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooAbsCategoryLValue.html:11233,test,testArg,11233,root/html528/RooAbsCategoryLValue.html,https://root.cern,https://root.cern/root/html528/RooAbsCategoryLValue.html,4,['test'],['testArg']
Testability,"oid* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); Bool_tRooAbsCategory::operator!=(Int_t index); Bool_tRooAbsCategory::operator!=(const char* label); Bool_tRooAbsCategory::operator!=(const RooAbsArg& other); RooAbsArg&operator=(int index); RooAbsArg&operator=(const char* label); RooAbsArg&operator=(const RooAbsCategory& other); RooAbsCategoryLValue&operator=(const RooAbsCategoryLValue&); Bool_tRooAbsCategory::operator==(Int_t index) const; Bool_tRooAbsCategory::operator==(const char* label) const; virtual Bool_tRooAbsCategory::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidRooAbsArg::Print(Option_t* options = 0) const; virtual voidRooAbsArg::printAddress(ostream& os) const; virtual voidRooAbsArg::printArgs(ostream& os) const; virtual voidRooAbsArg::printClassName(ostream& os) const; voidRooAbsArg::printCompactTree(const char* indent = """", const char* fileName = 0, const char* namePat = 0, RooAbsArg* client = 0); voidRooAbsArg::printCompactTree(ostream& os, const char* indent = """", const char* namePat = 0, RooAbsArg* client = 0); virtual voidRooAbsArg::printCompactTreeHook(ostream& os, const char* ind = """"); voidRooAbsArg::printComponentTree(const char* indent = """", const char* namePat = 0, Int_t nLevel = 999); voidRooAbsArg::printDirty(Bool_t depth = kTRUE) const; virtual voidRooPrintable::printExtras(ostream& os) const; virtual voidRooAbsArg::printMetaArgs(ostream&) const; v",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooAbsCategoryLValue.html:12291,test,testArg,12291,root/html602/RooAbsCategoryLValue.html,https://root.cern,https://root.cern/root/html602/RooAbsCategoryLValue.html,2,['test'],['testArg']
Testability,"oid, const char* extF = """", const char* extD = """"); The network is described by a simple string:; The input/output layers are defined by giving; the branch names separated by comas.; Hidden layers are just described by the number of neurons.; The layers are separated by colons.; Ex: ""x,y:10:5:f""; The output can be prepended by '@' if the variable has to be; normalized.; The output can be followed by '!' to use Softmax neurons for the; output layer only.; Ex: ""x,y:10:5:c1,c2,c3!""; Input and outputs are taken from the TTree given as second argument.; training and test are two cuts (see TTreeFormula) defining events; to be used during the neural net training and testing.; Example: ""Entry$%2"", ""(Entry$+1)%2"".; Both the TTree and the cut can be defined in the constructor,; or later with the suited setter method. TMultiLayerPerceptron(const char* layout, const char* weight, TTree* data = 0, const char* training = ""Entry$%2==0"", const char* test = """", TNeuron::ENeuronType type = TNeuron::kSigmoid, const char* extF = """", const char* extD = """"); The network is described by a simple string:; The input/output layers are defined by giving; the branch names separated by comas.; Hidden layers are just described by the number of neurons.; The layers are separated by colons.; Ex: ""x,y:10:5:f""; The output can be prepended by '@' if the variable has to be; normalized.; The output can be followed by '!' to use Softmax neurons for the; output layer only.; Ex: ""x,y:10:5:c1,c2,c3!""; Input and outputs are taken from the TTree given as second argument.; training and test are two cuts (see TTreeFormula) defining events; to be used during the neural net training and testing.; Example: ""Entry$%2"", ""(Entry$+1)%2"".; Both the TTree and the cut can be defined in the constructor,; or later with the suited setter method. ~TMultiLayerPerceptron(); Destructor. void SetData(TTree* ); Set the data source. void SetEventWeight(const char* ); Set the event weight. void SetTrainingDataSet(TEventList* train",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMultiLayerPerceptron.html:21744,test,test,21744,root/html528/TMultiLayerPerceptron.html,https://root.cern,https://root.cern/root/html528/TMultiLayerPerceptron.html,6,['test'],['test']
Testability,"oidMakeChildren(); voidMakeCopies(int number); voidMutate(Double_t probability = 20, Int_t startIndex = 0, Bool_t near = kFALSE, Double_t spread = 0.1, Bool_t mirror = kFALSE); voidNextGeneration(); TMVA::GeneticPopulation&operator=(const TMVA::GeneticPopulation&); voidPrint(Int_t untilIndex = -1); voidPrint(ostream& out, Int_t utilIndex = -1); voidSetRandomSeed(UInt_t seed = 0); virtual voidShowMembers(TMemberInspector&); voidSort(); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); voidTrimPopulation(); vector<Double_t>VariableDistribution(Int_t varNumber); TH1F*VariableDistribution(Int_t varNumber, Int_t bins, Int_t min, Int_t max). private:. TMVA::MsgLogger&Log() const; TMVA::GeneticGenesMakeSex(TMVA::GeneticGenes male, TMVA::GeneticGenes female). Data Members; private:. vector<TMVA::GeneticGenes>fGenePoolthe ""genePool"" where the individuals of the current generation are stored; TMVA::MsgLogger*fLoggermessage logger; Int_tfPopulationSizeLimit; TRandom3*fRandomGeneratorrandom Generator for this population; vector<TMVA::GeneticRange*>fRangescontains the ranges inbetween the values of the coefficients have to be. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; GeneticPopulation(const vector<TMVA::Interval*>& ranges, Int_t size, UInt_t seed = 0); Constructor. ~GeneticPopulation(); destructor. void SetRandomSeed(UInt_t seed = 0); the random seed of the random generator. void MakeCopies(int number); produces offspring which is are copies of their parents; Parameters:; int number : the number of the last individual to be copied. void MakeChildren(); does what the name says,... it creates children out of members of the; current generation; children have a combination of the coefficients of their parents. TMVA::GeneticGenes MakeSex(TMVA::GeneticGenes male, TMVA::GeneticGenes female); this function takes two individuals and produces offspring by mixing (recombining) their; coefficients. v",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TMVA__GeneticPopulation.html:2084,log,logger,2084,root/html534/TMVA__GeneticPopulation.html,https://root.cern,https://root.cern/root/html534/TMVA__GeneticPopulation.html,1,['log'],['logger']
Testability,"oidRooAbsReal::logEvalError(const char* message, const char* serverValueString = 0) const; static voidRooAbsReal::logEvalError(const RooAbsReal* originator, const char* origName, const char* message, const char* serverValueString = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooAbsReal*mean(); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); static voidRooPrintable::nameFieldLength(Int_t newLen); virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TNamed&TNamed::operator=(const TNamed& rhs); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Int_torder() const; Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFA",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooMoment.html:17199,test,testArg,17199,root/html526/RooMoment.html,https://root.cern,https://root.cern/root/html526/RooMoment.html,2,['test'],['testArg']
Testability,"oidRooAbsReal::logEvalError(const char* message, const char* serverValueString = 0) const; static voidRooAbsReal::logEvalError(const RooAbsReal* originator, const char* origName, const char* message, const char* serverValueString = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooAbsReal*mean(); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); static voidRooPrintable::nameFieldLength(Int_t newLen); virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TNamed&TNamed::operator=(const TNamed& rhs); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooMoment.html:17566,test,testArg,17566,root/html530/RooMoment.html,https://root.cern,https://root.cern/root/html530/RooMoment.html,2,['test'],['testArg']
Testability,"oidDivideTrainingSet (UInt_t blockNum); divide training set ; ; voidEventResult (Bool_t successful, Long64_t evtNumber=-1); increase the importance sampling weight of the event when not successful and decrease it when successful ; ; Types::ETreeTypeGetCurrentType () const; ; const Event *GetEvent () const; returns event without transformations ; ; const Event *GetEvent (Long64_t ievt) const; ; const Event *GetEvent (Long64_t ievt, Types::ETreeType type) const; ; const std::vector< Event * > &GetEventCollection (Types::ETreeType type=Types::kMaxTreeType) const; ; const TTree *GetEventCollectionAsTree (); ; Long64_tGetNClassEvents (Int_t type, UInt_t classNumber); ; Long64_tGetNEvents (Types::ETreeType type=Types::kMaxTreeType) const; ; Long64_tGetNEvtBkgdTest (); return number of background test events in dataset ; ; Long64_tGetNEvtBkgdTrain (); return number of background training events in dataset ; ; Long64_tGetNEvtSigTest (); return number of signal test events in dataset ; ; Long64_tGetNEvtSigTrain (); return number of signal training events in dataset ; ; UInt_tGetNSpectators () const; access the number of targets through the datasetinfo ; ; UInt_tGetNTargets () const; access the number of targets through the datasetinfo ; ; Long64_tGetNTestEvents () const; ; Long64_tGetNTrainingEvents () const; ; UInt_tGetNVariables () const; access the number of variables through the datasetinfo ; ; Results *GetResults (const TString &, Types::ETreeType type, Types::EAnalysisType analysistype); ; const Event *GetTestEvent (Long64_t ievt) const; ; const Event *GetTrainingEvent (Long64_t ievt) const; ; TTree *GetTree (Types::ETreeType type); create the test/trainings tree with all the variables, the weights, the classes, the targets, the spectators, the MVA outputs ; ; Bool_tHasNegativeEventWeights () const; ; voidIncrementNClassEvents (Int_t type, UInt_t classNumber); ; voidInitSampling (Float_t fraction, Float_t wei",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1DataSet.html:2096,test,test,2096,doc/master/classTMVA_1_1DataSet.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1DataSet.html,1,['test'],['test']
Testability,"oidProcessOptions (); process user options reference cut value to distinguish signal-like from background-like events ; ; Double_tTransformLikelihoodOutput (Double_t ps, Double_t pb) const; returns transformed or non-transformed output ; . Private Attributes; Int_tfAverageEvtPerBin; average events per bin; used to calculate fNbins ; ; Int_t *fAverageEvtPerBinVarB; average events per bin; used to calculate fNbins ; ; Int_t *fAverageEvtPerBinVarS; average events per bin; used to calculate fNbins ; ; TStringfBorderMethodString; the method to take care about ""border"" effects (string) ; ; PDF *fDefaultPDFLik; pdf that contains default definitions ; ; Int_tfDropVariable; for ranking test ; ; Double_tfEpsilon; minimum number of likelihood (to avoid zero) ; ; std::vector< TH1 * > *fHistBgd; background PDFs (histograms) ; ; std::vector< TH1 * > *fHistBgd_smooth; background PDFs (smoothed histograms) ; ; std::vector< TH1 * > *fHistSig; signal PDFs (histograms) ; ; std::vector< TH1 * > *fHistSig_smooth; signal PDFs (smoothed histograms) ; ; TString *fInterpolateString; which interpolation method used for reference histograms (individual for each variable) ; ; Float_tfKDEfineFactor; fine tuning factor for Adaptive KDE ; ; TStringfKDEiterString; Number of iterations (string) ; ; TStringfKDEtypeString; Kernel type to use for KDE (string) ; ; Int_tfNsmooth; number of smooth passes ; ; Int_t *fNsmoothVarB; number of smooth passes ; ; Int_t *fNsmoothVarS; number of smooth passes ; ; std::vector< PDF * > *fPDFBgd; list of PDFs (background) ; ; std::vector< PDF * > *fPDFSig; list of PDFs (signal) ; ; Bool_tfTransformLikelihoodOutput; likelihood output is sigmoid-transformed ; . Additional Inherited Members; Public Types inherited from TMVA::MethodBase; enum EWeightFileType { kROOT =0; , kTEXT; }; ; Public Types inherited from TObject; enum { ; kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1MethodLikelihood.html:29519,test,test,29519,doc/master/classTMVA_1_1MethodLikelihood.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1MethodLikelihood.html,1,['test'],['test']
Testability,"oint confidence intervals for the fitted function. ; ; voidGetConfidenceIntervals (TObject *obj, Double_t cl=0.95) override; Computes confidence intervals at level cl. ; ; Double_t *GetCovarianceMatrix () const override; return a pointer to the covariance matrix ; ; Double_tGetCovarianceMatrixElement (Int_t i, Int_t j) const override; return element i,j from the covariance matrix ; ; Int_tGetErrors (Int_t ipar, Double_t &eplus, Double_t &eminus, Double_t &eparab, Double_t &globcc) const override; return current errors for a parameter ipar : parameter number eplus : upper error eminus : lower error eparab : parabolic error globcc : global correlation coefficient ; ; TMinuit *GetMinuit () const; ; Int_tGetNumberFreeParameters () const override; return the number of free parameters ; ; Int_tGetNumberTotalParameters () const override; return the total number of parameters (free + fixed) ; ; Double_tGetParameter (Int_t ipar) const override; return current value of parameter ipar ; ; Int_tGetParameter (Int_t ipar, char *name, Double_t &value, Double_t &verr, Double_t &vlow, Double_t &vhigh) const override; return current values for a parameter ; ; Double_tGetParError (Int_t ipar) const override; return error of parameter ipar ; ; const char *GetParName (Int_t ipar) const override; return name of parameter ipar ; ; Int_tGetStats (Double_t &amin, Double_t &edm, Double_t &errdef, Int_t &nvpar, Int_t &nparx) const override; return global fit parameters ; ; Double_tGetSumLog (Int_t i) override; return Sum(log(i) i=0,n used by log likelihood fits ; ; TClass *IsA () const override; ; Bool_tIsFixed (Int_t ipar) const override; return kTRUE if parameter ipar is fixed, kFALSE otherwise) ; ; voidPrintResults (Int_t level, Double_t amin) const override; Print fit results. ; ; voidReleaseParameter (Int_t ipar) override; Release parameter ipar. ; ; voidSetFCN (void(*fcn)(Int_t &, Double_t *, Double_t &f, Double_t *, Int_t)) override; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTFitter.html:2882,log,log,2882,doc/master/classTFitter.html,https://root.cern,https://root.cern/doc/master/classTFitter.html,2,['log'],['log']
Testability,"oint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void dataDefinition TGWin32VirtualXProxy.cxx:104; RooBinSamplingPdfThe RooBinSamplingPdf is supposed to be used as an adapter between a continuous PDF and a binned dist...Definition RooBinSamplingPdf.h:28; RooBinSamplingPdf::integratorstd::unique_ptr< ROOT::Math::IntegratorOneDim > & integrator() constDirect access to the unique_ptr holding the integrator that's used to sample the bins.Definition RooBinSamplingPdf.cxx:278; RooBinSamplingPdf::observableconst RooAbsReal & observable() constDefinition RooBinSamplingPdf.h:111; When a PDF is wrapped with a RooBinSamplingPDF, just use the bin sampling PDF instead of the original one for fits or plotting etc. NoteThe binning will be taken from the observable. Make sure that this binning is the same as the one of the dataset that should be fit. Use RooRealVar::setBinning() to adapt it. Instruct test statistics to carry out this wrapping automatically: pdf.fitTo(data, IntegrateBins(<precision>));; RooAbsPdf::fitToRooFit::OwningPtr< RooFitResult > fitTo(RooAbsData &data, CmdArgs_t const &... cmdArgs)Fit PDF to given dataset.Definition RooAbsPdf.h:157; RooBinSamplingPdf::pdfconst RooAbsPdf & pdf() constDefinition RooBinSamplingPdf.h:110; This method is especially useful when used with a simultaneous PDF, since each component will automatically be wrapped, depending on the value of precision:; precision < 0.: None of the PDFs are touched, bin sampling is off.; precision = 0.: Continuous PDFs that are fit to a RooDataHist are wrapped into a RooBinSamplingPdf. The target precision forwarded to the integrator is 1.E-4 (the default argument of the constructor).; precision > 0.: All continuous PDFs are automatically wrapped into a RooBinSamplingPdf, regardless of what data they are fit to (see next paragraph). The same 'precision` is used for all integrators. Simulating a binned fit using RooDataSet; Some fr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooBinSamplingPdf.html:2508,test,test,2508,doc/master/classRooBinSamplingPdf.html,https://root.cern,https://root.cern/doc/master/classRooBinSamplingPdf.html,1,['test'],['test']
Testability,"ointSizeScale; TGLLockable::ELockTGLLockable::fLockLock state.; map<TObject*,TGLLogicalShape*>fLogicalShapes!; UInt_tTGLSceneBase::fMinorStampCounter increased on minimal update.; TStringTGLSceneBase::fNameObject identifier.; Float_tTGLSceneBase::fOLLineWScene outline line-width.; map<unsigned int,TGLPhysicalShape*>fPhysicalShapes!; UInt_tTGLSceneBase::fSceneIDUnique scene id.; Bool_tTGLSceneBase::fSelectableObjects in the scene are selectable.; map<TObject*,TGLLogicalShape*>fSmartRefreshCache!; Short_tTGLSceneBase::fStyleScene-style.; UInt_tTGLSceneBase::fTimeStampCounter increased on every update.; TStringTGLSceneBase::fTitleObject title.; list<TGLViewerBase*>TGLSceneBase::fViewers; Float_tTGLSceneBase::fWFLineWScene wire-frame line-width. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGLScene(); {}. ~TGLScene(); Destroy scene objects. void ReleaseGLCtxIdentity(); Release all GL resources for current context identity.; Requires iteration over all logical shapes. Bool_t ComparePhysicalVolumes(const TGLPhysicalShape* shape1, const TGLPhysicalShape* shape2); Compare 'shape1' and 'shape2' bounding box volumes - return kTRUE if; 'shape1' bigger than 'shape2'. Bool_t ComparePhysicalDiagonals(const TGLPhysicalShape* shape1, const TGLPhysicalShape* shape2); Compare 'shape1' and 'shape2' bounding box volumes - return kTRUE if; 'shape1' bigger than 'shape2'. void RebuildSceneInfo(TGLRnrCtx& rnrCtx); Major change in scene, need to rebuild all-element draw-vector and; sort it. Sort the TGLPhysical draw list by shape bounding box diagonal, from; large to small. This makes dropout of shapes with time limited; Draw() calls must less noticable. As this does not use projected; size it only needs to be done after a scene content change - not; everytime scene drawn (potential camera/projection change). void UpdateSceneInfo(TGLRnrCtx& rnrCtx); Fill scene-info with information needed for rendering, take into; account the render-context (view",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGLScene.html:7727,log,logical,7727,root/html528/TGLScene.html,https://root.cern,https://root.cern/root/html528/TGLScene.html,4,['log'],['logical']
Testability,"ointer to the last used table row; fLastRow = table[fLastIndx]; TSeqCollection*TDataSet::fListList of the the the objects included into this dataset; TStringTNamed::fNameobject identifier; TDataSet*TDataSet::fParentpointer to mother of the directory; TTable*fTablethe ""TTable"" object this object is pthe proxy for; TStringTNamed::fTitleobject title; static TDataSet*TDataSet::fgMainSetpointer the main dataset;. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void AddAt(TDataSet* dataset, Int_t idx); {TDataSet::AddAt(dataset,idx);}. void * operator[](Int_t i). const void * operator[](Int_t i) const; if (!GetThisTable()->BoundsOk(""TChair::operator[]"", i)); i = 0;. TTable * GetThisTable(); {return fTable; }. const TTable * GetThisTable() const; {return fTable; }. void * GetOffset(const void* base, ULong_t offset); { return (void *)((Char_t *)base + offset);}. TChair(); { ; }. TChair(TTable* table); { ; }. TChair(const TChair& org); TChair &operator=(const TChair &rhs){ assert(0); return rhs;}. {assert(0);}. virtual ~TChair(); {;}. void Adopt(Int_t n, void* array); {GetThisTable()->Adopt(n,array);}. void AddAt(TDataSet* dataset, Int_t idx). const void * At(Int_t i) const; {return GetThisTable()->At(i);}. void Browse(TBrowser* b); {GetThisTable()->Browse(b);}. void CopySet(TChair& chair); {GetThisTable()->CopySet(*chair.GetThisTable());}. Int_t CopyRows(const TChair* srcChair, Int_t srcRow = 0, Int_t dstRow = 0, Int_t nRows = 0, Bool_t expand = kFALSE); {return GetThisTable()->CopyRows(srcChair->GetThisTable(),srcRow,dstRow,nRows,expand);}. void Draw(Option_t* opt); {GetThisTable()->Draw(opt);}. TH1 * Draw(TCut varexp, TCut selection, Option_t* option = """", Int_t nentries = 1000000000, Int_t firstentry = 0); {return GetThisTable()->Draw(varexp,selection,option,nentries,firstentry);}. TH1 * Draw(const char* varexp, const char* selection, Option_t* option = """", Int_t nentries = 1000000000, Int_t firstentry = 0). Char_t * GetArray() c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TChair.html:10872,assert,assert,10872,root/html528/TChair.html,https://root.cern,https://root.cern/root/html528/TChair.html,6,['assert'],['assert']
Testability,"ointer, i);; 749 line[kvalue+i] = 0;; 750 } else {; 751 line[kvalue] = 0;; 752 }; 753 } else {; 754 strncpy(&line[kvalue], membertype->AsString(p3pointer), TMath::Min(kline-1-kvalue,(int)strlen(membertype->AsString(p3pointer))));; 755 }; 756 } else if (!strcmp(memberFullTypeName, ""char*"") ||; 757 !strcmp(memberFullTypeName, ""const char*"")) {; 758 i = strlen(*ppointer);; 759 if (kvalue+i >= kline) i=kline-1-kvalue;; 760 Bool_t isPrintable = kTRUE;; 761 for (Int_t j = 0; j < i; j++) {; 762 if (!std::isprint((*ppointer)[j])) {; 763 isPrintable = kFALSE;; 764 break;; 765 }; 766 }; 767 if (isPrintable) {; 768 strncpy(line + kvalue, *ppointer, kline - kvalue);; 769 line[kvalue+i] = 0;; 770 } else {; 771 line[kvalue] = 0;; 772 }; 773 } else {; 774 if (!fNoAddr) {; 775 snprintf(&line[kvalue],kline-kvalue,""->%zx "", (size_t)p3pointer);; 776 }; 777 }; 778 } else if (membertype) {; 779 if (isdate) {; 780 cdatime = (UInt_t*)pointer;; 781 TDatime::GetDateTime(cdatime[0],cdate,ctime);; 782 snprintf(&line[kvalue],kline-kvalue,""%d/%d"",cdate,ctime);; 783 } else if (isbits) {; 784 snprintf(&line[kvalue],kline-kvalue,""0x%08x"", *(UInt_t*)pointer);; 785 } else {; 786 strncpy(&line[kvalue], membertype->AsString(pointer), TMath::Min(kline-1-kvalue,(int)strlen(membertype->AsString(pointer))));; 787 }; 788 } else {; 789 if (isStdString) {; 790 std::string *str = (std::string*)pointer;; 791 snprintf(&line[kvalue],kline-kvalue,""%s"",str->c_str());; 792 } else if (isTString) {; 793 TString *str = (TString*)pointer;; 794 snprintf(&line[kvalue],kline-kvalue,""%s"",str->Data());; 795 } else {; 796 if (!fNoAddr) {; 797 snprintf(&line[kvalue],kline-kvalue,""->%zx "", (size_t)pointer);; 798 }; 799 }; 800 }; 801 // Encode data member title; 802 if (isdate == kFALSE && strcmp(memberFullTypeName, ""char*"") && strcmp(memberFullTypeName, ""const char*"")) {; 803 i = strlen(&line[0]); line[i] = ' ';; 804 assert(250 > ktitle);; 805 strlcpy(&line[ktitle],memberTitle,250-ktitle+1); // strlcpy copy 'size-1' characters.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TClass_8cxx_source.html:28124,assert,assert,28124,doc/master/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TClass_8cxx_source.html,1,['assert'],['assert']
Testability,"oissonian statistics should be used, which modifies the significance criterion.; The rectangular cut of a volume in the variable space is performed using a binary tree to sort the training events. This provides a significant reduction in computing time (up to several orders of magnitudes, depending on the complexity of the problem at hand).; Technically, optimisation is achieved in TMVA by two methods:. Monte Carlo generation using uniform priors for the lower cut value, and the cut width, thrown within the variable ranges.; A Genetic Algorithm (GA) searches for the optimal (""fittest"") cut sample. The GA is configurable by many external settings through the option string. For difficult cases (such as many variables), some tuning may be necessary to achieve satisfying results. Attempts to use Minuit fits (Simplex ot Migrad) instead have not shown superior results, and often failed due to convergence at local minima.; The tests we have performed so far showed that in generic applications, the GA is superior to MC sampling, and hence GA is the default method. It is worthwhile trying both anyway.; Decorrelated (or ""diagonalized"") Cuts**; See class description for Method Likelihood for a detailed explanation. ; Definition at line 61 of file MethodCuts.h. Public Member Functions; MethodCuts (const TString &jobName, const TString &methodTitle, DataSetInfo &theData, const TString &theOption=""MC:150:10000:""); standard constructor ; ; MethodCuts (DataSetInfo &theData, const TString &theWeightFile); construction from weight file ; ; virtual~MethodCuts (void); destructor ; ; voidAddWeightsXMLTo (void *parent) const; create XML description for LD classification and regression (for arbitrary number of output classes/targets) ; ; voidCheckSetup (); check may be overridden by derived class (sometimes, eg, fitters are used which can only be implemented during training phase) ; ; Double_tComputeEstimator (std::vector< Double_t > &); returns estimator for ""cut fitness",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1MethodCuts.html:2094,test,tests,2094,doc/master/classTMVA_1_1MethodCuts.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1MethodCuts.html,1,['test'],['tests']
Testability,"ojectedVars, RooArgSet*& cloneSet, const char* rangeName = 0, const RooArgSet* condObs = 0) const; virtual RooAbsReal*RooAbsReal::createProfile(const RooArgSet& paramsOfInterest); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); RooAbsReal*RooAbsReal::createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); RooAbsData&RooAbsOptTestStatistic::data(); const RooAbsData&RooAbsOptTestStatistic::data() const; virtual Double_tdefaultErrorLevel() const; static RooNumIntConfig*RooAbsReal::defaultIntegratorConfig(); virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; RooDerivative*RooAbsReal::derivative(RooRealVar& obs, Int_t order = 1, Double_t eps = 0.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooNLLVar.html:10038,test,testArg,10038,root/html528/RooNLLVar.html,https://root.cern,https://root.cern/root/html528/RooNLLVar.html,32,['test'],['testArg']
Testability,"ol (SeparationBase *qualityIndex=nullptr); the constructor for the cost complexity pruning ; ; virtual~CostComplexityPruneTool (); the destructor for the cost complexity pruning ; ; virtual PruningInfo *CalculatePruningInfo (DecisionTree *dt, const IPruneTool::EventSample *testEvents=nullptr, Bool_t isAutomatic=kFALSE); the routine that basically ""steers"" the pruning process. ; ; Public Member Functions inherited from TMVA::IPruneTool; IPruneTool (); ; virtual~IPruneTool (); ; Double_tGetPruneStrength () const; ; Bool_tIsAutomatic () const; ; voidSetAutomatic (); ; voidSetPruneStrength (Double_t alpha); . Private Member Functions; voidInitTreePruningMetaData (DecisionTreeNode *n); initialise ""meta data"" for the pruning, like the ""costcomplexity"", the critical alpha, the minimal alpha down the tree, etc... for each node!! ; ; MsgLogger &Log () const; output stream to save logging information ; ; voidOptimize (DecisionTree *dt, Double_t weights); after the critical \( \alpha \) values (at which the corresponding nodes would be pruned away) had been established in the ""InitMetaData"" we need now: automatic pruning: ; . Private Attributes; MsgLogger *fLogger; ; Int_tfOptimalK; ! the optimal index of the prune sequence ; ; std::vector< DecisionTreeNode * >fPruneSequence; ! map of weakest links (i.e., branches to prune) -> pruning index ; ; std::vector< Double_t >fPruneStrengthList; ! map of alpha -> pruning index ; ; std::vector< Double_t >fQualityIndexList; ! map of R(T) -> pruning index ; ; SeparationBase *fQualityIndexTool; ! the quality index used to calculate R(t), R(T) = sum[t in ~T]{ R(t) } ; . Additional Inherited Members; Public Types inherited from TMVA::IPruneTool; typedef std::vector< const Event * >EventSample; ; Protected Attributes inherited from TMVA::IPruneTool; Double_tB; ; Double_tfPruneStrength; ! regularization parameter in pruning ; ; Double_tS; . #include <TMVA/CostComplexityPruneTool.h>. Inhe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1CostComplexityPruneTool.html:2410,log,logging,2410,doc/master/classTMVA_1_1CostComplexityPruneTool.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1CostComplexityPruneTool.html,1,['log'],['logging']
Testability,"ol ROOT::RBrowserInfoWidget::DrawElement ; (; std::shared_ptr< Browsable::RElement > &; , . const std::string &; = """". ). inlineoverridevirtual . Reimplemented from ROOT::RBrowserWidget.; Definition at line 161 of file RBrowser.cxx. GetKind(). std::string ROOT::RBrowserInfoWidget::GetKind ; (; ); const. inlineoverridevirtual . Implements ROOT::RBrowserWidget.; Definition at line 155 of file RBrowser.cxx. GetTitle(). std::string ROOT::RBrowserInfoWidget::GetTitle ; (; ). inlineoverridevirtual . Reimplemented from ROOT::RBrowserWidget.; Definition at line 156 of file RBrowser.cxx. GetUrl(). std::string ROOT::RBrowserInfoWidget::GetUrl ; (; ). inlineoverridevirtual . Implements ROOT::RBrowserWidget.; Definition at line 157 of file RBrowser.cxx. Refresh(). void ROOT::RBrowserInfoWidget::Refresh ; (; ). inline . Definition at line 163 of file RBrowser.cxx. RefreshFromLogs(). void ROOT::RBrowserInfoWidget::RefreshFromLogs ; (; const std::string &; promt, . const std::vector< std::string > &; logs. ). inline . Definition at line 191 of file RBrowser.cxx. ResetConn(). void ROOT::RBrowserInfoWidget::ResetConn ; (; ). inlineoverridevirtual . Reimplemented from ROOT::RBrowserWidget.; Definition at line 153 of file RBrowser.cxx. SendWidgetContent(). std::string ROOT::RBrowserInfoWidget::SendWidgetContent ; (; ). inlineoverridevirtual . Reimplemented from ROOT::RBrowserWidget.; Definition at line 218 of file RBrowser.cxx. Show(). void ROOT::RBrowserInfoWidget::Show ; (; const std::string &; ). inlineoverridevirtual . Implements ROOT::RBrowserWidget.; Definition at line 159 of file RBrowser.cxx. Member Data Documentation. fContent. std::string ROOT::RBrowserInfoWidget::fContent. Definition at line 142 of file RBrowser.cxx. fFirstSend. bool ROOT::RBrowserInfoWidget::fFirstSend {false}. ! if editor content was send at least once ; Definition at line 143 of file RBrowser.cxx. fTitle. std::string ROOT::RBrowserInfoWidget::fTitle. Definition at line 141 of",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1RBrowserInfoWidget.html:3268,log,logs,3268,doc/v632/classROOT_1_1RBrowserInfoWidget.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1RBrowserInfoWidget.html,2,['log'],['logs']
Testability,"ol useLatex=false); Create a GraphViz .dot file visualizing the expression tree headed by this RooAbsArg object. ; ; voidgraphVizTree (std::ostream &os, const char *delimiter=""\n"", bool useTitle=false, bool useLatex=false); Write the GraphViz representation of the expression tree headed by this RooAbsArg object to the given ostream. ; ; boolhasClients () const; ; boolhasDataToken () const; ; virtual boolimportWorkspaceHook (RooWorkspace &ws); ; boolisConstant () const; Check if the ""Constant"" attribute is set. ; ; virtual boolisDerived () const; Does value or shape of this arg depend on any other arg? ; ; virtual boolisReducerNode () const; ; boolIsSortable () const override; ; boollocalNoDirtyInhibit () const; ; const TNamed *namePtr () const; De-duplicated pointer to this object's name. ; ; Int_tnumProxies () const; Return the number of registered proxies. ; ; boolobservableOverlaps (const RooAbsData *dset, const RooAbsArg &testArg) const; Test if any of the dependents of the arg tree (as determined by getObservables) overlaps with those of the testArg. ; ; boolobservableOverlaps (const RooArgSet *depList, const RooAbsArg &testArg) const; Test if any of the dependents of the arg tree (as determined by getObservables) overlaps with those of the testArg. ; ; RooAbsArg &operator= (const RooAbsArg &other)=delete; ; booloverlaps (const RooAbsArg &testArg, bool valueOnly=false) const; Test if any of the nodes of tree are shared with that of the given tree. ; ; const RooArgSet *ownedComponents () const; ; voidPrint (Option_t *options=nullptr) const override; Print the object to the defaultPrintStream(). ; ; voidprintAddress (std::ostream &os) const override; Print address of this RooAbsArg. ; ; voidprintArgs (std::ostream &os) const override; Print object arguments, ie its proxies. ; ; voidprintClassName (std::ostream &os) const override; Print object class name. ; ; voidprintCompactTree (const char *indent="""", const",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooSuperCategory.html:16573,test,testArg,16573,doc/master/classRooSuperCategory.html,https://root.cern,https://root.cern/doc/master/classRooSuperCategory.html,2,['test'],['testArg']
Testability,"ol_t assumeSameType = kFALSE); virtual Bool_tRooAbsArg::isLValue() const; virtual Bool_tRooAbsReal::isOffsetting() const; Bool_tTObject::IsOnHeap() const; Bool_tRooAbsArg::isShapeDirty() const; Bool_tRooAbsArg::isShapeServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isShapeServer(const char* name) const; virtual Bool_tRooAbsArg::IsSortable() const; Bool_tRooAbsArg::isValueDirty() const; Bool_tRooAbsArg::isValueDirtyAndClear() const; Bool_tRooAbsArg::isValueOrShapeDirtyAndClear() const; Bool_tRooAbsArg::isValueServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isValueServer(const char* name) const; Bool_tTObject::IsZombie() const; voidRooAbsArg::leafNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; const RooArgList&list() const; const RooArgList&list1() const; Bool_tRooAbsArg::localNoDirtyInhibit() const; voidRooAbsReal::logEvalError(const char* message, const char* serverValueString = 0) const; static voidRooAbsReal::logEvalError(const RooAbsReal* originator, const char* origName, const char* message, const char* serverValueString = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooAbsMoment*RooAbsReal::mean(RooRealVar& obs); RooAbsMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* d",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAddition.html:17808,log,logEvalError,17808,root/html534/RooAddition.html,https://root.cern,https://root.cern/root/html534/RooAddition.html,3,['log'],['logEvalError']
Testability,"ol_t fVerbose! verbose modeDefinition Factory.h:213; TMVA::Factory::EvaluateAllMethodsvoid EvaluateAllMethods(void)Iterates over all MVAs that have been booked, and calls their evaluation methods.Definition Factory.cxx:1376; TMVA::Factory::EvaluateImportanceRandomTH1F * EvaluateImportanceRandom(DataLoader *loader, UInt_t nseeds, Types::EMVA theMethod, TString methodTitle, const char *theOption="""")Definition Factory.cxx:2473; TMVA::Factory::GetImportanceTH1F * GetImportance(const int nbits, std::vector< Double_t > importances, std::vector< TString > varNames)Definition Factory.cxx:2591; TMVA::Factory::fROCBool_t fROC! enable to calculate ROC valuesDefinition Factory.h:216; TMVA::Factory::EvaluateAllVariablesvoid EvaluateAllVariables(DataLoader *loader, TString options="""")Iterates over all MVA input variables and evaluates them.Definition Factory.cxx:1360; TMVA::Factory::RootBaseDirTDirectory * RootBaseDir()Definition Factory.h:149; TMVA::Factory::fVerboseLevelTString fVerboseLevel! verbosity level, controls granularity of loggingDefinition Factory.h:214; TMVA::Factory::GetROCCurveAsMultiGraphTMultiGraph * GetROCCurveAsMultiGraph(DataLoader *loader, UInt_t iClass, Types::ETreeType type=Types::kTesting)Generate a collection of graphs, for all methods for a given class.Definition Factory.cxx:988; TMVA::Factory::EvaluateImportanceTH1F * EvaluateImportance(DataLoader *loader, VIType vitype, Types::EMVA theMethod, TString methodTitle, const char *theOption="""")Evaluate Variable Importance.Definition Factory.cxx:2217; TMVA::Factory::OptimizeAllMethodsForRegressionvoid OptimizeAllMethodsForRegression(TString fomType=""ROCIntegral"", TString fitType=""FitGA"")Definition Factory.h:111; TMVA::Factory::GetROCIntegralDouble_t GetROCIntegral(DataLoader *loader, TString theMethodName, UInt_t iClass=0, Types::ETreeType type=Types::kTesting)Calculate the integral of the ROC curve, also known as the area under curve (AUC),...Definition Factory.cxx:849; TMVA::Factory::fMethodsMapstd::map< TS",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/tmva_2tmva_2inc_2TMVA_2Factory_8h_source.html:14801,log,loggingDefinition,14801,doc/master/tmva_2tmva_2inc_2TMVA_2Factory_8h_source.html,https://root.cern,https://root.cern/doc/master/tmva_2tmva_2inc_2TMVA_2Factory_8h_source.html,1,['log'],['loggingDefinition']
Testability,"ol_t takeRoot, Bool_t intNormObs); static voidRooPrintable::nameFieldLength(Int_t newLen); virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tnumEvalErrorItems(); static Int_tnumEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TNamed&TNamed::operator=(const TNamed& rhs); Bool_toperator==(Double_t value) const; virtual Bool_toperator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg(), const RooCmdArg& arg9 = RooCmdArg(), const RooCmdArg& arg10 = RooCmdArg()) const; virtual list<Double_t>*plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; virtual RooPlot*plotSliceOn(RooPlot* frame, const RooArgSet& sliceSet, Option_t* drawOptions = ""L"", Double_t scaleFactor = 1.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAbsReal.html:17279,test,testArg,17279,root/html526/RooAbsReal.html,https://root.cern,https://root.cern/root/html526/RooAbsReal.html,2,['test'],['testArg']
Testability,"ol_tRooAbsArg::isConstant() const; virtual Bool_tRooAbsArg::isDerived() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; virtual Bool_tRooAbsArg::isFundamental() const; virtual Bool_tRooAbsArg::isLValue() const; Bool_tTObject::IsOnHeap() const; Bool_tRooAbsArg::isShapeDirty() const; Bool_tRooAbsArg::isShapeServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isShapeServer(const char* name) const; virtual Bool_tRooAbsArg::IsSortable() const; Bool_tRooAbsArg::isValueDirty() const; Bool_tRooAbsArg::isValueServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isValueServer(const char* name) const; Bool_tTObject::IsZombie() const; voidRooAbsArg::leafNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; const RooArgList&list() const; const RooArgList&list1() const; voidRooAbsReal::logEvalError(const char* message, const char* serverValueString = 0) const; static voidRooAbsReal::logEvalError(const RooAbsReal* originator, const char* origName, const char* message, const char* serverValueString = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooMoment*RooAbsReal::mean(RooRealVar& obs); RooMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); static voidRooPrintable::nameFieldLength(Int_t newLen); virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooAddition.html:16596,log,logEvalError,16596,root/html528/RooAddition.html,https://root.cern,https://root.cern/root/html528/RooAddition.html,2,['log'],['logEvalError']
Testability,"ol_tRooAbsArg::isConstant() const; virtual Bool_tRooAbsOptTestStatistic::isDerived() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; virtual Bool_tRooAbsArg::isFundamental() const; virtual Bool_tRooAbsArg::isLValue() const; Bool_tTObject::IsOnHeap() const; Bool_tRooAbsOptTestStatistic::isSealed() const; Bool_tRooAbsArg::isShapeDirty() const; Bool_tRooAbsArg::isShapeServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isShapeServer(const char* name) const; virtual Bool_tRooAbsArg::IsSortable() const; Bool_tRooAbsArg::isValueDirty() const; Bool_tRooAbsArg::isValueDirtyAndClear() const; Bool_tRooAbsArg::isValueOrShapeDirtyAndClear() const; Bool_tRooAbsArg::isValueServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isValueServer(const char* name) const; Bool_tTObject::IsZombie() const; voidRooAbsArg::leafNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; voidRooAbsReal::logEvalError(const char* message, const char* serverValueString = 0) const; static voidRooAbsReal::logEvalError(const RooAbsReal* originator, const char* origName, const char* message, const char* serverValueString = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooMoment*RooAbsReal::mean(RooRealVar& obs); RooMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static In",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooNLLVar.html:18283,log,logEvalError,18283,root/html532/RooNLLVar.html,https://root.cern,https://root.cern/root/html532/RooNLLVar.html,1,['log'],['logEvalError']
Testability,"ol_tRooAbsArg::isConstant() const; virtual Bool_tRooAbsOptTestStatistic::isDerived() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; virtual Bool_tRooAbsArg::isFundamental() const; virtual Bool_tRooAbsArg::isLValue() const; Bool_tTObject::IsOnHeap() const; Bool_tRooAbsOptTestStatistic::isSealed() const; Bool_tRooAbsArg::isShapeDirty() const; Bool_tRooAbsArg::isShapeServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isShapeServer(const char* name) const; virtual Bool_tRooAbsArg::IsSortable() const; Bool_tRooAbsArg::isValueDirty() const; Bool_tRooAbsArg::isValueDirtyAndClear() const; Bool_tRooAbsArg::isValueOrShapeDirtyAndClear() const; Bool_tRooAbsArg::isValueServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isValueServer(const char* name) const; Bool_tTObject::IsZombie() const; voidRooAbsArg::leafNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; voidRooAbsReal::logEvalError(const char* message, const char* serverValueString = 0) const; static voidRooAbsReal::logEvalError(const RooAbsReal* originator, const char* origName, const char* message, const char* serverValueString = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooMoment*RooAbsReal::mean(RooRealVar& obs); RooMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); static voidRooPrintable::nameFieldLength(Int_t newLen); virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRoo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooChi2Var.html:18654,log,logEvalError,18654,root/html532/RooChi2Var.html,https://root.cern,https://root.cern/root/html532/RooChi2Var.html,3,['log'],['logEvalError']
Testability,"ol_tRooAbsArg::isValueServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isValueServer(const char* name) const; Bool_tTObject::IsZombie() const; voidRooAbsArg::leafNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; const RooCatType*lookupType(Int_t index, Bool_t printError = kFALSE) const; const RooCatType*lookupType(const char* label, Bool_t printError = kFALSE) const; const RooCatType*lookupType(const RooCatType& type, Bool_t printError = kFALSE) const; virtual voidTNamed::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; Int_tnumTypes(const char* = 0) const; Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); Bool_toperator!=(Int_t index); Bool_toperator!=(const char* label); Bool_toperator!=(const RooAbsArg& other); TNamed&TNamed::operator=(const TNamed& rhs); Bool_toperator==(Int_t index) const; Bool_toperator==(const char* label) const; virtual Bool_toperator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooAbsCategory.html:9762,test,testArg,9762,root/html532/RooAbsCategory.html,https://root.cern,https://root.cern/root/html532/RooAbsCategory.html,1,['test'],['testArg']
Testability,"ol_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooStats::HistFactory::RooBarlowBeestonLL&operator=(const RooStats::HistFactory::RooBarlowBeestonLL&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, RooLinkedList& cmdList) const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg(), const RooCmdArg& arg9 = RooCmdArg(), const RooCmdArg& arg10 = RooCmdArg()) const; virtual list<Double_t>*RooAbsReal::plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; virtual RooPlot*RooAbsReal::plotSliceOn(RooPlot* frame, const RooArgSet& sliceSet, Option_t* drawOptions = ""L"", Double_t scaleFactor = 1.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooStats__HistFactory__RooBarlowBeestonLL.html:19685,test,testArg,19685,root/html602/RooStats__HistFactory__RooBarlowBeestonLL.html,https://root.cern,https://root.cern/root/html602/RooStats__HistFactory__RooBarlowBeestonLL.html,2,['test'],['testArg']
Testability,"ol_tRooAbsReal::isOffsetting() const; Bool_tTObject::IsOnHeap() const; Bool_tRooAbsArg::isShapeDirty() const; Bool_tRooAbsArg::isShapeServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isShapeServer(const char* name) const; virtual Bool_tRooAbsArg::IsSortable() const; virtual Bool_tRooAbsRealLValue::isValidReal(Double_t value, Bool_t printError = kFALSE) const; Bool_tRooAbsArg::isValueDirty() const; Bool_tRooAbsArg::isValueDirtyAndClear() const; Bool_tRooAbsArg::isValueOrShapeDirtyAndClear() const; Bool_tRooAbsArg::isValueServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isValueServer(const char* name) const; Bool_tTObject::IsZombie() const; virtual Double_tRooAbsRealLValue::jacobian() const; voidRooAbsArg::leafNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; Bool_tRooAbsArg::localNoDirtyInhibit() const; voidRooAbsReal::logEvalError(const char* message, const char* serverValueString = 0) const; static voidRooAbsReal::logEvalError(const RooAbsReal* originator, const char* origName, const char* message, const char* serverValueString = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooAbsMoment*RooAbsReal::mean(RooRealVar& obs); RooAbsMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; virtual Bool_tTObject::Notify(); virtual Int_tRooAbsRealLValue::numBins(const char* rangeName = 0) const; virtual Int_tRooAbsRealLValue::numBins(const RooAbsBinning& binning) const; Int_tRooAbsArg::numCaches()",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooErrorVar.html:21032,log,logEvalError,21032,root/html534/RooErrorVar.html,https://root.cern,https://root.cern/root/html534/RooErrorVar.html,6,['log'],['logEvalError']
Testability,"ol_tRooResolutionModel::isConvolved(); virtual Bool_tRooAbsArg::isDerived() const; virtual Bool_tisDirectGenSafe(const RooAbsArg& arg) const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; virtual Bool_tRooAbsArg::isFundamental() const; virtual Bool_tRooAbsArg::isLValue() const; Bool_tTObject::IsOnHeap() const; Bool_tRooAbsArg::isShapeDirty() const; Bool_tRooAbsArg::isShapeServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isShapeServer(const char* name) const; virtual Bool_tRooAbsArg::IsSortable() const; Bool_tRooAbsArg::isValueDirty() const; Bool_tRooAbsArg::isValueServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isValueServer(const char* name) const; Bool_tTObject::IsZombie() const; voidRooAbsArg::leafNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; voidRooAbsReal::logEvalError(const char* message, const char* serverValueString = 0) const; static voidRooAbsReal::logEvalError(const RooAbsReal* originator, const char* origName, const char* message, const char* serverValueString = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooMoment*RooAbsReal::mean(RooRealVar& obs); RooMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); Int_tRooAbsPdf::minDimNormValueCaching() const; virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tRooAbsPdf::mustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); virtual voidRooResolutionModel::normLeafServerList(RooArgSet& list) const; const char*RooAbsPdf::normRange() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCache",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooAddModel.html:20934,log,logEvalError,20934,root/html528/RooAddModel.html,https://root.cern,https://root.cern/root/html528/RooAddModel.html,2,['log'],['logEvalError']
Testability,"ol_tRooResolutionModel::isConvolved(); virtual Bool_tRooAbsArg::isDerived() const; virtual Bool_tisDirectGenSafe(const RooAbsArg& arg) const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; virtual Bool_tRooAbsArg::isFundamental() const; virtual Bool_tRooAbsArg::isLValue() const; Bool_tTObject::IsOnHeap() const; Bool_tRooAbsArg::isShapeDirty() const; Bool_tRooAbsArg::isShapeServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isShapeServer(const char* name) const; virtual Bool_tRooAbsArg::IsSortable() const; Bool_tRooAbsArg::isValueDirty() const; Bool_tRooAbsArg::isValueServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isValueServer(const char* name) const; Bool_tTObject::IsZombie() const; voidRooAbsArg::leafNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; voidRooAbsReal::logEvalError(const char* message, const char* serverValueString = 0) const; static voidRooAbsReal::logEvalError(const RooAbsReal* originator, const char* origName, const char* message, const char* serverValueString = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooMoment*RooAbsReal::mean(RooRealVar& obs); RooMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); Int_tRooAbsPdf::minDimNormValueCaching() const; virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tRooAbsPdf::mustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); virtual voidRooResolutionModel::normLeafServerList(RooArgSet& list) const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEva",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAddModel.html:20680,log,logEvalError,20680,root/html526/RooAddModel.html,https://root.cern,https://root.cern/root/html526/RooAddModel.html,1,['log'],['logEvalError']
Testability,"ol_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; Double_tTMVA::PDEFoamDensityBase::GetBoxVolume(); TMVA::MsgLogger&TMVA::PDEFoamDensityBase::Log() const; voidTObject::MakeZombie(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TMVA::BinarySearchTree*TMVA::PDEFoamDensityBase::fBstBinary tree to find events within a volume; UInt_tfClasssignal class; TMVA::MsgLogger*TMVA::PDEFoamDensityBase::fLogger! message logger. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; PDEFoamDecisionTreeDensity(); {}. PDEFoamDecisionTreeDensity(vector<Double_t> box, UInt_t cls); User construcor:. Parameters:. - box - size of the range-searching box (n-dimensional; std::vector). - cls - event class used for the range-searching. PDEFoamDecisionTreeDensity(const TMVA::PDEFoamDecisionTreeDensity& ); Copy constructor. Double_t Density(vector<Double_t>& Xarg, Double_t& event_density); This function is not used in the decision tree like PDEFoam,; instead FillHist() is used. void FillHistograms(TMVA::Volume& , vector<TH1D*>& , vector<TH1D*>& , vector<TH1D*>& , vector<TH1D*>& ); Fill the given histograms with signal and background events,; which are found in the volume. Parameters:. - volume - volume box to search in. - hsig, hbkg, hsig_unw, hbkg_unw - histograms with weighted and; unweighte",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TMVA__PDEFoamDecisionTreeDensity.html:6291,log,logger,6291,root/html530/TMVA__PDEFoamDecisionTreeDensity.html,https://root.cern,https://root.cern/root/html530/TMVA__PDEFoamDecisionTreeDensity.html,3,['log'],['logger']
Testability,"ol_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; Double_tTMVA::PDEFoamDensityBase::GetBoxVolume(); TMVA::MsgLogger&TMVA::PDEFoamDensityBase::Log() const; voidTObject::MakeZombie(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TMVA::BinarySearchTree*TMVA::PDEFoamDensityBase::fBstBinary tree to find events within a volume; UInt_tfClasssignal class; TMVA::MsgLogger*TMVA::PDEFoamDensityBase::fLogger! message logger. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; PDEFoamDiscriminantDensity(); {}. PDEFoamDiscriminantDensity(vector<Double_t> box, UInt_t cls); User construcor:. Parameters:. - box - size of the range-searching box (n-dimensional; std::vector). - cls - event class used for the range-searching. PDEFoamDiscriminantDensity(const TMVA::PDEFoamDiscriminantDensity& ); Copy constructor. Double_t Density(vector<Double_t>& Xarg, Double_t& event_density); This function is needed during the foam buildup. It returns the; average number density of events of type fClass within the; range-searching volume (specified by fBox). Parameters:. - Xarg - event vector (in [fXmin,fXmax]) to place the box at. - event_density - here the event density is stored. Returns:. Number of events (event weights) of type fClass, which were; found in the range-searching volume at point",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TMVA__PDEFoamDiscriminantDensity.html:6238,log,logger,6238,root/html530/TMVA__PDEFoamDiscriminantDensity.html,https://root.cern,https://root.cern/root/html530/TMVA__PDEFoamDiscriminantDensity.html,2,['log'],['logger']
Testability,"ol_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; Double_tTMVA::PDEFoamDensityBase::GetBoxVolume(); TMVA::MsgLogger&TMVA::PDEFoamDensityBase::Log() const; voidTObject::MakeZombie(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TMVA::BinarySearchTree*TMVA::PDEFoamDensityBase::fBstBinary tree to find events within a volume; UInt_tfClasssignal class; TMVA::MsgLogger*TMVA::PDEFoamDensityBase::fLogger! message logger. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; PDEFoamDiscriminantDensity(); {}. PDEFoamDiscriminantDensity(vector<Double_t> box, UInt_t cls); User construcor:. Parameters:. - box - size of the range-searching box (n-dimensional; std::vector). - cls - event class used for the range-searching. PDEFoamDiscriminantDensity(const TMVA::PDEFoamDiscriminantDensity& ); Copy constructor. Double_t Density(vector<Double_t>& Xarg, Double_t& event_density); This function is needed during the foam buildup. It returns the; average number density of events of type fClass within the; range-searching volume (specified by fBox). Parameters:. - xev - event vector (in [fXmin,fXmax]) to place the box at. - event_density - here the event density is stored. Returns:. Number of events (event weights) of type fClass, which were; found in the range-searching volume at point ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TMVA__PDEFoamDiscriminantDensity.html:6257,log,logger,6257,root/html534/TMVA__PDEFoamDiscriminantDensity.html,https://root.cern,https://root.cern/root/html534/TMVA__PDEFoamDiscriminantDensity.html,1,['log'],['logger']
Testability,"ol_t_verboseVerbose messaging if true; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~RooAbsTestStatistic(); Destructor. Double_t evaluate() const; Calculates and return value of test statistic. If the test statistic; is calculated from on a RooSimultaneous, the test statistic calculation; is performed separately on each simultaneous p.d.f component and associated; data and then combined. If the test statistic calculation is parallelized; partitions are calculated in nCPU processes and a posteriori combined. Bool_t initialize(); One-time initialization of the test statistic. Setup; infrastructure for simultaneous p.d.f processing and/or; parallelized processing if requested. Bool_t redirectServersHook(const RooAbsCollection& newServerList, Bool_t mustReplaceAll, Bool_t nameChange, Bool_t isRecursive); Forward server redirect calls to component test statistics. void printCompactTreeHook(ostream& os, const char* indent = """"); Add extra information on component test statistics when printing; itself as part of a tree structure. void constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); Forward constant term optimization management calls to component; test statistics. void setMPSet(Int_t setNum, Int_t numSets); Set MultiProcessor set number identification of this instance. void initMPMode(RooAbsReal* real, RooAbsData* data, const RooArgSet* projDeps, const char* rangeName, const char* addCoefRangeName); Initialize multi-processor calculation mode. Create component test statistics in separate; processed that are connected to this process through a RooAbsRealMPFE front-end class. void initSimMode(RooSimultaneous* pdf, RooAbsData* data, const RooArgSet* projDeps, const char* rangeName, const char* addCoefRangeName); I",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAbsTestStatistic.html:39886,test,test,39886,root/html534/RooAbsTestStatistic.html,https://root.cern,https://root.cern/root/html534/RooAbsTestStatistic.html,1,['test'],['test']
Testability,"old value which the user must set (TMultiDimFit::SetMinAngle). Figure 1: (a) angle \f$\theta\f$ between \f$\textbf{w}_l\f$ and \f$\textbf{f}_L\f$, (b) angle \f$ \phi \f$ between \f$\textbf{w}_L\f$ and \f$\textbf{D}\f$. Test 2; Let \(\textbf{D}\) be the data vector to be fitted. As illustrated in figure 1, the \(L^{\mbox{th}}\) function \(\textbf{w}_L\) will contribute significantly to the reduction of \( S\), if the angle \(\phi^\prime\) between \(\textbf{w}_L\) and \(\textbf{D}\) is smaller than an upper limit \( \phi \), defined by the user (MultiDimFit::SetMaxAngle); However, the method automatically readjusts the value of this angle while fitting is in progress, in order to make the selection criteria less and less difficult to be fulfilled. The result is that the functions contributing most to the reduction of \( S\) are chosen first (TMultiDimFit::TestFunction).; In case \( \phi \) isn't defined, an alternative method of performing this second test is used: The \(L^{\mbox{th}}\) function \(\textbf{f}_L\) is accepted if (refer also to equation (13)) ; \[; \Delta S_L > \frac{S_{L-1}}{L_{max}-L}; \]. where \( S_{L-1}\) is the sum of the \( L-1\) first residuals from the \( L-1\) functions previously accepted; and \( L_{max}\) is the total number of functions allowed in the final expression of the fit (defined by user).; From this we see, that by restricting \( L_{max}\)  the number of terms in the final model  the fit is more difficult to perform, since the above selection criteria is more limiting.; The more coefficients we evaluate, the more the sum of squares of residuals \( S\) will be reduced. We can evaluate \( S\) before inverting \(\mathsf{B}\) as shown below. Coefficients and Coefficient Errors; Having found a parameterization, that is the \( F_l\)'s and \( L\), that minimizes \( S\), we still need to determine the coefficients \( c_l\). However, it's a feature of how we choose the significant functions, that the evaluation of the \( c_l\)'s becomes tr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMultiDimFit.html:11069,test,test,11069,doc/master/classTMultiDimFit.html,https://root.cern,https://root.cern/doc/master/classTMultiDimFit.html,1,['test'],['test']
Testability,"oldDensity and TUnfoldBinning ; testUnfold7b.C Test program for the classes TUnfoldDensity and TUnfoldBinning ; testUnfold7c.C Test program for the classes TUnfoldDensity and TUnfoldBinning ; unuran; unuranDemo.CExample macro to show unuran capabilities The results are compared with what is obtained using TRandom or TF1::GetRandom The macro is divided in 3 parts: ; unuranFoamTest.CThis program must be compiled and executed with Aclic as follows ; v7; concurrentfill.cxx; draw.cxx; histops.cxx; histspeedtest.cxx; perf.cxx; perfcomp.cxx; simple.cxx; xml; DOMParsePerson.C ROOT implementation of a XML DOM Parser ; DOMRecursive.C ROOT implementation of a XML DOM Parser ; SAXHandler.C ROOT implementation of a simple SAX Handler ; xmlnewfile.C Example to create a new xml file with the TXMLEngine class ; xmlreadfile.C Example to read and parse any xml file, supported by TXMLEngine class The input file, produced by xmlnewfile.C macro is used If you need full xml syntax support, use TXMLParser instead ; benchmarks.CThis macro run several tests and produces an benchmark report ; demos.CThis macro shows a control bar to run some of the ROOT tutorials ; demoshelp.CThis macro shows help on running the Demos ; geant3tasks.CThis script is a representation using TTasks of the Geant3 simulation program This example uses directly TTask objects ; hsimple.C This program creates : ; htmlex.CThis file demonstrates how THtml can document sources ; MyTasks.cxxA set of classes deriving from TTask ; regexp.CA regular expression, often called a pattern, is an expression that describes a set of strings ; regexp_pme.CClass TPMERegexp - API similar to PME - PCRE Made Easy Tries to be as close as possible to PERL syntax and functionality ; rootalias.CDefines aliases: ; rootenv.CProduce a picture of the ROOT environment ; rootlogoff.CExample of rootlogoff.C ; rootlogon.CExample of rootlogon.C ; rootmarks.CPrints a summary of all ROOT benchmarks (must be run bef",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v610/files.html:161303,benchmark,benchmarks,161303,doc/v610/files.html,https://root.cern,https://root.cern/doc/v610/files.html,1,['benchmark'],['benchmarks']
Testability,"oldDensity and TUnfoldBinning ; testUnfold7c.C Test program for the classes TUnfoldDensity and TUnfoldBinning ; unuran; unuranDemo.CExample macro to show unuran capabilities The results are compared with what is obtained using TRandom or TF1::GetRandom The macro is divided in 3 parts: ; unuranFoamTest.CThis program must be compiled and executed with Aclic as follows ; v7; concurrentfill.cxx; draw.cxx; histops.cxx; histspeedtest.cxx; perf.cxx; perfcomp.cxx; simple.cxx; xml; DOMParsePerson.C ROOT implementation of a XML DOM Parser ; DOMRecursive.C ROOT implementation of a XML DOM Parser ; SAXHandler.C ROOT implementation of a simple SAX Handler ; xmlnewfile.C Example to create a new xml file with the TXMLEngine class ; xmlreadfile.C Example to read and parse any xml file, supported by TXMLEngine class The input file, produced by xmlnewfile.C macro is used If you need full xml syntax support, use TXMLParser instead ; benchmarks.CThis macro run several tests and produces an benchmark report ; demos.CThis macro shows a control bar to run some of the ROOT tutorials ; demoshelp.CThis macro shows help on running the Demos ; geant3tasks.CThis script is a representation using TTasks of the Geant3 simulation program This example uses directly TTask objects ; hsimple.C This program creates : ; htmlex.CThis file demonstrates how THtml can document sources ; MyTasks.cxxA set of classes deriving from TTask ; regexp.CA regular expression, often called a pattern, is an expression that describes a set of strings ; regexp_pme.CClass TPMERegexp - API similar to PME - PCRE Made Easy Tries to be as close as possible to PERL syntax and functionality ; rootalias.CDefines aliases: ; rootenv.CProduce a picture of the ROOT environment ; rootlogoff.CExample of rootlogoff.C ; rootlogon.CExample of rootlogon.C ; rootmarks.CPrints a summary of all ROOT benchmarks (must be run before) ; tasks.CExample of TTasks . ROOT 6.10/09 - Reference Guide Generated on Th",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v610/files.html:161338,test,tests,161338,doc/v610/files.html,https://root.cern,https://root.cern/doc/v610/files.html,2,"['benchmark', 'test']","['benchmark', 'tests']"
Testability,"older() const; virtual Bool_tRooAbsArg::isFundamental() const; virtual Bool_tRooAbsReal::isIdentical(const RooAbsArg& other, Bool_t assumeSameType = kFALSE); virtual Bool_tRooAbsArg::isLValue() const; virtual Bool_tRooAbsReal::isOffsetting() const; Bool_tTObject::IsOnHeap() const; Bool_tRooAbsArg::isShapeDirty() const; Bool_tRooAbsArg::isShapeServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isShapeServer(const char* name) const; virtual Bool_tRooAbsArg::IsSortable() const; Bool_tRooAbsArg::isValueDirty() const; Bool_tRooAbsArg::isValueDirtyAndClear() const; Bool_tRooAbsArg::isValueOrShapeDirtyAndClear() const; Bool_tRooAbsArg::isValueServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isValueServer(const char* name) const; Bool_tTObject::IsZombie() const; voidRooAbsArg::leafNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; voidLoadDataSet(RooDataSet& data); Bool_tRooAbsArg::localNoDirtyInhibit() const; voidRooAbsReal::logEvalError(const char* message, const char* serverValueString = 0) const; static voidRooAbsReal::logEvalError(const RooAbsReal* originator, const char* origName, const char* message, const char* serverValueString = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tmaxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooAbsMoment*RooAbsReal::mean(RooRealVar& obs); RooAbsMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tRooAbsPdf::mustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; const char*RooAbsPdf::normRange() const; virtual Bool_tTObject::Notify(); Int_tRo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooKeysPdf.html:21865,log,logEvalError,21865,root/html534/RooKeysPdf.html,https://root.cern,https://root.cern/root/html534/RooKeysPdf.html,3,['log'],['logEvalError']
Testability,"olds. StreamerNVirtual(). void TMVA::Configurable::StreamerNVirtual ; (; TBuffer &; ClassDef_StreamerNVirtual_b). inline . Definition at line 138 of file Configurable.h. WriteOptionsReferenceToFile(). void TMVA::Configurable::WriteOptionsReferenceToFile ; (; ). protected . write complete options to output stream ; Definition at line 409 of file Configurable.cxx. WriteOptionsToStream(). void TMVA::Configurable::WriteOptionsToStream ; (; std::ostream &; o, . const TString &; prefix. ); const. write options to output stream (e.g. in writing the MVA weight files ; Definition at line 333 of file Configurable.cxx. Member Data Documentation. fConfigDescription. TString TMVA::Configurable::fConfigDescription. private . description of this configurable ; Definition at line 116 of file Configurable.h. fLastDeclaredOption. OptionBase* TMVA::Configurable::fLastDeclaredOption. private . ! last declared option ; Definition at line 113 of file Configurable.h. fListOfOptions. TList TMVA::Configurable::fListOfOptions. private . option list ; Definition at line 114 of file Configurable.h. fLogger. MsgLogger* TMVA::Configurable::fLogger. mutableprotected . ! message logger ; Definition at line 128 of file Configurable.h. fLooseOptionCheckingEnabled. Bool_t TMVA::Configurable::fLooseOptionCheckingEnabled. private . checker for option string ; Definition at line 110 of file Configurable.h. fOptions. TString TMVA::Configurable::fOptions. private . options string ; Definition at line 109 of file Configurable.h. fReferenceFile. TString TMVA::Configurable::fReferenceFile. private . reference file for options writing ; Definition at line 117 of file Configurable.h. Libraries for TMVA::Configurable:. [legend]; The documentation for this class was generated from the following files:; tmva/tmva/inc/TMVA/Configurable.h; tmva/tmva/src/Configurable.cxx. TMVAConfigurable. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:45:30 (GVA Time) using Doxygen 1.9.8 ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1Configurable.html:22773,log,logger,22773,doc/master/classTMVA_1_1Configurable.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1Configurable.html,1,['log'],['logger']
Testability,"olfComputationsAltDoneFlagflag if the fAlternatePValue computation have been already done or not (ie need to be refreshed); boolfComputationsNulDoneFlagflag if the fNullPValue computation have been already done or not (ie need to be refreshed); boolfSumLargerValuesp-value for velues of testStat >= testStat_data (or testStat <= testStat_data); vector<double>fTestStat_bvector of results for B-only toy-MC; doublefTestStat_dataresults (test statistics) evaluated for data; vector<double>fTestStat_sbvector of results for S+B toy-MC. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; HybridResult( const char *name); HybridResult default constructor (with name ). HybridResult(const char* name, vector<double>& testStat_sb_vals, vector<double>& testStat_b_vals, bool sumLargerValues = true); HybridResult constructor (with name, title and vectors of S+B and B values). ~HybridResult(); HybridResult destructor. void SetDataTestStatistics(double testStat_data_val); set the value of the test statistics on data. double NullPValue() const; return 1-CL_b : the B p-value. double AlternatePValue() const; return CL_s+b : the S+B p-value. Double_t CLbError() const; Returns an estimate of the error on CLb assuming a binomial error on; CLb:. Double_t CLsplusbError() const; Returns an estimate of the error on CLsplusb assuming a binomial; error on CLsplusb:. Double_t CLsError() const; Returns an estimate of the error on CLs through combination of the; errors on CLb and CLsplusb:. void Add(RooStats::HybridResult* other); add additional toy-MC experiments to the current results; use the data test statistics of the added object if none is already present (otherwise, ignore the new one). HybridPlot* GetPlot(const char* name, const char* title, int n_bins); prepare a plot showing a result and return a pointer to a HybridPlot object; the needed arguments are: an object name, a title and the number of bins in the plot. void PrintMore(const char* options); Pri",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooStats__HybridResult.html:8466,test,test,8466,root/html526/RooStats__HybridResult.html,https://root.cern,https://root.cern/root/html526/RooStats__HybridResult.html,1,['test'],['test']
Testability,"ollection member-wise.; 518 ; 519 UInt_t pos = b.WriteVersionMemberWise(this->IsA(),kTRUE);; 520 b.WriteVersion( vClass, kFALSE );; 521 DOLOOP {; 522 char **contp = (char**)(arr[k]+ioffset);; 523 for(int j=0;j<compinfo[i]->fLength;++j) {; 524 char *cont = contp[j];; 525 TVirtualCollectionProxy::TPushPop helper( proxy, cont );; 526 Int_t nobjects = cont ? proxy->Size() : 0;; 527 b << nobjects;; 528 if (nobjects) {; 529 auto actions = proxy->GetWriteMemberWiseActions();; 530 ; 531 char startbuf[TVirtualCollectionProxy::fgIteratorArenaSize];; 532 char endbuf[TVirtualCollectionProxy::fgIteratorArenaSize];; 533 void *begin = &(startbuf[0]);; 534 void *end = &(endbuf[0]);; 535 proxy->GetFunctionCreateIterators(/* read = */ kFALSE)(cont, &begin, &end, proxy);; 536 // We can not get here with a split vector of pointer, so we can indeed assume; 537 // that actions->fConfiguration != null.; 538 b.ApplySequence(*actions, begin, end);; 539 ; 540 if (begin != &(startbuf[0])) {; 541 // assert(end != endbuf);; 542 proxy->GetFunctionDeleteTwoIterators()(begin,end);; 543 }; 544 }; 545 }; 546 }; 547 b.SetByteCount(pos,kTRUE);; 548 continue;; 549 }; 550 UInt_t pos = b.WriteVersion(this->IsA(),kTRUE);; 551 if (pstreamer == 0) {; 552 DOLOOP {; 553 char **contp = (char**)(arr[k]+ioffset);; 554 for(int j=0;j<compinfo[i]->fLength;++j) {; 555 char *cont = contp[j];; 556 cl->Streamer( cont, b );; 557 }; 558 }; 559 } else {; 560 DOLOOP{(*pstreamer)(b,arr[k]+ioffset,compinfo[i]->fLength);}; 561 }; 562 b.SetByteCount(pos,kTRUE);; 563 }; 564 continue;; 565 ; 566 case TStreamerInfo::kSTL: // container with no virtual table (stl) and no comment; 567 case TStreamerInfo::kSTL + TStreamerInfo::kOffsetL: // array of containers with no virtual table (stl) and no comment; 568 {; 569 TClass *cl = compinfo[i]->fClass;; 570 TMemberStreamer *pstreamer = compinfo[i]->fStreamer;; 571 TVirtualCollectionProxy *proxy = cl->GetCollectionProxy();; 572 TClass* vClass = proxy ? proxy->GetValueClass() : 0;; 573 if (!b",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TStreamerInfoWriteBuffer_8cxx_source.html:23222,assert,assert,23222,doc/master/TStreamerInfoWriteBuffer_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TStreamerInfoWriteBuffer_8cxx_source.html,1,['assert'],['assert']
Testability,"olor picker.; 1951///; 1952/// The color retrieval is done using a threshold defined by SetColorThreshold.; 1953 ; 1954 ; 1955Int_t TColor::GetColor(ULong_t pixel); 1956{; 1957 Int_t r, g, b;; 1958 ; 1959 Pixel2RGB(pixel, r, g, b);; 1960 ; 1961 return GetColor(r, g, b);; 1962}; 1963 ; 1964////////////////////////////////////////////////////////////////////////////////; 1965/// This method specifies the color threshold used by GetColor to retrieve a color.; 1966///; 1967/// \param[in] t Color threshold. By default is equal to 1./31. or 1./255.; 1968/// depending on the number of available color planes.; 1969///; 1970/// When GetColor is called, it scans the defined colors and compare them to the; 1971/// requested color.; 1972/// If the Red Green and Blue values passed to GetColor are Rr Gr Br; 1973/// and Rd Gd Bd the values of a defined color. These two colors are considered equal; 1974/// if (abs(Rr-Rd) < t & abs(Br-Bd) < t & abs(Br-Bd) < t). If this test passes,; 1975/// the color defined by Rd Gd Bd is returned by GetColor.; 1976///; 1977/// To make sure GetColor will return a color having exactly the requested; 1978/// R G B values it is enough to specify a nul :; 1979/// ~~~ {.cpp}; 1980/// TColor::SetColorThreshold(0.);; 1981/// ~~~; 1982///; 1983/// To reset the color threshold to its default value it is enough to do:; 1984/// ~~~ {.cpp}; 1985/// TColor::SetColorThreshold(-1.);; 1986/// ~~~; 1987 ; 1988void TColor::SetColorThreshold(Float_t t); 1989{; 1990 gColorThreshold = t;; 1991}; 1992 ; 1993////////////////////////////////////////////////////////////////////////////////; 1994/// Static method returning color number for color specified by; 1995/// r, g and b. The r,g,b should be in the range [0,255].; 1996/// If the specified color does not exist it will be created; 1997/// with as name ""#rrggbb"" with rr, gg and bb in hex between; 1998/// [0,FF].; 1999///; 2000/// The color retrieval is done using a threshold defined by SetColorThreshold.; 2001 ; 2002Int_",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TColor_8cxx_source.html:70726,test,test,70726,doc/master/TColor_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TColor_8cxx_source.html,1,['test'],['test']
Testability,"olor.C Palette coloring for graphs is activated thanks to the options PFC (Palette Fill Color), PLC (Palette Line Color) and AMC (Palette Marker Color) ; graphpolar.C Create and draw a polar graph ; graphpolar2.C Create and draw a polar graph with PI axis ; graphpolar3.C Create and draw a polar graph with PI axis using a TF1 ; graphShade.C Show how to shade an area between two graphs ; graphstruct.C Draw a simple graph structure ; graphtext.C Draw a graph with text attached to each point ; gtime.C Example of TGraphTime ; gtime2.C Example of TGraphTime showing how the class could be used to visualize a set of particles with their time stamp in a MonteCarlo program ; hlGraph1.CThis tutorial demonstrates how to use the highlight mode on graph ; hlGraph2.CThis tutorial demonstrates how to use the highlight mode on graph ; labels1.C Setting alphanumeric labels in a 1-d histogram ; labels2.C Setting alphanumeric labels ; motorcycle.C Macro to test scatterplot smoothers: ksmooth, lowess, supsmu as described in: ; multigraph.C Create and Draw a TMultiGraph ; multigraphpalettecolor.C Palette coloring for multi-graphs is activated thanks to the options PFC (Palette Fill Color), PLC (Palette Line Color) and AMC (Palette Marker Color) ; multipalette.C Draw color plots using different color palettes ; seism.C Strip chart example ; splines_test.C Examples of use of the spline classes ; surfaces.C Draw 2-Dim functions ; timeonaxis.C This macro illustrates the use of the time mode on the axis with different time intervals and time formats ; timeonaxis2.C Define the time offset as 2003, January 1st ; timeonaxis3.C This example compares what the system time function gmtime and localtime give with what gives TGaxis ; timeSeriesFromCSV.C This macro illustrates the use of the time axis on a TGraph with data read from a text file containing the SWAN usage statistics during July 2017 ; timeSeriesFromCSV.py This macro illustrates the use of the time axis on a TGraph",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v616/files.html:119497,test,test,119497,doc/v616/files.html,https://root.cern,https://root.cern/doc/v616/files.html,1,['test'],['test']
Testability,"ols which can produce both RooStats HypoTestResults and ConfIntervals ; CConfidenceBeltConfidenceBelt is a concrete implementation of the ConfInterval interface ; CConfIntervalConfInterval is an interface class for a generic interval in the RooStats framework ; CDebuggingSampler; CDebuggingTestStat; CDetailedOutputAggregator; CFeldmanCousins(like the Feldman-Cousins technique) is essentially a specific configuration of the more general NeymanConstruction ; CFrequentistCalculatorHypothesis Test Calculator using a full frequentist procedure for sampling the test statistic distribution ; CHeavisideRepresents the Heaviside function ; CHLFactoryHLFactory is an High Level model Factory allows you to describe your models in a configuration file (datacards) acting as an interface with the RooFactoryWSTool ; CHybridCalculatorThis class implements the Hypothesis test calculation using an hybrid (frequentist/bayesian) procedure ; CHybridCalculatorOriginalHybridCalculatorOriginal class ; CHybridPlotThis class provides the plots for the result of a study performed with the HybridCalculatorOriginal class ; CHybridResult; CHypoTestCalculatorHypoTestCalculator is an interface class for a tools which produce RooStats HypoTestResults ; CHypoTestCalculatorGenericCommon base class for the Hypothesis Test Calculators ; CHypoTestInverterHypoTestInverter class for performing an hypothesis test inversion by scanning the hypothesis test results of an HypoTestCalculator for various values of the parameter of interest ; CHypoTestInverterOriginalThis class is now depratcated and to be replaced by the HypoTestInverter ; CHypoTestInverterPlotClass to plot an HypoTestInverterResult, result of the HypoTestInverter calculator ; CHypoTestInverterResultHypoTestInverterResult class: holds the array of hypothesis test results and compute a confidence interval ; CHypoTestPlotThis class provides the plots for the result of a study performed with any of the HypoTestCalculatorGeneric (e.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v608/annotated.html:5158,test,test,5158,doc/v608/annotated.html,https://root.cern,https://root.cern/doc/v608/annotated.html,6,['test'],['test']
Testability,"ols::GetSeparationDouble_t GetSeparation(TH1 *S, TH1 *B) constcompute ""separation"" defined asDefinition Tools.cxx:121; TMVA::Tools::Instancestatic Tools & Instance()Definition Tools.cxx:71; TMVA::Tools::GetSQRootMatrixTMatrixD * GetSQRootMatrix(TMatrixDSym *symMat)square-root of symmetric matrix of course the resulting sqrtMat is also symmetric,...Definition Tools.cxx:271; TMVA::Tools::MVADiffstd::vector< Double_t > MVADiff(std::vector< Double_t > &, std::vector< Double_t > &)computes difference between two vectorsDefinition Tools.cxx:506; TMVA::Tools::GetIndexMinElementInt_t GetIndexMinElement(std::vector< Double_t > &)find index of minimum entry in vectorDefinition Tools.cxx:765; TMVA::Tools::projNormTH1FTH1 * projNormTH1F(TTree *theTree, const TString &theVarName, const TString &name, Int_t nbins, Double_t xmin, Double_t xmax, const TString &cut)projects variable from tree into normalised histogramDefinition Tools.cxx:366; TMVA::Tools::ROOTVersionMessagevoid ROOTVersionMessage(MsgLogger &logger)prints the ROOT release number and dateDefinition Tools.cxx:1325; TMVA::Tools::ReplaceRegularExpressionsTString ReplaceRegularExpressions(const TString &s, const TString &replace=""+"")replace regular expressions helper function to remove all occurrences ""$!%^&()'<>?...Definition Tools.cxx:798; TMVA::Tools::ReadTVectorDFromXMLvoid ReadTVectorDFromXML(void *node, const char *name, TVectorD *vec)Definition Tools.cxx:1267; TMVA::Tools::GetCumulativeDistTH1 * GetCumulativeDist(TH1 *h)get the cumulative distribution of a histogramDefinition Tools.cxx:1756; TMVA::Tools::ReadFloatArbitraryPrecisionvoid ReadFloatArbitraryPrecision(Float_t &val, std::istream &is)reads a float value with the available precision from a streamDefinition Tools.cxx:1073; TMVA::Tools::AddRawLineBool_t AddRawLine(void *node, const char *raw)XML helpers.Definition Tools.cxx:1190; TMVA::Tools::~Tools~Tools()destructorDefinition Tools.cxx:101; TMVA::Tools::ContainsRegularExpressionBool_t ContainsRegularExpress",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/Tools_8cxx_source.html:74634,log,logger,74634,doc/master/Tools_8cxx_source.html,https://root.cern,https://root.cern/doc/master/Tools_8cxx_source.html,1,['log'],['logger']
Testability,olverDens.cxx; TQpLinSolverSparse.cxx; TQpProbBase.cxx; TQpProbDens.cxx; TQpProbSparse.cxx; TQpResidual.cxx; TQpSolverBase.cxx; TQpVar.cxx; rtools; inc; Math; RMinimizer.h; LinkDef.h; src; RMinimizer.cxx; smatrix; inc; Math; BinaryOperators.h; BinaryOpPolicy.h; CholeskyDecomp.hHeader file containing the templated implementation of matrix inversion routines for use with ROOT's SMatrix classes (symmetric positive definite case) ; CramerInversion.icc; CramerInversionSym.icc; Dfact.h; Dfactir.h; Dfinv.h; Dinv.h; Dsfact.h; Dsinv.h; Expression.h; Functions.h; HelperOps.h; MatrixFunctions.h; MatrixInversion.icc; MatrixRepresentationsStatic.h; MConfig.h; SMatrix.h; SMatrix.icc; SMatrixDfwd.h; SMatrixFfwd.h; StaticCheck.h; SVector.h; SVector.icc; UnaryOperators.h; LinkDef.h; LinkDefAll.h; LinkDefD32.h; src; Dict.h; test; kalman.C; matrix_op.h; matrix_util.h; matrixOperations.C; stressKalman.cxx; stressOperations.cxx; testInversion.cxx; testIO.cxx; testKalman.cxx; testOperations.cxx; testSMatrix.cxx; TestTimer.h; Track.h; TrackLinkDef.h; splot; inc; LinkDef.h; TSPlot.h; src; TSPlot.cxx; unuran; inc; LinkDef.h; TUnuran.h; TUnuranBaseDist.h; TUnuranContDist.h; TUnuranDiscrDist.h; TUnuranEmpDist.h; TUnuranMultiContDist.h; TUnuranSampler.h; src; TUnuran.cxx; TUnuranContDist.cxx; TUnuranDiscrDist.cxx; TUnuranEmpDist.cxx; TUnuranMultiContDist.cxx; TUnuranSampler.cxx; UnuranDistr.h; UnuranDistrAdapter.h; UnuranRng.h; test; unuranDiscrete.cxx; unuranDistr.cxx; unuranHist.cxx; unuranMulti2D.cxx; unuranMultiDim.cxx; unuranSimple.cxx; vc; examples; buddhabrot; main.cpp; main.h; finitediff; main.cpp; fit; GaussFunction.h; MinimizerTypes.h; testFitPerf.cxx; genvector; vectorOperation.cxx; mandelbrot; main.cpp; main.h; mandel.cpp; mandel.h; matrix; main.cpp; polarcoord; main.cpp; smatrix; matrix_op_vec.h; matrix_util.h;,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html606/files.html:57014,test,testInversion,57014,root/html606/files.html,https://root.cern,https://root.cern/root/html606/files.html,1,['test'],['testInversion']
Testability,olverDens.cxx; TQpLinSolverSparse.cxx; TQpProbBase.cxx; TQpProbDens.cxx; TQpProbSparse.cxx; TQpResidual.cxx; TQpSolverBase.cxx; TQpVar.cxx; rtools; inc; Math; RMinimizer.h; LinkDef.h; src; RMinimizer.cxx; smatrix; inc; Math; BinaryOperators.h; BinaryOpPolicy.h; CholeskyDecomp.hHeader file containing the templated implementation of matrix inversion routines for use with ROOT's SMatrix classes (symmetric positive definite case) ; CramerInversion.icc; CramerInversionSym.icc; Dfact.h; Dfactir.h; Dfinv.h; Dinv.h; Dsfact.h; Dsinv.h; Expression.h; Functions.h; HelperOps.h; MatrixFunctions.h; MatrixInversion.icc; MatrixRepresentationsStatic.h; MConfig.h; SMatrix.h; SMatrix.icc; SMatrixDfwd.h; SMatrixFfwd.h; StaticCheck.h; SVector.h; SVector.icc; UnaryOperators.h; LinkDef.h; LinkDefAll.h; LinkDefD32.h; src; Dict.h; test; kalman.C; matrix_op.h; matrix_util.h; matrixOperations.C; stressKalman.cxx; stressOperations.cxx; testInversion.cxx; testIO.cxx; testKalman.cxx; testOperations.cxx; testSMatrix.cxx; TestTimer.h; Track.h; TrackLinkDef.h; splot; inc; LinkDef.h; TSPlot.h; src; TSPlot.cxx; unuran; inc; LinkDef.h; TUnuran.h; TUnuranBaseDist.h; TUnuranContDist.h; TUnuranDiscrDist.h; TUnuranEmpDist.h; TUnuranMultiContDist.h; TUnuranSampler.h; src; TUnuran.cxx; TUnuranContDist.cxx; TUnuranDiscrDist.cxx; TUnuranEmpDist.cxx; TUnuranMultiContDist.cxx; TUnuranSampler.cxx; UnuranDistr.h; UnuranDistrAdapter.h; UnuranRng.h; test; unuranDiscrete.cxx; unuranDistr.cxx; unuranHist.cxx; unuranMulti2D.cxx; unuranMultiDim.cxx; unuranSimple.cxx; vdt; include; vdt; asin.h; atan.h; atan2.h; cos.h; exp.h; inv.h; log.h; sin.h; sincos.h; sqrt.h; tan.h; vdtcore_common.h; vdtMath.h; tests; stressVdt.cxx; misc; memstat; inc; LinkDef.h; TMemStat.h; TMemStatBacktrace.h; TMemStatDef.h; TMemStatHelpers.h; TMemStatHook.h; TMemStatMng.h; src,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v608/files.html:57382,test,testInversion,57382,doc/v608/files.html,https://root.cern,https://root.cern/doc/v608/files.html,1,['test'],['testInversion']
Testability,"ol; markov, . Int_t; averWindow. ). One-dimensional high-resolution peak search function. ; This function searches for peaks in source spectrum. It is based on deconvolution method. First the background is removed (if desired), then Markov smoothed spectrum is calculated (if desired), then the response function is generated according to given sigma and deconvolution is carried out. The order of peaks is arranged according to their heights in the spectrum after background elimination. The highest peak is the first in the list. On success it returns number of found peaks.; Parameters:. source: pointer to the vector of source spectrum.; destVector: pointer to the vector of resulting deconvolved spectrum.; ssize: length of source spectrum.; sigma: sigma of searched peaks, for details we refer to manual.; threshold: threshold value in % for selected peaks, peaks with amplitude less than threshold*highest_peak/100 are ignored, see manual.; backgroundRemove: logical variable, set if the removal of background before deconvolution is desired.; deconIterations-number of iterations in deconvolution operation.; markov: logical variable, if it is true, first the source spectrum is replaced by new spectrum calculated using Markov chains method.; averWindow: averaging window of searched peaks, for details we refer to manual (applies only for Markov method). Peaks searching:; The goal of this function is to identify automatically the peaks in spectrum with the presence of the continuous background and statistical fluctuations - noise.; The common problems connected with correct peak identification are:. non-sensitivity to noise, i.e., only statistically relevant peaks should be identified.; non-sensitivity of the algorithm to continuous background.; ability to identify peaks close to the edges of the spectrum region. Usually peak finders fail to detect them.; resolution, decomposition of Double_tts and multiplets. The algorithm should be able to recognise close positioned peaks.;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSpectrum.html:56863,log,logical,56863,doc/master/classTSpectrum.html,https://root.cern,https://root.cern/doc/master/classTSpectrum.html,1,['log'],['logical']
Testability,"olgenerateAndFit (Int_t nSamples, Int_t nEvtPerSample=0, bool keepGenData=false, const char *asciiFilePat=nullptr); Generate and fit 'nSamples' samples of 'nEvtPerSample' events. ; ; const RooDataSet *genParDataSet () const; Return dataset with generator parameters for each toy. ; ; TClass *IsA () const override; ; RooPlot *plotError (const RooRealVar &param, const RooCmdArg &arg1={}, const RooCmdArg &arg2={}, const RooCmdArg &arg3={}, const RooCmdArg &arg4={}, const RooCmdArg &arg5={}, const RooCmdArg &arg6={}, const RooCmdArg &arg7={}, const RooCmdArg &arg8={}); Plot the distribution of the fit errors for the specified parameter on a newly created frame. ; ; RooPlot *plotError (const RooRealVar &param, double lo, double hi, Int_t nbins=100); Create a RooPlot of the distribution of the fitted errors of the given parameter. ; ; RooPlot *plotNLL (const RooCmdArg &arg1={}, const RooCmdArg &arg2={}, const RooCmdArg &arg3={}, const RooCmdArg &arg4={}, const RooCmdArg &arg5={}, const RooCmdArg &arg6={}, const RooCmdArg &arg7={}, const RooCmdArg &arg8={}); Plot the distribution of the -log(L) values on a newly created frame. ; ; RooPlot *plotNLL (double lo, double hi, Int_t nBins=100); Create a RooPlot of the -log(L) distribution in the range lo-hi with 'nBins' bins. ; ; RooPlot *plotParam (const char *paramName, const RooCmdArg &arg1={}, const RooCmdArg &arg2={}, const RooCmdArg &arg3={}, const RooCmdArg &arg4={}, const RooCmdArg &arg5={}, const RooCmdArg &arg6={}, const RooCmdArg &arg7={}, const RooCmdArg &arg8={}); Plot the distribution of the fitted value of the given parameter on a newly created frame. ; ; RooPlot *plotParam (const RooRealVar &param, const RooCmdArg &arg1={}, const RooCmdArg &arg2={}, const RooCmdArg &arg3={}, const RooCmdArg &arg4={}, const RooCmdArg &arg5={}, const RooCmdArg &arg6={}, const RooCmdArg &arg7={}, const RooCmdArg &arg8={}); Plot the distribution of the fitted value of the given parameter on a newly created fram",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooMCStudy.html:4901,log,log,4901,doc/master/classRooMCStudy.html,https://root.cern,https://root.cern/doc/master/classRooMCStudy.html,1,['log'],['log']
Testability,"om (4) Press W. H., Teukolsky S.A., Vetterling W.T., Flannery B.P. (2007), Numerical Recipes - The Art of Scientific Computing (Third Edition), Cambridge University Press ; Definition at line 921 of file GoFTest.cxx. LogNormalCDF(). Double_t ROOT::Math::GoFTest::LogNormalCDF ; (; Double_t; x); const. private . LogSample(). void ROOT::Math::GoFTest::LogSample ; (; ). private . Applies the logarithm to the sample when the specified distribution to test is LogNormal. ; Definition at line 303 of file GoFTest.cxx. operator()() [1/2]. void ROOT::Math::GoFTest::operator() ; (; ETestType; test, . Double_t &; pvalue, . Double_t &; testStat. ); const. The class's unary functions performing the gif test according to the ETestType provided. ; Definition at line 208 of file GoFTest.cxx. operator()() [2/2]. Double_t ROOT::Math::GoFTest::operator() ; (; ETestType; test = kAD, . const Char_t *; option = ""p"". ); const. Returns default Anderson Darling 1-Sample Test and default p-value; option ""t"" returns the test statistic value specific to the test type. ; Definition at line 225 of file GoFTest.cxx. operator=(). GoFTest ROOT::Math::GoFTest::operator= ; (; GoFTest &; gof). private . Disallowed assign operator. . PValueAD1Sample(). Double_t ROOT::Math::GoFTest::PValueAD1Sample ; (; Double_t; A2); const. private . Computation of the 1-Sample Anderson-Darling Test's p-value. ; Definition at line 483 of file GoFTest.cxx. PValueADKSamples(). Double_t ROOT::Math::GoFTest::PValueADKSamples ; (; size_t; nsamples, . Double_t; A2. ). static . Computation of the K-Sample Anderson-Darling Test's p-value as described in (1) ; Definition at line 353 of file GoFTest.cxx. SetCDF(). void ROOT::Math::GoFTest::SetCDF ; (; ). private . Definition at line 244 of file GoFTest.cxx. SetDistribution(). void ROOT::Math::GoFTest::SetDistribution ; (; EDistribution; dist, . const std::vector< double > &; distParams = {}. ). Sets the distribution for the predefined distribution ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1GoFTest.html:16689,test,test,16689,doc/master/classROOT_1_1Math_1_1GoFTest.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1GoFTest.html,2,['test'],['test']
Testability,"om of the page.; 5 : Landscape mode with a large margin at the bottom of the page. The large margin is useful for some PostScript printers (very often for the colour printers) as they need more space to grip the paper for mechanical reasons. Note that some PostScript colour printers can also use the so called special A4 format permitting the full usage of the A4 area; in this case larger margins are not necessary and Type=1 or 2 can be used.; 3 : Encapsulated PostScript. This Type permits the generation of files which can be included in other documents, for example in LaTeX files. Making several pictures in the same Postscript file: case 1; The following macro is an example illustrating how to open a Postscript file and draw several pictures. The generation of a new Postscript page is automatic when TCanvas::Clear is called by object->Draw().; {; TFile f(""hsimple.root"");; TCanvas c1(""c1"",""canvas"",800,600);; ; // select postscript output type; // type = 111 portrait ps; // type = 112 landscape ps; // type = 113 eps; Int_t type = 111;; ; // create a postscript file and set the paper size; TPostScript ps(""test.ps"",type);; ps.Range(16,24); //set x,y of printed page; ; // draw 3 histograms from file hsimple.root on separate pages; hpx->Draw();; c1.Update(); //force drawing in a macro; hprof->Draw();; c1.Update();; hpx->Draw(""lego1"");; c1.Update();; ps.Close();; }; f#define f(i)Definition RSha256.hxx:104; typeOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid window const char font_name cursor keysym reg const char only_if_exist regb h Point_t winding char text const char depth char const char Int_t count const cha",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTPostScript.html:5472,test,test,5472,doc/master/classTPostScript.html,https://root.cern,https://root.cern/doc/master/classTPostScript.html,1,['test'],['test']
Testability,"om the paper; 8045/// F.W Scholz, M.A. Stephens ""k-Sample Anderson-Darling Test"".; 8046///; 8047/// The test is implemented in root in the ROOT::Math::GoFTest class; 8048/// It is the same formula ( (6) in the paper), and also shown in; 8049/// [this preprint](http://arxiv.org/pdf/0804.0380v1.pdf); 8050///; 8051/// Binned data are considered as un-binned data; 8052/// with identical observation happening in the bin center.; 8053///; 8054/// \param[in] h2 Pointer to 1D histogram; 8055/// \param[in] option is a character string to specify options; 8056/// - ""D"" Put out a line of ""Debug"" printout; 8057/// - ""T"" Return the normalized A-D test statistic; 8058///; 8059/// - Note1: Underflow and overflow are not considered in the test; 8060/// - Note2: The test works only for un-weighted histogram (i.e. representing counts); 8061/// - Note3: The histograms are not required to have the same X axis; 8062/// - Note4: The test works only for 1-dimensional histograms; 8063 ; 8064Double_t TH1::AndersonDarlingTest(const TH1 *h2, Option_t *option) const; 8065{; 8066 Double_t advalue = 0;; 8067 Double_t pvalue = AndersonDarlingTest(h2, advalue);; 8068 ; 8069 TString opt = option;; 8070 opt.ToUpper();; 8071 if (opt.Contains(""D"") ) {; 8072 printf("" AndersonDarlingTest Prob = %g, AD TestStatistic = %g\n"",pvalue,advalue);; 8073 }; 8074 if (opt.Contains(""T"") ) return advalue;; 8075 ; 8076 return pvalue;; 8077}; 8078 ; 8079////////////////////////////////////////////////////////////////////////////////; 8080/// Same function as above but returning also the test statistic value; 8081 ; 8082Double_t TH1::AndersonDarlingTest(const TH1 *h2, Double_t & advalue) const; 8083{; 8084 if (GetDimension() != 1 || h2->GetDimension() != 1) {; 8085 Error(""AndersonDarlingTest"",""Histograms must be 1-D"");; 8086 return -1;; 8087 }; 8088 ; 8089 // empty the buffer. Probably we could add as an unbinned test; 8090 if (fBuffer) ((TH1*)this)->BufferEmpty();; 8091 ; 8092 // use the BinData class; 8093 ROOT::Fit:",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TH1_8cxx_source.html:316124,test,test,316124,doc/master/TH1_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html,1,['test'],['test']
Testability,"om this file. ; The key with name holding the list of TStreamerInfo objects is read. The corresponding TClass objects are updated. Note that this function is not called if the static member fgReadInfo is false. (see TFile::SetReadStreamerInfo) ; Definition at line 3605 of file TFile.cxx. Recover(). Int_t TFile::Recover ; (; ). virtual . Attempt to recover file if not correctly closed. ; The function returns the number of keys that have been recovered. If no keys can be recovered, the file will be declared Zombie by the calling function. This function is automatically called when opening a file. If the file is open in read only mode, the file is not modified. If open in update mode and the function finds something to recover, a new directory header is written to the file. When opening the file gain no message from Recover will be reported. If keys have been recovered, the file is usable and you can safely read the corresponding objects. If the file is not usable (a zombie), you can test for this case with code like:; TFile f(""myfile.root"");; if (f.IsZombie()) {<actions to take if file is unusable>}; If the file has been recovered, the bit kRecovered is set in the TFile object in memory. You can test if the file has been recovered with if (f.TestBit(TFile::kRecovered)) {... the file has been recovered}; When writing TTrees to a file, it is important to save the Tree header at regular intervals (see TTree::AutoSave). If a file containing a Tree is recovered, the last Tree header written to the file will be used. In this case all the entries in all the branches written before writing the header are valid entries. One can disable the automatic recovery procedure by setting TFile.Recover 0; in the system.rootrc file. ; Reimplemented in TSQLFile, and TXMLFile.; Definition at line 2048 of file TFile.cxx. ReOpen(). Int_t TFile::ReOpen ; (; Option_t *; mode). virtual . Reopen a file with a different access mode. ; For example, it is possible to change from READ to UPDATE ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTFile.html:89418,test,test,89418,doc/v632/classTFile.html,https://root.cern,https://root.cern/doc/v632/classTFile.html,2,['test'],['test']
Testability,"om this object; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static TList*TApplication::fgApplicationsList of available applications. private:. TStringfDefaultPromptdefault prompt: ""root [%d] ""; TFileHandler*fInputHandlerterminal input handler; Bool_tfInterruptif true macro execution will be stopped; Int_tfNcmdcommand history number; charfPrompt[64]interpreter prompt. Class Charts. Inheritance Chart:. TObject. TQObject. ; TApplication. ; TRint. Function documentation; TRint(const char* appClassName, int* argc, char** argv, void* options = 0, int numOptions = 0, Bool_t noLogo = kFALSE); Create an application environment. The TRint environment provides an; interface to the WM manager functionality and eventloop via inheritance; of TApplication and in addition provides interactive access to; the CINT C++ interpreter via the command line. ~TRint(); Destructor. void ExecLogon(); Execute logon macro's. There are three levels of logon macros that; will be executed: the system logon etc/system.rootlogon.C, the global; user logon ~/.rootlogon.C and the local ./.rootlogon.C. For backward; compatibility also the logon macro as specified by the Rint.Logon; environment setting, by default ./rootlogon.C, will be executed.; No logon macros will be executed when the system is started with; the -n option. void Run(Bool_t retrn = kFALSE); Main application eventloop. First process files given on the command; line and then go into the main application event loop, unless the -q; command line option was specfied in which case the program terminates.; When retrun is true this method returns even when -q was specified. When QuitOpt is true and retrn is false, terminate the application with; an error code equal to either the ProcessLine error (if any) or the; return value of the command casted to a long. void PrintLogo(Bool_t lite = kFALSE); Print the ROOT logo on standard output. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TRint.html:13755,log,logon,13755,root/html602/TRint.html,https://root.cern,https://root.cern/root/html602/TRint.html,1,['log'],['logon']
Testability,"om, TRandom *rng=nullptr)TF2virtual; GetRange(Double_t &xmin, Double_t &ymin, Double_t &xmax, Double_t &ymax) const overrideTF2virtual; GetRange(Double_t &xmin, Double_t &ymin, Double_t &zmin, Double_t &xmax, Double_t &ymax, Double_t &zmax) const overrideTF2virtual; GetRange(Double_t *xmin, Double_t *xmax) constTF2virtual; GetRange(Double_t &xmin, Double_t &xmax) constTF2virtual; GetRange(Double_t &xmin, Double_t &ymin, Double_t &xmax, Double_t &ymax) constTF2virtual; GetRange(Double_t &xmin, Double_t &ymin, Double_t &zmin, Double_t &xmax, Double_t &ymax, Double_t &zmax) constTF2virtual; GetSave(const Double_t *x) overrideTF2virtual; GetTitle() const overrideTNamedinlinevirtual; GetUniqueID() constTObjectvirtual; GetVariable(const TString &name)TF1inlinevirtual; GetX(Double_t y, Double_t xmin=0, Double_t xmax=0, Double_t epsilon=1.E-10, Int_t maxiter=100, Bool_t logx=false) constTF1virtual; GetXaxis() constTF1; GetXmax() constTF1inlinevirtual; GetXmin() constTF1inlinevirtual; GetYaxis() constTF1; GetYmax() constTF2inlinevirtual; GetYmin() constTF2inlinevirtual; GetZaxis() constTF1; GradientPar(Int_t ipar, const Double_t *x, Double_t eps=0.01)TF1virtual; GradientPar(Int_t ipar, const T *x, Double_t eps=0.01)TF1inline; GradientPar(const Double_t *x, Double_t *grad, Double_t eps=0.01)TF1virtual; GradientPar(const T *x, T *grad, Double_t eps=0.01)TF1inline; GradientParTempl(Int_t ipar, const T *x, Double_t eps=0.01)TF1inline; GradientParTempl(const T *x, T *grad, Double_t eps=0.01)TF1inline; HandleTimer(TTimer *timer)TObjectvirtual; Hash() const overrideTNamedinlinevirtual; HasInconsistentHash() constTObjectinline; HasSave() constTF1inline; Info(const char *method, const char *msgfmt,...) constTObjectvirtual; InheritsFrom(const char *classname) constTObjectvirtual; InheritsFrom(const TClass *cl) constTObjectvirtual; InitArgs(const Double_t *x, const Double_t *params)TF1virtual; InitStandardFunctions()TF1static; Inspect() constTObjectvirtual; Integral(Double_t ax, Double",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTF2-members.html:9161,log,logx,9161,doc/master/classTF2-members.html,https://root.cern,https://root.cern/doc/master/classTF2-members.html,1,['log'],['logx']
Testability,"omPointsvirtual void RandomPoints(const TGeoVolume *vol, Int_t npoints, Option_t *option="""")=0; TVirtualGeoPainter::CountVisibleNodesvirtual Int_t CountVisibleNodes()=0; TVirtualGeoPainter::DefaultAnglesvirtual void DefaultAngles()=0; TVirtualGeoPainter::SetNmeshPointsvirtual void SetNmeshPoints(Int_t npoints)=0; TVirtualGeoPainter::UnbombTranslationvirtual void UnbombTranslation(const Double_t *tr, Double_t *bombtr)=0; TVirtualGeoPainter::EditGeometryvirtual void EditGeometry(Option_t *option="""")=0; TVirtualGeoPainter::GetBombFactorsvirtual void GetBombFactors(Double_t &bombx, Double_t &bomby, Double_t &bombz, Double_t &bombr) const =0; TVirtualGeoPainter::CheckPointvirtual void CheckPoint(Double_t x=0, Double_t y=0, Double_t z=0, Option_t *option="""", Double_t safety=0.)=0; TVirtualGeoPainter::BombTranslationvirtual void BombTranslation(const Double_t *tr, Double_t *bombtr)=0; TVirtualGeoPainter::CheckShapevirtual void CheckShape(TGeoShape *shape, Int_t testNo, Int_t nsamples, Option_t *option)=0; TVirtualGeoPainter::ExecuteManagerEventvirtual void ExecuteManagerEvent(TGeoManager *geom, Int_t event, Int_t px, Int_t py)=0; TVirtualGeoPainter::SetBombFactorsvirtual void SetBombFactors(Double_t bombx=1.3, Double_t bomby=1.3, Double_t bombz=1.3, Double_t bombr=1.3)=0; TVirtualGeoPainter::CheckBoundaryErrorsvirtual void CheckBoundaryErrors(Int_t ntracks=1000000, Double_t radius=-1.)=0; TVirtualGeoTrackBase class for user-defined tracks attached to a geometry.Definition TVirtualGeoTrack.h:23; TVirtualGeoTrack::GetIdInt_t GetId() constDefinition TVirtualGeoTrack.h:43; TVirtualGeoTrack::GetMotherTVirtualGeoTrack * GetMother() constDefinition TVirtualGeoTrack.h:46; TVirtualGeoTrack::FindTrackWithIdvirtual TVirtualGeoTrack * FindTrackWithId(Int_t id) constRecursively search through this track for a daughter particle (at any depth) with the specified id.Definition TVirtualGeoTrack.cxx:83; bool; double; int; unsigned int; boxvoid box(Int_t pat, Double_t x1, Double_t y1, Double_",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGeoManager_8cxx_source.html:248159,test,testNo,248159,doc/master/TGeoManager_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGeoManager_8cxx_source.html,1,['test'],['testNo']
Testability,"om_t Atom_t Time_t UChar_t lenDefinition TGWin32VirtualXProxy.cxx:249; funcsOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void funcsDefinition TGWin32VirtualXProxy.cxx:142; fsOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize fsDefinition TGWin32VirtualXProxy.cxx:102; namechar name[80]Definition TGX11.cxx:110; TGeoBBox.h; TGeoBoolNode.h; TGeoCompositeShape.h; TGeoCone.h; TGeoEltu.h; TGeoHype.h; TGeoManager.h; gGeoManagerR__EXTERN TGeoManager * gGeoManagerDefinition TGeoManager.h:608; TGeoMaterial.h; TGeoMatrix.h; TGeoMedium.h; TGeoNode.h; TGeoParaboloid.h; TGeoPcon.h; TGeoPgon.h; TGeoScaledShape.h; TGeoSphere.h; TGeoTessellated.h; TGeoTorus.h; TGeoTube.h; TGeoVolume.h; TGeoXtru.h; TMath.h; TROOT.h; gROOT#define gROOTDefinition TROOT.h:406; TRegexp.h; ROOT::Experimental::RLogChannelA log configuration for a channel, e.g.Definition RLogger.hxx:101; ROOT::RBrowserReplyReply on browser request.Definition RBrowserReply.hxx:27; ROOT::RBrowserReply::pathstd::vector< std::string > pathreply pathDefinition RBrowserReply.hxx:29; ROOT::RBrowserReply::nodesstd::vector< const Browsable::RItem * > nodeslist of pointers, no ownership!Definition RBrowserReply.hxx:32; ROOT::RBrowserReply::firstint firstfirst node in returned listDefinition RBrowserReply.hxx:31; ROOT::RBrowserReply::nchildsint nchildstotal number of childs in the nodeDefinition RBrowserReply.hxx:30; ROOT::RGeomBrowserIterIterator of hierarchical geometry structures.Definition RGeomData.cxx:60; ROOT::RGeomBrowserIter::Enterbool Enter()Definition RGeomData.cxx:89; ROOT::RGeomBrowserIter::Leavebool Leave()Definition RGeomData.cxx:111; ROOT::RGeomBrowserIter::RGeomBrowserIterRGeomBrowserIter(RGeomDescription &desc)Definition RGeomData.cxx:71; ROOT::RGeomBrowserIter::fNodeIdint fNodeIdDefinition RGeomData.cxx:65; ROOT::",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RGeomData_8cxx_source.html:69366,log,log,69366,doc/master/RGeomData_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RGeomData_8cxx_source.html,2,['log'],['log']
Testability,"om_t Atom_t Time_t typeDefinition TGWin32VirtualXProxy.cxx:249; TObjString.h; TString.h; Timer.h; Tools.h; PatternDefinition Pattern.h:8; TFormulaThe Formula class.Definition TFormula.h:89; TIterDefinition TCollection.h:235; TMVA::Config::WriteOptionsReferenceBool_t WriteOptionsReference() constDefinition Config.h:65; TMVA::DNN::LayerLayer defines the layout of a layer.Definition NeuralNet.h:673; TMVA::DNN::Netneural netDefinition NeuralNet.h:1062; TMVA::DNN::SettingsSettings for the training of the neural net.Definition NeuralNet.h:730; TMVA::DNN::SteepestSteepest Gradient Descent algorithm (SGD)Definition NeuralNet.h:334; TMVA::DNN::TCpu::Copystatic void Copy(Matrix_t &B, const Matrix_t &A)Definition Arithmetic.hxx:269; TMVA::DNN::TCuda::Copystatic void Copy(Matrix_t &B, const Matrix_t &A); TMVA::DNN::TDataLoaderTDataLoader.Definition DataLoader.h:129; TMVA::DNN::TGradientDescentDefinition Minimizers.h:56; TMVA::DNN::TGradientDescent::HasConvergedbool HasConverged()Increases the minimization step counter by the test error evaluation period and uses the current inte...Definition Minimizers.h:667; TMVA::DNN::TGradientDescent::Stepvoid Step(Net_t &net, Matrix_t &input, const Matrix_t &output, const Matrix_t &weights)Perform a single optimization step on a given batch.Definition Minimizers.h:331; TMVA::DNN::TGradientDescent::GetTestIntervalsize_t GetTestInterval() constDefinition Minimizers.h:163; TMVA::DNN::TGradientDescent::StepMomentumvoid StepMomentum(Net_t &master, std::vector< Net_t > &nets, std::vector< TBatch< Architecture_t > > &batches, Scalar_t momentum)Same as the Step(...) method for multiple batches but uses momentum.Definition Minimizers.h:438; TMVA::DNN::TGradientDescent::GetConvergenceCountsize_t GetConvergenceCount() constDefinition Minimizers.h:159; TMVA::DNN::TGradientDescent::GetConvergenceStepssize_t GetConvergenceSteps() constDefinition Minimizers.h:160; TMVA::DNN::TNetGeneric neural network class.Definition Net.h:49; TMVA::EventDefinition Event",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/MethodDNN_8cxx_source.html:63660,test,test,63660,doc/master/MethodDNN_8cxx_source.html,https://root.cern,https://root.cern/doc/master/MethodDNN_8cxx_source.html,1,['test'],['test']
Testability,"ombi1);; 134 ; 135 //--- make letter 'T'; 136 TGeoVolume *T = geom->MakeBox(""T"", Vacuum, 25., 25., 5.);; 137 T->SetVisibility(kFALSE);; 138 TGeoVolume *bar5 = geom->MakeBox(""bar5"", Al, 5., 20., 5.);; 139 bar5->SetLineColor(kBlue);; 140 T->AddNode(bar5, 1, tr8);; 141 TGeoVolume *bar6 = geom->MakeBox(""bar6"", Al, 17.5, 5., 5.);; 142 ; 143 bar6->SetLineColor(kBlue);; 144 T->AddNode(bar6, 1, tr9);; 145 ; 146 rootbox->AddNode(R, 1, tr10);; 147 rootbox->AddNode(O, 1, tr11);; 148 rootbox->AddNode(O, 2, tr12);; 149 rootbox->AddNode(T, 1, tr13);; 150 ; 151 replica->AddNode(rootbox, 1, tr14);; 152 replica->AddNode(rootbox, 2, combi2);; 153 replica->AddNode(rootbox, 3, combi3);; 154 replica->AddNode(rootbox, 4, combi4);; 155 replica->AddNode(rootbox, 5, combi5);; 156 replica->AddNode(rootbox, 6, combi6);; 157 ; 158 top->AddNode(replica, 1, new TGeoTranslation(-150, -150, 0));; 159 top->AddNode(replica, 2, new TGeoTranslation(150, -150, 0));; 160 top->AddNode(replica, 3, new TGeoTranslation(150, 150, 0));; 161 top->AddNode(replica, 4, new TGeoTranslation(-150, 150, 0));; 162 ; 163 //--- close the geometry; 164 geom->CloseGeometry();; 165 return gGeoManager->GetTopNode();; 166}; 167 ; 168 ; 169void eveGeoBrowser(bool showDet = true); 170{; 171 auto eveMng = REX::REveManager::Create();; 172 // eveMng->AllowMultipleRemoteConnections(false, false);; 173 ; 174 TGeoNode *gn;; 175 int vislevel = 4;; 176 if (showDet) {; 177 gn = testCmsGeo();; 178 vislevel = 2;; 179 } else {; 180 gn = rootgeom();; 181 vislevel = 8;; 182 }; 183 ; 184 // initialize RGeomDesc from TGeoNode; 185 auto data = new REX::REveGeoTopNodeData();; 186 data->SetTNode(gn);; 187 data->RefDescription().SetVisLevel(vislevel);; 188 ; 189 // make geoTable; 190 auto scene = eveMng->SpawnNewScene(""GeoSceneTable"");; 191 auto view = eveMng->SpawnNewViewer(""GeoTable"");; 192 view->AddScene(scene);; 193 scene->AddElement(data);; 194 ; 195 // 3D representation; 196 auto geoViz = new REX::REveGeoTopNodeViz();; 197 geoViz->SetGeoData",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/eveGeoBrowser_8C_source.html:6957,test,testCmsGeo,6957,doc/master/eveGeoBrowser_8C_source.html,https://root.cern,https://root.cern/doc/master/eveGeoBrowser_8C_source.html,1,['test'],['testCmsGeo']
Testability,"ombinator and it has to be; 86constructed providing a string boolean expression between the components names.; 87 ; 88 ; 89## Example for building a simple geometry; 90 ; 91Begin_Macro(source); 92../../../tutorials/geom/rootgeom.C; 93End_Macro; 94 ; 95## TGeoManager - the manager class for the geometry package.; 96 ; 97 TGeoManager class is embedding all the API needed for building and tracking; 98a geometry. It defines a global pointer (gGeoManager) in order to be fully; 99accessible from external code. The mechanism of handling multiple geometries; 100at the same time will be soon implemented.; 101 ; 102 TGeoManager is the owner of all geometry objects defined in a session,; 103therefore users must not try to control their deletion. It contains lists of; 104media, materials, transformations, shapes and volumes. Logical nodes (positioned; 105volumes) are created and destroyed by the TGeoVolume class. Physical; 106nodes and their global transformations are subjected to a caching mechanism; 107due to the sometimes very large memory requirements of logical graph expansion.; 108The caching mechanism is triggered by the total number of physical instances; 109of volumes and the cache manager is a client of TGeoManager. The manager class; 110also controls the painter client. This is linked with ROOT graphical libraries; 111loaded on demand in order to control visualization actions.; 112 ; 113## Rules for building a valid geometry; 114 ; 115 A given geometry can be built in various ways, but there are mandatory steps; 116that have to be followed in order to be validated by the modeler. There are; 117general rules : volumes needs media and shapes in order to be created,; 118both container and containee volumes must be created before linking them together,; 119and the relative transformation matrix must be provided. All branches must; 120have an upper link point otherwise they will not be considered as part of the; 121geometry. Visibility or tracking properties of volumes can",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGeoManager_8cxx_source.html:6387,log,logical,6387,doc/master/TGeoManager_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGeoManager_8cxx_source.html,1,['log'],['logical']
Testability,"ome OpenGL state variables. void SetNormals(); One normal per vertex;; this normal is average of; neighbouring triangles normals. void SetSurfaceColor() const; Set color for surface. void DrawPlot() const; Draw surf/surf1/surf2/surf4. Bool_t InitGeometryCartesian(); Find bin ranges for X and Y axes,; axes ranges for X, Y and Z.; Function returns false, if logarithmic scale for; some axis was requested, but we cannot; find correct range. Bool_t InitGeometryPolar(); Find bin ranges for X and Y axes,; axes ranges for X, Y and Z.; Function returns false, if logarithmic scale for; some axis was requested, but we cannot; find correct range. Bool_t InitGeometryCylindrical(); Find bin ranges for X and Y axes,; axes ranges for X, Y and Z.; Function returns false, if logarithmic scale for; some axis was requested, but we cannot; find correct range. Bool_t InitGeometrySpherical(); Find bin ranges for X and Y axes,; axes ranges for X, Y and Z.; Function returns false, if logarithmic scale for; some axis was requested, but we cannot; find correct range. void DrawProjections() const; Draw projections. void DrawSectionXOZ() const; Draw section X. void DrawSectionYOZ() const; Draw section Y. void DrawSectionXOY() const; Draw section Z. void ClampZ(Double_t& zVal) const; Clamp z value. char * WindowPointTo3DPoint(Int_t px, Int_t py) const; Find 3d coords using mouse cursor coords.; if (!MakeGLContextCurrent()) {; static char err[] = { ""Apocalipshit!"" };; return err;; }. Bool_t PreparePalette() const; Generate palette. void GenTexMap() const; Find texture coordinates. void DrawContoursProjection() const; Draw flat textured surface. Bool_t Textured() const; Checks, if surf requires texture. Bool_t HasSections() const; Any section exists. Bool_t HasProjections() const; Any projection exists. void DrawPalette() const; Draw. Palette.; Originally, fCamera was never null.; It can be a null now because of gl-viewer. void DrawPaletteAxis() const; Draw. Palette. Axis. TGLSurfacePainter(TH1* hi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGLSurfacePainter.html:6779,log,logarithmic,6779,root/html602/TGLSurfacePainter.html,https://root.cern,https://root.cern/root/html602/TGLSurfacePainter.html,2,['log'],['logarithmic']
Testability,"ome OpenGL state variables. void SetNormals(); One normal per vertex;; this normal is average of; neighbouring triangles normals. void SetSurfaceColor() const; Set color for surface. void DrawPlot() const; Draw surf/surf1/surf2/surf4. Bool_t InitGeometryCartesian(); Find bin ranges for X and Y axes,; axes ranges for X, Y and Z.; Function returns false, if logarithmic scale for; some axis was requested, but we cannot; find correct range. Bool_t InitGeometryPolar(); Find bin ranges for X and Y axes,; axes ranges for X, Y and Z.; Function returns false, if logarithmic scale for; some axis was requested, but we cannot; find correct range. Bool_t InitGeometryCylindrical(); Find bin ranges for X and Y axes,; axes ranges for X, Y and Z.; Function returns false, if logarithmic scale for; some axis was requested, but we cannot; find correct range. Bool_t InitGeometrySpherical(); Find bin ranges for X and Y axes,; axes ranges for X, Y and Z.; Function returns false, if logarithmic scale for; some axis was requested, but we cannot; find correct range. void DrawProjections() const; Draw projections. void DrawSectionXOZ() const; Draw section X. void DrawSectionYOZ() const; Draw section Y. void DrawSectionXOY() const; Draw section Z. void ClampZ(Double_t& zVal) const; Clamp z value. char * WindowPointTo3DPoint(Int_t px, Int_t py) const; Find 3d coords using mouse cursor coords.; if (!MakeGLContextCurrent()) {; static char err[] = { ""Apocalipshit!"" };; return err;; }. Bool_t PreparePalette() const; Generate palette. void GenTexMap() const; Find texture coordinates. void DrawContoursProjection() const; Draw flat textured surface. Bool_t Textured() const; Checks, if surf requires texture. Bool_t HasSections() const; Any section exists. Bool_t HasProjections() const; Any projection exists. void DrawPalette() const; Draw. Palette.; Originally, fCamera was never null.; It can be a null now because of gl-viewer. void DrawPaletteAxis() const; Draw. Palette. Axis.  Author: Timur Pocheptso",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGLSurfacePainter.html:5908,log,logarithmic,5908,root/html528/TGLSurfacePainter.html,https://root.cern,https://root.cern/root/html528/TGLSurfacePainter.html,4,['log'],['logarithmic']
Testability,"ome basic graphics primitives such as line, arrow and text ; palettes.C This macro draws all the high definition palettes available in ROOT ; pavetext.C Draw a pave text ; piechart.C Pie chart example ; polytest1.C This macro is testing the ""compacting"" algorithm in TPadPainter ; polytest2.C This macro is testing the ""compacting"" algorithm in TPadPainter ; pstable.C Display all possible types of ROOT/Postscript characters ; psview.C An example how to display PS, EPS, PDF files in canvas ; quarks.C Example illustrating divided pads and Latex ; tmathtext.CThis macro draws various formula in a canvas ; tmathtext2.C This macro draw all possible symbols provided by TMathtext ; tornado.C Show 3-d polymarker ; transparency.C This macro demonstrates the use of color transparency ; triangles.C Generate small triangles randomly in the canvas ; graphs; annotation3d.C This example show how to put some annotation on a 3D plot using 3D polylines ; approx.C Macro to test interpolation function Approx ; bent.C Bent error bars ; bent.py Bent error bars ; exclusiongraph.C Draw three graphs with an exclusion zone ; exclusiongraph2.C Draw several graphs with an exclusion zones ; gerrors.C Draw a graph with error bars ; gerrors2.C Draw two graphs with error bars ; graph.C Draw a simple graph ; graph2derrorsfit.C Draw and fit a TGraph2DErrors ; graphApply.C A macro to demonstrate the functionality of TGraph::Apply() method ; graphpalettecolor.C Palette coloring for graphs is activated thanks to the options PFC (Palette Fill Color), PLC (Palette Line Color) and AMC (Palette Marker Color) ; graphpolar.C Create and draw a polar graph ; graphpolar2.C Create and draw a polar graph with PI axis ; graphpolar3.C Create and draw a polar graph with PI axis using a TF1 ; graphShade.C Show how to shade an area between two graphs ; graphstruct.C Draw a simple graph structure ; graphtext.C Draw a graph with text attached to each point ; gtime.C Example of TGraphTime ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v612/files.html:114252,test,test,114252,doc/v612/files.html,https://root.cern,https://root.cern/doc/v612/files.html,3,['test'],['test']
Testability,"ome basic graphics primitives such as line, arrow and text ; palettes.C This macro draws all the high definition palettes available in ROOT ; pavetext.C Draw a pave text ; piechart.C Pie chart example ; polytest1.C This macro is testing the ""compacting"" algorithm in TPadPainter ; polytest2.C This macro is testing the ""compacting"" algorithm in TPadPainter ; pstable.C Display all possible types of ROOT/Postscript characters ; psview.C An example how to display PS, EPS, PDF files in canvas ; quarks.C Example illustrating divided pads and Latex ; tmathtext.CThis macro draws various formula in a canvas ; tmathtext2.C This macro draw all possible symbols provided by TMathtext ; tornado.C Show 3-d polymarker ; transparency.C This macro demonstrates the use of color transparency ; triangles.C Generate small triangles randomly in the canvas ; graphs; annotation3d.C This example show how to put some annotation on a 3D plot using 3D polylines ; approx.C Macro to test interpolation function Approx ; bent.C Bent error bars ; exclusiongraph.C Draw three graphs with an exclusion zone ; exclusiongraph2.C Draw several graphs with an exclusion zones ; gerrors.C Draw a graph with error bars ; gerrors2.C Draw two graphs with error bars ; graph.C Draw a simple graph ; graph2derrorsfit.C Draw and fit a TGraph2DErrors ; graphApply.C A macro to demonstrate the functionality of TGraph::Apply() method ; graphpalettecolor.C Palette coloring for graphs is activated thanks to the options PFC (Palette Fill Color), PLC (Palette Line Color) and AMC (Palette Marker Color) ; graphpolar.C Create and draw a polar graph ; graphpolar2.C Create and draw a polar graph with PI axis ; graphpolar3.C Create and draw a polar graph with PI axis using a TF1 ; graphShade.C Show how to shade an area between two graphs ; graphstruct.C Draw a simple graph structure ; graphtext.C Draw a graph with text attached to each point ; gtime.C Example of TGraphTime ; gtime2.C Example of TGra",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v610/files.html:115999,test,test,115999,doc/v610/files.html,https://root.cern,https://root.cern/doc/v610/files.html,1,['test'],['test']
Testability,"oment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tRooAbsPdf::mustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; const char*RooAbsPdf::normRange() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooCFunction3PdfBinding<double,double,double,bool>&operator=(const RooCFunction3PdfBinding<double,double,double,bool>&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsPdf::paramOn(RooPlot* frame, const RooAbsData* data, const char* label = """", Int_t sigDigits = 2, Option_t* options = ""NELU"", Double_t xmin = 0.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooCFunction3PdfBinding_double_double_double_bool_.html:23788,test,testArg,23788,root/html602/RooCFunction3PdfBinding_double_double_double_bool_.html,https://root.cern,https://root.cern/root/html602/RooCFunction3PdfBinding_double_double_double_bool_.html,2,['test'],['testArg']
Testability,"omp), _normRange(other._normRange); 263{; 264 resetErrorCounters() ;; 265 setTraceCounter(other._traceCount) ;; 266 ; 267 if (other._specGeneratorConfig) {; 268 _specGeneratorConfig = std::make_unique<RooNumGenConfig>(*other._specGeneratorConfig);; 269 }; 270}; 271 ; 272 ; 273 ; 274////////////////////////////////////////////////////////////////////////////////; 275/// Destructor; 276 ; 277RooAbsPdf::~RooAbsPdf(); 278{; 279}; 280 ; 281 ; 282double RooAbsPdf::normalizeWithNaNPacking(double rawVal, double normVal) const {; 283 ; 284 if (normVal < 0. || (normVal == 0. && rawVal != 0)) {; 285 //Unreasonable normalisations. A zero integral can be tolerated if the function vanishes, though.; 286 const std::string msg = ""p.d.f normalization integral is zero or negative: "" + std::to_string(normVal);; 287 logEvalError(msg.c_str());; 288 clearValueAndShapeDirty();; 289 return RooNaNPacker::packFloatIntoNaN(-normVal + (rawVal < 0. ? -rawVal : 0.));; 290 }; 291 ; 292 if (rawVal < 0.) {; 293 logEvalError(Form(""p.d.f value is less than zero (%f), trying to recover"", rawVal));; 294 clearValueAndShapeDirty();; 295 return RooNaNPacker::packFloatIntoNaN(-rawVal);; 296 }; 297 ; 298 if (TMath::IsNaN(rawVal)) {; 299 logEvalError(""p.d.f value is Not-a-Number"");; 300 clearValueAndShapeDirty();; 301 return rawVal;; 302 }; 303 ; 304 return (rawVal == 0. && normVal == 0.) ? 0. : rawVal / normVal;; 305}; 306 ; 307 ; 308////////////////////////////////////////////////////////////////////////////////; 309/// Return current value, normalized by integrating over; 310/// the observables in `nset`. If `nset` is 0, the unnormalized value; 311/// is returned. All elements of `nset` must be lvalues.; 312///; 313/// Unnormalized values are not cached.; 314/// Doing so would be complicated as `_norm->getVal()` could; 315/// spoil the cache and interfere with returning the cached; 316/// return value. Since unnormalized calls are typically; 317/// done in integration calls, there is no performance hit.; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RooAbsPdf_8cxx_source.html:11106,log,logEvalError,11106,doc/master/RooAbsPdf_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RooAbsPdf_8cxx_source.html,1,['log'],['logEvalError']
Testability,"omparison of weighted and unweighted histograms. Statistical Problems in Particle Physics, Astrophysics and Cosmology, Proceedings of PHYSTAT05, Oxford, UK, 12-15 September 2005, Imperial College Press, London, 43-44. Gagunashvili,N., Comparison of weighted and unweighted histograms, arXiv:physics/0605123, 2006.; [3] Cramer, H., 1946. Mathematical methods of statistics. Princeton University Press, Princeton.; [4] Haberman, S.J., 1973. The analysis of residuals in cross-classified tables. Biometrics 29, 205-220.; [5] Lewontin, R.C. and Felsenstein, J., 1965. The robustness of homogeneity test in 2xN tables. Biometrics 21, 19-33.; [6] Seber, G.A.F., Lee, A.J., 2003, Linear Regression Analysis. John Wiley & Sons Inc., New York. . Definition at line 2008 of file TH1.cxx. Chi2TestX(). Double_t TH1::Chi2TestX ; (; const TH1 *; h2, . Double_t &; chi2, . Int_t &; ndf, . Int_t &; igood, . Option_t *; option = ""UU"", . Double_t *; res = nullptr. ); const. virtual . The computation routine of the Chisquare test. ; For the method description, see Chi2Test() function.; Returnsp-value ; Parameters. [in]h2the second histogram ; [in]option; ""UU"" = experiment experiment comparison (unweighted-unweighted); ""UW"" = experiment MC comparison (unweighted-weighted). Note that the first histogram should be unweighted; ""WW"" = MC MC comparison (weighted-weighted); ""NORM"" = if one or both histograms is scaled; ""OF"" = overflows included; ""UF"" = underflows included by default underflows and overflows are not included . [out]igoodtest output; igood=0 - no problems; For unweighted unweighted comparison; igood=1'There is a bin in the 1st histogram with less than 1 event'; igood=2'There is a bin in the 2nd histogram with less than 1 event'; igood=3'when the conditions for igood=1 and igood=2 are satisfied'. For unweighted weighted comparison; igood=1'There is a bin in the 1st histogram with less then 1 event'; igood=2'There is a bin in the 2nd histogram with less then 10 effective number of e",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTH1.html:99203,test,test,99203,doc/master/classTH1.html,https://root.cern,https://root.cern/doc/master/classTH1.html,1,['test'],['test']
Testability,"ompatability reasons. ; Definition at line 878 of file TAuthenticate.cxx. CheckNetrc() [2/2]. Bool_t TAuthenticate::CheckNetrc ; (; TString &; user, . TString &; passwd, . Bool_t &; pwhash, . Bool_t; srppwd. ). Try to get user name and passwd from the ~/.rootnetrc or ~/.netrc files. ; First ~/.rootnetrc is tried, after that ~/.netrc. These files will only be used when their access masks are 0600. Returns kTRUE if user and passwd were found for the machine specified in the URL. If kFALSE, user and passwd are """". The boolean pwhash is set to kTRUE if the returned passwd is to be understood as password hash, i.e. if the 'password-hash' keyword is found in the 'machine' lines; not implemented for 'secure' and the .netrc file. The format of these files are:. this is a comment line; machine <machine fqdn> login <user> password <passwd> machine <machine fqdn> login <user> password-hash <passwd>; and in addition ~/.rootnetrc also supports:; secure <machine fqdn> login <user> password <passwd>; <machine fqdn> may be a domain name or contain the wild card '*'.; for the secure protocols. All lines must start in the first column. ; Definition at line 908 of file TAuthenticate.cxx. CheckProofAuth(). Bool_t TAuthenticate::CheckProofAuth ; (; Int_t; cSec, . TString &; det. ). static . Check if the authentication method can be attempted for the client. ; Definition at line 3541 of file TAuthenticate.cxx. Class(). static TClass * TAuthenticate::Class ; (; ). static . ReturnsTClass describing this class . Class_Name(). static const char * TAuthenticate::Class_Name ; (; ). static . ReturnsName of this class . Class_Version(). static constexpr Version_t TAuthenticate::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 207 of file TAuthenticate.h. ClearAuth(). Int_t TAuthenticate::ClearAuth ; (; TString &; user, . TString &; passwd, . Bool_t &; pwdhash. ). private . UsrPwd client authentication code. ; Returns 0 in case",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTAuthenticate.html:23945,log,login,23945,doc/master/classTAuthenticate.html,https://root.cern,https://root.cern/doc/master/classTAuthenticate.html,1,['log'],['login']
Testability,"ompiled->Add(k);; 3820 ; 3821 if (needLoadMap) {; 3822 gInterpreter->LoadLibraryMap(libmapfilename);; 3823 }; 3824 if (verboseLevel>3 && withInfo) ::Info(""ACLiC"",""loading the shared library"");; 3825 if (loadLib); 3826 result = LoadLibrary(library);; 3827 else; 3828 result = kTRUE;; 3829 ; 3830 if ( !result ) {; 3831 if (verboseLevel>3 && withInfo) {; 3832 ::Info(""ACLiC"",""testing for missing symbols:"");; 3833 if (verboseLevel>4) ::Info(""ACLiC"", ""%s"", testcmd.Data());; 3834 }; 3835 gSystem->Exec(testcmd);; 3836 gSystem->Unlink( exec );; 3837 }; 3838 ; 3839 };; 3840 ; 3841 if (verboseLevel<=5 && !internalDebug) {; 3842 gSystem->Unlink( dict );; 3843 gSystem->Unlink( dicth );; 3844 gSystem->Unlink( dictObj );; 3845 gSystem->Unlink( linkdef );; 3846 gSystem->Unlink( mapfilein );; 3847 gSystem->Unlink( mapfileout );; 3848 gSystem->Unlink( fakeMain );; 3849 gSystem->Unlink( exec );; 3850 }; 3851 if (verboseLevel>6) {; 3852 rcling.Prepend(""echo "");; 3853 cmd.Prepend(""echo \"" "").Append("" \"" "");; 3854 testcmd.Prepend(""echo \"" "").Append("" \"" "");; 3855 gSystem->Exec(rcling);; 3856 gSystem->Exec( cmd );; 3857 gSystem->Exec(testcmd);; 3858 }; 3859 ; 3860 return result;; 3861}; 3862 ; 3863////////////////////////////////////////////////////////////////////////////////; 3864/// Return the ACLiC properties field. See EAclicProperties for details; 3865/// on the semantic of each bit.; 3866 ; 3867Int_t TSystem::GetAclicProperties() const; 3868{; 3869 return fAclicProperties;; 3870}; 3871 ; 3872////////////////////////////////////////////////////////////////////////////////; 3873/// Return the build architecture.; 3874 ; 3875const char *TSystem::GetBuildArch() const; 3876{; 3877 return fBuildArch;; 3878}; 3879 ; 3880////////////////////////////////////////////////////////////////////////////////; 3881/// Return the build compiler; 3882 ; 3883const char *TSystem::GetBuildCompiler() const; 3884{; 3885 return fBuildCompiler;; 3886}; 3887 ; 3888/////////////////////////////////////////////",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TSystem_8cxx_source.html:130904,test,testcmd,130904,doc/master/TSystem_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html,1,['test'],['testcmd']
Testability,"ompute distance from point px,py to a function. ; ; voidDraw (Option_t *option="""") override; Draw this function with its current attributes. ; ; TF1 *DrawCopy (Option_t *option="""") const override; Draw a copy of this function with its current attributes-*. ; ; TObject *DrawDerivative (Option_t *=""al"") override; Draw derivative of this function. ; ; TObject *DrawIntegral (Option_t *=""al"") override; Draw integral of this function. ; ; voidExecuteEvent (Int_t event, Int_t px, Int_t py) override; Execute action corresponding to one event. ; ; virtual Int_tGetContour (Double_t *levels=nullptr); Return contour values into array levels. ; ; virtual Double_tGetContourLevel (Int_t level) const; Return the number of contour levels. ; ; virtual Double_tGetMaximum (Double_t *x) const; Return maximum value of the function See TF2::GetMinimum. ; ; virtual Double_tGetMaximum (Double_t xmin=0, Double_t xmax=0, Double_t epsilon=1.E-10, Int_t maxiter=100, Bool_t logx=false) const; Returns the maximum value of the function. ; ; virtual Double_tGetMaximumXY (Double_t &x, Double_t &y) const; Compute the X and Y values corresponding to the maximum value of the function. ; ; virtual Double_tGetMinimum (Double_t *x) const; Return minimum/maximum value of the function. ; ; virtual Double_tGetMinimum (Double_t xmin=0, Double_t xmax=0, Double_t epsilon=1.E-10, Int_t maxiter=100, Bool_t logx=false) const; Returns the minimum value of the function on the (xmin, xmax) interval. ; ; virtual Double_tGetMinimumXY (Double_t &x, Double_t &y) const; Compute the X and Y values corresponding to the minimum value of the function. ; ; Int_tGetNpy () const; ; char *GetObjectInfo (Int_t px, Int_t py) const override; Redefines TObject::GetObjectInfo. ; ; Double_tGetRandom (Double_t xmin, Double_t xmax, TRandom *rng=nullptr, Option_t *opt=nullptr) override; Return a random number following this function shape. ; ; Double_tGetRandom (TRandom *rng=nullptr, Option",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTF2.html:5207,log,logx,5207,doc/master/classTF2.html,https://root.cern,https://root.cern/doc/master/classTF2.html,1,['log'],['logx']
Testability,"ompute significance)Definition DataLoader.cxx:371; TMVA::DataLoader::AddDataSetDataSetInfo & AddDataSet(DataSetInfo &)Definition DataLoader.cxx:119; TMVA::DataLoader::AddSpectatorvoid AddSpectator(const TString &expression, const TString &title="""", const TString &unit="""", Double_t min=0, Double_t max=0)user inserts target in data set infoDefinition DataLoader.cxx:524; TMVA::DataLoader::SetInputTreesFromEventAssignTreesvoid SetInputTreesFromEventAssignTrees()assign event-wise local trees to data setDefinition DataLoader.cxx:319; TMVA::DataLoader::AddTrainingEventvoid AddTrainingEvent(const TString &className, const std::vector< Double_t > &event, Double_t weight)add signal training eventDefinition DataLoader.cxx:260; TMVA::DataLoader::SetTreevoid SetTree(TTree *tree, const TString &className, Double_t weight)deprecatedDefinition DataLoader.cxx:447; TMVA::DataLoader::AddSignalTestEventvoid AddSignalTestEvent(const std::vector< Double_t > &event, Double_t weight=1.0)add signal testing eventDefinition DataLoader.cxx:236; TMVA::DataLoader::DefaultDataSetInfoDataSetInfo & DefaultDataSetInfo()default creationDefinition DataLoader.cxx:533; TMVA::DataLoader::AddBackgroundTestEventvoid AddBackgroundTestEvent(const std::vector< Double_t > &event, Double_t weight=1.0)add signal training eventDefinition DataLoader.cxx:252; TMVA::DataLoader::fDataSetManagerDataSetManager * fDataSetManagerDefinition DataLoader.h:186; TMVA::DataLoader::MakeCopyDataLoader * MakeCopy(TString name)Copy method use in VI and CV.Definition DataLoader.cxx:691; TMVA::DataLoader::SetSignalWeightExpressionvoid SetSignalWeightExpression(const TString &variable)Definition DataLoader.cxx:549; TMVA::DataLoader::MakeKFoldDataSetvoid MakeKFoldDataSet(CvSplit &s)Function required to split the training and testing datasets into a number of folds.Definition DataLoader.cxx:662; TMVA::DataLoader::SetWeightExpressionvoid SetWeightExpression(const TString &variable, const TString &className="""")Definition DataLoader.cxx:5",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/DataLoader_8cxx_source.html:33321,test,testing,33321,doc/master/DataLoader_8cxx_source.html,https://root.cern,https://root.cern/doc/master/DataLoader_8cxx_source.html,1,['test'],['testing']
Testability,"on (); ; static const char *DeclFileName (); ; static RooMsgService &instance (); Return reference to singleton instance. ; ; Static Public Member Functions inherited from TObject; static TClass *Class (); ; static const char *Class_Name (); ; static constexpr Version_tClass_Version (); ; static const char *DeclFileName (); ; static Longptr_tGetDtorOnly (); Return destructor only flag. ; ; static Bool_tGetObjectStat (); Get status of object stat flag. ; ; static voidSetDtorOnly (void *obj); Set destructor only flag. ; ; static voidSetObjectStat (Bool_t stat); Turn on/off tracking of objects in the TObjectTable. ; . Public Attributes; std::map< int, std::string >_levelNames; ; std::map< int, std::string >_topicNames; . Static Public Attributes; static Int_t_debugCount = 0; . Protected Member Functions; RooMsgService (); Constructor. ; ; RooMsgService (const RooMsgService &); ; template<class T > ; Int_tactiveStream (T self, RooFit::MsgTopic topic, RooFit::MsgLevel level); Find appropriate logging stream for message from given object with given topic and message level. ; ; Protected Member Functions inherited from TObject; virtual voidDoError (int level, const char *location, const char *fmt, va_list va) const; Interface to ErrorHandler (protected). ; ; voidMakeZombie (); . Protected Attributes; Int_t_debugCode; ; std::unique_ptr< RooWorkspace >_debugWorkspace; ; std::unique_ptr< std::ofstream >_devnull; ; Int_t_errorCount; ; std::map< std::string, std::unique_ptr< std::ostream > >_files; ; RooFit::MsgLevel_globMinLevel; ; RooFit::MsgLevel_lastMsgLevel; ; bool_showPid; ; bool_silentMode; ; std::vector< StreamConfig >_streams; ; std::stack< std::vector< StreamConfig > >_streamsSaved; . Additional Inherited Members; Public Types inherited from TObject; enum { ; kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ; kBitMask = 0x00ffffff. }; ;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooMsgService.html:13362,log,logging,13362,doc/master/classRooMsgService.html,https://root.cern,https://root.cern/doc/master/classRooMsgService.html,1,['log'],['logging']
Testability,"on DataSet.cxx:427; TMVA::DataSet::GetTreeTTree * GetTree(Types::ETreeType type)create the test/trainings tree with all the variables, the weights, the classes, the targets,...Definition DataSet.cxx:609; TMVA::DataSet::GetEventconst Event * GetEvent() constreturns event without transformationsDefinition DataSet.cxx:202; TMVA::DataSet::GetNEventsLong64_t GetNEvents(Types::ETreeType type=Types::kMaxTreeType) constDefinition DataSet.h:206; TMVA::DataSet::GetResultsResults * GetResults(const TString &, Types::ETreeType type, Types::EAnalysisType analysistype)Definition DataSet.cxx:265; TMVA::DataSet::GetNTrainingEventsLong64_t GetNTrainingEvents() constDefinition DataSet.h:68; TMVA::DataSet::SetCurrentTypevoid SetCurrentType(Types::ETreeType type) constDefinition DataSet.h:89; TMVA::DataSet::GetEventCollectionconst std::vector< Event * > & GetEventCollection(Types::ETreeType type=Types::kMaxTreeType) constDefinition DataSet.h:216; TMVA::DataSet::GetNEvtBkgdTestLong64_t GetNEvtBkgdTest()return number of background test events in datasetDefinition DataSet.cxx:435; TMVA::EventDefinition Event.h:51; TMVA::Event::GetValueFloat_t GetValue(UInt_t ivar) constreturn value of i'th variableDefinition Event.cxx:236; TMVA::Event::SetIsTrainingstatic void SetIsTraining(Bool_t)when this static function is called, it sets the flag whether events with negative event weight shoul...Definition Event.cxx:399; TMVA::FactoryThis is the main MVA steering class.Definition Factory.h:80; TMVA::Factory::PrintHelpMessagevoid PrintHelpMessage(const TString &datasetname, const TString &methodTitle="""") constPrint predefined help message of classifier.Definition Factory.cxx:1333; TMVA::Factory::fCorrelationsBool_t fCorrelations! enable to calculate correlationsDefinition Factory.h:215; TMVA::Factory::MVectorstd::vector< IMethod * > MVectorDefinition Factory.h:84; TMVA::Factory::TrainAllMethodsvoid TrainAllMethods()Iterates through all booked methods and calls training.Definition Factory.cxx:1114; TMVA",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/tmva_2tmva_2src_2Factory_8cxx_source.html:119586,test,test,119586,doc/master/tmva_2tmva_2src_2Factory_8cxx_source.html,https://root.cern,https://root.cern/doc/master/tmva_2tmva_2src_2Factory_8cxx_source.html,1,['test'],['test']
Testability,"on Factory.cxx:586; TMVA::Factory::GetROCCurveTGraph * GetROCCurve(DataLoader *loader, TString theMethodName, Bool_t setTitles=kTRUE, UInt_t iClass=0, Types::ETreeType type=Types::kTesting)Argument iClass specifies the class to generate the ROC curve in a multiclass setting.Definition Factory.cxx:912; TMVA::Factory::EvaluateImportanceAllTH1F * EvaluateImportanceAll(DataLoader *loader, Types::EMVA theMethod, TString methodTitle, const char *theOption="""")Definition Factory.cxx:2246; TMVA::Factory::SetVerbosevoid SetVerbose(Bool_t v=kTRUE)Definition Factory.cxx:343; TMVA::Factory::fgTargetFileTFile * fgTargetFile! ROOT output fileDefinition Factory.h:205; TMVA::Factory::GetMethodIMethod * GetMethod(const TString &datasetname, const TString &title) constReturns pointer to MVA that corresponds to given method title.Definition Factory.cxx:566; TMVA::Factory::DeleteAllMethodsvoid DeleteAllMethods(void)Delete methods.Definition Factory.cxx:324; TMVA::Factory::fTransformationsTString fTransformations! list of transformations to testDefinition Factory.h:212; TMVA::Factory::Greetingsvoid Greetings()Print welcome message.Definition Factory.cxx:295; TMVA::IMethodInterface for all concrete MVA method implementations.Definition IMethod.h:53; TMVA::IMethod::PrintHelpMessagevirtual void PrintHelpMessage() const =0; TMVA::IMethod::HasAnalysisTypevirtual Bool_t HasAnalysisType(Types::EAnalysisType type, UInt_t numberClasses, UInt_t numberTargets)=0; TMVA::IMethod::MakeClassvirtual void MakeClass(const TString &classFileName=TString("""")) const =0; TMVA::MethodBaseVirtual base Class for all MVA method.Definition MethodBase.h:111; TMVA::MethodBase::GetSeparationvirtual Double_t GetSeparation(TH1 *, TH1 *) constcompute ""separation"" defined asDefinition MethodBase.cxx:2789; TMVA::MethodBase::SetSilentFilevoid SetSilentFile(Bool_t status)Definition MethodBase.h:378; TMVA::MethodBase::SetWeightFileDirvoid SetWeightFileDir(TString fileDir)set directory of weight fileDefinition MethodBase.cxx:",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/tmva_2tmva_2src_2Factory_8cxx_source.html:125628,test,testDefinition,125628,doc/master/tmva_2tmva_2src_2Factory_8cxx_source.html,https://root.cern,https://root.cern/doc/master/tmva_2tmva_2src_2Factory_8cxx_source.html,1,['test'],['testDefinition']
Testability,"on Members (Methods); public:. virtual~BrentMinimizer1D(); ROOT::Math::BrentMinimizer1DBrentMinimizer1D(); ROOT::Math::BrentMinimizer1DBrentMinimizer1D(const ROOT::Math::BrentMinimizer1D&); virtual doubleFValLower() const; virtual doubleFValMinimum() const; virtual doubleFValUpper() const; virtual intIterations() const; virtual boolMinimize(int maxIter, double absTol = 1.E-8, double relTol = 1.E-10); virtual const char*Name() const; static voidSetDefaultNpx(int npx); static voidSetDefaultNSearch(int n); voidSetFunction(const ROOT::Math::IGenFunction& f, double xlow, double xup); voidSetLogScan(bool on); voidSetNpx(int npx); virtual intStatus() const; virtual doubleXLower() const; virtual doubleXMinimum() const; virtual doubleXUpper() const. private:. ROOT::Math::IMinimizer1D&ROOT::Math::IMinimizer1D::operator=(const ROOT::Math::IMinimizer1D&). Data Members; private:. const ROOT::Math::IGenFunction*fFunctionPointer to the function.; boolfLogScanflag to control usage of a log scan; intfNIterNumber of iterations needed for the last estimation.; intfNpxNumber of points to bracket minimum with grid (def is 100); intfStatusStatus of code of the last estimate; doublefXMaxUpper bound of the search interval; doublefXMinLower bound of the search interval.; doublefXMinimumPosition of the stimated minimum. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; BrentMinimizer1D(); Default Constructor. . virtual ~BrentMinimizer1D(); Default Destructor. . {}. double XMinimum() const; Return current estimate of the position of the minimum. . { return fXMinimum; }. double XLower() const; Return current lower bound of the minimization interval. . { return fXMin; }. double XUpper() const; Return current upper bound of the minimization interval. . { return fXMax; }. double FValMinimum() const; Return function value at current estimate of the minimum. . double FValLower() const; Return function value at current lower bound of the minimization interval",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/ROOT__Math__BrentMinimizer1D.html:2503,log,log,2503,root/html528/ROOT__Math__BrentMinimizer1D.html,https://root.cern,https://root.cern/root/html528/ROOT__Math__BrentMinimizer1D.html,4,['log'],['log']
Testability,"on TGWin32VirtualXProxy.cxx:245; namechar name[80]Definition TGX11.cxx:110; ROOT::Experimental::Detail::RLogBuilderBuilds a diagnostic entry, emitted by the static RLogManager upon destruction of this builder,...Definition RLogger.hxx:213; ROOT::Experimental::Detail::RLogBuilder::RLogBuilderRLogBuilder(ELogLevel level, RLogChannel &channel)Definition RLogger.hxx:218; ROOT::Experimental::Detail::RLogBuilder::RLogBuilderRLogBuilder(ELogLevel level, RLogChannel &channel, const std::string &filename, int line, const std::string &funcname)Definition RLogger.hxx:219; ROOT::Experimental::Detail::RLogBuilder::fEntryRLogEntry fEntryThe log entry to be built.Definition RLogger.hxx:215; ROOT::Experimental::Detail::RLogBuilder::~RLogBuilder~RLogBuilder()Emit the log entry through the static log manager.Definition RLogger.hxx:226; ROOT::Experimental::RLogChannelA log configuration for a channel, e.g.Definition RLogger.hxx:101; ROOT::Experimental::RLogChannel::RLogChannelRLogChannel(const std::string &name)Construct a log channel given its name, which is part of the diagnostics.Definition RLogger.hxx:116; ROOT::Experimental::RLogChannel::fVerbosityELogLevel fVerbosityVerbosity of this channel. By default, use the global verbosity.Definition RLogger.hxx:106; ROOT::Experimental::RLogChannel::RLogChannelRLogChannel()=defaultConstruct an anonymous channel.; ROOT::Experimental::RLogChannel::GetEffectiveVerbosityELogLevel GetEffectiveVerbosity(const RLogManager &mgr) constDefinition RLogger.hxx:313; ROOT::Experimental::RLogChannel::fNamestd::string fNameName as shown in diagnostics.Definition RLogger.hxx:103; ROOT::Experimental::RLogChannel::GetVerbosityELogLevel GetVerbosity() constDefinition RLogger.hxx:123; ROOT::Experimental::RLogChannel::SetVerbosityELogLevel SetVerbosity(ELogLevel verbosity)Definition RLogger.hxx:118; ROOT::Experimental::RLogChannel::GetNameconst std::string & GetName() constDefinition RLogger.hxx:126; ROOT::Experimental::RLogChannel::RLogChannelRLogChannel(ELogL",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RLogger_8hxx_source.html:16493,log,log,16493,doc/master/RLogger_8hxx_source.html,https://root.cern,https://root.cern/doc/master/RLogger_8hxx_source.html,1,['log'],['log']
Testability,"on TStyle.h:101; TStyle::GetDateXFloat_t GetDateX() constDefinition TStyle.h:197; TStyle::fStatFontStyle_t fStatFontFont style of Stats PaveLabel.Definition TStyle.h:109; TStyle::fLineStyleTString fLineStyle[30]String describing line style i (for postScript)Definition TStyle.h:130; TStyle::SetDateYvoid SetDateY(Float_t y=0.01)Definition TStyle.h:338; TStyle::fGridWidthWidth_t fGridWidthGrid line width.Definition TStyle.h:62; TStyle::fCandleBoxRangeDouble_t fCandleBoxRangeCandle plot, The fraction which is covered by the box (0 < x < 1), default 0.5.Definition TStyle.h:142; TStyle::GetTitleOffsetFloat_t GetTitleOffset(Option_t *axis=""X"") constReturn title offset.Definition TStyle.cxx:1228; TStyle::GetHistFillColorColor_t GetHistFillColor() constDefinition TStyle.h:232; TStyle::SetFrameBorderModevoid SetFrameBorderMode(Int_t mode=1)Definition TStyle.h:378; TStyle::GetTitleFontStyle_t GetTitleFont(Option_t *axis=""X"") constReturn title font.Definition TStyle.cxx:1216; TStyle::fOptLogxInt_t fOptLogxTrue if log scale in X.Definition TStyle.h:39; TStyle::fStripDecimalsBool_t fStripDecimalsStrip decimals in axis labels.Definition TStyle.h:117; TStyle::fHistMinimumZeroBool_t fHistMinimumZeroTrue if default minimum is 0, false if minimum is automatic.Definition TStyle.h:82; TStyle::fLegendFontStyle_t fLegendFontLegend font style.Definition TStyle.h:66; TStyle::SetFuncColorvoid SetFuncColor(Color_t color=1)Definition TStyle.h:367; TStyle::GetHistMinimumZeroBool_t GetHistMinimumZero() constDefinition TStyle.h:237; TStyle::fXaxisTAttAxis fXaxisX axis attributes.Definition TStyle.h:32; TStyle::SetHeaderPSvoid SetHeaderPS(const char *header)Define a string to be inserted in the Postscript header.Definition TStyle.cxx:1362; TStyle::GetStatYFloat_t GetStatY() constDefinition TStyle.h:265; TStyle::fTitleColorColor_t fTitleColorTitle fill area color.Definition TStyle.h:119; TStyle::fJoinLinePSInt_t fJoinLinePSDetermines the appearance of joining lines on PostScript, PDF and SVG.Definit",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TStyle_8cxx_source.html:106373,log,log,106373,doc/master/TStyle_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TStyle_8cxx_source.html,1,['log'],['log']
Testability,on Trees ... patience please; : Elapsed time for training with 1000 events: 0.386 sec ; <HEADER> BDT : [dataset] : Evaluation of BDT on training sample (1000 events); : Elapsed time for evaluation of 1000 events: 0.0729 sec ; : Creating xml weight file: dataset/weights/_BDT.weights.xml; : Creating standalone class: dataset/weights/_BDT.class.C; : out.root:/dataset/Method_BDT/BDT; <HEADER> Factory : Training finished; : ; : Ranking input variables (method specific)...; <HEADER> BDT : Ranking result (top variable is best ranked); : -----------------------------------; : Rank : Variable : Variable Importance; : -----------------------------------; : 1 : y : 5.011e-01; : 2 : x : 4.989e-01; : -----------------------------------; <HEADER> Factory : === Destroy and recreate all methods via weight files for testing ===; : ; : Reading weight file: dataset/weights/_BDT.weights.xml; <HEADER> Factory : Test all methods; <HEADER> Factory : Test method: BDT for Classification performance; : ; <HEADER> BDT : [dataset] : Evaluation of BDT on testing sample (1000 events); : Elapsed time for evaluation of 1000 events: 0.0581 sec ; <HEADER> Factory : Evaluate all methods; <HEADER> Factory : Evaluate classifier: BDT; : ; <HEADER> BDT : [dataset] : Loop over test events and fill histograms with classifier response...; : ; <HEADER> TFHandler_BDT : Variable Mean RMS [ Min Max ]; : -----------------------------------------------------------; : x: 1.0136 0.57754 [ 0.0011208 1.9999 ]; : y: 1.4938 0.75135 [ 0.0054384 2.9981 ]; : -----------------------------------------------------------; : ; : Evaluation results ranked by best signal efficiency and purity (area); : -------------------------------------------------------------------------------------------------------------------; : DataSet MVA ; : Name: Method: ROC-integ; : dataset BDT : 0.870; : -------------------------------------------------------------------------------------------------------------------; : ; : Testing efficiency compa,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVAMinimalClassification_8C.html:4908,test,testing,4908,doc/master/TMVAMinimalClassification_8C.html,https://root.cern,https://root.cern/doc/master/TMVAMinimalClassification_8C.html,1,['test'],['testing']
Testability,"on Trees ... patience please; : Elapsed time for training with 5000 events: 1.31 sec ; : Dataset[datasetcvreg] : Create results for training; : Dataset[datasetcvreg] : Evaluation of BDTG_fold2 on training sample; : Dataset[datasetcvreg] : Elapsed time for evaluation of 5000 events: 0.209 sec ; : Create variable histograms; : Create regression target histograms; : Create regression average deviation; : Results created; : Creating xml weight file: datasetcvreg/weights/TMVACrossValidationRegression_BDTG_fold2.weights.xml; <HEADER> Factory : Test all methods; <HEADER> Factory : Test method: BDTG_fold2 for Regression performance; : ; : Dataset[datasetcvreg] : Create results for testing; : Dataset[datasetcvreg] : Evaluation of BDTG_fold2 on testing sample; : Dataset[datasetcvreg] : Elapsed time for evaluation of 4999 events: 0.209 sec ; : Create variable histograms; : Create regression target histograms; : Create regression average deviation; : Results created; <HEADER> Factory : Evaluate all methods; : Evaluate regression method: BDTG_fold2; : TestRegression (testing); : Calculate regression for all events; : Elapsed time for evaluation of 4999 events: 0.208 sec ; : TestRegression (training); : Calculate regression for all events; : Elapsed time for evaluation of 5000 events: 0.208 sec ; : ; : Evaluation results ranked by smallest RMS on test sample:; : (""Bias"" quotes the mean deviation of the regression from true target.; : ""MutInf"" is the ""Mutual Information"" between regression and target.; : Indicated by ""_T"" are the corresponding ""truncated"" quantities ob-; : tained when removing events deviating more than 2sigma from average.); : --------------------------------------------------------------------------------------------------; : --------------------------------------------------------------------------------------------------; : datasetcvreg BDTG_fold2 : -0.0428 -0.0362 2.33 1.72 | 3.109 3.188; : ----------------------------------------------------------------------",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVACrossValidationRegression_8C.html:7669,test,testing,7669,doc/master/TMVACrossValidationRegression_8C.html,https://root.cern,https://root.cern/doc/master/TMVACrossValidationRegression_8C.html,1,['test'],['testing']
Testability,"on algorithm If not set use default algorithmic values In case of ToyMC sampling of the nuisance the value is 100 In case of using the GSL MCintegrations types the default value is defined in ROOT::Math::IntegratorMultiDimOptions::DefaultNCalls() ; ; virtual voidSetParameters (const RooArgSet &set); specify the parameters of interest in the interval ; ; virtual voidSetPriorPdf (RooAbsPdf &pdf); Set only the Prior Pdf. ; ; voidSetScanOfPosterior (int nbin=100); use directly the approximate posterior function obtained by binning it in nbins by default the cdf is used by integrating the posterior if a value of nbin <= 0 the cdf function will be used ; ; voidSetShortestInterval (); set the Bayesian calculator to compute the shortest interval (default is central interval) to switch off SetLeftSideTailFraction to the right value ; ; voidSetTestSize (double size) override; set the size of the test (rate of Type I error) ( Eg. 0.05 for a 95% Confidence Interval) ; ; doubleSize () const override; Get the size of the test (eg. rate of Type I error) ; ; voidStreamer (TBuffer &) override; ; voidStreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b); ; Public Member Functions inherited from RooStats::IntervalCalculator; virtual~IntervalCalculator (); ; voidStreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b); ; Public Member Functions inherited from TNamed; TNamed (); ; TNamed (const char *name, const char *title); ; TNamed (const TNamed &named); TNamed copy ctor. ; ; TNamed (const TString &name, const TString &title); ; virtual~TNamed (); TNamed destructor. ; ; voidClear (Option_t *option="""") override; Set name and title to empty strings (""""). ; ; TObject *Clone (const char *newname="""") const override; Make a clone of an object using the Streamer facility. ; ; Int_tCompare (const TObject *obj) const override; Compare two TNamed objects. ; ; voidCopy (TObject &named) const override; Copy this to obj. ; ; virtual voidFillB",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooStats_1_1BayesianCalculator.html:7046,test,test,7046,doc/master/classRooStats_1_1BayesianCalculator.html,https://root.cern,https://root.cern/doc/master/classRooStats_1_1BayesianCalculator.html,1,['test'],['test']
Testability,"on all nodes in the expression tree. Bool_t dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Test whether we depend on (ie, are served by) any object in the; specified collection. Uses the dependsOn(RooAbsArg&) member function. Bool_t dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Test whether we depend on (ie, are served by) the specified object.; Note that RooAbsArg objects are considered equivalent if they have; the same name. Bool_t overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; Test if any of the nodes of tree are shared with that of the given tree. Bool_t observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Test if any of the dependents of the arg tree (as determined by getObservables); overlaps with those of the testArg. Bool_t observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Test if any of the dependents of the arg tree (as determined by getObservables); overlaps with those of the testArg. void setValueDirty(const RooAbsArg* source) const; Mark this object as having changed its value, and propagate this status; change to all of our clients. If the object is not in automatic dirty; state propagation mode, this call has no effect. void setShapeDirty(const RooAbsArg* source) const; Mark this object as having changed its shape, and propagate this status; change to all of our clients. Bool_t redirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t isRecursionStep = kFALSE); Substitute our servers with those listed in newSet. If nameChange is false, servers and; and substitutes are matched by name. If nameChange is true, servers are matched to args; in newSet that have the 'ORIGNAME:<servername>' attribute set. If mustReplaceAll is set,; a warning is printed and error status is returned if not all servers could b",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooAbsArg.html:23748,test,testArg,23748,root/html528/RooAbsArg.html,https://root.cern,https://root.cern/root/html528/RooAbsArg.html,12,['test'],['testArg']
Testability,"on at line 1238 of file TGNumberEntry.cxx. SetFormat(). void TGNumberEntryField::SetFormat ; (; EStyle; style, . EAttribute; attr = kNEAAnyNumber. ). virtual . Set the numerical format. ; Definition at line 1628 of file TGNumberEntry.cxx. SetHexNumber(). void TGNumberEntryField::SetHexNumber ; (; ULong_t; val, . Bool_t; emit = kTRUE. ). virtual . Set the numeric value (hex format). ; Definition at line 1257 of file TGNumberEntry.cxx. SetIntNumber(). void TGNumberEntryField::SetIntNumber ; (; Long_t; val, . Bool_t; emit = kTRUE. ). virtual . Set the numeric value (integer representation). ; Definition at line 1198 of file TGNumberEntry.cxx. SetLimits(). void TGNumberEntryField::SetLimits ; (; ELimit; limits = kNELNoLimits, . Double_t; min = 0, . Double_t; max = 1. ). virtual . Set the numerical limits. ; Definition at line 1643 of file TGNumberEntry.cxx. SetLogStep(). virtual void TGNumberEntryField::SetLogStep ; (; Bool_t; on = kTRUE). inlinevirtual . Set logarithmic steps. ; Definition at line 113 of file TGNumberEntry.h. SetNumber(). void TGNumberEntryField::SetNumber ; (; Double_t; val, . Bool_t; emit = kTRUE. ). virtual . Set the numeric value (floating point representation). ; Definition at line 1143 of file TGNumberEntry.cxx. SetState(). void TGNumberEntryField::SetState ; (; Bool_t; state). overridevirtual . Set the active state. ; Reimplemented from TGTextEntry.; Definition at line 1658 of file TGNumberEntry.cxx. SetText(). void TGNumberEntryField::SetText ; (; const char *; text, . Bool_t; emit = kTRUE. ). overridevirtual . Set the value (text format). ; Reimplemented from TGTextEntry.; Definition at line 1265 of file TGNumberEntry.cxx. SetTime(). void TGNumberEntryField::SetTime ; (; Int_t; hour, . Int_t; min, . Int_t; sec, . Bool_t; emit = kTRUE. ). virtual . Set the numeric value (time format). ; In case of kNESMinSecCent, pass the centiseconds in the hour variable. ; Definition at line 1214 of file TGNumberEntr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGNumberEntryField.html:49127,log,logarithmic,49127,doc/master/classTGNumberEntryField.html,https://root.cern,https://root.cern/doc/master/classTGNumberEntryField.html,1,['log'],['logarithmic']
Testability,"on at line 131 of file TProofBenchRunDataRead.h. GetStep(). Int_t TProofBenchRunDataRead::GetStep ; (; ); const. inline . Definition at line 133 of file TProofBenchRunDataRead.h. GetStop(). Int_t TProofBenchRunDataRead::GetStop ; (; ); const. inline . Definition at line 132 of file TProofBenchRunDataRead.h. IsA(). TClass * TProofBenchRunDataRead::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TProofBenchRun.; Definition at line 141 of file TProofBenchRunDataRead.h. Print(). void TProofBenchRunDataRead::Print ; (; Option_t *; option = """"); const. overridevirtual . Print the content of this object. ; Implements TProofBenchRun.; Definition at line 669 of file TProofBenchRunDataRead.cxx. Run() [1/2]. void TProofBenchRunDataRead::Run ; (; const char *; dset, . Int_t; start, . Int_t; stop, . Int_t; step, . Int_t; ntries, . Int_t; debug, . Int_t; . ). overridevirtual . Run benchmark Input parameters dset: Dataset on which to run start: Start scan with 'start' workers. ; stop: Stop scan at 'stop workers. step: Scan every 'step' workers. ntries: Number of tries. When it is -1, data member fNTries is used. debug: debug switch. Int_t: Ignored Returns Nothing ; Implements TProofBenchRun.; Definition at line 123 of file TProofBenchRunDataRead.cxx. Run() [2/2]. void TProofBenchRunDataRead::Run ; (; Long64_t; , . Int_t; , . Int_t; , . Int_t; , . Int_t; , . Int_t; , . Int_t; . ). inlineoverridevirtual . Implements TProofBenchRun.; Definition at line 107 of file TProofBenchRunDataRead.h. SetDebug(). void TProofBenchRunDataRead::SetDebug ; (; Int_t; debug). inline . Definition at line 123 of file TProofBenchRunDataRead.h. SetDirProofBench(). void TProofBenchRunDataRead::SetDirProofBench ; (; TDirectory *; dir). inline . Definition at line 124 of file TProofBenchRunDataRead.h. SetFilesPerWrk(). void TProofBenchRunDataRead::SetFilesPerWrk ; (; Int_t; fpw). inline . Definition at line 125 of fi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProofBenchRunDataRead.html:18734,benchmark,benchmark,18734,doc/master/classTProofBenchRunDataRead.html,https://root.cern,https://root.cern/doc/master/classTProofBenchRunDataRead.html,1,['benchmark'],['benchmark']
Testability,"on at line 159 of file Classification.h. DeclFileName(). static const char * TMVA::Experimental::ClassificationResult::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 159 of file Classification.h. GetDataLoaderName(). TString TMVA::Experimental::ClassificationResult::GetDataLoaderName ; (; ). inline . Definition at line 151 of file Classification.h. GetMethodName(). const TString TMVA::Experimental::ClassificationResult::GetMethodName ; (; ); const. inline . Definition at line 147 of file Classification.h. GetMethodTitle(). const TString TMVA::Experimental::ClassificationResult::GetMethodTitle ; (; ); const. inline . Definition at line 148 of file Classification.h. GetROC(). TMVA::ROCCurve * TMVA::Experimental::ClassificationResult::GetROC ; (; UInt_t; iClass = 0, . TMVA::Types::ETreeType; type = TMVA::Types::kTesting. ). Method to get TMVA::ROCCurve Object. ; Parameters. iClasscategory, default 0 then signal ; typetrain/test tree, default test. . ReturnsTMVA::ROCCurve object. ; Definition at line 93 of file Classification.cxx. GetROCGraph(). TGraph * TMVA::Experimental::ClassificationResult::GetROCGraph ; (; UInt_t; iClass = 0, . TMVA::Types::ETreeType; type = TMVA::Types::kTesting. ). Method to get TGraph object with the ROC curve. ; Parameters. iClasscategory, default 0 then signal ; typetrain/test tree, default test. . ReturnsTGraph object. ; Definition at line 149 of file Classification.cxx. GetROCIntegral(). Double_t TMVA::Experimental::ClassificationResult::GetROCIntegral ; (; UInt_t; iClass = 0, . TMVA::Types::ETreeType; type = TMVA::Types::kTesting. ). Method to get ROC-Integral value from mvas. ; Parameters. iClasscategory, default 0 then signal ; typetrain/test tree, default test. . ReturnsDouble_t with the ROC-Integral value. ; Definition at line 74 of file Classification.cxx. IsA(). virtual TClass * TMVA::Experimental::ClassificationResult::IsA ; (; ); const. inlin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1Experimental_1_1ClassificationResult.html:13500,test,test,13500,doc/master/classTMVA_1_1Experimental_1_1ClassificationResult.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1Experimental_1_1ClassificationResult.html,2,['test'],['test']
Testability,"on at line 1812 of file TSessionViewer.cxx. OnBtnDownClicked(). void TSessionFrame::OnBtnDownClicked ; (; ). Move selected package entry one position down in the list. ; Definition at line 1776 of file TSessionViewer.cxx. OnBtnGetQueriesClicked(). void TSessionFrame::OnBtnGetQueriesClicked ; (; ). Get list of queries from current Proof server and populate the list tree. ; Definition at line 1862 of file TSessionViewer.cxx. OnBtnNewQueryClicked(). void TSessionFrame::OnBtnNewQueryClicked ; (; ). Call ""New Query"" Dialog. ; Definition at line 1853 of file TSessionViewer.cxx. OnBtnRemoveClicked(). void TSessionFrame::OnBtnRemoveClicked ; (; ). Remove selected package from the list. ; Definition at line 1711 of file TSessionViewer.cxx. OnBtnRemoveDSet(). void TSessionFrame::OnBtnRemoveDSet ; (; ). Remove dataset from the list and from the cluster. ; Definition at line 1393 of file TSessionViewer.cxx. OnBtnShowLogClicked(). void TSessionFrame::OnBtnShowLogClicked ; (; ). Show session log. ; Definition at line 1845 of file TSessionViewer.cxx. OnBtnUpClicked(). void TSessionFrame::OnBtnUpClicked ; (; ). Move selected package entry one position up in the list. ; Definition at line 1741 of file TSessionViewer.cxx. OnBtnUploadDSet(). void TSessionFrame::OnBtnUploadDSet ; (; ). Open Upload Dataset dialog. ; Definition at line 1330 of file TSessionViewer.cxx. OnBtnVerifyDSet(). void TSessionFrame::OnBtnVerifyDSet ; (; ). Verify that the files in the selected dataset are present on the cluster. ; Definition at line 1422 of file TSessionViewer.cxx. OnClearPackages(). void TSessionFrame::OnClearPackages ; (; ). Clear (disable) all packages in the current session. ; Definition at line 1641 of file TSessionViewer.cxx. OnCommandLine(). void TSessionFrame::OnCommandLine ; (; ). Command line handling. ; Definition at line 1930 of file TSessionViewer.cxx. OnDisablePackages(). void TSessionFrame::OnDisablePackages ; (; ). Disable selected package(s) in the current ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSessionFrame.html:37034,log,log,37034,doc/master/classTSessionFrame.html,https://root.cern,https://root.cern/doc/master/classTSessionFrame.html,1,['log'],['log']
Testability,"on at line 42 of file TMultiDimFit.h. fShowCorrelation. Bool_t TMultiDimFit::fShowCorrelation. protected . print correlation matrix ; Definition at line 104 of file TMultiDimFit.h. fSqError. TVectorD TMultiDimFit::fSqError. protected . Training sample, error in quantity. ; Definition at line 29 of file TMultiDimFit.h. fSumSqAvgQuantity. Double_t TMultiDimFit::fSumSqAvgQuantity. protected . Sum of squares away from mean. ; Definition at line 34 of file TMultiDimFit.h. fSumSqQuantity. Double_t TMultiDimFit::fSumSqQuantity. protected . SumSquare of dependent quantity. ; Definition at line 33 of file TMultiDimFit.h. fSumSqResidual. Double_t TMultiDimFit::fSumSqResidual. protected . Sum of Square residuals. ; Definition at line 77 of file TMultiDimFit.h. fTestCorrelationCoeff. Double_t TMultiDimFit::fTestCorrelationCoeff. protected . Multi Correlation coefficient. ; Definition at line 94 of file TMultiDimFit.h. fTestError. Double_t TMultiDimFit::fTestError. protected . Error from test. ; Definition at line 89 of file TMultiDimFit.h. fTestPrecision. Double_t TMultiDimFit::fTestPrecision. protected . Relative precision of test. ; Definition at line 91 of file TMultiDimFit.h. fTestQuantity. TVectorD TMultiDimFit::fTestQuantity. protected . Test sample, dependent quantity. ; Definition at line 44 of file TMultiDimFit.h. fTestSampleSize. Int_t TMultiDimFit::fTestSampleSize. protected . Size of test sample. ; Definition at line 48 of file TMultiDimFit.h. fTestSqError. TVectorD TMultiDimFit::fTestSqError. protected . Test sample, Error in quantity. ; Definition at line 45 of file TMultiDimFit.h. fTestVariables. TVectorD TMultiDimFit::fTestVariables. protected . Test sample, independent variables. ; Definition at line 46 of file TMultiDimFit.h. fVariables. TVectorD TMultiDimFit::fVariables. protected . Training sample, independent variables. ; Definition at line 36 of file TMultiDimFit.h. Libraries for TMultiDimFit:. [legend]; The documentation for this ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMultiDimFit.html:68933,test,test,68933,doc/master/classTMultiDimFit.html,https://root.cern,https://root.cern/doc/master/classTMultiDimFit.html,1,['test'],['test']
Testability,"on at line 630 of file TXMLFile.cxx. ReadStreamerElement(). void TXMLFile::ReadStreamerElement ; (; XMLNodePointer_t; node, . TStreamerInfo *; info. ). protected . read and reconstruct single TStreamerElement from xml node ; Definition at line 825 of file TXMLFile.cxx. Recover(). Int_t TXMLFile::Recover ; (; ). inlinefinalvirtual . Attempt to recover file if not correctly closed. ; The function returns the number of keys that have been recovered. If no keys can be recovered, the file will be declared Zombie by the calling function. This function is automatically called when opening a file. If the file is open in read only mode, the file is not modified. If open in update mode and the function finds something to recover, a new directory header is written to the file. When opening the file gain no message from Recover will be reported. If keys have been recovered, the file is usable and you can safely read the corresponding objects. If the file is not usable (a zombie), you can test for this case with code like:; TFile f(""myfile.root"");; if (f.IsZombie()) {<actions to take if file is unusable>}; TFileA ROOT file is an on-disk file, usually with extension .root, that stores objects in a file-system-li...Definition TFile.h:53; If the file has been recovered, the bit kRecovered is set in the TFile object in memory. You can test if the file has been recovered with if (f.TestBit(TFile::kRecovered)) {... the file has been recovered}; When writing TTrees to a file, it is important to save the Tree header at regular intervals (see TTree::AutoSave). If a file containing a Tree is recovered, the last Tree header written to the file will be used. In this case all the entries in all the branches written before writing the header are valid entries. One can disable the automatic recovery procedure by setting TFile.Recover 0; in the system.rootrc file. ; Reimplemented from TFile.; Definition at line 86 of file TXMLFile.h. ReOpen(). Int_t TXMLFile::ReOpen ; (; Option_t *; mo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTXMLFile.html:67155,test,test,67155,doc/master/classTXMLFile.html,https://root.cern,https://root.cern/doc/master/classTXMLFile.html,1,['test'],['test']
Testability,"on at line 729 of file TApplicationServer.cxx. Reset(). void TApplicationServer::Reset ; (; const char *; dir). Reset environment to be ready for execution of next command. ; Definition at line 708 of file TApplicationServer.cxx. Run(). void TApplicationServer::Run ; (; Bool_t; retrn = kFALSE). overridevirtual . Main server eventloop. ; Reimplemented from TApplication.; Definition at line 474 of file TApplicationServer.cxx. SendCanvases(). Int_t TApplicationServer::SendCanvases ; (; ). private . Send any created canvas to client. ; Definition at line 881 of file TApplicationServer.cxx. SendLogFile(). void TApplicationServer::SendLogFile ; (; Int_t; status = 0, . Int_t; start = -1, . Int_t; end = -1. ). Send log file to master. ; If start > -1 send only bytes in the range from start to end, if end <= start send everything from start. ; Definition at line 802 of file TApplicationServer.cxx. Setup(). Int_t TApplicationServer::Setup ; (; ). private . Print the Remote Server logo on standard output. ; Return 0 on success, -1 on failure ; Definition at line 366 of file TApplicationServer.cxx. Streamer(). void TApplicationServer::Streamer ; (; TBuffer &; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from TApplication. StreamerNVirtual(). void TApplicationServer::StreamerNVirtual ; (; TBuffer &; ClassDef_StreamerNVirtual_b). inline . Definition at line 94 of file TApplicationServer.h. Terminate(). void TApplicationServer::Terminate ; (; Int_t; status). overridevirtual . Terminate the proof server. ; Reimplemented from TApplication.; Definition at line 1028 of file TApplicationServer.cxx. Member Data Documentation. fInterrupt. Bool_t TApplicationServer::fInterrupt. private . Definition at line 41 of file TApplicationServer.h. fIsValid. Bool_t TApplicationServer::fIsValid. private . Definition at line 40 of file TApplicationServer.h. fLogFile. FILE* TApplicationServer::fLogFile. private . Definition at line 44 of fil",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTApplicationServer.html:29693,log,logo,29693,doc/master/classTApplicationServer.html,https://root.cern,https://root.cern/doc/master/classTApplicationServer.html,1,['log'],['logo']
Testability,"on at line 7345 of file TClass.cxx. HasConsistentHashMember() [2/2]. Bool_t ROOT::Internal::HasConsistentHashMember ; (; TClass &; clRef). Return true is the Hash/RecursiveRemove setup is consistent, i.e. ; when all classes in the class hierarchy that overload TObject::Hash do call ROOT::CallRecursiveRemoveIfNeeded in their destructor. i.e. it is safe to call the Hash virtual function during the RecursiveRemove operation. ; Definition at line 7371 of file TClass.cxx. IsImplicitMTEnabledImpl(). static Bool_t & ROOT::Internal::IsImplicitMTEnabledImpl ; (; ). static . Keeps track of the status of ImplicitMT w/o resorting to the load of libImt. ; Definition at line 463 of file TROOT.cxx. IsParBranchProcessingEnabled(). Bool_t ROOT::Internal::IsParBranchProcessingEnabled ; (; ). Returns true if parallel branch processing is enabled. ; Definition at line 447 of file TROOT.cxx. LogicalCPUBandwidthControl(). int ROOT::Internal::LogicalCPUBandwidthControl ; (; ). Returns the available number of logical cores. . Checks if there is CFS bandwidth control in place (linux, via cgroups, assuming standard paths); Otherwise, returns the number of logical cores provided by std::thread::hardware_concurrency() . Definition at line 50 of file RTaskArena.cxx. MinimalErrorHandler(). void ROOT::Internal::MinimalErrorHandler ; (; Int_t; level, . Bool_t; abort_bool, . const char *; location, . const char *; msg. ). A very simple error handler that is usually replaced by the TROOT default error handler. ; The minimal error handler is not serialized across threads, so that output of multi-threaded programs can get scrambled Noteabort() is only called if abort_bool is true and level >= gErrorIgnoreLevel ; Definition at line 67 of file TError.cxx. NotifyDirected(). void ROOT::Internal::NotifyDirected ; (; Detail::TBranchProxy *; x). Definition at line 36 of file TBranchProxyDirector.cxx. operator<<(). std::ostream & ROOT::Internal::operator<< ; (; std::ostream &; os, . const",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/namespaceROOT_1_1Internal.html:37208,log,logical,37208,doc/v632/namespaceROOT_1_1Internal.html,https://root.cern,https://root.cern/doc/v632/namespaceROOT_1_1Internal.html,1,['log'],['logical']
Testability,"on at line 7412 of file TClass.cxx. HasConsistentHashMember() [2/2]. Bool_t ROOT::Internal::HasConsistentHashMember ; (; TClass &; clRef). Return true is the Hash/RecursiveRemove setup is consistent, i.e. ; when all classes in the class hierarchy that overload TObject::Hash do call ROOT::CallRecursiveRemoveIfNeeded in their destructor. i.e. it is safe to call the Hash virtual function during the RecursiveRemove operation. ; Definition at line 7438 of file TClass.cxx. IsImplicitMTEnabledImpl(). static Bool_t & ROOT::Internal::IsImplicitMTEnabledImpl ; (; ). static . Keeps track of the status of ImplicitMT w/o resorting to the load of libImt. ; Definition at line 463 of file TROOT.cxx. IsParBranchProcessingEnabled(). Bool_t ROOT::Internal::IsParBranchProcessingEnabled ; (; ). Returns true if parallel branch processing is enabled. ; Definition at line 447 of file TROOT.cxx. LogicalCPUBandwidthControl(). int ROOT::Internal::LogicalCPUBandwidthControl ; (; ). Returns the available number of logical cores. . Checks if there is CFS bandwidth control in place (linux, via cgroups, assuming standard paths); Otherwise, returns the number of logical cores provided by std::thread::hardware_concurrency() . Definition at line 50 of file RTaskArena.cxx. MinimalErrorHandler(). void ROOT::Internal::MinimalErrorHandler ; (; Int_t; level, . Bool_t; abort_bool, . const char *; location, . const char *; msg. ). A very simple error handler that is usually replaced by the TROOT default error handler. ; The minimal error handler is not serialized across threads, so that output of multi-threaded programs can get scrambled Noteabort() is only called if abort_bool is true and level >= gErrorIgnoreLevel ; Definition at line 67 of file TError.cxx. NotifyDirected(). void ROOT::Internal::NotifyDirected ; (; Detail::TBranchProxy *; x). Definition at line 36 of file TBranchProxyDirector.cxx. operator<<(). std::ostream & ROOT::Internal::operator<< ; (; std::ostream &; os, . const",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/namespaceROOT_1_1Internal.html:37789,log,logical,37789,doc/master/namespaceROOT_1_1Internal.html,https://root.cern,https://root.cern/doc/master/namespaceROOT_1_1Internal.html,1,['log'],['logical']
Testability,"on at line 965 of file TGeoVolume.cxx. CheckGeometry(). void TGeoVolume::CheckGeometry ; (; Int_t; nrays = 1, . Double_t; startx = 0, . Double_t; starty = 0, . Double_t; startz = 0. ); const. Shoot nrays with random directions from starting point (startx, starty, startz) in the reference frame of this volume. ; Track each ray until exiting geometry, then shoot backwards from exiting point and compare boundary crossing points. ; Definition at line 588 of file TGeoVolume.cxx. CheckOverlaps(). void TGeoVolume::CheckOverlaps ; (; Double_t; ovlp = 0.1, . Option_t *; option = """". ); const. Overlap checking tool. ; Check for illegal overlaps within a limit OVLP. Use option=""s[number]"" to force overlap checking by sampling volume with [number] points.; Ex: myVol->CheckOverlaps(0.01, ""s10000000""); // shoot 10000000 points; myVol->CheckOverlaps(0.01, ""s""); // shoot the default value of 1e6 points. Definition at line 611 of file TGeoVolume.cxx. CheckShape(). void TGeoVolume::CheckShape ; (; Int_t; testNo, . Int_t; nsamples = 10000, . Option_t *; option = """". ). Tests for checking the shape navigation algorithms. See TGeoShape::CheckShape() ; Definition at line 651 of file TGeoVolume.cxx. CheckShapes(). void TGeoVolume::CheckShapes ; (; ). check for negative parameters in shapes. ; Definition at line 676 of file TGeoVolume.cxx. Class(). static TClass * TGeoVolume::Class ; (; ). static . ReturnsTClass describing this class . Class_Name(). static const char * TGeoVolume::Class_Name ; (; ). static . ReturnsName of this class . Class_Version(). static constexpr Version_t TGeoVolume::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 256 of file TGeoVolume.h. CleanAll(). void TGeoVolume::CleanAll ; (; ). Clean data of the volume. ; Definition at line 659 of file TGeoVolume.cxx. ClearNodes(). void TGeoVolume::ClearNodes ; (; ). inline . Definition at line 95 of file TGeoVolume.h. ClearShape(). void TGeoVolume",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoVolume.html:43417,test,testNo,43417,doc/master/classTGeoVolume.html,https://root.cern,https://root.cern/doc/master/classTGeoVolume.html,1,['test'],['testNo']
Testability,"on edges and decreasing clipping window. In the lower part of the Figure we present the background, which was added to the synthetic spectrum. One can observe good coincidence with the estimated background. The method of the estimation of Compton edge is described in details in [3]. Synthetic spectrum with Compton edges. The generalized form of the algorithm is implemented in the following function.; char *Background1General(float *spectrum,; int size,; int number_of_iterations,; int direction,; int filter_order,; bool compton);; The meaning of the parameters is as follows:. spectrum: pointer to the vector of the source spectrum; size: length of spectrum vector; number_of_iterations: maximal width of clipping window; direction: direction of change of clipping window. Possible values:. BACK1_INCREASING_WINDOW; BACK1_DECREASING_WINDOW. filter_order: order of clipping filter. Possible values:. BACK1_ORDER2; BACK1_ORDER4; BACK1_ORDER6; BACK1_ORDER8. compton: logical variable whether the estimation of Compton edge will be included. Possible values:. BACK1_EXCLUDE_COMPTON; BACK1_INCLUDE_COMPTON. 1.2 2-DIMENSIONAL SPECTRA; This basic background estimation function allows to separate useless spectrum information (2D-continuous background and coincidences of peaks with background in both dimensions) from peaks. It calculates background spectrum from the source spectrum. The result is placed in the array pointed by spectrum pointer. On successful completion it returns 0. On error it returns a pointer to the string describing error.; char *Background2(float **spectrum,; int sizex,; int sizey,; int number_of_iterations);; Function parameters:. spectrum: pointer to the array of the source spectrum; sizex: x length of spectrum; sizey: y length of spectrum; number_of_iterations: width of the clipping window. In Figure 1.6 we present an example of a 2-dimensional spectrum before background elimination. 2-dimensional spectrum before background elimination. Estimated background is sho",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/spectrum/Spectrum.html:4689,log,logical,4689,root/htmldoc/guides/spectrum/Spectrum.html,https://root.cern,https://root.cern/root/htmldoc/guides/spectrum/Spectrum.html,1,['log'],['logical']
Testability,on functions. Function Members (Methods); public:. virtual~TActivationChooser(); static TClass*Class(); TMVA::TActivation*CreateActivation(TMVA::TActivationChooser::EActivationType type) const; TMVA::TActivation*CreateActivation(const TString& type) const; vector<TString>*GetAllActivationNames() const; virtual TClass*IsA() const; TMVA::TActivationChooser&operator=(const TMVA::TActivationChooser&); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); TMVA::TActivationChooserTActivationChooser(); TMVA::TActivationChooserTActivationChooser(const TMVA::TActivationChooser&). private:. TMVA::MsgLogger&Log() const. Data Members; public:. static TMVA::TActivationChooser::EActivationTypekLinear; static TMVA::TActivationChooser::EActivationTypekRadial; static TMVA::TActivationChooser::EActivationTypekSigmoid; static TMVA::TActivationChooser::EActivationTypekTanh. private:. TStringfLINEARactivation function name; TMVA::MsgLogger*fLogger! message logger; TStringfRADIALactivation function name; TStringfSIGMOIDactivation function name; TStringfTANHactivation function name. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TActivationChooser(); defaut constructor. ~TActivationChooser(); destructor. CreateActivation(EActivationType type); instantiate the correct activation object according to the; type choosen (given as the enumeration type). CreateActivation(const TString& type) const; instantiate the correct activation object according to the; type choosen (given by a TString). GetAllActivationNames() const; retuns the names of all know activation functions. TActivationChooser().  Author: Matt Jachowski  Copyright (c) 2005: *;  Last changed: root/tmva $Id$  Last generated: 2015-06-30 15:17; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TMVA__TActivationChooser.html:1406,log,logger,1406,root/html602/TMVA__TActivationChooser.html,https://root.cern,https://root.cern/root/html602/TMVA__TActivationChooser.html,1,['log'],['logger']
Testability,on is an interface for all proposal functions that would be used with a Markov Chain Monte Carlo algorithm ; CProposalHelper; CRatioOfProfiledLikelihoodsTestStatTestStatistic that returns the ratio of profiled likelihoods ; CSamplingDistPlotThis class provides simple and straightforward utilities to plot SamplingDistribution objects ; CSamplingDistributionThis class simply holds a sampling distribution of some test statistic ; CSamplingSummary; CSamplingSummaryLookup; CSequentialProposalClass implementing a proposal function that samples the parameter space by moving only in one coordinate (chosen randomly) at each step ; CSimpleIntervalSimpleInterval is a concrete implementation of the ConfInterval interface ; CSimpleLikelihoodRatioTestStatTestStatistic class that returns -log(L[null] / L[alt]) where L is the likelihood ; CSPlotThis class calculates sWeights used to create an sPlot ; CTestStatisticTestStatistic is an interface class to provide a facility for construction test statistics distributions to the NeymanConstruction class ; CTestStatSamplerTestStatSampler is an interface class for a tools which produce RooStats SamplingDistributions ; CToyMCImportanceSamplerToyMCImportanceSampler is an extension of the ToyMCSampler for Importance Sampling ; CToyMCPayload; CToyMCSamplerToyMCSampler is an implementation of the TestStatSampler interface ; CToyMCStudyToyMCStudy is an implementation of RooAbsStudy for toy Monte Carlo sampling ; CUniformProposalUniformProposal is a concrete implementation of the ProposalFunction interface for use with a Markov Chain Monte Carlo algorithm ; CUpperLimitMCSModuleThis class allow to compute in the ToyMcStudy framework the ProfileLikelihood upper limit for each toy-MC sample generated ; NROOTNamespace for new ROOT classes and functions ; NCocoaTutorials; NDetail; NRDF; NCustomColExtraArgs; CNone; CSlot; CSlotAndEntry; CRCustomColumn; CRCustomColumnBase; CRFilter; CRFilterBase; CRJittedCustomColumnA ,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v616/namespaces.html:15846,test,test,15846,doc/v616/namespaces.html,https://root.cern,https://root.cern/doc/v616/namespaces.html,1,['test'],['test']
Testability,"on is an interface for all proposal functions that would be used with a Markov Chain Monte Carlo algorithm ; CProposalHelper; CRatioOfProfiledLikelihoodsTestStatTestStatistic that returns the ratio of profiled likelihoods ; CSamplingDistPlotThis class provides simple and straightforward utilities to plot SamplingDistribution objects ; CSamplingDistributionThis class simply holds a sampling distribution of some test statistic ; CSamplingSummary; CSamplingSummaryLookup; CSequentialProposalClass implementing a proposal function that samples the parameter space by moving only in one coordinate (chosen randomly) at each step ; CSimpleIntervalSimpleInterval is a concrete implementation of the ConfInterval interface ; CSimpleLikelihoodRatioTestStatTestStatistic class that returns -log(L[null] / L[alt]) where L is the likelihood ; CSPlotThis class calculates sWeights used to create an sPlot ; CTestStatisticTestStatistic is an interface class to provide a facility for construction test statistics distributions to the NeymanConstruction class ; CTestStatSamplerTestStatSampler is an interface class for a tools which produce RooStats SamplingDistributions ; CToyMCImportanceSamplerToyMCImportanceSampler is an extension of the ToyMCSampler for Importance Sampling ; CToyMCPayload; CToyMCSamplerToyMCSampler is an implementation of the TestStatSampler interface ; CToyMCStudyToyMCStudy is an implementation of RooAbsStudy for toy Monte Carlo sampling ; CUniformProposalUniformProposal is a concrete implementation of the ProposalFunction interface for use with a Markov Chain Monte Carlo algorithm ; CUpperLimitMCSModuleThis class allow to compute in the ToyMcStudy framework the ProfileLikelihood upper limit for each toy-MC sample generated ; NROOTNamespace for new ROOT classes and functions ; NDetail; NRDF; CRCustomColumn; CRCustomColumnBase; CRFilter; CRFilterBase; CRJittedFilterA wrapper around a concrete RFilter, which forwards all calls to it RJittedFilter",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v614/annotated.html:11480,test,test,11480,doc/v614/annotated.html,https://root.cern,https://root.cern/doc/v614/annotated.html,1,['test'],['test']
Testability,on is an interface for all proposal functions that would be used with a Markov Chain Monte Carlo algorithm ; CProposalHelper; CRatioOfProfiledLikelihoodsTestStatTestStatistic that returns the ratio of profiled likelihoods ; CSamplingDistPlotThis class provides simple and straightforward utilities to plot SamplingDistribution objects ; CSamplingDistributionThis class simply holds a sampling distribution of some test statistic ; CSamplingSummary; CSamplingSummaryLookup; CSequentialProposalClass implementing a proposal function that samples the parameter space by moving only in one coordinate (chosen randomly) at each step ; CSimpleIntervalSimpleInterval is a concrete implementation of the ConfInterval interface ; CSimpleLikelihoodRatioTestStatTestStatistic class that returns -log(L[null] / L[alt]) where L is the likelihood ; CSPlotThis class calculates sWeights used to create an sPlot ; CTestStatisticTestStatistic is an interface class to provide a facility for construction test statistics distributions to the NeymanConstruction class ; CTestStatSamplerTestStatSampler is an interface class for a tools which produce RooStats SamplingDistributions ; CToyMCImportanceSamplerToyMCImportanceSampler is an extension of the ToyMCSampler for Importance Sampling ; CToyMCPayload; CToyMCSamplerToyMCSampler is an implementation of the TestStatSampler interface ; CToyMCStudyToyMCStudy is an implementation of RooAbsStudy for toy Monte Carlo sampling ; CUniformProposalUniformProposal is a concrete implementation of the ProposalFunction interface for use with a Markov Chain Monte Carlo algorithm ; CUpperLimitMCSModuleThis class allow to compute in the ToyMcStudy framework the ProfileLikelihood upper limit for each toy-MC sample generated ; NROOTNamespace for new ROOT classes and functions ; NDetail; NRDF; NCustomColExtraArgs; CNone; CSlot; CSlotAndEntry; CRCustomColumn; CRCustomColumnBase; CRFilter; CRFilterBase; CRJittedCustomColumnA wrapper around a c,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v616/annotated.html:12946,test,test,12946,doc/v616/annotated.html,https://root.cern,https://root.cern/doc/v616/annotated.html,1,['test'],['test']
Testability,on is an interface for all proposal functions that would be used with a Markov Chain Monte Carlo algorithm ; CProposalHelper; CRatioOfProfiledLikelihoodsTestStatTestStatistic that returns the ratio of profiled likelihoods ; CSamplingDistPlotThis class provides simple and straightforward utilities to plot SamplingDistribution objects ; CSamplingDistributionThis class simply holds a sampling distribution of some test statistic ; CSamplingSummary; CSamplingSummaryLookup; CSequentialProposalClass implementing a proposal function that samples the parameter space by moving only in one coordinate (chosen randomly) at each step ; CSimpleIntervalSimpleInterval is a concrete implementation of the ConfInterval interface ; CSimpleLikelihoodRatioTestStatTestStatistic class that returns -log(L[null] / L[alt]) where L is the likelihood ; CSPlotThis class calculates sWeights used to create an sPlot ; CTestStatisticTestStatistic is an interface class to provide a facility for construction test statistics distributions to the NeymanConstruction class ; CTestStatSamplerTestStatSampler is an interface class for a tools which produce RooStats SamplingDistributions ; CToyMCImportanceSamplerToyMCImportanceSampler is an extension of the ToyMCSampler for Importance Sampling ; CToyMCPayload; CToyMCSamplerToyMCSampler is an implementation of the TestStatSampler interface ; CToyMCStudyToyMCStudy is an implementation of RooAbsStudy for toy Monte Carlo sampling ; CUniformProposalUniformProposal is a concrete implementation of the ProposalFunction interface for use with a Markov Chain Monte Carlo algorithm ; CUpperLimitMCSModuleThis class allow to compute in the ToyMcStudy framework the ProfileLikelihood upper limit for each toy-MC sample generated ; NROOTNamespace for new ROOT classes and functions ; NDetail; NTDF; CTCustomColumn; CTCustomColumnBase; CTFilter; CTFilterBase; CTLoopManager; CTRange; CTRangeBase; CTBranchProxyBase class for all the proxy object ; CT,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v610/annotated.html:9734,test,test,9734,doc/v610/annotated.html,https://root.cern,https://root.cern/doc/v610/annotated.html,1,['test'],['test']
Testability,on is an interface for all proposal functions that would be used with a Markov Chain Monte Carlo algorithm ; CProposalHelper; CRatioOfProfiledLikelihoodsTestStatTestStatistic that returns the ratio of profiled likelihoods ; CSamplingDistPlotThis class provides simple and straightforward utilities to plot SamplingDistribution objects ; CSamplingDistributionThis class simply holds a sampling distribution of some test statistic ; CSamplingSummary; CSamplingSummaryLookup; CSequentialProposalClass implementing a proposal function that samples the parameter space by moving only in one coordinate (chosen randomly) at each step ; CSimpleIntervalSimpleInterval is a concrete implementation of the ConfInterval interface ; CSimpleLikelihoodRatioTestStatTestStatistic class that returns -log(L[null] / L[alt]) where L is the likelihood ; CSPlotThis class calculates sWeights used to create an sPlot ; CTestStatisticTestStatistic is an interface class to provide a facility for construction test statistics distributions to the NeymanConstruction class ; CTestStatSamplerTestStatSampler is an interface class for a tools which produce RooStats SamplingDistributions ; CToyMCImportanceSamplerToyMCImportanceSampler is an extension of the ToyMCSampler for Importance Sampling ; CToyMCPayload; CToyMCSamplerToyMCSampler is an implementation of the TestStatSampler interface ; CToyMCStudyToyMCStudy is an implementation of RooAbsStudy for toy Monte Carlo sampling ; CUniformProposalUniformProposal is a concrete implementation of the ProposalFunction interface for use with a Markov Chain Monte Carlo algorithm ; CUpperLimitMCSModuleThis class allow to compute in the ToyMcStudy framework the ProfileLikelihood upper limit for each toy-MC sample generated ; NROOTNamespace for new ROOT classes and functions ; NDetail; NTDF; NTCCHelperTypes; CTNothing; CTSlot; CTSlotAndEntry; CTCustomColumn; CTCustomColumnBase; CTFilter; CTFilterBase; CTLoopManager; CTCallback; CTOneTim,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v612/annotated.html:9734,test,test,9734,doc/v612/annotated.html,https://root.cern,https://root.cern/doc/v612/annotated.html,1,['test'],['test']
Testability,"on of TBuffer3D contains two members relating to reference; frames:; fLocalFrame & fLocalMaster. fLocalFrame indicates; if any positions in the buffer (bounding box and tessellation vertexes) are; in local or master (world; frame). fLocalMaster is a standard 4x4 translation matrix (OpenGL; colum major ordering) for placing the object into the 3D master frame.; If fLocalFrame is kFALSE, fLocalMaster should contain an; identity matrix. This is set by default, and can be reset using SetLocalMasterIdentity() function.; Logical & Physical Objects; There are two cases of object addition:. Add this object as a single independent entity in the world reference; frame.; Add; a physical placement (copy) of this logical object (described in local; reference frame). The second case is very typical in geometry packages, GEANT4, where we have; very large number repeated placements of relatively few logical (unique) shapes.; Some viewers (OpenGL only at present) are able to take advantage of this by; identifying unique logical shapes from the fID logical ID member of; TBuffer3D. If repeated addition of the same fID is found, the shape; is cached already - and the costly tessellation does not need to be sent again.; The viewer can; also perform internal GL specific caching with considerable performance gains; in these cases.; For this to work correctly the logical object in must be described in TBuffer3D; in the local reference frame, complete with the local/master translation. The; viewer indicates this through the interface method; PreferLocalFrame(); If this returns kTRUE you can make repeated calls to AddObject(), with TBuffer3D; containing the same fID, and different fLocalMaster placements.; For viewers supporting logical/physical objects, the TBuffer3D content refers; to the properties of logical object, with the fLocalMaster transform and the; fColor and fTransparency attributes, which can be varied for each physical; object.; As a minimum requirement all clients must be cap",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/TBuffer3D.html:5193,log,logical,5193,root/html526/TBuffer3D.html,https://root.cern,https://root.cern/root/html526/TBuffer3D.html,26,['log'],['logical']
Testability,"on of function retrieving the bin up-edge in case of multidimensions. ; ; doubleGetCoordErrorComponent (unsigned int ipoint, unsigned int icoord) const; returns a single coordinate error component of a point. ; ; ErrorTypeGetErrorType () const; retrieve the errortype ; ; const double *GetPoint (unsigned int ipoint, double &value) const; retrieve at the same time a pointer to the coordinate data and the fit value More efficient than calling Coords(i) and Value(i) ; ; const double *GetPoint (unsigned int ipoint, double &value, double &invError) const; retrieve in a single call a pointer to the coordinate data, value and inverse error for the given fit point. ; ; const double *GetPointError (unsigned int ipoint, double &errlow, double &errhigh) const; Get errors on the point (coordinate errors and asymmetric value errors) for the given fit point. ; ; const double *GetPointError (unsigned int ipoint, double &errvalue) const; Retrieve the errors on the point (coordinate and value) for the given fit point It must be called only when the coordinate errors are stored otherwise it will produce an assert. ; ; boolHasBinEdges () const; query if the data store the bin edges instead of the center ; ; boolHaveAsymErrors () const; flag to control if data provides asymmetric errors on the value ; ; boolHaveCoordErrors () const; flag to control if data provides error on the coordinates ; ; voidInitialize (unsigned int newPoints, unsigned int dim=1, ErrorType err=kValueError); Preallocate a data set with given size, dimension and error type. ; ; doubleInvError (unsigned int ipoint) const; Return the inverse of error on the value for the given fit point useful when error in the coordinates are not stored and then this is used directly this as the weight in the least square function. ; ; boolIsWeighted () const; return true if the data set is weighted We cannot compute ourselves because sometimes errors are filled with 1 instead of zero (as in ROOT::",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Fit_1_1BinData.html:6485,assert,assert,6485,doc/master/classROOT_1_1Fit_1_1BinData.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Fit_1_1BinData.html,1,['assert'],['assert']
Testability,"on of objects inside; a static system of coordinates. In case you want to rotate the frame and; want to know the coordinates of objects in the rotated system, you should; apply the inverse rotation to the objects. If you want to transform coordinates; from the rotated frame to the original frame you have to apply the direct; transformation.; A rotation around a specified axis means counterclockwise rotation around; the positive direction of the axis.; . Declaration, Access, Comparisons;  TRotation r; // r initialized as identity;  TRotation m(r); // m = r; There is no direct way to to set the matrix elements - to ensure that; a TRotation object always describes a real rotation. But you can get the; values by the member functions XX()..ZZ() or the (,); operator:;  Double_t xx = r.XX(); // the; same as xx=r(0,0);  xx; = r(0,0);;  if (r==m) {...}// test for equality;  if (r!=m) {..}// test for inequality;  if (r.IsIdentity()) {...} // test for identity; . Rotation around axes; The following matrices desrcibe counterclockwise rotations around coordinate; axes;  | 1 0; 0 |; Rx(a) = | 0 cos(a) -sin(a) |;  | 0 sin(a) cos(a); |;  | cos(a) 0 sin(a); |; Ry(a) = | 0 1; 0 |;  | -sin(a) 0 cos(a) |;  | cos(a) -sin(a) 0 |; Rz(a) = | sin(a) cos(a) 0 |;  | 0; 0 1 |; and are implemented as member functions RotateX(), RotateY(); and RotateZ():;  r.RotateX(TMath::Pi()); // rotation around the x-axis. Rotation around arbitary axis; The member function Rotate() allows to rotate around an arbitary vector; (not neccessary a unit one) and returns the result.;  r.Rotate(TMath::Pi()/3,TVector3(3,4,5));; It is possible to find a unit vector and an angle, which describe the; same rotation as the current one:;  Double_t angle;;  TVector3 axis;;  r.GetAngleAxis(angle,axis);. Rotation of local axes; Member function RotateAxes() adds a rotation of local axes to; the curre",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TRotation.html:1951,test,test,1951,root/html528/TRotation.html,https://root.cern,https://root.cern/root/html528/TRotation.html,3,['test'],['test']
Testability,"on of type double ()(double ).; 13.7.4.3 Wrapping Multi-dimensional Functions; The class ROOT::Math::Functor is used to wrap in a very simple and convenient way multi-dimensional function objects. It can wrap all the following types: * Any C++ callable object implementing double operator()( const double * ). * A free C function of type double ()(const double * ). * A member function with the correct signature like Foo::Eval(const double * ). In this case one pass the object pointer and a pointer to the member function (&Foo::Eval).; The function dimension is required when constructing the functor.; Example of using Functor:; #include ""Math/Functor.h"". class MyFunction {. public:; double operator()(const double *x) const {; return x[0]+x[1];; }. double Eval(const double * x) const { return x[0]+x[1]; }; };. double freeFunction(const double * x ); {; return x[0]+x[1];; }. int main(); {; // test directly calling the function object; MyFunction myf;. // test from a free function pointer; ROOT::Math::Functor f1(&freeFunction,2);. // test from function object; ROOT::Math::Functor f2(myf,2);. // test from a member function; ROOT::Math::Functor f3(&myf,&MyFunction::Eval,2);. double x[] = {1,2};. cout << f1(x) << endl;; cout << f2(x) << endl;; cout << f3(x) << endl;. return 0;; }; 13.7.4.4 Wrapping Multi-dimensional Gradient Functions; The class ROOT::Math::GradFunctor is used to wrap in a very C++ callable object to make gradient functions. It can be constructed in three different way: * From an object implementing both double operator()( const double * ) for the function evaluation and double Derivative(const double *, int icoord) for the partial derivatives. * From an object implementing any member function like Foo::XXX(const double *) for the function evaluation and any member function like Foo::XXX(const double *, int icoord) for the partial derivatives. * From an function object implementing double operator()( const double * ) for the function evaluation and another f",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:697207,test,test,697207,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['test'],['test']
Testability,"on of weighted and unweighted histograms and two weighted; histograms [2] as well as usual Pearson's test for; comparison two usual (unweighted) histograms. Overview:. Comparison of two histograms expect hypotheses that two histograms; represent identical distributions. To make a decision p-value should; be calculated. The hypotheses of identity is rejected if the p-value is; lower then some significance level. Traditionally significance levels; 0.1, 0.05 and 0.01 are used. The comparison procedure should include an; analysis of the residuals which is often helpful in identifying the; bins of histograms responsible for a significant overall value.; Residuals are the difference between bin contents and expected bin; contents. Most convenient for analysis are the normalized residuals. If; hypotheses of identity are valid then normalized residuals are; approximately independent and identically distributed random variables; having N(0,1) distribution. Analysis of residuals expect test of above; mentioned properties of residuals. Notice that indirectly the analysis; of residuals increase the power of test. Methods of comparison:. test for comparison two (unweighted) histograms:; Let us consider two histograms with the same binning and the number; of bins equal to r. Let us denote the number of events in the ith bin; in the first histogram as ni and as mi in the second one. The total; number of events in the first histogram is equal to:. and. in the second histogram. The hypothesis of identity (homogeneity) [3]; is that the two histograms represent random values with identical; distributions. It is equivalent that there exist r constants p1,...,pr,; such that. and the probability of belonging to the ith bin for some measured value; in both experiments is equal to pi. The number of events in the ith; bin is a random variable with a distribution approximated by a Poisson; probability distribution. for the first histogram and with distribution. for the second histogram. If th",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TH1.html:45915,test,test,45915,root/html528/TH1.html,https://root.cern,https://root.cern/root/html528/TH1.html,6,['test'],['test']
Testability,"on source1 != source2; 2840 ; 2841template <class Element>; 2842TMatrixT<Element> TMatrixTAutoloadOps::operator!=(const TMatrixT<Element> &source1, const TMatrixT<Element> &source2); 2843{; 2844 TMatrixT<Element> target;; 2845 ; 2846 if (gMatrixCheck && !AreCompatible(source1, source2)) {; 2847 Error(""operator!=(const TMatrixT&,const TMatrixT&)"", ""matrices not compatible"");; 2848 return target;; 2849 }; 2850 ; 2851 target.ResizeTo(source1);; 2852 ; 2853 const Element *sp1 = source1.GetMatrixArray();; 2854 const Element *sp2 = source2.GetMatrixArray();; 2855 Element *tp = target.GetMatrixArray();; 2856 const Element *const tp_last = tp + target.GetNoElements();; 2857 while (tp != tp_last) {; 2858 *tp++ = (*sp1) != (*sp2);; 2859 sp1++;; 2860 sp2++;; 2861 }; 2862 ; 2863 return target;; 2864}; 2865 ; 2866////////////////////////////////////////////////////////////////////////////////; 2867/// logical operation source1 != source2; 2868 ; 2869template <class Element>; 2870TMatrixT<Element> TMatrixTAutoloadOps::operator!=(const TMatrixT<Element> &source1, const TMatrixTSym<Element> &source2); 2871{; 2872 TMatrixT<Element> target;; 2873 ; 2874 if (gMatrixCheck && !AreCompatible(source1, source2)) {; 2875 Error(""operator!=(const TMatrixT&,const TMatrixTSym&)"", ""matrices not compatible"");; 2876 return target;; 2877 }; 2878 ; 2879 target.ResizeTo(source1);; 2880 ; 2881 const Element *sp1 = source1.GetMatrixArray();; 2882 const Element *sp2 = source2.GetMatrixArray();; 2883 Element *tp = target.GetMatrixArray();; 2884 const Element *const tp_last = tp + target.GetNoElements();; 2885 while (tp != tp_last) {; 2886 *tp++ = (*sp1) != (*sp2);; 2887 sp1++;; 2888 sp2++;; 2889 }; 2890 ; 2891 return target;; 2892}; 2893 ; 2894////////////////////////////////////////////////////////////////////////////////; 2895/// logical operation source1 != source2; 2896 ; 2897template <class Element>; 2898TMatrixT<Element> TMatrixTAutoloadOps::operator!=(const TMatrixTSym<Element> &source1, const TMat",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMatrixT_8cxx_source.html:100315,log,logical,100315,doc/master/TMatrixT_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TMatrixT_8cxx_source.html,1,['log'],['logical']
Testability,"on source1 <= source2; 2712 ; 2713template <class Element>; 2714TMatrixT<Element> TMatrixTAutoloadOps::operator<=(const TMatrixT<Element> &source1, const TMatrixT<Element> &source2); 2715{; 2716 TMatrixT<Element> target;; 2717 ; 2718 if (gMatrixCheck && !AreCompatible(source1, source2)) {; 2719 Error(""operator<=(const TMatrixT&,const TMatrixT&)"", ""matrices not compatible"");; 2720 return target;; 2721 }; 2722 ; 2723 target.ResizeTo(source1);; 2724 ; 2725 const Element *sp1 = source1.GetMatrixArray();; 2726 const Element *sp2 = source2.GetMatrixArray();; 2727 Element *tp = target.GetMatrixArray();; 2728 const Element *const tp_last = tp + target.GetNoElements();; 2729 while (tp < tp_last) {; 2730 *tp++ = (*sp1) <= (*sp2);; 2731 sp1++;; 2732 sp2++;; 2733 }; 2734 ; 2735 return target;; 2736}; 2737 ; 2738////////////////////////////////////////////////////////////////////////////////; 2739/// logical operation source1 <= source2; 2740 ; 2741template <class Element>; 2742TMatrixT<Element> TMatrixTAutoloadOps::operator<=(const TMatrixT<Element> &source1, const TMatrixTSym<Element> &source2); 2743{; 2744 TMatrixT<Element> target;; 2745 ; 2746 if (gMatrixCheck && !AreCompatible(source1, source2)) {; 2747 Error(""operator<=(const TMatrixT&,const TMatrixTSym&)"", ""matrices not compatible"");; 2748 return target;; 2749 }; 2750 ; 2751 target.ResizeTo(source1);; 2752 ; 2753 const Element *sp1 = source1.GetMatrixArray();; 2754 const Element *sp2 = source2.GetMatrixArray();; 2755 Element *tp = target.GetMatrixArray();; 2756 const Element *const tp_last = tp + target.GetNoElements();; 2757 while (tp < tp_last) {; 2758 *tp++ = (*sp1) <= (*sp2);; 2759 sp1++;; 2760 sp2++;; 2761 }; 2762 ; 2763 return target;; 2764}; 2765 ; 2766////////////////////////////////////////////////////////////////////////////////; 2767/// logical operation source1 <= source2; 2768 ; 2769template <class Element>; 2770TMatrixT<Element> TMatrixTAutoloadOps::operator<=(const TMatrixTSym<Element> &source1, const TMatr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMatrixT_8cxx_source.html:95970,log,logical,95970,doc/master/TMatrixT_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TMatrixT_8cxx_source.html,1,['log'],['logical']
Testability,"on source1 >= source2; 2647 ; 2648template <class Element>; 2649TMatrixT<Element> TMatrixTAutoloadOps::operator>=(const TMatrixT<Element> &source1, const TMatrixT<Element> &source2); 2650{; 2651 TMatrixT<Element> target;; 2652 ; 2653 if (gMatrixCheck && !AreCompatible(source1, source2)) {; 2654 Error(""operator>=(const TMatrixT&,const TMatrixT&)"", ""matrices not compatible"");; 2655 return target;; 2656 }; 2657 ; 2658 target.ResizeTo(source1);; 2659 ; 2660 const Element *sp1 = source1.GetMatrixArray();; 2661 const Element *sp2 = source2.GetMatrixArray();; 2662 Element *tp = target.GetMatrixArray();; 2663 const Element *const tp_last = tp + target.GetNoElements();; 2664 while (tp < tp_last) {; 2665 *tp++ = (*sp1) >= (*sp2);; 2666 sp1++;; 2667 sp2++;; 2668 }; 2669 ; 2670 return target;; 2671}; 2672 ; 2673////////////////////////////////////////////////////////////////////////////////; 2674/// logical operation source1 >= source2; 2675 ; 2676template <class Element>; 2677TMatrixT<Element> TMatrixTAutoloadOps::operator>=(const TMatrixT<Element> &source1, const TMatrixTSym<Element> &source2); 2678{; 2679 TMatrixT<Element> target;; 2680 ; 2681 if (gMatrixCheck && !AreCompatible(source1, source2)) {; 2682 Error(""operator>=(const TMatrixT&,const TMatrixTSym&)"", ""matrices not compatible"");; 2683 return target;; 2684 }; 2685 ; 2686 target.ResizeTo(source1);; 2687 ; 2688 const Element *sp1 = source1.GetMatrixArray();; 2689 const Element *sp2 = source2.GetMatrixArray();; 2690 Element *tp = target.GetMatrixArray();; 2691 const Element *const tp_last = tp + target.GetNoElements();; 2692 while (tp < tp_last) {; 2693 *tp++ = (*sp1) >= (*sp2);; 2694 sp1++;; 2695 sp2++;; 2696 }; 2697 ; 2698 return target;; 2699}; 2700 ; 2701////////////////////////////////////////////////////////////////////////////////; 2702/// logical operation source1 >= source2; 2703 ; 2704template <class Element>; 2705TMatrixT<Element> TMatrixTAutoloadOps::operator>=(const TMatrixTSym<Element> &source1, const TMatr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMatrixT_8cxx_source.html:93774,log,logical,93774,doc/master/TMatrixT_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TMatrixT_8cxx_source.html,1,['log'],['logical']
Testability,"on the overall (multiplicative) normalization of \(\mbox{FCN}\), in the sense that if the value of \(\mbox{FCN}\) is everywhere multiplied by a constant \(\beta\), then the errors will be decreased by a factor \(\sqrt{\beta}\). Additive constants do not change the parameter errors, but may imply a different goodness-of-fit confidence level.; Assuming that the user knows what the normalization of his \(\mbox{FCN}\) means, and also that he is interested in parameter errors, the user can change the error definition which allows him to define what he means by one error, in terms of the change in the \(\mbox{FCN}\) value which should be caused by changing one parameter by one error. If the \(\mbox{FCN}\) is the usual chisquare function (defined below) and if the user wants the usual one-standard-deviation errors, then the error definition (return value of the FCNBase::up() method, see [howto:errordef]) should be \(1.0\). If the \(\mbox{FCN}\) is a negative-log-likelihood function, then the one-standard-deviation value for FCNBase::up() to return is \(0.5\). If the \(\mbox{FCN}\) is a chisquare, but the user wants two-standard-deviation errors, then FCNBase::up() should return \(= 4.0\), etc.; Note that in the usual case where M is being used to perform a fit to some experimental data, the parameter errors will be proportional to the uncertainty in the data, and therefore meaningful parameter errors cannot be obtained unless the measurement errors of the data are known. In the common case of a least-squares fit, \(\mbox{FCN}\) is usually defined as a chisquare:; \[\chi^2 (\alpha) = \sum_{i=1}^{n} (\frac{f(x_i,\alpha) - m_i)^2}{\sigma_i^2}\]; where \(\alpha\) is the vector of free parameters being fitted, and the \(\sigma_i\) are the uncertainties in the individual measurements \(m_i\). If these uncertainties are not known, and are simply left out of the calculation, then the fit may still have meaning, but not the quantitative values of the resulting parameter errors. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/guides/minuit2/Minuit2.html:19493,log,log-likelihood,19493,root/html534/guides/minuit2/Minuit2.html,https://root.cern,https://root.cern/root/html534/guides/minuit2/Minuit2.html,1,['log'],['log-likelihood']
Testability,"on(). void TSessionViewer::ResetSession ; (; ). Reset Proof session. ; Definition at line 5159 of file TSessionViewer.cxx. SetBusy(). void TSessionViewer::SetBusy ; (; Bool_t; busy = kTRUE). inline . Definition at line 619 of file TSessionViewer.h. SetChangePic(). void TSessionViewer::SetChangePic ; (; Bool_t; change). inline . Definition at line 620 of file TSessionViewer.h. SetLogWindow(). void TSessionViewer::SetLogWindow ; (; TSessionLogView *; log). inline . Definition at line 621 of file TSessionViewer.h. ShowEnabledPackages(). void TSessionViewer::ShowEnabledPackages ; (; ). Query list of enabled packages from proof and display it into a new text window. ; Definition at line 5372 of file TSessionViewer.cxx. ShowInfo(). void TSessionViewer::ShowInfo ; (; const char *; txt). Display text in status bar. ; Definition at line 5444 of file TSessionViewer.cxx. ShowLog(). void TSessionViewer::ShowLog ; (; const char *; queryref). Display the content of the temporary log file for queryref into a new text window. ; Definition at line 5410 of file TSessionViewer.cxx. ShowPackages(). void TSessionViewer::ShowPackages ; (; ). Query the list of uploaded packages from proof and display it into a new text window. ; Definition at line 5287 of file TSessionViewer.cxx. ShowStatus(). void TSessionViewer::ShowStatus ; (; ). Retrieve and display Proof status. ; Definition at line 5454 of file TSessionViewer.cxx. StartupMessage(). void TSessionViewer::StartupMessage ; (; char *; msg, . Bool_t; stat, . Int_t; curr, . Int_t; total. ). Handle startup message (connection progress) coming from Proof session. ; Definition at line 5490 of file TSessionViewer.cxx. StartViewer(). void TSessionViewer::StartViewer ; (; ). Start TreeViewer from selected TChain. ; Definition at line 5265 of file TSessionViewer.cxx. Streamer(). void TSessionViewer::Streamer ; (; TBuffer &; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from TGMainFrame",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSessionViewer.html:49165,log,log,49165,doc/master/classTSessionViewer.html,https://root.cern,https://root.cern/doc/master/classTSessionViewer.html,1,['log'],['log']
Testability,"on(const RooArgSet& iset); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooCmdArg arg1, const RooCmdArg arg2 = RooCmdArg::none(), const RooCmdArg arg3 = RooCmdArg::none(), const RooCmdArg arg4 = RooCmdArg::none(), const RooCmdArg arg5 = RooCmdArg::none(), const RooCmdArg arg6 = RooCmdArg::none(), const RooCmdArg arg7 = RooCmdArg::none(), const RooCmdArg arg8 = RooCmdArg::none()); RooAbsReal*RooAbsPdf::createScanCdf(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); RooAbsReal*RooAbsReal::createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); Int_tdeclareBasis(const char* expression, const RooArgList& params); virtual Double_tRooAbsReal::defaultErrorLevel() const; static RooNumGenConfig*RooAbsPdf::defaultGeneratorConfig(); static RooNumIntConfig*RooAbsReal::defaultIntegratorConfig(); virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; RooDerivative*RooAbsReal::derivative(RooRealVar& obs, Int_t order = 1, Double_t eps = 0.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAbsAnaConvPdf.html:9974,test,testArg,9974,root/html526/RooAbsAnaConvPdf.html,https://root.cern,https://root.cern/root/html526/RooAbsAnaConvPdf.html,4,['test'],['testArg']
Testability,"on, ; 359 Vol 82, No. 399, pp 918-924.; 360 Code from kSamples package from R (author F. Scholtz); 361 ; 362 This function uses the upper T_m quantiles as obtained via simulation of; 363 the Anderson-Darling test statistics (Nsim = 2*10^6) with sample sizes n=500; 364 for each sample, and after standardization, in order to emulate the Table 1 ; 365 values given in the above reference. However, here we estimate p-quantiles; 366 for p = .00001,.00005,.0001,.0005,.001,.005,.01,.025,.05,.075,; 367 .1,.2,.3,.4,.5,.6,.7,.8,.9,.925,.95,.975,.99,.9925,.995,.9975,.999,; 368 .99925,.9995,.99975,.9999,.999925,.99995,.999975,.99999; 369 First the appropriate p-quantiles are determined from those simulated; 370 for ms = 1,2,3,4,6,8,10, Inf, interpolating to the given value of m. ; 371 Since we use only m=2 we avoid this interpolation. ; 372 ; 373 Next linear inetrpolation to find the observed p value given the observed test statistic value. ; 374 We use interpolation in the test statistic -> log((1-p)/p) domain; 375 and we extrapolatelinearly) beyond p = .00001 and .99999.; 376 */; 377 ; 378 // sample values ; 379 //double ms[] = { 1, 2, 3, 4, 6, 8, 10, TMath::Infinity() };; 380 //int ns = ms.size();; 381 const int ns = 8;; 382 double ts[ ] = { -1.1954, -1.5806, -1.8172, ; 383 -2.0032, -2.2526, -2.4204, -2.5283, -4.2649, -1.1786, -1.5394, ; 384 -1.7728, -1.9426, -2.1685, -2.3288, -2.4374, -3.8906, -1.166, ; 385 -1.5193, -1.7462, -1.9067, -2.126, -2.2818, -2.3926, -3.719, ; 386 -1.1407, -1.4659, -1.671, -1.8105, -2.0048, -2.1356, -2.2348, ; 387 -3.2905, -1.1253, -1.4371, -1.6314, -1.7619, -1.9396, -2.0637, ; 388 -2.1521, -3.0902, -1.0777, -1.3503, -1.5102, -1.6177, -1.761, ; 389 -1.8537, -1.9178, -2.5758, -1.0489, -1.2984, -1.4415, -1.5355, ; 390 -1.6625, -1.738, -1.7936, -2.3263, -0.9978, -1.2098, -1.3251, ; 391 -1.4007, -1.4977, -1.5555, -1.5941, -1.96, -0.9417, -1.1187, ; 392 -1.209, -1.2671, -1.3382, -1.379, -1.405, -1.6449, -0.8981, -1.0491, ; 393 -1.1235, -1.1692, -1.2249, ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/GoFTest_8cxx_source.html:13197,test,test,13197,doc/master/GoFTest_8cxx_source.html,https://root.cern,https://root.cern/doc/master/GoFTest_8cxx_source.html,2,"['log', 'test']","['log', 'test']"
Testability,"on, Gaussianisation, Normalisation, each for the given class of events ('AllClasses' denotes all events of all classes, if no class indication is given, 'All' is assumed)""]; : H: ""False"" [Print method-specific help message]; : Layout: ""TANH|100,TANH|50,TANH|10,LINEAR"" [Layout of the network.]; : ErrorStrategy: ""CROSSENTROPY"" [Loss function: Mean squared error (regression) or cross entropy (binary classification).]; : WeightInitialization: ""XAVIERUNIFORM"" [Weight initialization strategy]; : Architecture: ""GPU"" [Which architecture to perform the training on.]; : TrainingStrategy: ""Optimizer=ADAM,LearningRate=1e-3,TestRepetitions=1,ConvergenceSteps=10,BatchSize=100,MaxEpochs=20"" [Defines the training strategies.]; : - Default:; : VerbosityLevel: ""Default"" [Verbosity level]; : CreateMVAPdfs: ""False"" [Create PDFs for classifier outputs (signal and background)]; : IgnoreNegWeightsInTraining: ""False"" [Events with negative weights are ignored in the training (but are included for testing and performance evaluation)]; : InputLayout: ""0|0|0"" [The Layout of the input]; : BatchLayout: ""0|0|0"" [The Layout of the batch]; : RandomSeed: ""0"" [Random seed used for weight initialization and batch shuffling]; : ValidationSize: ""20%"" [Part of the training data to use for validation. Specify as 0.2 or 20% to use a fifth of the data set as validation set. Specify as 100 to use exactly 100 events. (Default: 20%)]; DL_CPU : [dataset] : Create Transformation ""N"" with events from all classes.; : ; : Transformation, Variable selection : ; : Input : variable 'var1' <---> Output : variable 'var1'; : Input : variable 'var2' <---> Output : variable 'var2'; : Input : variable 'var3' <---> Output : variable 'var3'; : Input : variable 'var4' <---> Output : variable 'var4'; [31m<ERROR> : CUDA backend not enabled. Please make sure you have CUDA installed and it was successfully detected by CMAKE by using -Dtmva-gpu=On [0m; : Will now use instead the CPU architecture !; : Will now use the CPU architec",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVAMulticlass_8C.html:5830,test,testing,5830,doc/master/TMVAMulticlass_8C.html,https://root.cern,https://root.cern/doc/master/TMVAMulticlass_8C.html,1,['test'],['testing']
Testability,"on, const char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TStringfCurDirname of current directory; TList*fKeyslist of Hbook keys (Ids) on disk; TList*fListlist of objects in memory; Int_tfLreclRecord length in Hbook machine words; Int_tfLunFortran logical unit for this file; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; static Int_t*fgLuns; static Bool_tfgPawInit. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; THbookFile(); the constructor. THbookFile(const char* fname, Int_t lrecl = 1024); Constructor for an HBook file object. ~THbookFile(); destructor. void Browse(TBrowser* b); to be implemented. Bool_t cd(const char* dirname = """"); change directory to dirname. void Close(Option_t* option = """"); Close the Hbook file. void DeleteID(Int_t id); remove id from file and memory. TObject * FindObject(const char* name) const; return object with name in fList in memory. TObject * FindObject(const TObject* obj) const; return object with pointer obj in fList in memory. TObject * Get(Int_t id); import Hbook object with identifier idd in memory. Int_t GetEntry(Int_t entry, Int_t id, Int_t atype, Float_t* x); Read in memory all columns of entry num",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/THbookFile.html:7404,log,logical,7404,root/html602/THbookFile.html,https://root.cern,https://root.cern/root/html602/THbookFile.html,2,['log'],['logical']
Testability,"on, using the Kolmogorov test.; That is, it is used to compare two experimental distributions of unbinned data. Input:; a,b: One-dimensional arrays of length na, nb, respectively.; The elements of a and b must be given in ascending order.; option is a character string to specify options; ""D"" Put out a line of ""Debug"" printout; ""M"" Return the Maximum Kolmogorov distance instead of prob. Output:; The returned value prob is a calculated confidence level which gives a; statistical test for compatibility of a and b.; Values of prob close to zero are taken as indicating a small probability; of compatibility. For two point sets drawn randomly from the same parent; distribution, the value of prob should be uniformly distributed between; zero and one.; in case of error the function return -1; If the 2 sets have a different number of points, the minimum of; the two sets is used. Method:; The Kolmogorov test is used. The test statistic is the maximum deviation; between the two integrated distribution functions, multiplied by the; normalizing factor (rdmax*sqrt(na*nb/(na+nb)). Code adapted by Rene Brun from CERNLIB routine TKOLMO (Fred James); (W.T. Eadie, D. Drijard, F.E. James, M. Roos and B. Sadoulet,; Statistical Methods in Experimental Physics, (North-Holland,; Amsterdam 1971) 269-271). Method Improvement by Jason A Detwiler (JADetwiler@lbl.gov). The nuts-and-bolts of the TMath::KolmogorovTest() algorithm is a for-loop; over the two sorted arrays a and b representing empirical distribution; functions. The for-loop handles 3 cases: when the next points to be; evaluated satisfy a>b, a<b, or a=b:. for (Int_t i=0;i<na+nb;i++) {; if (a[ia-1] < b[ib-1]) {; rdiff -= sa;; ia++;; if (ia > na) {ok = kTRUE; break;}; } else if (a[ia-1] > b[ib-1]) {; rdiff += sb;; ib++;; if (ib > nb) {ok = kTRUE; break;}; } else {; rdiff += sb - sa;; ia++;; ib++;; if (ia > na) {ok = kTRUE; break;}; if (ib > nb) {ok = kTRUE; break;}; }; rdmax = TMath::Max(rdmax,TMath::Abs(rdiff));; }. For the last case,",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMath.html:18345,test,test,18345,root/html528/TMath.html,https://root.cern,https://root.cern/root/html528/TMath.html,6,['test'],['test']
Testability,"on. ; That is, when a certain mouse button is hit while certain modifier's (Shift, Control, Meta, Alt) are active then the mouse will be grabbed for window id. When grab is false, ungrab the mouse button for this button and modifier. ; Reimplemented in TGWin32, TGWin32VirtualXProxy, TGX11, and TGCocoa.; Definition at line 1684 of file TVirtualX.cxx. GrabKey(). void TVirtualX::GrabKey ; (; Window_t; id, . Int_t; keycode, . UInt_t; modifier, . Bool_t; grab = kTRUE. ). virtual . Establishes a passive grab on the keyboard. ; In the future, the keyboard is actively grabbed, the last-keyboard-grab time is set to the time at which the key was pressed (as transmitted in the KeyPress event), and the KeyPress event is reported if all of the following conditions are true:. the keyboard is not grabbed and the specified key (which can itself be a modifier key) is logically pressed when the specified modifier keys are logically down, and no other modifier keys are logically down;; either the grab window ""id"" is an ancestor of (or is) the focus window, or ""id"" is a descendant of the focus window and contains the pointer;; a passive grab on the same key combination does not exist on any ancestor of grab_window. Parameters. [in]idwindow id ; [in]keycodespecifies the KeyCode or AnyKey ; [in]modifierspecifies the set of keymasks or AnyModifier; the mask is the bitwise inclusive OR of the valid keymask bits ; [in]graba switch between grab/ungrab key grab = kTRUE grab the key and modifier grab = kFALSE ungrab the key and modifier . Reimplemented in TGWin32, TGWin32VirtualXProxy, TGX11, and TGCocoa.; Definition at line 1673 of file TVirtualX.cxx. GrabPointer(). void TVirtualX::GrabPointer ; (; Window_t; id, . UInt_t; evmask, . Window_t; confine, . Cursor_t; cursor, . Bool_t; grab = kTRUE, . Bool_t; owner_events = kTRUE. ). virtual . Establishes an active pointer grab. ; While an active pointer grab is in effect, further pointer events are only reported to the grabbing cli",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTVirtualX.html:94618,log,logically,94618,doc/master/classTVirtualX.html,https://root.cern,https://root.cern/doc/master/classTVirtualX.html,3,['log'],['logically']
Testability,"on: %s"",fname); return -1; }; 3922 return Fit(f1,option,goption,xxmin,xxmax);; 3923 }; 3924}; 3925 ; 3926////////////////////////////////////////////////////////////////////////////////; 3927/// Fit histogram with the function pointer f1.; 3928///; 3929/// \param[in] f1 pointer to the function object; 3930/// \param[in] option string defining the fit options (see table below).; 3931/// \param[in] goption specify a list of graphics options. See TH1::Draw for a complete list of these options.; 3932/// \param[in] xxmin lower fitting range; 3933/// \param[in] xxmax upper fitting range; 3934/// \return A smart pointer to the TFitResult class; 3935///; 3936/// \anchor HFitOpt; 3937/// ### Histogram Fitting Options; 3938///; 3939/// Here is the full list of fit options that can be given in the parameter `option`.; 3940/// Several options can be used together by concatanating the strings without the need of any delimiters.; 3941///; 3942/// option | description; 3943/// -------|------------; 3944/// ""L"" | Uses a log likelihood method (default is chi-square method). To be used when the histogram represents counts.; 3945/// ""WL"" | Weighted log likelihood method. To be used when the histogram has been filled with weights different than 1. This is needed for getting correct parameter uncertainties for weighted fits.; 3946/// ""P"" | Uses Pearson chi-square method. Uses expected errors instead of the observed one (default case). The expected error is instead estimated from the square-root of the bin function value.; 3947/// ""MULTI"" | Uses Loglikelihood method based on multi-nomial distribution. In this case the function must be normalized and one fits only the function shape.; 3948/// ""W"" | Fit using the chi-square method and ignoring the bin uncertainties and skip empty bins.; 3949/// ""WW"" | Fit using the chi-square method and ignoring the bin uncertainties and include the empty bins.; 3950/// ""I"" | Uses the integral of function in the bin instead of the default bin center value.;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TH1_8cxx_source.html:156254,log,log,156254,doc/master/TH1_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html,1,['log'],['log']
Testability,"on; RooArgSet*RooAbsOptTestStatistic::_funcCloneSetSet owning all components of internal clone of input function; RooChi2Var::FuncMode_funcModeFunction, P.d.f. or extended p.d.f?; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; static Int_tRooPrintable::_nameLength; RooArgSet*RooAbsOptTestStatistic::_normSetPointer to set with observables used for normalization ; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; Bool_tRooAbsOptTestStatistic::_ownDataDo we own the dataset; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; RooSetProxyRooAbsTestStatistic::_paramSetParameters of the test statistic (=parameters of the input function); Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooArgSet*RooAbsOptTestStatistic::_projDepsSet of projected observable; const RooArgSet*RooAbsTestStatistic::_projDepsPointer to set with projected observables; TListRooAbsArg::_proxyListlist of proxies; stringRooAbsTestStatistic::_rangeNameName of range in which to calculate test statistic; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; Int_tRooAbsTestStatistic::_simCountTotal number of component p.d.f.s in RooSimultaneous (if any); RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; Bool_tRooAbsTestStatistic::_split",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooChi2Var.html:35190,test,test,35190,root/html526/RooChi2Var.html,https://root.cern,https://root.cern/root/html526/RooChi2Var.html,2,['test'],['test']
Testability,"on; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel; static TGFrame::(anonymous)TGFrame::kDeleteWindowCalled. private:. TGTextButton*fBtnAbortabort process button; TGTextButton*fBtnFinalizefinalize query button; TGTextButton*fBtnRetrieveretrieve query button; TGTextButton*fBtnSavesave query button; TGTextButton*fBtnShowLogshow log button; TGTextButton*fBtnStopstop process button; TGTextButton*fBtnSubmitsubmit query button; TQueryDescription*fDescquery description; TRootEmbeddedCanvas*fECanvasnode statistics embeded canvas; Long64_tfEntriesnumber of events/entries to process; TGCompositeFrame*fFAthree tabs element; TGCompositeFrame*fFBthree tabs element; TGCompositeFrame*fFCthree tabs element; TEditQueryFrame*fFDfourth tab element (edit query frame); Int_tfFilesnumber of files processed; Long64_tfFirstfirst event/entry to process; TGTextView*fInfoTextViewsummary on current query; TGLabel*fLabInfosinfos on current process; TGLabel*fLabStatusactual process status; Bool_tfModifiedkTRUE if settings have changed; Long64_tfPrevProcessedused for progress bar; Long64_tfPrevTotalused for progress bar; TGLabel*fRaterate of process in events/sec; TCanvas*fStatsCanvasnode statistics canvas; TSessionQueryFrame::EQueryStatusfStatusstatus of actual query; TGTab*fTabmain tab frame; TGLabel*fTotaltotal progress info; TSessionViewer*fViewerpointer on main viewer; TGHProgressBar*frmProgcurrent process progress bar; static TSessionQueryFrame::EQueryStatuskAborted; static TSessionQueryFrame::EQueryStatuskDone; static TSessionQueryFrame::EQueryStatuskRunning; static TSessionQueryFrame::EQueryStatuskStopped. Class Charts. Inheritance Chart:. TObject. ; TGObject. ; TGWindow. TQObject. ; TGFrame. ; TGCompositeFrame. ; TSessionQueryFrame. Function documentation; TSessionQueryFrame(TGWindow* parent, Int_t w, Int_t h); Constructor. ~TSessionQueryFrame(); De",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TSessionQueryFrame.html:20692,log,log,20692,root/html602/TSessionQueryFrame.html,https://root.cern,https://root.cern/root/html602/TSessionQueryFrame.html,2,['log'],['log']
Testability,"onCategory_LikelihoodCat.weights.xml; : Recreating sub-classifiers from XML-file ; <HEADER> DataSetInfo : [Category_Likelihood_1_dsi] : Added class ""Signal""; <HEADER> DataSetInfo : [Category_Likelihood_1_dsi] : Added class ""Background""; <HEADER> DataSetInfo : [Category_Likelihood_2_dsi] : Added class ""Signal""; <HEADER> DataSetInfo : [Category_Likelihood_2_dsi] : Added class ""Background""; <HEADER> Factory : Test all methods; <HEADER> Factory : Test method: Fisher for Classification performance; : ; <HEADER> Fisher : [dataset] : Evaluation of Fisher on testing sample (10000 events); : Elapsed time for evaluation of 10000 events: 0.00318 sec ; <HEADER> Factory : Test method: Likelihood for Classification performance; : ; <HEADER> Likelihood : [dataset] : Evaluation of Likelihood on testing sample (10000 events); : Elapsed time for evaluation of 10000 events: 0.00959 sec ; <HEADER> Factory : Test method: FisherCat for Classification performance; : ; <HEADER> Category_Fisher_1 : [Category_Fisher_1_dsi] : Evaluation of Category_Fisher_1 on testing sample (10000 events); : Elapsed time for evaluation of 10000 events: 0.00192 sec ; <HEADER> Category_Fisher_2 : [Category_Fisher_2_dsi] : Evaluation of Category_Fisher_2 on testing sample (10000 events); : Elapsed time for evaluation of 10000 events: 0.00196 sec ; <HEADER> Factory : Test method: LikelihoodCat for Classification performance; : ; <HEADER> Category_Likelihood_1 : [Category_Likelihood_1_dsi] : Evaluation of Category_Likelihood_1 on testing sample (10000 events); : Elapsed time for evaluation of 10000 events: 0.00948 sec ; <HEADER> Category_Likelihood_2 : [Category_Likelihood_2_dsi] : Evaluation of Category_Likelihood_2 on testing sample (10000 events); : Elapsed time for evaluation of 10000 events: 0.00932 sec ; <HEADER> Factory : Evaluate all methods; <HEADER> Factory : Evaluate classifier: Fisher; : ; <HEADER> Fisher : [dataset] : Loop over test events and fill histograms with classifier response...; : ; <HEADER>",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVAClassificationCategory_8C.html:23224,test,testing,23224,doc/master/TMVAClassificationCategory_8C.html,https://root.cern,https://root.cern/doc/master/TMVAClassificationCategory_8C.html,1,['test'],['testing']
Testability,onWrapper.h; GSLMultiRootSolver.h; GSLNLSMinimizer.cxx; GSLQRngWrapper.h; GSLQuasiRandom.cxx; GSLRndmEngines.cxx; GSLRngROOTWrapper.h; GSLRngWrapper.h; GSLRootFdFSolver.h; GSLRootFinder.cxx; GSLRootFinderDeriv.cxx; GSLRootFSolver.h; GSLRootHelper.cxx; GSLSimAnMinimizer.cxx; GSLSimAnnealing.cxx; Interpolator.cxx; KelvinFunctions.cxx; MCParameters.cxx; MultiNumGradFunction.cxx; PdfFuncMathMore.cxx; Polynomial.cxx; QuantFuncMathMore.cxx; RootFinderAlgorithms.cxx; SpecFuncMathMore.cxx; Vavilov.cxx; VavilovAccurate.cxx; VavilovAccurateCdf.cxx; VavilovAccuratePdf.cxx; VavilovAccurateQuantile.cxx; VavilovFast.cxx; zsolve_cubic.cxx; test; piRandom.C; pirndm.C; simanTSP.cxx; testChebyshev.cxx; testDerivation.cxx; testFunctor.cxx; testGSLIntegration.cxx; testGSLRootFinder.cxx; testInterpolation.cxx; testMCIntegration.cxx; testMinimization1D.cxx; testMultiRootFinder.cxx; testPermute.cxx; testQuasiRandom.cxx; testRandom.cxx; testRandomDist.cxx; testSpecFunc.cxx; testStatFunc.cxx; testVavilov.cxx; UnuRanDist.h; VavilovTest.cxx; VavilovTest.h; matrix; inc; LinkDef.h; TDecompBase.h; TDecompBK.h; TDecompChol.h; TDecompLU.h; TDecompQRH.h; TDecompSparse.h; TDecompSVD.h; TMatrix.h; TMatrixD.h; TMatrixDBase.h; TMatrixDBasefwd.h; TMatrixDEigen.h; TMatrixDfwd.h; TMatrixDLazy.h; TMatrixDSparse.h; TMatrixDSparsefwd.h; TMatrixDSym.h; TMatrixDSymEigen.h; TMatrixDSymfwd.h; TMatrixDUtils.h; TMatrixDUtilsfwd.h; TMatrixF.h; TMatrixFBase.h; TMatrixFBasefwd.h; TMatrixFfwd.h; TMatrixFLazy.h; TMatrixFSparse.h; TMatrixFSparsefwd.h; TMatrixFSym.h; TMatrixFSymfwd.h; TMatrixFUtils.h; TMatrixFUtilsfwd.h; TMatrixT.h; TMatrixTBase.h; TMatrixTCramerInv.h; TMatrixTLazy.h; TMatrixTSparse.h; TMatrixTSym.h; TMatrixTSymCramerInv.h; TMatrixTUtils.h; TVector.h; TVectorD.h; TVectorDfwd.h; TVectorF.h; TVectorFfwd.h; TVectorfwd.h; TVectorT.h; src; TDecompBase.cxx; TDecompBK.cxx; TDecompChol.cxx; TDecompL,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v608/files.html:49433,test,testSpecFunc,49433,doc/v608/files.html,https://root.cern,https://root.cern/doc/v608/files.html,1,['test'],['testSpecFunc']
Testability,onWrapper.h; GSLMultiRootSolver.h; GSLNLSMinimizer.cxx; GSLQRngWrapper.h; GSLQuasiRandom.cxx; GSLRndmEngines.cxx; GSLRngROOTWrapper.h; GSLRngWrapper.h; GSLRootFdFSolver.h; GSLRootFinder.cxx; GSLRootFinderDeriv.cxx; GSLRootFSolver.h; GSLRootHelper.cxx; GSLSimAnMinimizer.cxx; GSLSimAnnealing.cxx; Interpolator.cxx; KelvinFunctions.cxx; MCParameters.cxx; MultiNumGradFunction.cxx; PdfFuncMathMore.cxx; Polynomial.cxx; QuantFuncMathMore.cxx; RootFinderAlgorithms.cxx; SpecFuncMathMore.cxx; Vavilov.cxx; VavilovAccurate.cxx; VavilovAccurateCdf.cxx; VavilovAccuratePdf.cxx; VavilovAccurateQuantile.cxx; VavilovFast.cxx; zsolve_cubic.cxx; test; piRandom.C; pirndm.C; simanTSP.cxx; testChebyshev.cxx; testDerivation.cxx; testFunctor.cxx; testGSLIntegration.cxx; testGSLRootFinder.cxx; testInterpolation.cxx; testMCIntegration.cxx; testMinimization1D.cxx; testMultiRootFinder.cxx; testPermute.cxx; testQuasiRandom.cxx; testRandom.cxx; testRandomDist.cxx; testSpecFunc.cxx; testStatFunc.cxx; testVavilov.cxx; UnuRanDist.h; VavilovTest.cxx; VavilovTest.h; matrix; inc; TDecompBase.h; TDecompBK.h; TDecompChol.h; TDecompLU.h; TDecompQRH.h; TDecompSparse.h; TDecompSVD.h; TMatrix.h; TMatrixD.h; TMatrixDBase.h; TMatrixDBasefwd.h; TMatrixDEigen.h; TMatrixDfwd.h; TMatrixDLazy.h; TMatrixDSparse.h; TMatrixDSparsefwd.h; TMatrixDSym.h; TMatrixDSymEigen.h; TMatrixDSymfwd.h; TMatrixDUtils.h; TMatrixDUtilsfwd.h; TMatrixF.h; TMatrixFBase.h; TMatrixFBasefwd.h; TMatrixFfwd.h; TMatrixFLazy.h; TMatrixFSparse.h; TMatrixFSparsefwd.h; TMatrixFSym.h; TMatrixFSymfwd.h; TMatrixFUtils.h; TMatrixFUtilsfwd.h; TMatrixT.h; TMatrixTBase.h; TMatrixTCramerInv.h; TMatrixTLazy.h; TMatrixTSparse.h; TMatrixTSym.h; TMatrixTSymCramerInv.h; TMatrixTUtils.h; TVector.h; TVectorD.h; TVectorDfwd.h; TVectorF.h; TVectorFfwd.h; TVectorfwd.h; TVectorT.h; src; TDecompBase.cxx; TDecompBK.cxx; TDecompChol.cxx; TDecompLU.cxx; TDec,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v610/files.html:48011,test,testSpecFunc,48011,doc/v610/files.html,https://root.cern,https://root.cern/doc/v610/files.html,1,['test'],['testSpecFunc']
Testability,"onY(const char *name=""_py"", Int_t firstxbin=0, Int_t lastxbin=-1, Option_t *option="""") constProject a 2-D histogram into a 1-D histogram along Y.Definition TH2.cxx:2476; TH2::GetStatsvoid GetStats(Double_t *stats) const overrideFill the array stats from the contents of this histogram The array stats must be correctly dimensione...Definition TH2.cxx:1254; TH2::ShowPeaksInt_t ShowPeaks(Double_t sigma=2, Option_t *option="""", Double_t threshold=0.05) overrideInterface to TSpectrum2::Search the function finds peaks in this histogram where the width is > sigma...Definition TH2.cxx:2695; TH2::GetCorrelationFactorvirtual Double_t GetCorrelationFactor(Int_t axis1=1, Int_t axis2=2) constReturn correlation factor between axis1 and axis2.Definition TH2.cxx:1145; TH2::DoProfilevirtual TProfile * DoProfile(bool onX, const char *name, Int_t firstbin, Int_t lastbin, Option_t *option) constDefinition TH2.cxx:1880; TH2::KolmogorovTestDouble_t KolmogorovTest(const TH1 *h2, Option_t *option="""") const overrideStatistical test of compatibility in shape between THIS histogram and h2, using Kolmogorov test.Definition TH2.cxx:1470; TH2::FitSlicesYvirtual void FitSlicesY(TF1 *f1=nullptr, Int_t firstxbin=0, Int_t lastxbin=-1, Int_t cut=0, Option_t *option=""QNR"", TObjArray *arr=nullptr)Project slices along Y in case of a 2-D histogram, then fit each slice with function f1 and make a hi...Definition TH2.cxx:1081; TH2::GetBinWithContent2virtual Double_t GetBinWithContent2(Double_t c, Int_t &binx, Int_t &biny, Int_t firstxbin=1, Int_t lastxbin=-1, Int_t firstybin=1, Int_t lastybin=-1, Double_t maxdiff=0) constcompute first cell (binx,biny) in the range [firstxbin,lastxbin][firstybin,lastybin] for which diff =...Definition TH2.cxx:1117; TH2::ProfileXTProfile * ProfileX(const char *name=""_pfx"", Int_t firstybin=1, Int_t lastybin=-1, Option_t *option="""") constProject a 2-D histogram into a profile histogram along X.Definition TH2.cxx:2109; TH2::AddBinContentvoid AddBinContent(Int_t bin) overrideIncrem",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TH2_8cxx_source.html:186191,test,test,186191,doc/master/TH2_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TH2_8cxx_source.html,4,['test'],['test']
Testability,"on_t RooTemplateProxy< T >::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 448 of file RooTemplateProxy.h. DeclFileName(). template<class T > . static const char * RooTemplateProxy< T >::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 448 of file RooTemplateProxy.h. IsA(). template<class T > . TClass * RooTemplateProxy< T >::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from RooArgProxy.; Definition at line 448 of file RooTemplateProxy.h. lvptr() [1/4]. template<class T > . const LValue_t * RooTemplateProxy< T >::lvptr ; (; const LValue_t *; ); const. inline . Return l-value pointer to contents. ; If the contents derive from RooAbsLValue or RooAbsCategoryLValue, the conversion is safe, and the function directly returns the pointer using a static_cast. If the template parameter of this proxy is not an LValue type, then; in a debug build, a dynamic_cast with an assertion is used.; in a release build, a static_cast is forced, irrespective of what the type of the object actually is. This is dangerous, but equivalent to the behaviour before refactoring the RooFit proxies. Deprecated:This function is unnecessary if the template parameter is RooAbsRealLValue (+ derived types) or RooAbsCategoryLValue (+derived types), as arg() will always return the correct type. . Definition at line 407 of file RooTemplateProxy.h. lvptr() [2/4]. template<class T > . const LValue_t * RooTemplateProxy< T >::lvptr ; (; const RooAbsArg *; ); const. inline . Return l-value pointer to contents. ; If the contents derive from RooAbsLValue or RooAbsCategoryLValue, the conversion is safe, and the function directly returns the pointer using a static_cast. If the template parameter of this proxy is not an LValue type, then; in a debug build, a dynamic_cast with an assertion is used.; in a release build, a static_cast is forced,",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooTemplateProxy.html:23662,assert,assertion,23662,doc/master/classRooTemplateProxy.html,https://root.cern,https://root.cern/doc/master/classRooTemplateProxy.html,1,['assert'],['assertion']
Testability,"on_t vClVersion = buf.ReadVersionForMemberWise( valueClass );; 1140 ; 1141 TVirtualCollectionProxy::TPushPop helper( oldProxy, (char*)addr );; 1142 Int_t nobjects;; 1143 buf.ReadInt(nobjects);; 1144 void* alternative = oldProxy->Allocate(nobjects,true);; 1145 if (nobjects) {; 1146 TActionSequence *actions = oldProxy->GetReadMemberWiseActions( vClVersion );; 1147 ; 1148 char startbuf[TVirtualCollectionProxy::fgIteratorArenaSize];; 1149 char endbuf[TVirtualCollectionProxy::fgIteratorArenaSize];; 1150 void *begin = &(startbuf[0]);; 1151 void *end = &(endbuf[0]);; 1152 config->fCreateIterators(alternative, &begin, &end, oldProxy);; 1153 // We can not get here with a split vector of pointer, so we can indeed assume; 1154 // that actions->fConfiguration != null.; 1155 buf.ApplySequence(*actions, begin, end);; 1156 if (begin != &(startbuf[0])) {; 1157 // assert(end != endbuf);; 1158 config->fDeleteTwoIterators(begin,end);; 1159 }; 1160 }; 1161 oldProxy->Commit(alternative);; 1162 ; 1163 } else {; 1164 ; 1165 TClass *oldClass = config->fOldClass;; 1166 ; 1167 TVirtualCollectionProxy *oldProxy = oldClass ? oldClass->GetCollectionProxy() : nullptr;; 1168 if (!oldProxy) {; 1169 // Missing information, broken file ... give up; 1170 return;; 1171 }; 1172 ; 1173 TVirtualCollectionProxy::TPushPop helper( oldProxy, (char*)addr );; 1174 Int_t nobjects;; 1175 buf.ReadInt(nobjects);; 1176 void* env = oldProxy->Allocate(nobjects,true);; 1177 ; 1178 if (nobjects || vers < 7 ) {; 1179 // coverity[dereference] since this is a member streaming action by definition the collection contains objects.; 1180 TStreamerInfo *subinfo = (TStreamerInfo*)oldProxy->GetValueClass()->GetStreamerInfo( 0 );; 1181 ; 1182 subinfo->ReadBufferSTL(buf, oldProxy, nobjects, /* offset */ 0, /* v7 */ kFALSE);; 1183 }; 1184 oldProxy->Commit(env);; 1185 }; 1186 }; 1187 ; 1188 INLINE_TEMPLATE_ARGS void ReadArraySTLMemberWiseSameClass(TBuffer &buf, void *addr, const TConfiguration *conf, Version_t vers); 1189 {; 1190 /",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TStreamerInfoActions_8cxx_source.html:48200,assert,assert,48200,doc/master/TStreamerInfoActions_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TStreamerInfoActions_8cxx_source.html,1,['assert'],['assert']
Testability,"onding number of dimensions. WARNING. In case of an interpreted function (fType=2), it is the; user's responsability to initialize the parameters via InitArgs; before calling this function.; InitArgs should be called at least once to specify the addresses; of the arguments x and params.; InitArgs should be called everytime these addresses change. void ExecuteEvent(Int_t event, Int_t px, Int_t py); Execute action corresponding to one event. This member function is called when a F1 is clicked with the locator. void FixParameter(Int_t ipar, Double_t value); Fix the value of a parameter; The specified value will be used in a fit operation. TF1 * GetCurrent(); Static function returning the current function being processed. TH1 * GetHistogram() const; Return a pointer to the histogram used to vusualize the function. Double_t GetMaximum(Double_t xmin = 0, Double_t xmax = 0, Double_t epsilon = 1.E-10, Int_t maxiter = 100, Bool_t logx = false) const; Return the maximum value of the function; Method:; First, the grid search is used to bracket the maximum; with the step size = (xmax-xmin)/fNpx.; This way, the step size can be controlled via the SetNpx() function.; If the function is unimodal or if its extrema are far apart, setting; the fNpx to a small value speeds the algorithm up many times.; Then, Brent's method is applied on the bracketed interval; epsilon (default = 1.E-10) controls the relative accuracy (if |x| > 1 ); and absolute (if |x| < 1) and maxiter (default = 100) controls the maximum number; of iteration of the Brent algorithm; If the flag logx is set the grid search is done in log step size; This is done automatically if the log scale is set in the current Pad. NOTE: see also TF1::GetMaximumX and TF1::GetX. Double_t GetMaximumX(Double_t xmin = 0, Double_t xmax = 0, Double_t epsilon = 1.E-10, Int_t maxiter = 100, Bool_t logx = false) const; Return the X value corresponding to the maximum value of the function; Method:; First, the grid search is used to bracket the",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TF1.html:39150,log,logx,39150,root/html528/TF1.html,https://root.cern,https://root.cern/root/html528/TF1.html,4,['log'],['logx']
Testability,"one of input function; RooArgSet*RooAbsOptTestStatistic::_funcCloneSetSet owning all components of internal clone of input function; RooChi2Var::FuncMode_funcModeFunction, P.d.f. or extended p.d.f?; RooArgSet*RooAbsOptTestStatistic::_funcObsSetList of observables in the pdf expression; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; pRooAbsTestStatistic*RooAbsTestStatistic::_gofArray! Array of sub-contexts representing part of the combined test statistic; RooAbsTestStatistic::GOFOpModeRooAbsTestStatistic::_gofOpModeOperation mode of test statistic instance; vector<RooFit::MPSplit>RooAbsTestStatistic::_gofSplitMode! GOF MP Split mode specified by component (when Auto is active); static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Bool_tRooAbsTestStatistic::_init! Is object initialized; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches; Bool_tRooAbsArg::_isConstant! Cached isConstant status; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; pRooRealMPFE*RooAbsTestStatistic::_mpfeArray! Array of parallel execution frond ends; RooFit::MPSplitRooAbsTestStatistic::_mpinterlUse interleaving strategy rather than N-wise split for partioning of dataset for multiprocessor-split; Int_tRooAbsTestStatistic::_nCPUNumber of processors to use in parallel calculation mode; Int_tRooAbsTestStatistic::_nEventsTotal number of events in test statistic calculation; Int_tRooAbsTestStatistic::_nGofNumber of sub-contexts; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; RooArgSet*RooAbsOptTestStatistic::_normSetPointer to set with observables used for normalization; Int_tRooAbsTestStatistic::_numSe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooChi2Var.html:40790,test,test,40790,root/html602/RooChi2Var.html,https://root.cern,https://root.cern/root/html602/RooChi2Var.html,6,['test'],['test']
Testability,"oneOf(const RooAbsArg& other) const; Bool_tRooAbsArg::isConstant() const; virtual Bool_tRooAbsArg::isDerived() const; virtual Bool_tRooAbsPdf::isDirectGenSafe(const RooAbsArg& arg) const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; virtual Bool_tRooAbsArg::isFundamental() const; virtual Bool_tRooAbsArg::isLValue() const; Bool_tTObject::IsOnHeap() const; Bool_tRooAbsArg::isShapeDirty() const; Bool_tRooAbsArg::isShapeServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isShapeServer(const char* name) const; virtual Bool_tRooAbsArg::IsSortable() const; Bool_tRooAbsArg::isValueDirty() const; Bool_tRooAbsArg::isValueServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isValueServer(const char* name) const; Bool_tTObject::IsZombie() const; voidRooAbsArg::leafNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; Int_tloadDataSet(RooDataSet& data, TString options); voidRooAbsReal::logEvalError(const char* message, const char* serverValueString = 0) const; static voidRooAbsReal::logEvalError(const RooAbsReal* originator, const char* origName, const char* message, const char* serverValueString = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooMoment*RooAbsReal::mean(RooRealVar& obs); RooMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); Int_tRooAbsPdf::minDimNormValueCaching() const; virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tRooAbsPdf::mustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); const char*RooAbsPdf::normRange() const; virtual Bool_tTObject::Notify(); ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/Roo2DKeysPdf.html:19628,log,logEvalError,19628,root/html528/Roo2DKeysPdf.html,https://root.cern,https://root.cern/root/html528/Roo2DKeysPdf.html,2,['log'],['logEvalError']
Testability,"oneOf(const RooAbsArg& other) const; Bool_tRooAbsArg::isConstant() const; virtual Bool_tRooAbsArg::isDerived() const; virtual Bool_tRooAbsPdf::isDirectGenSafe(const RooAbsArg& arg) const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; virtual Bool_tRooAbsArg::isFundamental() const; virtual Bool_tRooAbsArg::isLValue() const; Bool_tTObject::IsOnHeap() const; Bool_tRooAbsArg::isShapeDirty() const; Bool_tRooAbsArg::isShapeServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isShapeServer(const char* name) const; virtual Bool_tRooAbsArg::IsSortable() const; Bool_tRooAbsArg::isValueDirty() const; Bool_tRooAbsArg::isValueServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isValueServer(const char* name) const; Bool_tTObject::IsZombie() const; voidRooAbsArg::leafNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; Int_tloadDataSet(RooDataSet& data, TString options); voidRooAbsReal::logEvalError(const char* message, const char* serverValueString = 0) const; static voidRooAbsReal::logEvalError(const RooAbsReal* originator, const char* origName, const char* message, const char* serverValueString = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooMoment*RooAbsReal::mean(RooRealVar& obs); RooMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); Int_tRooAbsPdf::minDimNormValueCaching() const; virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tRooAbsPdf::mustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/Roo2DKeysPdf.html:19566,log,logEvalError,19566,root/html526/Roo2DKeysPdf.html,https://root.cern,https://root.cern/root/html526/Roo2DKeysPdf.html,1,['log'],['logEvalError']
Testability,"oneOf(const RooAbsArg& other) const; Bool_tRooAbsArg::isConstant() const; virtual Bool_tRooAbsArg::isDerived() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; virtual Bool_tRooAbsArg::isFundamental() const; Bool_tisHidden() const; virtual Bool_tRooAbsArg::isLValue() const; Bool_tTObject::IsOnHeap() const; Bool_tRooAbsArg::isShapeDirty() const; Bool_tRooAbsArg::isShapeServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isShapeServer(const char* name) const; virtual Bool_tRooAbsArg::IsSortable() const; Bool_tRooAbsArg::isValueDirty() const; Bool_tRooAbsArg::isValueServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isValueServer(const char* name) const; Bool_tTObject::IsZombie() const; voidRooAbsArg::leafNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; voidRooAbsReal::logEvalError(const char* message, const char* serverValueString = 0) const; static voidRooAbsReal::logEvalError(const RooAbsReal* originator, const char* origName, const char* message, const char* serverValueString = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooMoment*RooAbsReal::mean(RooRealVar& obs); RooMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); static voidRooPrintable::nameFieldLength(Int_t newLen); virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAbsHiddenReal.html:16102,log,logEvalError,16102,root/html526/RooAbsHiddenReal.html,https://root.cern,https://root.cern/root/html526/RooAbsHiddenReal.html,3,['log'],['logEvalError']
Testability,"oneOf(const RooAbsArg& other) const; Bool_tRooAbsArg::isConstant() const; virtual Bool_tRooAbsArg::isDerived() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; virtual Bool_tRooAbsArg::isFundamental() const; virtual Bool_tRooAbsArg::isLValue() const; Bool_tTObject::IsOnHeap() const; Bool_tRooAbsArg::isShapeDirty() const; Bool_tRooAbsArg::isShapeServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isShapeServer(const char* name) const; virtual Bool_tRooAbsArg::IsSortable() const; Bool_tRooAbsArg::isValueDirty() const; Bool_tRooAbsArg::isValueServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isValueServer(const char* name) const; Bool_tTObject::IsZombie() const; const RooAbsReal&ixF(); voidRooAbsArg::leafNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; voidRooAbsReal::logEvalError(const char* message, const char* serverValueString = 0) const; static voidRooAbsReal::logEvalError(const RooAbsReal* originator, const char* origName, const char* message, const char* serverValueString = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooAbsReal*mean(); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); static voidRooPrintable::nameFieldLength(Int_t newLen); virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; static voidTOb",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooMoment.html:16317,log,logEvalError,16317,root/html526/RooMoment.html,https://root.cern,https://root.cern/root/html526/RooMoment.html,2,['log'],['logEvalError']
Testability,"oneOf(const RooAbsArg& other) const; Bool_tRooAbsArg::isConstant() const; virtual Bool_tRooAbsArg::isDerived() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; virtual Bool_tRooAbsArg::isFundamental() const; virtual Bool_tRooAbsArg::isLValue() const; Bool_tTObject::IsOnHeap() const; Bool_tRooAbsArg::isShapeDirty() const; Bool_tRooAbsArg::isShapeServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isShapeServer(const char* name) const; virtual Bool_tRooAbsArg::IsSortable() const; Bool_tRooAbsArg::isValueDirty() const; Bool_tRooAbsArg::isValueServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isValueServer(const char* name) const; Bool_tTObject::IsZombie() const; const RooAbsReal&ixF(); voidRooAbsArg::leafNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; voidRooAbsReal::logEvalError(const char* message, const char* serverValueString = 0) const; static voidRooAbsReal::logEvalError(const RooAbsReal* originator, const char* origName, const char* message, const char* serverValueString = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooAbsReal*mean(); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); static voidRooPrintable::nameFieldLength(Int_t newLen); virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::O",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooMoment.html:16684,log,logEvalError,16684,root/html530/RooMoment.html,https://root.cern,https://root.cern/root/html530/RooMoment.html,1,['log'],['logEvalError']
Testability,onents of internal clone of input function; RooAbsReal*_funcInt! Function integral; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; RooNumIntConfig_intConfigNumeric integrator configuration for integration of function over bin; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Bool_t_integrateIs integration over the bin volume requested; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; static Int_tRooPrintable::_nameLength; RooArgSet*RooAbsOptTestStatistic::_normSetPointer to set with observables used for normalization ; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; Bool_tRooAbsOptTestStatistic::_ownDataDo we own the dataset; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; RooSetProxyRooAbsTestStatistic::_paramSetParameters of the test statistic (=parameters of the input function); Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooArgSet*RooAbsOptTestStatistic::_projDepsSet of projected observable; const RooArgSet*RooAbsTestStatistic::_projDepsPointer to set with projected observables; TListRooAbsArg::_proxyListlist of proxies; stringRooAbsTestStatistic::_rangeNameName of range in which to calculate test statistic; RooArgSet_rrvArgsSet of real-valued observables; TIterator*_rrvIter! Iterator over set of real-valued observables; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; Int_tRooAbsTestStatistic::_simCountTotal number of component p.,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooXYChi2Var.html:34314,test,test,34314,root/html526/RooXYChi2Var.html,https://root.cern,https://root.cern/root/html526/RooXYChi2Var.html,2,['test'],['test']
Testability,"onents that depend on obs are binned that so is the product. ; ; boolisDirectGenSafe (const RooAbsArg &arg) const override; Forward determination of safety of internal generator code to component p.d.f that would generate the given observable. ; ; const RooArgList &pdfList () const; ; std::list< double > *plotSamplingHint (RooAbsRealLValue &obs, double xlo, double xhi) const override; Forward the plot sampling hint from the p.d.f. that defines the observable obs. ; ; voidprintMetaArgs (std::ostream &os) const override; Customized printing of arguments of a RooProdPdf to more intuitively reflect the contents of the product operator construction. ; ; boolredirectServersHook (const RooAbsCollection &, bool, bool, bool) override; Implement support for node removal. ; ; voidremovePdfs (RooAbsCollection const &pdfs); Remove some PDFs from the factors of this RooProdPdf. ; ; voidselectNormalizationRange (const char *rangeName=nullptr, bool force=false) override; Interface function used by test statistics to freeze choice of range for interpretation of conditional product terms. ; ; boolselfNormalized () const override; Shows if a PDF is self-normalized, which means that no attempt is made to add a normalization term. ; ; voidsetDefNormSet (const RooArgSet &nset); ; voidsetSelfNormalized (bool flag); ; voidStreamer (TBuffer &) override; Stream an object of class TObject. ; ; voidStreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b); ; Public Member Functions inherited from RooAbsPdf; RooAbsPdf (); Default constructor. ; ; RooAbsPdf (const char *name, const char *title, double minVal, double maxVal); Constructor with name, title, and plot range. ; ; RooAbsPdf (const char *name, const char *title=nullptr); Constructor with name and title only. ; ; ~RooAbsPdf () override; Destructor. ; ; virtual RooAbsGenContext *autoGenContext (const RooArgSet &vars, const RooDataSet *prototype=nullptr, const RooArgSet *auxProto=nullptr, bool v",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooProdPdf.html:7060,test,test,7060,doc/master/classRooProdPdf.html,https://root.cern,https://root.cern/doc/master/classRooProdPdf.html,1,['test'],['test']
Testability,"onfig& model); NeymanConstruction();. void SetTestStatSampler(RooStats::TestStatSampler& sampler); in addition to interface we also need:; Set the TestStatSampler (eg. ToyMC or FFT, includes choice of TestStatistic). {fTestStatSampler = &sampler;}. void SetLeftSideTailFraction(Double_t leftSideFraction = 0.); fLeftSideTailFraction*fSize defines lower edge of acceptance region.; Unified limits use 0, central limits use 0.5,; for upper/lower limits it is 0/1 depends on sign of test statistic w.r.t. parameter. {fLeftSideFraction = leftSideFraction;}. void SetParameterPointsToTest(RooAbsData& pointsToTest); User-defined set of points to test. Double_t Size() const; This class can make regularly spaced scans based on range stored in RooRealVars.; Choose number of steps for a rastor scan (common for each dimension); void SetNumSteps(Int_t);; This class can make regularly spaced scans based on range stored in RooRealVars.; Choose number of steps for a rastor scan (specific for each dimension); void SetNumSteps(map<RooAbsArg, Int_t>); Get the size of the test (eg. rate of Type I error). {return fSize;}. Double_t ConfidenceLevel() const; Get the Confidence level for the test. {return 1.-fSize;}. void SetModel(const RooStats::ModelConfig& model); Set ModelConfig. {fModel = model;}. void SetData(RooAbsData& data); Set the DataSet. { fData = data; }. void SetPdf(RooAbsPdf& ); Set the Pdf, add to the the workspace if not already there. void SetParameters(const RooArgSet& ); specify the parameters of interest in the interval. void SetNuisanceParameters(const RooArgSet& ); specify the nuisance parameters (eg. the rest of the parameters). void SetTestSize(Double_t size); set the size of the test (rate of Type I error) ( Eg. 0.05 for a 95% Confidence Interval). {fSize = size;}. void SetConfidenceLevel(Double_t cl); set the confidence level for the interval (eg. 0.95 for a 95% Confidence Interval). {fSize = 1.-cl;}. ConfidenceBelt* GetConfidenceBelt(); get confidence belt. {return fC",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooStats__NeymanConstruction.html:5972,test,test,5972,root/html528/RooStats__NeymanConstruction.html,https://root.cern,https://root.cern/root/html528/RooStats__NeymanConstruction.html,3,['test'],['test']
Testability,"onitoring ; Definition at line 820 of file NeuralNet.h. cycle(). virtual void TMVA::DNN::Settings::cycle ; (; double; progress, . TString; text. ). inlinevirtual . Parameters. textadvance on the progress bar; progressthe new value; texta label . Definition at line 799 of file NeuralNet.h. drawSample(). virtual void TMVA::DNN::Settings::drawSample ; (; const std::vector< double > &; , . const std::vector< double > &; , . const std::vector< double > &; , . double; . ). inlinevirtual . callback for monitoring and logging ; Definition at line 807 of file NeuralNet.h. dropFractions(). const std::vector< double > & TMVA::DNN::Settings::dropFractions ; (; ); const. inline . Definition at line 762 of file NeuralNet.h. dropRepetitions(). size_t TMVA::DNN::Settings::dropRepetitions ; (; ); const. inline . Definition at line 761 of file NeuralNet.h. endTestCycle(). virtual void TMVA::DNN::Settings::endTestCycle ; (; ). inlinevirtual . callback for monitoring and loggging ; Reimplemented in TMVA::DNN::ClassificationSettings.; Definition at line 805 of file NeuralNet.h. endTrainCycle(). virtual void TMVA::DNN::Settings::endTrainCycle ; (; double; ). inlinevirtual . callback for monitoring and logging ; Reimplemented in TMVA::DNN::ClassificationSettings.; Definition at line 788 of file NeuralNet.h. exists(). bool TMVA::DNN::Settings::exists ; (; std::string; histoName). inline . for monitoring ; Definition at line 825 of file NeuralNet.h. factorWeightDecay(). double TMVA::DNN::Settings::factorWeightDecay ; (; ); const. inline . get the weight-decay factor ; Definition at line 769 of file NeuralNet.h. hasConverged(). bool TMVA::DNN::Settings::hasConverged ; (; double; testError). virtual . has this training converged already? ; check for convergence; Definition at line 485 of file NeuralNet.cxx. learningRate(). double TMVA::DNN::Settings::learningRate ; (; ); const. inline . get the learning rate ; Definition at line 771 of file NeuralNet.h. maxConv",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1DNN_1_1Settings.html:8141,log,loggging,8141,doc/master/classTMVA_1_1DNN_1_1Settings.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1DNN_1_1Settings.html,1,['log'],['loggging']
Testability,"only print the error count per p.d.f component,; a positive value is will print details of each error up to numErr messages per p.d.f component. EvalErrorValue(Double_t value) -- Set curve points at which (pdf) evaluation error occur to specified value. By default the; function value is plotted. Normalization(Double_t scale, -- Adjust normalization by given scale factor. Interpretation of number depends on code: Relative:; ScaleType code) relative adjustment factor, NumEvent: scale to match given number of events. Name(const chat* name) -- Give curve specified name in frame. Useful if curve is to be referenced later. Asymmetry(const RooCategory& c) -- Show the asymmetry of the PDF in given two-state category [F(+)-F(-)] / [F(+)+F(-)] rather than; the PDF projection. Category must have two states with indices -1 and +1 or three states with; indeces -1,0 and +1. ShiftToZero(Bool_t flag) -- Shift entire curve such that lowest visible point is at exactly zero. Mostly useful when; plotting -log(L) or chi^2 distributions. AddTo(const char* name, -- Add constructed projection to already existing curve with given name and relative weight factors; double_t wgtSelf, double_t wgtOther). Plotting control. DrawOption(const char* opt) -- Select ROOT draw option for resulting TGraph object. LineStyle(Int_t style) -- Select line style by ROOT line style code, default is solid. LineColor(Int_t color) -- Select line color by ROOT color code, default is blue. LineWidth(Int_t width) -- Select line with in pixels, default is 3. FillStyle(Int_t style) -- Select fill style, default is not filled. If a filled style is selected, also use VLines(); to add vertical downward lines at end of curve to ensure proper closure; FillColor(Int_t color) -- Select fill color by ROOT color code. Range(const char* name) -- Only draw curve in range defined by given name. Range(double lo, double hi) -- Only draw curve in specified range. VLines() -- Add vertical lines to y=0 at end points of curve. Precision",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAbsReal.html:46771,log,log,46771,root/html526/RooAbsReal.html,https://root.cern,https://root.cern/root/html526/RooAbsReal.html,7,['log'],['log']
Testability,"ons inherited from TGeoVolume; TGeoVolume (); dummy constructor ; ; TGeoVolume (const char *name, const TGeoShape *shape, const TGeoMedium *med=nullptr); default constructor ; ; ~TGeoVolume () override; Destructor. ; ; voidAddNodeOffset (TGeoVolume *vol, Int_t copy_no, Double_t offset=0, Option_t *option=""""); Add a division node to the list of nodes. ; ; voidBrowse (TBrowser *b) override; How to browse a volume. ; ; Double_tCapacity () const; Computes the capacity of this [cm^3] as the capacity of its shape. ; ; virtual voidcd (Int_t inode) const; Actualize matrix of node indexed <inode> ; ; voidCheckGeometry (Int_t nrays=1, Double_t startx=0, Double_t starty=0, Double_t startz=0) const; Shoot nrays with random directions from starting point (startx, starty, startz) in the reference frame of this volume. ; ; voidCheckOverlaps (Double_t ovlp=0.1, Option_t *option="""") const; Overlap checking tool. ; ; voidCheckShape (Int_t testNo, Int_t nsamples=10000, Option_t *option=""""); Tests for checking the shape navigation algorithms. See TGeoShape::CheckShape() ; ; voidCheckShapes (); check for negative parameters in shapes. ; ; voidCleanAll (); Clean data of the volume. ; ; voidClearNodes (); ; voidClearShape (); Clear the shape of this volume from the list held by the current manager. ; ; virtual voidClearThreadData () const; ; voidCloneNodesAndConnect (TGeoVolume *newmother) const; Clone the array of nodes. ; ; virtual TGeoVolume *CloneVolume () const; Clone this volume. ; ; Bool_tContains (const Double_t *point) const; ; Int_tCountNodes (Int_t nlevels=1000, Int_t option=0); Count total number of subnodes starting from this volume, nlevels down. ; ; virtual voidCreateThreadData (Int_t nthreads); ; Int_tDistancetoPrimitive (Int_t px, Int_t py) override; compute the closest distance of approach from point px,py to this volume ; ; voidDraw (Option_t *option="""") override; draw top volume according to option ; ; virtua",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoVolumeMulti.html:11547,test,testNo,11547,doc/master/classTGeoVolumeMulti.html,https://root.cern,https://root.cern/doc/master/classTGeoVolumeMulti.html,1,['test'],['testNo']
Testability,"ons inherited from TGeoVolume; TGeoVolume (); dummy constructor ; ; TGeoVolume (const char *name, const TGeoShape *shape, const TGeoMedium *med=nullptr); default constructor ; ; ~TGeoVolume () override; Destructor. ; ; voidAddNodeOffset (TGeoVolume *vol, Int_t copy_no, Double_t offset=0, Option_t *option=""""); Add a division node to the list of nodes. ; ; voidBrowse (TBrowser *b) override; How to browse a volume. ; ; Double_tCapacity () const; Computes the capacity of this [cm^3] as the capacity of its shape. ; ; virtual voidcd (Int_t inode) const; Actualize matrix of node indexed <inode> ; ; voidCheckGeometry (Int_t nrays=1, Double_t startx=0, Double_t starty=0, Double_t startz=0) const; Shoot nrays with random directions from starting point (startx, starty, startz) in the reference frame of this volume. ; ; voidCheckOverlaps (Double_t ovlp=0.1, Option_t *option="""") const; Overlap checking tool. ; ; voidCheckShape (Int_t testNo, Int_t nsamples=10000, Option_t *option=""""); Tests for checking the shape navigation algorithms. See TGeoShape::CheckShape() ; ; voidCheckShapes (); check for negative parameters in shapes. ; ; voidCleanAll (); Clean data of the volume. ; ; voidClearNodes (); ; voidClearShape (); Clear the shape of this volume from the list held by the current manager. ; ; voidCloneNodesAndConnect (TGeoVolume *newmother) const; Clone the array of nodes. ; ; Bool_tContains (const Double_t *point) const; ; Int_tCountNodes (Int_t nlevels=1000, Int_t option=0); Count total number of subnodes starting from this volume, nlevels down. ; ; Int_tDistancetoPrimitive (Int_t px, Int_t py) override; compute the closest distance of approach from point px,py to this volume ; ; voidDraw (Option_t *option="""") override; draw top volume according to option ; ; voidExecuteEvent (Int_t event, Int_t px, Int_t py) override; Execute mouse actions on this volume. ; ; Int_tExport (const char *filename, const char *name="""", Opti",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoVolumeAssembly.html:3795,test,testNo,3795,doc/master/classTGeoVolumeAssembly.html,https://root.cern,https://root.cern/doc/master/classTGeoVolumeAssembly.html,1,['test'],['testNo']
Testability,"ons return resulting chi square ; ; Int_tfFitTaylor; order of Taylor expansion, possible values kFitTaylorOrderFirst, kFitTaylorOrderSecond. It applies only for Awmi fitting function. ; ; Bool_tfFixA0; logical value of a0 parameter, which allows to fix the parameter (not to fit). ; ; Bool_t *fFixAmp; [fNPeaks] array of logical values which allow to fix appropriate amplitudes of 2D peaks (not fit). However they are present in the estimated functional ; ; Bool_t *fFixAmpX1; [fNPeaks] array of logical values which allow to fix appropriate amplitudes of 1D ridges in x direction (not fit). However they are present in the estimated functional ; ; Bool_t *fFixAmpY1; [fNPeaks] array of logical values which allow to fix appropriate amplitudes of 1D ridges in y direction (not fit). However they are present in the estimated functional ; ; Bool_tfFixAx; logical value of ax parameter, which allows to fix the parameter (not to fit). ; ; Bool_tfFixAy; logical value of ay parameter, which allows to fix the parameter (not to fit). ; ; Bool_tfFixBx; logical value of b parameter for 1D ridges in x direction, which allows to fix the parameter (not to fit). ; ; Bool_tfFixBy; logical value of b parameter for 1D ridges in y direction, which allows to fix the parameter (not to fit). ; ; Bool_t *fFixPositionX; [fNPeaks] array of logical values which allow to fix appropriate x positions of 2D peaks (not fit). However they are present in the estimated functional ; ; Bool_t *fFixPositionX1; [fNPeaks] array of logical values which allow to fix appropriate x positions of 1D ridges (not fit). However they are present in the estimated functional ; ; Bool_t *fFixPositionY; [fNPeaks] array of logical values which allow to fix appropriate y positions of 2D peaks (not fit). However they are present in the estimated functional ; ; Bool_t *fFixPositionY1; [fNPeaks] array of logical values which allow to fix appropriate y positions of 1D ridges (not fit). However th",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSpectrum2Fit.html:26620,log,logical,26620,doc/master/classTSpectrum2Fit.html,https://root.cern,https://root.cern/doc/master/classTSpectrum2Fit.html,1,['log'],['logical']
Testability,"ons to this object; TList*TQObject::fListOfSignals! list of signals from this object; TProofMgr*TProof::fManagermanager to which this session belongs (if any); Bool_tTProof::fMasterServtrue if we are a master server; TStringTNamed::fNameobject identifier; Int_tTProof::fProtocolremote PROOF server protocol version number; TProof::EQueryModeTProof::fQueryModedefault query mode; TList*TProof::fRunningDSetsTemporary datasets used for async running; TProofMgr::EServTypeTProof::fServTypetype of server: proofd, XrdProofd; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; TList*TProof::fSlaveslist of all slave servers as in config file; TStringTNamed::fTitleobject title; Long64_tTProof::fTotalBytesnumber of bytes to be analyzed; TUrlTProof::fUrlUrl of the master; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static TSemaphore*TProof::fgSemaphoresemaphore to control no of parallel startup threads. private:. TCondor*fCondorproxy for our Condor pool; TTimer*fTimertimer for delayed Condor COD suspend. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TProofCondor(const char* masterurl, const char* conffile = kPROOF_ConfFile, const char* confdir = kPROOF_ConfDir, Int_t loglevel = 0, const char* alias = 0, TProofMgr* mgr = 0); Start proof using condor. ~TProofCondor(); Clean up Condor PROOF environment. Bool_t StartSlaves(Bool_t ); Setup Condor workers using dynamic information. void SetActive(Bool_t active); Suspend or resume PROOF via Condor. TString GetJobAd(); Get job Ad. void SetActive(); { TProof::SetActive(); }.  Author: Fons Rademakers 13/02/97  Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *;  Last changed: root/proof:$Id: TProofCondor.h 27171 2009-01-16 16:04:00Z ganis $  Last generated: 2010-10-06 16:19; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TProofCondor.html:24212,log,loglevel,24212,root/html528/TProofCondor.html,https://root.cern,https://root.cern/root/html528/TProofCondor.html,1,['log'],['loglevel']
Testability,"ons to this object; TList*TQObject::fListOfSignals! list of signals from this object; TProofMgr*TProof::fManagermanager to which this session belongs (if any); Bool_tTProof::fMasterServtrue if we are a master server; TStringTNamed::fNameobject identifier; Int_tTProof::fProtocolremote PROOF server protocol version number; TProof::EQueryModeTProof::fQueryModedefault query mode; TList*TProof::fRunningDSetsTemporary datasets used for async running; TProofMgr::EServTypeTProof::fServTypetype of server: proofd, XrdProofd; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; TList*TProof::fSlaveslist of all slave servers as in config file; TStringTNamed::fTitleobject title; Long64_tTProof::fTotalBytesnumber of bytes to be analyzed; TUrlTProof::fUrlUrl of the master; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static TSemaphore*TProof::fgSemaphoresemaphore to control no of parallel startup threads. private:. TCondor*fCondorproxy for our Condor pool; TTimer*fTimertimer for delayed Condor COD suspend. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TProofCondor(const char* masterurl, const char* conffile = kPROOF_ConfFile, const char* confdir = kPROOF_ConfDir, Int_t loglevel = 0, const char* alias = 0, TProofMgr* mgr = 0); Start proof using condor. ~TProofCondor(); Clean up Condor PROOF environment. Bool_t StartSlaves(Bool_t ); Setup Condor workers using dynamic information. void SetActive(Bool_t active); Suspend or resume PROOF via Condor. TString GetJobAd(); Get job Ad. void SetActive(); { TProof::SetActive(); }.  Author: Fons Rademakers 13/02/97  Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *;  Last changed: root/proof:$Id: TProofCondor.h 27171 2009-01-16 16:04:00Z ganis $  Last generated: 2011-07-04 15:36; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TProofCondor.html:24538,log,loglevel,24538,root/html530/TProofCondor.html,https://root.cern,https://root.cern/root/html530/TProofCondor.html,1,['log'],['loglevel']
Testability,"ons to this object; TList*TQObject::fListOfSignals! list of signals from this object; TProofMgr*TProof::fManagermanager to which this session belongs (if any); Bool_tTProof::fMasterServtrue if we are a master server; TStringTNamed::fNameobject identifier; Int_tTProof::fProtocolremote PROOF server protocol version number; TProof::EQueryModeTProof::fQueryModedefault query mode; TList*TProof::fRunningDSetsTemporary datasets used for async running; TProofMgr::EServTypeTProof::fServTypetype of server: proofd, XrdProofd; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; TList*TProof::fSlaveslist of all slave servers as in config file; TStringTNamed::fTitleobject title; Long64_tTProof::fTotalBytesnumber of bytes to be analyzed; TUrlTProof::fUrlUrl of the master; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static TSemaphore*TProof::fgSemaphoresemaphore to control no of parallel startup threads. private:. TCondor*fCondorproxy for our Condor pool; TTimer*fTimertimer for delayed Condor COD suspend. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TProofCondor(const char* masterurl, const char* conffile = kPROOF_ConfFile, const char* confdir = kPROOF_ConfDir, Int_t loglevel = 0, const char* alias = 0, TProofMgr* mgr = 0); Start proof using condor. ~TProofCondor(); Clean up Condor PROOF environment. Bool_t StartSlaves(Bool_t ); Setup Condor workers using dynamic information. void SetActive(Bool_t active); Suspend or resume PROOF via Condor. TString GetJobAd(); Get job Ad. void SetActive(); { TProof::SetActive(); }.  Author: Fons Rademakers 13/02/97  Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *;  Last changed: root/proof:$Id: TProofCondor.h 27171 2009-01-16 16:04:00Z ganis $  Last generated: 2011-11-03 20:21; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TProofCondor.html:24538,log,loglevel,24538,root/html532/TProofCondor.html,https://root.cern,https://root.cern/root/html532/TProofCondor.html,1,['log'],['loglevel']
Testability,"ons.at (dropIndex);; 764 ; 765 fillDropContainer (dropContainer, dropFraction, _numNodes);; 766 }; 767 isWeightsForDrop = true;; 768 }; 769 ; 770 // execute training cycle; 771 trainError = trainCycle (minimizer, weights, begin (trainPattern), end (trainPattern), settings, dropContainer);; 772 ; 773 ; 774 // ------ check if we have to execute a test ------------------; 775 bool hasConverged = false;; 776 if (testCycleCount % settings.testRepetitions () == 0) // we test only everye ""testRepetitions"" repetition; 777 {; 778 if (isWeightsForDrop); 779 {; 780 dropOutWeightFactor (weights, dropFractions);; 781 isWeightsForDrop = false;; 782 }; 783 ; 784 ; 785 testError = 0;; 786 //double weightSum = 0;; 787 settings.startTestCycle ();; 788 if (settings.useMultithreading ()); 789 {; 790 size_t numThreads = std::thread::hardware_concurrency ();; 791 size_t patternPerThread = testPattern.size () / numThreads;; 792 std::vector<Batch> batches;; 793 auto itPat = testPattern.begin ();; 794 // auto itPatEnd = testPattern.end ();; 795 for (size_t idxThread = 0; idxThread < numThreads-1; ++idxThread); 796 {; 797 batches.push_back (Batch (itPat, itPat + patternPerThread));; 798 itPat += patternPerThread;; 799 }; 800 if (itPat != testPattern.end ()); 801 batches.push_back (Batch (itPat, testPattern.end ()));; 802 ; 803 std::vector<std::future<std::tuple<double,std::vector<double>>>> futures;; 804 for (auto& batch : batches); 805 {; 806 // -------------------- execute each of the batch ranges on a different thread -------------------------------; 807 futures.push_back (; 808 std::async (std::launch::async, [&](); 809 {; 810 std::vector<double> localOutput;; 811 pass_through_type passThrough (settings, batch, dropContainerTest);; 812 double testBatchError = (*this) (passThrough, weights, ModeOutput::FETCH, localOutput);; 813 return std::make_tuple (testBatchError, localOutput);; 814 }); 815 );; 816 }; 817 ; 818 auto itBatch = batches.begin ();; 819 for (auto& f : futures); 820 {; 821 s",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/NeuralNet_8icc_source.html:23662,test,testPattern,23662,doc/master/NeuralNet_8icc_source.html,https://root.cern,https://root.cern/doc/master/NeuralNet_8icc_source.html,1,['test'],['testPattern']
Testability,"ons.clear();; 156 fImportTransformations.clear();; 157 fModel = RNTupleModel::CreateBare();; 158 fEntry = nullptr;; 159}; 160 ; 161ROOT::Experimental::RResult<void> ROOT::Experimental::RNTupleImporter::PrepareSchema(); 162{; 163 ResetSchema();; 164 ; 165 // Browse through all branches and their leaves, create corresponding fields and prepare the memory buffers for; 166 // reading and writing. Usually, reading and writing share the same memory buffer, i.e. the object is read from TTree; 167 // and written as-is to the RNTuple. There are exceptions, e.g. for leaf count arrays and C strings.; 168 for (auto b : TRangeDynCast<TBranch>(*fSourceTree->GetListOfBranches())) {; 169 assert(b);; 170 const auto firstLeaf = static_cast<TLeaf *>(b->GetListOfLeaves()->First());; 171 assert(firstLeaf);; 172 ; 173 const bool isLeafList = b->GetNleaves() > 1;; 174 const bool isCountLeaf = firstLeaf->IsRange(); // A leaf storing the number of elements of a leaf count array; 175 const bool isClass = (firstLeaf->IsA() == TLeafElement::Class()); // STL or user-defined class; 176 if (isLeafList && isClass); 177 return R__FAIL(""unsupported: classes in leaf list, branch "" + std::string(b->GetName()));; 178 if (isLeafList && isCountLeaf); 179 return R__FAIL(""unsupported: count leaf arrays in leaf list, branch "" + std::string(b->GetName()));; 180 ; 181 // Only plain leafs with type identifies 'C' are C strings. Otherwise, they are char arrays.; 182 // We use GetLeafCounter instead of GetLeafCount and GetLenStatic because the latter don't distinguish between; 183 // char arrays and C strings.; 184 Int_t firstLeafCountval;; 185 const bool isCString = !isLeafList && (firstLeaf->IsA() == TLeafC::Class()) &&; 186 (!firstLeaf->GetLeafCounter(firstLeafCountval)) && (firstLeafCountval == 1);; 187 ; 188 if (isCountLeaf) {; 189 // This is a count leaf. We expect that this is not part of a leaf list. We also expect that the; 190 // leaf count comes before any array leaves that use it.; 191 // Count leaf b",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RNTupleImporter_8cxx_source.html:6832,assert,assert,6832,doc/master/RNTupleImporter_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RNTupleImporter_8cxx_source.html,2,['assert'],['assert']
Testability,"ons:; class description; function members; data members; class charts. ROOT;  GUI;  RECORDER;  TRecorderState. class TRecorderState. ROOT EVENT RECORDING SYSTEM. TRecorder class provides interface for recording and replaying; events in ROOT.; Recorded events are:; - Commands typed by user in commandline ('new TCanvas'); - GUI events (mouse movement, button clicks, ...). All the recorded events from one session are stored in one TFile; and can be replayed again anytime. Recording. 1] To start recording. TRecorder r(const char *filename, ""NEW""); TRecorder r(const char *filename, ""RECREATE""). or:. TRecorder *recorder = new TRecorder;; recorder->Start(const char *filename, ...). -filename Name of ROOT file in which to save; recorded events. 2] To stop recording. recorder->Stop(). IMPORTANT:; State capturing is part of recording. It means that if you want to; record events for some object (window), creation of this object; must be also recorded. Example:. t = new TRecorder(); // Create a new recorder; t->Start(""logfile.root""); // ! Start recording first. c = new TCanvas(); // ! Then, create an object; c->Dump(); // Work with that object. t->Stop(); // Stop recording. It is strongly recommended to start recording with empty ROOT; environment, at least with no previously created ROOT GUI.; This ensures that only events for well known windows are stored.; Events for windows, which were not created during recording,; cannot be replayed. Replaying. 1] To start replaying. TRecorder r(const char *filename); TRecorder r(const char *filename, ""READ""). or:. TRecorder *recorder = new TRecorder;; recorder->Replay(const char *filename,; Bool_t showMouseCursor = kTRUE);. -filename A name of file with recorded events; previously created with TRecorder::Start. -showMouseCursor If kTRUE, mouse cursor is replayed as well.; In that case it is not recommended to use mouse; during replaying. In general, it is not recommended to use mouse to change positions; and states of ROOT windows dur",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TRecorderState.html:1153,log,logfile,1153,root/html528/TRecorderState.html,https://root.cern,https://root.cern/root/html528/TRecorderState.html,6,['log'],['logfile']
Testability,"ons; doubleg (double x, double sigma) const; . Private Attributes; bool_asymLeft = false; ; bool_asymRight = false; ; double_binWidth; ; double *_dataPts = nullptr; ; double *_dataWgts = nullptr; ; double_hi; ; double_lo; ; double_lookupTable [_nPoints+1]; ; bool_mirrorLeft = false; ; bool_mirrorRight = false; ; Int_t_nEvents = 0; ; double_rho; ; double_sumWgt = 0.0; ; Char_t_varName [128]; ; double *_weights = nullptr; . Static Private Attributes; static constexpr int_nPoints {1000}; ; static const double_nSigma; . Additional Inherited Members; Public Attributes inherited from RooAbsArg; R__DEPRECATED(6, 36, ""Use getObservables()."") RooFit R__DEPRECATED(6, 36, ""Use getObservables()."") RooFit R__DEPRECATED(6, 36, ""Use getObservables()."") RooFit const RooAbsArg &testArgconst { return observableOverlaps(dset,testArg); ; const RooAbsArg &testArgconst { return observableOverlaps(depList, testArg); ; Protected Types inherited from TObject; enum { kOnlyPrepStep = (1ULL << ( 3 )); }; ; Static Protected Member Functions inherited from RooAbsReal; static voidglobalSelectComp (bool flag); Global switch controlling the activation of the selectComp() functionality. ; ; Static Protected Member Functions inherited from RooAbsArg; static voidioStreamerPass2Finalize (); Method called by workspace container to finalize schema evolution issues that cannot be handled in a single ioStreamer pass. ; ; Static Protected Attributes inherited from RooAbsPdf; static TString_normRangeOverride; ; static Int_t_verboseEval = 0; ; Static Protected Attributes inherited from RooAbsReal; static bool_globalSelectComp = false; ; static bool_hideOffset = true; Offset hiding flag. ; ; Static Protected Attributes inherited from RooAbsArg; static bool_inhibitDirty; ; static bool_verboseDirty; cache of the list of proxies. Avoids type casting. ; ; Static Protected Attributes inherited from RooPrintable; static Int_t_nameLength; . #incl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooKeysPdf.html:73765,test,testArg,73765,doc/master/classRooKeysPdf.html,https://root.cern,https://root.cern/doc/master/classRooKeysPdf.html,4,['test'],['testArg']
Testability,"onst RooAbsArg& other) const; Bool_tRooAbsArg::isConstant() const; virtual Bool_tRooAbsArg::isDerived() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; virtual Bool_tRooAbsArg::isFundamental() const; virtual Bool_tRooAbsArg::isLValue() const; Bool_tTObject::IsOnHeap() const; Bool_tRooAbsArg::isShapeDirty() const; Bool_tRooAbsArg::isShapeServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isShapeServer(const char* name) const; virtual Bool_tRooAbsArg::IsSortable() const; virtual Bool_tisValid() const; Bool_tRooAbsArg::isValueDirty() const; Bool_tRooAbsArg::isValueServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isValueServer(const char* name) const; Bool_tTObject::IsZombie() const; voidRooAbsArg::leafNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; voidRooAbsReal::logEvalError(const char* message, const char* serverValueString = 0) const; static voidRooAbsReal::logEvalError(const RooAbsReal* originator, const char* origName, const char* message, const char* serverValueString = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooMoment*RooAbsReal::mean(RooRealVar& obs); RooMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); static voidRooPrintable::nameFieldLength(Int_t newLen); virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); const RooArgSet&numIntCatVars() const; const RooArgSet&numIntRealVars() const; Bool_tRooAbsArg::observableOv",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooRealIntegral.html:15776,log,logEvalError,15776,root/html526/RooRealIntegral.html,https://root.cern,https://root.cern/root/html526/RooRealIntegral.html,3,['log'],['logEvalError']
Testability,"onst RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); Roo1DMomentMorphFunction&operator=(const Roo1DMomentMorphFunction&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, RooLinkedList& cmdList) const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg(), const RooCmdArg& arg9 = RooCmdArg(), const RooCmdArg& arg10 = RooCmdArg()) const; virtual list<Double_t>*RooAbsReal::plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; virtual RooPlot*RooAbsReal::plotSliceOn(RooPlot* frame, const RooArgSet& sliceSet, Option_t* drawOptions = ""L"", Double_t scaleFactor = 1.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/Roo1DMomentMorphFunction.html:19400,test,testArg,19400,root/html602/Roo1DMomentMorphFunction.html,https://root.cern,https://root.cern/root/html602/Roo1DMomentMorphFunction.html,2,['test'],['testArg']
Testability,"onst RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); Roo2DMomentMorphFunction&operator=(const Roo2DMomentMorphFunction&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, RooLinkedList& cmdList) const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg(), const RooCmdArg& arg9 = RooCmdArg(), const RooCmdArg& arg10 = RooCmdArg()) const; virtual list<Double_t>*RooAbsReal::plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; virtual RooPlot*RooAbsReal::plotSliceOn(RooPlot* frame, const RooArgSet& sliceSet, Option_t* drawOptions = ""L"", Double_t scaleFactor = 1.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/Roo2DMomentMorphFunction.html:19400,test,testArg,19400,root/html602/Roo2DMomentMorphFunction.html,https://root.cern,https://root.cern/root/html602/Roo2DMomentMorphFunction.html,2,['test'],['testArg']
Testability,"onst RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); virtual RooAbsArg&operator=(const RooAbsReal& other); virtual RooAbsArg&operator=(Double_t newValue); virtual RooAbsArg&operator=(Int_t ival); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg(), const RooCmdArg& arg9 = RooCmdArg(), const RooCmdArg& arg10 = RooCmdArg()) const; virtual list<Double_t>*RooAbsReal::plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; virtual RooPlot*RooAbsReal::plotSliceOn(RooPlot* frame, const RooArgSet& sliceSet, Option_t* drawOptions = ""L"", Double_t scaleFactor = 1.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooAbsRealLValue.html:21777,test,testArg,21777,root/html530/RooAbsRealLValue.html,https://root.cern,https://root.cern/root/html530/RooAbsRealLValue.html,2,['test'],['testArg']
Testability,"onst RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooLinearVar&operator=(const RooLinearVar&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, RooLinkedList& cmdList) const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg(), const RooCmdArg& arg9 = RooCmdArg(), const RooCmdArg& arg10 = RooCmdArg()) const; virtual list<Double_t>*RooAbsReal::plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; virtual RooPlot*RooAbsReal::plotSliceOn(RooPlot* frame, const RooArgSet& sliceSet, Option_t* drawOptions = ""L"", Double_t scaleFactor = 1.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooLinearVar.html:23626,test,testArg,23626,root/html602/RooLinearVar.html,https://root.cern,https://root.cern/root/html602/RooLinearVar.html,2,['test'],['testArg']
Testability,"onst RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooProfileLL&operator=(const RooProfileLL&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, RooLinkedList& cmdList) const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg(), const RooCmdArg& arg9 = RooCmdArg(), const RooCmdArg& arg10 = RooCmdArg()) const; virtual list<Double_t>*RooAbsReal::plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; virtual RooPlot*RooAbsReal::plotSliceOn(RooPlot* frame, const RooArgSet& sliceSet, Option_t* drawOptions = ""L"", Double_t scaleFactor = 1.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooProfileLL.html:19965,test,testArg,19965,root/html602/RooProfileLL.html,https://root.cern,https://root.cern/root/html602/RooProfileLL.html,2,['test'],['testArg']
Testability,"onst RooAbsReal* originator, const char* origName, const char* message, const char* serverValueString = 0); const RooArgList&lowList() const; virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooMoment*RooAbsReal::mean(RooRealVar& obs); RooMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); static voidRooPrintable::nameFieldLength(Int_t newLen); virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TNamed&TNamed::operator=(const TNamed& rhs); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const Ro",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/PiecewiseInterpolation.html:17479,test,testArg,17479,root/html528/PiecewiseInterpolation.html,https://root.cern,https://root.cern/root/html528/PiecewiseInterpolation.html,1,['test'],['testArg']
Testability,"onst RooAbsReal* originator, const char* origName, const char* message, const char* serverValueString = 0); const RooArgList&lowList() const; virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooMoment*RooAbsReal::mean(RooRealVar& obs); RooMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); static voidRooPrintable::nameFieldLength(Int_t newLen); virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TNamed&TNamed::operator=(const TNamed& rhs); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/PiecewiseInterpolation.html:17435,test,testArg,17435,root/html530/PiecewiseInterpolation.html,https://root.cern,https://root.cern/root/html530/PiecewiseInterpolation.html,1,['test'],['testArg']
Testability,"onst RooArgSet *; nset); const. virtual . Return expected number of events to be used in calculation of extended likelihood. ; Return expected number of events from this p.d.f for use in extended likelihood calculations.; This default implementation returns zero ; Reimplemented in RooNormalizedPdf, RooFixedProdPdf, RooAddModel, RooAddPdf, RooBinSamplingPdf, RooExtendedTerm, RooExtendPdf, RooProdPdf, RooProjectedPdf, RooRealSumPdf, RooSimultaneous, and xRooProjectedPdf.; Definition at line 2398 of file RooAbsPdf.cxx. extendedTerm() [1/3]. double RooAbsPdf::extendedTerm ; (; double; sumEntries, . double; expected, . double; sumEntriesW2 = 0.0, . bool; doOffset = false. ); const. Definition at line 730 of file RooAbsPdf.cxx. extendedTerm() [2/3]. double RooAbsPdf::extendedTerm ; (; double; sumEntries, . RooArgSet const *; nset, . double; sumEntriesW2 = 0.0, . bool; doOffset = false. ); const. Return the extended likelihood term ( \( N_\mathrm{expect} - N_\mathrm{observed} \cdot \log(N_\mathrm{expect} \)) of this PDF for the given number of observed events. ; For successful operation, the PDF implementation must indicate that it is extendable by overloading canBeExtended(), and must implement the expectedEvents() function.; Parameters. [in]sumEntriesThe number of observed events. ; [in]nsetThe normalization set when asking the pdf for the expected number of events. ; [in]observedSumW2The number of observed events when weighting with squared weights. If non-zero, the weight-squared error correction is applied to the extended term. ; [in]doOffsetOffset the extended term by a counterterm where the expected number of events equals the observed number of events. This constant shift results in a term closer to zero that is approximately chi-square distributed. It is useful to do this also when summing multiple NLL terms to avoid numeric precision loss that happens if you sum multiple terms of different orders of magnitude. The weight-squared error correction wor",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsPdf.html:99269,log,log,99269,doc/master/classRooAbsPdf.html,https://root.cern,https://root.cern/doc/master/classRooAbsPdf.html,1,['log'],['log']
Testability,"onst RooArgSet& depVars, const RooArgSet& projVars, RooArgSet*& cloneSet) const; const RooAbsReal*createPlotProjection(const RooArgSet& dependentVars, const RooArgSet* projectedVars, RooArgSet*& cloneSet, const char* rangeName = 0, const RooArgSet* condObs = 0) const; virtual RooAbsReal*createProfile(const RooArgSet& paramsOfInterest); RooAbsReal*createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); RooAbsReal*createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); virtual Double_tdefaultErrorLevel() const; static RooNumIntConfig*defaultIntegratorConfig(); virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; RooDerivative*derivative(RooRealVar& obs, Int_t order = 1, Double_t eps = 0.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooAbsReal.html:8373,test,testArg,8373,root/html528/RooAbsReal.html,https://root.cern,https://root.cern/root/html528/RooAbsReal.html,12,['test'],['testArg']
Testability,"onst RooArgSet&); virtual voidSetObservables(const RooArgSet&); virtual voidSetParametersForTestStat(const RooArgSet&); virtual voidSetPdf(RooAbsPdf&); virtual voidSetPriorNuisance(RooAbsPdf*); virtual voidSetSamplingDistName(const char* name); virtual voidSetTestSize(Double_t size); virtual voidSetTestStatistic(RooStats::TestStatistic* testStatistic); virtual voidShowMembers(TMemberInspector&); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~TestStatSampler(); TestStatSampler();. {}. SamplingDistribution* GetSamplingDistribution(RooArgSet& paramsOfInterest); Main interface to get a ConfInterval, pure virtual. Double_t EvaluateTestStatistic(RooAbsData& data, RooArgSet& paramsOfInterest); Main interface to evaluate the test statistic on a dataset. TestStatistic* GetTestStatistic() const; Get the TestStatistic. Double_t ConfidenceLevel() const; Get the Confidence level for the test. void Initialize(RooAbsArg& testStatistic, RooArgSet& paramsOfInterest, RooArgSet& nuisanceParameters); Common Initialization. void SetPdf(RooAbsPdf& ); Set the Pdf, add to the the workspace if not already there. void SetPriorNuisance(RooAbsPdf* ); How to randomize the prior. Set to NULL to deactivate randomization. void SetParametersForTestStat(const RooArgSet& ); specify the values of parameters used when evaluating test statistic. void SetNuisanceParameters(const RooArgSet& ); REMOVE THIS; specify the parameters of interest in the interval; virtual void SetParameters(const RooArgSet&) = 0;; specify the nuisance parameters (eg. the rest of the parameters). void SetObservables(const RooArgSet& ); specify the observables in the dataset (needed to evaluate the test statistic). void SetGlobalObservables(const RooArgSet& ); specify the conditional observables. void SetTestSize(Double_t size); set the size of the test (rate of Type I error) ( Eg. 0.05 fo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooStats__TestStatSampler.html:2381,test,test,2381,root/html534/RooStats__TestStatSampler.html,https://root.cern,https://root.cern/root/html534/RooStats__TestStatSampler.html,1,['test'],['test']
Testability,"onst RooCmdArg& arg4={},; 270 const RooCmdArg& arg5={}, const RooCmdArg& arg6={},; 271 const RooCmdArg& arg7={}, const RooCmdArg& arg8={},; 272 const RooCmdArg& arg9={}, const RooCmdArg& arg10={}; 273 ) const ;; 274 ; 275 ; 276 enum ScaleType { Raw, Relative, NumEvent, RelativeExpected } ;; 277 ; 278 // Fill an existing histogram; 279 TH1 *fillHistogram(TH1 *hist, const RooArgList &plotVars,; 280 double scaleFactor= 1, const RooArgSet *projectedVars= nullptr, bool scaling=true,; 281 const RooArgSet* condObs=nullptr, bool setError=true) const;; 282 ; 283 // Create 1,2, and 3D histograms from and fill it; 284 TH1 *createHistogram(RooStringView varNameList, Int_t xbins=0, Int_t ybins=0, Int_t zbins=0) const ;; 285 TH1* createHistogram(const char *name, const RooAbsRealLValue& xvar, RooLinkedList& argList) const ;; 286 TH1 *createHistogram(const char *name, const RooAbsRealLValue& xvar,; 287 const RooCmdArg& arg1={}, const RooCmdArg& arg2={},; 288 const RooCmdArg& arg3={}, const RooCmdArg& arg4={},; 289 const RooCmdArg& arg5={}, const RooCmdArg& arg6={},; 290 const RooCmdArg& arg7={}, const RooCmdArg& arg8={}) const ;; 291 ; 292 // Fill a RooDataHist; 293 RooDataHist* fillDataHist(RooDataHist *hist, const RooArgSet* nset, double scaleFactor,; 294 bool correctForBinVolume=false, bool showProgress=false) const ;; 295 ; 296 // I/O streaming interface (machine readable); 297 bool readFromStream(std::istream& is, bool compact, bool verbose=false) override ;; 298 void writeToStream(std::ostream& os, bool compact) const override ;; 299 ; 300 // Printing interface (human readable); 301 void printValue(std::ostream& os) const override ;; 302 void printMultiline(std::ostream& os, Int_t contents, bool verbose=false, TString indent="""") const override ;; 303 ; 304 inline void setCachedValue(double value, bool notifyClients = true) final;; 305 ; 306 // Evaluation error logging; 307 class EvalError {; 308 public:; 309 EvalError() { }; 310 EvalError(const EvalError& other) : _msg(other.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RooAbsReal_8h_source.html:15156,log,logging,15156,doc/master/RooAbsReal_8h_source.html,https://root.cern,https://root.cern/doc/master/RooAbsReal_8h_source.html,1,['log'],['logging']
Testability,"onst RooDataSet* protoData = NULL, int forceEvents = 0) const; This is the generate function to use in the context of the ToyMCSampler; instead of the standard RooAbsPdf::generate(...).; It takes into account whether the number of events is given explicitly; or whether it should use the expected number of events. It also takes; into account the option to generate a binned data set (ie RooDataHist). ToyMCSampler(); Proof constructor. Do not use. ToyMCSampler(RooStats::TestStatistic& ts, Int_t ntoys). void SetAlwaysUseMultiGen(Bool_t flag); { fgAlwaysUseMultiGen = flag ; }. void SetUseMultiGen(Bool_t flag); { fUseMultiGen = flag ; }. RooAbsData* GenerateToyData(RooArgSet& paramPoint) const; generates toy data; without weight. SamplingDistribution* AppendSamplingDistribution(RooArgSet& allParameters, RooStats::SamplingDistribution* last, Int_t additionalMC); Extended interface to append to sampling distribution more samples. Double_t EvaluateTestStatistic(RooAbsData& data, RooArgSet& nullPOI); Main interface to evaluate the test statistic on a dataset. TestStatistic* GetTestStatistic() const; { return fTestStat; }. Double_t ConfidenceLevel() const; { return 1. - fSize; }. void Initialize(RooAbsArg& , RooArgSet& , RooArgSet& ); { return fNToys; }. void SetNToys(const Int_t ntoy); { fNToys = ntoy; }. void SetNEventsPerToy(const Int_t nevents); Forces n events even for extended PDFs. Set NEvents=0 to; use the Poisson distributed events from the extended PDF. void SetParametersForTestStat(const RooArgSet& nullpoi); specify the values of parameters used when evaluating test statistic. void SetPdf(RooAbsPdf& pdf); Set the Pdf, add to the the workspace if not already there. { fPdf = &pdf; }. void SetPriorNuisance(RooAbsPdf* pdf); How to randomize the prior. Set to NULL to deactivate randomization. { fPriorNuisance = pdf; }. void SetNuisanceParameters(const RooArgSet& np); specify the nuisance parameters (eg. the rest of the parameters). { fNuisancePars = &np; }. void SetObser",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooStats__ToyMCSampler.html:7096,test,test,7096,root/html530/RooStats__ToyMCSampler.html,https://root.cern,https://root.cern/root/html530/RooStats__ToyMCSampler.html,1,['test'],['test']
Testability,"onst T* SVector<T,D>::Array() const { return fArray; }; 541 ; 542template <class T, unsigned int D>; 543inline T* SVector<T,D>::Array() { return fArray; }; 544 ; 545 ; 546//==============================================================================; 547// STL interface; 548//==============================================================================; 549template <class T, unsigned int D>; 550inline T* SVector<T,D>::begin() { return fArray; }; 551 ; 552template <class T, unsigned int D>; 553inline const T* SVector<T,D>::begin() const { return fArray; }; 554 ; 555template <class T, unsigned int D>; 556inline T* SVector<T,D>::end() { return fArray + Dim(); }; 557 ; 558template <class T, unsigned int D>; 559inline const T* SVector<T,D>::end() const { return fArray + Dim(); }; 560 ; 561template <class T, unsigned int D>; 562template <class InputIterator>; 563void SVector<T,D>::SetElements(InputIterator ibegin, InputIterator iend) {; 564 // iterator size must match vector size; 565 assert( ibegin + D == iend);; 566 std::copy(ibegin, iend, fArray);; 567}; 568 ; 569template <class T, unsigned int D>; 570template <class InputIterator>; 571void SVector<T,D>::SetElements(InputIterator ibegin, unsigned int size) {; 572 // size <= vector size; 573 assert( size <= D);; 574 std::copy(ibegin, ibegin+size, fArray);; 575}; 576 ; 577 ; 578//==============================================================================; 579// Operators; 580//==============================================================================; 581template <class T, unsigned int D>; 582inline const T& SVector<T,D>::operator[](unsigned int i) const { return fArray[i]; }; 583 ; 584template <class T, unsigned int D>; 585inline const T& SVector<T,D>::operator()(unsigned int i) const { return fArray[i]; }; 586 ; 587template <class T, unsigned int D>; 588inline T& SVector<T,D>::operator[](unsigned int i) { return fArray[i]; }; 589 ; 590template <class T, unsigned int D>; 591inline T& SVector<T,D>::operator()(un",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/SVector_8icc_source.html:18250,assert,assert,18250,doc/master/SVector_8icc_source.html,https://root.cern,https://root.cern/doc/master/SVector_8icc_source.html,1,['assert'],['assert']
Testability,"onst TH1* hist); TGLPlotCoordinates(const TGLPlotCoordinates&). Data Members; private:. EGLCoordTypefCoordType; Double_tfFactor; Bool_tfModified; Rgl::BinRange_tfXBins; Bool_tfXLog; Rgl::Range_tfXRange; Rgl::Range_tfXRangeScaled; Double_tfXScale; Rgl::BinRange_tfYBins; Bool_tfYLog; Rgl::Range_tfYRange; Rgl::Range_tfYRangeScaled; Double_tfYScale; Rgl::BinRange_tfZBins; Bool_tfZLog; Rgl::Range_tfZRange; Rgl::Range_tfZRangeScaled; Double_tfZScale. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGLPlotCoordinates(); Constructor. ~TGLPlotCoordinates(); Destructor. void SetCoordType(EGLCoordType type); If coord type was changed, plot must reset sections (if any),; set fModified. EGLCoordType GetCoordType() const; Get coordinates type. void SetXLog(Bool_t xLog); If log changed, sections must be reset,; set fModified. Bool_t GetXLog() const; Get X log. void SetYLog(Bool_t yLog); If log changed, sections must be reset,; set fModified. Bool_t GetYLog() const; Get Y log. void SetZLog(Bool_t zLog); If log changed, sections must be reset,; set fModified. Bool_t GetZLog() const; Get Z log. void ResetModified(); Reset modified. Bool_t Modified() const; Modified. Bool_t SetRanges(const TH1* hist, Bool_t errors = kFALSE, Bool_t zBins = kFALSE); Set bin ranges, ranges. Int_t GetNXBins() const; Number of X bins. Int_t GetNYBins() const; Number of Y bins. Int_t GetNZBins() const; Number of Z bins. const Rgl::BinRange_t & GetXBins() const; X bins range. const Rgl::BinRange_t & GetYBins() const; Y bins range. const Rgl::BinRange_t & GetZBins() const; Z bins range. const Rgl::Range_t & GetXRange() const; X range. Double_t GetXLength() const; X length. const Rgl::Range_t & GetYRange() const; Y range. Double_t GetYLength() const; Y length. const Rgl::Range_t & GetZRange() const; Z range. Double_t GetZLength() const; Z length. const Rgl::Range_t & GetXRangeScaled() const; Scaled range. const Rgl::Range_t & GetYRangeScaled() const; Scaled range. cons",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGLPlotCoordinates.html:3238,log,log,3238,root/html602/TGLPlotCoordinates.html,https://root.cern,https://root.cern/root/html602/TGLPlotCoordinates.html,2,['log'],['log']
Testability,"onst TMVA::Event* TMVA::MethodBase::GetEvent( const TMVA::Event* ev ) const; 747{; 748 return GetTransformationHandler().Transform(ev);; 749}; 750 ; 751inline const TMVA::Event* TMVA::MethodBase::GetEvent() const; 752{; 753 if(fTmpEvent); 754 return GetTransformationHandler().Transform(fTmpEvent);; 755 else; 756 return GetTransformationHandler().Transform(Data()->GetEvent());; 757}; 758 ; 759inline const TMVA::Event* TMVA::MethodBase::GetEvent( Long64_t ievt ) const; 760{; 761 assert(fTmpEvent==nullptr);; 762 return GetTransformationHandler().Transform(Data()->GetEvent(ievt));; 763}; 764 ; 765inline const TMVA::Event* TMVA::MethodBase::GetEvent( Long64_t ievt, Types::ETreeType type ) const; 766{; 767 assert(fTmpEvent==nullptr);; 768 return GetTransformationHandler().Transform(Data()->GetEvent(ievt, type));; 769}; 770 ; 771inline const TMVA::Event* TMVA::MethodBase::GetTrainingEvent( Long64_t ievt ) const; 772{; 773 assert(fTmpEvent==nullptr);; 774 return GetEvent(ievt, Types::kTraining);; 775}; 776 ; 777inline const TMVA::Event* TMVA::MethodBase::GetTestingEvent( Long64_t ievt ) const; 778{; 779 assert(fTmpEvent==nullptr);; 780 return GetEvent(ievt, Types::kTesting);; 781}; 782 ; 783#endif; Configurable.h; DataSet.h; Event.h; IMethod.h; Results.h; Char_tchar Char_tDefinition RtypesCore.h:37; kFALSEconstexpr Bool_t kFALSEDefinition RtypesCore.h:94; Double_tdouble Double_tDefinition RtypesCore.h:59; Long64_tlong long Long64_tDefinition RtypesCore.h:69; kTRUEconstexpr Bool_t kTRUEDefinition RtypesCore.h:93; ClassDef#define ClassDef(name, id)Definition Rtypes.h:342; TFile.h; dataOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void dataDefinition TGWin32VirtualXProxy.cxx:104; valueOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void valueDefinition TGWin32VirtualXPro",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/MethodBase_8h_source.html:33134,assert,assert,33134,doc/master/MethodBase_8h_source.html,https://root.cern,https://root.cern/doc/master/MethodBase_8h_source.html,2,['assert'],['assert']
Testability,"onst char *name, Option_t *option="""", const char *ftitle="""", Int_t compress=ROOT::RCompressionSetting::EDefaults::kUseCompiledDefault, Int_t netopt=0)Create / open a file.Definition TFile.cxx:4089; TFile::Closevoid Close(Option_t *option="""") overrideClose a file.Definition TFile.cxx:950; TMVA::CrossValidationClass to perform cross validation, splitting the dataloader into folds.Definition CrossValidation.h:124; TMVA::DataLoaderDefinition DataLoader.h:50; TMVA::DataLoader::AddSignalTreevoid AddSignalTree(TTree *signal, Double_t weight=1.0, Types::ETreeType treetype=Types::kMaxTreeType)number of signal events (used to compute significance)Definition DataLoader.cxx:371; TMVA::DataLoader::AddSpectatorvoid AddSpectator(const TString &expression, const TString &title="""", const TString &unit="""", Double_t min=0, Double_t max=0)user inserts target in data set infoDefinition DataLoader.cxx:524; TMVA::DataLoader::PrepareTrainingAndTestTreevoid PrepareTrainingAndTestTree(const TCut &cut, const TString &splitOpt)prepare the training and test trees -> same cuts for signal and backgroundDefinition DataLoader.cxx:632; TMVA::DataLoader::AddBackgroundTreevoid AddBackgroundTree(TTree *background, Double_t weight=1.0, Types::ETreeType treetype=Types::kMaxTreeType)number of signal events (used to compute significance)Definition DataLoader.cxx:402; TMVA::DataLoader::AddVariablevoid AddVariable(const TString &expression, const TString &title, const TString &unit, char type='F', Double_t min=0, Double_t max=0)user inserts discriminating variable in data set infoDefinition DataLoader.cxx:485; TMVA::Tools::Instancestatic Tools & Instance()Definition Tools.cxx:71; TMVA::Types::kFisher@ kFisherDefinition Types.h:82; TMVA::Types::kBDT@ kBDTDefinition Types.h:86; TNamed::GetNameconst char * GetName() const overrideReturns name of object.Definition TNamed.h:47; TRandom3Random number generator class based on M.Definition TRandom3.h:27; TStringBasic string class.Definition TString.h:139; TString::D",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVACrossValidation_8C.html:28897,test,test,28897,doc/master/TMVACrossValidation_8C.html,https://root.cern,https://root.cern/doc/master/TMVACrossValidation_8C.html,1,['test'],['test']
Testability,"onst char *; buffer). Load a text buffer in the window. ; Definition at line 280 of file TProofProgressLog.cxx. LoadFile(). void TProofProgressLog::LoadFile ; (; const char *; file). Load a file in the window. ; Definition at line 289 of file TProofProgressLog.cxx. LogMessage(). void TProofProgressLog::LogMessage ; (; const char *; msg, . Bool_t; all. ). Load/append a log msg in the log frame, if open. ; Definition at line 519 of file TProofProgressLog.cxx. NoLineEntry(). void TProofProgressLog::NoLineEntry ; (; ). Enable/disable the line number entry. ; Definition at line 599 of file TProofProgressLog.cxx. Popup(). void TProofProgressLog::Popup ; (; ). Show log window. ; Definition at line 263 of file TProofProgressLog.cxx. Rebuild(). void TProofProgressLog::Rebuild ; (; ). Rebuild the log info for a new entered session. ; Definition at line 635 of file TProofProgressLog.cxx. SaveToFile(). void TProofProgressLog::SaveToFile ; (; ). Save the logs to a file Only the name of the file is taken, no expansion. ; Definition at line 534 of file TProofProgressLog.cxx. Select(). void TProofProgressLog::Select ; (; Int_t; id, . Bool_t; all = kTRUE. ). actions of select all/clear all button ; Definition at line 614 of file TProofProgressLog.cxx. SetGrepView(). void TProofProgressLog::SetGrepView ; (; ). Sets the view of grep filters according to the value of checkboxes. ; Definition at line 570 of file TProofProgressLog.cxx. SetUrl(). void TProofProgressLog::SetUrl ; (; const char *; url). inline . Definition at line 89 of file TProofProgressLog.h. Streamer(). void TProofProgressLog::Streamer ; (; TBuffer &; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from TGTransientFrame. StreamerNVirtual(). void TProofProgressLog::StreamerNVirtual ; (; TBuffer &; ClassDef_StreamerNVirtual_b). inline . Definition at line 93 of file TProofProgressLog.h. Member Data Documentation. fAllLines. TGCheckButton* TProofProgressLog::fA",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProofProgressLog.html:42066,log,logs,42066,doc/master/classTProofProgressLog.html,https://root.cern,https://root.cern/doc/master/classTProofProgressLog.html,1,['log'],['logs']
Testability,"onst char* fmt, va_list va) const; voidTObject::MakeZombie(); voidSetBins(const RooAbsCollection& coll, Int_t numBins) const; voidSetupBasicUsage(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. RooArgList*fAxeswhich variables to put on each axis; RooArgSetfChainParamsparameters to store in the chain (if not specified they are all of them ); RooArgSetfConditionalObsconditional observables; RooAbsData*fDatapointer to the data (owned by the workspace); Double_tfDeltaacceptable error for Keys cutoffs being equal; Double_tfEpsilonacceptable error for Keys interval determination; RooStats::MCMCInterval::IntervalTypefIntervalTypetype of interval to find; Double_tfLeftSideTFleft side tail-fraction for interval; TStringTNamed::fNameobject identifier; RooArgSetfNuisParamsnuisance parameters for interval (not really used); Int_tfNumBinsset the number of bins to create for each; Int_tfNumBurnInStepsnumber of iterations to discard as burn-in, starting from the first; Int_tfNumItersnumber of iterations to run metropolis algorithm; RooArgSetfPOIparameters of interest for interval; RooAbsPdf*fPdfpointer to common PDF (owned by the workspace); RooAbsPdf*fPriorPdfpointer to prior PDF (owned by the workspace); RooStats::ProposalFunction*fPropFuncProposal function for MCMC integration; Double_tfSizesize of the test (eg. specified rate of Type I error); TStringTNamed::fTitleobject title; Bool_tfUseKeyswhether to use kernel estimation to determine interval; Bool_tfUseSparseHistwhether to use sparse histogram (if using hist at all). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; MCMCCalculator(). MCMCCalculator(RooAbsData& data, const RooStats::ModelConfig& model). void SetModel(const RooStats::ModelConfig&",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooStats__MCMCCalculator.html:8534,test,test,8534,root/html534/RooStats__MCMCCalculator.html,https://root.cern,https://root.cern/root/html534/RooStats__MCMCCalculator.html,1,['test'],['test']
Testability,"onst char* image, const char* workdir); TSlave*TProof::CreateSubmaster(const char* url, const char* ord, const char* image, const char* msd); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; TList*TProof::GetEnabledPackages() const; static Bool_tTProof::GetFileInCmd(const char* cmd, TString& fn); static Int_tTProof::GetInputData(TList* input, const char* cachedir, TString& emsg); TList*TProof::GetListOfActiveSlaves() const; TVirtualProofPlayer*TProof::GetPlayer() const; TPluginHandler*TProof::GetProgressDialog() const; Int_tTProof::GetSandbox(TString& sb, Bool_t assert = kFALSE, const char* rc = 0); virtual void*TQObject::GetSender(); virtual const char*TQObject::GetSenderClassName() const; voidTProof::HandleLibIncPath(const char* what, Bool_t add, const char* dirs); Int_tTProof::HandleOutputOptions(TString& opt, TString& target, Int_t action); Int_tTProof::Init(const char* masterurl, const char* conffile, const char* confdir, Int_t loglevel, const char* alias = 0); voidTProof::InitMembers(); virtual TVirtualProofPlayer*MakePlayer(const char* player = 0, TSocket* s = 0); voidTObject::MakeZombie(); virtual Int_tTProof::PollForNewWorkers(); voidTProof::PrepareInputDataFile(TString& dataFile); Int_tTProof::RemoveWorkers(TList* wrks); static Int_tTProof::SaveInputData(TQueryResult* qr, const char* cachedir, TString& emsg); virtual voidTProof::SaveWorkerInfo(); Int_tTProof::SendFile(const char* file, Int_t opt = (kBinary|kForward|kCp|kCpBin), const char* rfile = 0, TSlave* sl = 0); static Int_tTProof::SendInputData(TQueryResult* qr, TProof* p, TString& emsg); virtual voidTProof::SendInputDataFile(); voidTProof::SetDSet(TDSet* dset); voidTProof::SetFeedback(TString& opt, TString& optfb, Int_t action); voidTProof::SetPlayer(TVirtualProofPlayer* player); voidTProof::SetupWorkersEnv(TList* wrks, Bool_t increasingpool = kFALSE); static void*TProof::SlaveStartupThread(void* arg); virtual Bool_tStartSlaves(Bool_t); static voidTPro",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TProofSuperMaster.html:22124,log,loglevel,22124,root/html534/TProofSuperMaster.html,https://root.cern,https://root.cern/root/html534/TProofSuperMaster.html,1,['log'],['loglevel']
Testability,"onst char* image, const char* workdir); TSlave*TProof::CreateSubmaster(const char* url, const char* ord, const char* image, const char* msd, Int_t nwk = 1); Int_tCreateSymLinks(TList* files); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; static Bool_tTProof::GetFileInCmd(const char* cmd, TString& fn); static Int_tTProof::GetInputData(TList* input, const char* cachedir, TString& emsg); TList*TProof::GetListOfActiveSlaves() const; TVirtualProofPlayer*TProof::GetPlayer() const; TPluginHandler*TProof::GetProgressDialog() const; Int_tTProof::GetSandbox(TString& sb, Bool_t assert = kFALSE, const char* rc = 0); virtual void*TQObject::GetSender(); virtual const char*TQObject::GetSenderClassName() const; voidTProof::HandleLibIncPath(const char* what, Bool_t add, const char* dirs); Int_tTProof::HandleOutputOptions(TString& opt, TString& target, Int_t action); Int_tInit(const char* masterurl, const char* conffile, const char* confdir, Int_t loglevel, const char* alias = 0); voidTProof::InitMembers(); virtual TVirtualProofPlayer*TProof::MakePlayer(const char* player = 0, TSocket* s = 0); TProofQueryResult*MakeQueryResult(Long64_t nent, const char* opt, Long64_t fst, TDSet* dset, const char* selec); voidTObject::MakeZombie(); voidTProof::PrepareInputDataFile(TString& dataFile); Int_tTProof::RemoveWorkers(TList* wrks); static Int_tTProof::SaveInputData(TQueryResult* qr, const char* cachedir, TString& emsg); virtual voidTProof::SaveWorkerInfo(); Int_tTProof::SendFile(const char* file, Int_t opt = (kBinary | kForward | kCp | kCpBin), const char* rfile = 0, TSlave* sl = 0); static Int_tTProof::SendInputData(TQueryResult* qr, TProof* p, TString& emsg); voidTProof::SetDSet(TDSet* dset); voidTProof::SetFeedback(TString& opt, TString& optfb, Int_t action); voidTProof::SetPlayer(TVirtualProofPlayer* player); voidSetQueryRunning(TProofQueryResult* pq); Int_tSetupWorkers(Int_t opt = 0, TList* wrks = 0); static void*TProof::SlaveStartupThre",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TProofLite.html:21670,log,loglevel,21670,root/html602/TProofLite.html,https://root.cern,https://root.cern/root/html602/TProofLite.html,1,['log'],['loglevel']
Testability,"onst char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TMVA::MsgLogger*fLogger! message logger. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; PDEFoamKernelBase(); Default constructor for streamer. PDEFoamKernelBase(const TMVA::PDEFoamKernelBase& ); Copy constructor. ~PDEFoamKernelBase(); Destructor. Float_t Estimate(TMVA::PDEFoam* , vector<Float_t>& , TMVA::ECellValue ); kernel estimator.  Author: Dominik Dannheim, Alexander Voigt  Copyright (c) 2010: *;  Last changed: root/tmva $Id$  Last generated: 2015-06-02 16:17; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TMVA__PDEFoamKernelBase.html:6276,log,logger,6276,root/html604/TMVA__PDEFoamKernelBase.html,https://root.cern,https://root.cern/root/html604/TMVA__PDEFoamKernelBase.html,1,['log'],['logger']
Testability,"onst char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TMVA::MsgLogger*fLogger! message logger. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; PDEFoamKernelBase(); Default constructor for streamer. PDEFoamKernelBase(const TMVA::PDEFoamKernelBase& ); Copy constructor. ~PDEFoamKernelBase(); Destructor. Float_t Estimate(TMVA::PDEFoam* , vector<Float_t>& , TMVA::ECellValue ); kernel estimator.  Author: Dominik Dannheim, Alexander Voigt  Copyright (c) 2010: *;  Last changed: root/tmva $Id$  Last generated: 2015-06-30 15:17; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TMVA__PDEFoamKernelBase.html:6268,log,logger,6268,root/html602/TMVA__PDEFoamKernelBase.html,https://root.cern,https://root.cern/root/html602/TMVA__PDEFoamKernelBase.html,1,['log'],['logger']
Testability,"onst char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TMVA::MsgLogger*TMVA::PDEFoamKernelBase::fLogger! message logger. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; PDEFoamKernelTrivial(); Default constructor for streamer. PDEFoamKernelTrivial(const TMVA::PDEFoamKernelTrivial& ); Copy constructor. Float_t Estimate(TMVA::PDEFoam* , vector<Float_t>& , TMVA::ECellValue ); Simple kernel estimator. It returns the cell value 'cv',; corresponding to the event vector 'txvec' (in foam coordinates). Parameters:. - foam - the pdefoam to search in. - txvec - event vector in foam coordinates [0,1]. - cv - cell value to estimate. virtual ~PDEFoamKernelTrivial(); {}.  Author: Dominik Dannheim, Alexander Voigt  Copyright (c) 2010: *;  Last changed: root/tmva $Id$  Last generated: 2015-06-02 16:18; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TMVA__PDEFoamKernelTrivial.html:6241,log,logger,6241,root/html604/TMVA__PDEFoamKernelTrivial.html,https://root.cern,https://root.cern/root/html604/TMVA__PDEFoamKernelTrivial.html,1,['log'],['logger']
Testability,"onst char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TMVA::MsgLogger*TMVA::PDEFoamKernelBase::fLogger! message logger. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; PDEFoamKernelTrivial(); Default constructor for streamer. PDEFoamKernelTrivial(const TMVA::PDEFoamKernelTrivial& ); Copy constructor. Float_t Estimate(TMVA::PDEFoam* , vector<Float_t>& , TMVA::ECellValue ); Simple kernel estimator. It returns the cell value 'cv',; corresponding to the event vector 'txvec' (in foam coordinates). Parameters:. - foam - the pdefoam to search in. - txvec - event vector in foam coordinates [0,1]. - cv - cell value to estimate. virtual ~PDEFoamKernelTrivial(); {}.  Author: Dominik Dannheim, Alexander Voigt  Copyright (c) 2010: *;  Last changed: root/tmva $Id$  Last generated: 2015-06-30 15:17; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TMVA__PDEFoamKernelTrivial.html:6233,log,logger,6233,root/html602/TMVA__PDEFoamKernelTrivial.html,https://root.cern,https://root.cern/root/html602/TMVA__PDEFoamKernelTrivial.html,1,['log'],['logger']
Testability,"onst char* str); Sends a string to master and workers and expect them to echo it back to; the client via a message. It is a special case of the generic Echo(); that works with TObjects. Returns -1 on error, the number of workers that; received the message on success. Int_t SendObject(const TObject* obj, TProof::ESlaves list = kActive); Send object to master or slave servers. Returns number of slaves object; was sent to, -1 in case of error. Int_t SendPrint(Option_t* option = """"); Send print command to master server. Returns number of slaves message; was sent to. Returns -1 in case of error. void SetLogLevel(Int_t level, UInt_t mask = TProofDebug::kAll); Set server logging level. void SetRealTimeLog(Bool_t on = kTRUE); Switch ON/OFF the real-time logging facility. When this option is; ON, log messages from processing are sent back as they come, instead of; being sent back at the end in one go. This may help debugging or monitoring; in some cases, but, depending on the amount of log, it may have significant; consequencies on the load over the network, so it must be used with care. Int_t SetParallelSilent(Int_t nodes, Bool_t random = kFALSE); Tell PROOF how many slaves to use in parallel. If random is TRUE a random; selection is done (if nodes is less than the available nodes).; Returns the number of parallel slaves. Returns -1 in case of error. Int_t SetParallel(Int_t nodes = -1, Bool_t random = kFALSE); Tell PROOF how many slaves to use in parallel. Returns the number of; parallel slaves. Returns -1 in case of error. Int_t GoMoreParallel(Int_t nWorkersToAdd); Add nWorkersToAdd workers to current list of workers. This function is; works on the master only, and only when an analysis is ongoing. A message; is sent back to the client when we go ""more"" parallel.; Returns -1 on error, number of total (not added!) workers on success. Int_t GoParallel(Int_t nodes, Bool_t accept = kFALSE, Bool_t random = kFALSE); Go in parallel mode with at most ""nodes"" slaves. Since the fSla",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TProof.html:67408,log,log,67408,root/html534/TProof.html,https://root.cern,https://root.cern/root/html534/TProof.html,3,['log'],['log']
