quality_attribute,sentence,source,author,repo,version,id,keyword,matched_word,match_idx,filename,wiki,url,total_similar,target_keywords,target_matched_words
Usability,"e'll add are programmable unary operators; (right now, Kaleidoscope has no unary operators at all) as well as; binary operators. An example of this is:. ::. # Logical unary not.; def unary!(v); if v then; 0; else; 1;. # Define > with the same precedence as <.; def binary> 10 (LHS RHS); RHS < LHS;. # Binary ""logical or"", (note that it does not ""short circuit""); def binary| 5 (LHS RHS); if LHS then; 1; else if RHS then; 1; else; 0;. # Define = with slightly lower precedence than relationals.; def binary= 9 (LHS RHS); !(LHS < RHS | LHS > RHS);. Many languages aspire to being able to implement their standard runtime; library in the language itself. In Kaleidoscope, we can implement; significant parts of the language in the library!. We will break down implementation of these features into two parts:; implementing support for user-defined binary operators and adding unary; operators. User-defined Binary Operators; =============================. Adding support for user-defined binary operators is pretty simple with; our current framework. We'll first add support for the unary/binary; keywords:. .. code-block:: c++. enum Token {; ...; // operators; tok_binary = -11,; tok_unary = -12; };; ...; static int gettok() {; ...; if (IdentifierStr == ""for""); return tok_for;; if (IdentifierStr == ""in""); return tok_in;; if (IdentifierStr == ""binary""); return tok_binary;; if (IdentifierStr == ""unary""); return tok_unary;; return tok_identifier;. This just adds lexer support for the unary and binary keywords, like we; did in `previous chapters <LangImpl05.html#lexer-extensions-for-if-then-else>`_. One nice thing; about our current AST, is that we represent binary operators with full; generalisation by using their ASCII code as the opcode. For our extended; operators, we'll use this same representation, so we don't need any new; AST or parser support. On the other hand, we have to be able to represent the definitions of; these new operators, in the ""def binary\| 5"" part of the function; de",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl06.rst:3382,simpl,simple,3382,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl06.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl06.rst,1,['simpl'],['simple']
Usability,"e) in a MaterializationUnit,; which is then stored in the JITDylib. MaterializationUnits are responsible for; describing the definitions they provide, and for unwrapping the program; representation and passing it back to the layer when compilation is required; (this ownership shuffle makes writing thread-safe layers easier, since the; ownership of the program representation will be passed back on the stack,; rather than having to be fished out of a Layer member, which would require; synchronization). - *MaterializationResponsibility* - When a MaterializationUnit hands a program; representation back to the layer it comes with an associated; MaterializationResponsibility object. This object tracks the definitions; that must be materialized and provides a way to notify the JITDylib once they; are either successfully materialized or a failure occurs. Absolute Symbols, Aliases, and Reexports; ========================================. ORC makes it easy to define symbols with absolute addresses, or symbols that; are simply aliases of other symbols:. Absolute Symbols; ----------------. Absolute symbols are symbols that map directly to addresses without requiring; further materialization, for example: ""foo"" = 0x1234. One use case for; absolute symbols is allowing resolution of process symbols. E.g. .. code-block:: c++. JD.define(absoluteSymbols(SymbolMap({; { Mangle(""printf""),; { ExecutorAddr::fromPtr(&printf),; JITSymbolFlags::Callable } }; });. With this mapping established code added to the JIT can refer to printf; symbolically rather than requiring the address of printf to be ""baked in"".; This in turn allows cached versions of the JIT'd code (e.g. compiled objects); to be re-used across JIT sessions as the JIT'd code no longer changes, only the; absolute symbol definition does. For process and library symbols the DynamicLibrarySearchGenerator utility (See; :ref:`How to Add Process and Library Symbols to JITDylibs; <ProcessAndLibrarySymbols>`) can be used to automatically",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ORCv2.rst:13054,simpl,simply,13054,interpreter/llvm-project/llvm/docs/ORCv2.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ORCv2.rst,1,['simpl'],['simply']
Usability,"e). Divides `MOTHER` into `NDIV` divisions called `NAME` along axis `IAXIS`; starting at coordinate value `START` and having size `STEP`. The created; volumes will have tracking media `ID=NUMED` (if `NUMED=0` -\> same media; as `MOTHER`). The behavior of the division operation can be triggered using `OPTION`; (case insensitive):. - `N`divide all range in `NDIV` cells (same effect as `STEP<=0`); (GSDVN in G3); - `NX`divide range starting with `START` in `NDIV` cells (GSDVN2 in; G3); - `S`divide all range with given `STEP`; `NDIV` is computed and; divisions will be centered in full range (same effect as `NDIV<=0`); (GSDVS, GSDVT in G3); - `SX`same as `DVS`, but from `START` position (GSDVS2, GSDVT2 in G3). \anchor GP01bj; #### Volume Assemblies. In general, geometry contains structures of positioned volumes that have; to be grouped and handled together, for different possible reasons. One; of these is that the structure has to be replicated in several parts of; the geometry, or it may simply happen that they really represent a; single object, too complex to be described by a primitive shape. Usually handling structures like these can be easily done by positioning; all components in the same container volume, then positioning the; container itself. However, there are many practical cases when defining; such a container is not straightforward or even possible without; generating overlaps with the rest of the geometry. There are few ways; out of this:. - Defining the container for the structure as ""overlapping"" (see also; ""Overlapping Volumes""); - Representing the container as a composite shape - the Boolean union; of all components (see also ""Composite Shapes""); - Using an assembly volume - this will be described in the following. The first two approaches have the disadvantage of penalizing the; navigation performance with a factor increasing more than linear of the; number of components in the structure. The best solution is the third; one because it uses all volume-rel",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md:48584,simpl,simply,48584,geom/geom/doc/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md,1,['simpl'],['simply']
Usability,"e, in one script you can use ACLiC to compile and load another; script. ``` {.cpp}; gROOT->ProcessLine("".L MyScript.C+""); gROOT->ProcessLine("".L MyScript.C++""); ```. ### Setting the Include Path. You can get the include path by typing:. ``` {.cpp}; root[] .include; ```. You can append to the include path by typing:. ``` {.cpp}; root[] .include $HOME/mypackage/include; ```. In a script you can append to the include path:. ``` {.cpp}; gSystem->AddIncludePath("" -I$HOME/mypackage/include ""); ```. You can also overwrite the existing include path:. ``` {.cpp}; gSystem->SetIncludePath("" -I$HOME/mypackage/include ""); ```. The `$ROOTSYS/include` directory is automatically appended to the; include path, so you do not have to worry about including it. To add; library that should be used during linking of the shared library use; something like:. ``` {.cpp}; gSystem->AddLinkedLibs(""-L/my/path -lanylib"");; ```. This is especially useful for static libraries. For shared ones you; can also simply load them before trying to compile the script:. ``` {.cpp}; gSystem->Load(""mydir/mylib"");; ```. ACLiC uses the directive `fMakeSharedLibs` to create the shared; library. If loading the shared library fails, it tries to output a; list of missing symbols by creating an executable (on some platforms; like OSF, this does not HAVE to be an executable) containing the; script. It uses the directive `fMakeExe` to do so. For both; directives, before passing them to `TSystem::Exec()`, it expands the; variables `$SourceFiles`, `$SharedLib`, `$LibName`, `$IncludePath`,; `$LinkedLibs`, `$ExeName `and` $ObjectFiles`. See `SetMakeSharedLib()`; for more information on those variables. When the file being passed to; ACLiC is on a read only file system, ACLiC warns the user and creates; the library in a temporary directory:. ``` {.cpp}; root[] .L readonly/t.C++; Warning in <ACLiC>: /scratch/aclic/subs/./readonly is not writable!; Warning in <ACLiC>: Output will be written to /tmp; Info in <TUnixSystem::ACLiC",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Cling.md:17204,simpl,simply,17204,documentation/users-guide/Cling.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Cling.md,1,['simpl'],['simply']
Usability,"e, the gas has some container also, but let; us keeps it like that for the sake of simplicity. Since we did not; supply the third argument, the wire will be positioned with an identity; transformation inside the chamber. \anchor GP01bf; #### Overlapping Volumes. Positioning volumes that does not overlap their neighbors nor extrude; their container is sometimes quite strong constraint. Having a limited; set of geometric shapes might force sometimes overlaps. Since; overlapping is contradictory to containment, a point belonging to an; overlapping region will naturally belong to all overlapping partners.; The answer provided by the modeller to ""Where am I?"" is no longer; deterministic if there is no priority assigned. There are two ways out provided by the modeller in such cases and we; will illustrate them by examples. - Suppose we have 2 crossing tubes that we have to describe. Such a; structure cannot be decomposed in a containment schema. This is a; typical example of simple structure that can be handled by using; composite shapes. What we have to do is to define as shapes the; inner and outer parts of the tubes (tubes having; `Rmin=0`,` Rmax=`inner/outer radius), then to make a composite:; - `C = (Tub1out+Tub2out)-(Tub1in+Tub2in)`; - On the other hand, if we have an EM calorimeter having a honeycomb; structure, Boolean combinations do not help anymore. Here the; problem is that we usually have a very large number of cells that; are naturally belonging to the same container. This result in a very; flat and slow structure for that particular container, which we; would very much want to avoid by introducing additional levels in; depth. We can describe the basic cell as a hexahedron that we can; represent by using a polygon primitive shape. Instead of putting one; by one all cells in the same container, we can define rows of such; elements, fitting in box-shaped containers. Then we can put; row-beside-row inside the container, making life much easier for its; navigatio",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md:36243,simpl,simple,36243,geom/geom/doc/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md,1,['simpl'],['simple']
Usability,"e-types-functions-variables-and-enumerators-properly>`_; states:. Variable names should be nouns (as they represent state). The name should be; camel case, and start with an upper case letter (e.g. Leader or Boats). This rule is the same as that for type names. This is a problem because the; type name cannot be reused for a variable name [*]_. LLVM developers tend to; work around this by either prepending ``The`` to the type name::. Triple TheTriple;. ... or more commonly use an acronym, despite the coding standard stating ""Avoid; abbreviations unless they are well known""::. Triple T;. The proliferation of acronyms leads to hard-to-read code such as `this; <https://github.com/llvm/llvm-project/blob/0a8bc14ad7f3209fe702d18e250194cd90188596/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp#L7445>`_::. InnerLoopVectorizer LB(L, PSE, LI, DT, TLI, TTI, AC, ORE, VF.Width, IC,; &LVL, &CM);. Many other coding guidelines [LLDB]_ [Google]_ [WebKit]_ [Qt]_ [Rust]_ [Swift]_; [Python]_ require that variable names begin with a lower case letter in contrast; to class names which begin with a capital letter. This convention means that the; most readable variable name also requires the least thought::. Triple triple;. There is some agreement that the current rule is broken [LattnerAgree]_; [ArsenaultAgree]_ [RobinsonAgree]_ and that acronyms are an obstacle to reading; new code [MalyutinDistinguish]_ [CarruthAcronym]_ [PicusAcronym]_. There are; some opposing views [ParzyszekAcronym2]_ [RicciAcronyms]_. This work-in-progress proposal is to change the coding standard for variable; names to require that they start with a lower case letter. .. [*] In `some cases; <https://github.com/llvm/llvm-project/blob/8b72080d4d7b13072f371712eed333f987b7a18e/llvm/lib/CodeGen/SelectionDAG/SelectionDAG.cpp#L2727>`_; the type name *is* reused as a variable name, but this shadows the type name; and confuses many debuggers [DenisovCamelBack]_. Variable Names Coding Standard Options; =======================",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Proposals/VariableNames.rst:1710,guid,guidelines,1710,interpreter/llvm-project/llvm/docs/Proposals/VariableNames.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Proposals/VariableNames.rst,1,['guid'],['guidelines']
Usability,"e:. .. code-block:: llvm. %Y = add i32 %X, 1; %Z = add i32 %Y, 1. into:. .. code-block:: llvm. %Z = add i32 %X, 2. This is a simple worklist driven algorithm. This pass guarantees that the following canonicalizations are performed on the; program:. #. If a binary operator has a constant operand, it is moved to the right-hand; side.; #. Bitwise operators with constant operands are always grouped so that shifts; are performed first, then ``or``\ s, then ``and``\ s, then ``xor``\ s.; #. Compare instructions are converted from ``<``, ``>``, ``≤``, or ``≥`` to; ``=`` or ``≠`` if possible.; #. All ``cmp`` instructions on boolean values are replaced with logical; operations.; #. ``add X, X`` is represented as ``mul X, 2`` ⇒ ``shl X, 1``; #. Multiplies with a constant power-of-two argument are transformed into; shifts.; #. … etc. This pass can also simplify calls to specific well-known function calls (e.g.; runtime library functions). For example, a call ``exit(3)`` that occurs within; the ``main()`` function can be transformed into simply ``return 3``. Whether or; not library calls are simplified is controlled by the; :ref:`-function-attrs <passes-function-attrs>` pass and LLVM's knowledge of; library calls on different targets. .. _passes-aggressive-instcombine:. ``aggressive-instcombine``: Combine expression patterns; --------------------------------------------------------. Combine expression patterns to form expressions with fewer, simple instructions. For example, this pass reduce width of expressions post-dominated by TruncInst; into smaller width when applicable. It differs from instcombine pass in that it can modify CFG and contains pattern; optimization that requires higher complexity than the O(1), thus, it should run fewer; times than instcombine pass. ``internalize``: Internalize Global Symbols; -------------------------------------------. This pass loops over all of the functions in the input module, looking for a; main function. If a main function is found, al",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Passes.rst:20606,simpl,simply,20606,interpreter/llvm-project/llvm/docs/Passes.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Passes.rst,1,['simpl'],['simply']
Usability,"e:. <IfModule mod_headers.c>; <FilesMatch ""\.root"">; Header set Access-Control-Allow-Origin ""*""; Header set Access-Control-Allow-Headers ""range""; Header set Access-Control-Expose-Headers ""content-range,content-length,accept-ranges""; Header set Access-Control-Allow-Methods ""GET""; </FilesMatch>; </IfModule>. More details about configuring of CORS headers can be found [here](https://developer.mozilla.org/en/http_access_control). Alternative - enable CORS requests in the browser. It can be easily done with [CORS Everywhere plugin](https://addons.mozilla.org/de/firefox/addon/cors-everywhere/) for the Firefox browser or [Allow CORS plugin](https://chrome.google.com/webstore/detail/allow-control-allow-origi/nlfbmbojpeacfghkpbjhddihlkkiljbi?hl=en) for the Chrome browser. Next solution - install JSROOT on the server hosting ROOT files. In such configuration JSROOT does not issue CORS requests, therefore server and browsers can be used with their default settings. A simplified variant of such solution - copy only the top index.htm file from JSROOT package and specify the full path to `modules/gui.mjs` script like:. ```javascript; <script type=""module"">; import { openFile, draw } from 'https://root.cern/js/latest/modules/gui.mjs';; // ...; </script>; ```. In the main `<div>` element one can specify many custom parameters like one do it in URL string:. ```html; <div id=""simpleGUI"" path=""files/path"" files=""userfile1.root;subdir/usefile2.root"">; loading scripts ...; </div>; ```. ## Reading local ROOT files. JSROOT can read files from local file system using HTML5 FileReader functionality.; Main limitation here - user should interactively select files for reading.; There is button __""...""__ on the main JSROOT page, which starts file selection dialog.; If valid ROOT file is selected, JSROOT will be able to normally read content of such file. ## JSROOT with THttpServer. THttpServer provides http access to objects from running ROOT application.; JSROOT is used to implement the user in",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/JSROOT/JSROOT.md:28857,simpl,simplified,28857,documentation/JSROOT/JSROOT.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/JSROOT/JSROOT.md,1,['simpl'],['simplified']
Usability,"e; * Proves values to be constant, and replaces them with constants; * Proves conditional branches to be unconditional. Note that this pass has a habit of making definitions be dead. It is a good; idea to run a :ref:`DCE <passes-dce>` pass sometime after running this pass. .. _passes-simplifycfg:. ``simplifycfg``: Simplify the CFG; ---------------------------------. Performs dead code elimination and basic block merging. Specifically:. * Removes basic blocks with no predecessors.; * Merges a basic block into its predecessor if there is only one and the; predecessor only has one successor.; * Eliminates PHI nodes for basic blocks with a single predecessor.; * Eliminates a basic block that only contains an unconditional branch. ``sink``: Code sinking; ----------------------. This pass moves instructions into successor blocks, when possible, so that they; aren't executed on paths where their results aren't needed. .. _passes-simple-loop-unswitch:. ``simple-loop-unswitch``: Unswitch loops; ----------------------------------------. This pass transforms loops that contain branches on loop-invariant conditions; to have multiple loops. For example, it turns the left into the right code:. .. code-block:: c++. for (...) if (lic); A for (...); if (lic) A; B; C; B else; C for (...); A; C. This can increase the size of the code exponentially (doubling it every time a; loop is unswitched) so we only unswitch if the resultant code will be smaller; than a threshold. This pass expects :ref:`LICM <passes-licm>` to be run before it to hoist; invariant conditions out of the loop, to make the unswitching opportunity; obvious. ``strip``: Strip all symbols from a module; ------------------------------------------. Performs code stripping. This transformation can delete:. * names for virtual registers; * symbols for internal globals and functions; * debug information. Note that this transformation makes code much less readable, so it should only; be used in situations where the strip utili",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Passes.rst:35393,simpl,simple-loop-unswitch,35393,interpreter/llvm-project/llvm/docs/Passes.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Passes.rst,1,['simpl'],['simple-loop-unswitch']
Usability,"e; developer asking for more review prevents any lingering disagreement over; code in the tree. This does not indicate any fault from the patch author,; this is inherent to our post-commit review practices.; Reverting a patch ensures that design discussions can happen without blocking; other development; it's entirely possible the patch will end up being reapplied; essentially as-is once concerns have been resolved. Before being recommitted, the patch generally should undergo further review.; The community member who identified the problem is expected to engage; actively in the review. In cases where the problem is identified by a buildbot,; a community member with access to hardware similar to that on the buildbot is; expected to engage in the review. Please note: The bar for post-commit feedback is not higher than for pre-commit; feedback. Don't delay unnecessarily in providing feedback. However, if you see; something after code has been committed about which you would have commented; pre-commit (had you noticed it earlier), please feel free to provide that; feedback at any time. That having been said, if a substantial period of time has passed since the; original change was committed, it may be better to create a new patch to; address the issues than comment on the original commit. The original patch; author, for example, might no longer be an active contributor to the project. What Tools Are Used for Code Review?; ------------------------------------. Pre-commit code reviews are conducted on GitHub with Pull Requests. See; :ref:`GitHub <github-reviews>` documentation. When Is an RFC Required?; ------------------------. Some changes are too significant for just a code review. Changes that should; change the LLVM Language Reference (e.g., adding new target-independent; intrinsics), adding language extensions in Clang, and so on, require an RFC; (Request for Comment) email on the project's ``*-dev`` mailing list first. For; changes that promise significant impact o",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodeReview.rst:3425,feedback,feedback,3425,interpreter/llvm-project/llvm/docs/CodeReview.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodeReview.rst,1,['feedback'],['feedback']
Usability,"e; execution of at least one cycle header, or ``X`` itself is a cycle; header. In reducible cycles (natural loops), each execution of the header is; equivalent to the start of a new iteration of the cycle. But this; analogy breaks down in the presence of explicit constraints on the; converged-with relation, such as those described in :ref:`future; work<convergence-note-convergence>`. Instead, cycle headers should be; treated as implicit *points of convergence* in a maximal; converged-with relation. Consider a sequence of nested cycles ``C1``, ``C2``, ..., ``Ck`` such; that ``C1`` is the outermost cycle and ``Ck`` is the innermost cycle,; with headers ``H1``, ``H2``, ..., ``Hk`` respectively. When a thread; enters the cycle ``Ck``, any of the following is possible:. 1. The thread directly entered cycle ``Ck`` without having executed; any of the headers ``H1`` to ``Hk``. 2. The thread executed some or all of the nested headers one or more; times. The maximal converged-with relation captures the following intuition; about cycles:. 1. When two threads enter a top-level cycle ``C1``, they execute; converged dynamic instances of every node that is a :ref:`child; <cycle-parent-block>` of ``C1``. 2. When two threads enter a nested cycle ``Ck``, they execute; converged dynamic instances of every node that is a child of; ``Ck``, until either thread exits ``Ck``, if and only if they; executed converged dynamic instances of the last nested header that; either thread encountered. Note that when a thread exits a nested cycle ``Ck``, it must follow; a closed path outside ``Ck`` to reenter it. This requires executing; the header of some outer cycle, as described earlier. Consider two dynamic instances ``X1`` and ``X2`` produced by threads ``T1``; and ``T2`` for a node ``X`` that is a child of nested cycle ``Ck``.; Maximal convergence relates ``X1`` and ``X2`` as follows:. 1. If neither thread executed any header from ``H1`` to ``Hk``, then; ``X1`` and ``X2`` are converged. 2. Otherw",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ConvergenceAndUniformity.rst:12401,intuit,intuition,12401,interpreter/llvm-project/llvm/docs/ConvergenceAndUniformity.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ConvergenceAndUniformity.rst,1,['intuit'],['intuition']
Usability,"e; provided in the ``DependenceGraphBuilder`` class, while the ``DDGBuilder``; and ``PDGBuilder`` control some aspects of how the graph is constructed; by the way of overriding virtual methods defined in ``DependenceGraphBuilder``. Note also that the steps and the names used in this diagram are for; illustrative purposes and may be different from those in the actual; implementation. Design Trade-offs; -----------------. Advantages:; ^^^^^^^^^^^; - Builder allows graph construction code to be reused for DDG and PDG.; - Builder allows us to create DDG and PDG as separate graphs.; - DDG nodes and edges are completely disjoint from PDG nodes and edges allowing them to change easily and independently. Disadvantages:; ^^^^^^^^^^^^^^; - Builder may be perceived as over-engineering at first.; - There are some similarities between DDG nodes and edges compared to PDG nodes and edges, but there is little reuse of the class definitions. - This is tolerable given that the node and edge types are fairly simple and there is little code reuse opportunity anyway. .. _implementation-details:. Implementation Details; ======================. The current implementation of DDG differs slightly from the dependence; graph described in [1]_ in the following ways:. 1. The graph nodes in the paper represent three main program components, namely *assignment statements*, *for loop headers* and *while loop headers*. In this implementation, DDG nodes naturally represent LLVM IR instructions. An assignment statement in this implementation typically involves a node representing the ``store`` instruction along with a number of individual nodes computing the right-hand-side of the assignment that connect to the ``store`` node via a def-use edge. The loop header instructions are not represented as special nodes in this implementation because they have limited uses and can be easily identified, for example, through ``LoopAnalysis``.; 2. The paper describes five types of dependency edges between nodes n",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/DependenceGraphs/index.rst:4716,simpl,simple,4716,interpreter/llvm-project/llvm/docs/DependenceGraphs/index.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/DependenceGraphs/index.rst,1,['simpl'],['simple']
Usability,"e; regression tests to ensure everything is in working order. * CMake will generate build targets for each tool and library, and most; LLVM sub-projects generate their own ``check-<project>`` target. * Running a serial build will be **slow**. To improve speed, try running a; parallel build. That's done by default in Ninja; for ``make``, use the; option ``-j NN``, where ``NN`` is the number of parallel jobs, e.g. the; number of available CPUs. * A basic CMake and build/test invocation which only builds LLVM and no other; subprojects:. ``cmake -S llvm -B build -G Ninja -DCMAKE_BUILD_TYPE=Debug``. ``ninja -C build check-llvm``. This will setup an LLVM build with debugging info, then compile LLVM and; run LLVM tests. * For more detailed information on CMake options, see `CMake <CMake.html>`__. * If you get build or test failures, see `below`_. Consult the `Getting Started with LLVM`_ section for detailed information on; configuring and compiling LLVM. Go to `Directory Layout`_ to learn about the; layout of the source code tree. Stand-alone Builds; ------------------. Stand-alone builds allow you to build a sub-project against a pre-built; version of the clang or llvm libraries that is already present on your; system. You can use the source code from a standard checkout of the llvm-project; (as described above) to do stand-alone builds, but you may also build; from a :ref:`sparse checkout<workflow-multicheckout-nocommit>` or from the; tarballs available on the `releases <https://github.com/llvm/llvm-project/releases/>`_; page. For stand-alone builds, you must have an llvm install that is configured; properly to be consumable by stand-alone builds of the other projects.; This could be a distro provided LLVM install, or you can build it yourself,; like this:. .. code-block:: console. cmake -G Ninja -S path/to/llvm-project/llvm -B $builddir \; -DLLVM_INSTALL_UTILS=ON \; -DCMAKE_INSTALL_PREFIX=/path/to/llvm/install/prefix \; < other options >. ninja -C $builddir install. Onc",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GettingStarted.rst:5077,learn,learn,5077,interpreter/llvm-project/llvm/docs/GettingStarted.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GettingStarted.rst,1,['learn'],['learn']
Usability,"e; reviewer has experience with the area of LLVM and knows the design goals; well. The author of a change will often assign a specific reviewer (git; blame and git log can be useful to find one). As our change is fairly simple, we'll add the cfe-commits mailing list; as a subscriber; anyone who works on clang can likely pick up the; review. (For changes outside clang, llvm-commits is the usual list. See; `http://lists.llvm.org/ <http://lists.llvm.org/mailman/listinfo>`__ for; all the \*-commits mailing lists). Uploading a change for review; -----------------------------. LLVM code reviews happen through pull-request on GitHub, see; :ref:`GitHub <github-reviews>` documentation for how to open; a pull-request on GitHub. Review process; --------------. When you open a pull-request, some automation will add a comment and; notify different member of the projects depending on the component you; changed.; Within a few days, someone should start the review. They may add; themselves as a reviewer, or simply start leaving comments. You'll get; another email any time the review is updated. The details are in the; `https://llvm.org/docs/CodeReview/ <https://llvm.org/docs/CodeReview.html>`__. Comments; ~~~~~~~~. The reviewer can leave comments on the change, and you can reply. Some; comments are attached to specific lines, and appear interleaved with the; code. You can either reply to these, or address them and mark them as; ""done"". Note that in-line replies are **not** sent straight away! They; become ""draft"" comments and you must click ""Submit"" at the bottom of the; page. Updating your change; ~~~~~~~~~~~~~~~~~~~~. If you make changes in response to a reviewer's comments, simply update; your branch with more commits and push to your fork. It may be a good; idea to answer the comments from the reviewer explicitly. Accepting a revision; ~~~~~~~~~~~~~~~~~~~~. When the reviewer is happy with the change, they will **Accept** the; revision. They may leave some more minor comments th",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MyFirstTypoFix.rst:10098,simpl,simply,10098,interpreter/llvm-project/llvm/docs/MyFirstTypoFix.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MyFirstTypoFix.rst,1,['simpl'],['simply']
Usability,"e; sure 'dot' and 'gv' are in your path. If you are running on macOS, download; and install the macOS `Graphviz program; <http://www.pixelglow.com/graphviz/>`_ and add; ``/Applications/Graphviz.app/Contents/MacOS/`` (or wherever you install it) to; your path. The programs need not be present when configuring, building or; running LLVM and can simply be installed when needed during an active debug; session. ``SelectionDAG`` has been extended to make it easier to locate *interesting*; nodes in large complex graphs. From gdb, if you ``call DAG.setGraphColor(node,; ""color"")``, then the next ``call DAG.viewGraph()`` would highlight the node in; the specified color (choices of colors can be found at `colors; <http://www.graphviz.org/doc/info/colors.html>`_.) More complex node attributes; can be provided with ``call DAG.setGraphAttrs(node, ""attributes"")`` (choices can; be found at `Graph attributes <http://www.graphviz.org/doc/info/attrs.html>`_.); If you want to restart and clear all the current graph attributes, then you can; ``call DAG.clearGraphAttrs()``. Note that graph visualization features are compiled out of Release builds to; reduce file size. This means that you need a Debug+Asserts or Release+Asserts; build to use these features. .. _datastructure:. Picking the Right Data Structure for a Task; ===========================================. LLVM has a plethora of data structures in the ``llvm/ADT/`` directory, and we; commonly use STL data structures. This section describes the trade-offs you; should consider when you pick one. The first step is a choose your own adventure: do you want a sequential; container, a set-like container, or a map-like container? The most important; thing when choosing a container is the algorithmic properties of how you plan to; access the container. Based on that, you should use:. * a :ref:`map-like <ds_map>` container if you need efficient look-up of a; value based on another value. Map-like containers also support efficient; queries f",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:54482,clear,clear,54482,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,1,['clear'],['clear']
Usability,"e; used is when we want that a volume positioned inside a container to; match one ore more container limits. Suppose we want to position the; same box inside 2 different volumes and we want the Z size to match the; one of each container:. ~~~{.cpp}; TGeoVolume *container1 = gGeoManager->MakeBox(""C1"",imed,10,10,30);; TGeoVolume *container2 = gGeoManager->MakeBox(""C2"",imed,10,10,20);; TGeoVolume *pvol = gGeoManager->MakeBox(""PVOL"",jmed,3,3,-1);; container1->AddNode(pvol,1);; container2->AddNode(pvol,1);; ~~~. Note that the third parameter of `PVOL` is negative, which does not make; sense as half-length on Z. This is interpreted as: when positioned,; create a box replacing all invalid parameters with the corresponding; dimensions of the container. This is also internally handled by the; **`TGeoVolumeMulti`** class, which does not need to be instantiated by; users. \anchor GP01bi; #### Dividing Volumes. Volumes can be divided according a pattern. The simplest division can be; done along one axis that can be: `X,Y,Z,Phi,Rxy or Rxyz`. Let's take a; simple case: we would like to divide a box in N equal slices along X; coordinate, representing a new volume family. Supposing we already have; created the initial box, this can be done like:. ~~~{.cpp}; TGeoVolume *slicex = box->Divide(""SLICEX"",1,N);; ~~~. Here `SLICEX` is the name of the new family representing all slices and; 1 is the slicing axis. The meaning of the axis index is the following:; for all volumes having shapes like `box`, `trd1`, `trd2`, `trap`,; `gtra `or` para - `1, 2, 3 mean X, Y, Z; for `tube`, `tubs`, `cone`,; `cons - `1 means `Rxy`, 2 means `phi` and 3 means Z; for `pcon` and; `pgon` - 2 means `phi` and 3 means Z; for spheres 1 means `R `and 2; means `phi.`. In fact, the division operation has the same effect as positioning; volumes in a given order inside the divided container - the advantage; being that the navigation in such a structure is much faster. When a; volume is divided, a volume family corres",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md:44231,simpl,simplest,44231,geom/geom/doc/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md,1,['simpl'],['simplest']
Usability,"eMapper`` method:. .. code-block:: c++. int main(int argc, char *argv[]) {; ExitOnErr.setBanner(std::string(argv[0]) + "" error:"");; ExitOnErr.setExitCodeMapper(; [](const Error &Err) {; if (Err.isA<BadFileFormat>()); return 2;; return 1;; });. Use ``ExitOnError`` in your tool code where possible as it can greatly improve; readability. .. _err_cantfail:. Using cantFail to simplify safe callsites; """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""". Some functions may only fail for a subset of their inputs, so calls using known; safe inputs can be assumed to succeed. The cantFail functions encapsulate this by wrapping an assertion that their; argument is a success value and, in the case of Expected<T>, unwrapping the; T value:. .. code-block:: c++. Error onlyFailsForSomeXValues(int X);; Expected<int> onlyFailsForSomeXValues2(int X);. void foo() {; cantFail(onlyFailsForSomeXValues(KnownSafeValue));; int Y = cantFail(onlyFailsForSomeXValues2(KnownSafeValue));; ...; }. Like the ExitOnError utility, cantFail simplifies control flow. Their treatment; of error cases is very different however: Where ExitOnError is guaranteed to; terminate the program on an error input, cantFail simply asserts that the result; is success. In debug builds this will result in an assertion failure if an error; is encountered. In release builds the behavior of cantFail for failure values is; undefined. As such, care must be taken in the use of cantFail: clients must be; certain that a cantFail wrapped call really can not fail with the given; arguments. Use of the cantFail functions should be rare in library code, but they are; likely to be of more use in tool and unit-test code where inputs and/or; mocked-up classes or functions may be known to be safe. Fallible constructors; """""""""""""""""""""""""""""""""""""""""". Some classes require resource acquisition or other complex initialization that; can fail during construction. Unfortunately constructors can't return errors,; and having clients test objects after they're constr",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:32680,simpl,simplifies,32680,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,1,['simpl'],['simplifies']
Usability,"ean they are reordered to be on top of the others. To; interactively make an object ""active"", you can use the middle mouse; button. In case of canvases or pads, the border becomes highlighted when; it is active. #### With C++ Statements (Programmatically). Frequently we want to draw in different canvases or pads. By default,; the objects are drawn in the active canvas. To activate a canvas you can; use the `TPad::cd()` method. ``` {.cpp}; root[] c1->cd(); ```. ### Context Menus: the Right Mouse Button. The context menus are a way to interactively call certain methods of an; object. When designing a class, the programmer can add methods to the; context menu of the object by making minor changes to the header file. #### Using Context Menus. On a ROOT canvas, you can right-click on any object and see the context; menu for it. The script `hsimple.C` draws a histogram. The image below; shows the context menus for some of the objects on the canvas. Next; picture shows that drawing a simple histogram involves as many as seven; objects. When selecting a method from the context menu and that method; has options, the user will be asked for numerical values or strings to; fill in the option. For example, `TAxis::SetTitle` will prompt you for a; string to use for the axis title. ![Context menus of different objects in a canvas](pictures/030000A0.png). #### Structure of the Context Menus. The curious reader will have noticed that each entry in the context menu; corresponds to a method of the class. Look for example to the menu named; `TAxis::xaxis`. `xaxis` is the name of the object and **`TAxis`** the; name of its class. If we look at the list of **`TAxis`** methods, for; example in <https://root.cern/doc/master/classTAxis.html>, we see the; methods `SetTimeDisplay()` and` UnZoom()`, which appear also in the; context menu. There are several divisions in the context menu, separated by lines. The; top division is a list of the class methods; the second division is a; list of the ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md:4649,simpl,simple,4649,documentation/users-guide/Graphics.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md,1,['simpl'],['simple']
Usability,"earch=product%3Aclang+component%3A-New%2BBugs%2CAST%2CBasic%2CDriver%2CHeaders%2CLLVM%2BCodeGen%2Cparser%2Cpreprocessor%2CSemantic%2BAnalyzer>`_; for known existing bugs (FIXME: Is there a section for bug-reporting; guidelines somewhere?). Intentionally unsupported GCC extensions; ----------------------------------------. - clang does not support the gcc extension that allows variable-length; arrays in structures. This is for a few reasons: one, it is tricky to; implement, two, the extension is completely undocumented, and three,; the extension appears to be rarely used. Note that clang *does*; support flexible array members (arrays with a zero or unspecified; size at the end of a structure).; - GCC accepts many expression forms that are not valid integer constant; expressions in bit-field widths, enumerator constants, case labels,; and in array bounds at global scope. Clang also accepts additional; expression forms in these contexts, but constructs that GCC accepts due to; simplifications GCC performs while parsing, such as ``x - x`` (where ``x`` is a; variable) will likely never be accepted by Clang.; - clang does not support ``__builtin_apply`` and friends; this extension; is extremely obscure and difficult to implement reliably. .. _c_ms:. Microsoft extensions; --------------------. clang has support for many extensions from Microsoft Visual C++. To enable these; extensions, use the ``-fms-extensions`` command-line option. This is the default; for Windows targets. Clang does not implement every pragma or declspec provided; by MSVC, but the popular ones, such as ``__declspec(dllexport)`` and ``#pragma; comment(lib)`` are well supported. clang has a ``-fms-compatibility`` flag that makes clang accept enough; invalid C++ to be able to parse most Microsoft headers. For example, it; allows `unqualified lookup of dependent base class members; <https://clang.llvm.org/compatibility.html#dep_lookup_bases>`_, which is; a common compatibility issue with clang. This flag is",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:136215,simpl,simplifications,136215,interpreter/llvm-project/clang/docs/UsersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst,1,['simpl'],['simplifications']
Usability,"earned some parsing techniques, how to build and represent; an AST, how to build LLVM IR, and how to optimize the resultant code as; well as JIT compile it. While Kaleidoscope is interesting as a functional language, the fact; that it is functional makes it ""too easy"" to generate LLVM IR for it. In; particular, a functional language makes it very easy to build LLVM IR; directly in `SSA; form <http://en.wikipedia.org/wiki/Static_single_assignment_form>`_.; Since LLVM requires that the input code be in SSA form, this is a very; nice property and it is often unclear to newcomers how to generate code; for an imperative language with mutable variables. The short (and happy) summary of this chapter is that there is no need; for your front-end to build SSA form: LLVM provides highly tuned and; well tested support for this, though the way it works is a bit; unexpected for some. Why is this a hard problem?; ===========================. To understand why mutable variables cause complexities in SSA; construction, consider this extremely simple C example:. .. code-block:: c. int G, H;; int test(_Bool Condition) {; int X;; if (Condition); X = G;; else; X = H;; return X;; }. In this case, we have the variable ""X"", whose value depends on the path; executed in the program. Because there are two different possible values; for X before the return instruction, a PHI node is inserted to merge the; two values. The LLVM IR that we want for this example looks like this:. .. code-block:: llvm. @G = weak global i32 0 ; type of @G is i32*; @H = weak global i32 0 ; type of @H is i32*. define i32 @test(i1 %Condition) {; entry:; br i1 %Condition, label %cond_true, label %cond_false. cond_true:; %X.0 = load i32, i32* @G; br label %cond_next. cond_false:; %X.1 = load i32, i32* @H; br label %cond_next. cond_next:; %X.2 = phi i32 [ %X.1, %cond_false ], [ %X.0, %cond_true ]; ret i32 %X.2; }. In this example, the loads from the G and H global variables are; explicit in the LLVM IR, and they live in t",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl07.rst:1561,simpl,simple,1561,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl07.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl07.rst,1,['simpl'],['simple']
Usability,"easily remembered. With check boxes all; alternatives are visible: it is easy to access and compare choices; because they can all be seen together. Each option acts as a switch and; can be either ""on"" or ""off"". It is never changed in contents. Checkboxes; differ from radio buttons in that they permit selection of more than one; alternative. Each box can be switched on or off independently. These; buttons can be used alone or grouped in sets. It is good practice to; provide default settings for check boxes whenever it is possible. ![](pictures/03000213.png). This can be done by:. ``` {.cpp}; SetState(EButtonState state); ```. The parameter state can be one of `kButtonUp`, `kButtonDown`,; `kButtonEngaged`, `kButtonDisabled`. Check boxes can be used to affect other controls. The contents of a list; can, for example, be filtered by setting a check box. In any case, use a; check box only when both states of a choice are clearly opposite and; unambiguous. If opposite states are not clear, it is better to use two; radio buttons. Choice description, i.e. check box label, must be clear, meaningful,; fully spelled out, and displayed in mixed-type text. Whenever the use of; a given button is inappropriate, for whatever reason, that button should; be disabled:. ``` {.cpp}; button->SetState(kButtonDisabled);; ```. Never make a button appear and disappear. In general, option buttons should not offer more than eight choices. If; the number of choices exceeds this maximum, it is better to use a; multiple selection list box. The method `IsToggleButton()` gives the information whether a radio; button or a check button is selected. An option button can be set or; unset via its method `PSetState(EButtonState state).`. The method `HandleKey(event)` is called when the defined hotkey is hit; for any button. It sets the selected option button or clicks the; selected text button and invokes its defined action. ### Text Entries. A **`TGTextEntry`** is a one-line text input widget. It contain",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md:63200,clear,clear,63200,documentation/users-guide/WritingGUI.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md,1,['clear'],['clear']
Usability,"eated notebooks with viewers like https://nbviewer.jupyter.org/; - Fix problem with using of local JSROOT version. ## Tutorials. - The tutorial games.C was not working properly. - Improve tutorial ErrorIntegral.C. - Schrödinger's Hydrogen Atom example. - Tutorial demonstrating how the changing of the range can zoom into the histogram. - Tutorial demonstrating how a Histogram can be read from a ROOT File. - histMax.C: a tutorial demoing how the hist->GetMaximumBin() can be used. ## Class Reference Guide. - Images for ROOT7 tutorials can be generated, in json format, using the directive using; `\macro_image (json)` in the macro header. - Clarify THStack drawing options. - Add missing documentation to TH1 functions. - Restructure the math reference guide. - Make the web gui documentation visible in the reference guide. - Make clear THtml is legacy code. Add deprecated flag on PROOF and TGeoTrack. - Improve many classes documentation: TContext, TTreePlayer, THistPainter, TGraph, TSelector,; integrator, GUI, TH1, TH2, TH3, TColor classes ... - Make the TFile layout doc visible in Reference Guide. - Update the external links of the reference guide main page. - Reformat TMVA mathcore Unuran Roostats documentation . ## Build, Configuration and Testing Infrastructure. - For users building from source the `latest-stable` branch and passing `-Droottest=ON` to the CMake command line, the corresponding revision of roottest pointed to by `latest-stable` will be downloaded as required. ## PyROOT. - The `ROOT` Python module is now properly serializable so that it is automatically available in the Python environment if a function or ROOT object needs to be serialized. See issue [#6764](https://github.com/root-project/root/issues/6764) for a concrete usecase.; - Improve overload resolution of functions that accept classes with long inheritance trees. Now prefer to call the function overload of the most derived class type (PR [#9092](https://github.com/root-project/root/pull/9092)).; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v626/index.md:39311,guid,guide,39311,README/ReleaseNotes/v626/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v626/index.md,1,['guid'],['guide']
Usability,"ec), [](const std::string &fieldName) {; if (fieldName == ""aliasVec"") return ""vec"";; else return ""vec._0"";; });; ```; Projected fields are stored as part of the metadata. - Improvements on the internal `RField` value API. The `RFieldValue` class has been deprecated in favor of `RField::Value` and the related interfaces have changed accordingly (see [#13219](https://github.com/root-project/root/pull/13219) and [#13264](https://github.com/root-project/root/pull/13264)).; If you were not using `RField::(Read|Append)` directly, this change should not impact you. - The new `RNTupleImporter` class provides automatic conversion of TTree to RNTuple.; Note that not all of the C++ types supported in TTree are currently supported in RNTuple. - Many bug fixes and performance improvements. Please, report any issues regarding the abovementioned features should you encounter them.; RNTuple is still experimental and is scheduled to become production grade by end of 2024.; Thus, we appreciate feedback and suggestions for improvement. ## Histogram Libraries. ## Math Libraries. ### Minuit2 is now the default minimizer. Many ROOT-based frameworks and users employ Minuit2 as the minimizer of choice for a long time already.; Therefore, Minuit2 is now the default minimizer used by ROOT.; This affects also **RooFit**, which inherits the default minimizer from ROOT Math. The default can be changed back to the old Minuit implementation as follows:; ```c++; ROOT::Math::MinimizerOptions::SetDefaultMinimizer(""Minuit"");; ```. Alternatively, you can add this line to your `~/.rootrc` file:; ```; Root.Fitter: Minuit; ```. ### Behavior change of `TMath::AreEqualAbs()`. The `TMath::AreEqualAbs()` compares two numbers for equality within a certain absolute range.; So far, it would tell you that `inf != inf` if you define `inf` as `std::numeric_limits<double>::infinity()`, which is inconsistent with the regular `==` operator. This is unexpected, because one would expect that if two numbers are considere",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v630/index.md:9925,feedback,feedback,9925,README/ReleaseNotes/v630/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v630/index.md,1,['feedback'],['feedback']
Usability,"econd argument of the `coro.suspend`_ intrinsic to `true`.; Such a suspend point has two properties:. * it is possible to check whether a suspended coroutine is at the final suspend; point via `coro.done`_ intrinsic;. * a resumption of a coroutine stopped at the final suspend point leads to; undefined behavior. The only possible action for a coroutine at a final; suspend point is destroying it via `coro.destroy`_ intrinsic. From the user perspective, the final suspend point represents an idea of a; coroutine reaching the end. From the compiler perspective, it is an optimization; opportunity for reducing number of resume points (and therefore switch cases) in; the resume function. The following is an example of a function that keeps resuming the coroutine; until the final suspend point is reached after which point the coroutine is; destroyed:. .. code-block:: llvm. define i32 @main() {; entry:; %hdl = call ptr @f(i32 4); br label %while; while:; call void @llvm.coro.resume(ptr %hdl); %done = call i1 @llvm.coro.done(ptr %hdl); br i1 %done, label %end, label %while; end:; call void @llvm.coro.destroy(ptr %hdl); ret i32 0; }. Usually, final suspend point is a frontend injected suspend point that does not; correspond to any explicitly authored suspend point of the high level language.; For example, for a Python generator that has only one suspend point:. .. code-block:: python. def coroutine(n):; for i in range(n):; yield i. Python frontend would inject two more suspend points, so that the actual code; looks like this:. .. code-block:: c. void* coroutine(int n) {; int current_value;; <designate current_value to be coroutine promise>; <SUSPEND> // injected suspend point, so that the coroutine starts suspended; for (int i = 0; i < n; ++i) {; current_value = i; <SUSPEND>; // corresponds to ""yield i""; }; <SUSPEND final=true> // injected final suspend point; }. and python iterator `__next__` would look like:. .. code-block:: c++. int __next__(void* hdl) {; coro.resume(hdl);; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst:25587,resume,resume,25587,interpreter/llvm-project/llvm/docs/Coroutines.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst,1,['resume'],['resume']
Usability,"ecord stream, and are referenced from this stream. - **PdbDllVersion** - The version number of ``mspdbXXXX.dll`` used to produce this; PDB. Note this obviously does not apply for LLVM as LLVM does not use ``mspdb.dll``. - **SymRecordStream** - The stream containing all CodeView symbol records used; by the program. This is used for deduplication, so that many different; compilands can refer to the same symbols without having to include the full record; content inside of each module stream. - **PdbDllRbld** - Unknown. - **MFCTypeServerIndex** - The index of the MFC type server in the; :ref:`dbi_type_server_map_substream`. - **Flags** - A bitfield with the following layout, containing various; information about how the program was built:. .. code-block:: c++. uint16_t WasIncrementallyLinked : 1;; uint16_t ArePrivateSymbolsStripped : 1;; uint16_t HasConflictingTypes : 1;; uint16_t Reserved : 13;. The only one of these that is not self-explanatory is ``HasConflictingTypes``.; Although undocumented, ``link.exe`` contains a hidden flag ``/DEBUG:CTYPES``.; If it is passed to ``link.exe``, this field will be set. Otherwise it will; not be set. It is unclear what this flag does, although it seems to have; subtle implications on the algorithm used to look up type records. - **Machine** - A value from the `CV_CPU_TYPE_e <https://msdn.microsoft.com/en-us/library/b2fc64ek.aspx>`__; enumeration. Common values are ``0x8664`` (x86-64) and ``0x14C`` (x86). Immediately after the fixed-size DBI Stream header are ``7`` variable-length; `substreams`. The following ``7`` fields of the DBI Stream header specify the; number of bytes of the corresponding substream. Each substream's contents will; be described in detail :ref:`below <dbi_substreams>`. The length of the entire; DBI Stream should equal ``64`` (the length of the header above) plus the value; of each of the following ``7`` fields. - **ModInfoSize** - The length of the :ref:`dbi_mod_info_substream`. - **SectionContributionSize** - ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/PDB/DbiStream.rst:3985,undo,undocumented,3985,interpreter/llvm-project/llvm/docs/PDB/DbiStream.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/PDB/DbiStream.rst,1,['undo'],['undocumented']
Usability,"ecords are passed on; to various *backends*, which extract information from a subset of the records; and generate one or more output files. These output files are typically; ``.inc`` files for C++, but may be any type of file that the backend; developer needs. This document describes the LLVM TableGen facility in detail. It is intended; for the programmer who is using TableGen to produce code for a project. If; you are looking for a simple overview, check out the :doc:`TableGen Overview; <./index>`. The various ``*-tblgen`` commands used to invoke TableGen are; described in :doc:`tblgen Family - Description to C++; Code<../CommandGuide/tblgen>`. An example of a backend is ``RegisterInfo``, which generates the register; file information for a particular target machine, for use by the LLVM; target-independent code generator. See :doc:`TableGen Backends <./BackEnds>`; for a description of the LLVM TableGen backends, and :doc:`TableGen; Backend Developer's Guide <./BackGuide>` for a guide to writing a new; backend. Here are a few of the things backends can do. * Generate the register file information for a particular target machine. * Generate the instruction definitions for a target. * Generate the patterns that the code generator uses to match instructions; to intermediate representation (IR) nodes. * Generate semantic attribute identifiers for Clang. * Generate abstract syntax tree (AST) declaration node definitions for Clang. * Generate AST statement node definitions for Clang. Concepts; --------. TableGen source files contain two primary items: *abstract records* and; *concrete records*. In this and other TableGen documents, abstract records; are called *classes.* (These classes are different from C++ classes and do; not map onto them.) In addition, concrete records are usually just called; records, although sometimes the term *record* refers to both classes and; concrete records. The distinction should be clear in context. Classes and concrete records have a unique",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TableGen/ProgRef.rst:1517,guid,guide,1517,interpreter/llvm-project/llvm/docs/TableGen/ProgRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TableGen/ProgRef.rst,1,['guid'],['guide']
Usability,"ect: RE: LLVM Concerns... > 1. Reference types; > Right now, I've spec'd out the language to have a pointer type, which; > works fine for lots of stuff... except that Java really has; > references: constrained pointers that cannot be manipulated: added and; > subtracted, moved, etc... Do we want to have a type like this? It; > could be very nice for analysis (pointer always points to the start of; > an object, etc...) and more closely matches Java semantics. The; > pointer type would be kept for C++ like semantics. Through analysis,; > C++ pointers could be promoted to references in the LLVM; > representation. You're right, having references would be useful. Even for C++ the *static*; compiler could generate references instead of pointers with fairly; straightforward analysis. Let's include a reference type for now. But I'm; also really concerned that LLVM is becoming big and complex and (perhaps); too high-level. After we get some initial performance results, we may have; a clearer idea of what our goals should be and we should revisit this; question then. > 2. Our ""implicit"" memory references in assembly language:; > After thinking about it, this model has two problems:; > A. If you do pointer analysis and realize that two stores are; > independent and can share the same memory source object,. not sure what you meant by ""share the same memory source object"". > there is; > no way to represent this in either the bytecode or assembly.; > B. When parsing assembly/bytecode, we effectively have to do a full; > SSA generation/PHI node insertion pass to build the dependencies; > when we don't want the ""pinned"" representation. This is not; > cool. I understand the concern. But again, let's focus on the performance first; and then look at the language design issues. E.g., it would be good to know; how big the bytecode files are before expanding them further. I am pretty; keen to explore the implications of LLVM for mobile devices. Both bytecode; size and power consumption a",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HistoricalNotes/2001-02-13-Reference-MemoryResponse.txt:1113,clear,clearer,1113,interpreter/llvm-project/llvm/docs/HistoricalNotes/2001-02-13-Reference-MemoryResponse.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HistoricalNotes/2001-02-13-Reference-MemoryResponse.txt,1,['clear'],['clearer']
Usability,"ected that; this list will change following experimentation:. * TableGen; * llvm/tools; * clang-tools-extra; * clang; * ARM backend; * AArch64 backend; * AMDGPU backend; * ARC backend; * AVR backend; * BPF backend; * Hexagon backend; * Lanai backend; * MIPS backend; * NVPTX backend; * PowerPC backend; * RISC-V backend; * Sparc backend; * SystemZ backend; * WebAssembly backend; * X86 backend; * XCore backend; * libLTO; * Debug Information; * Remainder of llvm; * compiler-rt; * libunwind; * openmp; * parallel-libs; * polly; * lldb. #. Remove the old variable name rule from the policy page. #. Repeat many of the steps in the sequence, using a script to expand acronyms. References; ==========. .. [LLDB] LLDB Coding Conventions https://llvm.org/svn/llvm-project/lldb/branches/release_39/www/lldb-coding-conventions.html; .. [Google] Google C++ Style Guide https://google.github.io/styleguide/cppguide.html#Variable_Names; .. [WebKit] WebKit Code Style Guidelines https://webkit.org/code-style-guidelines/#names; .. [Qt] Qt Coding Style https://wiki.qt.io/Qt_Coding_Style#Declaring_variables; .. [Rust] Rust naming conventions https://doc.rust-lang.org/1.0.0/style/style/naming/README.html; .. [Swift] Swift API Design Guidelines https://swift.org/documentation/api-design-guidelines/#general-conventions; .. [Python] Style Guide for Python Code https://www.python.org/dev/peps/pep-0008/#function-and-variable-names; .. [Mozilla] Mozilla Coding style: Prefixes https://firefox-source-docs.mozilla.org/tools/lint/coding-style/coding_style_cpp.html#prefixes; .. [SVE] LLVM with support for SVE https://github.com/ARM-software/LLVM-SVE; .. [AminiInconsistent] Mehdi Amini, http://lists.llvm.org/pipermail/llvm-dev/2019-February/130329.html; .. [ArsenaultAgree] Matt Arsenault, http://lists.llvm.org/pipermail/llvm-dev/2019-February/129934.html; .. [BeylsDistinguish] Kristof Beyls, http://lists.llvm.org/pipermail/llvm-dev/2019-February/130292.html; .. [BradburyConcern] Alex Bradbury, http://lists.l",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Proposals/VariableNames.rst:13602,guid,guidelines,13602,interpreter/llvm-project/llvm/docs/Proposals/VariableNames.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Proposals/VariableNames.rst,1,['guid'],['guidelines']
Usability,"ection below for more details, or see [the tutorial](https://root.cern/doc/master/rf408__RDataFrameToRooFit_8C.html). ### Notable changes in behavior. - Using `Alias`, it is now possible to register homonymous aliases (alternative column names) in different branches of the computation graph, in line with the behavior of `Define` (until now, aliases were required to be unique in the whole computaton graph).; - The `Histo*D` methods now support the combination of scalar values and vector-like weight values. For each entry, the histogram is filled once for each weight, always with the same scalar value.; - The `Histo*D` methods do not work on columns of type `std::string` anymore. They used to fill the histogram with the integer value corresponding to each of the characters in the string. Please use `Fill` with a custom class to recover the old behavior if that was what was desired. ### Other improvements. - The scaling to a large amount of threads of computation graphs with many simple `Filter`s or `Define`s has been greatly improved, see also [this talk](https://indico.cern.ch/event/1036730/#1-a-performance-study-of-the-r) for more details; - The output format of `Display` has been significantly improved.; - The `Fill` method now correctly supports user-defined classes with arbitrary `Fill` signatures (see [#9428](https://github.com/root-project/root/issues/9428)). ### Experimental Distributed RDataFrame. The distributed RDataFrame module has been improved. Now it supports sending RDataFrame tasks to a [Dask](https://dask.org/) scheduler. Through Dask, RDataFrame can be also scaled to a cluster of machines managed through a batch system like HTCondor or Slurm. Here is an example:. ```python; import ROOT; from dask.distributed import Client; RDataFrame = ROOT.RDF.Experimental.Distributed.Dask.RDataFrame. # In a Python script the Dask client needs to be initalized in a context; # Jupyter notebooks / Python session don't need this; if __name__ == ""__main__"":; client = Cl",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v626/index.md:9847,simpl,simple,9847,README/ReleaseNotes/v626/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v626/index.md,1,['simpl'],['simple']
Usability,"ects of the call must happen whether; the assert is enabled or not. In this case, the value should be cast to void to; disable the warning. To be specific, it is preferred to write the code like; this:. .. code-block:: c++. assert(V.size() > 42 && ""Vector smaller than it should be"");. bool NewToSet = Myset.insert(Value); (void)NewToSet;; assert(NewToSet && ""The value shouldn't be in the set yet"");. Do Not Use ``using namespace std``; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. In LLVM, we prefer to explicitly prefix all identifiers from the standard; namespace with an ""``std::``"" prefix, rather than rely on ""``using namespace; std;``"". In header files, adding a ``'using namespace XXX'`` directive pollutes the; namespace of any source file that ``#include``\s the header, creating; maintenance issues. In implementation files (e.g. ``.cpp`` files), the rule is more of a stylistic; rule, but is still important. Basically, using explicit namespace prefixes; makes the code **clearer**, because it is immediately obvious what facilities; are being used and where they are coming from. And **more portable**, because; namespace clashes cannot occur between LLVM code and other namespaces. The; portability rule is important because different standard library implementations; expose different symbols (potentially ones they shouldn't), and future revisions; to the C++ standard will add more symbols to the ``std`` namespace. As such, we; never use ``'using namespace std;'`` in LLVM. The exception to the general rule (i.e. it's not an exception for the ``std``; namespace) is for implementation files. For example, all of the code in the; LLVM project implements code that lives in the 'llvm' namespace. As such, it is; ok, and actually clearer, for the ``.cpp`` files to have a ``'using namespace; llvm;'`` directive at the top, after the ``#include``\s. This reduces; indentation in the body of the file for source editors that indent based on; braces, and keeps the conceptual context cleaner. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodingStandards.rst:49332,clear,clearer,49332,interpreter/llvm-project/llvm/docs/CodingStandards.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodingStandards.rst,1,['clear'],['clearer']
Usability,"ects; (""shapes"") - filled /added by negotiation with viewer via; **`TVirtualViewer3D`**. A typical interaction between viewer and client using these, taken from; **`TGeoPainter`** is:. ``` {.cpp}; TVirtualViewer3D * viewer = gPad->GetViewer3D();; // Does viewer prefer local frame positions?; Bool_t localFrame = viewer->PreferLocalFrame();; // Perform first fetch of buffer from the shape and try adding it to the viewer; const TBuffer3D &buffer = shape.GetBuffer3D(TBuffer3D::kCore |; TBuffer3D::kBoundingBox |; TBuffer3D::kShapeSpecific,; localFrame);; Int_t reqSections = viewer->AddObject(buffer, &addDaughters);. // If the viewer requires additional sections fetch from the shape; // (if possible) and add again; if (reqSections != TBuffer3D::kNone); shape.GetBuffer3D(reqSections, localFrame);; ```. Together these allow clients to publish objects to any one of the 3D; viewers free of viewer specific drawing code. They allow our simple x3d; viewer, and considerably more sophisticated OpenGL one to both work with; both geometry libraries (`g3d` and `geom`) efficiently. In addition to external viewers, created in separate windows, this; architecture is also used by internal **`TPad`** drawing when it; requires 3D projections. Publishing to a viewer consists of the; following steps:. 1- Create / obtain viewer handle. 2- Begin scene on viewer. 3- Fill mandatory parts of TBuffer3D describing object. 4- Add to viewer. 5- Fill optional parts of TBuffer3D as requested by viewer. [ .... repeat 3/4/5 as required for other/child objects]. 6- End scene on viewer. You should attach the top-level node of your external geometry (or the; manager) to a **`TPad`** object using **`TObject::Draw()`, and perform; the publishing to the viewer in your object's `TObject::Paint()`; overloaded method. See ""Scene Rebuilds"", and example scripts, for more; details.**. #### Creating / Obtaining Viewer Handle. External viewers are bound to a **`TPad`** object (this may be removed; as a requirement in t",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md:123775,simpl,simple,123775,documentation/users-guide/Graphics.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md,1,['simpl'],['simple']
Usability,"ed by a single call: `ROOT::EnableThreadSafety()` which is the successor of the existing `TThread::Initialize`. This call must take place if ROOT needs to be used in a thread safe manner. The implementation of TSemaphore was redone based on C++11 thread primitive in order to prevent cases where some of request post were lost. ### TDirectory::TContext. We added a default constructor to `TDirectory::TContext` which record the current directory; and will restore it at destruction time and does not change the current directory. The constructor for `TDirectory::TContext` that takes a single TDirectory pointer as; an argument was changed to set `gDirectory` to zero when being passed a null pointer;; previously it was interpreting a null pointer as a request to *not* change the current; directory - this behavior is now implement by the default constructor. ### Collections. In THashList and THashTable, GetListForObject now returns a pointer to const as modifying the returned list (in particular adding to it) can break invariant of THashTable so we need to clearly mark the list as not being allowed to be modified. In TSeqCollection::Merge, we no longer delete the object in the case where the original collection is marked as a owner. We resolved a memory leakage occuring as a consequence of repeated calls to `TClonesArray::AbsorbObjects` and `TClonesArray::Clear` [ROOT-6996]. A similar problem was affecting `TClonesArray::operator=`, `TClonesArray::Expand` and `TClonesArray::ExpandCreate` and was also solved. `TClonesArray` reliance on global state during the destruction of the elements was decreased (removing use of `TObject::SetDtorOnly`). ### Global resources. Several tweaks to if and when, resources held by the global ROOT object (TROOT, TApplication) are deleted. When the default TApplication is replaced by a user provide TApplication, do not call EndOfProcessCleanups and co. and thus do not delete TFiles, TSockets or TColors that have already been created. In EndOfProce",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v606/index.md:3719,clear,clearly,3719,README/ReleaseNotes/v606/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v606/index.md,1,['clear'],['clearly']
Usability,"ed from a thread. Some compilers, for example `gcc` version 2.95.2,; may not allow the `(void(*) (void*))s` cast and just stop if `Thread0`; is not static. On the other hand, if `Thread0` is static, no compiler; warnings are generated at all. Because the `'this'` pointer is passed in; `'arg'` in the call to `Thread0(void *arg),` you have access to the; instance of the class even if `Thread0` is static. Using the `'this'`; pointer, non static members can still be read and written from; `Thread0`, as long as you have provided Getter and Setter methods for; these members. For example:. ``` {.cpp}; Bool_t state = arg->GetRunStatus();; arg->SetRunStatus(state);; ```. Second, the pointer to the current instance of `Myclass`, i.e. (void\*); this, has to be passed as first argument of the threaded function; Thread0 (C++ member functions internally expect this pointer as first; argument to have access to class members of the same instance).; `pthreads` are made for simple C functions and do not know about Thread0; being a member function of a class. Thus, you have to pass this; information by hand, if you want to access all members of the `Myclass`; instance from the Thread0 function. Note: Method Thread0 cannot be a virtual member function, since the cast; of `Thread0` to `void(*)` in the **`TThread`** constructor may raise; problems with C++ virtual function table. However, Thread0 may call; another virtual member function virtual void `Myclass::Func0()` which; then can be overridden in a derived class of `Myclass`. (See example; `TMhs3`). Class `Myclass` may also provide a method to stop the running thread:. ``` {.cpp}; Int_t Myclass::Threadstop() {; if (mTh) {; TThread::Delete(mTh);; delete mTh;; mTh=0;; return 0;; }; return 1;; }; ```. Example `TMhs3:` Class **`TThreadframe`**; (`TThreadframe.h, TThreadframe.cxx`) is a simple example of a framework; class managing up to four threaded methods. Class `TMhs3`; (`TMhs3.h, TMhs3.cxx)` inherits from this base class, showing th",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Threads.md:15622,simpl,simple,15622,documentation/users-guide/Threads.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Threads.md,1,['simpl'],['simple']
Usability,"ed if the coroutine frame needs to be allocated dynamically.; The `coro.id`_ intrinsic serves as coroutine identity useful in cases when the; `coro.begin`_ intrinsic get duplicated by optimization passes such as; jump-threading. The `cleanup` block destroys the coroutine frame. The `coro.free`_ intrinsic,; given the coroutine handle, returns a pointer of the memory block to be freed or; `null` if the coroutine frame was not allocated dynamically. The `cleanup`; block is entered when coroutine runs to completion by itself or destroyed via; call to the `coro.destroy`_ intrinsic. The `suspend` block contains code to be executed when coroutine runs to; completion or suspended. The `coro.end`_ intrinsic marks the point where; a coroutine needs to return control back to the caller if it is not an initial; invocation of the coroutine. The `loop` blocks represents the body of the coroutine. The `coro.suspend`_; intrinsic in combination with the following switch indicates what happens to; control flow when a coroutine is suspended (default case), resumed (case 0) or; destroyed (case 1). Coroutine Transformation; ------------------------. One of the steps of coroutine lowering is building the coroutine frame. The; def-use chains are analyzed to determine which objects need be kept alive across; suspend points. In the coroutine shown in the previous section, use of virtual register; `%inc` is separated from the definition by a suspend point, therefore, it; cannot reside on the stack frame since the latter goes away once the coroutine; is suspended and control is returned back to the caller. An i32 slot is; allocated in the coroutine frame and `%inc` is spilled and reloaded from that; slot as needed. We also store addresses of the resume and destroy functions so that the; `coro.resume` and `coro.destroy` intrinsics can resume and destroy the coroutine; when its identity cannot be determined statically at compile time. For our; example, the coroutine frame will be:. .. code-bloc",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst:13682,resume,resumed,13682,interpreter/llvm-project/llvm/docs/Coroutines.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst,1,['resume'],['resumed']
Usability,"ed is not allowed in general.; (Specifically, in the case where another thread might write to and read; from an address, introducing a store can change a load that may see; exactly one write into a load that may see multiple writes.). .. _ordering:. Atomic Memory Ordering Constraints; ----------------------------------. Atomic instructions (:ref:`cmpxchg <i_cmpxchg>`,; :ref:`atomicrmw <i_atomicrmw>`, :ref:`fence <i_fence>`,; :ref:`atomic load <i_load>`, and :ref:`atomic store <i_store>`) take; ordering parameters that determine which other atomic instructions on; the same address they *synchronize with*. These semantics implement; the Java or C++ memory models; if these descriptions aren't precise; enough, check those specs (see spec references in the; :doc:`atomics guide <Atomics>`). :ref:`fence <i_fence>` instructions; treat these orderings somewhat differently since they don't take an; address. See that instruction's documentation for details. For a simpler introduction to the ordering constraints, see the; :doc:`Atomics`. ``unordered``; The set of values that can be read is governed by the happens-before; partial order. A value cannot be read unless some operation wrote; it. This is intended to provide a guarantee strong enough to model; Java's non-volatile shared variables. This ordering cannot be; specified for read-modify-write operations; it is not strong enough; to make them atomic in any interesting way.; ``monotonic``; In addition to the guarantees of ``unordered``, there is a single; total order for modifications by ``monotonic`` operations on each; address. All modification orders must be compatible with the; happens-before order. There is no guarantee that the modification; orders can be combined to a global total order for the whole program; (and this often will not be possible). The read in an atomic; read-modify-write operation (:ref:`cmpxchg <i_cmpxchg>` and; :ref:`atomicrmw <i_atomicrmw>`) reads the value in the modification; order immediately befo",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:152925,simpl,simpler,152925,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['simpl'],['simpler']
Usability,"ed to manipulate an existing; coroutine. They can be used in any function which happen to have a pointer; to a `coroutine frame`_ or a pointer to a `coroutine promise`_. .. _coro.destroy:. 'llvm.coro.destroy' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare void @llvm.coro.destroy(ptr <handle>). Overview:; """""""""""""""""". The '``llvm.coro.destroy``' intrinsic destroys a suspended; switched-resume coroutine. Arguments:; """""""""""""""""""". The argument is a coroutine handle to a suspended coroutine. Semantics:; """""""""""""""""""". When possible, the `coro.destroy` intrinsic is replaced with a direct call to; the coroutine destroy function. Otherwise it is replaced with an indirect call; based on the function pointer for the destroy function stored in the coroutine; frame. Destroying a coroutine that is not suspended leads to undefined behavior. .. _coro.resume:. 'llvm.coro.resume' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. ::. declare void @llvm.coro.resume(ptr <handle>). Overview:; """""""""""""""""". The '``llvm.coro.resume``' intrinsic resumes a suspended switched-resume coroutine. Arguments:; """""""""""""""""""". The argument is a handle to a suspended coroutine. Semantics:; """""""""""""""""""". When possible, the `coro.resume` intrinsic is replaced with a direct call to the; coroutine resume function. Otherwise it is replaced with an indirect call based; on the function pointer for the resume function stored in the coroutine frame.; Resuming a coroutine that is not suspended leads to undefined behavior. .. _coro.done:. 'llvm.coro.done' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. ::. declare i1 @llvm.coro.done(ptr <handle>). Overview:; """""""""""""""""". The '``llvm.coro.done``' intrinsic checks whether a suspended; switched-resume coroutine is at the final suspend point or not. Arguments:; """""""""""""""""""". The argument is a handle to a suspended coroutine. Semantics:; """""""""""""""""""". Using this intrinsic on a coroutine that does not have a `final suspend`_ point; or on a c",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst:27825,resume,resume,27825,interpreter/llvm-project/llvm/docs/Coroutines.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst,1,['resume'],['resume']
Usability,"ed with a null resume function. There is a somewhat complex protocol of intrinsics for allocating and; deallocating the coroutine object. It is complex in order to allow the; allocation to be elided due to inlining. This protocol is discussed; in further detail below. The frontend may generate code to call the coroutine function directly;; this will become a call to the ramp function and will return a pointer; to the coroutine object. The frontend should always resume or destroy; the coroutine using the corresponding intrinsics. Returned-Continuation Lowering; ------------------------------. In returned-continuation lowering, signaled by the use of; `llvm.coro.id.retcon` or `llvm.coro.id.retcon.once`, some aspects of; the ABI must be handled more explicitly by the frontend. In this lowering, every suspend point takes a list of ""yielded values""; which are returned back to the caller along with a function pointer,; called the continuation function. The coroutine is resumed by simply; calling this continuation function pointer. The original coroutine; is divided into the ramp function and then an arbitrary number of; these continuation functions, one for each suspend point. LLVM actually supports two closely-related returned-continuation; lowerings:. - In normal returned-continuation lowering, the coroutine may suspend; itself multiple times. This means that a continuation function; itself returns another continuation pointer, as well as a list of; yielded values. The coroutine indicates that it has run to completion by returning; a null continuation pointer. Any yielded values will be `undef`; should be ignored. - In yield-once returned-continuation lowering, the coroutine must; suspend itself exactly once (or throw an exception). The ramp; function returns a continuation function pointer and yielded; values, the continuation function may optionally return ordinary; results when the coroutine has run to completion. The coroutine frame is maintained in a fixed-size buf",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst:5712,resume,resumed,5712,interpreter/llvm-project/llvm/docs/Coroutines.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst,2,"['resume', 'simpl']","['resumed', 'simply']"
Usability,"ed with them will see many familiar elements. Where appropriate; we will make this connection with the earlier APIs explicit to help people who; are transitioning from them to ORC. JIT API Basics; ==============. The purpose of a JIT compiler is to compile code ""on-the-fly"" as it is needed,; rather than compiling whole programs to disk ahead of time as a traditional; compiler does. To support that aim our initial, bare-bones JIT API will have; just two functions:. 1. ``Error addModule(std::unique_ptr<Module> M)``: Make the given IR module; available for execution.; 2. ``Expected<ExecutorSymbolDef> lookup()``: Search for pointers to; symbols (functions or variables) that have been added to the JIT. A basic use-case for this API, executing the 'main' function from a module,; will look like:. .. code-block:: c++. JIT J;; J.addModule(buildModule());; auto *Main = J.lookup(""main"").getAddress().toPtr<int(*)(int, char *[])>();; int Result = Main();. The APIs that we build in these tutorials will all be variations on this simple; theme. Behind this API we will refine the implementation of the JIT to add; support for concurrent compilation, optimization and lazy compilation.; Eventually we will extend the API itself to allow higher-level program; representations (e.g. ASTs) to be added to the JIT. KaleidoscopeJIT; ===============. In the previous section we described our API, now we examine a simple; implementation of it: The KaleidoscopeJIT class [1]_ that was used in the; `Implementing a language with LLVM <LangImpl01.html>`_ tutorials. We will use; the REPL code from `Chapter 7 <LangImpl07.html>`_ of that tutorial to supply the; input for our JIT: Each time the user enters an expression the REPL will add a; new IR module containing the code for that expression to the JIT. If the; expression is a top-level expression like '1+1' or 'sin(x)', the REPL will also; use the lookup method of our JIT class find and execute the code for the; expression. In later chapters of this tu",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/BuildingAJIT1.rst:3420,simpl,simple,3420,interpreter/llvm-project/llvm/docs/tutorial/BuildingAJIT1.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/BuildingAJIT1.rst,1,['simpl'],['simple']
Usability,"ed) on an as-needed basis.; Note carefully how this is different from other Python (extension); modules, and what to expect if you use the normal inspection tools (such; as e.g. '`dir()`'). This feature prevents the inspection tools from; being swamped by an enormous amount of classes, but they can no longer; be used to explore unknown parts of the system (e.g. to find out which; classes are available). Furthermore, because of this approach,; \<`tab`\>-completion will usually not be available until after the first; use (and hence creation) of a class. Access to class static functions, public data members, enums, etc. is as; expected. Many more example uses of ROOT classes from Python can be; found in the tutorials directory in the ROOT distribution. The recipes; section contains a description on working with your own classes (see; ""Using Your Own Classes""). #### Access to STL Classes. The STL classes live in the ROOT.std namespace (or, if you prefer to get; them from there, in the ROOT module directly, but doing so makes the; code less clear, of course). Be careful in their use, because Python; already has types called ""`string`"" and ""`list`."". In order to understand how to get access to a templated class, think of; the general template as a meta class. By instantiating the meta class; with the proper parameters, you get an actual class, which can then be; used to create object instances. An example usage:. ``` {.cpp}; >>> from ROOT import std; >>> v = std.vector(int)(); >>> for i in range(0,10):; ... v.push_back(i); ...; >>> for i in v:; ... print(i, end=' '); 1 2 3 4 5 6 7 8 9; >>>; >>> list(v); [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]; >>>; ```. The parameters to the template instantiation can either be an actual; type or value (as is used here, ""int""), or a string representation of; the parameters (e.g. ""'double'""), or a mixture of both (e.g. ""'TCanvas,; 0'"" or ""'double', 0"" ). The ""std::vector\<int\>"" class is one of the; classes builtin by default into the Cling extensio",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PythonRuby.md:11682,clear,clear,11682,documentation/users-guide/PythonRuby.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PythonRuby.md,1,['clear'],['clear']
Usability,"ed). In addition,; the separation indices are protected against negative S or; S+B returning 0.5 (no separation at all) in case that; occurs.; ; BDT: In addition there is a new BDT option to; ignore events with negative event weights for the; training. This option could be used as a cross check of a; ""worst case"" solution for Monte Carlo samples with; negative weights. Note that the results of the testing; phase still include these events and are hence objective.; ; BDT: Added randomised trees: similar to the; ""Random Forests"" technique of Leo Breiman and Adele; Cutler, it uses the ""bagging"" algorithm and bases the; determination of the best node-split during the training; on a random subset of variables only, which is; individually chosen for each split.; ; BDT: Move to TRandom2 for the ""bagging"" algorithm; and throw random weights according to Poisson; statistics. (This way the random weights are closer to a; resampling with replacement algorithm.); ; TMlpANN: Extended options to; TMultilayerPerceptron learning methods. Added example for; reader application: TMVApplication.py; . GUI:. Parallel Coordinates: New GUI button for Parallel; Coordinate plotting.; . Application:. Added Python example for reader application: TMVApplication.py; . Bug fixes:. TMlpANN: fixed crash with ROOT>=5.17 when using; large number of test events; also corrected bias in cross; validation: before the test events were used, which led to; an overestimated performance evaluation in case of a small; number of degrees of freedom; separate now training tree; in two parts for training and validation with configurable; ValidationFraction; ; Cuts: Corrected inconsistency in MethodCuts:; the signal efficiency written out into the weight file does; not correspond to the center of the bin within which the; background rejection is maximised (as before) but to the; lower left edge of it. This is because the cut optimisation; algorithm determines the best background rejection for all; signal efficienci",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/doc/v520/index.html:4152,learn,learning,4152,tmva/doc/v520/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/doc/v520/index.html,1,['learn'],['learning']
Usability,"ed. Each virtual register can only be mapped to physical registers of a; particular class. For instance, in the X86 architecture, some virtuals can only; be allocated to 8 bit registers. A register class is described by; ``TargetRegisterClass`` objects. To discover if a virtual register is; compatible with a given physical, this code can be used:. .. code-block:: c++. bool RegMapping_Fer::compatible_class(MachineFunction &mf,; unsigned v_reg,; unsigned p_reg) {; assert(TargetRegisterInfo::isPhysicalRegister(p_reg) &&; ""Target register must be physical"");; const TargetRegisterClass *trc = mf.getRegInfo().getRegClass(v_reg);; return trc->contains(p_reg);; }. Sometimes, mostly for debugging purposes, it is useful to change the number of; physical registers available in the target architecture. This must be done; statically, inside the ``TargetRegisterInfo.td`` file. Just ``grep`` for; ``RegisterClass``, the last parameter of which is a list of registers. Just; commenting some out is one simple way to avoid them being used. A more polite; way is to explicitly exclude some registers from the *allocation order*. See the; definition of the ``GR8`` register class in; ``lib/Target/X86/X86RegisterInfo.td`` for an example of this. Virtual registers are also denoted by integer numbers. Contrary to physical; registers, different virtual registers never share the same number. Whereas; physical registers are statically defined in a ``TargetRegisterInfo.td`` file; and cannot be created by the application developer, that is not the case with; virtual registers. In order to create new virtual registers, use the method; ``MachineRegisterInfo::createVirtualRegister()``. This method will return a new; virtual register. Use an ``IndexedMap<Foo, VirtReg2IndexFunctor>`` to hold; information per virtual register. If you need to enumerate all virtual; registers, use the function ``TargetRegisterInfo::index2VirtReg()`` to find the; virtual register numbers:. .. code-block:: c++. for (unsigned",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodeGenerator.rst:60592,simpl,simple,60592,interpreter/llvm-project/llvm/docs/CodeGenerator.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodeGenerator.rst,1,['simpl'],['simple']
Usability,"ed.; reserved ``s_trap 0x05`` Reserved.; reserved ``s_trap 0x06`` Reserved.; reserved ``s_trap 0x07`` Reserved.; reserved ``s_trap 0x08`` Reserved.; reserved ``s_trap 0xfe`` Reserved.; reserved ``s_trap 0xff`` Reserved.; =================== =============== =============== =======================================. .. .. table:: AMDGPU Trap Handler for AMDHSA OS Code Object V4 and Above; :name: amdgpu-trap-handler-for-amdhsa-os-v4-onwards-table. =================== =============== ================ ================= =======================================; Usage Code Sequence GFX6-GFX8 Inputs GFX9-GFX11 Inputs Description; =================== =============== ================ ================= =======================================; reserved ``s_trap 0x00`` Reserved by hardware.; debugger breakpoint ``s_trap 0x01`` *none* *none* Reserved for debugger to use for; breakpoints. Causes wave to be halted; with the PC at the trap instruction.; The debugger is responsible to resume; the wave, including the instruction; that the breakpoint overwrote.; ``llvm.trap`` ``s_trap 0x02`` ``SGPR0-1``: *none* Causes wave to be halted with the PC at; ``queue_ptr`` the trap instruction. The associated; queue is signalled to put it into the; error state. When the queue is put in; the error state, the waves executing; dispatches on the queue will be; terminated.; ``llvm.debugtrap`` ``s_trap 0x03`` *none* *none* - If debugger not enabled then behaves; as a no-operation. The trap handler; is entered and immediately returns to; continue execution of the wavefront.; - If the debugger is enabled, causes; the debug trap to be reported by the; debugger and the wavefront is put in; the halt state with the PC at the; instruction. The debugger must; increment the PC and resume the wave.; reserved ``s_trap 0x04`` Reserved.; reserved ``s_trap 0x05`` Reserved.; reserved ``s_trap 0x06`` Reserved.; reserved ``s_trap 0x07`` Reserved.; reserved ``s_trap 0x08`` Reserved.; reserved ``s_trap 0xfe`` Reserved.; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst:384638,resume,resume,384638,interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,1,['resume'],['resume']
Usability,"edOperatorKind``). ``CXXLiteralOperatorName``. The name is a C++11 user defined literal operator. User defined; Literal operators are named according to the suffix they define,; e.g., ""``_foo``"" for ""``operator """" _foo``"". Use; ``N.getCXXLiteralIdentifier()`` to retrieve the corresponding; ``IdentifierInfo*`` pointing to the identifier. ``CXXUsingDirective``. The name is a C++ using directive. Using directives are not really; NamedDecls, in that they all have the same name, but they are; implemented as such in order to store them in DeclContext; effectively. ``DeclarationName``\ s are cheap to create, copy, and compare. They require; only a single pointer's worth of storage in the common cases (identifiers,; zero- and one-argument Objective-C selectors) and use dense, uniqued storage; for the other kinds of names. Two ``DeclarationName``\ s can be compared for; equality (``==``, ``!=``) using a simple bitwise comparison, can be ordered; with ``<``, ``>``, ``<=``, and ``>=`` (which provide a lexicographical ordering; for normal identifiers but an unspecified ordering for other kinds of names),; and can be placed into LLVM ``DenseMap``\ s and ``DenseSet``\ s. ``DeclarationName`` instances can be created in different ways depending on; what kind of name the instance will store. Normal identifiers; (``IdentifierInfo`` pointers) and Objective-C selectors (``Selector``) can be; implicitly converted to ``DeclarationNames``. Names for C++ constructors,; destructors, conversion functions, and overloaded operators can be retrieved; from the ``DeclarationNameTable``, an instance of which is available as; ``ASTContext::DeclarationNames``. The member functions; ``getCXXConstructorName``, ``getCXXDestructorName``,; ``getCXXConversionFunctionName``, and ``getCXXOperatorName``, respectively,; return ``DeclarationName`` instances for the four kinds of C++ special function; names. .. _DeclContext:. Declaration contexts; --------------------. Every declaration in a program exists with",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:72049,simpl,simple,72049,interpreter/llvm-project/clang/docs/InternalsManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst,1,['simpl'],['simple']
Usability,"ed_inlined 'InlineFunction' -> 'int'; [003] {Block}; [004] 5 {Variable} 'Var_2' -> 'int'; [003] 2 {Parameter} 'Param' -> 'int'; [003] 3 {Variable} 'Var_1' -> 'int'; [002] 11 {Function} extern not_inlined 'test' -> 'int'; [003] 12 {Variable} 'A' -> 'int'; [003] 13 {InlinedFunction} declared_inlined 'InlineFunction' -> 'int'; [004] {Block}; [005] {Variable} 'Var_2' -> 'int'; [004] {Parameter} 'Param' -> 'int'; [004] {Variable} 'Var_1' -> 'int'; [003] 11 {Parameter} 'Param_1' -> 'int'; [003] 11 {Parameter} 'Param_2' -> 'int'. From the previous logical views, we can see that the CodeView debug; information generated by the Clang compiler shows the variables **Var_1**; and **Var_2** are at the same lexical scope (**4**) in the function; **InlineFuction**. The DWARF generated by GCC/Clang and CodeView; generated by MSVC, show those variables at the correct lexical scope:; **3** and **4** respectively. Using the :program:`llvm-debuginfo-analyzer` selection facilities, we; can produce a simple tabular output showing just the logical elements; that have in their name the *var* pattern. The logical view is sorted; by the variables name. .. code-block:: none. llvm-debuginfo-analyzer --attribute=level,format; --output-sort=name; --select-regex --select-nocase --select=Var; --report=list; --print=symbols; pr-43860-*.o. .. code-block:: none. Logical View:; [000] {File} 'pr-43860-codeview-clang.o' -> COFF-x86-64. [001] {CompileUnit} 'pr-43860.cpp'; [004] {Variable} 'Var_1' -> 'int'; [004] {Variable} 'Var_2' -> 'int'. Logical View:; [000] {File} 'pr-43860-codeview-msvc.o' -> COFF-i386. [001] {CompileUnit} 'pr-43860.cpp'; [003] {Variable} 'Var_1' -> 'int'; [004] {Variable} 'Var_2' -> 'int'. Logical View:; [000] {File} 'pr-43860-dwarf-clang.o' -> elf64-x86-64. [001] {CompileUnit} 'pr-43860.cpp'; [004] {Variable} 'Var_1' -> 'int'; [003] 3 {Variable} 'Var_1' -> 'int'; [005] {Variable} 'Var_2' -> 'int'; [004] 5 {Variable} 'Var_2' -> 'int'. Logical View:; [000] {File} 'pr-43860-dwarf-gcc.",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-debuginfo-analyzer.rst:53415,simpl,simple,53415,interpreter/llvm-project/llvm/docs/CommandGuide/llvm-debuginfo-analyzer.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-debuginfo-analyzer.rst,1,['simpl'],['simple']
Usability,"editors`*. Any object editor; provides an object specific GUI. The main purpose of the ROOT graphics; editor is the organization of the object editors' appearance and the; task sequence between them. ### Object Editors. Every object editor follows a simple naming convention: to have as a; name the object class name concatenated with ‘*`Editor`*' (e.g. for; **`TGraph`** objects the object editor is **`TGraphEditor`**). Thanks to; the signals/slots communication mechanism and to the method; `DistancetoPrimitive()` that computes a ‘‘distance'' to an object from; the mouse position, it was possible to implement a signal method of the; canvas that says which is the selected object and to which pad it; belongs. Having this information the graphics editor loads the; corresponding object editor and the user interface is ready for use.; This way after a click on ‘axis'—the axis editor is active; a click on a; ‘pad' activates the pad editor, etc. The algorithm in use is simple and is based on the object-oriented; relationship and communication. When the user activates the editor,; according to the selected object **`<obj>`** in the canvas it looks for; a class name **`<obj>Editor`**. For that reason, the correct naming is; very important. If a class with this name is found, the editor verifies; that this class derives from the base editor class **`TGedFrame`**. If; all checks are satisfied, the editor makes an instance of the object; editor. Then, it scans all object base classes searching the; corresponding object editors. When it finds one, it makes an instance of; the base class editor too. Once the object editor is in place, it sets the user interface elements; according to the object's status. After that, it is ready to interact; with the object following the user actions. The graphics editor gives an intuitive way to edit objects in a canvas; with immediate feedback. Complexity of some object editors is reduced by; hiding GUI elements and revealing them only on users' r",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md:102937,simpl,simple,102937,documentation/users-guide/WritingGUI.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md,2,['simpl'],['simple']
Usability,"eds to provide a function.; ROOT provides a common way of specifying them via some interfaces. ## ROOT::Math Function interfaces. To get a consistency in the mathematical methods within ROOT, there exists a set of interfaces to define the basic behaviour of a mathematical function.; In order to use the classes presented in this chapter, the mathematical functions defined by the user must inherit from any of the classes seen in the figure:. ![ROOT::Math Function interface structure](pictures/function-hierarchy.png). ### One-dimensional Function Interfaces. These interfaces are used for numerical algorithms operating only on one-dimensional functions and cannot be applied to multi-dimensional functions.; For this case the users needs to define a function object which evaluates in one dimension, and the object will have to derivate from the following:. * `ROOT::Math::IBaseFunctionOneDim`: This class is the most basic function. Provides a method to evaluate the function given a value (simple double) by implementing; `double operator() (const double )`. The user class defined only needs to reimplement the pure abstract method `double DoEval(double x)`,; that will do the work of evaluating the function at point x. Example on how to create a class that represents a mathematical function. The user only has to override two methods from `IBaseFunctionOneDim`:. ```{.cpp}; #include ""Math/IFunction.h"". class MyFunction: public ROOT::Math::IBaseFunctionOneDim; {; double DoEval(double x) const; {; return x*x;; }. ROOT::Math::IBaseFunctionOneDim* Clone() const; {; return new MyFunction();; }; };; ```. * `ROOT::Math::IGradientFunctionOneDim`: Some of the numerical algorithm will need to calculate the derivatives of the function. In these cases, the user will have to provide the necessary code for; this to happen. The interface defined in `IGradientFunctionOneDim` introduced the method `double Derivative(double x)` that will return the derivative of the function at the point `x`. The ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:35631,simpl,simple,35631,documentation/users-guide/MathLibraries.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md,1,['simpl'],['simple']
Usability,"eds, the collector copies objects from one heap; area to another, compacting them in the process. Copying collectors enable; highly efficient ""bump pointer"" allocation and can improve locality of; reference. Incremental; (Including generational collectors.) Incremental collectors generally have all; the properties of a copying collector (regardless of whether the mature heap; is compacting), but bring the added complexity of requiring write barriers. Threaded; Denotes a multithreaded mutator; the collector must still stop the mutator; (""stop the world"") before beginning reachability analysis. Stopping a; multithreaded mutator is a complicated problem. It generally requires highly; platform-specific code in the runtime, and the production of carefully; designed machine code at safe points. Concurrent; In this technique, the mutator and the collector run concurrently, with the; goal of eliminating pause times. In a *cooperative* collector, the mutator; further aids with collection should a pause occur, allowing collection to take; advantage of multiprocessor hosts. The ""stop the world"" problem of threaded; collectors is generally still present to a limited extent. Sophisticated; marking algorithms are necessary. Read barriers may be necessary. As the matrix indicates, LLVM's garbage collection infrastructure is already; suitable for a wide variety of collectors, but does not currently extend to; multithreaded programs. This will be added in the future as there is; interest. .. _stack-map:. Computing stack maps; --------------------. LLVM automatically computes a stack map. One of the most important features; of a ``GCStrategy`` is to compile this information into the executable in; the binary representation expected by the runtime library. The stack map consists of the location and identity of each GC root in the; each function in the module. For each root:. * ``RootNum``: The index of the root. * ``StackOffset``: The offset of the object relative to the frame pointer",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GarbageCollection.rst:31462,pause,pause,31462,interpreter/llvm-project/llvm/docs/GarbageCollection.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GarbageCollection.rst,1,['pause'],['pause']
Usability,"ee TNamed::GetName() in its list of functions.; A click on this name will send you to the documentation for the method.; If you enabled the display of inherited members you will see; some members with a class name prefix. It tells you where this method has been defined.; Display Options; The info box contains options that influence how; the list of members is displayed: you can e.g. show or hide non-public methods. If you; just want to use ROOT you should hide them - you cannot access protected or private; members anyway. And you can select whether member that are inherited from a base class; should be shown. Again, if you just want to use ROOT you should probably show them,; as you often want to use them whether they are defined in the current class or in one; of its base classes. Whatever you set these options to should be stored in a cookie,; so you will have the same setting next time you look at the class documentation. Access (public / protected / private); Not all members are available to everyone (check any C++ introduction to learn why).; Public members have a green bar on their left, protected ones have a yellow one, and; private members are marked with a red bar. Of course you won't see any protected or; private members if you hide them in the display options. Inheritance; You can often access members of a class's base classes, just as if they are defined; in the derived class. A histogram,; for example, has a name, and you can access it using GetName() as defined in its base; class TNamed. If you want to see; all available members, and not just the ones defined in the current class, in the; display options. They will be prefixed with the name of; the class they are defined in. Class Charts; The class charts are shown in a tabbed box; click on the names ontop to select a tab. Inheritance; This chart shows the inheritance hierarchy for the current class. Arrows point to; base classes. You can click the classes to get to their reference page. Inherited Memb",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/etc/html/HELP.html:6180,learn,learn,6180,etc/html/HELP.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/etc/html/HELP.html,1,['learn'],['learn']
Usability,"ee later). User convenient typedefs are also provided.; 	They derive from the common generic interface multi-dimensional for function evaluation, `ROOT::Math::IBaseFunctionMultiDim`. In addition the fitter classes make uses of the generic interfaces for parametric function evaluations, `ROOT::Math::IParametricFunctionMultiDim`; to define the fit model function and use the `ROOT::Math::Minimizer` interface to perform the minimization of the objective function.; More information about the function interface and the multi-dimensional minimization in ROOT is given in the Mathematical Library chapter. Here we present a detailed description of the `ROOT::Fit` classes and how to use them.; Using these classes instead of the interface provided directly in the ROOT data objects, like `TH1::Fit` allow are more fine control; to configure and customise the fits. For example, using these classes a combined fit of several histograms can be performed. To understand how these class work, let's go through a simple example, such as fitting an histogram. When fitting an histogram, instead of using `TH1::Fit` we will show in the following hot wo use the `ROOT::Fit` classes.; We will show how to perform the following different type of fits with the histogram data:; * a least square fit using the observed errors (Neyman chi-squared);; * a least square fit using the expected errors from the function (Pearson chi-squared);; * a binned likelihood fit;; * an extended unbinned likelihood fits, if the histogram has been set to store in the buffer the original data used to fill it. Let's go through all the steps required for performing these fits using the `ROOT::Fit::Fitter` class.; These steps are:; 1. Create the input fit data object.; 2. Create the input model function.; 3. Configure the fit.; 4. Perform the data fitting.; 5. Examine the result. ### Creating the input fit data. We have two types of input data, binned data (class `ROOT::Fit::BinData`) used for least square (chi-square) fits o",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:28728,simpl,simple,28728,documentation/users-guide/FittingHistograms.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md,1,['simpl'],['simple']
Usability,"eed.dyn.free, label %dyn.free, label %if.end; dyn.free:; call void @CustomFree(ptr %mem); br label %if.end; if.end:; ... With allocations and deallocations represented as described as above, after; coroutine heap allocation elision optimization, the resulting main will be:. .. code-block:: llvm. define i32 @main() {; entry:; call void @print(i32 4); call void @print(i32 5); call void @print(i32 6); ret i32 0; }. Multiple Suspend Points; -----------------------. Let's consider the coroutine that has more than one suspend point:. .. code-block:: c++. void *f(int n) {; for(;;) {; print(n++);; <suspend>; print(-n);; <suspend>; }; }. Matching LLVM code would look like (with the rest of the code remaining the same; as the code in the previous section):. .. code-block:: llvm. loop:; %n.addr = phi i32 [ %n, %entry ], [ %inc, %loop.resume ]; call void @print(i32 %n.addr) #4; %2 = call i8 @llvm.coro.suspend(token none, i1 false); switch i8 %2, label %suspend [i8 0, label %loop.resume; i8 1, label %cleanup]; loop.resume:; %inc = add nsw i32 %n.addr, 1; %sub = xor i32 %n.addr, -1; call void @print(i32 %sub); %3 = call i8 @llvm.coro.suspend(token none, i1 false); switch i8 %3, label %suspend [i8 0, label %loop; i8 1, label %cleanup]. In this case, the coroutine frame would include a suspend index that will; indicate at which suspend point the coroutine needs to resume. .. code-block:: llvm. %f.frame = type { ptr, ptr, i32, i32 }. The resume function will use an index to jump to an appropriate basic block and will look; as follows:. .. code-block:: llvm. define internal fastcc void @f.Resume(ptr %FramePtr) {; entry.Resume:; %index.addr = getelementptr inbounds %f.Frame, ptr %FramePtr, i64 0, i32 2; %index = load i8, ptr %index.addr, align 1; %switch = icmp eq i8 %index, 0; %n.addr = getelementptr inbounds %f.Frame, ptr %FramePtr, i64 0, i32 3; %n = load i32, ptr %n.addr, align 4. br i1 %switch, label %loop.resume, label %loop. loop.resume:; %sub = sub nsw i32 0, %n; call void @pr",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst:18533,resume,resume,18533,interpreter/llvm-project/llvm/docs/Coroutines.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst,1,['resume'],['resume']
Usability,"een the two as part of overload resolution and ``cppyy``; allows C++ exceptions as such, enabling detailed type disambiguation and; input validation.; (The original use case was for filling database fields, requiring an exact; field label and data type match.). If, however, all methods fail and there is only one C++ exception (the other; exceptions originating from argument conversion, never succeeding to call; into C++), this C++ exception will be preferentially reported and will have; the original C++ type. `Return values`; ---------------. Most return types are readily amenable to automatic memory management: builtin; returns, by-value returns, (const-)reference returns to internal data, smart; pointers, etc.; The important exception is pointer returns.; ; A function that returns a pointer to an object over which Python should claim; ownership, should have its ``__creates__`` flag set through its; :doc:`pythonization <pythonizations>`.; Well-written APIs will have clear clues in their naming convention about the; ownership rules.; For example, functions called ``New...``, ``Clone...``, etc. can be expected; to return freshly allocated objects.; A basic name-matching in the pythonization then makes it simple to mark all; these functions as creators. The return values are :ref:`auto-casted <sec-auto-casting-label>`. `\*args and \*\*kwds`; ---------------------. C++ default arguments work as expected.; Keywords, however, are a Python language feature that does not exist in C++.; Many C++ function declarations do have formal arguments, but these are not; part of the C++ interface (the argument names are repeated in the definition,; making the names in the declaration irrelevant: they do not even need to be; provided).; Thus, although ``cppyy`` will map keyword argument names to formal argument; names from the C++ declaration, use of this feature is not recommended unless; you have a guarantee that the names in C++ the interface are maintained.; Example:. .. code-bloc",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/functions.rst:12765,clear,clear,12765,bindings/pyroot/cppyy/cppyy/doc/source/functions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/functions.rst,1,['clear'],['clear']
Usability,"efault argument; >>> c.m_int; 42; >>> c = Concrete(13) # uses provided argument; >>> c.m_int; 13; >>> args = (27,); >>> c = Concrete(*args) # argument pack; >>> c.m_int; 27; >>> c = Concrete(n=17); >>> c.m_int; 17; >>> kwds = {'n' : 18}; >>> c = Concrete(**kwds); >>> c.m_int; 18; >>>. `Callbacks`; -----------. Python callables (functions/lambdas/instances) can be passed to C++ through; function pointers and/or ``std::function``.; This involves creation of a temporary wrapper, which has the same life time as; the Python callable it wraps, so the callable needs to be kept alive on the; Python side if the C++ side stores the callback.; Example:. .. code-block:: python. >>> from cppyy.gbl import call_int_int; >>> print(call_int_int.__doc__); int ::call_int_int(int(*)(int,int) f, int i1, int i2); >>> def add(a, b):; ... return a+b; ...; >>> call_int_int(add, 3, 7); 7; >>> call_int_int(lambda x, y: x*y, 3, 7); 21; >>>. Python functions can be used to instantiate C++ templates, assuming the; type information of the arguments and return types can be inferred.; If this can not be done directly from the template arguments, then it can; be provided through Python annotations, by explicitly adding the; ``__annotations__`` special data member (e.g. for older versions of Python; that do not support annotations), or by the function having been bound by; ``cppyy`` in the first place.; For example:. .. code-block:: python. >>> import cppyy; >>> cppyy.cppdef(""""""\; ... template<typename R, typename... U, typename... A>; ... R callT(R(*f)(U...), A&&... a) {; ... return f(a...);; ... }""""""); True; >>> def f(a: 'int') -> 'double':; ... return 3.1415*a; ...; >>> cppyy.gbl.callT(f, 2); 6.283; >>> def f(a: 'int', b: 'int') -> 'int':; ... return 3*a*b; ...; >>> cppyy.gbl.callT(f, 6, 7); 126; >>>. `extern ""C""`; ------------. Functions with C linkage are supported and are simply represented as; overloads of a single function.; Such functions are allowed both globally as well as in namespaces.; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/functions.rst:15734,simpl,simply,15734,bindings/pyroot/cppyy/cppyy/doc/source/functions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/functions.rst,1,['simpl'],['simply']
Usability,"efault_%m.profraw`` in the directory named ``dirname`` if specified.; If ``dirname`` does not exist, it will be created at runtime. ``%m`` specifier; will be substituted with a unique id documented in step 2 above. In other words,; with ``-fprofile-generate[=<dirname>]`` option, the ""raw"" profile data automatic; merging is turned on by default, so there will no longer any risk of profile; clobbering from different running processes. For example,. .. code-block:: console. $ clang++ -O2 -fprofile-generate=yyy/zzz code.cc -o code. When ``code`` is executed, the profile will be written to the file; ``yyy/zzz/default_xxxx.profraw``. To generate the profile data file with the compiler readable format, the; ``llvm-profdata`` tool can be used with the profile directory as the input:. .. code-block:: console. $ llvm-profdata merge -output=code.profdata yyy/zzz/. If the user wants to turn off the auto-merging feature, or simply override the; the profile dumping path specified at command line, the environment variable; ``LLVM_PROFILE_FILE`` can still be used to override; the directory and filename for the profile file at runtime.; To override the path and filename at compile time, use; ``-Xclang -fprofile-instrument-path=/path/to/file_pattern.profraw``. .. option:: -fcs-profile-generate[=<dirname>]. The ``-fcs-profile-generate`` and ``-fcs-profile-generate=`` flags will use; the same instrumentation method, and generate the same profile as in the; ``-fprofile-generate`` and ``-fprofile-generate=`` flags. The difference is; that the instrumentation is performed after inlining so that the resulted; profile has a better context sensitive information. They cannot be used; together with ``-fprofile-generate`` and ``-fprofile-generate=`` flags.; They are typically used in conjunction with ``-fprofile-use`` flag.; The profile generated by ``-fcs-profile-generate`` and ``-fprofile-generate``; can be merged by llvm-profdata. A use example:. .. code-block:: console. $ clang++ -O2 -fprofi",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:108435,simpl,simply,108435,interpreter/llvm-project/clang/docs/UsersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst,1,['simpl'],['simply']
Usability,"eference frame of the current volume and to; compute the distance to exit its shape from inside. The returned value; is again compared to the maximum allowed step (the proposed one) and in; case the distance is safe no other action is performed and the proposed; step is approved. In case the boundary is closer, the computed distance; is taken as maximum allowed step. For optimization purposed, for; particles starting very close to the current volume boundary (less than; 0.01 microns) and exiting the algorithm stops here. After computing the distance to exit the current node, the distance to; the daughter of the current volume which is crossed next is computed by; TGeoManager::FindNextDaughterBoundary(). This computes the; distance to all daughter candidates that can be possibly crossed by; using volume voxelization. The algorithm is efficient in average only in; case the number of daughters is greater than 4. For fewer nodes, a; simple loop is performed and the minimum distance (from a point outside; each shape) is taken and compared to the maximum allowed step. The step; value is again updated if `step<stepmax` . A special case is when the current node is declared as possibly; overlapping with something else. If this is the case, the distance is; computed for all possibly overlapping candidates, taking into account; the overlapping priorities (see also: "" Overlapping volumes ""). The global matrix describing the next crossed physical node is; systematically computed in case the value of the proposed step is; negative. In this case, one can subsequently call; TGeoManager::ComputeNormalFast() to get the normal vector to the; crossed surface, after propagating the current point with the; TGeoManager::GetStep() value. This propagation can be done like:. ~~~{.cpp}; Double_t *current_point = gGeoManager->GetCurrentPoint();; Double_t *current_dir = gGeoManager->GetCurrentDirection();; for (Int_t i=0; i<3; i++); current_point[i] += step * current_dir[I];; ~~~. Note: The met",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md:124043,simpl,simple,124043,geom/geom/doc/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md,1,['simpl'],['simple']
Usability,"egarding the report and parties involved. All incident reports should be assessed if they require immediate response and; acted on accordingly. .. _Incident Response Assessment:. Incident Response Assessment; ============================. The committee will assess the incident and determine an appropriate response.; The assessment will be documented and retained in records. Here are some; guidelines for the process:. * Review report documentation to determine the content and context of the; incident. * Request additional information if needed from the reporter. * Determine if it occurred within the scope of the CoC.; * Determine if it violated the CoC and specifically which part.; * Consult documentation of past incidents for patterns of behavior (if; available and applicable).; * Follow up with the reportee to get their view or any other additional; information.; * Determine appropriate resolutions to the incident when all information has; been gathered.; * Notify the reporter of the resolution and request feedback. This may or may; not be used to reevaluate the resolution. The committee will aim to have a resolution agreed upon within two weeks of; receipt of the incident report. In the event that a resolution cannot be; determined within that time, the CoC committee will respond to the reporter(s); with an updated and projected timeline for resolution. . .. _Following Up With the Reportee:. Following Up With the Reportee; ==============================. When following up with the reportee, the committee will:. * Explain that an incident was reported that involves the reportee.; * In this explanation, the focus will be on the impact of their behavior, not; their intent.; * Reiterate the Code of Conduct and that their behavior may be deemed; inappropriate.; * Give them the opportunity to state their view of the incident.; * Explain the possible resolutions that may be enforced should the CoC; committee determine there is a breach. The reportee will be given a week t",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ResponseGuide.rst:5671,feedback,feedback,5671,interpreter/llvm-project/llvm/docs/ResponseGuide.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ResponseGuide.rst,1,['feedback'],['feedback']
Usability,"el put a; limitation on the maximum applied depth. Combined with visibility; settings per volume, these can tune quite well what should appear on the; screen. However, there are situations when users want to see a volume; branch displayed down to the maximum depth, keeping at the same time a; limitation or even suppressing others. In order to accomplish that, one; should use the volume attribute: ""Visible daughters"". By default, all; daughters of all volumes are displayed if there is no limitation related; with their level depth with respect to the top drawn volume. \anchor GP04c; ### Ray Tracing. Ray tracing is a quite known drawing technique based on tracking rays; from the eye position through all pixels of a view port device. The; pixel color is derived from the properties of the first crossed surface,; according some illumination model and material optical properties. While; there are currently existing quite sophisticated ray tracing models,; `TGeo` is currently using a very simple approach where the light; source is matching the eye position (no shadows or back-tracing of the; reflected ray). In future we are considering providing a base class in; order to be able to derive more complex models. Due to the fact that the number of rays that have to be tracked matches; the size in pixels of the pad, the time required by this algorithm is; proportional to the pad size. On the other hand, the speed is quite; acceptable for the default ROOT pad size and the images produced by; using this technique have high quality. Since the algorithm is; practically using all navigation features, producing ray-traced pictures; is also a geometry validation check. Ray tracing can be activated at; volume level as the normal `Draw()`. \image html geometry013.jpg ""Ray-traced view in a pad"". ~~~{.cpp}; myVolume->Raytrace(); ~~~. Once ray-tracing a view, this can be zoomed or rotated as a usual one.; Objects on the screen are no longer highlighted when picking the; vertices but the corr",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md:104014,simpl,simple,104014,geom/geom/doc/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md,1,['simpl'],['simple']
Usability,"elected object, executed from method **`TGedEditor::SetModel()`**.; When a new object of a different class is selected, the unneeded; GED-frames are cached in memory for potential reuse. The frames are; deleted automatically when the editor is closed. Note: A deep cleanup is assumed for all frames put into the editor. This; implies:. - do not share the layout-hints among GUI components;. - do not delete child widgets in the destructor as this is done; automatically. #### Using Several Tabs. Sometimes you might need to use several tabs to organize properly your; class-editor. Each editor tab is a resource shared among all the; class-editors. Tabs must be created from the constructor of your; editor-class by using the method:. ``` {.cpp}; TGVerticalFrame* TGedFrame::CreateEditorTabSubFrame(const Text_t *name),; ```. It returns a pointer to a new tab container frame ready for use in your; class. If you need to hide/show this frame depending on the object's; status, you should store it in a data member. See for examples:; **`TH1Editor`**, **`TH2Editor`**. #### Base-Class Editors Control. Full control over base-class editors can be achieved by re-implementing; virtual method void `TGedFrame::ActivateBaseClassEditors(TClass` `*cl)`.; It is called during each compound editor rebuild and the default; implementation simply offers all base-classes to the publishing; mechanism. To prevent inclusion of a base-class into the compound editor, call:. ``` {.cpp}; void TGedEditor::ExcludeClassEditor(TClass* class, Bool_t recurse); ```. Pointer to the compound GED-editor is available in **`TGedFrame`**‘s; data-member:. ``` {.cpp}; TGedEditor *fGedEditor; ```. Ordering of base-class editor frames follows the order of the classes in; the class hierarchy. This order can be changed by modifying the value of; **`TGedFrame`**'s data member `Int_t fPriority`. The default value is; 50; smaller values move the frame towards to the top. This priority; should be set in the editor constructor.; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/ged/doc/index.md:5896,simpl,simply,5896,gui/ged/doc/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/ged/doc/index.md,1,['simpl'],['simply']
Usability,"electionDAG.cpp``:. Add code to print the node to ``getOperationName``. If your new node can be; evaluated at compile time when given constant arguments (such as an add of a; constant with another constant), find the ``getNode`` method that takes the; appropriate number of arguments, and add a case for your node to the switch; statement that performs constant folding for nodes that take the same number; of arguments as your new node. #. ``lib/CodeGen/SelectionDAG/LegalizeDAG.cpp``:. Add code to `legalize, promote, and expand; <CodeGenerator.html#selectiondag_legalize>`_ the node as necessary. At a; minimum, you will need to add a case statement for your node in; ``LegalizeOp`` which calls LegalizeOp on the node's operands, and returns a; new node if any of the operands changed as a result of being legalized. It; is likely that not all targets supported by the SelectionDAG framework will; natively support the new node. In this case, you must also add code in your; node's case statement in ``LegalizeOp`` to Expand your node into simpler,; legal operations. The case for ``ISD::UREM`` for expanding a remainder into; a divide, multiply, and a subtract is a good example. #. ``lib/CodeGen/SelectionDAG/LegalizeDAG.cpp``:. If targets may support the new node being added only at certain sizes, you; will also need to add code to your node's case statement in ``LegalizeOp``; to Promote your node's operands to a larger size, and perform the correct; operation. You will also need to add code to ``PromoteOp`` to do this as; well. For a good example, see ``ISD::BSWAP``, which promotes its operand to; a wider size, performs the byteswap, and then shifts the correct bytes right; to emulate the narrower byteswap in the wider type. #. ``lib/CodeGen/SelectionDAG/LegalizeDAG.cpp``:. Add a case for your node in ``ExpandOp`` to teach the legalizer how to; perform the action represented by the new node on a value that has been split; into high and low halves. This case will be used to suppor",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ExtendingLLVM.rst:5092,simpl,simpler,5092,interpreter/llvm-project/llvm/docs/ExtendingLLVM.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ExtendingLLVM.rst,1,['simpl'],['simpler']
Usability,"elements (but could contain many), for example, it's much better to use; :ref:`SmallVector <dss_smallvector>` than :ref:`vector <dss_vector>`. Doing so; avoids (relatively) expensive malloc/free calls, which dwarf the cost of adding; the elements to the container. .. _ds_sequential:. Sequential Containers (std::vector, std::list, etc); ---------------------------------------------------. There are a variety of sequential containers available for you, based on your; needs. Pick the first in this section that will do what you want. .. _dss_arrayref:. llvm/ADT/ArrayRef.h; ^^^^^^^^^^^^^^^^^^^. The ``llvm::ArrayRef`` class is the preferred class to use in an interface that; accepts a sequential list of elements in memory and just reads from them. By; taking an ``ArrayRef``, the API can be passed a fixed size array, an; ``std::vector``, an ``llvm::SmallVector`` and anything else that is contiguous; in memory. .. _dss_fixedarrays:. Fixed Size Arrays; ^^^^^^^^^^^^^^^^^. Fixed size arrays are very simple and very fast. They are good if you know; exactly how many elements you have, or you have a (low) upper bound on how many; you have. .. _dss_heaparrays:. Heap Allocated Arrays; ^^^^^^^^^^^^^^^^^^^^^. Heap allocated arrays (``new[]`` + ``delete[]``) are also simple. They are good; if the number of elements is variable, if you know how many elements you will; need before the array is allocated, and if the array is usually large (if not,; consider a :ref:`SmallVector <dss_smallvector>`). The cost of a heap allocated; array is the cost of the new/delete (aka malloc/free). Also note that if you; are allocating an array of a type with a constructor, the constructor and; destructors will be run for every element in the array (re-sizable vectors only; construct those elements actually used). .. _dss_tinyptrvector:. llvm/ADT/TinyPtrVector.h; ^^^^^^^^^^^^^^^^^^^^^^^^. ``TinyPtrVector<Type>`` is a highly specialized collection class that is; optimized to avoid allocation in the case whe",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:58138,simpl,simple,58138,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,1,['simpl'],['simple']
Usability,"elistorder <ty> <value>, { <order-indexes> }; uselistorder_bb @function, %block { <order-indexes> }. :Examples:. ::. define void @foo(i32 %arg1, i32 %arg2) {; entry:; ; ... instructions ...; bb:; ; ... instructions ... ; At function scope.; uselistorder i32 %arg1, { 1, 0, 2 }; uselistorder label %bb, { 1, 0 }; }. ; At global scope.; uselistorder ptr @global, { 1, 2, 0 }; uselistorder i32 7, { 1, 0 }; uselistorder i32 (i32) @bar, { 1, 0 }; uselistorder_bb @foo, %bb, { 5, 1, 3, 2, 0, 4 }. .. _source_filename:. Source Filename; ---------------. The *source filename* string is set to the original module identifier,; which will be the name of the compiled source file when compiling from; source through the clang front end, for example. It is then preserved through; the IR and bitcode. This is currently necessary to generate a consistent unique global; identifier for local functions used in profile data, which prepends the; source file name to the local function name. The syntax for the source file name is simply:. .. code-block:: text. source_filename = ""/path/to/source.c"". .. _typesystem:. Type System; ===========. The LLVM type system is one of the most important features of the; intermediate representation. Being typed enables a number of; optimizations to be performed on the intermediate representation; directly, without having to do extra analyses on the side before the; transformation. A strong type system makes it easier to read the; generated code and enables novel analyses and transformations that are; not feasible to perform on normal three address code representations. .. _t_void:. Void Type; ---------. :Overview:. The void type does not represent any value and has no size. :Syntax:. ::. void. .. _t_function:. Function Type; -------------. :Overview:. The function type can be thought of as a function signature. It consists of a; return type and a list of formal parameter types. The return type of a function; type is a void type or first class type --- except f",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:165106,simpl,simply,165106,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['simpl'],['simply']
Usability,"elpful. In this approach, you can modify the source code of instcombine to; disable just those transformations that are being performed on your test input; and perform a binary search over the set of transformations. One set of places; to modify are the ""``visit*``"" methods of ``InstCombiner`` (*e.g.*; ``visitICmpInst``) by adding a ""``return false``"" as the first line of the; method. If that still doesn't remove enough, then change the caller of; ``InstCombiner::DoOneIteration``, ``InstCombiner::runOnFunction`` to limit the; number of iterations. You may also find it useful to use ""``-stats``"" now to see what parts of; instcombine are firing. This can guide where to put additional reporting code. At this point, if the amount of transformations is still too large, then; inserting code to limit whether or not to execute the body of the code in the; visit function can be helpful. Add a static counter which is incremented on; every invocation of the function. Then add code which simply returns false on; desired ranges. For example:. .. code-block:: c++. static int calledCount = 0;; calledCount++;; LLVM_DEBUG(if (calledCount < 212) return false);; LLVM_DEBUG(if (calledCount > 217) return false);; LLVM_DEBUG(if (calledCount == 213) return false);; LLVM_DEBUG(if (calledCount == 214) return false);; LLVM_DEBUG(if (calledCount == 215) return false);; LLVM_DEBUG(if (calledCount == 216) return false);; LLVM_DEBUG(dbgs() << ""visitXOR calledCount: "" << calledCount << ""\n"");; LLVM_DEBUG(dbgs() << ""I: ""; I->dump());. could be added to ``visitXOR`` to limit ``visitXor`` to being applied only to; calls 212 and 217. This is from an actual test case and raises an important; point---a simple binary search may not be sufficient, as transformations that; interact may require isolating more than one call. In TargetLowering, use; ``return SDNode();`` instead of ``return false;``. Now that the number of transformations is down to a manageable number, try; examining the output to see if you ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Bugpoint.rst:10014,simpl,simply,10014,interpreter/llvm-project/llvm/docs/Bugpoint.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Bugpoint.rst,1,['simpl'],['simply']
Usability,"els will end up at; different addresses though. It's perfectly legal to output something like this; to the .s file:. ::. foo:; bar:; .byte 4. In this case, both the foo and bar symbols will have the same address. The ``MCSection`` class; -----------------------. The ``MCSection`` class represents an object-file specific section. It is; subclassed by object file specific implementations (e.g. ``MCSectionMachO``,; ``MCSectionCOFF``, ``MCSectionELF``) and these are created and uniqued by; MCContext. The MCStreamer has a notion of the current section, which can be; changed with the SwitchToSection method (which corresponds to a "".section""; directive in a .s file). .. _MCInst:. The ``MCInst`` class; --------------------. The ``MCInst`` class is a target-independent representation of an instruction.; It is a simple class (much more so than `MachineInstr`_) that holds a; target-specific opcode and a vector of MCOperands. MCOperand, in turn, is a; simple discriminated union of three cases: 1) a simple immediate, 2) a target; register ID, 3) a symbolic expression (e.g. ""``Lfoo-Lbar+42``"") as an MCExpr. MCInst is the common currency used to represent machine instructions at the MC; layer. It is the type used by the instruction encoder, the instruction printer,; and the type generated by the assembly parser and disassembler. .. _ObjectFormats:. Object File Format; ------------------. The MC layer's object writers support a variety of object formats. Because of; target-specific aspects of object formats each target only supports a subset of; the formats supported by the MC layer. Most targets support emitting ELF; objects. Other vendor-specific objects are generally supported only on targets; that are supported by that vendor (i.e. MachO is only supported on targets; supported by Darwin, and XCOFF is only supported on targets that support AIX).; Additionally some targets have their own object formats (i.e. DirectX, SPIR-V; and WebAssembly). The table below captures a snapshot of",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodeGenerator.rst:30733,simpl,simple,30733,interpreter/llvm-project/llvm/docs/CodeGenerator.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodeGenerator.rst,2,['simpl'],['simple']
Usability,"eltoX(apx)` | Double\_t |; | user | | |; | | `AbsPixeltoY(apy)` | Double\_t |; | | | |; | | `AbsPixeltoXY(apx,apy,&ux,&uy)` | Double\_t ux,uy |; +-----------------------+----------------------------------+--------------------+. Note: all the pixel conversion functions along the Y axis consider that; `py=0` is at the top of the pad except `PixeltoY()` which assume that; the position `py=0` is at the bottom of the pad. To make `PixeltoY()`; converting the same way as the other conversion functions, it should be; used the following way (`p` is a pointer to a **`TPad`**):. ``` {.cpp}; p->PixeltoY(py - p->GetWh());; ```. ### Dividing a Pad into Sub-pads. Dividing a pad into sub pads in order for instance to draw a few; histograms, may be done in two ways. The first is to build pad objects; and to draw them into a parent pad, which may be a canvas. The second is; to automatically divide a pad into horizontal and vertical sub pads. #### Creating a Single Sub-pad. The simplest way to divide a pad is to build sub-pads in it. However,; this forces the user to explicitly indicate the size and position of; those sub-pads. Suppose we want to build a sub-pad in the active pad; (pointed by ***`gPad`***). First, we build it, using a **`TPad`**; constructor:. ``` {.cpp}; root[] spad1 = new TPad(""spad1"",""The first subpad"",.1,.1,.5,.5); ```. One gives the coordinates of the lower left point (0.1, 0.1) and of the; upper right one (0.5, 0.5). These coordinates are in NDC. This means; that they are independent of the user coordinates system, in particular; if you have already drawn for example a histogram in the mother pad. The; only thing left is to draw the pad:. ``` {.cpp}; root[] spad1->Draw(); ```. If you want more sub-pads, you have to repeat this procedure as many; times as necessary. #### Dividing a Canvas into Sub-Pads. The manual way of dividing a pad into sub-pads is sometimes very; tedious. There is a way to automatically generate horizontal and; vertical sub-pads inside a giv",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md:24048,simpl,simplest,24048,documentation/users-guide/Graphics.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md,1,['simpl'],['simplest']
Usability,"ement is a compiler that supports; C++14, this in order to build LLVM. With CPython on Linux or MacOS, probably by far the easiest way to install; cppyy, is through conda-forge on `Anaconda`_ (or `miniconda`_).; A Windows recipe for ``conda`` is not available yet, but is forthcoming, so; use ``pip`` for that platform for now (see below).; PyPI always has the authoritative releases (conda-forge pulls the sources; from there), so conda-forge may sometimes lag PyPI.; If you absolutely need the latest release, use PyPI or consider; :ref:`building from source <building_from_source>`. To install using ``conda``, create and/or activate your (new) work environment; and install from the conda-forge channel::. $ conda create -n WORK; $ conda activate WORK; (WORK) $ conda install -c conda-forge cppyy; (WORK) [current compiler] $. To install with ``pip`` through `PyPI`_, use `venv`.; The use of virtual environment (`venv`) prevents pollution of any system directories and allows; you to wipe out the full installation simply by removing the virtual environment (`venv`); created directory (""WORK"" in this example)::. $ python -m venv WORK ; $ WORK\Scripts\activate; (WORK) $ python -m pip install cppyy; (WORK) $. .. note:: ; If you are using python version less than 3.3, you should use `virtualenv` instead of `venv`.; First install virtualenv package that allows you to create virtual environment. $ python -m pip install virtualenv . $ virtualenv WORK. $ source WORK/bin/activate. (WORK) $ python -m pip install cppyy. (WORK) $. If you use the ``--user`` option to ``pip`` and use ``pip`` directly on the; command line, instead of through ``python``, make sure that the ``PATH``; envar points to the bin directory that will contain the installed entry; points during the installation, as the build process needs them.; You may also need to install ``wheel`` first if you have an older version of; ``pip`` and/or do not use virtualenv (which installs wheel by default).; Example::. $ python -m pi",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/installation.rst:1576,simpl,simply,1576,bindings/pyroot/cppyy/cppyy/doc/source/installation.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/installation.rst,1,['simpl'],['simply']
Usability,"emote node: it will effectively; decode the Base64 string back to the proxy file and write it into the; `/tmp` directory. Note also that the first `$UID` is not escaped and; will be substituted *locally* with your user ID *on your client; machine*, while the second one has the dollar escaped (`\$UID`) and will; be substituted *remotely* with your user ID *on the remote node*. > It is worth noting that the remote environment scripts will be sent to; > the remote node using a secure connection (SSH), thus there is no; > concern in placing sensitive user data there. Installing the Virtual Analysis Facility client; -----------------------------------------------. ### Download the client from Git. The Virtual Analysis Facility client is available on; [GitHub](https://github.com/dberzano/virtual-analysis-facility):. ``` {.bash}; git clone git://github.com/dberzano/virtual-analysis-facility.git /dest/dir; ```. The client will be found in `/dest/dir/client/bin/vaf-enter`: it is; convenient to add it to the `$PATH` so that the users might simply start; it by typing `vaf-enter`. ### Install the experiment's configuration files system-wide. A system administrator might find convenient to install the experiment; environment scripts system-wide. Configuration scripts for LHC experiments are shipped with the VAF; client and can be found in; `/dest/dir/client/config-samples/<experiment_name>`. To make them used; by default by the VAF client, place them in the `/dest/dir/etc`; directory like this:. ``` {.bash}; rsync -a /dest/dir/client/config-samples/<experiment_name>/ /dest/dir/etc/; ```. Remember that the trailing slash in the source directory name has a; meaning in `rsync` and must not be omitted. > Remember that system-wide configuration files will always have; > precedence over user's configuration files, so *don't place there; > files that are supposed to be provided by the user!*. Entering the Virtual Analysis Facility environment; -------------------------------------------",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/doc/confman/UsingVirtualAnalysisFacility.md:7244,simpl,simply,7244,proof/doc/confman/UsingVirtualAnalysisFacility.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/doc/confman/UsingVirtualAnalysisFacility.md,1,['simpl'],['simply']
Usability,"en to have a pointer; to a `coroutine frame`_ or a pointer to a `coroutine promise`_. .. _coro.destroy:. 'llvm.coro.destroy' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare void @llvm.coro.destroy(ptr <handle>). Overview:; """""""""""""""""". The '``llvm.coro.destroy``' intrinsic destroys a suspended; switched-resume coroutine. Arguments:; """""""""""""""""""". The argument is a coroutine handle to a suspended coroutine. Semantics:; """""""""""""""""""". When possible, the `coro.destroy` intrinsic is replaced with a direct call to; the coroutine destroy function. Otherwise it is replaced with an indirect call; based on the function pointer for the destroy function stored in the coroutine; frame. Destroying a coroutine that is not suspended leads to undefined behavior. .. _coro.resume:. 'llvm.coro.resume' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. ::. declare void @llvm.coro.resume(ptr <handle>). Overview:; """""""""""""""""". The '``llvm.coro.resume``' intrinsic resumes a suspended switched-resume coroutine. Arguments:; """""""""""""""""""". The argument is a handle to a suspended coroutine. Semantics:; """""""""""""""""""". When possible, the `coro.resume` intrinsic is replaced with a direct call to the; coroutine resume function. Otherwise it is replaced with an indirect call based; on the function pointer for the resume function stored in the coroutine frame.; Resuming a coroutine that is not suspended leads to undefined behavior. .. _coro.done:. 'llvm.coro.done' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. ::. declare i1 @llvm.coro.done(ptr <handle>). Overview:; """""""""""""""""". The '``llvm.coro.done``' intrinsic checks whether a suspended; switched-resume coroutine is at the final suspend point or not. Arguments:; """""""""""""""""""". The argument is a handle to a suspended coroutine. Semantics:; """""""""""""""""""". Using this intrinsic on a coroutine that does not have a `final suspend`_ point; or on a coroutine that is not suspended leads to undefined behavior. .. _coro.promise:. 'llv",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst:27886,resume,resume,27886,interpreter/llvm-project/llvm/docs/Coroutines.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst,3,['resume'],"['resume', 'resumes']"
Usability,"en.i.i.i.i.i, label %_ZNSt12_Vector_baseIiSaIiEEC2EmRKS0_.exit.i.i. if.then.i.i.i.i.i: ; preds = %cond.true.i.i.i.i; call void @_ZSt17__throw_bad_allocv() noreturn nounwind; unreachable. _ZNSt12_Vector_baseIiSaIiEEC2EmRKS0_.exit.i.i: ; preds = %cond.true.i.i.i.i; %mul.i.i.i.i.i = shl i64 %conv, 2; %call3.i.i.i.i.i = call noalias i8* @_Znwm(i64 %mul.i.i.i.i.i) nounwind; %0 = bitcast i8* %call3.i.i.i.i.i to i32*; store i32* %0, i32** %v2.sub, align 8, !tbaa !0; store i32* %0, i32** %tmp3.i.i.i.i.i, align 8, !tbaa !0; %add.ptr.i.i.i = getelementptr inbounds i32* %0, i64 %conv; store i32* %add.ptr.i.i.i, i32** %tmp4.i.i.i.i.i, align 8, !tbaa !0; call void @llvm.memset.p0i8.i64(i8* %call3.i.i.i.i.i, i8 0, i64 %mul.i.i.i.i.i, i32 4, i1 false); br label %_ZNSt6vectorIiSaIiEEC1EmRKiRKS0_.exit. This is just the handling the construction of the vector. Most surprising here; is the fact that all three null stores in %entry are dead (because we do no; cross-block DSE). Also surprising is that %conv isn't simplified to 0 in %....exit.thread.i.i.; This is a because the client of LazyValueInfo doesn't simplify all instruction; operands, just selected ones. //===---------------------------------------------------------------------===//. clang -O3 -fno-exceptions currently compiles this code:. void f(char* a, int n) {; __builtin_memset(a, 0, n);; for (int i = 0; i < n; ++i); a[i] = 0;; }. into:. define void @_Z1fPci(i8* nocapture %a, i32 %n) nounwind {; entry:; %conv = sext i32 %n to i64; tail call void @llvm.memset.p0i8.i64(i8* %a, i8 0, i64 %conv, i32 1, i1 false); %cmp8 = icmp sgt i32 %n, 0; br i1 %cmp8, label %for.body.lr.ph, label %for.end. for.body.lr.ph: ; preds = %entry; %tmp10 = add i32 %n, -1; %tmp11 = zext i32 %tmp10 to i64; %tmp12 = add i64 %tmp11, 1; call void @llvm.memset.p0i8.i64(i8* %a, i8 0, i64 %tmp12, i32 1, i1 false); ret void. for.end: ; preds = %entry; ret void; }. This shouldn't need the ((zext (%n - 1)) + 1) game, and it should ideally fold; the two memset's ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/README.txt:58227,simpl,simplified,58227,interpreter/llvm-project/llvm/lib/Target/README.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/README.txt,1,['simpl'],['simplified']
Usability,"en/else. In this case the only thing left to do is to return to the; caller of the function. The question then becomes: how does the code; know which expression to return?. The answer to this question involves an important SSA operation: the; `Phi; operation <http://en.wikipedia.org/wiki/Static_single_assignment_form>`_.; If you're not familiar with SSA, `the wikipedia; article <http://en.wikipedia.org/wiki/Static_single_assignment_form>`_; is a good introduction and there are various other introductions to it; available on your favorite search engine. The short version is that; ""execution"" of the Phi operation requires ""remembering"" which block; control came from. The Phi operation takes on the value corresponding to; the input control block. In this case, if control comes in from the; ""then"" block, it gets the value of ""calltmp"". If control comes from the; ""else"" block, it gets the value of ""calltmp1"". At this point, you are probably starting to think ""Oh no! This means my; simple and elegant front-end will have to start generating SSA form in; order to use LLVM!"". Fortunately, this is not the case, and we strongly; advise *not* implementing an SSA construction algorithm in your; front-end unless there is an amazingly good reason to do so. In; practice, there are two sorts of values that float around in code; written for your average imperative programming language that might need; Phi nodes:. #. Code that involves user variables: ``x = 1; x = x + 1;``; #. Values that are implicit in the structure of your AST, such as the; Phi node in this case. In `Chapter 7 <LangImpl07.html>`_ of this tutorial (""mutable variables""),; we'll talk about #1 in depth. For now, just believe me that you don't; need SSA construction to handle this case. For #2, you have the choice; of using the techniques that we will describe for #1, or you can insert; Phi nodes directly, if convenient. In this case, it is really; easy to generate the Phi node, so we choose to do it directly. Okay, eno",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl05.rst:8051,simpl,simple,8051,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl05.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl05.rst,1,['simpl'],['simple']
Usability,"end; * PowerPC backend; * RISC-V backend; * Sparc backend; * SystemZ backend; * WebAssembly backend; * X86 backend; * XCore backend; * libLTO; * Debug Information; * Remainder of llvm; * compiler-rt; * libunwind; * openmp; * parallel-libs; * polly; * lldb. #. Remove the old variable name rule from the policy page. #. Repeat many of the steps in the sequence, using a script to expand acronyms. References; ==========. .. [LLDB] LLDB Coding Conventions https://llvm.org/svn/llvm-project/lldb/branches/release_39/www/lldb-coding-conventions.html; .. [Google] Google C++ Style Guide https://google.github.io/styleguide/cppguide.html#Variable_Names; .. [WebKit] WebKit Code Style Guidelines https://webkit.org/code-style-guidelines/#names; .. [Qt] Qt Coding Style https://wiki.qt.io/Qt_Coding_Style#Declaring_variables; .. [Rust] Rust naming conventions https://doc.rust-lang.org/1.0.0/style/style/naming/README.html; .. [Swift] Swift API Design Guidelines https://swift.org/documentation/api-design-guidelines/#general-conventions; .. [Python] Style Guide for Python Code https://www.python.org/dev/peps/pep-0008/#function-and-variable-names; .. [Mozilla] Mozilla Coding style: Prefixes https://firefox-source-docs.mozilla.org/tools/lint/coding-style/coding_style_cpp.html#prefixes; .. [SVE] LLVM with support for SVE https://github.com/ARM-software/LLVM-SVE; .. [AminiInconsistent] Mehdi Amini, http://lists.llvm.org/pipermail/llvm-dev/2019-February/130329.html; .. [ArsenaultAgree] Matt Arsenault, http://lists.llvm.org/pipermail/llvm-dev/2019-February/129934.html; .. [BeylsDistinguish] Kristof Beyls, http://lists.llvm.org/pipermail/llvm-dev/2019-February/130292.html; .. [BradburyConcern] Alex Bradbury, http://lists.llvm.org/pipermail/llvm-dev/2019-February/130266.html; .. [BradburyTransition] Alex Bradbury, http://lists.llvm.org/pipermail/llvm-dev/2019-February/130388.html; .. [CarruthAcronym] Chandler Carruth, http://lists.llvm.org/pipermail/llvm-dev/2019-February/130313.html; .. [CarruthC",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Proposals/VariableNames.rst:13881,guid,guidelines,13881,interpreter/llvm-project/llvm/docs/Proposals/VariableNames.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Proposals/VariableNames.rst,1,['guid'],['guidelines']
Usability,"enerate:; 	ldr	r2, .LCPI0_0; 	and	r0, r0, r2; 	ldr	r2, .LCPI0_1; 	and	r1, r1, r2; 	orr	r0, r1, r0; 	bx	lr. We should be able to replace the second ldr+and with a bic (i.e. reuse the; constant which was already loaded). Not sure what's necessary to do that. //===---------------------------------------------------------------------===//. The code generated for bswap on armv4/5 (CPUs without rev) is less than ideal:. int a(int x) { return __builtin_bswap32(x); }. a:; 	mov	r1, #255, 24; 	mov	r2, #255, 16; 	and	r1, r1, r0, lsr #8; 	and	r2, r2, r0, lsl #8; 	orr	r1, r1, r0, lsr #24; 	orr	r0, r2, r0, lsl #24; 	orr	r0, r0, r1; 	bx	lr. Something like the following would be better (fewer instructions/registers):; 	eor r1, r0, r0, ror #16; 	bic r1, r1, #0xff0000; 	mov r1, r1, lsr #8; 	eor r0, r1, r0, ror #8; 	bx	lr. A custom Thumb version would also be a slight improvement over the generic; version. //===---------------------------------------------------------------------===//. Consider the following simple C code:. void foo(unsigned char *a, unsigned char *b, int *c) {; if ((*a | *b) == 0) *c = 0;; }. currently llvm-gcc generates something like this (nice branchless code I'd say):. ldrb r0, [r0]; ldrb r1, [r1]; orr r0, r1, r0; tst r0, #255; moveq r0, #0; streq r0, [r2]; bx lr. Note that both ""tst"" and ""moveq"" are redundant. //===---------------------------------------------------------------------===//. When loading immediate constants with movt/movw, if there are multiple; constants needed with the same low 16 bits, and those values are not live at; the same time, it would be possible to use a single movw instruction, followed; by multiple movt instructions to rewrite the high bits to different values.; For example:. volatile store i32 -1, i32* inttoptr (i32 1342210076 to i32*), align 4,; !tbaa; !0; volatile store i32 -1, i32* inttoptr (i32 1342341148 to i32*), align 4,; !tbaa; !0. is compiled and optimized to:. movw r0, #32796; mov.w r1, #-1; movt r0, #20480; str r1, [r0]; m",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/README.txt:18993,simpl,simple,18993,interpreter/llvm-project/llvm/lib/Target/ARM/README.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/README.txt,1,['simpl'],['simple']
Usability,"enough to show all items. The; choices may be mutually exclusive (a list box with single selection) or; not mutually exclusive (a list box with multiple selection). ![](pictures/02000219.jpg). The proper usage of the list boxes is for selecting values, or objects,; or setting attributes. You have to create them to display 4 to 8 choices; at one time (3 is a required minimum in case of lack of screen space).; The list should contain not more than 40 items accessible by scrolling; view (vertical scroll bar). If more are required, you should provide a; method for using search criteria or scoping the options. The best list; boxes use is for textual data or choices. They should be wide enough to; display fully all items. When it is not possible, break the long items; with ellipsis and provide tool tip that displays the full item text. The list box widget is represented by **`TGListBox`**,; **`TGLBContainer`**, **`TGLBEntry`** and **`TGTextLBEntry`** classes.; Currently entries are simple text strings (**`TGTextLBEntry`**). A; **`TGListBox`** looks a lot like a **`TGCanvas`**. It has a; **`TGViewPort`** containing a **`TGLBContainer`** which contains the; entries and it also has a vertical scrollbar which becomes visible if; there are more items than fit in the visible part of the container. The; **`TGListBox`** is user callable. The other classes are service classes; of the list box. Here is a sample code showing how to create a list box; with ten entries:. ``` {.cpp}; // list box widget containing 10 entries; int fFirstEntry = 0, fLastEntry = 10;; char tmp[20];; TGListBox *fListBox = new TGListBox(parent, 90);; for (i = fFirstEntry; i < fLastEntry; i++) {; sprintf(tmp, ""Entry %i"", i+1);; fListBox->AddEntry(tmp, i);; }; fListBox->Resize(150, 80);; parent->AddFrame(fListBox,new TGLayoutHints(kLHintsTop|kLHintsLeft,; 5, 5, 5, 5));; ```. We create the list box widget passing the parent window pointer and; giving an ID number. Next we add entries with specified string and ID",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md:79624,simpl,simple,79624,documentation/users-guide/WritingGUI.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md,1,['simpl'],['simple']
Usability,"ent RWebWindow instances for connection. ## Montecarlo Libraries. ## PROOF Libraries. ## Language Bindings. ## JavaScript ROOT. ## Jupyter lab. - Let use created notebooks with viewers like https://nbviewer.jupyter.org/; - Fix problem with using of local JSROOT version. ## Tutorials. - The tutorial games.C was not working properly. - Improve tutorial ErrorIntegral.C. - Schrödinger's Hydrogen Atom example. - Tutorial demonstrating how the changing of the range can zoom into the histogram. - Tutorial demonstrating how a Histogram can be read from a ROOT File. - histMax.C: a tutorial demoing how the hist->GetMaximumBin() can be used. ## Class Reference Guide. - Images for ROOT7 tutorials can be generated, in json format, using the directive using; `\macro_image (json)` in the macro header. - Clarify THStack drawing options. - Add missing documentation to TH1 functions. - Restructure the math reference guide. - Make the web gui documentation visible in the reference guide. - Make clear THtml is legacy code. Add deprecated flag on PROOF and TGeoTrack. - Improve many classes documentation: TContext, TTreePlayer, THistPainter, TGraph, TSelector,; integrator, GUI, TH1, TH2, TH3, TColor classes ... - Make the TFile layout doc visible in Reference Guide. - Update the external links of the reference guide main page. - Reformat TMVA mathcore Unuran Roostats documentation . ## Build, Configuration and Testing Infrastructure. - For users building from source the `latest-stable` branch and passing `-Droottest=ON` to the CMake command line, the corresponding revision of roottest pointed to by `latest-stable` will be downloaded as required. ## PyROOT. - The `ROOT` Python module is now properly serializable so that it is automatically available in the Python environment if a function or ROOT object needs to be serialized. See issue [#6764](https://github.com/root-project/root/issues/6764) for a concrete usecase.; - Improve overload resolution of functions that accept classes with long",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v626/index.md:38992,clear,clear,38992,README/ReleaseNotes/v626/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v626/index.md,1,['clear'],['clear']
Usability,"ent pads. When a displayed histogram is deleted, its image is; automatically removed from the pad. To create a copy of the histogram; when drawing it, you can use **`TH1`**`::DrawClone()`. This will clone; the histogram and allow you to change and delete the original one; without affecting the clone. You can use **`TH1`**`::DrawNormalized()`; to draw a normalized copy of a histogram. ``` {.cpp}; TH1 *TH1::DrawNormalized(Option_t *option,Double_t norm) const; ```. A clone of this histogram is normalized to norm and drawn with option.; A pointer to the normalized histogram is returned. The contents of the; histogram copy are scaled such that the new sum of weights (excluding; under and overflow) is equal to `norm` . Note that the returned normalized histogram is not added to the list; of histograms in the current directory in memory. It is the user's; responsibility to delete this histogram. The `kCanDelete` bit is set; for the returned object. If a pad containing this copy is cleared, the; histogram will be automatically deleted. See ""Draw Options"" for the; list of options. ### Setting the Style. Histograms use the current style ***`gStyle`***, which is the global; object of class **`TStyle`**. To change the current style for; histograms, the **`TStyle`** class provides a multitude of methods; ranging from setting the fill color to the axis tick marks. Here are; a few examples:. ``` {.cpp}; void SetHistFillColor(Color_t color = 1); void SetHistFillStyle(Style_t styl = 0); void SetHistLineColor(Color_t color = 1); void SetHistLineStyle(Style_t styl = 0); void SetHistLineWidth(Width_t width = 1); ```. When you change the current style and would like to propagate the; change to a previously created histogram you can call; **`TH1`**`::UseCurrentStyle()`. You will need to call; `UseCurrentStyle()` on each histogram. When reading many histograms; from a file and you wish to update them to the current style, you can; use ***`gROOT`***`::ForceStyle` and all histograms read a",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md:15160,clear,cleared,15160,documentation/users-guide/Histograms.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md,1,['clear'],['cleared']
Usability,"ental.convergence.loop() [ ""convergencectrl""(token %outer) ]; ; (B); call void @convergent.operation() [ ""convergencectrl""(token %inner) ]; call void @convergent.operation() [ ""convergencectrl""(token %inner) ]; counter -= 2;; }; ; (C); if (counter > 0) {; %remainder = call token @llvm.experimental.convergence.loop() [ ""convergencectrl""(token %outer) ]; ; (D); call void @convergent.operation() [ ""convergencectrl""(token %remainder) ]; }; ; (E). First of all, note some interesting problems surrounding the loop intrinsic:. 1. It is *not* duplicated inside the unrolled loop. This is to comply with; the :ref:`convergence_static_rules`. 2. It is unclear whether the loop intrinsic ought to be duplicated in the; remainder, or whether the final ``@convergent.operation`` in D should just; refer to either ``%inner`` (which is possible in SSA form) or directly to; ``%outer``. The decision made here is arbitrary and doesn't change the; argument that follows. Ultimately, it simply doesn't matter because the; transform is incorrect either way. The threads now execute the following sequences of blocks:. .. code-block:: text. Thread 1: A B C D E; Thread 2: A B B C D E. Analogous to the argument above, they execute converged dynamic instances of the; ``%inner`` intrinsic and the ``@convergent.operation`` in the first iteration; of the unrolled loop, which corresponds to the first 2 iterations of the; original loop. However, they execute different static calls to ``@convergent.operation`` for; the 3rd iteration of the original loop. In thread 1, that iteration corresponds; to the call in the remainder, while in thread 2 it corresponds to the first; call to ``@convergent.operation`` in the unrolled loop. Therefore, they execute; non-converged dynamic instances, which means that the set of communicating threads; for the 3rd iteration of the original loop is different. This is why the; unrolling is incorrect. On the other hand, unrolling without ""tail"" is allowed. For example, assuming; th",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ConvergentOperations.rst:53224,simpl,simply,53224,interpreter/llvm-project/llvm/docs/ConvergentOperations.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ConvergentOperations.rst,1,['simpl'],['simply']
Usability,"ently.; There are a number of ways to fix this bug, see what you can come up with! Here; is a testcase:. ::. extern foo(a); # ok, defines foo.; def foo(b) b; # Error: Unknown variable name. (decl using 'a' takes precedence). Driver Changes and Closing Thoughts; ===================================. For now, code generation to LLVM doesn't really get us much, except that; we can look at the pretty IR calls. The sample code inserts calls to; codegen into the ""``HandleDefinition``"", ""``HandleExtern``"" etc; functions, and then dumps out the LLVM IR. This gives a nice way to look; at the LLVM IR for simple functions. For example:. ::. ready> 4+5;; Read top-level expression:; define double @0() {; entry:; ret double 9.000000e+00; }. Note how the parser turns the top-level expression into anonymous; functions for us. This will be handy when we add `JIT; support <LangImpl04.html#adding-a-jit-compiler>`_ in the next chapter. Also note that the; code is very literally transcribed, no optimizations are being performed; except simple constant folding done by IRBuilder. We will `add; optimizations <LangImpl04.html#trivial-constant-folding>`_ explicitly in the next; chapter. ::. ready> def foo(a b) a*a + 2*a*b + b*b;; Read function definition:; define double @foo(double %a, double %b) {; entry:; %multmp = fmul double %a, %a; %multmp1 = fmul double 2.000000e+00, %a; %multmp2 = fmul double %multmp1, %b; %addtmp = fadd double %multmp, %multmp2; %multmp3 = fmul double %b, %b; %addtmp4 = fadd double %addtmp, %multmp3; ret double %addtmp4; }. This shows some simple arithmetic. Notice the striking similarity to the; LLVM builder calls that we use to create the instructions. ::. ready> def bar(a) foo(a, 4.0) + bar(31337);; Read function definition:; define double @bar(double %a) {; entry:; %calltmp = call double @foo(double %a, double 4.000000e+00); %calltmp1 = call double @bar(double 3.133700e+04); %addtmp = fadd double %calltmp, %calltmp1; ret double %addtmp; }. This shows some function",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl03.rst:18264,simpl,simple,18264,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl03.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl03.rst,1,['simpl'],['simple']
Usability,"entries in the Index (\< 0 indicates; failure). ## Branches. The organization of branches allows the designer to optimize the data; for the anticipated use. The class for a branch is called **`TBranch`**.; If two variables are independent, and the designer knows the variables; will not be used together, they should be placed on separate branches.; If, however, the variables are related, such as the coordinates of a; point, it is most efficient to create one branch with both coordinates; on it. A variable on a **`TBranch`** is called a leaf (yes -; **`TLeaf`**). Another point to keep in mind when designing trees is that; branches of the same **`TTree`** can be written to separate files. To; add a **`TBranch`** to a **`TTree`** we call the; method **`TTree::Branch()`**. Note that we DO NOT use the `TBranch`; constructor. The `TTree::Branch` method has several signatures. The branch type; differs by what is stored in it. A branch can hold an entire object, a; list of simple variables, contents of a folder, contents of a; **`TList`**, or an array of objects. Let's see some examples. To follow; along you will need the shared library `libEvent.so`. First, check if it; is in `$ROOTSYS/test`. If it is, copy it to your own area. If it is not; there, you have to build it by typing make in `$ROOTSYS/test`. ## Adding a Branch to Hold a List of Variables. As in the very first example (`cernstaff.root.root`); the data we want to save is a list of simple variables, such as integers; or floats. In this case, we use the following `TTree::Branch` signature:. ``` {.cpp}; tree->Branch(""Ev_Branch"",&event,; ""temp/F:ntrack/I:nseg:nvtex:flag/i"");; ```. The first parameter is the branch name. The second parameter is the address from which the first variable is to; be read. In the code above, ""event"" is a structure with one float and; three integers and one unsigned integer. You should not assume that the; compiler aligns the elements of a structure without gaps. To avoid; alignment problems,",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:18926,simpl,simple,18926,documentation/users-guide/Trees.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md,1,['simpl'],['simple']
Usability,"ents --> BaggedSampleFraction. have been replaced by options that are now given in terms of the relative; size of the training sample rather than in absulut numbers of events. This; is in order to facilitate the parameter tuning on different sample sizes; (i.e when starting on a smaller data sample to tune the parameter in order; to speed up the training); Furthermore, this option here has been changed name. GradBaggingFraction --> BaggedSampleFraction. in an attempt to consolidate and avoid idential duplicate code; ; The option UseWeightedTrees has been removed and set to ""true"", as was default; anyway, as a measure of further consolidation. Removed the option NNodesMax --> This should be replaced by specifying MaxDepth; instead (limiting the maximum tree depth also limits the number of possible nodes!). b) Added a trial version of a new ""cost sensitive"" boosting algorithem according to; Wei Fan and Salvatore J. Stolfo, {\em AdaCost: misclassification cost-sensitive boosting}, Proceedings of the 16th International conference on machine learning (ICML 1999)}. With the currently; chosen DEFAULT settings (all costs equal and set to ""one""), it is equivalent to the ""real-AdaBoost"" (i.e. using the option !UseYesNoLeaf (which uses the leave node purity rather than a signal or background attribute in the leaf node of each individual tree). Unfortunatly, no reasonable performance has been achieved yet when choosing different cost parameters. c) BDT's with little tree depth (as favoured for good performance) do not *like* it if; there are very clean signal and background separation cuts available, which however ; have NOT been applied yet as preselection. Now there is a possibility to choose the option; ""DoPreselection"" that looks for suitable preselection cuts and applies them prior to ; the Decision Tree training. While that works fine, this clearly gives ""sharp"" peaks at +1 (-1); for the MVA output distribution and therefore the ""smoothing"" of this distribution used to; pr",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/tmva/UsersGuide/ReleaseNotes4.2.0.txt:2152,learn,learning,2152,documentation/tmva/UsersGuide/ReleaseNotes4.2.0.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/tmva/UsersGuide/ReleaseNotes4.2.0.txt,1,['learn'],['learning']
Usability,"enumeration member (with a prefix, e.g. ``LS_Auto``), and as a value usable in; the configuration (without a prefix: ``Auto``). .. _BasedOnStyle:. **BasedOnStyle** (``String``) :ref:`¶ <BasedOnStyle>`; The style used for all options not specifically set in the configuration. This option is supported only in the :program:`clang-format` configuration; (both within ``-style='{...}'`` and the ``.clang-format`` file). Possible values:. * ``LLVM``; A style complying with the `LLVM coding standards; <https://llvm.org/docs/CodingStandards.html>`_; * ``Google``; A style complying with `Google's C++ style guide; <https://google.github.io/styleguide/cppguide.html>`_; * ``Chromium``; A style complying with `Chromium's style guide; <https://chromium.googlesource.com/chromium/src/+/refs/heads/main/styleguide/styleguide.md>`_; * ``Mozilla``; A style complying with `Mozilla's style guide; <https://firefox-source-docs.mozilla.org/code-quality/coding-style/index.html>`_; * ``WebKit``; A style complying with `WebKit's style guide; <https://www.webkit.org/coding/coding-style.html>`_; * ``Microsoft``; A style complying with `Microsoft's style guide; <https://docs.microsoft.com/en-us/visualstudio/ide/editorconfig-code-style-settings-reference>`_; * ``GNU``; A style complying with the `GNU coding standards; <https://www.gnu.org/prep/standards/standards.html>`_; * ``InheritParentConfig``; Not a real style, but allows to use the ``.clang-format`` file from the; parent directory (or its parent if there is none). If there is no parent; file found it falls back to the ``fallback`` style, and applies the changes; to that. With this option you can overwrite some parts of your main style for your; subdirectories. This is also possible through the command line, e.g.:; ``--style={BasedOnStyle: InheritParentConfig, ColumnLimit: 20}``. .. START_FORMAT_STYLE_OPTIONS. .. _AccessModifierOffset:. **AccessModifierOffset** (``Integer``) :versionbadge:`clang-format 3.3` :ref:`¶ <AccessModifierOffset>`; The ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:5950,guid,guide,5950,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,1,['guid'],['guide']
Usability,"ep->Fill(destep);; }. // we do not close the file; we want to keep the generated histograms;; // we fill a 3-d scatter plot with the particle step coordinates; TCanvas *c1 = new TCanvas(""c1"",""c1"",600,800);; c1->SetFillColor(42);; c1->Divide(1,2);. c1->cd(1);; hdestep->SetFillColor(45);; hdestep->Fit(""gaus"");. c1->cd(2);; gPad->SetFillColor(37); // continued...; t2->SetMarkerColor(kRed);; t2->Draw(""vect[0]:vect[1]:vect[2]"");; if (gROOT->IsBatch()) return;. // invoke the x3d viewer; gPad->GetViewer3D(""x3d"");; }; ```. ## Example 3: Adding Friends to Trees. In this example, we will show how to extend a tree with a branch from; another tree with the Friends feature. ### Adding a Branch to an Existing Tree. You may want to add a branch to an existing tree. For example, if one; variable in the tree was computed with a certain algorithm, you may want; to try another algorithm and compare the results. One solution is to add; a new branch, fill it, and save the tree. The code below adds a simple; branch to an existing tree. Note that the `kOverwrite` option in the; `Write` method overwrites the existing tree. If it is not specified, two; copies of the tree headers are saved. ``` {.cpp}; void tree3AddBranch() {; TFile f(""tree3.root"",""update"");; Float_t new_v;; TTree *t3 = (TTree*)f->Get(""t3"");; TBranch *newBranch = t3-> Branch(""new_v"",&new_v,""new_v/F"");; //read the number of entries in the t3; Int_t nentries = (Int_t)t3->GetEntries();; for (Int_t i = 0; i < nentries; i++){; new_v= gRandom->Gaus(0,1);; newBranch->Fill();; }; t3->Write("""",TObject::kOverwrite); // save only the new version of; // the tree; }; ```. Adding a branch is often not possible because the tree is in a read-only; file and you do not have permission to save the modified tree with the; new branch. Even if you do have the permission, you risk loosing the; original tree with an unsuccessful attempt to save the modification.; Since trees are usually large, adding a branch could extend it over the; 2GB limit. In",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:51307,simpl,simple,51307,documentation/users-guide/Trees.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md,1,['simpl'],['simple']
Usability,"eportee at LLVM events.; * Ending a talk/tutorial/etc at an LLVM event early. See immediate response; checklist for further clarification.; * Not publishing the video or slides of a talk.; * Not allowing a speaker to give (further) talks at LLVM events for a specified; amount of time or ever.; * Requiring that the reportee immediately leave an event and not return.; * Immediately ending any volunteer responsibilities and privileges the reportee; holds.; * An imposed suspension (e.g., asking someone to ""take a week off"" from mailing; lists, bug tracker, IRC, Discord, repositories, or other communication; forms). ; * A permanent or temporary ban from some or all LLVM Project spaces (online or; in person). Once a resolution is agreed upon, but before it is enacted, the committee will; contact the reporter and any other affected parties to explain the proposed; resolution. They will ask if this resolution is acceptable and must note; feedback for the record. However, the committee is not required to act on this; feedback. .. _Appeal Process:. Appeal Process; ===============. Any individual(s) determined to have violated the CoC have the right to appeal; a decision. An appeal can be made directly to the committee by sending an email; to conduct@llvm.org with subject line Code of Conduct Incident Appeal. The email should include documentation related to the incident to support the; appeal. The said documentation may include, but does not have to be limited to:. * Information from the reportee justifying reasoning for the appeal.; * Statements from other individuals involved in the incident to support the; appeal. Appeals can be requested up to 30 days after a resolution has been communicated; to the individual(s). The committee will aim to evaluate appeals within two weeks of receipt. In the event that appeal can not be evaluated within that time, the CoC committee will respond with an updated and projected timeline. . Conflicts of Interest; =====================. Committe",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ResponseGuide.rst:8849,feedback,feedback,8849,interpreter/llvm-project/llvm/docs/ResponseGuide.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ResponseGuide.rst,1,['feedback'],['feedback']
Usability,"epping through optimized programs. Secondly, optimization; can move variables in ways that are either optimized out, shared in memory; with other variables, or difficult to track. For the purposes of this; tutorial we're going to avoid optimization (as you'll see with one of the; next sets of patches). Ahead-of-Time Compilation Mode; ==============================. To highlight only the aspects of adding debug information to a source; language without needing to worry about the complexities of JIT debugging; we're going to make a few changes to Kaleidoscope to support compiling; the IR emitted by the front end into a simple standalone program that; you can execute, debug, and see results. First we make our anonymous function that contains our top level; statement be our ""main"":. .. code-block:: udiff. - auto Proto = std::make_unique<PrototypeAST>("""", std::vector<std::string>());; + auto Proto = std::make_unique<PrototypeAST>(""main"", std::vector<std::string>());. just with the simple change of giving it a name. Then we're going to remove the command line code wherever it exists:. .. code-block:: udiff. @@ -1129,7 +1129,6 @@ static void HandleTopLevelExpression() {; /// top ::= definition | external | expression | ';'; static void MainLoop() {; while (true) {; - fprintf(stderr, ""ready> "");; switch (CurTok) {; case tok_eof:; return;; @@ -1184,7 +1183,6 @@ int main() {; BinopPrecedence['*'] = 40; // highest. // Prime the first token.; - fprintf(stderr, ""ready> "");; getNextToken();. Lastly we're going to disable all of the optimization passes and the JIT so; that the only thing that happens after we're done parsing and generating; code is that the LLVM IR goes to standard error:. .. code-block:: udiff. @@ -1108,17 +1108,8 @@ static void HandleExtern() {; static void HandleTopLevelExpression() {; // Evaluate a top-level expression into an anonymous function.; if (auto FnAST = ParseTopLevelExpr()) {; - if (auto *FnIR = FnAST->codegen()) {; - // We're just doing this to make",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl09.rst:3112,simpl,simple,3112,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl09.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl09.rst,1,['simpl'],['simple']
Usability,"equested [here](https://sft.its.cern.ch/jira/browse/ROOT-9184); - New color palette ""cividis"" implemented by Sven Augustin.; This colormap aims to solve problems that people with color vision deficiency have; with the common colormaps. For more details see:; Nuñez J, Anderton C, and Renslow R. Optimizing colormaps with consideration; for color vision deficiency to enable accurate interpretation of scientific data.; See the article [here](https://arxiv.org/abs/1712.01662); - New graphics style ""ATLAS"" from M.Sutton.; - In `TGraphPainter` the fit parameters were painted too early. [In some cases graph's; error bars overlapped the stat box](https://root-forum.cern.ch/t/hide-error-bars-behind-tpavestats/27996).; - Implement the possibility to generate high definition bitmap pictures in `TImageDump`.; This done via `gStyle->SetImageScaling(x);` `x` being a multiplication factor.; This new feature is now used to generate the reference guide with `x=3`.; Pictures in the reference guide are now much shaper and in particular the text. ## 3D Graphics Libraries; - When a LEGO plot was drawn with Theta=90, the X and Y axis were misplaced. ## Geometry Libraries. ## Database Libraries; - Fix issue related to time stamps manipulation done by `TPgSQLStatement` as suggested [here](https://root-forum.cern.ch/t/please-correct-bug-reading-date-time-from-postgresql-tpgsqlstatement). ## Networking Libraries; - New THttpWSHandler class should be used to work with websockets. It includes all necessary methods to handle multiple connections correctly. See in tutorials/http/ws.C how it can be used.; - Interface of THttpWSEngine class was changed, all its instances handled internally in THttpWSHandler. ## GUI Libraries. ## Montecarlo Libraries. ## Parallelism; - `TTree::GetEntry`: if IMT is enabled, run work in tasks if we have at least more than one top level branch.; - Make EnableImplicitMT no-op if IMT is already on; - Decompress `TTreeCache` in parallel if IMT is on (upgrade of the `TTreeC",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v614/index.md:13978,guid,guide,13978,README/ReleaseNotes/v614/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v614/index.md,1,['guid'],['guide']
Usability,"er 3 is corrupt. Size is 10 when it should be 20. This is a bad message, since it does not provide useful information and uses the; wrong style:. .. code-block:: none. error: file.o: Corrupt section header. As with other coding standards, individual projects, such as the Clang Static; Analyzer, may have preexisting styles that do not conform to this. If a; different formatting scheme is used consistently throughout the project, use; that style instead. Otherwise, this standard applies to all LLVM tools,; including clang, clang-tidy, and so on. If the tool or project does not have existing functions to emit warnings or; errors, use the error and warning handlers provided in ``Support/WithColor.h``; to ensure they are printed in the appropriate style, rather than printing to; stderr directly. When using ``report_fatal_error``, follow the same standards for the message as; regular error messages. Assertion messages and ``llvm_unreachable`` calls do not; necessarily need to follow these same styles as they are automatically; formatted, and thus these guidelines may not be suitable. ``#include`` Style; ^^^^^^^^^^^^^^^^^^. Immediately after the `header file comment`_ (and include guards if working on a; header file), the `minimal list of #includes`_ required by the file should be; listed. We prefer these ``#include``\s to be listed in this order:. .. _Main Module Header:; .. _Local/Private Headers:. #. Main Module Header; #. Local/Private Headers; #. LLVM project/subproject headers (``clang/...``, ``lldb/...``, ``llvm/...``, etc); #. System ``#include``\s. and each category should be sorted lexicographically by the full path. The `Main Module Header`_ file applies to ``.cpp`` files which implement an; interface defined by a ``.h`` file. This ``#include`` should always be included; **first** regardless of where it lives on the file system. By including a; header file first in the ``.cpp`` files that implement the interfaces, we ensure; that the header does not have any hid",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodingStandards.rst:15689,guid,guidelines,15689,interpreter/llvm-project/llvm/docs/CodingStandards.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodingStandards.rst,1,['guid'],['guidelines']
Usability,"er HTML element position (#121); 2. Fix - prevent I/O failure when server automatically gzip response (#119); 3. Fix - lego drawing for stacked TH1 histograms; 4. Fix - when change global tooltips settings, also change for each sub-pad. ## Changes in 5.0.2; 1. Fix - read branch entries as arrays; 2. Fix - command submission to THttpServer; 3. Fix - let refill statbox also for empty histogram; 4. Fix - problem with online TTree::Draw and ROOT6. ## Changes in 5.0.1; 1. Support older ROOT files, created before 2010; 2. Support TBranchObject - appears in old files; 3. Correctly set TBasket buffer position for the entry; 4. Fix - problem with empty STL containers; 5. Fix - empty baskets at the end of branch store; 6. Fix - problem with zooming in THStack. ## Changes in 5.0.0; 1. Reading TTree data; - all kinds of branches, including split STL containers; - branches with several elementary leaves; - branches from different ROOT files; - JSROOT.TSelector class to access TTree data; - simple access to branch data with ""dump"" draw option; 2. TTree::Draw support; - simple 1D/2D/3D histograms; - simple cut conditions; - configurable histogram like ""px:py>>hist(50,-5,5,50,-5,5)""; - strings support; - iterate over arrays indexes, let use another branch as index values; - support ""Entry$"" and ""Entries$"" variables in expressions; - bits histogram like ""event.fTracks.fBits>>bits(16)""; - special handling of TBits; - arbitrary math function from JavaScript Math class, some TMath:: function from ROOT; - if branch is object, one could use methods ""TMath::Abs(lep1_p4.X()+lep1_p4.Y())""; - interactive player to configure and execute draw expression; 3. Full support of Float16_t and Double32_t types in I/O; 4. Drawing of RooPlot objects, I/O support for RooFit classes; 5. Many improvements in object inspector; - support of large lists; only first part is shown; - support of large arrays; values group in decades; - allow to call draw function for sub-elements in inspector; 6. Canvas or sele",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/changes.md:46867,simpl,simple,46867,js/changes.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/changes.md,1,['simpl'],['simple']
Usability,"er ``--precompile``; or ``-fmodule-output`` flags. The ``--precompile`` option generates the BMI as the output of the compilation and the output path; can be specified using the ``-o`` option. The ``-fmodule-output`` option generates the BMI as a by-product of the compilation.; If ``-fmodule-output=`` is specified, the BMI will be emitted the specified location. Then if; ``-fmodule-output`` and ``-c`` are specified, the BMI will be emitted in the directory of the; output file with the name of the input file with the new extension ``.pcm``. Otherwise, the BMI; will be emitted in the working directory with the name of the input file with the new extension; ``.pcm``. The style to generate BMIs by ``--precompile`` is called two-phase compilation since it takes; 2 steps to compile a source file to an object file. The style to generate BMIs by ``-fmodule-output``; is called one-phase compilation respectively. The one-phase compilation model is simpler; for build systems to implement and the two-phase compilation has the potential to compile faster due; to higher parallelism. As an example, if there are two module units A and B, and B depends on A, the; one-phase compilation model would need to compile them serially, whereas the two-phase compilation; model may be able to compile them simultaneously if the compilation from A.pcm to A.o takes a long; time. File name requirement; ~~~~~~~~~~~~~~~~~~~~~. The file name of an ``importable module unit`` should end with ``.cppm``; (or ``.ccm``, ``.cxxm``, ``.c++m``). The file name of a ``module implementation unit``; should end with ``.cpp`` (or ``.cc``, ``.cxx``, ``.c++``). The file name of BMIs should end with ``.pcm``.; The file name of the BMI of a ``primary module interface unit`` should be ``module_name.pcm``.; The file name of BMIs of ``module partition unit`` should be ``module_name-partition_name.pcm``. If the file names use different extensions, Clang may fail to build the module.; For example, if the filename of an ``imp",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst:7849,simpl,simpler,7849,interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst,1,['simpl'],['simpler']
Usability,"er around the ``ExtractLoop()`` scalar transformation to extract; each top-level loop into its own new function. If the loop is the *only* loop; in a given function, it is not touched. This is a pass most useful for; debugging via bugpoint. ``loop-reduce``: Loop Strength Reduction; ----------------------------------------. This pass performs a strength reduction on array references inside loops that; have as one or more of their components the loop induction variable. This is; accomplished by creating a new value to hold the initial value of the array; access for the first iteration, and then creating a new GEP instruction in the; loop to increment the value by the appropriate amount. .. _passes-loop-rotate:. ``loop-rotate``: Rotate Loops; -----------------------------. A simple loop rotation transformation. A summary of it can be found in; :ref:`Loop Terminology for Rotated Loops <loop-terminology-loop-rotate>`. .. _passes-loop-simplify:. ``loop-simplify``: Canonicalize natural loops; ---------------------------------------------. This pass performs several transformations to transform natural loops into a; simpler form, which makes subsequent analyses and transformations simpler and; more effective. A summary of it can be found in; :ref:`Loop Terminology, Loop Simplify Form <loop-terminology-loop-simplify>`. Loop pre-header insertion guarantees that there is a single, non-critical entry; edge from outside of the loop to the loop header. This simplifies a number of; analyses and transformations, such as :ref:`LICM <passes-licm>`. Loop exit-block insertion guarantees that all exit blocks from the loop (blocks; which are outside of the loop that have predecessors inside of the loop) only; have predecessors from inside of the loop (and are thus dominated by the loop; header). This simplifies transformations such as store-sinking that are built; into LICM. This pass also guarantees that loops will have exactly one backedge. Note that the :ref:`simplifycfg <passes-simpl",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Passes.rst:26607,simpl,simplify,26607,interpreter/llvm-project/llvm/docs/Passes.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Passes.rst,1,['simpl'],['simplify']
Usability,"er function; ROOT::Math::Functor1D f3(&myf1,&MyFunction1D::Eval);. cout << f1(2) << endl;; cout << f2(2) << endl;; cout << f3(2) << endl;. return 0;; }; ```. #### Wrapping One Dimensional Gradient Functions. The `ROOT::Math::GradFunctor1D` class is used to wrap one-dimensional gradient functions. It can be constructed in three different ways:; * Any object implementing both `double operator()( double)` for the function evaluation and `double Derivative(double)` for the function derivative.; * Any object implementing any member function like `Foo::XXX(double )` for the function evaluation and any other member function like `Foo::YYY(double )` for the derivative.; * Any two function objects implementing `double operator()( double )` . One object provides the function evaluation, the other the derivative. One or both function object can be a free C function of; type `double ()(double )`. #### Wrapping Multi-dimensional Functions. The class `ROOT::Math::Functor` is used to wrap in a very simple and convenient way multi-dimensional function objects. It can wrap all the following types:; * Any C++ callable object implementing `double operator()( const double * )`.; * A free C function of type `double ()(const double * )`.; * A member function with the correct signature like `Foo::Eval(const double * )`. In this case one pass the object pointer and a pointer to the member function `(&Foo::Eval)`. The function dimension is required when constructing the functor. Example of using `Functor`:; ```{.cpp}; #include ""Math/Functor.h"". class MyFunction {. public:; double operator()(const double *x) const {; return x[0]+x[1];; }. double Eval(const double * x) const { return x[0]+x[1]; }; };. double freeFunction(const double * x ); {; return x[0]+x[1];; }. int main(); {; // test directly calling the function object; MyFunction myf;. // test from a free function pointer; ROOT::Math::Functor f1(&freeFunction,2);. // test from function object; ROOT::Math::Functor f2(myf,2);. // test fro",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:44873,simpl,simple,44873,documentation/users-guide/MathLibraries.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md,1,['simpl'],['simple']
Usability,"er is involved in a report, the member will be asked to recuse themselves; from ongoing conversations, and they will not have access to reports after the; enforcement decision has been made. . In the event of a temporary suspension or ban, the appropriate people must be; notified of the ban in order to restrict access to infrastructure or events.; These individuals will only be notified of the person's name and the; restrictions imposed. They will be under a confidentiality clause and not; allowed to respond to questions regarding the ban and should direct all; questions to the CoC committee. . .. _Transparency Reports:. Transparency Reports; ====================. Lack of transparency in the outcomes of our Code of Conduct incidents leaves; our community without an understanding of how or if the organizers worked to; resolve incidents. The CoC committee should aim to publish transparency; reports, if reports are received, after major events (such as the LLVM; Developers' meetings) and on the following dates: Jan 15, April 15, July 15,; Oct 15. . A transparency report consists of 2 parts:. * An overview of the reports received, and resolutions.; * A more detailed summary of each reported incident and the resolution while; maintaining confidentiality. These reports will be published on the LLVM website. Thanks!; =======. This guide was created and inspired by the following: the `Django Project`_,; `Carpentries Response Guide`_, and the `Write The Docs Response Guide`_. License; =======. All content on this page is licensed under a `Creative Commons Attribution 3.0; Unported License`_. .. _Django Project: https://www.djangoproject.com/conduct/; .. _Carpentries Response Guide: https://docs.carpentries.org/topic_folders/policies/enforcement-guidelines.html; .. _Write The Docs Response Guide: https://www.writethedocs.org/code-of-conduct/#guidelines-for-reporting-incidents; .. _Creative Commons Attribution 3.0 Unported License: http://creativecommons.org/licenses/by/3.0/. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ResponseGuide.rst:12701,guid,guide,12701,interpreter/llvm-project/llvm/docs/ResponseGuide.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ResponseGuide.rst,3,['guid'],"['guide', 'guidelines', 'guidelines-for-reporting-incidents']"
Usability,"er time. This lets us cover a range of language design and LLVM-specific; ideas, showing and explaining the code for it all along the way,; and reduces the overwhelming amount of details up front. We strongly; encourage that you *work with this code* - make a copy and hack it up and; experiment. **Warning**: In order to focus on teaching compiler techniques and LLVM; specifically,; this tutorial does *not* show best practices in software engineering; principles. For example, the code uses global variables; pervasively, doesn't use; `visitors <http://en.wikipedia.org/wiki/Visitor_pattern>`_, etc... but; instead keeps things simple and focuses on the topics at hand. This tutorial is structured into chapters covering individual topics,; allowing you to skip ahead as you wish:. - `Chapter #1: Kaleidoscope language and Lexer <LangImpl01.html>`_ -; This shows where we are; going and the basic functionality that we want to build. A lexer; is also the first part of building a parser for a language, and we; use a simple C++ lexer which is easy to understand.; - `Chapter #2: Implementing a Parser and AST <LangImpl02.html>`_ -; With the lexer in place, we can talk about parsing techniques and; basic AST construction. This tutorial describes recursive descent; parsing and operator precedence parsing.; - `Chapter #3: Code generation to LLVM IR <LangImpl03.html>`_ - with; the AST ready, we show how easy it is to generate LLVM IR, and show; a simple way to incorporate LLVM into your project.; - `Chapter #4: Adding JIT and Optimizer Support <LangImpl04.html>`_ -; One great thing about LLVM is its support for JIT compilation, so; we'll dive right into it and show you the 3 lines it takes to add JIT; support. Later chapters show how to generate .o files.; - `Chapter #5: Extending the Language: Control Flow <LangImpl05.html>`_ - With; the basic language up and running, we show how to extend; it with control flow operations ('if' statement and a 'for' loop). This; gives us a chance to t",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/index.rst:1846,simpl,simple,1846,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/index.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/index.rst,1,['simpl'],['simple']
Usability,"er') to break the input up into ""tokens"". Each token returned by; the lexer includes a token code and potentially some metadata (e.g. the; numeric value of a number). First, we define the possibilities:. .. code-block:: c++. // The lexer returns tokens [0-255] if it is an unknown character, otherwise one; // of these for known things.; enum Token {; tok_eof = -1,. // commands; tok_def = -2,; tok_extern = -3,. // primary; tok_identifier = -4,; tok_number = -5,; };. static std::string IdentifierStr; // Filled in if tok_identifier; static double NumVal; // Filled in if tok_number. Each token returned by our lexer will either be one of the Token enum; values or it will be an 'unknown' character like '+', which is returned; as its ASCII value. If the current token is an identifier, the; ``IdentifierStr`` global variable holds the name of the identifier. If; the current token is a numeric literal (like 1.0), ``NumVal`` holds its; value. We use global variables for simplicity, but this is not the; best choice for a real language implementation :). The actual implementation of the lexer is a single function named; ``gettok``. The ``gettok`` function is called to return the next token; from standard input. Its definition starts as:. .. code-block:: c++. /// gettok - Return the next token from standard input.; static int gettok() {; static int LastChar = ' ';. // Skip any whitespace.; while (isspace(LastChar)); LastChar = getchar();. ``gettok`` works by calling the C ``getchar()`` function to read; characters one at a time from standard input. It eats them as it; recognizes them and stores the last character read, but not processed,; in LastChar. The first thing that it has to do is ignore whitespace; between tokens. This is accomplished with the loop above. The next thing ``gettok`` needs to do is recognize identifiers and; specific keywords like ""def"". Kaleidoscope does this with this simple; loop:. .. code-block:: c++. if (isalpha(LastChar)) { // identifier: [a-zA-Z][a-zA-",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl01.rst:3163,simpl,simplicity,3163,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl01.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl01.rst,1,['simpl'],['simplicity']
Usability,"er:. Stream Header; =============; At offset 0 of the DBI Stream is a header with the following layout:. .. code-block:: c++. struct DbiStreamHeader {; int32_t VersionSignature;; uint32_t VersionHeader;; uint32_t Age;; uint16_t GlobalStreamIndex;; uint16_t BuildNumber;; uint16_t PublicStreamIndex;; uint16_t PdbDllVersion;; uint16_t SymRecordStream;; uint16_t PdbDllRbld;; int32_t ModInfoSize;; int32_t SectionContributionSize;; int32_t SectionMapSize;; int32_t SourceInfoSize;; int32_t TypeServerMapSize;; uint32_t MFCTypeServerIndex;; int32_t OptionalDbgHeaderSize;; int32_t ECSubstreamSize;; uint16_t Flags;; uint16_t Machine;; uint32_t Padding;; };. - **VersionSignature** - Unknown meaning. Appears to always be ``-1``. - **VersionHeader** - A value from the following enum. .. code-block:: c++. enum class DbiStreamVersion : uint32_t {; VC41 = 930803,; V50 = 19960307,; V60 = 19970606,; V70 = 19990903,; V110 = 20091201; };. Similar to the :doc:`PDB Stream <PdbStream>`, this value always appears to be; ``V70``, and it is not clear what the other values are for. - **Age** - The number of times the PDB has been written. Equal to the same; field from the :ref:`PDB Stream header <pdb_stream_header>`. - **GlobalStreamIndex** - The index of the :doc:`Global Symbol Stream <GlobalStream>`,; which contains CodeView symbol records for all global symbols. Actual records; are stored in the symbol record stream, and are referenced from this stream. - **BuildNumber** - A bitfield containing values representing the major and minor; version number of the toolchain (e.g. 12.0 for MSVC 2013) used to build the; program, with the following layout:. .. code-block:: c++. uint16_t MinorVersion : 8;; uint16_t MajorVersion : 7;; uint16_t NewVersionFormat : 1;. For the purposes of LLVM, we assume ``NewVersionFormat`` to be always ``true``.; If it is ``false``, the layout above does not apply and the reader should consult; the `Microsoft Source Code <https://github.com/Microsoft/microsoft-pdb>`__ for",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/PDB/DbiStream.rst:1810,clear,clear,1810,interpreter/llvm-project/llvm/docs/PDB/DbiStream.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/PDB/DbiStream.rst,1,['clear'],['clear']
Usability,"er_context;; }. .. code-block:: llvm. %resume_func_ptr = call ptr @llvm.coro.async.resume(); call {ptr, ptr, ptr} (ptr, ptr, ...) @llvm.coro.suspend.async(; ptr %resume_func_ptr,; ptr %context_projection_function. The frontend should provide a `async function pointer` struct associated with; each async coroutine by `llvm.coro.id.async`'s argument. The initial size and; alignment of the `async context` must be provided as arguments to the; `llvm.coro.id.async` intrinsic. Lowering will update the size entry with the; coroutine frame requirements. The frontend is responsible for allocating the; memory for the `async context` but can use the `async function pointer` struct; to obtain the required size. .. code-block:: c. struct async_function_pointer {; uint32_t relative_function_pointer_to_async_impl;; uint32_t context_size;; }. Lowering will split an async coroutine into a ramp function and one resume; function per suspend point. How control-flow is passed between caller, suspension point, and back to; resume function is left up to the frontend. The suspend point takes a function and its arguments. The function is intended; to model the transfer to the callee function. It will be tail called by; lowering and therefore must have the same signature and calling convention as; the async coroutine. .. code-block:: llvm. call {ptr, ptr, ptr} (ptr, ptr, ...) @llvm.coro.suspend.async(; ptr %resume_func_ptr,; ptr %context_projection_function,; ptr %suspend_function,; ptr %arg1, ptr %arg2, i8 %arg3). Coroutines by Example; =====================. The examples below are all of switched-resume coroutines. Coroutine Representation; ------------------------. Let's look at an example of an LLVM coroutine with the behavior sketched; by the following pseudo-code. .. code-block:: c++. void *f(int n) {; for(;;) {; print(n++);; <suspend> // returns a coroutine handle on first suspend; }; }. This coroutine calls some function `print` with value `n` as an argument and; suspends execution. E",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst:10177,resume,resume,10177,interpreter/llvm-project/llvm/docs/Coroutines.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst,1,['resume'],['resume']
Usability,"eral, hoisting and sinking of convergent operations is forbidden. This is; because moving the operation to a different point in control flow generally; changes the set of threads that reach the operation and therefore, the set of; threads that execute converged dynamic instances of the operation. By; definition, this changes the set of threads that participate in the; communication of the convergent operation, which will typically change its; result. There are a number of exceptions, though most of them require additional; knowledge. For example, hoisting and sinking across *uniform* conditional branches -- i.e.,; conditional branches where within every possible relevant set of threads, all; threads will always take the same direction -- is generally allowed. See the end; of the :ref:`example of reductions inside control flow; <convergence_example_reductions>` for a brief discussion. Some convergent operations can be hoisted but not sunk, or vice versa. A simple; example is the ``subgroupShuffle(data, id)`` operation. It returns the ``data``; operand of the thread identified by ``id``, where thread IDs are fixed and; assigned to each thread at launch. The result is undefined (or perhaps there is; UB, depending on the language and environment) if thread ``id`` is not in the; communicating set of threads. So hoisting is allowed in the following; pseudo-code example:. .. code-block:: llvm. define void @example(...) convergent {; %entry = call token @llvm.experimental.convergence.entry(); %data = ...; %id = ...; if (condition) {; %shuffled = call i32 @subgroupShuffle(i32 %data, i32 %id) [ ""convergencectrl""(token %entry) ]; ...; } else {; %shuffled = call i32 @subgroupShuffle(i32 %data, i32 %id) [ ""convergencectrl""(token %entry) ]; ...; }; }. After hoisting the calls to ``@subgroupShuffle``, the communicating set of; threads is the union of the two sets of threads in the original program, so; ``%id`` can only go ""out of range"" after hoisting if it did so in the original;",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ConvergentOperations.rst:56051,simpl,simple,56051,interpreter/llvm-project/llvm/docs/ConvergentOperations.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ConvergentOperations.rst,1,['simpl'],['simple']
Usability,"erface. Home; Download; News; Docs. Documentation. Developer. Doxygen; Extensions; Error Recovery; Late Binding. End User. User Manual; Status of ObjC[++] Support. Get Involved. Latest News; Cling goes public; July 25th, 2011; Cling was officially announced to the Clang community Read more. New website launched; July 1st, 2011; Welcome to the new website of the project. Read more; Useful Links. CERN. Extensions. Cling has several additional features. The main reason for their implementation is to improve the interactivity of the prompt. We call them language extensions.; ; For instance, language extensions are:; Execution of statements and expressions on the fly - From user's point of view it would make much sense if functions could be called by typing the function name at the prompt. This is true for other handy operations like creation of objects. However, the operations that do it are classified as statements and expressions, entered on the global scope. Statements and expressions on the global scope are not allowed by the C/C++/ObjC/ObjC++ grammar. Cling's prompt allows entering statements and expression on the global scope as transforming them into proper language constructs. ; Easy print out of the execution results - The way of signaling that the user wants to see the result of the entered and executed code is done by omitting the semicolon in the end. The standard doesn't allow statements (except those that change the control flow - such as if, for, while) without semicolon (;) in the end. However, this appears to be really simple and useful language extension that improves the user-cling interplay. Imagine if you had to write printf every time that you want to see the result of a function call. . See Also:; ; Statements and expression on the global scope in details; Easy printing of execution results in details. Copyright © Cling Team; . The ROOT Framework |; LLVM |; Clang |; Web Design. Page was modified on $Date$ in $Rev: 41615 $ by $Author: vvassilev $. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/docs/internal/extensions.html:1633,simpl,simple,1633,interpreter/cling/www/docs/internal/extensions.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/docs/internal/extensions.html,1,['simpl'],['simple']
Usability,"erface. Implementing a loop pass is usually straightforward.; ``LoopPass``\ es may override three virtual methods to do their work. All; these methods should return ``true`` if they modified the program, or ``false``; if they didn't. A ``LoopPass`` subclass which is intended to run as part of the main loop pass; pipeline needs to preserve all of the same *function* analyses that the other; loop passes in its pipeline require. To make that easier,; a ``getLoopAnalysisUsage`` function is provided by ``LoopUtils.h``. It can be; called within the subclass's ``getAnalysisUsage`` override to get consistent; and correct behavior. Analogously, ``INITIALIZE_PASS_DEPENDENCY(LoopPass)``; will initialize this set of function analyses. The ``doInitialization(Loop *, LPPassManager &)`` method; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. .. code-block:: c++. virtual bool doInitialization(Loop *, LPPassManager &LPM);. The ``doInitialization`` method is designed to do simple initialization type of; stuff that does not depend on the functions being processed. The; ``doInitialization`` method call is not scheduled to overlap with any other; pass executions (thus it should be very fast). ``LPPassManager`` interface; should be used to access ``Function`` or ``Module`` level analysis information. .. _writing-an-llvm-pass-runOnLoop:. The ``runOnLoop`` method; ^^^^^^^^^^^^^^^^^^^^^^^^. .. code-block:: c++. virtual bool runOnLoop(Loop *, LPPassManager &LPM) = 0;. The ``runOnLoop`` method must be implemented by your subclass to do the; transformation or analysis work of your pass. As usual, a ``true`` value; should be returned if the function is modified. ``LPPassManager`` interface; should be used to update loop nest. The ``doFinalization()`` method; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. .. code-block:: c++. virtual bool doFinalization();. The ``doFinalization`` method is an infrequently used method that is called; when the pass framework has finished calling :ref:`runOnLoop; <writ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/WritingAnLLVMPass.rst:21558,simpl,simple,21558,interpreter/llvm-project/llvm/docs/WritingAnLLVMPass.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/WritingAnLLVMPass.rst,1,['simpl'],['simple']
Usability,"ering, a coroutine is assumed to take the current `async context` as; one of its arguments (the argument position is determined by; `llvm.coro.id.async`). It is used to marshal arguments and return values of the; coroutine. Therefore an async coroutine returns `void`. .. code-block:: llvm. define swiftcc void @async_coroutine(ptr %async.ctxt, ptr, ptr) {; }. Values live across a suspend point need to be stored in the coroutine frame to; be available in the continuation function. This frame is stored as a tail to the; `async context`. Every suspend point takes an `context projection function` argument which; describes how-to obtain the continuations `async context` and every suspend; point has an associated `resume function` denoted by the; `llvm.coro.async.resume` intrinsic. The coroutine is resumed by calling this; `resume function` passing the `async context` as the one of its arguments; argument. The `resume function` can restore its (the caller's) `async context`; by applying a `context projection function` that is provided by the frontend as; a parameter to the `llvm.coro.suspend.async` intrinsic. .. code-block:: c. // For example:; struct async_context {; struct async_context *caller_context;; ...; }. char *context_projection_function(struct async_context *callee_ctxt) {; return callee_ctxt->caller_context;; }. .. code-block:: llvm. %resume_func_ptr = call ptr @llvm.coro.async.resume(); call {ptr, ptr, ptr} (ptr, ptr, ...) @llvm.coro.suspend.async(; ptr %resume_func_ptr,; ptr %context_projection_function. The frontend should provide a `async function pointer` struct associated with; each async coroutine by `llvm.coro.id.async`'s argument. The initial size and; alignment of the `async context` must be provided as arguments to the; `llvm.coro.id.async` intrinsic. Lowering will update the size entry with the; coroutine frame requirements. The frontend is responsible for allocating the; memory for the `async context` but can use the `async function pointer` struct;",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst:8756,resume,resume,8756,interpreter/llvm-project/llvm/docs/Coroutines.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst,1,['resume'],['resume']
Usability,"ernel. This notebook is running `llvm-tblgen`. ```tablegen; %reset; // This is some tablegen; class Foo {}; ```. ------------- Classes -----------------; class Foo {; }; ------------- Defs -----------------. Errors printed to stderr are shown. ```tablegen; %reset; This is not tablegen.; ```. <stdin>:1:1: error: Unexpected token at top level; This is not tablegen.; ^. Add some classes to get some output. ```tablegen; %reset; class Stuff {}; def thing : Stuff {}; ```. ------------- Classes -----------------; class Stuff {; }; ------------- Defs -----------------; def thing {	// Stuff; }. By default cells are connected. Meaning that we cache the code and magic directives from the previously run cells. This means that the next cell still sees the `Stuff` class. ```tablegen; def other_thing : Stuff {}; ```. ------------- Classes -----------------; class Stuff {; }; ------------- Defs -----------------; def other_thing {	// Stuff; }; def thing {	// Stuff; }. You can use the magic `%reset` to clear this cache and start fresh. ```tablegen; %reset; def other_thing : Stuff {}; ```. <stdin>:1:19: error: Couldn't find class 'Stuff'; def other_thing : Stuff {}; ^. You can also configure the default reset behaviour using the `%config` magic. ```tablegen; %config cellreset on; class Thing {}; ```. ------------- Classes -----------------; class Thing {; }; ------------- Defs -----------------. ```tablegen; // The cache is reset here so this is an error.; def AThing: Thing {}; ```. <stdin>:2:13: error: Couldn't find class 'Thing'; def AThing: Thing {}; ^. The default value is `off`, meaning cells are connected. If you want to override the default for one cell only, use the `%reset` or `%noreset` magic. These always override the default. ```tablegen; class Thing {}; ```. ------------- Classes -----------------; class Thing {; }; ------------- Defs -----------------. ```tablegen; %noreset; // This works because of the noreset above.; def AThing: Thing {}; ```. ------------- Classes --",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/jupyter/LLVM_TableGen.md:1018,clear,clear,1018,interpreter/llvm-project/llvm/utils/TableGen/jupyter/LLVM_TableGen.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/jupyter/LLVM_TableGen.md,1,['clear'],['clear']
Usability,"ers whose; type is a qualified-``id`` (e.g., ``id<Foo>``). This mangling allows such; parameters to be differentiated from those with the regular unqualified ``id``; type. This was a non-backward compatible mangling change to the ABI. This change; allows proper overloading, and also prevents mangling conflicts with template; parameters of protocol-qualified type. Query the presence of this new mangling with; ``__has_feature(objc_protocol_qualifier_mangling)``. Initializer lists for complex numbers in C; ==========================================. clang supports an extension which allows the following in C:. .. code-block:: c++. #include <math.h>; #include <complex.h>; complex float x = { 1.0f, INFINITY }; // Init to (1, Inf). This construct is useful because there is no way to separately initialize the; real and imaginary parts of a complex variable in standard C, given that clang; does not support ``_Imaginary``. (Clang also supports the ``__real__`` and; ``__imag__`` extensions from gcc, which help in some cases, but are not usable; in static initializers.). Note that this extension does not allow eliding the braces; the meaning of the; following two lines is different:. .. code-block:: c++. complex float x[] = { { 1.0f, 1.0f } }; // [0] = (1, 1); complex float x[] = { 1.0f, 1.0f }; // [0] = (1, 0), [1] = (1, 0). This extension also works in C++ mode, as far as that goes, but does not apply; to the C++ ``std::complex``. (In C++11, list initialization allows the same; syntax to be used with ``std::complex`` with the same meaning.). For GCC compatibility, ``__builtin_complex(re, im)`` can also be used to; construct a complex number from the given real and imaginary components. OpenCL Features; ===============. Clang supports internal OpenCL extensions documented below. ``__cl_clang_bitfields``; --------------------------------. With this extension it is possible to enable bitfields in structs; or unions using the OpenCL extension pragma mechanism detailed in; `the Op",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:84784,usab,usable,84784,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst,1,['usab'],['usable']
Usability,"erwise, the DWARF expression is ill-formed. *Many compilers store a single variable in sets of registers or store a; variable partially in memory and partially in registers.* ``DW_OP_piece``; *provides a way of describing where a part of a variable is located.*. *If a non-0 byte displacement is required, the* ``DW_OP_LLVM_offset``; *operation can be used to update the location description before using it as; the part location description of a* ``DW_OP_piece`` *operation.*. *The evaluation rules for the* ``DW_OP_piece`` *operation allow it to be; compatible with the DWARF Version 5 definition.*. .. note::. Since these extensions allow location descriptions to be entries on the; stack, a simpler operation to create composite location descriptions could; be defined. For example, just one operation that specifies how many parts,; and pops pairs of stack entries for the part size and location; description. Not only would this be a simpler operation and avoid the; complexities of incomplete composite location descriptions, but it may; also have a smaller encoding in practice. However, the desire for; compatibility with DWARF Version 5 is likely a stronger consideration. 2. ``DW_OP_bit_piece``. ``DW_OP_bit_piece`` has two operands. The first is an unsigned LEB128; integer that represents the part bit size S. The second is an unsigned; LEB128 integer that represents a bit displacement B. The action is the same as for ``DW_OP_piece``, except that any part created; has the bit size S, and the location description PL of any created part is; updated as if the ``DW_OP_constu B; DW_OP_LLVM_bit_offset`` operations were; applied. ``DW_OP_bit_piece`` *is used instead of* ``DW_OP_piece`` *when the piece to; be assembled is not byte-sized or is not at the start of the part location; description.*. *If a computed bit displacement is required, the* ``DW_OP_LLVM_bit_offset``; *operation can be used to update the location description before using it as; the part location description of a*",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst:136192,simpl,simpler,136192,interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,1,['simpl'],['simpler']
Usability,"es also need to be; checked if they are invalidated:. .. code-block:: c++. bool FooAnalysisResult::invalidate(Function &F, const PreservedAnalyses &PA,; FunctionAnalysisManager::Invalidator &Inv) {; auto PAC = PA.getChecker<FooAnalysis>();; if (!PAC.preserved() && !PAC.preservedSet<AllAnalysesOn<Function>>()); return true;. // Check transitive dependencies.; return Inv.invalidate<BarAnalysis>(F, PA) ||; Inv.invalidate<BazAnalysis>(F, PA);; }. Combining invalidation and analysis manager proxies results in some; complexity. For example, when we invalidate all analyses in a module pass,; we have to make sure that we also invalidate function analyses accessible via; any existing inner proxies. The inner proxy's ``invalidate()`` first checks; if the proxy itself should be invalidated. If so, that means the proxy may; contain pointers to IR that is no longer valid, meaning that the inner proxy; needs to completely clear all relevant analysis results. Otherwise the proxy; simply forwards the invalidation to the inner analysis manager. Generally for outer proxies, analysis results from the outer analysis manager; should be immutable, so invalidation shouldn't be a concern. However, it is; possible for some inner analysis to depend on some outer analysis, and when; the outer analysis is invalidated, we need to make sure that dependent inner; analyses are also invalidated. This actually happens with alias analysis; results. Alias analysis is a function-level analysis, but there are; module-level implementations of specific types of alias analysis. Currently; ``GlobalsAA`` is the only module-level alias analysis and it generally is not; invalidated so this is not so much of a concern. See; ``OuterAnalysisManagerProxy::Result::registerOuterAnalysisInvalidation()``; for more details. Invoking ``opt``; ================. .. code-block:: shell. $ opt -passes='pass1,pass2' /tmp/a.ll -S; # -p is an alias for -passes; $ opt -p pass1,pass2 /tmp/a.ll -S. The new PM typically requires exp",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/NewPassManager.rst:17495,simpl,simply,17495,interpreter/llvm-project/llvm/docs/NewPassManager.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/NewPassManager.rst,1,['simpl'],['simply']
Usability,"es can be identified using the AST call VarDecl::isNRVOVariable.; . Handle constructors of lambda captures; Variables which are captured by value into a lambda require a call to; a copy constructor.; This call is not currently modeled.; . Handle constructors for default arguments; Default arguments in C++ are recomputed at every call,; and are therefore local, and not static, variables.; See tests cases in handle_constructors_for_default_arguments.cpp.; . Default arguments are annoying because the initializer expression is; evaluated at the call site but doesn't syntactically belong to the; caller's AST; instead it belongs to the ParmVarDecl for the default; parameter. This can lead to situations when the same expression has to; carry different values simultaneously -; when multiple instances of the same function are evaluated as part of the; same full-expression without specifying the default arguments.; Even simply calling the function twice (not necessarily within the; same full-expression) may lead to program points agglutinating because; it's the same expression. There are some nasty test cases already; in temporaries.cpp (struct DefaultParam and so on). I recommend adding a; new LocationContext kind specifically to deal with this problem. It'll; also help you figure out the construction context when you evaluate the; construct-expression (though you might still need to do some additional; CFG work to get construction contexts right).; . Enhance the modeling of the standard library.; The analyzer needs a better understanding of STL in order to be more; useful on C++ codebases.; While full library modeling is not an easy task,; large gains can be achieved by supporting only a few cases:; e.g. calling .length() on an empty; std::string always yields zero.; (Difficulty: Medium). Enhance CFG to model exception-handling.; Currently exceptions are treated as ""black holes"", and exception-handling; control structures are poorly modeled in order to be conservative.; This",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/open_projects.html:5108,simpl,simply,5108,interpreter/llvm-project/clang/www/analyzer/open_projects.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/open_projects.html,1,['simpl'],['simply']
Usability,"es flags are present |; | | - PDB contains an :doc:`IPI Stream <TpiStream>` |; +------------------+-------------------------------------------------+; | VC140 | - Other feature flags may be present |; | | - PDB contains an :doc:`IPI Stream <TpiStream>` |; +------------------+-------------------------------------------------+; | NoTypeMerge | - Presumably duplicate types can appear in the |; | | TPI Stream, although it's unclear why this |; | | might happen. |; +------------------+-------------------------------------------------+; | MinimalDebugInfo | - Program was linked with /DEBUG:FASTLINK |; | | - There is no TPI / IPI stream, all type info |; | | is contained in the original object files. |; +------------------+-------------------------------------------------+. Matching a PDB to its executable; ================================; The linker is responsible for writing both the PDB and the final executable, and; as a result is the only entity capable of writing the information necessary to; match the PDB to the executable. In order to accomplish this, the linker generates a guid for the PDB (or; re-uses the existing guid if it is linking incrementally) and increments the Age; field. The executable is a PE/COFF file, and part of a PE/COFF file is the presence of; number of ""directories"". For our purposes here, we are interested in the ""debug; directory"". The exact format of a debug directory is described by the; `IMAGE_DEBUG_DIRECTORY structure <https://msdn.microsoft.com/en-us/library/windows/desktop/ms680307(v=vs.85).aspx>`__.; For this particular case, the linker emits a debug directory of type; ``IMAGE_DEBUG_TYPE_CODEVIEW``. The format of this record is defined in; ``llvm/DebugInfo/CodeView/CVDebugRecord.h``, but it suffices to say here only; that it includes the same ``Guid`` and ``Age`` fields. At runtime, a; debugger or tool can scan the COFF executable image for the presence of; a debug directory of the correct type and verify that the Guid and Age match.; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/PDB/PdbStream.rst:5727,guid,guid,5727,interpreter/llvm-project/llvm/docs/PDB/PdbStream.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/PDB/PdbStream.rst,2,['guid'],['guid']
Usability,"es in the ""``.debug_names``"" section. In the ""``.apple_names``"" section for Objective-C functions, the full name is; the entire function name with the brackets (""``-[NSString; stringWithCString:]``"") and the basename is the selector only; (""``stringWithCString:``""). Mach-O Changes; """""""""""""""""""""""""""". The sections names for the apple hash tables are for non-mach-o files. For; mach-o files, the sections should be contained in the ``__DWARF`` segment with; names as follows:. * ""``.apple_names``"" -> ""``__apple_names``""; * ""``.apple_types``"" -> ""``__apple_types``""; * ""``.apple_namespaces``"" -> ""``__apple_namespac``"" (16 character limit); * ""``.apple_objc``"" -> ""``__apple_objc``"". .. _codeview:. CodeView Debug Info Format; ==========================. LLVM supports emitting CodeView, the Microsoft debug info format, and this; section describes the design and implementation of that support. Format Background; -----------------. CodeView as a format is clearly oriented around C++ debugging, and in C++, the; majority of debug information tends to be type information. Therefore, the; overriding design constraint of CodeView is the separation of type information; from other ""symbol"" information so that type information can be efficiently; merged across translation units. Both type information and symbol information is; generally stored as a sequence of records, where each record begins with a; 16-bit record size and a 16-bit record kind. Type information is usually stored in the ``.debug$T`` section of the object; file. All other debug info, such as line info, string table, symbol info, and; inlinee info, is stored in one or more ``.debug$S`` sections. There may only be; one ``.debug$T`` section per object file, since all other debug info refers to; it. If a PDB (enabled by the ``/Zi`` MSVC option) was used during compilation,; the ``.debug$T`` section will contain only an ``LF_TYPESERVER2`` record pointing; to the PDB. When using PDBs, symbol information appears to remain in the ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst:82630,clear,clearly,82630,interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,1,['clear'],['clearly']
Usability,"es that Clang has; historically rejected. In order to parse widely distributed headers for; libraries such as the Active Template Library (ATL) and Windows Runtime Library; (WRL), some template rules have been relaxed or extended in Clang on Windows. The first major semantic difference is that MSVC appears to defer all parsing; an analysis of inline method bodies in class templates until instantiation; time. By default on Windows, Clang attempts to follow suit. This behavior is; controlled by the ``-fdelayed-template-parsing`` flag. While Clang delays; parsing of method bodies, it still parses the bodies *before* template argument; substitution, which is not what MSVC does. The following compatibility tweaks; are necessary to parse the template in those cases. MSVC allows some name lookup into dependent base classes. Even on other; platforms, this has been a `frequently asked question`_ for Clang users. A; dependent base class is a base class that depends on the value of a template; parameter. Clang cannot see any of the names inside dependent bases while it; is parsing your template, so the user is sometimes required to use the; ``typename`` keyword to assist the parser. On Windows, Clang attempts to; follow the normal lookup rules, but if lookup fails, it will assume that the; user intended to find the name in a dependent base. While parsing the; following program, Clang will recover as if the user had written the; commented-out code:. .. _frequently asked question:; https://clang.llvm.org/compatibility.html#dep_lookup. .. code-block:: c++. template <typename T>; struct Foo : T {; void f() {; /*typename*/ T::UnknownType x = /*this->*/unknownMember;; }; };. After recovery, Clang warns the user that this code is non-standard and issues; a hint suggesting how to fix the problem. As of this writing, Clang is able to compile a simple ATL hello world; application. There are still issues parsing WRL headers for modern Windows 8; apps, but they should be addressed soon.; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/MSVCCompatibility.rst:6829,simpl,simple,6829,interpreter/llvm-project/clang/docs/MSVCCompatibility.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/MSVCCompatibility.rst,1,['simpl'],['simple']
Usability,"es use of this feature to enable running C++; within Python. It enables transporting values/information between C++; and Python. Note: `cppyy <https://github.com/wlav/cppyy/>`_ is an automatic, run-time,; Python-to-C++ bindings generator, for calling C++ from Python and Python from C++.; It uses LLVM along with a C++ interpreter (e.g., Cling) to enable features like; run-time instantiation of C++ templates, cross-inheritance, callbacks,; auto-casting, transparent use of smart pointers, etc. In a nutshell, this feature enables a new way of developing code, paving the; way for language interoperability and easier interactive programming. Implementation Details; ======================. Interpreter as a REPL vs. as a Library; --------------------------------------. 1 - If we're using the interpreter in interactive (REPL) mode, it will dump; the value (i.e., value printing). .. code-block:: console. if (LastValue.isValid()) {; if (!V) {; LastValue.dump();; LastValue.clear();; } else; *V = std::move(LastValue);; }. 2 - If we're using the interpreter as a library, then it will pass the value; to the user. Incremental AST Consumer; ------------------------. The ``IncrementalASTConsumer`` class wraps the original code generator; ``ASTConsumer`` and it performs a hook, to traverse all the top-level decls, to; look for expressions to synthesize, based on the ``isSemiMissing()`` condition. If this condition is found to be true, then ``Interp.SynthesizeExpr()`` will be; invoked. **Note:** Following is a sample code snippet. Actual code may vary over time. .. code-block:: console. for (Decl *D : DGR); if (auto *TSD = llvm::dyn_cast<TopLevelStmtDecl>(D);; TSD && TSD->isSemiMissing()); TSD->setStmt(Interp.SynthesizeExpr(cast<Expr>(TSD->getStmt())));. return Consumer->HandleTopLevelDecl(DGR);. The synthesizer will then choose the relevant expression, based on its type. Communication between Compiled Code and Interpreted Code; --------------------------------------------------------.",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangRepl.rst:11726,clear,clear,11726,interpreter/llvm-project/clang/docs/ClangRepl.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangRepl.rst,1,['clear'],['clear']
Usability,"es<gv_summary>`, and; :ref:`type identifiers<typeid_summary>`. .. _module_path_summary:. Module Path Summary Entry; -------------------------. Each module path summary entry lists a module containing global values included; in the summary. For a single IR module there will be one such entry, but; in a combined summary index produced during the thin link, there will be; one module path entry per linked module with summary. Example:. .. code-block:: text. ^0 = module: (path: ""/path/to/file.o"", hash: (2468601609, 1329373163, 1565878005, 638838075, 3148790418)). The ``path`` field is a string path to the bitcode file, and the ``hash``; field is the 160-bit SHA-1 hash of the IR bitcode contents, used for; incremental builds and caching. .. _gv_summary:. Global Value Summary Entry; --------------------------. Each global value summary entry corresponds to a global value defined or; referenced by a summarized module. Example:. .. code-block:: text. ^4 = gv: (name: ""f""[, summaries: (Summary)[, (Summary)]*]?) ; guid = 14740650423002898831. For declarations, there will not be a summary list. For definitions, a; global value will contain a list of summaries, one per module containing; a definition. There can be multiple entries in a combined summary index; for symbols with weak linkage. Each ``Summary`` format will depend on whether the global value is a; :ref:`function<function_summary>`, :ref:`variable<variable_summary>`, or; :ref:`alias<alias_summary>`. .. _function_summary:. Function Summary; ^^^^^^^^^^^^^^^^. If the global value is a function, the ``Summary`` entry will look like:. .. code-block:: text. function: (module: ^0, flags: (linkage: external, notEligibleToImport: 0, live: 0, dsoLocal: 0), insts: 2[, FuncFlags]?[, Calls]?[, TypeIdInfo]?[, Params]?[, Refs]?. The ``module`` field includes the summary entry id for the module containing; this definition, and the ``flags`` field contains information such as; the linkage type, a flag indicating whether it is legal to im",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:340864,guid,guid,340864,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['guid'],['guid']
Usability,"es`. See `SetMakeSharedLib()`; for more information on those variables. When the file being passed to; ACLiC is on a read only file system, ACLiC warns the user and creates; the library in a temporary directory:. ``` {.cpp}; root[] .L readonly/t.C++; Warning in <ACLiC>: /scratch/aclic/subs/./readonly is not writable!; Warning in <ACLiC>: Output will be written to /tmp; Info in <TUnixSystem::ACLiC>: creating shared library; /tmp//scratch/aclic/subs/./readonly/t_C.so; ```. To select the temporary directory ACLiC looks at `$TEMP`, `$TEMP_DIR`,; `$TEMPDIR`, `$TMP`, `$TMPDIR`, `$TMP_DIR `or uses `/tmp (`or `C:/)`.; Also, a new interface `TSystem::Get/SetBuildDir` is introduced; to let users select an alternative 'root' for building of the ACLiC; libraries. For `filename/full/path/name/macro.C`, the library is; created as `fBuildDir/full/path/name/macro_C.so.`. ### Dictionary Generation. You can direct what is added to the dictionary generated by ACLiC in; two ways. The simplest way is to add at the end of script (i.e. after; the symbols have been defined) something like:. ``` {.cpp}; #if defined(__ROOTCLING__); #pragma link C++ class MyOtherClass;; #endif; ```. You can also write this portion of code in a file name; `MyScript_linkdef.h` where the suffix `'_linkdef' `is the prefix; defined by the key `‘ACLiC.Linkdef`‘ in the currently used resource; file (usually `.rootrc `or` $ROOTSYS/etc/system.rootrc`) and the; prefix is the name of your script. The default behavior of `rootcling` is to; not link in (i.e. generate the dictionary for) any of the symbols. In; particular, this means that the following lines are, in the; general case, unnecessary. ``` {.cpp}; #pragma link off all globals;; #pragma link off all classes;; #pragma link off all functions;; ```. This also means that linking the instantiation of a class template:. ``` {.cpp}; #pragma link C++ class mytemplate<int>;; ```. ONLY links this specific class. You need to; request the generation of the iterators explici",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Cling.md:18796,simpl,simplest,18796,documentation/users-guide/Cling.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Cling.md,1,['simpl'],['simplest']
Usability,"esigned and built with many grand plans for how we can use it. The; driving force is the fact that we use C and C++ daily, and have to suffer due to; a lack of good tools available for it. We believe that the C and C++ tools; ecosystem has been significantly limited by how difficult it is to parse and; represent the source code for these languages, and we aim to rectify this; problem in clang.; The problem with this goal is that different clients have very different; requirements. Consider code generation, for example: a simple front-end that; parses for code generation must analyze the code for validity and emit code; in some intermediate form to pass off to a optimizer or backend. Because; validity analysis and code generation can largely be done on the fly, there is; not hard requirement that the front-end actually build up a full AST for all; the expressions and statements in the code. TCC and GCC are examples of; compilers that either build no real AST (in the former case) or build a stripped; down and simplified AST (in the later case) because they focus primarily on; codegen.; On the opposite side of the spectrum, some clients (like refactoring) want; highly detailed information about the original source code and want a complete; AST to describe it with. Refactoring wants to have information about macro; expansions, the location of every paren expression '(((x)))' vs 'x', full; position information, and much more. Further, refactoring wants to look; across the whole program to ensure that it is making transformations; that are safe. Making this efficient and getting this right requires a; significant amount of engineering and algorithmic work that simply are; unnecessary for a simple static compiler.; The beauty of the clang approach is that it does not restrict how you use it.; In particular, it is possible to use the clang preprocessor and parser to build; an extremely quick and light-weight on-the-fly code generator (similar to TCC); that does not build an ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/features.html:7463,simpl,simplified,7463,interpreter/llvm-project/clang/www/features.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/features.html,1,['simpl'],['simplified']
Usability,"esn't make it more difficult to; understand the code. One great way to do this is by making use of early exits; and the ``continue`` keyword in long loops. Consider this code that does not; use an early exit:. .. code-block:: c++. Value *doSomething(Instruction *I) {; if (!I->isTerminator() &&; I->hasOneUse() && doOtherThing(I)) {; ... some long code ....; }. return 0;; }. This code has several problems if the body of the ``'if'`` is large. When; you're looking at the top of the function, it isn't immediately clear that this; *only* does interesting things with non-terminator instructions, and only; applies to things with the other predicates. Second, it is relatively difficult; to describe (in comments) why these predicates are important because the ``if``; statement makes it difficult to lay out the comments. Third, when you're deep; within the body of the code, it is indented an extra level. Finally, when; reading the top of the function, it isn't clear what the result is if the; predicate isn't true; you have to read to the end of the function to know that; it returns null. It is much preferred to format the code like this:. .. code-block:: c++. Value *doSomething(Instruction *I) {; // Terminators never need 'something' done to them because ...; if (I->isTerminator()); return 0;. // We conservatively avoid transforming instructions with multiple uses; // because goats like cheese.; if (!I->hasOneUse()); return 0;. // This is really just here for example.; if (!doOtherThing(I)); return 0;. ... some long code ....; }. This fixes these problems. A similar problem frequently happens in ``for``; loops. A silly example is something like this:. .. code-block:: c++. for (Instruction &I : BB) {; if (auto *BO = dyn_cast<BinaryOperator>(&I)) {; Value *LHS = BO->getOperand(0);; Value *RHS = BO->getOperand(1);; if (LHS != RHS) {; ...; }; }; }. When you have very, very small loops, this sort of structure is fine. But if it; exceeds more than 10-15 lines, it becomes difficult f",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodingStandards.rst:36462,clear,clear,36462,interpreter/llvm-project/llvm/docs/CodingStandards.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodingStandards.rst,1,['clear'],['clear']
Usability,"esp; 	ret. Note the load into xmm0, then xor (to negate), then store. In PIC mode,; this code computes the pic base and does two loads to do the constant pool ; load, so the improvement is much bigger. The tricky part about this xform is that the argument load/store isn't exposed; until post-legalize, and at that point, the fneg has been custom expanded into ; an X86 fxor. This means that we need to handle this case in the x86 backend; instead of in target independent code. //===---------------------------------------------------------------------===//. Non-SSE4 insert into 16 x i8 is atrociously bad. //===---------------------------------------------------------------------===//. <2 x i64> extract is substantially worse than <2 x f64>, even if the destination; is memory. //===---------------------------------------------------------------------===//. INSERTPS can match any insert (extract, imm1), imm2 for 4 x float, and insert; any number of 0.0 simultaneously. Currently we only use it for simple; insertions. See comments in LowerINSERT_VECTOR_ELT_SSE4. //===---------------------------------------------------------------------===//. On a random note, SSE2 should declare insert/extract of 2 x f64 as legal, not; Custom. All combinations of insert/extract reg-reg, reg-mem, and mem-reg are; legal, it'll just take a few extra patterns written in the .td file. Note: this is not a code quality issue; the custom lowered code happens to be; right, but we shouldn't have to custom lower anything. This is probably related; to <2 x i64> ops being so bad. //===---------------------------------------------------------------------===//. LLVM currently generates stack realignment code, when it is not necessary; needed. The problem is that we need to know about stack alignment too early,; before RA runs. At that point we don't know, whether there will be vector spill, or not.; Stack realignment logic is overly conservative here, but otherwise we can; produce unaligned loads/stores. F",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/README-SSE.txt:14195,simpl,simple,14195,interpreter/llvm-project/llvm/lib/Target/X86/README-SSE.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/README-SSE.txt,1,['simpl'],['simple']
Usability,"esponding iterator, and; this is a constant time operation (very efficient). The following code snippet; illustrates use of the conversion constructors provided by LLVM iterators. By; using these, you can explicitly grab the iterator of something without actually; obtaining it via iteration over some structure:. .. code-block:: c++. void printNextInstruction(Instruction* inst) {; BasicBlock::iterator it(inst);; ++it; // After this line, it refers to the instruction after *inst; if (it != inst->getParent()->end()) errs() << *it << ""\n"";; }. .. _iterate_complex:. Finding call sites: a slightly more complex example; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Say that you're writing a FunctionPass and would like to count all the locations; in the entire module (that is, across every ``Function``) where a certain; function (i.e., some ``Function *``) is already in scope. As you'll learn; later, you may want to use an ``InstVisitor`` to accomplish this in a much more; straight-forward manner, but this example will allow us to explore how you'd do; it if you didn't have ``InstVisitor`` around. In pseudo-code, this is what we; want to do:. .. code-block:: none. initialize callCounter to zero; for each Function f in the Module; for each BasicBlock b in f; for each Instruction i in b; if (i a Call and calls the given function); increment callCounter. And the actual code is (remember, because we're writing a ``FunctionPass``, our; ``FunctionPass``-derived class simply has to override the ``runOnFunction``; method):. .. code-block:: c++. Function* targetFunc = ...;. class OurFunctionPass : public FunctionPass {; public:; OurFunctionPass(): callCounter(0) { }. virtual runOnFunction(Function& F) {; for (BasicBlock &B : F) {; for (Instruction &I: B) {; if (auto *CB = dyn_cast<CallBase>(&I)) {; // We know we've encountered some kind of call instruction (call,; // invoke, or callbr), so we need to determine if it's a call to; // the function pointed to by m_func or not.; if",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:109637,learn,learn,109637,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,1,['learn'],['learn']
Usability,"esponse team to immediately respond; to an incident. For example:. * Each LLVM Developers' Meeting has a Code of Conduct response team.; * For LLVM meetups, the local organizers will be the first point of contact.; * Any other event funded by the LLVM Foundation or listed on the LLVM website,; will have a code of conduct response team or point of contact for CoC ; reports. These teams should determine if an :ref:`immediate response<Immediate Response; Checklist>` is needed before sending the report to the Code of Conduct; committee. .. _Receiving a report:. Receiving a Report; ==================. Reports are typically received by email (conduct@llvm.org) or in person from; the reporter or event CoC response team. When receiving a report by email, the CoC Committee should acknowledge receipt; within 24 hours. The acknowledgement should be understanding and compassionate; but no commitment should be made on whether this is a violation or which action; will be taken. Specific guidance is in the checklist below. For in-person events that have a violation reported, the report should be sent; to the Code of Conduct committee within 24 hours by the on-site CoC response; team. . .. _Immediate Response Checklist:. Immediate Response Checklist; ============================. The CoC committee generally works, decides, and communicates together. If the; report indicates that an immediate response is required and other committee; members are not available, any committee member may take the immediate action; they think is necessary. In-person Code of Conduct response teams should use; this checklist to determine if an immediate response is needed. * If the incident involves physical danger, contact the appropriate law; enforcement or event security immediately. Ensure the reporter feels safe and; stay with them if possible until help arrives.; * If the act is ongoing and involves harassment or threats against someone in; any space (online or physical), any appropriate response (e.",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ResponseGuide.rst:1578,guid,guidance,1578,interpreter/llvm-project/llvm/docs/ResponseGuide.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ResponseGuide.rst,1,['guid'],['guidance']
Usability,"essages posted after the; statement is executed. We will describe the corresponding operations; later. ``` {.cpp}; root[] gGeoManager->CloseGeometry();; ```. Now we are really done with geometry building stage, but we would like; to see our simple world:. ``` {.cpp}; root[] top->SetLineColor(kMagenta);; root[] gGeoManager->SetTopVisible(); // the TOP is invisible; root[] top->Draw();; ```. ### Example 2: A Geometrical Hierarchy Look and Feel. Before going further, let us get a look and feel of interacting with the; modeller. For this, we will use one of the examples illustrating the; geometry package. To get an idea on the geometry structure created in; this example, just look at the link:; <http://root.cern.ch/root/html/tutorials/geom/rootgeom.C.html>. You will; notice that this is a bit more complex that just creating the ""world""; since several other volumes are created and put together in a hierarchy.; The purpose here is just to learn how to interact with a geometry that; is already built, but just few hints on the building steps in this; example might be useful. The geometry here represents the word ROOT that; is replicated in some symmetric manner. You might for instance ask some; questions after having a first look:. ***`Q:`*** ""OK, I understand the first lines that load the libGeom library and create; a geometry manager object. I also recognize from the previous example the following; lines creating some materials and media, but what about the geometrical transformations below?"". ***`A:`*** As explained before, the model that we are trying to create; is a hierarchy of volumes based on ***`containment`***. This is; accomplished by ***`positioning`*** some volumes ***`inside`*** others.; Any volume is an un-positioned object in the sense that it defines only; a ***`local frame`*** (matching the one of its ***`shape`***). In order; to fully define the mother-daughter relationship between two volumes one; has to specify how the daughter will be positioned inside",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:4773,learn,learn,4773,documentation/users-guide/Geometry.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md,1,['learn'],['learn']
Usability,"eta_i^{min}\le\theta_i\le\theta^{max}_i$$. They form parallelepiped $P$ ($P_0$ may be deformed by $P$). Very; similar step formulae are used in FUMILI for negative logarithm of; the likelihood function with the same idea - linearization of function; argument. ## Neural Networks. ### Introduction. Neural Networks are used in various fields for data analysis and; classification, both for research and commercial institutions. Some; randomly chosen examples are image analysis, financial movements'; predictions and analysis, or sales forecast and product shipping; optimization. In particles physics neural networks are mainly used for; classification tasks (signal over background discrimination). A vast; majority of commonly used neural networks are multilayer perceptrons.; This implementation of multilayer perceptrons is inspired from the; `MLPfit` package, which remains one of the fastest tools for neural; networks studies. ### The MLP. The multilayer perceptron is a simple feed-forward network with the; following structure showed on the left. ![](pictures/0300008D.png). It is made of neurons characterized by a bias and weighted links in; between - let's call those links synapses. The input neurons receive; the inputs, normalize them and forward them to the first hidden layer.; Each neuron in any subsequent layer first computes a linear; combination of the outputs of the previous layer. The output of the; neuron is then function of that combination with f being linear for; output neurons or a sigmoid for hidden layers. Such a structure is very useful because of two theorems:. 1- A linear combination of `sigmoids` can approximate any continuous; function. 2- Trained with `output=1` for the signal and 0 for the background,; the approximated function of inputs `X` is the probability of signal,; knowing `X`. ### Learning Methods. The aim of all learning methods is to minimize the total error on a; set of weighted examples. The error is defined as the sum in quadrate,; divide",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:70526,simpl,simple,70526,documentation/users-guide/FittingHistograms.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md,1,['simpl'],['simple']
Usability,"ethod 2. Another method allows to create the evolution of a given radioactive; material/mixture at a given moment in time:. ~~~{.cpp}; TGeoMaterial::DecayMaterial(Double_t time, Double_t precision=0.001); ~~~. The method will create the mixture that result from the decay of a; initial material/mixture at time, while all resulting elements having a; fractional weight less than precision are excluded. A demo macro for radioactive material features is; `$ROOTSYS/tutorials/geom/RadioNuclides.C` It demonstrates also the decay; of a mixture made of radionuclides. \image html geometry004.png width=600px. \anchor GM00c; ### Tracking Media. The class TGeoMedium describes tracking media properties. This has; a pointer to a material and the additional data members representing the; properties related to tracking. ~~~{.cpp}; TGeoMedium(const char *name,Int_t numed,TGeoMaterial *mat,; Double_t *params=0);; ~~~. - `name:` name assigned to the medium; - `mat:` pointer to a material; - `params:` array of additional parameters. Another constructor allows effectively defining tracking parameters in; GEANT3 style:. ~~~{.cpp}; TGeoMedium(const char *name,Int_t numed,Int_t imat,Int_t ifield,; Double_t fieldm,Double_t tmaxfd,Double_t stemax,; Double_t deemax,Double_t epsil,Double_t stmin);; ~~~. This constructor is reserved for creating tracking media from the VMC; interface [...]:. - `numed:` user-defined medium index; - `imat:` unique ID of the material; - `others:` see G3 documentation. Looking at our simple world example, one can see that for creating; volumes one needs to create tracking media before. The way to proceed; for those not interested in performing tracking with external MC's is to; define and use only one `dummy tracking medium` as in the example (or a; `NULL` pointer). \anchor GM00d; ### User Interface for Handling Materials and Media. The TGeoManager class contains the API for accessing and handling; defined materials:. ~~~{.cpp}; TGeoManager::GetMaterial(name);; ~~~. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/materials.md:10039,simpl,simple,10039,geom/geom/doc/materials.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/materials.md,1,['simpl'],['simple']
Usability,"eturn_object() { return std::coroutine_handle<promise_type>::from_promise(*this); }; std::suspend_always initial_suspend() { return {}; }; std::suspend_always final_suspend() noexcept { return {}; }; void return_void() noexcept {}; void unhandled_exception() noexcept {}. int count = 0;; };. void resume() noexcept {; handle.resume();; }. task(std::coroutine_handle<promise_type> hdl) : handle(hdl) {}; ~task() {; if (handle); handle.destroy();; }. std::coroutine_handle<> handle;; };. class await_counter : public std::suspend_always {; public:; template<class PromiseType>; void await_suspend(std::coroutine_handle<PromiseType> handle) noexcept {; handle.promise().count++;; }; };. static task coro_task(int v) {; int a = v;; co_await await_counter{};; a++;; std::cout << a << ""\n"";; a++;; std::cout << a << ""\n"";; a++;; std::cout << a << ""\n"";; co_await await_counter{};; a++;; std::cout << a << ""\n"";; a++;; std::cout << a << ""\n"";; }. int main() {; task t = coro_task(43);; t.resume();; t.resume();; t.resume();; return 0;; }. In debug mode (`O0` + `g`), the printing result would be:. .. parsed-literal::. {__resume_fn = 0x4019e0 <coro_task(int)>, __destroy_fn = 0x402000 <coro_task(int)>, __promise = {count = 1}, v = 43, a = 45, __coro_index = 1 '\001', struct_std__suspend_always_0 = {__int_8 = 0 '\000'},; class_await_counter_1 = {__int_8 = 0 '\000'}, class_await_counter_2 = {__int_8 = 0 '\000'}, struct_std__suspend_always_3 = {__int_8 = 0 '\000'}}. In the above, the values of `v` and `a` are clearly expressed, as are the; temporary values for `await_counter` (`class_await_counter_1` and; `class_await_counter_2`) and `std::suspend_always` (; `struct_std__suspend_always_0` and `struct_std__suspend_always_3`). The index; of the current suspension point of the coroutine is emitted as `__coro_index`.; In the above example, the `__coro_index` value of `1` means the coroutine; stopped at the second suspend point (Note that `__coro_index` is zero indexed); which is the first `co_await ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DebuggingCoroutines.rst:7147,resume,resume,7147,interpreter/llvm-project/clang/docs/DebuggingCoroutines.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DebuggingCoroutines.rst,1,['resume'],['resume']
Usability,"even if no compression is selected). The compression algorithm used is an in memory ZIP compression written for the; DELPHI collaboration at CERN. Its author is E. Chernyaev (IHEP/Protvino).; The source code is internal to ROOTIO. \anchor si; ## StreamerInfo. The ""StreamerInfo"" data record is used by ROOTIO to support the storage of; self-identifying objects. Its detailed format is given in \ref streamerinfo.; A ROOTIO file contains exactly one StreamerInfo record, which is written to disk; automatically when a new or modified file is closed. The StreamerInfo record is a list (ROOTIO class TList) of ""StreamerInfo"" objects; (ROOTIO class TStreamerInfo). There is one StreamerInfo object in the list for; every class used in the file in a data record, other than a core layer record.; There is no streamerinfo object for a class used in a core layer record unless the; class is also used elsewhere in a data record. When reading a self-identifying; object from a file, the system uses the StreamerInfo list to decompose the object; recursively into its simple data members. Each streamerinfo object is an array of ""streamer element"" objects, each of which; describes a base class of the object or a (non-static and non-transient) data member; of the object. If the base class or data member is itself a class, then there will; also be a streamerinfo object in the record for that class. In this way, each; class is recursively decomposed into its atomic elements, each of which is a simple; type (e.g. ""int""). A ""long"" or ""unsigned long"" member is always written; as an 8 byte quantity, even if it occupies only 4 bytes in memory. A data member of a class is marked transient on the line of its declaration by a; comment beginning with ""//!"". Such members are not written to disk, nor is there; any streamerinfo for such a member. A data member that is a C++ pointer (not to be confused with ""pointers to persistent; objects"" described below) is never written to disk as a pointer value. If it ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/doc/TFile/README.md:6879,simpl,simple,6879,io/doc/TFile/README.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/doc/TFile/README.md,1,['simpl'],['simple']
Usability,"events and react to them according to the; application functionality. ![](pictures/0200020B.jpg). The signals/slot communication mechanism is an advanced object; communication concept; it largely replaces the concept of callback; functions to handle actions in GUI's. Signals and slots are just like; any object-oriented methods implemented in C++. The objects are the; instances of classes that don't know anything about each other. They; interact and allow method calls of other object's methods. The idea is; simple: any object can send out (emit) a signal in certain situations; saying that something happened. This is all it does to communicate and; it does not know whether anything is interested in this information. On; the other side there might be an object waiting for that signal and; ready to react to it. This object disposes of special instruments to; listen to the sent out signals. To have a communication we need a; message transmission between the objects. In this simple example we use; signals and slots. The code of the method **`TGButton::Clicked()`** is:. ``` {.cpp}; virtual void Clicked() { Emit(""Clicked()""); } // *SIGNAL*; ```. I.e. any button emits the signal `Clicked()` any time someone clicks on; it. As you can see this method is virtual and could be overridden if you; need to. In our simple example we call the `Connect()` method to connect; the `Clicked()` signal of Draw button with `MyMainFrame::DoDraw():`. ``` {.cpp}; draw->Connect(""Clicked()"",""MyMainFrame"",this,""DoDraw()"");; ```. In the same way we can connect to the signal `Clicked()` of the Exit; button with the system call `gApplication->Terminate(0).` We declare a; new slot `DoExit(),` implement it to invoke the termination call and; associate this slot with the signal `Clicked()` of the Exit button. The code of `example.C` can be changed as follows:. ``` {.cpp}; public:; ...; void DoExit(); // a new slot is added; }; void MyMainFrame::DoExit() {; gApplication->Terminate(0);; }; MyMainFrame::MyM",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md:41572,simpl,simple,41572,documentation/users-guide/WritingGUI.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md,1,['simpl'],['simple']
Usability,"ew algorithmic optimization in the caching of pdfs. So far - in the likelihood - two classes of; objects are identified: those that change with every event (i.e. the pdf) and those that change; only with the parameters (typically pdf normalization integrals). Pdfs are always recalculated; for every event, whereas integrals are only evaluated when needed. The exception to the first type are pdfs; that only depend on constant parameters (or no parameters) - these are identified at the beginning, and precalculated once ; to avoid recalculating an expression with the same outcome for every iteration of the likelihood calculation. For composite pdfs a further optimization has been included: for a M(x,a,b) = f*F(x,a)+(1-f)G(x,b) ; it is e.g. not needed to recalculate G(x,b) if only parameter a has changed w.r.t to the previous likelihood; calculation. This optimization is now implemented by extending the value caching originally designed; for constant terms to be usable for non-constant terms, with a check executed at the beginning of each; likelihood evaluation if selected columns need to be updated because parameters have changed. The speed gain; of this optimization depends much on the structure of the pdf: in models with many free parameters most of the; likelihood evaluations are executed when MINUIT calculates numerical likelihood derivatives which vary ; one parameter at a time and the speedup is potentially larger. In models with few free parameters the; effect will be smaller. The new per-component caching strategy is enabled by default for all pdfs that are a component of; a RooAddPdf or a RooRealSumPdf, unless that component is a RooProdPdf or a RooProduct, in that; case the components of the product are cached instead of the product itself. You can disable this; new optimization by adding Optimize(1) to the RooAbsPdf::fitTo() command line (0 = no caching,; 1 = cache constant terms only, 2 = cache also variable terms according to above mentioned strategy (DEFAUL",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v532/index.html:2652,usab,usable,2652,roofit/doc/v532/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v532/index.html,1,['usab'],['usable']
Usability,"example $ROOTSYS/tutorials/histfactory/example_channel.xml; This file is edited by the user. It specifies for each channel. observed data (if absent the tool will use the expectation, which is useful for expected sensitivity); several 'Samples' (eg. signal, bkg1, bkg2, ...), each of which has:; ; a name; if the sample is normalized by theory (eg N = L*sigma) or not (eg. data driven); a nominal expectation histogram; a named 'Normalization Factor' (which can be fixed or allowed to float in a fit); several 'Overall Systematics' in normalization with:; 	 ; a name; +/- 1 sigma variations (eg. 1.05 and 0.95 for a 5% uncertainty); 	 ; several 'Histogram Systematics' in shape with:; 	 ; a name (which can be shared with the OverallSyst if correlated); +/- 1 sigma variational histograms; 	 . RooStats; ModelConfig. This class is now used extensively by the calculator tools. It encapsulates the configuration of a model to define a particular hypothesis.; Various fixes by and improvements to make it usable with all; the existing calculator.; ModelConfig contains now always a reference to an; external workspace who manages all the objects being part of the model (pdf's and parameter sets). The user needs then to; set always a workspace pointer before setting the various objects.; . General Improvements. ModelConfig is now used extensively by the calculator tools. It encapsulates the configuration of a model to define a particular hypothesis.; ProfileLikelihood::GetInterval now returns LikleihoodInterval in the interface to avoid unnecessary casting; FeldmanCousins::GetInterval now returns PointSetInterval in the interface to avoid unnecessary casting. Profile Likelihood . When running ProfileLikelihoodCalculator::GetHypoTest; the user does not need anymore to clone the null parameter set. It; is done now inside the calculator; LikelihoodInterval::LowerLimit (and UpperLimit); returns now a boolean flag with the status of the limit search.; In case of a failure in finding the uppe",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v528/index.html:3264,usab,usable,3264,roofit/doc/v528/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v528/index.html,1,['usab'],['usable']
Usability,"example a sequence; of mappings in which one of the mapping values is itself a sequence:. .. code-block:: yaml. # a sequence of mappings with one key's value being a sequence; - name: Tom; cpus:; - x86; - x86_64; - name: Bob; cpus:; - x86; - name: Dan; cpus:; - PowerPC; - x86. Sometime sequences are known to be short and the one entry per line is too; verbose, so YAML offers an alternate syntax for sequences called a ""Flow; Sequence"" in which you put comma separated sequence elements into square; brackets. The above example could then be simplified to :. .. code-block:: yaml. # a sequence of mappings with one key's value being a flow sequence; - name: Tom; cpus: [ x86, x86_64 ]; - name: Bob; cpus: [ x86 ]; - name: Dan; cpus: [ PowerPC, x86 ]. Introduction to YAML I/O; ========================. The use of indenting makes the YAML easy for a human to read and understand,; but having a program read and write YAML involves a lot of tedious details.; The YAML I/O library structures and simplifies reading and writing YAML; documents. YAML I/O assumes you have some ""native"" data structures which you want to be; able to dump as YAML and recreate from YAML. The first step is to try; writing example YAML for your data structures. You may find after looking at; possible YAML representations that a direct mapping of your data structures; to YAML is not very readable. Often the fields are not in the order that; a human would find readable. Or the same information is replicated in multiple; locations, making it hard for a human to write such YAML correctly. In relational database theory there is a design step called normalization in; which you reorganize fields and tables. The same considerations need to; go into the design of your YAML encoding. But, you may not want to change; your existing native data structures. Therefore, when writing out YAML; there may be a normalization step, and when reading YAML there would be a; corresponding denormalization step. YAML I/O uses a non-in",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/YamlIO.rst:1806,simpl,simplifies,1806,interpreter/llvm-project/llvm/docs/YamlIO.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/YamlIO.rst,1,['simpl'],['simplifies']
Usability,"example, the module map file for the C standard library might look a bit like this:. .. parsed-literal::. module std [system] [extern_c] {; module assert {; textual header ""assert.h""; header ""bits/assert-decls.h""; export *; }. module complex {; header ""complex.h""; export *; }. module ctype {; header ""ctype.h""; export *; }. module errno {; header ""errno.h""; header ""sys/errno.h""; export *; }. module fenv {; header ""fenv.h""; export *; }. // ...more headers follow...; }. Here, the top-level module ``std`` encompasses the whole C standard library. It has a number of submodules containing different parts of the standard library: ``complex`` for complex numbers, ``ctype`` for character types, etc. Each submodule lists one of more headers that provide the contents for that submodule. Finally, the ``export *`` command specifies that anything included by that submodule will be automatically re-exported. Lexical structure; -----------------; Module map files use a simplified form of the C99 lexer, with the same rules for identifiers, tokens, string literals, ``/* */`` and ``//`` comments. The module map language has the following reserved words; all other C identifiers are valid identifiers. .. parsed-literal::. ``config_macros`` ``export_as`` ``private``; ``conflict`` ``framework`` ``requires``; ``exclude`` ``header`` ``textual``; ``explicit`` ``link`` ``umbrella``; ``extern`` ``module`` ``use``; ``export``. Module map file; ---------------; A module map file consists of a series of module declarations:. .. parsed-literal::. *module-map-file*:; *module-declaration**. Within a module map file, modules are referred to by a *module-id*, which uses periods to separate each part of a module's name:. .. parsed-literal::. *module-id*:; *identifier* ('.' *identifier*)*. Module declaration; ------------------; A module declaration describes a module, including the headers that contribute to that module, its submodules, and other aspects of the module. .. parsed-literal::. *module-decl",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst:28896,simpl,simplified,28896,interpreter/llvm-project/clang/docs/Modules.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst,1,['simpl'],['simplified']
Usability,expr defaulted constructors; Unknown. 1655; drafting; Line endings in raw string literals; Not resolved. 1656; CD6; Encoding of numerically-escaped characters; Unknown. 1657; CD4; Attributes for namespaces and enumerators; Unknown. 1658; C++14; Deleted default constructor for abstract class via destructor; Clang 5. 1659; open; Initialization order of thread_local template static data members; Not resolved. 1660; C++14; member-declaration requirements and unnamed bit-fields; Unknown. 1661; NAD; Preservation of infinite loops; Unknown. 1662; C++14; Capturing function parameter packs; Unknown. 1663; NAD; Capturing an empty pack expansion; Unknown. 1664; C++14; Argument-dependent lookup of lambdas used in default arguments; Unknown. 1665; drafting; Declaration matching in explicit instantiations; Not resolved. 1666; C++14; Address constant expressions; Unknown. 1667; NAD; Function exiting via exception called by destructor during unwinding; Unknown. 1668; drafting; Parameter type determination still not clear enough; Not resolved. 1669; C++14; auto return type for main; Unknown. 1670; drafting; auto as conversion-type-id; Not resolved. 1671; NAD; Unclear rules for deduction with cv-qualification; Unknown. 1672; CD4; Layout compatibility with multiple empty bases; Clang 7. 1673; C++14; Clarifying overload resolution for the second step of copy-initialization; Unknown. 1674; C++14; Return type deduction for address of function; Unknown. 1675; NAD; Size limit for automatic array object; Unknown. 1676; drafting; auto return type for allocation and deallocation functions; Not resolved. 1677; C++17; Constant initialization via aggregate initialization; Unknown. 1678; NAD; Naming the type of an array of runtime bound; Unknown. 1679; NAD; Range-based for and array of runtime bound; Unknown. 1680; drafting; Including <initializer_list> for range-based for; Not resolved. 1681; C++14; init-captures and nested lambdas; Unknown. 1682; open; Overly-restrictive rules on function templa,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:112845,clear,clear,112845,interpreter/llvm-project/clang/www/cxx_dr_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html,1,['clear'],['clear']
Usability,expr if; Unknown. 2275; drafting; Type-dependence of function template; Not resolved. 2276; C++17; Dependent noexcept and function type-dependence; Unknown. 2277; CD5; Ambiguity inheriting constructors with default arguments; Unknown. 2278; CD5; Copy elision in constant expressions reconsidered; Unknown. 2279; NAD; Multiple attribute-specifiers in one attribute-list; Unknown. 2280; C++20; Matching a usual deallocation function with placement new; Unknown. 2281; drafting; Consistency of aligned operator delete replacement; Not resolved. 2282; C++20; Consistency with mismatched aligned/non-over-aligned allocation/deallocation functions; Unknown. 2283; drafting; Missing complete type requirements; Not resolved. 2284; open; Sequencing of braced-init-list arguments; Not resolved. 2285; CD5; Issues with structured bindings; Unknown. 2286; NAD; Assignment evaluation order; Unknown. 2287; CD5; Pointer-interconvertibility in non-standard-layout unions; Unknown. 2288; NAD; Contradictory optionality in simple-declaration; Unknown. 2289; CD5; Uniqueness of structured binding names; Unknown. 2290; CD5; Unclear specification for overload resolution and deleted special member functions; Unknown. 2291; dup; Implicit conversion sequences in non-call contexts; Unknown. 2292; CD5; simple-template-id is ambiguous between class-name and type-name; Clang 9. 2293; CD5; Requirements for simple-template-id used as a class-name; Unknown. 2294; CD5; Dependent auto static data members; Unknown. 2295; CD5; Aggregates with deleted defaulted constructors; Unknown. 2296; open; Are default argument instantiation failures in the “immediate context”?; Not resolved. 2297; open; Unclear specification of atomic operations; Not resolved. 2298; open; Actions and expression evaluation; Not resolved. 2299; CD5; constexpr vararg functions; Unknown. 2300; CD5; Lambdas in multiple definitions; Unknown. 2301; open; Value-initialization and constexpr constructor evaluation; Not resolved. 2302; NAD; Address compar,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:156040,simpl,simple-declaration,156040,interpreter/llvm-project/clang/www/cxx_dr_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html,1,['simpl'],['simple-declaration']
Usability,"f .js and .css files.; Minimized scripts used by default on web servers.; - Implement JSROOT.extend instead of jQuery.extend, reduce; usage of jquery.js in core JSROOT classes; - Implement main graphics without jquery at all,; such mode used in `nobrowser` mode.; - Provide optional latex drawing with MathJax SVG.; TMathText always drawn with MathJax,; other classes require `mathjax` option in URL; - Improve drawing of different text classes, correctly handle; their alignment and scaling, special handling for IE. ## TTree Libraries. ### TTree Behavior change. #### Merging. Added fast cloning support to TTree::MergeTrees and TTree::Merge(TCollection*,Option_t*). #### TTreeCache. The TTreeCache is now enabled by default. The default size of the TTreeCache; is the estimated size of a cluster size for the TTree. The TTreeCache; prefilling is also enabled by default; when in learning phase rather than; reading each requested branch individually, the TTreeCache will read all the; branches thus trading off the latencies inherent to multiple small reads for; the potential of requesting more data than needed by read from the disk or; server the baskets for too many branches. The default behavior can be changed by either updating one of the rootrc files; or by setting environment variables. The rootrc files, both the global and the; local ones, now support the following the resource variable TTreeCache.Size; which set the default size factor for auto sizing TTreeCache for TTrees. The; estimated cluster size for the TTree and this factor is used to give the cache; size. If option is set to zero auto cache creation is disabled and the default; cache size is the historical one (equivalent to factor 1.0). If set to; non zero auto cache creation is enabled and both auto created and; default sized caches will use the configured factor: 0.0 no automatic cache; and greater than 0.0 to enable cache. This value can be overridden by the; environment variable ROOT_TTREECACHE_SIZE. The reso",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v604/index.md:12745,learn,learning,12745,README/ReleaseNotes/v604/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v604/index.md,1,['learn'],['learning']
Usability,"f Transformer is the *rewrite rule*, which specifies how; to change a given program pattern into a new form. Here are some examples of; tasks you can achieve with Transformer:. * warn against using the name ``MkX`` for a declared function,; * change ``MkX`` to ``MakeX``, where ``MkX`` is the name of a declared function,; * change ``s.size()`` to ``Size(s)``, where ``s`` is a ``string``,; * collapse ``e.child().m()`` to ``e.m()``, for any expression ``e`` and method named; ``m``. All of the examples have a common form: they identify a pattern that is the; target of the transformation, they specify an *edit* to the code identified by; the pattern, and their pattern and edit refer to common variables, like ``s``,; ``e``, and ``m``, that range over code fragments. Our first and second examples also; specify constraints on the pattern that aren't apparent from the syntax alone,; like ""``s`` is a ``string``."" Even the first example (""warn ..."") shares this form,; even though it doesn't change any of the code -- it's ""edit"" is simply a no-op. Transformer helps users succinctly specify rules of this sort and easily execute; them locally over a collection of files, apply them to selected portions of; a codebase, or even bundle them as a clang-tidy check for ongoing application. Who is Clang Transformer for?; -----------------------------. Clang Transformer is for developers who want to write clang-tidy checks or write; tools to modify a large number of C++ files in (roughly) the same way. What; qualifies as ""large"" really depends on the nature of the change and your; patience for repetitive editing. In our experience, automated solutions become; worthwhile somewhere between 100 and 500 files. Getting Started; ---------------. Patterns in Transformer are expressed with :doc:`clang's AST matchers <LibASTMatchers>`.; Matchers are a language of combinators for describing portions of a clang; Abstract Syntax Tree (AST). Since clang's AST includes complete type information; (within",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangTransformerTutorial.rst:1545,simpl,simply,1545,interpreter/llvm-project/clang/docs/ClangTransformerTutorial.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangTransformerTutorial.rst,1,['simpl'],['simply']
Usability,"f a fourth field is present, it must be; a ``ConstantInt`` valued at 0 or 1. If it is 1 then the access tag states; that the location being accessed is ""constant"" (meaning; ``pointsToConstantMemory`` should return true; see `other useful; AliasAnalysis methods <AliasAnalysis.html#OtherItfs>`_). The TBAA root of; the access type and the base type of an access tag must be the same, and; that is the TBAA root of the access tag. '``tbaa.struct``' Metadata; ^^^^^^^^^^^^^^^^^^^^^^^^^^. The :ref:`llvm.memcpy <int_memcpy>` is often used to implement; aggregate assignment operations in C and similar languages, however it; is defined to copy a contiguous region of memory, which is more than; strictly necessary for aggregate types which contain holes due to; padding. Also, it doesn't contain any TBAA information about the fields; of the aggregate. ``!tbaa.struct`` metadata can describe which memory subregions in a; memcpy are padding and what the TBAA tags of the struct are. The current metadata format is very simple. ``!tbaa.struct`` metadata; nodes are a list of operands which are in conceptual groups of three.; For each group of three, the first operand gives the byte offset of a; field in bytes, the second gives its size in bytes, and the third gives; its tbaa tag. e.g.:. .. code-block:: llvm. !4 = !{ i64 0, i64 4, !1, i64 8, i64 4, !2 }. This describes a struct with two fields. The first is at offset 0 bytes; with size 4 bytes, and has tbaa tag !1. The second is at offset 8 bytes; and has size 4 bytes and has tbaa tag !2. Note that the fields need not be contiguous. In this example, there is a; 4 byte gap between the two fields. This gap represents padding which; does not carry useful data and need not be preserved. '``noalias``' and '``alias.scope``' Metadata; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. ``noalias`` and ``alias.scope`` metadata provide the ability to specify generic; noalias memory-access sets. This means that some collection of memory access; instructi",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:280171,simpl,simple,280171,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['simpl'],['simple']
Usability,"f operands) and later can not be used as multiple level. .. code-block:: text. IR for ""*ptr = 4;""; --------------; call void @llvm.dbg.value(metadata i32 4, metadata !17, metadata !20); !17 = !DILocalVariable(name: ""ptr1"", scope: !12, file: !3, line: 5,; type: !18); !18 = !DIDerivedType(tag: DW_TAG_pointer_type, baseType: !19, size: 64); !19 = !DIBasicType(name: ""int"", size: 32, encoding: DW_ATE_signed); !20 = !DIExpression(DW_OP_LLVM_implicit_pointer)). IR for ""**ptr = 4;""; --------------; call void @llvm.dbg.value(metadata i32 4, metadata !17, metadata !21); !17 = !DILocalVariable(name: ""ptr1"", scope: !12, file: !3, line: 5,; type: !18); !18 = !DIDerivedType(tag: DW_TAG_pointer_type, baseType: !19, size: 64); !19 = !DIDerivedType(tag: DW_TAG_pointer_type, baseType: !20, size: 64); !20 = !DIBasicType(name: ""int"", size: 32, encoding: DW_ATE_signed); !21 = !DIExpression(DW_OP_LLVM_implicit_pointer,; DW_OP_LLVM_implicit_pointer)). DWARF specifies three kinds of simple location descriptions: Register, memory,; and implicit location descriptions. Note that a location description is; defined over certain ranges of a program, i.e the location of a variable may; change over the course of the program. Register and memory location; descriptions describe the *concrete location* of a source variable (in the; sense that a debugger might modify its value), whereas *implicit locations*; describe merely the actual *value* of a source variable which might not exist; in registers or in memory (see ``DW_OP_stack_value``). A ``llvm.dbg.declare`` intrinsic describes an indirect value (the address) of a; source variable. The first operand of the intrinsic must be an address of some; kind. A DIExpression attached to the intrinsic refines this address to produce a; concrete location for the source variable. A ``llvm.dbg.value`` intrinsic describes the direct value of a source variable.; The first operand of the intrinsic may be a direct or indirect value. A; DIExpression attached to the i",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:267300,simpl,simple,267300,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['simpl'],['simple']
Usability,"f the redeclaration chain. This may result in long; redeclaration chains in certain cases, e.g. if we import from several; translation units which include the same header with the prototype. .. Squashing prototypes. To mitigate the problem of long redeclaration chains of free functions, we; could compare prototypes to see if they have the same properties and if yes; then we could merge these prototypes. The implementation of squashing of; prototypes for free functions is future work. .. Exception: Cannot have more than 1 prototype in-class. Chaining functions this way ensures that we do copy all information from the; source AST. Nonetheless, there is a problem with member functions: While we can; have many prototypes for free functions, we must have only one prototype for a; member function. .. code-block:: c++. void f(); // OK; void f(); // OK. struct X {; void f(); // OK; void f(); // ERROR; };; void X::f() {} // OK. Thus, prototypes of member functions must be squashed, we cannot just simply; attach a new prototype to the existing in-class prototype. Consider the; following contexts:. .. code-block:: c++. // ""to"" context; struct X {; void f(); // D0; };. .. code-block:: c++. // ""from"" context; struct X {; void f(); // D1; };; void X::f() {} // D2. When we import the prototype and the definition of ``f`` from the ""from""; context, then the resulting redecl chain will look like this ``D0 -> D2'``,; where ``D2'`` is the copy of ``D2`` in the ""to"" context. .. Redecl chains of other declarations. Generally speaking, when we import declarations (like enums and classes) we do; attach the newly imported declaration to the existing redeclaration chain (if; there is structural equivalency). We do not import, however, the whole; redeclaration chain as we do in case of functions. Up till now, we haven't; found any essential property of forward declarations which is similar to the; case of the virtual flag in a member function prototype. In the future, this; may change, though.",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:96826,simpl,simply,96826,interpreter/llvm-project/clang/docs/InternalsManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst,1,['simpl'],['simply']
Usability,"f the successors, we forward the edge; from the predecessor to the successor by duplicating the contents of this; block. An example of when this can occur is code like this:. .. code-block:: c++. if () { ...; X = 4;; }; if (X < 3) {. In this case, the unconditional branch at the end of the first if can be; revectored to the false side of the second if. .. _passes-lcssa:. ``lcssa``: Loop-Closed SSA Form Pass; ------------------------------------. This pass transforms loops by placing phi nodes at the end of the loops for all; values that are live across the loop boundary. For example, it turns the left; into the right code:. .. code-block:: c++. for (...) for (...); if (c) if (c); X1 = ... X1 = ...; else else; X2 = ... X2 = ...; X3 = phi(X1, X2) X3 = phi(X1, X2); ... = X3 + 4 X4 = phi(X3); ... = X4 + 4. This is still valid LLVM; the extra phi nodes are purely redundant, and will be; trivially eliminated by ``InstCombine``. The major benefit of this; transformation is that it makes many other loop optimizations, such as; ``LoopUnswitch``\ ing, simpler. You can read more in the; :ref:`loop terminology section for the LCSSA form <loop-terminology-lcssa>`. .. _passes-licm:. ``licm``: Loop Invariant Code Motion; ------------------------------------. This pass performs loop invariant code motion, attempting to remove as much; code from the body of a loop as possible. It does this by either hoisting code; into the preheader block, or by sinking code to the exit blocks if it is safe.; This pass also promotes must-aliased memory locations in the loop to live in; registers, thus hoisting and sinking ""invariant"" loads and stores. Hoisting operations out of loops is a canonicalization transform. It enables; and simplifies subsequent optimizations in the middle-end. Rematerialization; of hoisted instructions to reduce register pressure is the responsibility of; the back-end, which has more accurate information about register pressure and; also handles other optimizations than LICM",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Passes.rst:23285,simpl,simpler,23285,interpreter/llvm-project/llvm/docs/Passes.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Passes.rst,1,['simpl'],['simpler']
Usability,"f you experience unexpected problems related to the likelihood evaluation, you; can revert back to the old backend by passing `RooFit::EvalBackend(""legacy"")`; to `RooAbsPdf::fitTo()` or `RooAbsPdf::createNLL()`. In case you observe any slowdowns with the new likelihood evaluation, please; open a GitHub issue about this, as such a performance regression is considered; a bug. ### Asymptotically correct uncertainties for extended unbinned likelihood fits. Added correct treatment of extended term in asymptotically correct method for uncertainty determination in the presence of weights.; This improvement will allow for extended unbinned maximum likelihood fits to use the asymptotically correct method when using the `RooFit::AsymptoticError()` command argument in [RooAbsPdf::fitTo()](https://root.cern.ch/doc/master/classRooAbsPdf.html#ab0721374836c343a710f5ff92a326ff5).; See also this [writeup on extended weighted fits](https://root.cern/files/extended_weighted_fits.pdf) that is also linked from the reference guide.; The [pull request](https://github.com/root-project/root/pull/14751) that introduced this feature might also be a good reference. ### Compile your code with memory safe interfaces. If you define the `ROOFIT_MEMORY_SAFE_INTERFACES` preprocessor macro, the; RooFit interface changes in a way such that memory leaks are avoided. The most prominent effect of this change is that many functions that used to; return an owning pointer (e.g., a pointer to an object that you need to; manually `delete`) are then returning a `std::unique_pt` for automatic memory; management. For example this code would not compile anymore, because there is the risk that; the caller forgets to `delete params`:; ```c++; RooArgSet * params = pdf.getParameters(nullptr);; ```; If you wrap such return values in a `std::unique_ptr`, then your code will; compile both with and without memory safe interfaces:; ```c++; std::unique_ptr<RooArgSet> params{pdf.getParameters(nullptr)};; ```. Also some `vir",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v632/index.md:8240,guid,guide,8240,README/ReleaseNotes/v632/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v632/index.md,1,['guid'],['guide']
Usability,"fcmp one double %x, %y		; <i1> [#uses=1]; 	%tmp345 = zext i1 %tmp3 to i32		; <i32> [#uses=1]; 	ret i32 %tmp345; }. define i32 @test3(double %x, double %y) nounwind {; entry:; 	%tmp3 = fcmp ugt double %x, %y		; <i1> [#uses=1]; 	%tmp34 = zext i1 %tmp3 to i32		; <i32> [#uses=1]; 	ret i32 %tmp34; }. //===---------------------------------------------------------------------===//; for the following code:. void foo (float *__restrict__ a, int *__restrict__ b, int n) {; a[n] = b[n] * 2.321;; }. we load b[n] to GPR, then move it VSX register and convert it float. We should ; use vsx scalar integer load instructions to avoid direct moves. //===----------------------------------------------------------------------===//; ; RUN: llvm-as < %s | llc -march=ppc32 | not grep fneg. ; This could generate FSEL with appropriate flags (FSEL is not IEEE-safe, and ; ; should not be generated except with -enable-finite-only-fp-math or the like).; ; With the correctness fixes for PR642 (58871) LowerSELECT_CC would need to; ; recognize a more elaborate tree than a simple SETxx. define double @test_FNEG_sel(double %A, double %B, double %C) {; %D = fsub double -0.000000e+00, %A ; <double> [#uses=1]; %Cond = fcmp ugt double %D, -0.000000e+00 ; <i1> [#uses=1]; %E = select i1 %Cond, double %B, double %C ; <double> [#uses=1]; ret double %E; }. //===----------------------------------------------------------------------===//; The save/restore sequence for CR in prolog/epilog is terrible:; - Each CR subreg is saved individually, rather than doing one save as a unit.; - On Darwin, the save is done after the decrement of SP, which means the offset; from SP of the save slot can be too big for a store instruction, which means we; need an additional register (currently hacked in 96015+96020; the solution there; is correct, but poor).; - On SVR4 the same thing can happen, and I don't think saving before the SP; decrement is safe on that target, as there is no red zone. This is currently; broken AFAIK, althou",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/README.txt:12744,simpl,simple,12744,interpreter/llvm-project/llvm/lib/Target/PowerPC/README.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/README.txt,1,['simpl'],['simple']
Usability,"fer to the `error handling <https://llvm.org/docs/ProgrammersManual.html#recoverable-errors>`_ documentation for details. .. code-block:: cpp. if (!ImportedOrErr) {; llvm::Error Err = ImportedOrErr.takeError();; llvm::errs() << ""ERROR: "" << Err << ""\n"";; consumeError(std::move(Err));; return 1;; }. If there's no error then we can get the underlying value.; In this example we will print the AST of the ""to"" context. .. code-block:: cpp. Decl *Imported = *ImportedOrErr;; Imported->getTranslationUnitDecl()->dump();. Since we set **minimal import** in the constructor of the importer, the AST will not contain the declaration of the members (once we run the test tool). .. code-block:: bash. TranslationUnitDecl 0x68b9a8 <<invalid sloc>> <invalid sloc>; `-CXXRecordDecl 0x6c7e30 <line:2:7, col:13> col:13 class MyClass definition; `-DefinitionData pass_in_registers standard_layout trivially_copyable trivial literal; |-DefaultConstructor exists trivial needs_implicit; |-CopyConstructor simple trivial has_const_param needs_implicit implicit_has_const_param; |-MoveConstructor exists simple trivial needs_implicit; |-CopyAssignment trivial has_const_param needs_implicit implicit_has_const_param; |-MoveAssignment exists simple trivial needs_implicit; `-Destructor simple irrelevant trivial needs_implicit. We'd like to get the members too, so, we use ``ImportDefinition`` to copy the whole definition of ``MyClass`` into the ""to"" context.; Then we dump the AST again. .. code-block:: cpp. if (llvm::Error Err = Importer.ImportDefinition(From)) {; llvm::errs() << ""ERROR: "" << Err << ""\n"";; consumeError(std::move(Err));; return 1;; }; llvm::errs() << ""Imported definition.\n"";; Imported->getTranslationUnitDecl()->dump();. This time the AST is going to contain the members too. .. code-block:: bash. TranslationUnitDecl 0x68b9a8 <<invalid sloc>> <invalid sloc>; `-CXXRecordDecl 0x6c7e30 <line:2:7, col:13> col:13 class MyClass definition; |-DefinitionData pass_in_registers standard_layout trivial",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTImporter.rst:6711,simpl,simple,6711,interpreter/llvm-project/clang/docs/LibASTImporter.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTImporter.rst,4,['simpl'],['simple']
Usability,"fer; contains all simple data members of all the classes that make up this; particular object. Data members that are references (as; `MyClass &fObj;`) are never saved, it is always the responsibility of; the object's constructor to set them properly. ### Automatically Generated Streamers. A `Streamer `usually calls other `Streamers`: the `Streamer `of its; parents and data members. This architecture depends on all classes; having `Streamers`, because eventually they will be called. To ensure; that a class has a `Streamer`, `rootcling` automatically creates one in; the `ClassDef` macro that is defined in `$ROOTSYS/include/Rtypes.h`.; `ClassDef` defines several methods for any class, and one of them is the; `Streamer`. The automatically generated `Streamer `is complete and can; be used as long as no customization is needed. The `Event` class is defined in `$ROOTSYS/test/Event.h`. Looking at the; class definition, we find that it inherits from **`TObject`**. It is a; simple example of a class with diverse data members. ``` {.cpp}; class Event : public TObject {; private:; TDirectory *fTransient; //! current directory; Float_t fPt; //! transient value; char fType[20];; Int_t fNtrack;; Int_t fNseg;; Int_t fNvertex;; UInt_t fFlag;; Float_t fTemperature;; EventHeader fEvtHdr; //|| don't split; TClonesArray *fTracks; //->; TH1F *fH; //->; Int_t fMeasures[10];; Float_t fMatrix[4][4];; Float_t *fClosestDistance; //[fNvertex]; ...; ```. The Event class is added to the dictionary by the `rootcling`; utility. This is the `rootcling` statement in the; `$ROOTSYS/test/Makefile`:. ``` {.cpp}; @rootcling -f EventDict.cxx -c Event.h EventLinkDef.h; ```. The `EventDict.cxx` file contains the automatically generated; `Streamer `for Event:. ``` {.cpp}; void Event::Streamer(TBuffer &R__b){; // Stream an object of class Event.; if (R__b.IsReading()) {; Event::Class()->ReadBuffer(R__b, this);; } else {; Event::Class()->WriteBuffer(R__b, this);; }; }; ```. When writing an `Event` object, `TC",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md:44250,simpl,simple,44250,documentation/users-guide/InputOutput.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md,1,['simpl'],['simple']
Usability,"ferent libraries interact; due to macro collisions, and users are forced to reorder; ``#include`` directives or introduce ``#undef`` directives to break; the (unintended) dependency. * **Conventional workarounds**: C programmers have; adopted a number of conventions to work around the fragility of the; C preprocessor model. Include guards, for example, are required for; the vast majority of headers to ensure that multiple inclusion; doesn't break the compile. Macro names are written with; ``LONG_PREFIXED_UPPERCASE_IDENTIFIERS`` to avoid collisions, and some; library/framework developers even use ``__underscored`` names; in headers to avoid collisions with ""normal"" names that (by; convention) shouldn't even be macros. These conventions are a; barrier to entry for developers coming from non-C languages, are; boilerplate for more experienced developers, and make our headers; far uglier than they should be. * **Tool confusion**: In a C-based language, it is hard to build tools; that work well with software libraries, because the boundaries of; the libraries are not clear. Which headers belong to a particular; library, and in what order should those headers be included to; guarantee that they compile correctly? Are the headers C, C++,; Objective-C++, or one of the variants of these languages? What; declarations in those headers are actually meant to be part of the; API, and what declarations are present only because they had to be; written as part of the header file?. Semantic import; ---------------; Modules improve access to the API of software libraries by replacing the textual preprocessor inclusion model with a more robust, more efficient semantic model. From the user's perspective, the code looks only slightly different, because one uses an ``import`` declaration rather than a ``#include`` preprocessor directive:. .. code-block:: c. import std.io; // pseudo-code; see below for syntax discussion. However, this module import behaves quite differently from the corresp",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst:3425,clear,clear,3425,interpreter/llvm-project/clang/docs/Modules.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst,1,['clear'],['clear']
Usability,"ficient instead; of complicating the API. Right now I have no preference or objections between the alternatives but there; are some random thoughts:. * Maybe it would be great to have a guideline how to evolve the analyzer and; follow it, so it can help us to decide in similar situations. * I do care about performance in this case. The reason is that we have a; limited performance budget. And I think we should not expect most of the checker; writers to add modeling of language constructs. So, in my opinion, it is ok to; have less nice/more verbose API for language modeling if we can have better; performance this way, since it only needs to be done once, and is done by the; framework developers. **Artem:** These are some great questions, i guess it'd be better to discuss; them more openly. As a quick dump of my current mood:. * To me it seems obvious that we need to aim for a checker API that is both; simple and powerful. This can probably by keeping the API as powerful as; necessary while providing a layer of simple ready-made solutions on top of it.; Probably a few reusable components for assembling checkers. And this layer; should ideally be pleasant enough to work with, so that people would prefer to; extend it when something is lacking, instead of falling back to the complex; omnipotent API. I'm thinking of AST matchers vs. AST visitors as a roughly; similar situation: matchers are not omnipotent, but they're so nice. * Separation between core and checkers is usually quite strange. Once we have; shared state traits, i generally wouldn't mind having region store or range; constraint manager as checkers (though it's probably not worth it to transform; them - just a mood). The main thing to avoid here would be the situation when; the checker overwrites stuff written by the core because it thinks it has a; better idea what's going on, so the core should provide a good default behavior. * Yeah, i totally care about performance as well, and if i try to implement; appr",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/InitializerLists.rst:6338,simpl,simple,6338,interpreter/llvm-project/clang/docs/analyzer/developer-docs/InitializerLists.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/InitializerLists.rst,1,['simpl'],['simple']
Usability,"filing tests are very limited, and generating the profile takes a; significant amount of time, but it can result in a significant improvement in; the performance of the generated binaries. In addition to PGO profiling we also have limited support in-tree for generating; linker order files. These files provide the linker with a suggested ordering for; functions in the final binary layout. This can measurably speed up clang by; physically grouping functions that are called temporally close to each other.; The current tooling is only available on Darwin systems with ``dtrace(1)``. It; is worth noting that dtrace is non-deterministic, and so the order file; generation using dtrace is also non-deterministic. Options for Reducing Size; =========================. .. warning::; Any steps taken to reduce the binary size will come at a cost of runtime; performance in the generated binaries. The simplest and least significant way to reduce binary size is to set the; *CMAKE_BUILD_TYPE* variable to ``MinSizeRel``, which will set the compiler; optimization level to ``-Os`` which optimizes for binary size. This will have; both the least benefit to size and the least impact on performance. The most impactful way to reduce binary size is to dynamically link LLVM into; all the tools. This reduces code size by decreasing duplication of common code; between the LLVM-based tools. This can be done by setting the following two; CMake options to ``On``: *LLVM_BUILD_LLVM_DYLIB* and *LLVM_LINK_LLVM_DYLIB*. .. warning::; Distributions should never be built using the *BUILD_SHARED_LIBS* CMake; option. (:ref:`See the warning above for more explanation <shared_libs>`.). Relevant CMake Options; ======================. This section provides documentation of the CMake options that are intended to; help construct distributions. This is not an exhaustive list, and many; additional options are documented in the :doc:`CMake` page. Some key options; that are already documented include: *LLVM_TARGETS_TO_B",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/BuildingADistribution.rst:10031,simpl,simplest,10031,interpreter/llvm-project/llvm/docs/BuildingADistribution.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/BuildingADistribution.rst,1,['simpl'],['simplest']
Usability,"flow (`RET` instructions) can be hijacked; via overwriting the return address (`RA`) on stack.; Various mitigation techniques (e.g. `SafeStack`_, `RFG`_, `Intel CET`_); try to detect or prevent `RA` corruption on stack. RCFI enforces the expected control flow in several different ways described below.; RCFI heavily relies on LTO. Leaf Functions; --------------; If `f()` is a leaf function (i.e. it has no calls; except maybe no-return calls) it can be called using a special calling convention; that stores `RA` in a dedicated register `R` before the `CALL` instruction.; `f()` does not spill `R` and does not use the `RET` instruction,; instead it uses the value in `R` to `JMP` to `RA`. This flavour of CFI is *precise*, i.e. the function is guaranteed to return; to the point exactly following the call. An alternative approach is to; copy `RA` from stack to `R` in the first instruction of `f()`,; then `JMP` to `R`.; This approach is simpler to implement (does not require changing the caller); but weaker (there is a small window when `RA` is actually stored on stack). Functions called once; ---------------------; Suppose `f()` is called in just one place in the program; (assuming we can verify this in LTO mode).; In this case we can replace the `RET` instruction with a `JMP` instruction; with the immediate constant for `RA`.; This will *precisely* enforce the return control flow no matter what is stored on stack. Another variant is to compare `RA` on stack with the known constant and abort; if they don't match; then `JMP` to the known constant address. Functions called in a small number of call sites; ------------------------------------------------; We may extend the above approach to cases where `f()`; is called more than once (but still a small number of times).; With LTO we know all possible values of `RA` and we check them; one-by-one (or using binary search) against the value on stack.; If the match is found, we `JMP` to the known constant address, otherwise abort. T",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ControlFlowIntegrityDesign.rst:25126,simpl,simpler,25126,interpreter/llvm-project/clang/docs/ControlFlowIntegrityDesign.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ControlFlowIntegrityDesign.rst,1,['simpl'],['simpler']
Usability,"for GPU and optimized for speed and with multi-class support. ; * `Architecture=GPU` to select the newer GPU version. Requires configuration of ROOT with CUDA or OpenCL enabled. ; * Support for Cross Validation (see tutorial `tmva/TMVACrossValidation` as an example).; * Support for Hyper-Parameter tuning for BDT and SVM methods.; * New Variable Importance algorithm independent of the MVA method.; * New Loss Function class for regression.; * Improvements in the SVM method: new kernel functions.; * New `ROCCurve` class. ; * New interface to Keras (PyKeras) available in the PyMVA library.; * Support for Jupyter notebooks; * Support for all the functionality available in GUI: preprocessing, variable correlations, classifier output.; * New classifier visualization for BDT, ANN and DNN.; * Interactive training for all methods. ## 2D Graphics Libraries. * In `TColor::SetPalette`, make sure the high quality palettes are defined; only once taking care of transparency. Also `CreateGradientColorTable` has been; simplified.; * New fast constructor for `TColor` avoiding to call `gROOT->GetColor()`. The; normal constructor generated a big slow down when creating a Palette with; `CreateGradientColorTable`.; * In `CreateGradientColorTable` we do not need anymore to compute the highest; color index.; * In `TGraphPainter`, when graphs are painted with lines, they are split into; chunks of length `fgMaxPointsPerLine`. This allows to paint line with an ""infinite""; number of points. In some case this ""chunks painting"" technic may create artefacts; at the chunk's boundaries. For instance when zooming deeply in a PDF file. To avoid; this effect it might be necessary to increase the chunks' size using the new function:; `TGraphPainter::SetMaxPointsPerLine(20000)`.; * When using line styles different from 1 (continuous line), the behavior of TArrow; was suboptimal. The problem was that the line style is also applied to the arrow; head, which is usually not what one wants.; The arrow tip is ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v608/index.md:13951,simpl,simplified,13951,README/ReleaseNotes/v608/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v608/index.md,1,['simpl'],['simplified']
Usability,"for `loop induction; variables <LangImpl05.html#for-loop-expression>`_ in the symbol table, and for `local; variables <LangImpl07.html#user-defined-local-variables>`_. .. code-block:: c++. Value *BinaryExprAST::codegen() {; Value *L = LHS->codegen();; Value *R = RHS->codegen();; if (!L || !R); return nullptr;. switch (Op) {; case '+':; return Builder->CreateFAdd(L, R, ""addtmp"");; case '-':; return Builder->CreateFSub(L, R, ""subtmp"");; case '*':; return Builder->CreateFMul(L, R, ""multmp"");; case '<':; L = Builder->CreateFCmpULT(L, R, ""cmptmp"");; // Convert bool 0/1 to double 0.0 or 1.0; return Builder->CreateUIToFP(L, Type::getDoubleTy(TheContext),; ""booltmp"");; default:; return LogErrorV(""invalid binary operator"");; }; }. Binary operators start to get more interesting. The basic idea here is; that we recursively emit code for the left-hand side of the expression,; then the right-hand side, then we compute the result of the binary; expression. In this code, we do a simple switch on the opcode to create; the right LLVM instruction. In the example above, the LLVM builder class is starting to show its; value. IRBuilder knows where to insert the newly created instruction,; all you have to do is specify what instruction to create (e.g. with; ``CreateFAdd``), which operands to use (``L`` and ``R`` here) and; optionally provide a name for the generated instruction. One nice thing about LLVM is that the name is just a hint. For instance,; if the code above emits multiple ""addtmp"" variables, LLVM will; automatically provide each one with an increasing, unique numeric; suffix. Local value names for instructions are purely optional, but it; makes it much easier to read the IR dumps. `LLVM instructions <../../LangRef.html#instruction-reference>`_ are constrained by strict; rules: for example, the Left and Right operands of an `add; instruction <../../LangRef.html#add-instruction>`_ must have the same type, and the; result type of the add must match the operand types. Because all ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl03.rst:7184,simpl,simple,7184,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl03.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl03.rst,1,['simpl'],['simple']
Usability,"for constructor failure; Not resolved. 2624; C++23; Array delete expression with no array cookie; Unknown. 2625; C++23; Deletion of pointer to out-of-lifetime object; Unknown. 2626; C++23; Rephrase ones' complement using base-2 representation; Unknown. 2627; C++23; Bit-fields and narrowing conversions; Unknown. 2628; DR; Implicit deduction guides should propagate constraints; No. 2629; C++23; Variables of floating-point type as switch conditions; Unknown. 2630; C++23; Syntactic specification of class completeness; Unknown. 2631; C++23; Immediate function evaluations in default arguments; Clang 16. 2632; review; 'user-declared' is not defined; Not resolved. 2633; open; typeid of constexpr-unknown dynamic type; Not resolved. 2634; tentatively ready; Avoid circularity in specification of scope for friend class declarations; Unknown. 2635; C++23; Constrained structured bindings; Clang 16. 2636; C++23; Update Annex E based on Unicode 15.0 UAX #31; N/A. 2637; tentatively ready; Injected-class-name as a simple-template-id; Unknown. 2638; tentatively ready; Improve the example for initializing by initializer list; Unknown. 2639; C++23; new-lines after phase 1; Unknown. 2640; C++23; Allow more characters in an n-char sequence; Clang 16. 2641; C++23; Redundant specification of value category of literals; Unknown. 2642; C++23; Inconsistent use of T and C; N/A. 2643; C++23; Completing a pointer to array of unknown bound; Unknown. 2644; C++23; Incorrect comment in example; Clang 8. 2645; C++23; Unused term ""default argument promotions""; Unknown. 2646; C++23; Defaulted special member functions; Unknown. 2647; C++23; Fix for ""needed for constant evaluation""; Unknown. 2648; C++23; Correspondence of surrogate call function and conversion function; Unknown. 2649; C++23; Incorrect note about implicit conversion sequence; Unknown. 2650; C++23; Incorrect example for ill-formed non-type template arguments; Clang 17. 2651; C++23; Conversion function templates and ""noexcept""; Unknown. 2652;",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:181797,simpl,simple-template-id,181797,interpreter/llvm-project/clang/www/cxx_dr_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html,1,['simpl'],['simple-template-id']
Usability,"for resumption prior to a call to; `async_op` function that may trigger resumption of a coroutine from the same or; a different thread possibly prior to `async_op` call returning control back; to the coroutine:. .. code-block:: llvm. %save1 = call token @llvm.coro.save(ptr %hdl); call void @async_op1(ptr %hdl); %suspend1 = call i1 @llvm.coro.suspend(token %save1, i1 false); switch i8 %suspend1, label %suspend [i8 0, label %resume1; i8 1, label %cleanup]. .. _coro.suspend.async:. 'llvm.coro.suspend.async' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^; ::. declare {ptr, ptr, ptr} @llvm.coro.suspend.async(; ptr <resume function>,; ptr <context projection function>,; ... <function to call>; ... <arguments to function>). Overview:; """""""""""""""""". The '``llvm.coro.suspend.async``' intrinsic marks the point where; execution of an async coroutine is suspended and control is passed to a callee. Arguments:; """""""""""""""""""". The first argument should be the result of the `llvm.coro.async.resume` intrinsic.; Lowering will replace this intrinsic with the resume function for this suspend; point. The second argument is the `context projection function`. It should describe; how-to restore the `async context` in the continuation function from the first; argument of the continuation function. Its type is `ptr (ptr)`. The third argument is the function that models transfer to the callee at the; suspend point. It should take 3 arguments. Lowering will `musttail` call this; function. The fourth to six argument are the arguments for the third argument. Semantics:; """""""""""""""""""". The result of the intrinsic are mapped to the arguments of the resume function.; Execution is suspended at this intrinsic and resumed when the resume function is; called. .. _coro.prepare.async:. 'llvm.coro.prepare.async' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^; ::. declare ptr @llvm.coro.prepare.async(ptr <coroutine function>). Overview:; """""""""""""""""". The '``llvm.coro.prepare.async``' intrinsic is used t",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst:53719,resume,resume,53719,interpreter/llvm-project/llvm/docs/Coroutines.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst,1,['resume'],['resume']
Usability,"form of a; README file, mission statement, and/or manifesto.; * Should conform to coding standards, incremental development process, and; other expectations.; * Should have a sense of the community that it hopes to eventually foster, and; there should be interest from members with different affiliations /; organizations.; * Should have a feasible path to eventually graduate as a dedicated top-level; or sub-project within the `LLVM monorepo; <https://github.com/llvm/llvm-project>`_.; * Should include a notice (e.g. in the project README or web page) that the; project is in ‘incubation status’ and is not included in LLVM releases (see; suggested wording below).; * Must be proposed through the LLVM RFC process, and have its addition; approved by the LLVM community - this ultimately mediates the resolution of; the ""should"" concerns above. That said, the project need not have any code to get started, and need not have; an established community at all! Furthermore, incubating projects may pass; through transient states that violate the ""Should"" guidelines above, or would; otherwise make them unsuitable for direct inclusion in the monorepo (e.g.; dependencies that have not yet been factored appropriately, leveraging; experimental components or APIs that are not yet upstream, etc). When approved, the llvm-admin group can grant the new project:; * A new repository in the LLVM Github Organization - but not the LLVM monorepo.; * New mailing list, discourse forum, and/or discord chat hosted with other LLVM; forums.; * Other infrastructure integration can be discussed on a case-by-case basis. Graduation to the mono-repo would follow existing processes and standards for; becoming a first-class part of the monorepo. Similarly, an incubating project; may be eventually retired, but no process has been established for that yet. If; and when this comes up, please start an RFC discussion on the `LLVM Discourse forums`_. This process is very new - please expect the details to change, it",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/DeveloperPolicy.rst:49128,guid,guidelines,49128,interpreter/llvm-project/llvm/docs/DeveloperPolicy.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/DeveloperPolicy.rst,1,['guid'],['guidelines']
Usability,"format suitable to your needs, see documentation of; class `TCanvas`:. ``` {.cpp}; TCanvas c1(""c1"",""<Title>"",0,0,400,300); // create a canvas, specify position and size in pixels; c1.Divide(2,2); //set subdivisions, called pads; c1.cd(1); //change to pad 1 of canvas c1; ```. These parts of a well-written macro are pretty standard, and you should; remember to include pieces of code like in the examples above to make; sure your plots always look as you had intended. Below, in section [Interpretation and Compilation](#interpretation-and-compilation), some more code fragments; will be shown, allowing you to use the system compiler to compile macros for; more efficient execution, or turn macros into stand-alone applications linked; against the ROOT libraries. ## A more complete example ##. Let us now look at a rather complete example of a typical task in data; analysis, a macro that constructs a graph with errors, fits a (linear); model to it and saves it as an image. To run this macro, simply type in; the shell:. ``` {.cpp}; > root macro1.C; ```. The code is built around the ROOT class `TGraphErrors`, which was; already introduced previously. Have a look at it in the class reference; guide, where you will also find further examples. The macro shown below; uses additional classes, `TF1` to define a function, `TCanvas` to define; size and properties of the window used for our plot, and `TLegend` to; add a nice legend. For the moment, ignore the commented include; statements for header files, they will only become important at the end; in section [Interpretation and Compilation](#interpretation-and-compilation). ``` {.cpp .numberLines}; @ROOT_INCLUDE_FILE macros/macro1.C; ```. Let's comment it in detail:. - Line *13*: the name of the principal function (it plays the role of; the ""main"" function in compiled programs) in the macro file. It has; to be the same as the file name without extension. - Line *24-25*: instance of the `TGraphErrors` class. The constructor; takes the n",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/your_first_ROOT_macro.md:2759,simpl,simply,2759,documentation/primer/your_first_ROOT_macro.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/your_first_ROOT_macro.md,1,['simpl'],['simply']
Usability,"found on the; [MINUIT Web Site](http://www.cern.ch/minuit). Minuit2, originally developed in the SEAL project, is now distributed within %ROOT.; The API has been then changed in this new version to follow the %ROOT coding convention; (function names starting with capital letters) and the classes have been moved inside; the namespace _ROOT::Minuit2_. In addition, the %ROOT distribution contains classes; needed to integrate Minuit2 in the %ROOT framework. A new class has been introduced, ROOT::Minuit2::Minuit2Minimizer, which implements; the interface ROOT::Math::Minimizer. Within %ROOT, it can be instantiates also using; the %ROOT plug-in manager. This class provides a convenient entry point for using Minuit2\.; An example of using this interface is the %ROOT tutorial _tutorials/fit/NumericalMinimization.C_; or the Minuit2 test program; [<tt>testMinimize.cxx</tt>](https://github.com/cxx-hep/root-cern/blob/master/math/minuit2/test/testMinimize.cxx). A standalone version of Minuit2 (independent of %ROOT) can be easily built and installed using `CMake`. See this [`README`](https://github.com/root-project/root/blob/master/math/minuit2/README.md) for the instructions on how to get the sources, building and installing a stand-alone Minuit2. The [Minuit2 User Guide](https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html); provides all the information needed for using directly (without add-on packages like %ROOT) Minuit2. ## References. 1. F. James, _Fortran MINUIT Reference Manual_ ([html](https://cern-tex.web.cern.ch/cern-tex/minuit/minmain.html));; 2. F. James and M. Winkler, _C++ MINUIT User's Guide_ ([html](https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html) and [pdf](https://root.cern/root/htmldoc/guides/minuit2/Minuit2.pdf));; 3. F. James, _Minuit Tutorial on Function Minimization_ ([pdf](http://seal.cern.ch/documents/minuit/mntutorial.pdf));; 4. F. James, _The Interpretation of Errors in Minuit_ ([pdf](http://seal.cern.ch/documents/minuit/mnerror.pdf));; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/doc/Minuit2.md:1961,guid,guides,1961,math/minuit2/doc/Minuit2.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/doc/Minuit2.md,3,['guid'],['guides']
Usability,"fsets into the string table rather than embedding the string's value; directly. The format of this substream is as follows:. .. code-block:: c++. struct FileInfoSubstream {; uint16_t NumModules;; uint16_t NumSourceFiles;. uint16_t ModIndices[NumModules];; uint16_t ModFileCounts[NumModules];; uint32_t FileNameOffsets[NumSourceFiles];; char NamesBuffer[][NumSourceFiles];; };. **NumModules** - The number of modules for which source file information is; contained within this substream. Should match the corresponding value from the; ref:`dbi_header`. **NumSourceFiles**: In theory this is supposed to contain the number of source; files for which this substream contains information. But that would present a; problem in that the width of this field being ``16``-bits would prevent one from; having more than 64K source files in a program. In early versions of the file; format, this seems to have been the case. In order to support more than this, this; field of the is simply ignored, and computed dynamically by summing up the values of; the ``ModFileCounts`` array (discussed below). In short, this value should be; ignored. **ModIndices** - This array is present, but does not appear to be useful. **ModFileCountArray** - An array of ``NumModules`` integers, each one containing; the number of source files which contribute to the module at the specified index.; While each individual module is limited to 64K contributing source files, the; union of all modules' source files may be greater than 64K. The real number of; source files is thus computed by summing this array. Note that summing this array; does not give the number of `unique` source files, only the total number of source; file contributions to modules. **FileNameOffsets** - An array of **NumSourceFiles** integers (where **NumSourceFiles**; here refers to the 32-bit value obtained from summing **ModFileCountArray**), where; each integer is an offset into **NamesBuffer** pointing to a null terminated string. **NamesBuffer** ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/PDB/DbiStream.rst:13457,simpl,simply,13457,interpreter/llvm-project/llvm/docs/PDB/DbiStream.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/PDB/DbiStream.rst,1,['simpl'],['simply']
Usability,"ftware and method performance; validation has been implemented.; . Methods. BDT Automatic parameter optimisation for building the; tree architecture: The optimisation procedure uses the; performance of the trained classifier on the ""test sample"" for; finding the set of optimal parameters. Two different methods to; traverse the parameter space are available (scanning, genetic; algorithm). Currently parameter optimization is implemented only; for these three parameters that influence the tree architectur:; the maximum depth of a tree, MaxDepth, the minimum; number of events in each node, NodeMinEvents, and; the number of tress, NTrees. Optimization can; is invoked by calling; factory->OptimizeAllMethods(); prior to the call; factory->TrainAllMethods();. Automated and configurable parameter optimization is soon to; be enabled for all methods (for those parameters where; optimization is applicable).; . BDT node splitting: While Decision Trees; typically have only univariate splits, in TMVA one can now; also opt for multivariate splits that use a ""Fisher; Discriminant"" (option: UseFisherCuts), built from all; observables that show correlations larger than some threshold; (MinLinCorrForFisher). The training will then test at each; split a cut on this fisher discriminant in addition to all; univariate cuts on the variables (or only on those variables; that have not been used in the Fisher discriminant, option; UseExcusiveVars). No obvious improvement betwen very simple; decision trees after boosting has been observed so far, but; only a limited number of studies has been performed concerning; potiential benenfit of these simple multivariate splits.; . Bug fixes. A problem in the BDTG has been fixed, leading to a much; improved regression performance.; A problem in the TMVA::Reader has been fixed.; With the new test framework and the coverity checks of ROOT; a number of bugs were discovered and fixed. They mainly concerned; memory leaks, and did not affect the performance. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/doc/v528/index.html:2961,simpl,simple,2961,tmva/doc/v528/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/doc/v528/index.html,2,['simpl'],['simple']
Usability,"function stored in the coroutine; frame. Destroying a coroutine that is not suspended leads to undefined behavior. .. _coro.resume:. 'llvm.coro.resume' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. ::. declare void @llvm.coro.resume(ptr <handle>). Overview:; """""""""""""""""". The '``llvm.coro.resume``' intrinsic resumes a suspended switched-resume coroutine. Arguments:; """""""""""""""""""". The argument is a handle to a suspended coroutine. Semantics:; """""""""""""""""""". When possible, the `coro.resume` intrinsic is replaced with a direct call to the; coroutine resume function. Otherwise it is replaced with an indirect call based; on the function pointer for the resume function stored in the coroutine frame.; Resuming a coroutine that is not suspended leads to undefined behavior. .. _coro.done:. 'llvm.coro.done' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. ::. declare i1 @llvm.coro.done(ptr <handle>). Overview:; """""""""""""""""". The '``llvm.coro.done``' intrinsic checks whether a suspended; switched-resume coroutine is at the final suspend point or not. Arguments:; """""""""""""""""""". The argument is a handle to a suspended coroutine. Semantics:; """""""""""""""""""". Using this intrinsic on a coroutine that does not have a `final suspend`_ point; or on a coroutine that is not suspended leads to undefined behavior. .. _coro.promise:. 'llvm.coro.promise' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. ::. declare ptr @llvm.coro.promise(ptr <ptr>, i32 <alignment>, i1 <from>). Overview:; """""""""""""""""". The '``llvm.coro.promise``' intrinsic obtains a pointer to a; `coroutine promise`_ given a switched-resume coroutine handle and vice versa. Arguments:; """""""""""""""""""". The first argument is a handle to a coroutine if `from` is false. Otherwise,; it is a pointer to a coroutine promise. The second argument is an alignment requirements of the promise.; If a frontend designated `%promise = alloca i32` as a promise, the alignment; argument to `coro.promise` should be the alignment of `i32` on the target; plat",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst:28592,resume,resume,28592,interpreter/llvm-project/llvm/docs/Coroutines.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst,1,['resume'],['resume']
Usability,"functions support temporary ranges, for example:. .. code-block:: c++. for (auto [Letter, Count] : zip(SmallVector<char>{'a', 'b', 'c'}, Counts)); errs() << Letter << "": "" << Count << ""\n"";. The difference between the functions in the ``zip`` family is how they behave; when the supplied ranges have different lengths:. * ``zip_equal`` -- requires all input ranges have the same length.; * ``zip`` -- iteration stops when the end of the shortest range is reached.; * ``zip_first`` -- requires the first range is the shortest one.; * ``zip_longest`` -- iteration continues until the end of the longest range is; reached. The non-existent elements of shorter ranges are replaced with; ``std::nullopt``. The length requirements are checked with ``assert``\ s. As a rule of thumb, prefer to use ``zip_equal`` when you expect all; ranges to have the same lengths, and consider alternative ``zip`` functions only; when this is not the case. This is because ``zip_equal`` clearly communicates; this same-length assumption and has the best (release-mode) runtime performance. .. _uf_enumerate:. ``enumerate``; ^^^^^^^^^^^^^. The ``enumerate`` functions allows to iterate over one or more ranges while; keeping track of the index of the current loop iteration. For example:. .. code-block:: c++. for (auto [Idx, BB, Value] : enumerate(Phi->blocks(),; Phi->incoming_values())); errs() << ""#"" << Idx << "" "" << BB->getName() << "": "" << *Value << ""\n"";. The current element index is provided as the first structured bindings element.; Alternatively, the index and the element value can be obtained with the; ``index()`` and ``value()`` member functions:. .. code-block:: c++. char Letters[26] = ...;; for (auto En : enumerate(Letters)); errs() << ""#"" << En.index() << "" "" << En.value() << ""\n"";. Note that ``enumerate`` has ``zip_equal`` semantics and provides elements; through a 'reference wrapper' proxy, which makes them modifiable when accessed; through structured bindings or the ``value()`` member function.",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:101831,clear,clearly,101831,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,1,['clear'],['clearly']
Usability,"g Linux::. $ g++ `cling-config --cppflags` -fPIC -O2 -shared MyClass_rflx.cxx -o MyClassDict.so. Instead of loading the header text into ``cling``, you can now load the; dictionary:. .. code-block:: python. >>> import cppyy; >>> cppyy.load_reflection_info('MyClassDict'); >>> cppyy.gbl.MyClass(42); <cppyy.gbl.MyClass object at 0x7ffb9f230950>; >>> print(_.get_int()); 42; >>>. and use the selected C++ entities as if the header was loaded. The dictionary shared library can be relocated, as long as it can be found; by the dynamic loader (e.g. through ``LD_LIBRARY_PATH``) and the header file; is fully embedded or still accessible (e.g. through a path added to; ``cppyy.add_include_path`` at run-time, or with ``-I`` to; ``rootcling``/``genreflex`` during build time).; When relocating the shared library, move the .pcm with it.; Once support for C++ modules is fully fleshed out, access to the header file; will no longer be needed. .. _`rootcling manual`: https://root.cern.ch/root/html/guides/users-guide/AddingaClass.html#the-linkdef.h-file; .. _`helper script`: https://github.com/wlav/cppyy/blob/master/test/make_dict_win32.py. Class loader; ^^^^^^^^^^^^. Explicitly loading dictionaries is fine if this is hidden under the hood of; a Python package and thus transparently done on ``import``.; Otherwise, the automatic class loader is more convenient, as it allows direct; use without having to manually find and load dictionaries (assuming these are; locatable by the dynamic loader). The class loader utilizes so-called rootmap files, which by convention should; live alongside the dictionary shared library (and C++ module file).; These are simple text files, which map C++ entities (such as classes) to the; dictionaries and other libraries that need to be loaded for their use. With ``genreflex``, the mapping file can be automatically created with; ``--rootmap-lib=MyClassDict``, where ""MyClassDict"" is the name of the shared; library (without the extension) build from the dictionary fi",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/utilities.rst:8008,guid,guides,8008,bindings/pyroot/cppyy/cppyy/doc/source/utilities.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/utilities.rst,2,['guid'],"['guide', 'guides']"
Usability,"g as the `CMakeCache.txt` file is not removed. Remember that after building a tarball or a binary package you should remove the copied files using:. ```bash; make purge; ```. Otherwise git shows the file as untracked, unless you explicitly remove their tracking yourself with a .gitignore file. ## Building a tarball. Minuit2 standalone also has support for CPack to make installers for different platforms. To build a source package:. ```bash; make package_source; ```. This will create a source file in several formats that you can distribute. Reminder: You **must** have used `-Dminuit2_standalone=ON` when you configured CMake, or many of the files will be missing. ## Building a binary. To build a binary package (add other generators with `-G`):; ```bash; make; make package; ```. ## Maintenance. If new files are needed by Minuit2 due to additions to [ROOT], they should be added to the source files lists in `src/Math/CMakeLists.txt` and `src/Minuit2/CMakeLists.txt` (depending on if it's a new Math or Minuit2 requirement). For testing, the main `test/CMakeLists.txt` is used by ROOT, and the `test/*/CMakeLists.txt` files are used by the standalone build. ## How it works. Extracting from the ROOT sources is made possible through a few careful design features:. * A CMake variable `minuit2_inroot` lets the build system know we are inside ROOT (it looks for `../../build/version_info`); * All files that are not part of the minuit2 directory are passed into `copy_standalone`, and that handles selecting the correct location; * `copy_standalone` copies the files into the minuit2 source directory if `minuit2_standalone` is `ON`. After this happens, all the standard CMake machinery can produce the source distribution. And, CMake correctly builds and installs in either mode, since all source and header files are explicitly listed. [ROOT]: https://root.cern; [minuitdoc]: https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html#minuit2-package; [CMake]: https://cmake.org; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/DEVELOP.md:2745,guid,guides,2745,math/minuit2/DEVELOP.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/DEVELOP.md,2,['guid'],"['guide', 'guides']"
Usability,"g on macOS, download; and install the macOS `Graphviz program; <http://www.pixelglow.com/graphviz/>`_ and add; ``/Applications/Graphviz.app/Contents/MacOS/`` (or wherever you install it) to; your path. The programs need not be present when configuring, building or; running LLVM and can simply be installed when needed during an active debug; session. ``SelectionDAG`` has been extended to make it easier to locate *interesting*; nodes in large complex graphs. From gdb, if you ``call DAG.setGraphColor(node,; ""color"")``, then the next ``call DAG.viewGraph()`` would highlight the node in; the specified color (choices of colors can be found at `colors; <http://www.graphviz.org/doc/info/colors.html>`_.) More complex node attributes; can be provided with ``call DAG.setGraphAttrs(node, ""attributes"")`` (choices can; be found at `Graph attributes <http://www.graphviz.org/doc/info/attrs.html>`_.); If you want to restart and clear all the current graph attributes, then you can; ``call DAG.clearGraphAttrs()``. Note that graph visualization features are compiled out of Release builds to; reduce file size. This means that you need a Debug+Asserts or Release+Asserts; build to use these features. .. _datastructure:. Picking the Right Data Structure for a Task; ===========================================. LLVM has a plethora of data structures in the ``llvm/ADT/`` directory, and we; commonly use STL data structures. This section describes the trade-offs you; should consider when you pick one. The first step is a choose your own adventure: do you want a sequential; container, a set-like container, or a map-like container? The most important; thing when choosing a container is the algorithmic properties of how you plan to; access the container. Based on that, you should use:. * a :ref:`map-like <ds_map>` container if you need efficient look-up of a; value based on another value. Map-like containers also support efficient; queries for containment (whether a key is in the map). Map-like co",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:54547,clear,clearGraphAttrs,54547,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,1,['clear'],['clearGraphAttrs']
Usability,"g the old name - Reve):. - [EVE - Event Visualization Environment of the ROOT framework]; (http://pos.sissa.it//archive/conferences/070/103/ACAT08_103.pdf); presented at ACAT 2008. - [Event Visualization Environment of the ALICE experiment]; (http://indico.cern.ch/contributionDisplay.py?contribId=25&confId=13356); presented at ROOT Workshop 2007. - [Raw-data display and visual reconstruction validation in ALICE]; (http://indico.cern.ch/contributionDisplay.py?contribId=442&sessionId=23&confId=3580); presented at CHEP 2007. Eve is built on top of ROOT's GUI, GL and GED infrastructure and; delivers the following main features:. - Base-classes for representation of visual objects that can; be presented in list-tree views, object-editors and rendered; via OpenGL (TEveElement and sub-classes). - Application manager class TEveManager for top-level; management of elements, GUI components, geometries and events;. - Classes for presentation of full TGeo geometries; (TEveGeoNode and TEveGeoTopNode) as well as of; simplifed geometries via extraction of shape-data; (TEveGeoShape). \image html eve_cmsgeo.png ""CMS geometry"". - Classes for presentation of trajectories or tracks; (TEveTrack, TEveTrackPropagator) and hits or; clusters (TEvePointSet, TEvePointSetArray). \image html eve_alice3d.png ""A simulated ALICE pp@14TeV event in 3D"". - Base-classes for presentation of raw-data or digits; (TEveDigitSet, TEveQuadSet and; TEveBoxSet). A collection of objects can be assigned; common signal-to-color mapping (TEveRGBAPelette) and; surrounding frame (TEveFrameBox). \image html eve_quadset.png ""Hexagonal and rectangular digits"". - Base-classes for 2D projections with dynamically controllable; fish-eye magnification of the vertex region; (TEveProjectionManager and; TEveProjection). Tracks, points and geometries can be; projected automatically. R-phi and Rho-z projections are; currently supported. \image html eve_aliceproj.png ""A r-phi projection with fish-eye transformation of a simulated ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve/doc/index.md:1598,simpl,simplifed,1598,graf3d/eve/doc/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve/doc/index.md,1,['simpl'],['simplifed']
Usability,"g to add, is codegen support for these binary; operators. Given our current structure, this is a simple addition of a; default case for our existing binary operator node:. .. code-block:: c++. Value *BinaryExprAST::codegen() {; Value *L = LHS->codegen();; Value *R = RHS->codegen();; if (!L || !R); return nullptr;. switch (Op) {; case '+':; return Builder->CreateFAdd(L, R, ""addtmp"");; case '-':; return Builder->CreateFSub(L, R, ""subtmp"");; case '*':; return Builder->CreateFMul(L, R, ""multmp"");; case '<':; L = Builder->CreateFCmpULT(L, R, ""cmptmp"");; // Convert bool 0/1 to double 0.0 or 1.0; return Builder->CreateUIToFP(L, Type::getDoubleTy(*TheContext),; ""booltmp"");; default:; break;; }. // If it wasn't a builtin binary operator, it must be a user defined one. Emit; // a call to it.; Function *F = getFunction(std::string(""binary"") + Op);; assert(F && ""binary operator not found!"");. Value *Ops[2] = { L, R };; return Builder->CreateCall(F, Ops, ""binop"");; }. As you can see above, the new code is actually really simple. It just; does a lookup for the appropriate operator in the symbol table and; generates a function call to it. Since user-defined operators are just; built as normal functions (because the ""prototype"" boils down to a; function with the right name) everything falls into place. The final piece of code we are missing, is a bit of top-level magic:. .. code-block:: c++. Function *FunctionAST::codegen() {; // Transfer ownership of the prototype to the FunctionProtos map, but keep a; // reference to it for use below.; auto &P = *Proto;; FunctionProtos[Proto->getName()] = std::move(Proto);; Function *TheFunction = getFunction(P.getName());; if (!TheFunction); return nullptr;. // If this is an operator, install it.; if (P.isBinaryOp()); BinopPrecedence[P.getOperatorName()] = P.getBinaryPrecedence();. // Create a new basic block to start insertion into.; BasicBlock *BB = BasicBlock::Create(*TheContext, ""entry"", TheFunction);; ... Basically, before codegening a func",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl06.rst:8807,simpl,simple,8807,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl06.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl06.rst,1,['simpl'],['simple']
Usability,"g to define all the upcasts and downcasts that are; valid for the operands of each instruction (you probably have thought; of other benefits also); - it could make the bytecode significantly larger because there could; be a lot of cast operations. o Making the second arg. to 'shl' a ubyte seems good enough to me.; 255 positions seems adequate for several generations of machines; and is more compact than uint. o I still have some major concerns about including malloc and free in the; language (either as builtin functions or instructions). LLVM must be; able to represent code from many different languages. Languages such as; C, C++ Java and Fortran 90 would not be able to use our malloc anyway; because each of them will want to provide a library implementation of it. This gets even worse when code from different languages is linked; into a single executable (which is fairly common in large apps).; Having a single malloc would just not suffice, and instead would simply; complicate the picture further because it adds an extra variant in; addition to the one each language provides. Instead, providing a default library version of malloc and free; (and perhaps a malloc_gc with garbage collection instead of free); would make a good implementation available to anyone who wants it. I don't recall all your arguments in favor so let's discuss this again,; and soon. o 'alloca' on the other hand sounds like a good idea, and the; implementation seems fairly language-independent so it doesn't have the; problems with malloc listed above. o About indirect call:; Your option #2 sounded good to me. I'm not sure I understand your; concern about an explicit 'icall' instruction?. o A pair of important synchronization instr'ns to think about:; load-linked; store-conditional. o Other classes of instructions that are valuable for pipeline performance:; conditional-move		 ; predicated instructions. o I believe tail calls are relatively easy to identify; do you know why; .NET has a tailcall in",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HistoricalNotes/2001-02-09-AdveComments.txt:2571,simpl,simply,2571,interpreter/llvm-project/llvm/docs/HistoricalNotes/2001-02-09-AdveComments.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HistoricalNotes/2001-02-09-AdveComments.txt,1,['simpl'],['simply']
Usability,"g*`` *to be used instead of*; ``DW_OP_breg* 0``\ *.*. .. note::. This rule could be removed and require the producer to create the required; location description directly using ``DW_OP_call_frame_cfa``,; ``DW_OP_breg*``, or ``DW_OP_LLVM_aspace_bregx``. This would also then; allow a target to implement the call frames within a large register. Otherwise, the DWARF is ill-formed if SL is not a memory location; description in any of the target architecture specific address spaces. The resulting L is the *frame base* for the subprogram or entry point. *Typically, E will use the* ``DW_OP_call_frame_cfa`` *operation or be a; stack pointer register plus or minus some offset.*. *The frame base for a subprogram is typically an address relative to the; first unit of storage allocated for the subprogram's stack frame. The*; ``DW_AT_frame_base`` *attribute can be used in several ways:*. 1. *In subprograms that need location lists to locate local variables, the*; ``DW_AT_frame_base`` *can hold the needed location list, while all; variables' location descriptions can be simpler ones involving the frame; base.*. 2. *It can be used in resolving ""up-level"" addressing within; nested routines. (See also* ``DW_AT_static_link``\ *, below)*. *Some languages support nested subroutines. In such languages, it is; possible to reference the local variables of an outer subroutine from within; an inner subroutine. The* ``DW_AT_static_link`` *and* ``DW_AT_frame_base``; *attributes allow debuggers to support this same kind of referencing.*. 3. If a ``DW_TAG_subprogram`` or ``DW_TAG_entry_point`` debugger information; entry is lexically nested, it may have a ``DW_AT_static_link`` attribute,; whose value is a DWARF expression E. The result of the attribute is obtained by evaluating E with a context that; has a result kind of a location description, an unspecified object, the; compilation unit that contains E, an empty initial stack, and other context; elements corresponding to the source language th",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst:159034,simpl,simpler,159034,interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,1,['simpl'],['simpler']
Usability,"g. Attribute 'nonnull'. Mac OS X API Annotations. Cocoa & Core Foundation Memory Management Annotations. Attribute 'ns_returns_retained'; Attribute 'ns_returns_not_retained'; Attribute 'cf_returns_retained'; Attribute 'cf_returns_not_retained'; Attribute 'ns_consumed'; Attribute 'cf_consumed'; Attribute 'ns_consumes_self'. Libkern Memory Management Annotations. Attribute 'os_returns_retained'; Attribute 'os_returns_not_retained'; Attribute 'os_consumed'; Attribute 'os_consumes_this'; Out Parameters. Custom Assertion Handlers. Attribute 'noreturn'; Attribute 'analyzer_noreturn'. Annotations to Enhance Generic Checks. Null Pointer Checking; Attribute 'nonnull'; The analyzer recognizes the GCC attribute 'nonnull', which indicates that a; function expects that a given function parameter is not a null pointer. Specific; details of the syntax of using the 'nonnull' attribute can be found in GCC's; documentation.; Both the Clang compiler and GCC will flag warnings for simple cases where a; null pointer is directly being passed to a function with a 'nonnull' parameter; (e.g., as a constant). The analyzer extends this checking by using its deeper; symbolic analysis to track what pointer values are potentially null and then; flag warnings when they are passed in a function call via a 'nonnull'; parameter.; Example. $ cat test.m; int bar(int*p, int q, int *r) __attribute__((nonnull(1,3)));. int foo(int *p, int *q) {; return !p ? bar(q, 2, p); : bar(p, 2, q);; }. Running scan-build over this source produces the following; output:. Mac OS X API Annotations. Cocoa & Core Foundation Memory Management; Annotations. The analyzer supports the proper management of retain counts for; both Cocoa and Core Foundation objects. This checking is largely based on; enforcing Cocoa and Core Foundation naming conventions for Objective-C methods; (Cocoa) and C functions (Core Foundation). Not strictly following these; conventions can cause the analyzer to miss bugs or flag false positives.; One c",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/annotations.html:1926,simpl,simple,1926,interpreter/llvm-project/clang/www/analyzer/annotations.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/annotations.html,1,['simpl'],['simple']
Usability,"g., ban, physical; removal, or moderation) may be used to immediately stop it.; * For events that include talks, organizers should end talks early if the; violations include harassment or violent threats. There may be talks where; other types of code of conduct violations occur and organizers should do ; their best to determine if a talk should be ended early or not. . When undertaking an immediate response, document the action and notify the; committee within 24 hours. . Response Procedure; ==================. The following is a summary of the steps the committee takes when responding to; a reported incident. . 1. Determine if there is a need for an :ref:`immediate response<Immediate; Response Checklist>`. 2. :ref:`Acknowledge the report<Receiving a report>` within 24 hours. 3. :ref:`Discuss the incident report<Incident Response Assessment>`, gather; more information, and determine a :ref:`resolution<Resolutions>`. 4. During this process, the :ref:`reporter will be informed of the; resolution<Following Up With the Reportee>` and feedback is requested. This; feedback may or may not be used to re-evaluate the resolution. 5. Inform the reportee of the resolution. The reportee is provided options to; :ref:`appeal<Appeal Process>`. . 6. The :ref:`resolution<Resolutions>` is implemented. 7. All reports, data, notes, and resolutions are logged in a private location; (e.g., Google Drive or other database). The committee will never make public statements about a resolution and will; only publish :ref:`transparency reports<Transparency Reports>`. If a public; statement is necessary and requested by the committee, it will be given by the; LLVM Foundation Board of Directors. Report Acknowledgement; ======================. When a report is received, the committee will reply to the reporter to confirm; receipt within 24 hours of the incident being reported. . This acknowledgement will contain:. * Acknowledgement of the incident report; * Next steps of the committee for respondin",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ResponseGuide.rst:3637,feedback,feedback,3637,interpreter/llvm-project/llvm/docs/ResponseGuide.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ResponseGuide.rst,1,['feedback'],['feedback']
Usability,"g., for a draft PR), use `[skip-CI]` as the first tag.; Note that for functional changes this tag needs to be removed and it has to pass the CI before merging to ensure; the change does not break anything. The PR description describes (and in case of multiple commits, summarizes) the change in more detail.; Again, try to describe the **why** (and in this case, to a lesser extent the **what**), rather than the **how**. If your PR is related to an open [issue](https://github.com/root-project/root/issues), make sure to link it.; This will be done automatically if you add; [closing keywords](https://docs.github.com/en/issues/tracking-your-work-with-issues/linking-a-pull-request-to-an-issue); to the PR description. Once a PR is created, a member of the ROOT team will review it as quickly as possible. If you are familiar with the; ROOT community, it may be beneficial to add a suggested reviewer to the PR in order to get quicker attention.; Please ping people :wave: should you not get timely feedback, for instance with `@root-project/core ping!`. ## Tests. As you contribute code, this code will likely fix an issue or add a feature.; Whatever it is: this requires you to add a new test, or to extend an existing test. Depending on the size and complexity; of this test, it exists either in the `test/` subdirectory of each part of ROOT (see for instance; [`tree/dataframe/test`](https://github.com/root-project/root/tree/master/tree/dataframe/test)), or in; [roottest](https://github.com/root-project/roottest.git). Tests in `test/` subdirectories are unit tests, mostly based on; [Google Test](https://github.com/google/googletest) and easily extended. Tests in; [roottest](https://github.com/root-project/roottest.git) are more involved (e.g., tests requiring custom dictionaries or; data files). When you create a branch in the main ROOT repository (i.e., this repository) and add a test to `roottest`,; make sure to do this under the same branch name (and open a PR for it). Our CI infra",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/CONTRIBUTING.md:5339,feedback,feedback,5339,CONTRIBUTING.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/CONTRIBUTING.md,1,['feedback'],['feedback']
Usability,"g/posts/2020-11-30-interactive-cpp-with-cling/>`_; - *Vassil Vassilev* 2020 The LLVM Project Blog; - This blog page briefly discusses the concept of interactive C++ by presenting Cling’s main features, such as wrapper functions, entity redefinition, error recovery. ; * - `Using the Cling C++ Interpreter on the Bela Platform <https://gist.github.com/jarmitage/6e411ae8746c04d6ecbee1cbc1ebdcd4>`_; - Jack Armitage 2019; - Cling has been installed on a BeagleBoard to bring live coding to the Bela interactive audio platform.; * - `Implementation of GlobalModuleIndex in ROOT and Cling <https://indico.cern.ch/event/840376/contributions/3525646/attachments/1895398/3127159/GSoC_Presentation__GMI.pdf>`_; - *Arpitha Raghunandan* 2012 Google Summer of Code GSoC; - GlobalModuleIndex can be used for improving ROOT’s and Cling’s performance ; * - `Example project using cling as library <https://github.com/root-project/cling/tree/master/tools/demo>`_; - *Axel Naumann* 2016 GitHub; - This video showcases how to use Cling as a library, and shows how to set up a simple CMake configuration that uses Cling.; * - `Cling C++ interpreter testdrive <https://www.youtube.com/watch?v=1IGTHusaJ18>`_; - *Mika* 2015 Youtube; - In this tutorial, a developer tries Cling for the first time by uploading a few simple C++ user-cases onto Cling, involving also the loading of external files; * - `Building an Order Book in C++ <https://www.youtube.com/watch?v=fxN4xEZvrxI>`_; - *Dimitri Nesteruk* 2015 Youtube; - This demo shows how to build a simple order book using C++, CLion, Google Test and, of course, Cling. ; * - `Cling C++ interpreter testdrive <https://www.youtube.com/watch?v=1IGTHusaJ18>`_; - Dimitri Nesteruk 2015 Youtube; - This tutorial describes Cling’s general features. You will learn how to start Cling on Ubuntu, how to write a simple expression (N=5, N++) and how to define a Class for calculating body mass index. ; * - `Cling Interactive OpenGL Demo <https://www.youtube.com/watch?v=eoIuqLNvzFs>",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/docs/chapters/references.rst:4581,simpl,simple,4581,interpreter/cling/docs/chapters/references.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/docs/chapters/references.rst,1,['simpl'],['simple']
Usability,"g; a common set of fields to all the records created by the ``defm``. The name is parsed in the same special mode used by ``def``. If the name is; not included, an unspecified but globally unique name is provided. That is,; the following examples end up with different names::. defm : SomeMultiClass<...>; // A globally unique name.; defm """" : SomeMultiClass<...>; // An empty name. The ``defm`` statement can be used in a multiclass body. When this occurs,; the second variant is equivalent to::. defm NAME : SomeMultiClass<...>;. More generally, when ``defm`` occurs in a multiclass and its name does not; include a use of the implicit template argument ``NAME``, then ``NAME`` will; be prepended automatically. That is, the following are equivalent inside a; multiclass::. defm Foo : SomeMultiClass<...>;; defm NAME # Foo : SomeMultiClass<...>;. See `Examples: multiclasses and defms`_ for examples. Examples: multiclasses and defms; --------------------------------. Here is a simple example using ``multiclass`` and ``defm``. Consider a; 3-address instruction architecture whose instructions come in two formats:; ``reg = reg op reg`` and ``reg = reg op imm`` (immediate). The SPARC is an; example of such an architecture. .. code-block:: text. def ops;; def GPR;; def Imm;; class inst <int opc, string asmstr, dag operandlist>;. multiclass ri_inst <int opc, string asmstr> {; def _rr : inst<opc, !strconcat(asmstr, "" $dst, $src1, $src2""),; (ops GPR:$dst, GPR:$src1, GPR:$src2)>;; def _ri : inst<opc, !strconcat(asmstr, "" $dst, $src1, $src2""),; (ops GPR:$dst, GPR:$src1, Imm:$src2)>;; }. // Define records for each instruction in the RR and RI formats.; defm ADD : ri_inst<0b111, ""add"">;; defm SUB : ri_inst<0b101, ""sub"">;; defm MUL : ri_inst<0b100, ""mul"">;. Each use of the ``ri_inst`` multiclass defines two records, one with the; ``_rr`` suffix and one with ``_ri``. Recall that the name of the ``defm``; that uses a multiclass is prepended to the names of the records defined in; that multic",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TableGen/ProgRef.rst:39135,simpl,simple,39135,interpreter/llvm-project/llvm/docs/TableGen/ProgRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TableGen/ProgRef.rst,1,['simpl'],['simple']
Usability,"ge(-10,10);; ```. ### Triple Slider. The new **`TGTripleHSlider`** and **`TGTripleVSlider`** classes inherit; from the double slider widgets and allow easy selection of a range and a; pointer value. The pointer position can be constrained into the selected; range or can be relative to it. ![](pictures/0300021D.png). To change the slider range value press the left mouse button near to the; left/right (top/bottom) edges of the slider. To change both values; simultaneously press the mouse button near to the slider center. To; change pointer value press the mouse on the pointer and drag it to the; desired position. ``` {.cpp}; fSlider = new TGTripleHSlider(parent,100,kDoubleScaleBoth,kSLD_ID,; kHorizontalFrame);; parent->AddFrame(fSlider,new TGLayoutHints(kLHintsExpandX,5,5,5,5));; fSlider->SetConstrained(kTRUE);; fSlider->SetRange(rmin, rmax);; fSlider->SetPosition(pmin, pmax);; fSlider ->SetPointerPosition(pvalue);; ```. ### Progress Bars. A progress bar is a widget that shows that an operation is in progress; and how much time is left. It is a long rectangular bar, initially; empty, that fills with a color as a process is being performed. The; filled-in area indicates the percentage of the process that has been; completed. You should use this widget for waits exceeding `one minute`.; For a very time consuming operation it is better to break the operation; into subtasks and provide a progress bar for each of them. ![](pictures/0200021E.jpg). A progress bar may be oriented horizontally or vertically. The; horizontally oriented progress bar fills with a color from left to; right; the vertically oriented - from bottom to top. A percent complete; message provides an indication of the completed part of the process. It; is a good practice to include some descriptive text of the process to; keep users informed and entertained while they are waiting for process; completion. The picture below shows the progress bars you can create using the; classes **`TGProgressBar`**, **`TGHP",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md:87755,progress bar,progress bar,87755,documentation/users-guide/WritingGUI.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md,1,['progress bar'],['progress bar']
Usability,"gen(mtm);; const TVectorD eigenVal = eigen.GetEigenValues();; const Bool_t ok = VerifyVectorIdentity(sig,eigenVal,1,1.-e-14);; ```. ## Speed Comparisons. Speed of four matrix operations have been compared between four matrix; libraries, `GSL` `CLHEP`, `ROOT v3.10` and `ROOT v4.0`. Next figure; shows the `CPU` time for these four operations as a function of the; matrix size:. 1. `A*B` The execution time is measured for the sum of A \* Bsym,; Bsym\* A and A \* B. Notice the matrix\_size3 dependence of execution; time. `CLHEP` results are hampered by a poor implementation of symmetric; matrix multiplications. For instance, for general matrices of size; 100x100, the time is 0.015 sec. while A \* Bsym takes 0.028 sec and; Bsym\* A takes 0.059 sec. Both `GSL` and `ROOT v4.0` can be setup to use the hardware-optimized; multiplication routines of the `BLAS` libraries. It was tested on a G4; PowerPC. The improvement becomes clearly visible around sizes of (50x50); were the execution speed improvement of the Altivec processor becomes; more significant than the overhead of filling its pipe. 2. $A^{-1}$ Here, the time is measured for an in-place matrix inversion. Except for `ROOT v3.10`, the algorithms are all based on an; `LU `factorization followed by forward/back-substitution. `ROOT v3.10`; is using the slower Gaussian elimination method. The numerical accuracy; of the `CLHEP` routine is poor:. - up to 6x6 the numerical imprecise Cramer multiplication is hard-coded.; For instance, calculating `U=H*H-1`, where `H` is a (5x5) Hilbert; matrix, results in off-diagonal elements of $10^{-7}$ instead of the $10^{-13}$; using an `LU `according to `Crout`. - scaling protection is non-existent and limits are hard-coded, as a; consequence inversion of a Hilbert matrix for `sizes>(12x12)` fails. In; order to gain speed the `CLHEP` algorithm stores its permutation info of; the pivots points in a static array, making multi-threading not; possible. `GSL` uses LU decomposition without the i",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/LinearAlgebra.md:50404,clear,clearly,50404,documentation/users-guide/LinearAlgebra.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/LinearAlgebra.md,1,['clear'],['clearly']
Usability,"generated with elements |; | | | uniformly distributed |; | | | between $\alpha$ and $\beta$ |; +--------------------------+------------+---------------------------------------------+. Output **`TMatrixX`** indicates that the returned matrix is of the same; type as `A`, being **`TMatrixD`**, **`TMatrixDSym`** or; **`TMatrixDSparse`**. Next table shows miscellaneous operations for; **`TMatrixD`**. +--------------------------------+------------+---------------------------------+; | Format | Output | Description |; +--------------------------------+------------+---------------------------------+; | `A.Rank1Update(v1,v2,alpha)` | `TMatrixD` | Perform with vector `v1` and |; | | | `v2`, a rank 1 operation on the |; | | | matrix: |; | | | $A = A + \alpha.\nu.\nu2^T$ |; +--------------------------------+------------+---------------------------------+. ## Matrix Views. Another way to access matrix elements is through the matrix-view; classes, **`TMatrixDRow`**, **`TMatrixDColumn`**, **`TMatrixDDiag`** and; **`TMatrixDSub`** (each has also a const version which is obtained by; simply appending const to the class name). These classes create a; reference to the underlying matrix, so no memory management is involved.; The next table shows how the classes access different parts of the; matrix:. +--------------------------------+-----------------------------------------+; | class | view |; +--------------------------------+-----------------------------------------+; | | $$ \left(\begin{array}{ccccc} |; | | x_{00} & & & & x_{0n} \\ |; | | & & & & \\ |; | `TMatrixDRow const(X,i)` | x_{i0} & ... & x_{ij} & ... & x_{in} \\ |; | `TMatrixDRow(X,i)` | & & & & \\ |; | | x_{n0} & & & & x_{nn} |; | | \end{array}\right)$$ |; +--------------------------------+-----------------------------------------+; | | $$ \left(\begin{array}{ccccc} |; | | x_{00} & & x_{0j} & & x_{0n} \\ |; | | & & ... & & \\ |; | `TMatrixDColumn const(X,j)` | & & x_{ij} & & \\ |; | `TMatrixDColumn(X,j)` | & & ... & & \\ ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/LinearAlgebra.md:25052,simpl,simply,25052,documentation/users-guide/LinearAlgebra.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/LinearAlgebra.md,1,['simpl'],['simply']
Usability,"github.com/mozilla/dxr>`_; ""DXR is a source code cross-reference tool that uses static analysis; data collected by instrumented compilers."". `<https://github.com/eschulte/clang-mutate>`_; ""This tool performs a number of operations on C-language source files."". `<https://github.com/gmarpons/Crisp>`_; ""A coding rule validation add-on for LLVM/clang. Crisp rules are written; in Prolog. A high-level declarative DSL to easily write new rules is under; development. It will be called CRISP, an acronym for *Coding Rules in; Sugared Prolog*."". `<https://github.com/drothlis/clang-ctags>`_; ""Generate tag file for C++ source code."". `<https://github.com/exclipy/clang_indexer>`_; ""This is an indexer for C and C++ based on the libclang library."". `<https://github.com/holtgrewe/linty>`_; ""Linty - C/C++ Style Checking with Python & libclang."". `<https://github.com/axw/cmonster>`_; ""cmonster is a Python wrapper for the Clang C++ parser."". `<https://github.com/rizsotto/Constantine>`_; ""Constantine is a toy project to learn how to write clang plugin.; Implements pseudo const analysis. Generates warnings about variables,; which were declared without const qualifier."". `<https://github.com/jessevdk/cldoc>`_; ""cldoc is a Clang based documentation generator for C and C++.; cldoc tries to solve the issue of writing C/C++ software documentation; with a modern, non-intrusive and robust approach."". `<https://github.com/AlexDenisov/ToyClangPlugin>`_; ""The simplest Clang plugin implementing a semantic check for Objective-C.; This example shows how to use the ``DiagnosticsEngine`` (emit warnings,; errors, fixit hints). See also `<http://l.rw.rw/clang_plugin>`_ for; step-by-step instructions."". `<https://phabricator.kde.org/source/clazy>`_; ""clazy is a compiler plugin which allows clang to understand Qt semantics.; You get more than 50 Qt related compiler warnings, ranging from unneeded; memory allocations to misusage of API, including fix-its for automatic; refactoring."". `<https://gerrit.libreo",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ExternalClangExamples.rst:2850,learn,learn,2850,interpreter/llvm-project/clang/docs/ExternalClangExamples.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ExternalClangExamples.rst,1,['learn'],['learn']
Usability,"gle unsigned 1-byte operand that represents an index; I. A copy of the stack entry with index I is pushed onto the stack. 4. ``DW_OP_over``. ``DW_OP_over`` pushes a copy of the entry with index 1. *This is equivalent to a* ``DW_OP_pick 1`` *operation.*. 5. ``DW_OP_swap``. ``DW_OP_swap`` swaps the top two stack entries. The entry at the top of the; stack becomes the second stack entry, and the second stack entry becomes the; top of the stack. 6. ``DW_OP_rot``. ``DW_OP_rot`` rotates the first three stack entries. The entry at the top of; the stack becomes the third stack entry, the second entry becomes the top of; the stack, and the third entry becomes the second entry. *Examples illustrating many of these stack operations are found in Appendix; D.1.2 on page 289.*. .. _amdgpu-dwarf-control-flow-operations:. A.2.5.4.2 Control Flow Operations; #################################. .. note::. This section replaces DWARF Version 5 section 2.5.1.5. The following operations provide simple control of the flow of a DWARF operation; expression. 1. ``DW_OP_nop``. ``DW_OP_nop`` is a place holder. It has no effect on the DWARF stack; entries. 2. ``DW_OP_le``, ``DW_OP_ge``, ``DW_OP_eq``, ``DW_OP_lt``, ``DW_OP_gt``,; ``DW_OP_ne``. .. note::. The same as in DWARF Version 5 section 2.5.1.5. 3. ``DW_OP_skip``. ``DW_OP_skip`` is an unconditional branch. Its single operand is a 2-byte; signed integer constant. The 2-byte constant is the number of bytes of the; DWARF expression to skip forward or backward from the current operation,; beginning after the 2-byte constant. If the updated position is at one past the end of the last operation, then; the operation expression evaluation is complete. Otherwise, the DWARF expression is ill-formed if the updated operation; position is not in the range of the first to last operation inclusive, or; not at the start of an operation. 4. ``DW_OP_bra``. ``DW_OP_bra`` is a conditional branch. Its single operand is a 2-byte signed; integer constant. This op",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst:70639,simpl,simple,70639,interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,1,['simpl'],['simple']
Usability,"gma = 1 by calling; `gRandom->Rannor(px,py)`, and calculate` pz`. Then we call the; `TTree::Fill()` method. The call `t1.Fill()` fills all branches in the; tree because we have already organized the tree into branches and told; each branch where to get the value from. After this script is executed; we have a ROOT file called `tree1.root` with a tree called `t1`. There; is a possibility to fill branches one by one using the method; `TBranch::Fill()`. In this case you do not need to call `TTree::Fill()`; method. The entries can be set by `TTree::SetEntries(Double_t n)`.; Calling this method makes sense only if the number of existing entries; is null. ### Viewing the Tree. ![The tree1.root file and its tree in the browser and a leaf histogram](pictures/030000FC.png). In the right panel of the ROOT object browse are the branches: `ev`,; `px`, `py`, `pz`, and `random`. Note that these are shown as leaves; because they are ""end"" branches with only one leaf. To histogram a leaf,; we can simply double click on it in the browser. This is how the tree; `t1` looks in the Tree Viewer. Here we can add a cut and add other; operations for histogramming the leaves. See ""The Tree Viewer"". For; example, we can plot a two dimensional histogram. ![The tree viewer](pictures/030000FE.png). ### Reading the Tree. The `tree1r` function shows how to read the tree and access each entry; and each leaf. We first define the variables to hold the read values. ``` {.cpp}; Float_t px, py, pz;; ```. Then we tell the tree to populate these variables when reading an entry.; We do this with the method `TTree::SetBranchAddress`. The first; parameter is the branch name, and the second is the address of the; variable where the branch data is to be placed. In this example, the; branch name is `px`. This name was given when the tree was written (see; `tree1w`). The second parameter is the address of the variable `px`. ``` {.cpp}; t1->SetBranchAddress(""px"",&px);; ```. #### GetEntry. Once the branches have bee",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:37642,simpl,simply,37642,documentation/users-guide/Trees.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md,1,['simpl'],['simply']
Usability,"gn or zero extended. If spilled, we should be able; to spill these to a 8-bit or 16-bit stack slot, zero or sign extending as part; of the reload. Doing this reduces the size of the stack frame (important for thumb etc), and; also increases the likelihood that we will be able to reload multiple values; from the stack with a single load. //===---------------------------------------------------------------------===//. The constant island pass is in good shape. Some cleanups might be desirable,; but there is unlikely to be much improvement in the generated code. 1. There may be some advantage to trying to be smarter about the initial; placement, rather than putting everything at the end. 2. There might be some compile-time efficiency to be had by representing; consecutive islands as a single block rather than multiple blocks. 3. Use a priority queue to sort constant pool users in inverse order of; position so we always process the one closed to the end of functions; first. This may simply CreateNewWater. //===---------------------------------------------------------------------===//. Eliminate copysign custom expansion. We are still generating crappy code with; default expansion + if-conversion. //===---------------------------------------------------------------------===//. Eliminate one instruction from:. define i32 @_Z6slow4bii(i32 %x, i32 %y) {; %tmp = icmp sgt i32 %x, %y; %retval = select i1 %tmp, i32 %x, i32 %y; ret i32 %retval; }. __Z6slow4bii:; cmp r0, r1; movgt r1, r0; mov r0, r1; bx lr; =>. __Z6slow4bii:; cmp r0, r1; movle r0, r1; bx lr. //===---------------------------------------------------------------------===//. Implement long long ""X-3"" with instructions that fold the immediate in. These; were disabled due to badness with the ARM carry flag on subtracts. //===---------------------------------------------------------------------===//. More load / store optimizations:; 1) Better representation for block transfer? This is from Olden/power:. 	fldd d0, [r4];",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/README.txt:1933,simpl,simply,1933,interpreter/llvm-project/llvm/lib/Target/ARM/README.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/README.txt,1,['simpl'],['simply']
Usability,"gname !getdagop !gt !head !if; : !interleave !isa !le !listconcat !listremove; : !listsplat !logtwo !lt !mul !ne; : !not !or !range !repr !setdagarg; : !setdagname !setdagop !shl !size !sra; : !srl !strconcat !sub !subst !substr; : !tail !tolower !toupper !xor. The ``!cond`` operator has a slightly different; syntax compared to other bang operators, so it is defined separately:. .. productionlist::; CondOperator: !cond. See `Appendix A: Bang Operators`_ for a description of each bang operator. Include files; -------------. TableGen has an include mechanism. The content of the included file; lexically replaces the ``include`` directive and is then parsed as if it was; originally in the main file. .. productionlist::; IncludeDirective: ""include"" `TokString`. Portions of the main file and included files can be conditionalized using; preprocessor directives. .. productionlist::; PreprocessorDirective: ""#define"" | ""#ifdef"" | ""#ifndef"". Types; =====. The TableGen language is statically typed, using a simple but complete type; system. Types are used to check for errors, to perform implicit conversions,; and to help interface designers constrain the allowed input. Every value is; required to have an associated type. TableGen supports a mixture of low-level types (e.g., ``bit``) and; high-level types (e.g., ``dag``). This flexibility allows you to describe a; wide range of records conveniently and compactly. .. productionlist::; Type: ""bit"" | ""int"" | ""string"" | ""dag""; :| ""bits"" ""<"" `TokInteger` "">""; :| ""list"" ""<"" `Type` "">""; :| `ClassID`; ClassID: `TokIdentifier`. ``bit``; A ``bit`` is a boolean value that can be 0 or 1. ``int``; The ``int`` type represents a simple 64-bit integer value, such as 5 or; -42. ``string``; The ``string`` type represents an ordered sequence of characters of arbitrary; length. ``bits<``\ *n*\ ``>``; The ``bits`` type is a fixed-sized integer of arbitrary length *n* that; is treated as separate bits. These bits can be accessed individually.; A field ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TableGen/ProgRef.rst:10228,simpl,simple,10228,interpreter/llvm-project/llvm/docs/TableGen/ProgRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TableGen/ProgRef.rst,1,['simpl'],['simple']
Usability,"gnment exists simple trivial needs_implicit; `-Destructor simple irrelevant trivial needs_implicit. We'd like to get the members too, so, we use ``ImportDefinition`` to copy the whole definition of ``MyClass`` into the ""to"" context.; Then we dump the AST again. .. code-block:: cpp. if (llvm::Error Err = Importer.ImportDefinition(From)) {; llvm::errs() << ""ERROR: "" << Err << ""\n"";; consumeError(std::move(Err));; return 1;; }; llvm::errs() << ""Imported definition.\n"";; Imported->getTranslationUnitDecl()->dump();. This time the AST is going to contain the members too. .. code-block:: bash. TranslationUnitDecl 0x68b9a8 <<invalid sloc>> <invalid sloc>; `-CXXRecordDecl 0x6c7e30 <line:2:7, col:13> col:13 class MyClass definition; |-DefinitionData pass_in_registers standard_layout trivially_copyable trivial literal; | |-DefaultConstructor exists trivial needs_implicit; | |-CopyConstructor simple trivial has_const_param needs_implicit implicit_has_const_param; | |-MoveConstructor exists simple trivial needs_implicit; | |-CopyAssignment trivial has_const_param needs_implicit implicit_has_const_param; | |-MoveAssignment exists simple trivial needs_implicit; | `-Destructor simple irrelevant trivial needs_implicit; |-CXXRecordDecl 0x6c7f48 <col:7, col:13> col:13 implicit class MyClass; |-FieldDecl 0x6c7ff0 <line:3:9, col:13> col:13 m1 'int'; `-FieldDecl 0x6c8058 <line:4:9, col:13> col:13 m2 'int'. We can spare the call for ``ImportDefinition`` if we set up the importer to do a ""normal"" (not minimal) import. .. code-block:: cpp. ASTImporter Importer( .... /*MinimalImport=*/false);. With **normal import**, all dependent declarations are imported normally.; However, with minimal import, the dependent Decls are imported without definition, and we have to import their definition for each if we later need that. Putting this all together here is how the source of the tool looks like:. .. code-block:: cpp. #include ""clang/AST/ASTImporter.h""; #include ""clang/ASTMatchers/ASTMatchFinder.h""",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTImporter.rst:7825,simpl,simple,7825,interpreter/llvm-project/clang/docs/LibASTImporter.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTImporter.rst,4,['simpl'],['simple']
Usability,"gram to adjust; the scale of the function. In case of extended p.d.f.s, the adjustment is made with the expected; number of events, rather than the observed number of events. Tutorial macro rf602_chi2fit.C has been updated to use this new interface. Chi-squared fits to X-Y datasets now possible; In addition to the ability to perform chi-squared fits to histograms it is now also possible; to perform chi-squared fits to unbinned datasets containing a series of X and Y values; with associated errors on Y and optionally on X. These 'X-Y' chi-squared fits are interfaced through newly added method; RooAbsReal::chi2FitTo(const RooDataSet&,...). By default the event weight is; interpreted as the 'Y' value, but an YVar() argument can designate any other; dataset column as Y value. If X errors are defined, one can choose to integrate the fitted; function over the range of the X errors, rather than taking the central value by adding; an Integrate(true) argument to chi2FitTo(); Two new arguments, StoreError(const RooArgSet&) and StoreAsymError(const RooArgSet&); have been added to the RooDataSet constructor to simplify the process of storing the errors; of X and Y variables along with their values in a dataset. The newly added tutorial macro rf609_xychi2fit.C illustrates the use of all this; new functionality. Uniform interface for creation of (profile likelihoods) and chi-squared from p.d.f.s; It is now recommended to use the method RooAbsPdf::createNLL(RooAbsData&,...) to; create a likelihood from a p.d.f and a dataset rather than constructing a RooNLLVar; object directly. This is because part of the likelihood construction functionality such a using; multiple Range()s, or the inclusion for constraint terms are only available through; createNLL(). To promote the consistency of this interface, a similar method RooAbsReal::createChi2(); has been added to construct chi-squared functions of a dataset and a function or p.d.f. Along the same lines, it is recommended to use RooAbsRe",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v524/index.html:9019,simpl,simplify,9019,roofit/doc/v524/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v524/index.html,1,['simpl'],['simplify']
Usability,"h basic block is a node in the graph, and each node contains the instructions; in the block. Similarly, there also exists ``Function::viewCFGOnly()`` (does; not include the instructions), the ``MachineFunction::viewCFG()`` and; ``MachineFunction::viewCFGOnly()``, and the ``SelectionDAG::viewGraph()``; methods. Within GDB, for example, you can usually use something like ``call; DAG.viewGraph()`` to pop up a window. Alternatively, you can sprinkle calls to; these functions in your code in places you want to debug. Getting this to work requires a small amount of setup. On Unix systems; with X11, install the `graphviz <http://www.graphviz.org>`_ toolkit, and make; sure 'dot' and 'gv' are in your path. If you are running on macOS, download; and install the macOS `Graphviz program; <http://www.pixelglow.com/graphviz/>`_ and add; ``/Applications/Graphviz.app/Contents/MacOS/`` (or wherever you install it) to; your path. The programs need not be present when configuring, building or; running LLVM and can simply be installed when needed during an active debug; session. ``SelectionDAG`` has been extended to make it easier to locate *interesting*; nodes in large complex graphs. From gdb, if you ``call DAG.setGraphColor(node,; ""color"")``, then the next ``call DAG.viewGraph()`` would highlight the node in; the specified color (choices of colors can be found at `colors; <http://www.graphviz.org/doc/info/colors.html>`_.) More complex node attributes; can be provided with ``call DAG.setGraphAttrs(node, ""attributes"")`` (choices can; be found at `Graph attributes <http://www.graphviz.org/doc/info/attrs.html>`_.); If you want to restart and clear all the current graph attributes, then you can; ``call DAG.clearGraphAttrs()``. Note that graph visualization features are compiled out of Release builds to; reduce file size. This means that you need a Debug+Asserts or Release+Asserts; build to use these features. .. _datastructure:. Picking the Right Data Structure for a Task; ==============",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:53844,simpl,simply,53844,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,1,['simpl'],['simply']
Usability,"h the GCC; implementation, these attributes must appertain to the *declarator-id* in a; declaration, which means they must go either at the start of the declaration or; immediately after the name being declared. For example, this applies the GNU ``unused`` attribute to ``a`` and ``f``, and; also applies the GNU ``noreturn`` attribute to ``f``. .. code-block:: c++. [[gnu::unused]] int a, f [[gnu::noreturn]] ();. Target-Specific Extensions; ==========================. Clang supports some language features conditionally on some targets. ARM/AArch64 Language Extensions; -------------------------------. Memory Barrier Intrinsics; ^^^^^^^^^^^^^^^^^^^^^^^^^; Clang implements the ``__dmb``, ``__dsb`` and ``__isb`` intrinsics as defined; in the `Arm C Language Extensions; <https://github.com/ARM-software/acle/releases>`_.; Note that these intrinsics are implemented as motion barriers that block; reordering of memory accesses and side effect instructions. Other instructions; like simple arithmetic may be reordered around the intrinsic. If you expect to; have no reordering at all, use inline assembly instead. X86/X86-64 Language Extensions; ------------------------------. The X86 backend has these language extensions:. Memory references to specified segments; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Annotating a pointer with address space #256 causes it to be code generated; relative to the X86 GS segment register, address space #257 causes it to be; relative to the X86 FS segment, and address space #258 causes it to be; relative to the X86 SS segment. Note that this is a very very low-level; feature that should only be used if you know what you're doing (for example in; an OS kernel). Here is an example:. .. code-block:: c++. #define GS_RELATIVE __attribute__((address_space(256))); int foo(int GS_RELATIVE *P) {; return *P;; }. Which compiles to (on X86-32):. .. code-block:: gas. _foo:; movl 4(%esp), %eax; movl %gs:(%eax), %eax; ret. You can also use the GCC compatibility macr",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:154949,simpl,simple,154949,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst,1,['simpl'],['simple']
Usability,"h the ``<<`` operator: the first argument; becomes ``%0``, the second becomes ``%1``, etc. The diagnostic interface; allows you to specify arguments of many different types, including ``int`` and; ``unsigned`` for integer arguments, ``const char*`` and ``std::string`` for; string arguments, ``DeclarationName`` and ``const IdentifierInfo *`` for names,; ``QualType`` for types, etc. ``SourceRange``\ s are also specified with the; ``<<`` operator, but do not have a specific ordering requirement. As you can see, adding and producing a diagnostic is pretty straightforward.; The hard part is deciding exactly what you need to say to help the user,; picking a suitable wording, and providing the information needed to format it; correctly. The good news is that the call site that issues a diagnostic should; be completely independent of how the diagnostic is formatted and in what; language it is rendered. Fix-It Hints; ^^^^^^^^^^^^. In some cases, the front end emits diagnostics when it is clear that some small; change to the source code would fix the problem. For example, a missing; semicolon at the end of a statement or a use of deprecated syntax that is; easily rewritten into a more modern form. Clang tries very hard to emit the; diagnostic and recover gracefully in these and other cases. However, for these cases where the fix is obvious, the diagnostic can be; annotated with a hint (referred to as a ""fix-it hint"") that describes how to; change the code referenced by the diagnostic to fix the problem. For example,; it might add the missing semicolon at the end of the statement or rewrite the; use of a deprecated construct into something more palatable. Here is one such; example from the C++ front end, where we warn about the right-shift operator; changing meaning from C++98 to C++11:. .. code-block:: text. test.cpp:3:7: warning: use of right-shift operator ('>>') in template argument; will require parentheses in C++11; A<100 >> 2> *a;; ^; ( ). Here, the fix-it hint is sugge",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:17919,clear,clear,17919,interpreter/llvm-project/clang/docs/InternalsManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst,1,['clear'],['clear']
Usability,"h. The first diagram shows a system without folders. The objects have; pointers to each other to access each other's data. Pointers are an; efficient way to share data between classes. However, a direct pointer; creates a direct coupling between classes. This design can become a very; tangled web of dependencies in a system with a large number of classes. ![](pictures/020000E2.jpg). In the second diagram, a reference to the data is in the folder and the; consumers refer to the folder rather than each other to access the data.; The naming and search service provided by the ROOT folders hierarchy; provides an alternative. It loosely couples the classes and greatly; enhances I/O operations. In this way, folders separate the data from the; algorithms and greatly improve the modularity of an application by; minimizing the class dependencies. ![](pictures/020000E3.jpg). In addition, the folder hierarchy creates a picture of the data; organization. This is useful when discussing data design issues or when; learning the data organization. The example below illustrates this; point. ## How to Use Folders. Using folders means to build a hierarchy of folders, posting the; reference to the data in the folder by the producer, and creating a; reference to the folder by the user. ### Creating a Folder Hierarchy. To create a folder hierarchy you add the top folder of your hierarchy to; `//root`. Then you add a folder to an existing folder with the; **`TFolder::AddFolder`** method. This method takes two parameters: the; name and title of the folder to be added. It returns a pointer of the; newly created folder. The code below creates the folder hierarchy shown in the browser. In; this macro, the folder is also added to the list of browsable. This way,; it is visible in the browser on the top level. ``` {.cpp}; {; // Add the top folder of my hierary to //root; TFolder *aliroot=gROOT->GetRootFolder()->AddFolder(""aliroot"",; ""aliroot top level folders"");; // Add the hierarchy to the list ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FoldersTasks.md:2132,learn,learning,2132,documentation/users-guide/FoldersTasks.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FoldersTasks.md,1,['learn'],['learning']
Usability,"h`` from the compiler-rt ``xray`` directory. The important API; functions we list below:. - ``__xray_log_register_mode(...)``: Register a logging implementation against; a string Mode identifier. The implementation is an instance of; ``XRayLogImpl`` defined in ``xray/xray_log_interface.h``.; - ``__xray_log_select_mode(...)``: Select the mode to install, associated with; a string Mode identifier. Only implementations registered with; ``__xray_log_register_mode(...)`` can be chosen with this function.; - ``__xray_log_init_mode(...)``: This function allows for initializing and; re-initializing an installed logging implementation. See; ``xray/xray_log_interface.h`` for details, part of the XRay compiler-rt; installation. Once a logging implementation has been initialized, it can be ""stopped"" by; finalizing the implementation through the ``__xray_log_finalize()`` function.; The finalization routine is the opposite of the initialization. When finalized,; an implementation's data can be cleared out through the; ``__xray_log_flushLog()`` function. For implementations that support in-memory; processing, these should register an iterator function to provide access to the; data via the ``__xray_log_set_buffer_iterator(...)`` which allows code calling; the ``__xray_log_process_buffers(...)`` function to deal with the data in; memory. All of this is better explained in the ``xray/xray_log_interface.h`` header. Basic Mode; ----------. XRay supports a basic logging mode which will trace the application's; execution, and periodically append to a single log. This mode can be; installed/enabled by setting ``xray_mode=xray-basic`` in the ``XRAY_OPTIONS``; environment variable. Combined with ``patch_premain=true`` this can allow for; tracing applications from start to end. Like all the other modes installed through ``__xray_log_select_mode(...)``, the; implementation can be configured through the ``__xray_log_init_mode(...)``; function, providing the mode string and the flag options. B",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/XRay.rst:7657,clear,cleared,7657,interpreter/llvm-project/llvm/docs/XRay.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/XRay.rst,1,['clear'],['cleared']
Usability,"hading according to channels counts-; // PICTURE2_MODE_GROUP_HEIGHT, modes of combination of; // shading according to light and to channels counts-; // PICTURE2_MODE_GROUP_LIGHT_HEIGHT); int display_mode; // spectrum display mode (points, grid, contours, bars, x_lines,; // y_lines, bars_x, bars_y, needles, surface, triangles); int z_scale; // z scale (linear, log, sqrt); int nodesx; // number of nodes in x dimension of grid; int nodesy; // number of nodes in y dimension of grid; int count_reg; // width between contours, applies only for contours display mode; int alfa; // angles of display,alfa+beta must be less or equal to 90, alpha- angle; // between base line of Canvas and left lower edge of picture picture; // base plane; int beta; // angle between base line of Canvas and right lower edge of picture base plane; int view_angle; // rotation angle of the view, it can be 0, 90, 180, 270 degrees; int levels; // # of color levels for rainbowed display modes, it does not apply for; // simple display modes algorithm group; float rainbow1_step; // determines the first component step for neighboring color; // levels, applies only for rainbowed display modes, it does not apply; // for simple display modes algorithm group; float rainbow2_step; // determines the second component step for neighboring; // color levels, applies only for rainbowed display modes, it does not; // apply for simple display modes algorithm group; float rainbow3_step; // determines the third component step for neighboring; // color levels, applies only for rainbowed display modes, it does not; // apply for simple display modes algorithm group; int color_alg; // applies only for rainbowed display modes (rgb smooth algorithm,; // rgb modulo color component, cmy smooth algorithm, cmy modulo; // color component, cie smooth algorithm, cie modulo color component,; // yiq smooth algorithm, yiq modulo color component, hsv smooth; // algorithm, hsv modulo color component, it does not apply for simple; // displa",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/spectrum/Spectrum.md:77387,simpl,simple,77387,documentation/spectrum/Spectrum.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/spectrum/Spectrum.md,1,['simpl'],['simple']
Usability,"hance CFG to model exception-handling.; Currently exceptions are treated as ""black holes"", and exception-handling; control structures are poorly modeled in order to be conservative.; This could be improved for both C++ and Objective-C exceptions.; (Difficulty: Hard). Core Analyzer Infrastructure; ; Handle unions.; Currently in the analyzer the value of a union is always regarded as; an unknown.; This problem was; previously discussed; on the mailing list, but no solution was implemented.; (Difficulty: Medium) . Floating-point support.; Currently, the analyzer treats all floating-point values as unknown.; This project would involve adding a new SVal kind; for constant floats, generalizing the constraint manager to handle floats,; and auditing existing code to make sure it doesn't; make incorrect assumptions (most notably, that X == X; is always true, since it does not hold for NaN).; (Difficulty: Medium). Improved loop execution modeling.; The analyzer simply unrolls each loop N times before; dropping the path, for a fixed constant N.; However, that results in lost coverage in cases where the loop always; executes more than N times.; A Google Summer Of Code; project; was completed to make the loop bound parameterizable,; but the widening; problem still remains open. (Difficulty: Hard). Basic function summarization support; The analyzer performs inter-procedural analysis using; either inlining or ""conservative evaluation"" (invalidating all data; passed to the function).; Often, a very simple summary; (e.g. ""this function is pure"") would be; enough to be a large improvement over conservative evaluation.; Such summaries could be obtained either syntactically,; or using a dataflow framework.; (Difficulty: Hard). Implement a dataflow flamework.; The analyzer core; implements a symbolic execution; engine, which performs checks; (use-after-free, uninitialized value read, etc.); over a single program path.; However, many useful properties; (dead code, check-after-use, etc.) ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/open_projects.html:6964,simpl,simply,6964,interpreter/llvm-project/clang/www/analyzer/open_projects.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/open_projects.html,1,['simpl'],['simply']
Usability,"hardware anti-aliasing and; shaders is possible. Prototype visualization of 5-dimensional distributions:. New option for TTree::Draw - ""gl5d"", for the case you have 5 and; more dimensional dataset.; Set of iso-surfaces created, 4-th dimension is used to select iso-level.; ""gl5d"" is now very similar to ""gliso"" option, but instead of; filling TH3 object (very primitive and rude ""density estimator""),; points are fed directly to the kernel density estimator, based on; Fast Gauss Transform. See TGL5D* classes. Limitations: 5-th dimension is not shown correctly at the moment; (lacks sofisticated algorithms, we do not have in a ROOT's math; library now). Because of this limitation, GUI is just a toy now, must; be changed. Future directions:. GUI improvements.; Support several different density estimators.; Implement regression tools. Minor changes, fixes and improvements. It is now possible to draw a histogram with the ""GLBOX"" in the; GL-viewer. New class TGLColor has been introduced to simplify color; management in TGLViewer and TGLRnrCtx. Add support for several color-sets (class TGLColorSet -; each defines colors for background, foreground, outline, markup and; for outlines of selected and highlighted objects. This also allows for independent changing of background color and; outline mode in the GL viewer - the e key now toggles between; dark / light background. New class TGLAnnotation - it allows display of; annotation-text on top of displayed objects. The annotation can be created from the TGLViewer editor; (""Guides"" tab). After that it can be dragged around the screen, edited; or closed. TGLAxisPainter - reimplemented to completely separate; label and tick-mark positioning code from the rendering itself. TGLSAViewer - when exporting an image properly take into; account image extension if it was typed by the user. TGLFont now uses the same font-naming scheme as the rest; of ROOT (had to specify font-file names before). Overlay-object management has been improved. Allow",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/doc/v524/index.html:2648,simpl,simplify,2648,graf3d/doc/v524/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/doc/v524/index.html,1,['simpl'],['simplify']
Usability,"has three integers called; `ntrack`, `nseg`, and `nvtex`. ``` {.cpp}; ""ntrack/I:nseg:nvtex""; ```. There is one more rule: when no type is given for the very first leaf,; it becomes a `float` (F). This leaf list has three floats called `temp`,; `mass`, and `px`. ``` {.cpp}; ""temp:mass:px""; ```. The symbols used for the type are:. - `C`: a character string terminated by the 0 character; - `B`: an 8 bit signed integer; - `b`: an 8 bit unsigned integer; - `S`: a 16 bit signed integer; - `s`: a 16 bit unsigned integer; - `I`: a 32 bit signed integer; - `i`: a 32 bit unsigned integer; - `L`: a 64 bit signed integer; - `l`: a 64 bit unsigned integer; - `G`: a long signed integer, stored as 64 bit; - `g`: a long unsigned integer, stored as 64 bit; - `F`: a 32 bit floating point; - `D`: a 64 bit floating point; - `O`: [the letter 'o', not a zero] a boolean (Bool\_t). The type is used for a byte count to decide how much space to allocate.; The variable written is simply the block of bytes starting at the; starting address given in the second parameter. It may or may not match; the leaf list depending on whether or not the programmer is being; careful when choosing the leaf address, name, and type. By default, a variable will be copied with the number of bytes specified; in the type descriptor symbol. However, if the type consists of two; characters, the number specifies the number of bytes to be used when; copying the variable to the output buffer. The line below describes; `ntrack` to be written as a 16-bit integer (rather than a 32-bit; integer). ``` {.cpp}; ""ntrack/I2""; ```. With this Branch method, you can also add a leaf that holds an entire; array of variables. To add an array of floats use the `f[n]` notation; when describing the leaf. ``` {.cpp}; Float_t f[10];; tree->Branch(""fBranch"",f,""f[10]/F"");; ```. You can also add an array of variable length:. ``` {.cpp}; {; TFile *f = new TFile(""peter.root"",""recreate"");; Int_t nPhot;; Float_t E[500];; TTree* nEmcPhotons = new ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:21782,simpl,simply,21782,documentation/users-guide/Trees.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md,1,['simpl'],['simply']
Usability,"hat gives public access to the generation of toy data with all the same options for the treatment of nuisance parameters, binned or unbinned data, treatment of the global observables, importance sampling, etc. This is new method particularly useful for producing the expected limit bands where one needs to generate background-only pseudo-experiments in the same way that was used for the primary limit calculation. HypoTestResult. In the process of writing the new HypoTestInverter the conventions for p-values, CLb, CLs+b, and CLs were revisited. The situation is complicated by the fact that when performing a hypothesis test for discovery the null is background-only, but when performing an inverted hypothesis test the null is a signal+background model. The new convention is that the p-value for both the null and the alternate are taken from the same tail (as specified by the test statistic). Both CLs+b and CLb are equivalent to these p-values, and the HypoTestResult has a simple switch SetBackgroundIsAlt() to specify the pairing between (null p-value, alternate p-value) and (CLb, CLs+b). HypoTestInverter, HypoTestInverterResult, HypoTestInverterPlot. These classes have been rewritten for using them with the new hypothesis test calculators. The HypoTestInverter; class can now be constructed by any generic HypoTestCalculator, and both the HybridCalculator and the new; FrequentistCalculator are supported. The HypoTestInverter class can be constructed in two ways: either passing an; HypoTestCalculator and a data set or by passing the model for the signal, for the background and a data set.; In the first case the user configure the HypoTestCalculator before passing to the HypoTestInverter.; It must be configured using as null model the signal plus background model as alternate model the background; model. Optionally the user can pass the parameter to scan, if it is not passed, the first parameter of interest of the; null model will be used. In the second case (when passing d",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v530/index.html:3155,simpl,simple,3155,roofit/doc/v530/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v530/index.html,1,['simpl'],['simple']
Usability,"he ``preferred_name`` attribute, if any.; This implies that the ``preferred_name`` wouldn't show in debugger or dumping. This is tracked in: https://github.com/llvm/llvm-project/issues/56490. Don't emit macros about module declaration; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. This is covered by P1857R3. We mention it again here since users may abuse it before we implement it. Someone may want to write code which could be compiled both by modules or non-modules.; A direct idea would be use macros like:. .. code-block:: c++. MODULE; IMPORT header_name; EXPORT_MODULE MODULE_NAME;; IMPORT header_name; EXPORT ... So this file could be triggered like a module unit or a non-module unit depending on the definition; of some macros.; However, this kind of usage is forbidden by P1857R3 but we haven't implemented P1857R3 yet.; This means that is possible to write illegal modules code now, and obviously this will stop working; once P1857R3 is implemented.; A simple suggestion would be ""Don't play macro tricks with module declarations"". This is tracked in: https://github.com/llvm/llvm-project/issues/56917. In consistent filename suffix requirement for importable module units; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. Currently, clang requires the file name of an ``importable module unit`` should end with ``.cppm``; (or ``.ccm``, ``.cxxm``, ``.c++m``). However, the behavior is inconsistent with other compilers. This is tracked in: https://github.com/llvm/llvm-project/issues/57416. clang-cl is not compatible with the standard C++ modules; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. Now we can't use the `/clang:-fmodule-file` or `/clang:-fprebuilt-module-path` to specify; the BMI within ``clang-cl.exe``. This is tracked in: https://github.com/llvm/llvm-project/issues/64118. false positive ODR violation diagnostic due to using inconsistent qualified but the same type; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst:24128,simpl,simple,24128,interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst,1,['simpl'],['simple']
Usability,"he above statements is not; expected to be the same cycle for different headers. Cycles and; their headers are tightly coupled; for different headers in the; same outermost cycle, the child cycles detected may be different.; The property relevant to the above examples is that for every; closed path, there is a cycle ``C`` that contains the path and; whose header is on that path. The diverged entry criterion must be checked for every closed path; passing through a divergent branch ``B`` and its join ``J``. Since; :ref:`every closed path passes through the header of some; cycle<cycle-closed-path-header>`, this amounts to checking every cycle; ``C`` that contains ``B`` and ``J``. When the header of ``C``; dominates the join ``J``, there can be no entry to any path from the; header to ``J``, which includes any diverged path from ``B`` to ``J``.; This is also true for any closed paths passing through the header of; an outer cycle that contains ``C``. Thus, the diverged entry criterion can be conservatively simplified; as follows:. For a divergent branch ``B`` and its join node ``J``, the nodes in a; cycle ``C`` that contains both ``B`` and ``J`` are m-converged only; if:. - ``B`` strictly dominates ``J``, or,; - The header ``H`` of ``C`` strictly dominates ``J``, or,; - Recursively, there is cycle ``C'`` inside ``C`` that satisfies the; same condition. When ``J`` is the same as ``H`` or ``B``, the trivial dominance is; insufficient to make any statement about entries to diverged paths. .. _convergence-diverged-outside:. Diverged Paths reaching a Cycle; -------------------------------. .. figure:: convergence-divergent-outside.png; :name: convergence-divergent-outside. The figure shows two cycle hierarchies with a divergent branch in; ``Entry`` instead of ``Q``. For two threads that enter the closed path; ``P -> Q -> R -> S`` at ``P`` and ``R`` respectively, the convergence; of dynamic instances generated along the path depends on whether ``P``; or ``R`` is the header. - ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ConvergenceAndUniformity.rst:25826,simpl,simplified,25826,interpreter/llvm-project/llvm/docs/ConvergenceAndUniformity.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ConvergenceAndUniformity.rst,1,['simpl'],['simplified']
Usability,"he command line option; when you declare it. `Custom parsers`_ are no problem. #. Labor Saving: The CommandLine library cuts down on the amount of grunt work; that you, the user, have to do. For example, it automatically provides a; ``-help`` option that shows the available command line options for your tool.; Additionally, it does most of the basic correctness checking for you. #. Capable: The CommandLine library can handle lots of different forms of; options often found in real programs. For example, `positional`_ arguments,; ``ls`` style `grouping`_ options (to allow processing '``ls -lad``'; naturally), ``ld`` style `prefix`_ options (to parse '``-lmalloc; -L/usr/lib``'), and interpreter style options. This document will hopefully let you jump in and start using CommandLine in your; utility quickly and painlessly. Additionally it should be a simple reference; manual to figure out how stuff works. Quick Start Guide; =================. This section of the manual runs through a simple CommandLine'ification of a; basic compiler tool. This is intended to show you how to jump into using the; CommandLine library in your own program, and show you some of the cool things it; can do. To start out, you need to include the CommandLine header file into your program:. .. code-block:: c++. #include ""llvm/Support/CommandLine.h"". Additionally, you need to add this as the first line of your main program:. .. code-block:: c++. int main(int argc, char **argv) {; cl::ParseCommandLineOptions(argc, argv);; ...; }. ... which actually parses the arguments and fills in the variable declarations. Now that you are ready to support command line arguments, we need to tell the; system which ones we want, and what type of arguments they are. The CommandLine; library uses a declarative syntax to model command line arguments with the; global variable declarations that capture the parsed values. This means that; for every command line option that you would like to support, there should be a; glob",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandLine.rst:3716,simpl,simple,3716,interpreter/llvm-project/llvm/docs/CommandLine.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandLine.rst,1,['simpl'],['simple']
Usability,"he connection to the system. - Definition of main frame (top level window). - Creation of widgets as children of the top-level frame; assign them; desired properties following the steps:. - Create a new widget passing its parent in the constructor. - Connect widget's signals with desired slots to ensure desired; functionality. - Define widget's layout and add it to the parent list of children. - Set main window attributes. - Map all sub windows. - Initialize the layout algorithm via `Resize(GetDefaultSize())`; method. - Map the main frame. - Execution of the even-processing loop. ### A Standalone Version. As usual a standalone program in C++ has to contain a main() function -; the starting point for the application execution. In this case it is; better to separate the program code creating a program header file; example2a.h with the `MyMainFrame` class declaration and; `example2a.cxx `- with the class methods implementation. To run our; simple example as a standalone application we need to create in addition; an object of class **`TApplication`**. It will make a correct; initialization of the dictionaries if it is not yet done. It will be; responsible for holding everything together and to handle all events in; the application. Its environment provides an interface to the ROOT; graphics system and by calling the `Run()` method the event loop starts; and the application program is waiting for the user action. The; application exits only if the top level window is not closed. Two header; files are used in addition: `TApplication.h` - for the class; **`TApplication`** and `TGClient.h` that is used to make initial; connection to the graphics system. The class **`TApplication`** must be; instantiated only once in any given application. The original list of; argument options can be retrieved via the `Argc()` and `Argv()` methods. Note: to have signals/slots working we need to create a dictionary for; the class `MyMainFrame`, i.e. we create the file `ex2aLinkDef.h`; contain",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md:15741,simpl,simple,15741,documentation/users-guide/WritingGUI.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md,1,['simpl'],['simple']
Usability,"he generated; // histograms we open a browser and the TreeViewer; if (gROOT->IsBatch()) return;; new TBrowser ();; t1->StartViewer();. //In the browser, click on ""ROOT Files"", then on ""tree1.root""; //You can click on the histogram icons in the right panel to draw; //them in the TreeViewer, follow the instructions in the Help.; }; ```. ## Example 2: A Tree with a C Structure. The executable script for this example is; `$ROOTSYS/tutorials/tree/tree2.C. `In this example we show:. - how to build branches from a C structure; - how to make a branch with a fixed length array; - how to make a branch with a variable length array; - how to read selective branches; - how to fill a histogram from a branch; - how to use `TTree::Draw` to show a 3D plot. A C structure (`struct`) is used to build a ROOT tree. In general we; discourage the use of C structures`,` we recommend using a class; instead. However, we do support them for legacy applications written in; C or FORTRAN. The example `struct` holds simple variables and arrays. It; maps to a Geant3 common block `/gctrak/. `This is the definition of the; common block/structure:. ``` {.cpp}; const Int_t MAXMEC = 30;; // PARAMETER (MAXMEC=30); // COMMON/GCTRAK/VECT(7),GETOT,GEKIN,VOUT(7); // + ,NMEC,LMEC(MAXMEC); // + ,NAMEC(MAXMEC),NSTEP; // + ,PID,DESTEP,DESTEL,SAFETY,SLENG; // + ,STEP,SNEXT,SFIELD,TOFG,GEKRAT,UPWGHT. typedef struct {; Float_t vect[7];; Float_t getot;; Float_t gekin;; Float_t vout[7];; Int_t nmec;; Int_t lmec[MAXMEC];; Int_t namec[MAXMEC];; Int_t nstep;; Int_t pid;; Float_t destep;; Float_t destel;; Float_t safety;; Float_t sleng;; Float_t step;; Float_t snext;; Float_t sfield;; Float_t tofg;; Float_t gekrat;; Float_t upwght;; } Gctrak_t;; ```. When using Geant3, the common block is filled by Geant3 routines at each; step and only the `TTree::Fill` method needs to be called. In this; example we emulate the Geant3 step routine with the `helixStep`; function. We also emulate the filling of the particle values. The ca",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:43464,simpl,simple,43464,documentation/users-guide/Trees.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md,1,['simpl'],['simple']
Usability,"he lower and higher axis limits are always; different.; - Protection added to avoid a Seg Fault on `.q` when `SetHistogram()`; is called on a `TGraph2D`. ### TMultiGraph. - In `TMultiGraph::Add(TMultiGraph *multigraph, Option_t *chopt)`; If `chopt` is defined all the graphs in `multigraph` will be added; with the `chopt` option. If `chopt` is undefined each graph will; be added with the option it had in `multigraph`.; - The option ""A"" in the `Draw()` was not cleaning properly the; current pad.; - Implement this option `pads`. This option is equivalent to the one in; `THStack`. It allows to draw all the `TGraphs` in separated pads. ### THStack. - By default the background of the histograms is erased before drawing the; histograms. The new option `noclear` avoid this behaviour. This is useful; when drawing a `THStack` on top of an other plot. If the patterns used to; draw the histograms in the stack are transparents, then the plot behind; will be visible. ### TH2Poly. - Implement a simple version of ""Scale"". ### TF1. - Change `TF1::Integral(double a, double b, double * params = 0, double eps = 1.E-12)` to; `TF1::Integral(doubnle a, double b, double epsrel=1.E-12)`. One should use `TF1::SetParameters` to; set the function parameters before computing the integral. - Add a new function `TF1::IntegralOneDim(Double_t a, Double_t b, Double_t epsrel, Double_t epsabs, Double_t &err)`; that returns as last argument the error in the integration. `TF1::Integral` is implemented using `Tf1::IntegralOneDim`. - The one-dim and multi-dim integral functions are now implemented using the `ROOT::Math::IntegratorOneDim` and `ROOT::Math::IntegratorMultiDim`; classes. This allows to change the integration algorithm used in `TF1` using the static methods of the classes; `ROOT::Math::IntegratorOneDimOptions` and `ROOT::Math::IntegratorMultiDimOptions`. The default algorithm used are; `ROOT::Math::IntegratorOneDimOptions::DefaultIntegratorType()` and `ROOT::Math::IntegratorMultiDimOptions::Def",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/doc/v600/index.md:12323,simpl,simple,12323,hist/doc/v600/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/doc/v600/index.md,1,['simpl'],['simple']
Usability,"he mouse. The Graphical User Interface is as a bridge between the; user and the program - it provides methods to detect the user actions; and instruments that do something as a reaction of these actions. The; user communicates with an application through the window system. The; window system reports interaction events to the application. The; application in turn forwards them to the currently active window. The; objects/widgets receive the events and react to them according to the; application functionality. ![](pictures/0200020B.jpg). The signals/slot communication mechanism is an advanced object; communication concept; it largely replaces the concept of callback; functions to handle actions in GUI's. Signals and slots are just like; any object-oriented methods implemented in C++. The objects are the; instances of classes that don't know anything about each other. They; interact and allow method calls of other object's methods. The idea is; simple: any object can send out (emit) a signal in certain situations; saying that something happened. This is all it does to communicate and; it does not know whether anything is interested in this information. On; the other side there might be an object waiting for that signal and; ready to react to it. This object disposes of special instruments to; listen to the sent out signals. To have a communication we need a; message transmission between the objects. In this simple example we use; signals and slots. The code of the method **`TGButton::Clicked()`** is:. ``` {.cpp}; virtual void Clicked() { Emit(""Clicked()""); } // *SIGNAL*; ```. I.e. any button emits the signal `Clicked()` any time someone clicks on; it. As you can see this method is virtual and could be overridden if you; need to. In our simple example we call the `Connect()` method to connect; the `Clicked()` signal of Draw button with `MyMainFrame::DoDraw():`. ``` {.cpp}; draw->Connect(""Clicked()"",""MyMainFrame"",this,""DoDraw()"");; ```. In the same way we can connect to ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md:41100,simpl,simple,41100,documentation/users-guide/WritingGUI.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md,1,['simpl'],['simple']
Usability,"he need for more design discussions),; they may ask for a revert to the original author who is responsible to revert; the patch promptly. Developers often disagree, and erring on the side of the; developer asking for more review prevents any lingering disagreement over; code in the tree. This does not indicate any fault from the patch author,; this is inherent to our post-commit review practices.; Reverting a patch ensures that design discussions can happen without blocking; other development; it's entirely possible the patch will end up being reapplied; essentially as-is once concerns have been resolved. Before being recommitted, the patch generally should undergo further review.; The community member who identified the problem is expected to engage; actively in the review. In cases where the problem is identified by a buildbot,; a community member with access to hardware similar to that on the buildbot is; expected to engage in the review. Please note: The bar for post-commit feedback is not higher than for pre-commit; feedback. Don't delay unnecessarily in providing feedback. However, if you see; something after code has been committed about which you would have commented; pre-commit (had you noticed it earlier), please feel free to provide that; feedback at any time. That having been said, if a substantial period of time has passed since the; original change was committed, it may be better to create a new patch to; address the issues than comment on the original commit. The original patch; author, for example, might no longer be an active contributor to the project. What Tools Are Used for Code Review?; ------------------------------------. Pre-commit code reviews are conducted on GitHub with Pull Requests. See; :ref:`GitHub <github-reviews>` documentation. When Is an RFC Required?; ------------------------. Some changes are too significant for just a code review. Changes that should; change the LLVM Language Reference (e.g., adding new target-independent; intrin",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodeReview.rst:3148,feedback,feedback,3148,interpreter/llvm-project/llvm/docs/CodeReview.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodeReview.rst,2,['feedback'],['feedback']
Usability,"he new flag `RSnapshotOption::fOverwriteIfExists` to `true` to force the deletion of the TTree that is; already present and the writing of a new TTree with the same name. See; [ROOT-10573](https://sft.its.cern.ch/jira/browse/ROOT-10573) for more details.; - RDataFrame changed its error handling strategy in case of unreadable input files. Instead of simply logging an error; and skipping the file, it now throws an exception if any of the input files is unreadable (this could also happen in; the middle of an event loop). See [ROOT-10549](https://sft.its.cern.ch/jira/browse/ROOT-10549) for more details.; - New analysis examples based on the recent ATLAS Open Data release ([`Higgs to two photons`](https://root.cern/doc/master/df104__HiggsToTwoPhotons_8py.html), [`W boson analysis`](https://root.cern/doc/master/df105__WBosonAnalysis_8py.html), [`Higgs to four leptons`](https://root.cern/doc/master/df106__HiggsToFourLeptons_8py.html)); - An exception is now thrown in case the size of ROOT's thread-pool changes between RDataFrame construction time and the time the event loop begins.; - Just-in-time compilation of large portions of the computation graph has been optimized, and it is now much faster. Please report any regressions you might encounter on [our issue tracker](https://sft.its.cern.ch/jira/projects/ROOT).; - `MakeRootDataFrame` is now a safe way to construct RDFs. It used to return RDFs with more limited functionality. ## PyROOT. - Introduce the `ROOT.Numba.Declare` decorator which provides a simple way to call Python callables from C++. The Python callables are; just-in-time compiled with [numba](http://numba.pydata.org/), which ensures a runtime performance similar to a C++ implementation.; The feature is targeted to improve the performance of Python based analyses, e.g., allows seamless integration into `RDataFrame` workflows.; See the tutorial [`pyroot004_NumbaDeclare.py`](https://root.cern/doc/master/pyroot004__NumbaDeclare_8py.html) for further information.; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v622/index.md:10964,simpl,simple,10964,README/ReleaseNotes/v622/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v622/index.md,1,['simpl'],['simple']
Usability,"he other branch; event not split is not expandable and we can not browse the data; members. The **`TClonesArray`** of tracks `fTracks` is also split because we set; the split level to 2. The output on the command line is the result of; `tree4->Show()`. It shows the first entry with more than 587 tracks:. ``` {.cpp}; ======> EVENT:26; event_split =; fUniqueID = 0; fBits = 50331648; fType[20] = 116 121 112 101 49 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0; fNtrack = 585; fNseg = 5834; fNvertex = 17; fFlag = 0; fTemperature = 20.044315; fEvtHdr.fEvtNum = 26; fEvtHdr.fRun = 200; fEvtHdr.fDate = 960312; fTracks = 585; fTracks.fUniqueID = 0, 0, 0, 0, 0, 0, 0, 0, 0, 0; ...; ```. ## Example 5: Import an ASCII File into a TTree. The method `TTree::ReadFile` can be used to automatic define the; structure of the **`TTree`** and read the data from a formatted ascii; file. ``` {.cpp}; Long64_t TTree::ReadFile(const char *filename,; const char *branchDescriptor); ```. Creates or simply read branches from the file named whose name is passed; in `'filename'`. ``` {.cpp}; {; gROOT->Reset();; TFile *f = new TFile(""basic2.root"",""RECREATE"");; TH1F *h1 = new TH1F(""h1"",""x distribution"",100,-4,4);; TTree *T = new TTree(""ntuple"",""data from ascii file"");; Long64_t nlines = T->ReadFile(""basic.dat"",""x:y:z"");; printf("" found %lld pointsn"",nlines);; T->Draw(""x"",""z>2"");; T->Write();; }; ```. If `branchDescriptor` is set to an empty string (the default), it is; assumed that the **`Tree`** descriptor is given in the first line of the; file with a syntax like: `A/D:Table[2]/F:Ntracks/I:astring/C`. Otherwise branchDescriptor must be specified with the above syntax.Lines; in the input file starting with ""\#"" are ignored. A **`TBranch`** object; is created for each variable in the expression. The total number of rows; read from the file is returned. ## Trees in Analysis. The methods `TTree::Draw`, `TTree::MakeClass` and; `TTree::MakeSelector` are available for data analysis using trees. The; **`TTree::Draw`** metho",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:66660,simpl,simply,66660,documentation/users-guide/Trees.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md,1,['simpl'],['simply']
Usability,"he palette axis title is correct after a histogram cloning. This; problem was mentioned [here](https://sft.its.cern.ch/jira/browse/ROOT-8007).; * `TASImage` When the first or last point of a wide line is exactly on the; window limit the line is drawn vertically or horizontally.; This problem was mentioned [here](https://sft.its.cern.ch/jira/browse/ROOT-8021); * Make sure that `TLatex` text strings containing ""\\"" (ie: rendered using `TMathText`); produce an output in PDF et SVG files.; * In TLatex, with the Cocoa backend on Mac the Angstroem characters did not render correctly.; This problem was mentioned [here](https://root.cern.ch/phpBB3/viewtopic.php?f=3&t=21321); * New version of libpng (1.2.55) as requested [here](https://sft.its.cern.ch/jira/browse/ROOT-8045).; * Enhancement of the CANDLE drawing option (implemented by Georg Troska georg.troska@tu-dortmund.de).; This option has been completely rewritten and offers a wide range of possibilities.; See the THistPainter reference guide for all the details and examples.; * Fix `TText` copy constructor as requested [here](https://sft.its.cern.ch/jira/browse/ROOT-8116).; New example to check this fix.; * SVG boxes were not correct when `x2<1` (reported [here](https://sft.its.cern.ch/jira/browse/ROOT-8126)).; * In TASImage there was no protection against graphics being drawn outside the assigned; memory. That may generate some crashes like described [here](https://sft.its.cern.ch/jira/browse/ROOT-8123).; * In TASImage: transparent rectangles did not work when png files were created in batch mode.; * In TASImage: implement transparent text for png files created in batch mode.; * TCanvas title was not set correctly when a TCanvas was read from a TFile.; (reported [here](https://root.cern.ch/phpBB3/viewtopic.php?f=3&t=21540&p=94053#p93981)).; * The text generated by `TSVG` has now the `xml:space=""preserve""` attribute in order; to be editable later on using external softwares like ""inkscape"". This improvement; was suggest",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v608/index.md:17078,guid,guide,17078,README/ReleaseNotes/v608/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v608/index.md,1,['guid'],['guide']
Usability,"he presence; of a single statement that is accompanied by a comment (assuming the comment; can't be hoisted above the ``if`` or loop statement, see below). Similarly, braces should be used when a single-statement body is complex enough; that it becomes difficult to see where the block containing the following; statement began. An ``if``/``else`` chain or a loop is considered a single; statement for this rule, and this rule applies recursively. This list is not exhaustive. For example, readability is also harmed if an; ``if``/``else`` chain does not use braced bodies for either all or none of its; members, or has complex conditionals, deep nesting, etc. The examples below; intend to provide some guidelines. Maintainability is harmed if the body of an ``if`` ends with a (directly or; indirectly) nested ``if`` statement with no ``else``. Braces on the outer ``if``; would help to avoid running into a ""dangling else"" situation. .. code-block:: c++. // Omit the braces since the body is simple and clearly associated with the; // `if`.; if (isa<FunctionDecl>(D)); handleFunctionDecl(D);; else if (isa<VarDecl>(D)); handleVarDecl(D);. // Here we document the condition itself and not the body.; if (isa<VarDecl>(D)) {; // It is necessary that we explain the situation with this surprisingly long; // comment, so it would be unclear without the braces whether the following; // statement is in the scope of the `if`.; // Because the condition is documented, we can't really hoist this; // comment that applies to the body above the `if`.; handleOtherDecl(D);; }. // Use braces on the outer `if` to avoid a potential dangling `else`; // situation.; if (isa<VarDecl>(D)) {; if (shouldProcessAttr(A)); handleAttr(A);; }. // Use braces for the `if` block to keep it uniform with the `else` block.; if (isa<FunctionDecl>(D)) {; handleFunctionDecl(D);; } else {; // In this `else` case, it is necessary that we explain the situation with; // this surprisingly long comment, so it would be unclear wit",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodingStandards.rst:62936,simpl,simple,62936,interpreter/llvm-project/llvm/docs/CodingStandards.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodingStandards.rst,2,"['clear', 'simpl']","['clearly', 'simple']"
Usability,"he process; exit. Example:. .. code-block:: console. % cat -n cov.cc; 1 #include <stdio.h>; 2 __attribute__((noinline)); 3 void foo() { printf(""foo\n""); }; 4; 5 int main(int argc, char **argv) {; 6 if (argc == 2); 7 foo();; 8 printf(""main\n"");; 9 }; % clang++ -g cov.cc -fsanitize=address -fsanitize-coverage=trace-pc-guard; % ASAN_OPTIONS=coverage=1 ./a.out; wc -c *.sancov; main; SanitizerCoverage: ./a.out.7312.sancov 2 PCs written; 24 a.out.7312.sancov; % ASAN_OPTIONS=coverage=1 ./a.out foo ; wc -c *.sancov; foo; main; SanitizerCoverage: ./a.out.7316.sancov 3 PCs written; 24 a.out.7312.sancov; 32 a.out.7316.sancov. Every time you run an executable instrumented with SanitizerCoverage; one ``*.sancov`` file is created during the process shutdown.; If the executable is dynamically linked against instrumented DSOs,; one ``*.sancov`` file will be also created for every DSO. Sancov data format; ------------------. The format of ``*.sancov`` files is very simple: the first 8 bytes is the magic,; one of ``0xC0BFFFFFFFFFFF64`` and ``0xC0BFFFFFFFFFFF32``. The last byte of the; magic defines the size of the following offsets. The rest of the data is the; offsets in the corresponding binary/DSO that were executed during the run. Sancov Tool; -----------. A simple ``sancov`` tool is provided to process coverage files.; The tool is part of LLVM project and is currently supported only on Linux.; It can handle symbolization tasks autonomously without any extra support; from the environment. You need to pass .sancov files (named; ``<module_name>.<pid>.sancov`` and paths to all corresponding binary elf files.; Sancov matches these files using module names and binaries file names. .. code-block:: console. USAGE: sancov [options] <action> (<binary file>|<.sancov file>)... Action (required); -print - Print coverage addresses; -covered-functions - Print all covered functions.; -not-covered-functions - Print all not covered functions.; -symbolize - Symbolizes the report. Options; -blocklis",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SanitizerCoverage.rst:17026,simpl,simple,17026,interpreter/llvm-project/clang/docs/SanitizerCoverage.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SanitizerCoverage.rst,1,['simpl'],['simple']
Usability,"he type that your expression; expects, STOP! Go fix semantic analysis and the AST so that you don't; need these bitcasts.; * The ``CodeGenFunction`` class has a number of helper functions to make; certain operations easy, such as generating code to produce an lvalue or; an rvalue, or to initialize a memory location with a given value. Prefer; to use these functions rather than directly writing loads and stores,; because these functions take care of some of the tricky details for you; (e.g., for exceptions).; * If your expression requires some special behavior in the event of an; exception, look at the ``push*Cleanup`` functions in ``CodeGenFunction``; to introduce a cleanup. You shouldn't have to deal with; exception-handling directly.; * Testing is extremely important in IR generation. Use ``clang -cc1; -emit-llvm`` and `FileCheck; <https://llvm.org/docs/CommandGuide/FileCheck.html>`_ to verify that you're; generating the right IR. #. Teach template instantiation how to cope with your AST node, which requires; some fairly simple code:. * Make sure that your expression's constructor properly computes the flags; for type dependence (i.e., the type your expression produces can change; from one instantiation to the next), value dependence (i.e., the constant; value your expression produces can change from one instantiation to the; next), instantiation dependence (i.e., a template parameter occurs; anywhere in your expression), and whether your expression contains a; parameter pack (for variadic templates). Often, computing these flags; just means combining the results from the various types and; subexpressions.; * Add ``TransformXXX`` and ``RebuildXXX`` functions to the ``TreeTransform``; class template in ``Sema``. ``TransformXXX`` should (recursively); transform all of the subexpressions and types within your expression,; using ``getDerived().TransformYYY``. If all of the subexpressions and; types transform without error, it will then call the ``RebuildXXX``; function",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:152408,simpl,simple,152408,interpreter/llvm-project/clang/docs/InternalsManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst,1,['simpl'],['simple']
Usability,"he; demangled AST. Why are there multiple copies of the this library in the source tree?; ---------------------------------------------------------------------. The canonical sources are in libcxxabi/src/demangle and some of the; files are copied to llvm/include/llvm/Demangle. The simple reason for; this comes from before the monorepo, and both [sub]projects need to; demangle symbols, but neither can depend on each other. * libcxxabi needs the demangler to implement __cxa_demangle, which is; part of the itanium ABI spec. * LLVM needs a copy for a bunch of places, and cannot rely on the; system's __cxa_demangle because it a) might not be available (i.e.,; on Windows), and b) may not be up-to-date on the latest language; features. The copy of the demangler in LLVM has some extra stuff that aren't; needed in libcxxabi (ie, the MSVC demangler, ItaniumPartialDemangler),; which depend on the shared generic components. Despite these; differences, we want to keep the ""core"" generic demangling library; identical between both copies to simplify development and testing. If you're working on the generic library, then do the work first in; libcxxabi, then run libcxxabi/src/demangle/cp-to-llvm.sh. This; script takes as an optional argument the path to llvm, and copies the; changes you made to libcxxabi over. Note that this script just; blindly overwrites all changes to the generic library in llvm, so be; careful. Because the core demangler needs to work in libcxxabi, everything; needs to be declared in an anonymous namespace (see; DEMANGLE_NAMESPACE_BEGIN), and you can't introduce any code that; depends on the libcxx dylib. FIXME: Now that LLVM is a monorepo, it should be possible to; de-duplicate this code, and have both LLVM and libcxxabi depend on a; shared demangler library. Testing; -------. The tests are split up between libcxxabi/test/{unit,}test_demangle.cpp, and; llvm/unittest/Demangle. The llvm directory should only get tests for stuff not; included in the core library.",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Demangle/README.txt:1471,simpl,simplify,1471,interpreter/llvm-project/llvm/include/llvm/Demangle/README.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Demangle/README.txt,1,['simpl'],['simplify']
Usability,"heckDependents()`: use `checkObservables()`; - `RooAbsArg::recursiveCheckDependents()`: use `recursiveCheckObservables()`. ## Graphics Backends. ## 2D Graphics Libraries. ## 3D Graphics Libraries. ## Geometry Libraries. ## Database Libraries. ## Networking Libraries. ## GUI Libraries. ## Montecarlo Libraries. ## PROOF Libraries. ## PyROOT. ### Typesafe `TTree::SetBranchAddress()` for array inputs. If you call `TTree::SetBranchAddress` with NumPy array or `array.array` inputs, ROOT will now check if the array type matches with the column type.; If it doesn't, `SetBranchAddress()` will return a negative status code and print an error.; Take for example this code snippet:; ```python; arr = array.array(typecode, ""d""); status = t.SetBranchAddress(""name"", arr); print(""Status = %s"" % (status, )); ```; If the branch type is also `double` (like the type of the array indicated by `""d""`), the call to `SetBranchAddress()` would succeed with status code zero.; If the type doesn't match, you now get a clear error instead of garbage values.; ```txt; Error in <TTree::SetBranchAddress>: The pointer type given ""Double_t"" (8) does not correspond to the type needed ""Float_t"" (5) by the branch: a; Status = -2; ```. ### Deprecation of `TPython::Eval()`. The `TPython::Eval()` method is deprecated and scheduled for removal in ROOT 6.36.; Its implementation was fragile, and the same functionality can be achieved with `TPython::Exec()`, using a C++ variable that is known to the ROOT interpreter for crossing over from Python to C++. Example:; ```c++; // Before, with TPython::Eval(); std::string stringVal = static_cast<const char*>(TPython::Eval(""'done'""));; std::cout << stringVal << std::endl;. // Now, with TPython::Exec(). You can set `_anyresult` to whatever std::any you want.; // It will be swapped into the return variable in the end. std::any result;; TPython::Exec(""_anyresult = ROOT.std.make_any['std::string']('done')"", &result);; std::cout << std::any_cast<std::string>(result) << std::en",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v634/index.md:7607,clear,clear,7607,README/ReleaseNotes/v634/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v634/index.md,1,['clear'],['clear']
Usability,"hen subsequent calls to ``LLVMDisasmInstruction()`` will return output strings; with the marked up annotations. Instruction Annotations; =======================. .. _contextual markups:. Contextual markups; ------------------. Annotated assembly display will supply contextual markup to help clients more; efficiently implement things like pretty printers. Most markup will be target; independent, so clients can effectively provide good display without any target; specific knowledge. Annotated assembly goes through the normal instruction printer, but optionally; includes contextual tags on portions of the instruction string. An annotation; is any '<' '>' delimited section of text(1). .. code-block:: bat. annotation: '<' tag-name tag-modifier-list ':' annotated-text '>'; tag-name: identifier; tag-modifier-list: comma delimited identifier list. The tag-name is an identifier which gives the type of the annotation. For the; first pass, this will be very simple, with memory references, registers, and; immediates having the tag names ""mem"", ""reg"", and ""imm"", respectively. The tag-modifier-list is typically additional target-specific context, such as; register class. Clients should accept and ignore any tag-names or tag-modifiers they do not; understand, allowing the annotations to grow in richness without breaking older; clients. For example, a possible annotation of an ARM load of a stack-relative location; might be annotated as:. .. code-block:: text. ldr <reg gpr:r0>, <mem regoffset:[<reg gpr:sp>, <imm:#4>]>. 1: For assembly dialects in which '<' and/or '>' are legal tokens, a literal token is escaped by following immediately with a repeat of the character. For example, a literal '<' character is output as '<<' in an annotated assembly string. C API Details; -------------. The intended consumers of this information use the C API, therefore the new C; API function for the disassembler will be added to provide an option to produce; disassembled instructions with annotations",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MarkedUpDisassembly.rst:2219,simpl,simple,2219,interpreter/llvm-project/llvm/docs/MarkedUpDisassembly.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MarkedUpDisassembly.rst,1,['simpl'],['simple']
Usability,"hen-else CFG diamond into a ``select``. Preserving the; debug locations of speculated instructions can make it seem like a condition; is true when it's not (or vice versa), which leads to a confusing; single-stepping experience. The rule for; :ref:`dropping locations<WhenToDropLocation>` should apply here. * Hoisting identical instructions which appear in several successor blocks into; a predecessor block (see ``BranchFolder::HoistCommonCodeInSuccs``). In this; case there is no single merged instruction. The rule for; :ref:`dropping locations<WhenToDropLocation>` applies. .. _WhenToDropLocation:. When to drop an instruction location; ------------------------------------. A transformation should drop debug locations if the rules for; :ref:`preserving<WhenToPreserveLocation>` and; :ref:`merging<WhenToMergeLocation>` debug locations do not apply. The API to; use is ``Instruction::dropLocation()``. The purpose of this rule is to prevent erratic or misleading single-stepping; behavior in situations in which an instruction has no clear, unambiguous; relationship to a source location. To handle an instruction without a location, the DWARF generator; defaults to allowing the last-set location after a label to cascade forward, or; to setting a line 0 location with viable scope information if no previous; location is available. See the discussion in the section about; :ref:`merging locations<WhenToMergeLocation>` for examples of when the rule for; dropping locations applies. Rules for updating debug values; ===============================. Deleting an IR-level Instruction; --------------------------------. When an ``Instruction`` is deleted, its debug uses change to ``undef``. This is; a loss of debug info: the value of one or more source variables becomes; unavailable, starting with the ``llvm.dbg.value(undef, ...)``. When there is no; way to reconstitute the value of the lost instruction, this is the best; possible outcome. However, it's often possible to do better:. * If th",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToUpdateDebugInfo.rst:5972,clear,clear,5972,interpreter/llvm-project/llvm/docs/HowToUpdateDebugInfo.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToUpdateDebugInfo.rst,1,['clear'],['clear']
Usability,"hese frame indices will be; encoded as ``Direct`` locations in the form ``BP + Offset``. LLVM may; also optimize constants by emitting them directly in the stack map,; either in the ``Offset`` of a ``Constant`` location or in the constant; pool, referred to by ``ConstantIndex`` locations. At each callsite, a ""liveout"" register list is also recorded. These; are the registers that are live across the stackmap and therefore must; be saved by the runtime. This is an important optimization when the; patchpoint intrinsic is used with a calling convention that by default; preserves most registers as callee-save. Each entry in the liveout register list contains a DWARF register; number and size in bytes. The stackmap format deliberately omits; specific subregister information. Instead the runtime must interpret; this information conservatively. For example, if the stackmap reports; one byte at ``%rax``, then the value may be in either ``%al`` or; ``%ah``. It doesn't matter in practice, because the runtime will; simply save ``%rax``. However, if the stackmap reports 16 bytes at; ``%ymm0``, then the runtime can safely optimize by saving only; ``%xmm0``. The stack map format is a contract between an LLVM SVN revision and; the runtime. It is currently experimental and may change in the short; term, but minimizing the need to update the runtime is; important. Consequently, the stack map design is motivated by; simplicity and extensibility. Compactness of the representation is; secondary because the runtime is expected to parse the data; immediately after compiling a module and encode the information in its; own format. Since the runtime controls the allocation of sections, it; can reuse the same stack map space for multiple modules. Stackmap support is currently only implemented for 64-bit; platforms. However, a 32-bit implementation should be able to use the; same format with an insignificant amount of wasted space. .. _stackmap-section:. Stack Map Section; ^^^^^^^^^^^^^^^^^. A ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/StackMaps.rst:15191,simpl,simply,15191,interpreter/llvm-project/llvm/docs/StackMaps.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/StackMaps.rst,1,['simpl'],['simply']
Usability,hing a usual deallocation function with placement new; Unknown. 2281; drafting; Consistency of aligned operator delete replacement; Not resolved. 2282; C++20; Consistency with mismatched aligned/non-over-aligned allocation/deallocation functions; Unknown. 2283; drafting; Missing complete type requirements; Not resolved. 2284; open; Sequencing of braced-init-list arguments; Not resolved. 2285; CD5; Issues with structured bindings; Unknown. 2286; NAD; Assignment evaluation order; Unknown. 2287; CD5; Pointer-interconvertibility in non-standard-layout unions; Unknown. 2288; NAD; Contradictory optionality in simple-declaration; Unknown. 2289; CD5; Uniqueness of structured binding names; Unknown. 2290; CD5; Unclear specification for overload resolution and deleted special member functions; Unknown. 2291; dup; Implicit conversion sequences in non-call contexts; Unknown. 2292; CD5; simple-template-id is ambiguous between class-name and type-name; Clang 9. 2293; CD5; Requirements for simple-template-id used as a class-name; Unknown. 2294; CD5; Dependent auto static data members; Unknown. 2295; CD5; Aggregates with deleted defaulted constructors; Unknown. 2296; open; Are default argument instantiation failures in the “immediate context”?; Not resolved. 2297; open; Unclear specification of atomic operations; Not resolved. 2298; open; Actions and expression evaluation; Not resolved. 2299; CD5; constexpr vararg functions; Unknown. 2300; CD5; Lambdas in multiple definitions; Unknown. 2301; open; Value-initialization and constexpr constructor evaluation; Not resolved. 2302; NAD; Address comparison between different member subobjects; Unknown. 2303; CD5; Partial ordering and recursive variadic inheritance; Clang 12. 2304; NAD; Incomplete type vs overload resolution; Unknown. 2305; CD5; Explicit instantiation of constexpr or inline variable template; Unknown. 2306; NAD; Nested friend templates of class templates; Unknown. 2307; CD5; Unclear definition of “equivalent to a nontype tem,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:156419,simpl,simple-template-id,156419,interpreter/llvm-project/clang/www/cxx_dr_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html,1,['simpl'],['simple-template-id']
Usability,"hints about the correlations between the axes. Avery simple technique allows to make the clusters appearing:; Instead of painting solid lines we paint dotted lines. The cluttering of; each individual line is reduced and the clusters show clearly as we can; see on the next figure. The spacing between the dots is a parameter which; can be adjusted in order to get the best results. ![Using dotted lines is a very simple method to reduce the cluttering.](pictures/para5.png). Interactivity is a very important aspect of the Parallel Coordinates plots.; To really explore the data set it is essential to act directly with the; events and the axes. For instance, changing the axes order may show clusters; which were not visible in a different order. On the next figure the axes; order has been changed interactively. We can see that many more clusters; appear and all the “random spheres” we put in the data set are now; clearly visible. Having moved the variables `u,v,w` after the variables; `x,y,z` the correlation between these two sets of variables is clear also. ![Axis order is very important to show clusters.](pictures/para6.png). To pursue further data sets exploration we have implemented the possibility; to define selections interactively. A selection is a set of ranges combined; together. Within a selection, ranges along the same axis are combined with; logical OR, and ranges on different axes with logical AND. A selection is; displayed on top of the complete data set using its own color. Only the; events fulfilling the selection criteria (ranges) are displayed. Ranges; are defined interactively using cursors, like on the first axis on the; figure. Several selections can be defined at the same time,; each selection having its own color. ![Selections are set of ranges which can be defined interactively.](pictures/para7.png). Several selections can been defined. Each cluster is now clearly visible; and the zone with crossing clusters is now understandable whereas,; without any",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:100179,clear,clear,100179,documentation/users-guide/Trees.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md,1,['clear'],['clear']
Usability,"his intrinsic is implementation-defined. It is an error to pass a ``convergencectrl`` operand bundle at a; call to this intrinsic. .. note::. The expectation is that all threads within a group that ""happen to be active; at the same time"" will execute converged dynamic instances, so that programs; can detect the maximal set of threads that can communicate efficiently within; some local region of the program. .. _convergence_uncontrolled:. Uncontrolled Convergent Operations; ==================================. Convergent operations with an explicit ``convergencectrl`` operand bundle are; called *controlled convergent operations*. All other convergent operations are; said to be *uncontrolled*. An uncontrolled convergent operation is said to have *implicit convergence; control* determined by the ``convergent`` attribute alone. The semantics of the; ``convergent`` attribute as implemented in LLVM differs from the documented; semantics. The implementation tries to follow common intuition about convergent; operations, which remains under-specified. As such, it is not possible to fully; translate implicit convergence control into explicit convergence control tokens,; and these two modes cannot be mixed in the same function. If a function contains a controlled convergent operation, then all convergent; operations in that function must either be controlled operations or calls to; the convergence control intrinsics. Inferring Tokens; ----------------. (This section is informational). Sometimes, it may be necessary to reinterpret the implicit convergence control; in terms of explicit convergence control tokens. For example, this may happen; when a function call is inlined, and either the caller or the callee contains; uncontrolled convergent operations. Some uses of uncontrolled convergent operations may need to satisfy the; following property:. For an environment-defined group of threads (such as an OpenCL workgroup or; subgroup), if one thread in the group executes a convergen",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ConvergentOperations.rst:27697,intuit,intuition,27697,interpreter/llvm-project/llvm/docs/ConvergentOperations.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ConvergentOperations.rst,1,['intuit'],['intuition']
Usability,"his may be acceptable if LLVM's coroutine support is primarily being; used for low-level lowering and inlining is expected to be applied; earlier in the pipeline. Async Lowering; --------------. In async-continuation lowering, signaled by the use of `llvm.coro.id.async`,; handling of control-flow must be handled explicitly by the frontend. In this lowering, a coroutine is assumed to take the current `async context` as; one of its arguments (the argument position is determined by; `llvm.coro.id.async`). It is used to marshal arguments and return values of the; coroutine. Therefore an async coroutine returns `void`. .. code-block:: llvm. define swiftcc void @async_coroutine(ptr %async.ctxt, ptr, ptr) {; }. Values live across a suspend point need to be stored in the coroutine frame to; be available in the continuation function. This frame is stored as a tail to the; `async context`. Every suspend point takes an `context projection function` argument which; describes how-to obtain the continuations `async context` and every suspend; point has an associated `resume function` denoted by the; `llvm.coro.async.resume` intrinsic. The coroutine is resumed by calling this; `resume function` passing the `async context` as the one of its arguments; argument. The `resume function` can restore its (the caller's) `async context`; by applying a `context projection function` that is provided by the frontend as; a parameter to the `llvm.coro.suspend.async` intrinsic. .. code-block:: c. // For example:; struct async_context {; struct async_context *caller_context;; ...; }. char *context_projection_function(struct async_context *callee_ctxt) {; return callee_ctxt->caller_context;; }. .. code-block:: llvm. %resume_func_ptr = call ptr @llvm.coro.async.resume(); call {ptr, ptr, ptr} (ptr, ptr, ...) @llvm.coro.suspend.async(; ptr %resume_func_ptr,; ptr %context_projection_function. The frontend should provide a `async function pointer` struct associated with; each async coroutine by `llvm.co",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst:8555,resume,resume,8555,interpreter/llvm-project/llvm/docs/Coroutines.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst,1,['resume'],['resume']
Usability,"his pass performs several transformations to transform natural loops into a; simpler form, which makes subsequent analyses and transformations simpler and; more effective. A summary of it can be found in; :ref:`Loop Terminology, Loop Simplify Form <loop-terminology-loop-simplify>`. Loop pre-header insertion guarantees that there is a single, non-critical entry; edge from outside of the loop to the loop header. This simplifies a number of; analyses and transformations, such as :ref:`LICM <passes-licm>`. Loop exit-block insertion guarantees that all exit blocks from the loop (blocks; which are outside of the loop that have predecessors inside of the loop) only; have predecessors from inside of the loop (and are thus dominated by the loop; header). This simplifies transformations such as store-sinking that are built; into LICM. This pass also guarantees that loops will have exactly one backedge. Note that the :ref:`simplifycfg <passes-simplifycfg>` pass will clean up blocks; which are split out but end up being unnecessary, so usage of this pass should; not pessimize generated code. This pass obviously modifies the CFG, but updates loop information and; dominator information. ``loop-unroll``: Unroll loops; -----------------------------. This pass implements a simple loop unroller. It works best when loops have; been canonicalized by the :ref:`indvars <passes-indvars>` pass, allowing it to; determine the trip counts of loops easily. ``loop-unroll-and-jam``: Unroll and Jam loops; ---------------------------------------------. This pass implements a simple unroll and jam classical loop optimisation pass.; It transforms loop from:. .. code-block:: c++. for i.. i+= 1 for i.. i+= 4; for j.. for j..; code(i, j) code(i, j); code(i+1, j); code(i+2, j); code(i+3, j); remainder loop. Which can be seen as unrolling the outer loop and ""jamming"" (fusing) the inner; loops into one. When variables or loads can be shared in the new inner loop, this; can lead to significant performance i",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Passes.rst:27621,simpl,simplifycfg,27621,interpreter/llvm-project/llvm/docs/Passes.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Passes.rst,2,['simpl'],['simplifycfg']
Usability,"his pattern is intended for use by classes which hide locking; details behind an abstract interface. For example:. .. code-block:: c++. template <class T>; class CAPABILITY(""mutex"") Container {; private:; Mutex mu;; T* data;. public:; // Hide mu from public interface.; void Lock() ACQUIRE() { mu.Lock(); }; void Unlock() RELEASE() { mu.Unlock(); }. T& getElem(int i) { return data[i]; }; };. void test() {; Container<int> c;; c.Lock();; int i = c.getElem(0);; c.Unlock();; }. EXCLUDES(...); -------------. *Previously*: ``LOCKS_EXCLUDED``. ``EXCLUDES`` is an attribute on functions or methods, which declares that; the caller must *not* hold the given capabilities. This annotation is; used to prevent deadlock. Many mutex implementations are not re-entrant, so; deadlock can occur if the function acquires the mutex a second time. .. code-block:: c++. Mutex mu;; int a GUARDED_BY(mu);. void clear() EXCLUDES(mu) {; mu.Lock();; a = 0;; mu.Unlock();; }. void reset() {; mu.Lock();; clear(); // Warning! Caller cannot hold 'mu'.; mu.Unlock();; }. Unlike ``REQUIRES``, ``EXCLUDES`` is optional. The analysis will not issue a; warning if the attribute is missing, which can lead to false negatives in some; cases. This issue is discussed further in :ref:`negative`. NO_THREAD_SAFETY_ANALYSIS; -------------------------. ``NO_THREAD_SAFETY_ANALYSIS`` is an attribute on functions or methods, which; turns off thread safety checking for that method. It provides an escape hatch; for functions which are either (1) deliberately thread-unsafe, or (2) are; thread-safe, but too complicated for the analysis to understand. Reasons for; (2) will be described in the :ref:`limitations`, below. .. code-block:: c++. class Counter {; Mutex mu;; int a GUARDED_BY(mu);. void unsafeIncrement() NO_THREAD_SAFETY_ANALYSIS { a++; }; };. Unlike the other attributes, NO_THREAD_SAFETY_ANALYSIS is not part of the; interface of a function, and should thus be placed on the function definition; (in the ``.cc`` or ``.cpp`` ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst:10582,clear,clear,10582,interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst,1,['clear'],['clear']
Usability,"hoose their color. The simplest way is to pick colors in the current active color; palette. Palette coloring for histogram is activated thanks to the options `PFC`; (Palette Fill Color), `PLC` (Palette Line Color) and `AMC` (Palette Marker Color).; When one of these options is given to `TH1::Draw` the histogram get its color; from the current color palette defined by `gStyle->SetPalette(…)`. The color; is determined according to the number of objects having palette coloring in; the current pad.; - The line width and line style can be change on 2d histograms painted with; option `ARR`.; - When the angle of a TGraphPolar was not in radian, the error bars were misplaced.; The problem was reported [here](https://sft.its.cern.ch/jira/browse/ROOT-8476).; - In `TASimage::DrawLineInternal` the case of a line with 0 pixel along X and 0; pixel along Y was not treated properly. An horizontal line was drawn instead.; - In `TGraphPainter::PaintGrapHist`: Decouple the `P` option (histogram drawn with; a simple polymarker) from the `L` option (Histogram drawn as a simple polyline). This; improved (in some cases some extra markers were drawn) and simplified the code.; - Candle plot improvements:; * Rearragement of TCandle-code - split into calculate and paint; * Implementation for a ""raw-data candle"" inside TCandle - to be used from TTreeViewer in the future; * Implementation of 1D histograms along each candle (left, right and violin) - to be used for violin-charts; * Implementation of a zero indicator line for TCandle - to be used for violin-charts; * Reimplementation if THistPainter draw option VIOLIN; * Implementations of presets and individual options for VIOLIN-charts; * Implementation of VIOLIN-charts in THStack - can be combined with CANDLE; * Update of the docs (THistPainter and THStack); * New tutorials; - In various places in TGraph the underlying histogram was deleted when the graph; range should be recomputed. This has the side effect that some graph parameters; (like t",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v610/index.md:10047,simpl,simple,10047,README/ReleaseNotes/v610/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v610/index.md,2,['simpl'],['simple']
Usability,"hose values to human-readable form. Instead, logging text uses the; markup format defined here to identify pieces of information that should be; converted to human-readable form after the fact. As with other markup formats,; the expectation is that most of the text will be displayed as is, while the; markup elements will be replaced with expanded text, or converted into active UI; elements, that present more details in symbolic form. This means there is no need for symbol tables, DWARF debugging sections, or; similar information to be directly accessible at runtime. There is also no need; at runtime for any logic intended to compute human-readable presentation of; information, such as C++ symbol demangling. Instead, logging must include markup; elements that give the contextual information necessary to make sense of the raw; data, such as memory layout details. This format identifies markup elements with a syntax that is both simple and; distinctive. It's simple enough to be matched and parsed with straightforward; code. It's distinctive enough that character sequences that look like the start; or end of a markup element should rarely if ever appear incidentally in logging; text. It's specifically intended not to require sanitizing plain text, such as; the HTML/XML requirement to replace ``<`` with ``&lt;`` and the like. :doc:`llvm-symbolizer <CommandGuide/llvm-symbolizer>` includes a symbolizing; filter via its ``--filter-markup`` option. Also, LLVM utilites emit stack; traces as markup when the ``LLVM_ENABLE_SYMBOLIZER_MARKUP`` environment; variable is set. Scope and assumptions; =====================. A symbolizing filter implementation will be independent both of the target; operating system and machine architecture where the logs are generated and of; the host operating system and machine architecture where the filter runs. This format assumes that the symbolizing filter processes intact whole lines. If; long lines might be split during some stage of a logging ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SymbolizerMarkupFormat.rst:1350,simpl,simple,1350,interpreter/llvm-project/llvm/docs/SymbolizerMarkupFormat.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SymbolizerMarkupFormat.rst,1,['simpl'],['simple']
Usability,"hould be:; #. A proposal for removal / deactivation should be made to the Discourse forums ; (under the appropriate category), with a clear; statement of the maintenance costs imposed and the alternatives, if; applicable.; #. There must be enough consensus on the list that removal is warranted, and no; pending proposals to fix the situation from a sub-community.; #. An announcement for removal must be made on the same lists, with ample time; for downstream users to take action on their local infrastructure. The time; will depend on what is being removed. #. If a script or documents are to be removed, they can always be pulled; from previous revision, and can be removed within days.; #. if a whole target is removed, we need to first announce publicly, and; potentially mark as deprecated in one release, only to remove on the; next release.; #. Everything else will fall in between those two extremes.; #. The removal is made by either the proposer or the sub-community that used to; maintain it, with replacements and arrangements made atomically on the same; commit. If a proposal for removal is delayed by the promise a sub-community will take; care of the code affected, the sub-community will have a time to fix all the; issues (depending on each case, as above), and if those are not fixed in time, a; subsequent request for removal should be made and the community may elect to; eject the component without further attempts to fix. Reinstatement; -------------. If a component is removed from LLVM, it may, at a later date, request inclusion; of a modified version, with evidence that all of the issues were fixed and that; there is a clear sub-community that will maintain it. By consequence, the pressure on such sub-community will be higher to keep; overall maintenance costs to a minimum and will need to show steps to mitigate; all of the issues that were listed as reasons for its original removal. Failing on those again, will lead to become a candidate for removal yet again. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SupportPolicy.rst:11058,clear,clear,11058,interpreter/llvm-project/llvm/docs/SupportPolicy.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SupportPolicy.rst,1,['clear'],['clear']
Usability,"hout complying; with the conditions of Sections 4(a), 4(b) and 4(d) of the License. In addition, if you combine or link compiled forms of this Software with; software that is licensed under the GPLv2 (""Combined Software"") and if a; court of competent jurisdiction determines that the patent provision (Section; 3), the indemnity provision (Section 9) or other Section of the License; conflicts with the conditions of the GPLv2, you may retroactively and; prospectively choose to deem waived or otherwise exclude such Section(s) of; the License, but only in their entirety and only with respect to the Combined; Software. ==============================================================================; Software from third parties included in the LLVM Project:; ==============================================================================; The LLVM Project contains third party software which is under different license; terms. All such code will be identified clearly using at least one of two; mechanisms:; 1) It will be in a separate directory tree with its own `LICENSE.txt` or; `LICENSE` file at the top containing the specific license and restrictions; which apply to that software, or; 2) It will contain specific license and restriction terms at the top of every; file. ==============================================================================; Legacy LLVM License (https://llvm.org/docs/DeveloperPolicy.html#legacy):; ==============================================================================; University of Illinois/NCSA; Open Source License. Copyright (c) 2003-2019 University of Illinois at Urbana-Champaign.; All rights reserved. Developed by:. LLVM Team. University of Illinois at Urbana-Champaign. http://llvm.org. Permission is hereby granted, free of charge, to any person obtaining a copy of; this software and associated documentation files (the ""Software""), to deal with; the Software without restriction, including without limitation the rights to; use, copy, modify, mer",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/LICENSE.TXT:11834,clear,clearly,11834,interpreter/llvm-project/llvm/LICENSE.TXT,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/LICENSE.TXT,2,['clear'],['clearly']
Usability,"hout complying; with the conditions of Sections 4(a), 4(b) and 4(d) of the License. In addition, if you combine or link compiled forms of this Software with; software that is licensed under the GPLv2 (""Combined Software"") and if a; court of competent jurisdiction determines that the patent provision (Section; 3), the indemnity provision (Section 9) or other Section of the License; conflicts with the conditions of the GPLv2, you may retroactively and; prospectively choose to deem waived or otherwise exclude such Section(s) of; the License, but only in their entirety and only with respect to the Combined; Software. ==============================================================================; Software from third parties included in the LLVM Project:; ==============================================================================; The LLVM Project contains third party software which is under different license; terms. All such code will be identified clearly using at least one of two; mechanisms:; 1) It will be in a separate directory tree with its own `LICENSE.txt` or; `LICENSE` file at the top containing the specific license and restrictions; which apply to that software, or; 2) It will contain specific license and restriction terms at the top of every; file. ==============================================================================; Legacy LLVM License (https://llvm.org/docs/DeveloperPolicy.html#legacy):; ==============================================================================; University of Illinois/NCSA; Open Source License. Copyright (c) 2007-2018 University of Illinois at Urbana-Champaign.; All rights reserved. Developed by:. LLVM Team. University of Illinois at Urbana-Champaign. http://llvm.org. Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the ""Software""), to deal with the Software without restriction, including without limitation the rights to use, copy, modify, merge,",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-format-vs/ClangFormat/license.txt:11834,clear,clearly,11834,interpreter/llvm-project/clang/tools/clang-format-vs/ClangFormat/license.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-format-vs/ClangFormat/license.txt,1,['clear'],['clearly']
Usability,"hout complying; with the conditions of Sections 4(a), 4(b) and 4(d) of the License. In addition, if you combine or link compiled forms of this Software with; software that is licensed under the GPLv2 (""Combined Software"") and if a; court of competent jurisdiction determines that the patent provision (Section; 3), the indemnity provision (Section 9) or other Section of the License; conflicts with the conditions of the GPLv2, you may retroactively and; prospectively choose to deem waived or otherwise exclude such Section(s) of; the License, but only in their entirety and only with respect to the Combined; Software. ==============================================================================; Software from third parties included in the LLVM Project:; ==============================================================================; The LLVM Project contains third party software which is under different license; terms. All such code will be identified clearly using at least one of two; mechanisms:; 1) It will be in a separate directory tree with its own `LICENSE.txt` or; `LICENSE` file at the top containing the specific license and restrictions; which apply to that software, or; 2) It will contain specific license and restriction terms at the top of every; file. ==============================================================================; Legacy LLVM License (https://llvm.org/docs/DeveloperPolicy.html#legacy):; ==============================================================================; University of Illinois/NCSA; Open Source License. Copyright (c) 2007-2019 University of Illinois at Urbana-Champaign.; All rights reserved. Developed by:. LLVM Team. University of Illinois at Urbana-Champaign. http://llvm.org. Permission is hereby granted, free of charge, to any person obtaining a copy of; this software and associated documentation files (the ""Software""), to deal with; the Software without restriction, including without limitation the rights to; use, copy, modify, mer",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/LICENSE.TXT:11834,clear,clearly,11834,interpreter/llvm-project/clang/LICENSE.TXT,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/LICENSE.TXT,1,['clear'],['clearly']
Usability,"how some of the other pieces work in a bigger example. $ clang -fsyntax-only t.c; t.c:80:3: error: invalid operands to binary expression ('typeof(P)' (aka 'struct mystruct') and 'typeof(F)' (aka 'float')); X = MYMAX(P, F);; ^~~~~~~~~~~; t.c:76:94: note: expanded from:; #define MYMAX(A,B) __extension__ ({ __typeof__(A) __a = (A); __typeof__(B) __b = (B); __a < __b ? __b : __a; }); ~~~ ^ ~~~. Here's another real world warning that occurs in the ""window"" Unix package (which; implements the ""wwopen"" class of APIs):. $ clang -fsyntax-only t.c; t.c:22:2: warning: type specifier missing, defaults to 'int'; ILPAD();; ^; t.c:17:17: note: expanded from:; #define ILPAD() PAD((NROW - tt.tt_row) * 10) /* 1 ms per char */; ^; t.c:14:2: note: expanded from:; register i; \; ^. In practice, we've found that Clang's treatment of macros is actually more useful in multiply nested; macros than in simple ones.; Quality of Implementation and Attention to Detail; Finally, we have put a lot of work polishing the little things, because; little things add up over time and contribute to a great user experience.; The following example shows that we recover from the simple case of; forgetting a ; after a struct definition much better than GCC. $ cat t.cc; template<class T>; class a {};; struct b {}; a<int> c;; $ gcc-4.9 t.cc; t.cc:4:8: error: invalid declarator before 'c'; a<int> c;; ^; $ clang t.cc; t.cc:3:12: error: expected ';' after struct; struct b {}; ^; ;. The following example shows that we diagnose and recover from a missing; typename keyword well, even in complex circumstances where GCC; cannot cope. $ cat t.cc; template<class T> void f(T::type) { }; struct A { };; void g(); {; A a;; f<A>(a);; }; $ gcc-4.9 t.cc; t.cc:1:33: error: variable or field 'f' declared void; template<class T> void f(T::type) { }; ^; t.cc: In function 'void g()':; t.cc:6:5: error: 'f' was not declared in this scope; f<A>(a);; ^; t.cc:6:8: error: expected primary-expression before '>' token; f<A>(a);; ^; $ clang t",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/diagnostics.html:10157,user experience,user experience,10157,interpreter/llvm-project/clang/www/diagnostics.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/diagnostics.html,1,['user experience'],['user experience']
Usability,"however,; be exactly representable as bfloat, IEEE 754 half, and IEEE 754 single; precision respectively. Hexadecimal format is always used for long double, and; there are three forms of long double. The 80-bit format used by x86 is; represented as ``0xK`` followed by 20 hexadecimal digits. The 128-bit format; used by PowerPC (two adjacent doubles) is represented by ``0xM`` followed by 32; hexadecimal digits. The IEEE 128-bit format is represented by ``0xL`` followed; by 32 hexadecimal digits. Long doubles will only work if they match the long; double format on your target. The IEEE 16-bit format (half precision) is; represented by ``0xH`` followed by 4 hexadecimal digits. The bfloat 16-bit; format is represented by ``0xR`` followed by 4 hexadecimal digits. All; hexadecimal formats are big-endian (sign bit at the left). There are no constants of type x86_mmx and x86_amx. .. _complexconstants:. Complex Constants; -----------------. Complex constants are a (potentially recursive) combination of simple; constants and smaller complex constants. **Structure constants**; Structure constants are represented with notation similar to; structure type definitions (a comma separated list of elements,; surrounded by braces (``{}``)). For example:; ""``{ i32 4, float 17.0, ptr @G }``"", where ""``@G``"" is declared as; ""``@G = external global i32``"". Structure constants must have; :ref:`structure type <t_struct>`, and the number and types of elements; must match those specified by the type.; **Array constants**; Array constants are represented with notation similar to array type; definitions (a comma separated list of elements, surrounded by; square brackets (``[]``)). For example:; ""``[ i32 42, i32 11, i32 74 ]``"". Array constants must have; :ref:`array type <t_array>`, and the number and types of elements must; match those specified by the type. As a special case, character array; constants may also be represented as a double-quoted string using the ``c``; prefix. For example: ""``c",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:187731,simpl,simple,187731,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['simpl'],['simple']
Usability,"htforwards for line number information, as mapping; instructions to line numbers is a simple association. For variable locations; however the story is more complex. As each ``llvm.dbg.value`` intrinsic; represents a source-level assignment of a value to a source variable, the; variable location intrinsics effectively embed a small imperative program; within the LLVM IR. By the end of CodeGen, this becomes a mapping from each; variable to their machine locations over ranges of instructions.; From IR to object emission, the major transformations which affect variable; location fidelity are:. 1. Instruction Selection; 2. Register allocation; 3. Block layout. each of which are discussed below. In addition, instruction scheduling can; significantly change the ordering of the program, and occurs in a number of; different passes. Some variable locations are not transformed during CodeGen. Stack locations; specified by ``llvm.dbg.declare`` are valid and unchanging for the entire; duration of the function, and are recorded in a simple MachineFunction table.; Location changes in the prologue and epilogue of a function are also ignored:; frame setup and destruction may take several instructions, require a; disproportionate amount of debugging information in the output binary to; describe, and should be stepped over by debuggers anyway. Variable locations in Instruction Selection and MIR; ---------------------------------------------------. Instruction selection creates a MIR function from an IR function, and just as; it transforms ``intermediate`` instructions into machine instructions, so must; ``intermediate`` variable locations become machine variable locations.; Within IR, variable locations are always identified by a Value, but in MIR; there can be different types of variable locations. In addition, some IR; locations become unavailable, for example if the operation of multiple IR; instructions are combined into one machine instruction (such as; multiply-and-accumulate) t",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst:25174,simpl,simple,25174,interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,1,['simpl'],['simple']
Usability,"https://llvm.org/docs/DeveloperPolicy.html#introducing-new-components-into-llvm>`_; roadmap or similar efforts.; * Code that is making its way out of LLVM, via deprecation, replacement or; bit-rot, and will be removed if the sub-community that cares about it; cannot maintain it.; * Code that isn't meant to be in LLVM core and can coexist with the code in; the core tier (and others in the peripheral tier) long term, without causing; breakages or disturbances. What is covered; ---------------. The peripheral tier is composed of:; * Experimental targets and options that haven't been enable by default yet.; * Main repository projects that don't get released or regularly tested.; * Legacy tools and scripts that aren't used in upstream validation.; * Alternative build systems (ex. GN, Bazel) and related infrastructure.; * Tools support (ex. gdb scripts, editor configuration, helper scripts). Requirements; ------------. Code in this tier must:; * Have a clear benefit for residing in the main repository, catering to an; active sub-community (upstream or downstream).; * Be actively maintained by such sub-community and have its problems addressed; in a timely manner. Code in this tier must **not**:; * Break or invalidate core tier code or infrastructure. If that happens; accidentally, reverting functionality and working on the issues offline; is the only acceptable course of action.; * Negatively affect development of core tier code, with the sub-community; involved responsible for making changes to address specific concerns.; * Negatively affect other peripheral tier code, with the sub-communities; involved tasked to resolve the issues, still making sure the solution doesn't; break or invalidate the core tier.; * Impose sub-optimal implementation strategies on core tier components as a; result of idiosyncrasies in the peripheral component.; * Have build infrastructure that spams all developers about their breakages.; * Fall into disrepair. This is a reflection of lack of an ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SupportPolicy.rst:4788,clear,clear,4788,interpreter/llvm-project/llvm/docs/SupportPolicy.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SupportPolicy.rst,1,['clear'],['clear']
Usability,"human-readable error cause to the end user. A debug info consumer; that is unaware of this sees an inlined function whose name encodes an error; message (e.g., : ``__bounds_safety$Bounds check failed``). Expression Parsing; ------------------. In our implementation, LLDB’s expression evaluator does not enable the; ``-fbounds-safety`` language option because it’s currently unable to fully; reconstruct the pointers with external bounds annotations, and also because the; evaluator operates in C++ mode, utilizing C++ reference types, while; ``-fbounds-safety`` does not currently support C++. This means LLDB’s expression; evaluator can only evaluate a subset of the ``-fbounds-safety`` language model.; Specifically, it’s capable of evaluating the wide pointers that already exist in; the source code. All other expressions are evaluated according to C/C++; semantics. C++ support; ===========. C++ has multiple options to write code in a bounds-safe manner, such as; following the bounds-safety core guidelines and/or using hardened libc++ along; with the `C++ Safe Buffer model; <https://discourse.llvm.org/t/rfc-c-buffer-hardening/65734>`_. However, these; techniques may require ABI changes and may not be applicable to code; interoperating with C. When the ABI of an existing program needs to be preserved; and for headers shared between C and C++, ``-fbounds-safety`` offers a potential; solution. ``-fbounds-safety`` is not currently supported in C++, but we believe the; general approach would be applicable for future efforts. Upstreaming plan; ================. Gradual updates with experimental flag; --------------------------------------. The upstreaming will take place as a series of smaller PRs and we will guard our; implementation with an experimental flag ``-fexperimental-bounds-safety`` until; the usable model is fully upstreamed. Once the model is ready for use, we will; expose the flag ``-fbounds-safety``. Possible patch sets; -------------------. * External bounds annot",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafetyImplPlans.rst:10541,guid,guidelines,10541,interpreter/llvm-project/clang/docs/BoundsSafetyImplPlans.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafetyImplPlans.rst,1,['guid'],['guidelines']
Usability,"i Gheata, CERN/SFT,\; Sergey Linev, GSI, http,\; Pere Mato, CERN/SFT,\; Lorenzo Moneta, CERN/SFT,\; Axel Naumann, CERN/SFT,\; Danilo Piparo, CERN/SFT,\; Fons Rademakers, CERN/SFT,\; Enric Tejedor Saavedra, CERN/SFT,\; Vassil Vassilev, Fermilab/CMS,\; Wouter Verkerke, NIKHEF/Atlas, RooFit. ## Removed interfaces. The following interfaces have been removed, after deprecation in v6.08. ### CINT remnants, dysfunctional for ROOT 6. - `TInterpreter`'s `Getgvp()`, `Getp2f2funcname(void*)`, `Setgvp(Long_t)`, `SetRTLD_NOW()`, `SetRTLD_LAZY()`.; - `SetFCN(void*)` from TVirtualFitter, TFitter, TBackCompFitter, TMinuit; - `TFoam::SetRhoInt(void*)`. ### Core. - The enum constant `TRef::kNotComputed`, `TLink::kObjIsParent` were never used and have been removed.; - The enum constant `TClonesArray::kNoSplit` has not been used since v2.26 and has been removed. ## Interpreter. - Automatic declaration of variables (`h = new TH1F(...)`) is *only* available at the prompt. The side-effects of relying on this in source files is simply too grave. Due to a bug (ROOT-8538), automatically declared variables must currently reside on the top-most scope, i.e. not inside an `if` block etc.; - Improved the stack frame information generated by the JIT. By avoiding interleaving of the memory associated to multiple JIT module, the generation of stack trace involving jitted code and the catching of exception going through jitted code has been repaired.; - Interpreted code is now optimized; `.O 0/1/2/3` can be used to change the optimization level, as well as `#pragma cling optimize`.; - The prompt colors are now much more visible, both on terminals with light and dark background.; - Significant speedup of `TMethodCall`.; - One can now run `.x 12file-with@funny=name.C`; it will expect a function called `_12file_with_funny_name()`. ## Core Libraries. - See ""Build, Configuration and Testing Infrastructure"" below for changes in the directory structure.; - libCling now exports only a minimal set of symbols.;",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v610/index.md:1462,simpl,simply,1462,README/ReleaseNotes/v610/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v610/index.md,1,['simpl'],['simply']
Usability,"i;}; unsigned int f2(unsigned int i, unsigned int n) {++i; i += i == n; return i;}; These should combine to the same thing. Currently, the first function; produces better code on X86. //===---------------------------------------------------------------------===//. From GCC Bug 15784:; #define abs(x) x>0?x:-x; int f(int x, int y); {; return (abs(x)) >= 0;; }; This should optimize to x == INT_MIN. (With -fwrapv.) Currently not; optimized with ""clang -emit-llvm-bc | opt -O3"". //===---------------------------------------------------------------------===//. From GCC Bug 14753:; void; rotate_cst (unsigned int a); {; a = (a << 10) | (a >> 22);; if (a == 123); bar ();; }; void; minus_cst (unsigned int a); {; unsigned int tem;. tem = 20 - a;; if (tem == 5); bar ();; }; void; mask_gt (unsigned int a); {; /* This is equivalent to a > 15. */; if ((a & ~7) > 8); bar ();; }; void; rshift_gt (unsigned int a); {; /* This is equivalent to a > 23. */; if ((a >> 2) > 5); bar ();; }. All should simplify to a single comparison. All of these are; currently not optimized with ""clang -emit-llvm-bc | opt; -O3"". //===---------------------------------------------------------------------===//. From GCC Bug 32605:; int c(int* x) {return (char*)x+2 == (char*)x;}; Should combine to 0. Currently not optimized with ""clang; -emit-llvm-bc | opt -O3"" (although llc can optimize it). //===---------------------------------------------------------------------===//. int a(unsigned b) {return ((b << 31) | (b << 30)) >> 31;}; Should be combined to ""((b >> 1) | b) & 1"". Currently not optimized; with ""clang -emit-llvm-bc | opt -O3"". //===---------------------------------------------------------------------===//. unsigned a(unsigned x, unsigned y) { return x | (y & 1) | (y & 2);}; Should combine to ""x | (y & 3)"". Currently not optimized with ""clang; -emit-llvm-bc | opt -O3"". //===---------------------------------------------------------------------===//. int a(int a, int b, int c) {return (~a & c) | ((c|a) & b)",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/README.txt:23183,simpl,simplify,23183,interpreter/llvm-project/llvm/lib/Target/README.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/README.txt,1,['simpl'],['simplify']
Usability,"iagnostics-fixit-info:. .. option:: -f[no-]diagnostics-fixit-info. Enable ""FixIt"" information in the diagnostics output. This option, which defaults to on, controls whether or not Clang; prints the information on how to fix a specific diagnostic; underneath it when it knows. For example, in this output:. ::. test.c:28:8: warning: extra tokens at end of #endif directive [-Wextra-tokens]; #endif bad; ^; //. Passing **-fno-diagnostics-fixit-info** will prevent Clang from; printing the ""//"" line at the end of the message. This information; is useful for users who may not understand what is wrong, but can be; confusing for machine parsing. .. _opt_fdiagnostics-print-source-range-info:. .. option:: -fdiagnostics-print-source-range-info. Print machine parsable information about source ranges.; This option makes Clang print information about source ranges in a machine; parsable format after the file/line/column number information. The; information is a simple sequence of brace enclosed ranges, where each range; lists the start and end line/column locations. For example, in this output:. ::. exprs.c:47:15:{47:8-47:14}{47:17-47:24}: error: invalid operands to binary expression ('int *' and '_Complex float'); P = (P-42) + Gamma*4;; ~~~~~~ ^ ~~~~~~~. The {}'s are generated by -fdiagnostics-print-source-range-info. The printed column numbers count bytes from the beginning of the; line; take care if your source contains multibyte characters. .. option:: -fdiagnostics-parseable-fixits. Print Fix-Its in a machine parseable form. This option makes Clang print available Fix-Its in a machine; parseable format at the end of diagnostics. The following example; illustrates the format:. ::. fix-it:""t.cpp"":{7:25-7:29}:""Gamma"". The range printed is a half-open range, so in this example the; characters at column 25 up to but not including column 29 on line 7; in t.cpp should be replaced with the string ""Gamma"". Either the; range or the replacement string may be empty (representing strict; ins",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:16143,simpl,simple,16143,interpreter/llvm-project/clang/docs/UsersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst,1,['simpl'],['simple']
Usability,"ial; invocation of the coroutine. The `loop` blocks represents the body of the coroutine. The `coro.suspend`_; intrinsic in combination with the following switch indicates what happens to; control flow when a coroutine is suspended (default case), resumed (case 0) or; destroyed (case 1). Coroutine Transformation; ------------------------. One of the steps of coroutine lowering is building the coroutine frame. The; def-use chains are analyzed to determine which objects need be kept alive across; suspend points. In the coroutine shown in the previous section, use of virtual register; `%inc` is separated from the definition by a suspend point, therefore, it; cannot reside on the stack frame since the latter goes away once the coroutine; is suspended and control is returned back to the caller. An i32 slot is; allocated in the coroutine frame and `%inc` is spilled and reloaded from that; slot as needed. We also store addresses of the resume and destroy functions so that the; `coro.resume` and `coro.destroy` intrinsics can resume and destroy the coroutine; when its identity cannot be determined statically at compile time. For our; example, the coroutine frame will be:. .. code-block:: llvm. %f.frame = type { ptr, ptr, i32 }. After resume and destroy parts are outlined, function `f` will contain only the; code responsible for creation and initialization of the coroutine frame and; execution of the coroutine until a suspend point is reached:. .. code-block:: llvm. define ptr @f(i32 %n) {; entry:; %id = call token @llvm.coro.id(i32 0, ptr null, ptr null, ptr null); %alloc = call noalias ptr @malloc(i32 24); %frame = call noalias ptr @llvm.coro.begin(token %id, ptr %alloc); %1 = getelementptr %f.frame, ptr %frame, i32 0, i32 0; store ptr @f.resume, ptr %1; %2 = getelementptr %f.frame, ptr %frame, i32 0, i32 1; store ptr @f.destroy, ptr %2. %inc = add nsw i32 %n, 1; %inc.spill.addr = getelementptr inbounds %f.Frame, ptr %FramePtr, i32 0, i32 2; store i32 %inc, ptr %inc.spill.a",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst:14425,resume,resume,14425,interpreter/llvm-project/llvm/docs/Coroutines.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst,1,['resume'],['resume']
Usability,"ials; - Add the ""Legacy"" category collecting the old tutorials which do not represent any more best practices. ## Class Reference Guide; - Images in tutorials can now be displayed à JavaScript thanks to the (js) option; added next to the directive `\macro_image`; - As the tutorial `palettes.C` is often hit when searching the keyword `palette`; in the reference guide, a direct link from this example to the full list of; predefined palettes given in `TColor` has been added.; - Revisited the TSpectrum2 documentation. All the static images have been replaced; by macros generating images at reference guide build time. These macros have; been added in the tutorial section of the reference guide.; - The Reference Guide can now be accessed directly from the ROOT prompt thanks to; a great extension (implemented by Desislava Kalaydjieva) of the `.help` command.; For example to access the Reference Guide for `TTree` it is enough to type:; ~~~ {.cpp}; root[0] .help TTree; ~~~; To open the reference guide for a function/member:; ~~~ {.cpp}; root[0] .help TTree::Draw; ~~~. ## Build, Configuration and Testing Infrastructure. - Make MLP optional via the `-Dmlp={OFF,ON}` switch for CMake; - Make Spectrum optional via the `-Dspectrum={OFF,ON}` switch for CMake; - ROOT now fails to configure when any package is missing; when `-Dfail-on-missing=ON` is passed to CMake; - The `-Dall=ON` now switches the default value of all optional packages to `ON`; - The options `astiff`, `cling`, `pch`, `thread`, and `explicitlink` have been; removed and are now ignored. They either had no effect (their value was not; being used in the build system), or could not be disabled (like `cling` and; `explicitlink`).; - ROOT library targets now export which C++ standard they were built with via; the target compile features `cxx_std_11`, `cxx_std_14`, and `cxx_std_17`.; - The file `RootNewMacros.cmake` has been renamed to `RootMacros.cmake`.; Including the old file by name is deprecated and will generate a war",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v620/index.md:7732,guid,guide,7732,README/ReleaseNotes/v620/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v620/index.md,1,['guid'],['guide']
Usability,"ib64""`` to cmake to add an absolute; path to ``libstdc++.so.6`` as above. Since these binaries are not distributed,; having an absolute local path is fine for them. When you build Clang, you will need to give *it* access to modern C++; standard library in order to use it as your new host in part of a bootstrap.; There are two easy ways to do this, either build (and install) libc++ along; with Clang and then use it with the ``-stdlib=libc++`` compile and link flag,; or install Clang into the same prefix (``$HOME/toolchains`` above) as GCC.; Clang will look within its own prefix for libstdc++ and use it if found. You; can also add an explicit prefix for Clang to look in for a GCC toolchain with; the ``--gcc-toolchain=/opt/my/gcc/prefix`` flag, passing it to both compile and; link commands when using your just-built-Clang to bootstrap. .. _Getting Started with LLVM:. Getting Started with LLVM; =========================. The remainder of this guide is meant to get you up and running with LLVM and to; give you some basic information about the LLVM environment. The later sections of this guide describe the `general layout`_ of the LLVM; source tree, a `simple example`_ using the LLVM tool chain, and `links`_ to find; more information about LLVM or to get help via e-mail. Terminology and Notation; ------------------------. Throughout this manual, the following names are used to denote paths specific to; the local system and working environment. *These are not environment variables; you need to set but just strings used in the rest of this document below*. In; any of the examples below, simply replace each of these names with the; appropriate pathname on your local system. All these paths are absolute:. ``SRC_ROOT``. This is the top level directory of the LLVM source tree. ``OBJ_ROOT``. This is the top level directory of the LLVM object tree (i.e. the tree where; object files and compiled programs will be placed. It can be the same as; SRC_ROOT). Unpacking the LLVM Archives;",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GettingStarted.rst:20218,guid,guide,20218,interpreter/llvm-project/llvm/docs/GettingStarted.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GettingStarted.rst,1,['guid'],['guide']
Usability,"ibCore.so`) contains the essentials; it is a part of all; ROOT applications. In the Figure 1-2 you see that libCore.so is made; up of base classes, container classes, meta information classes,; operating system specific classes, and the ZIP algorithm used for; compression of the ROOT files. The Cling library (`libCling.so`) is also needed in all ROOT; applications, and even by `libCore`. A; program referencing only **`TObject`** only needs `libCore`;; `libCling` will be opened automatically. To add the ability to read and write; ROOT objects one also has to load `libRIO`. As one would expect, none of that; depends on graphics or the GUI. Library dependencies have different consequences; depending on whether; you try to build a binary, or you just try to access a class that is; defined in a library. #### Linktime Library Dependencies. When building your own executable you will have to link against the; libraries that contain the classes you use. The ROOT reference guide; states the library a class is reference guide defined in. Almost all; relevant classes can be found in libraries returned by; `root-config -glibs`; the graphics libraries are retuned by; `root-config --libs`. These commands are commonly used in `Makefiles`.; Using `root-config` instead of enumerating the libraries by hand; allows you to link them in a platform independent way. Also, if ROOT; library names change you will not need to change your Makefile. A batch program that does not have a graphic display, which creates,; fills, and saves histograms and trees, only needs to link the core; libraries (`libCore`, `libRIO`), `libHist` and `libTree`.; If ROOT needs access to other libraries, it loads them dynamically.; For example, if the **`TreeViewer`** is used, `libTreePlayer` and all; libraries `libTreePlayer` depends on are loaded also. The dependent; libraries are shown in the ROOT reference guide's library dependency; graph. The difference between reference guide `libHist` and; `libHistPainter` is",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md:17216,guid,guide,17216,documentation/users-guide/Introduction.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md,2,['guid'],['guide']
Usability,"ic information in the IR. Why do struct member indices always use ``i32``?; ------------------------------------------------. The specific type i32 is probably just a historical artifact, however it's wide; enough for all practical purposes, so there's been no need to change it. It; doesn't necessarily imply i32 address arithmetic; it's just an identifier which; identifies a field in a struct. Requiring that all struct indices be the same; reduces the range of possibilities for cases where two GEPs are effectively the; same but have distinct operand types. What's an uglygep?; ------------------. Some LLVM optimizers operate on GEPs by internally lowering them into more; primitive integer expressions, which allows them to be combined with other; integer expressions and/or split into multiple separate integer expressions. If; they've made non-trivial changes, translating back into LLVM IR can involve; reverse-engineering the structure of the addressing in order to fit it into the; static type of the original first operand. It isn't always possibly to fully; reconstruct this structure; sometimes the underlying addressing doesn't; correspond with the static type at all. In such cases the optimizer instead will; emit a GEP with the base pointer casted to a simple address-unit pointer, using; the name ""uglygep"". This isn't pretty, but it's just as valid, and it's; sufficient to preserve the pointer aliasing guarantees that GEP provides. Summary; =======. In summary, here's some things to always remember about the GetElementPtr; instruction:. #. The GEP instruction never accesses memory, it only provides pointer; computations. #. The second operand to the GEP instruction is always a pointer and it must be; indexed. #. There are no superfluous indices for the GEP instruction. #. Trailing zero indices are superfluous for pointer aliasing, but not for the; types of the pointers. #. Leading zero indices are not superfluous for pointer aliasing nor the types; of the pointers.; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GetElementPtr.rst:21136,simpl,simple,21136,interpreter/llvm-project/llvm/docs/GetElementPtr.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GetElementPtr.rst,1,['simpl'],['simple']
Usability,"ical and, which does not short circuit.; def binary& 6 (LHS RHS); if !LHS then; 0; else; !!RHS;. # Define = with slightly lower precedence than relationals.; def binary = 9 (LHS RHS); !(LHS < RHS | LHS > RHS);. # Define ':' for sequencing: as a low-precedence operator that ignores operands; # and just returns the RHS.; def binary : 1 (x y) y;. Given the previous if/then/else support, we can also define interesting; functions for I/O. For example, the following prints out a character; whose ""density"" reflects the value passed in: the lower the value, the; denser the character:. ::. ready> extern putchard(char);; ...; ready> def printdensity(d); if d > 8 then; putchard(32) # ' '; else if d > 4 then; putchard(46) # '.'; else if d > 2 then; putchard(43) # '+'; else; putchard(42); # '*'; ...; ready> printdensity(1): printdensity(2): printdensity(3):; printdensity(4): printdensity(5): printdensity(9):; putchard(10);; **++.; Evaluated to 0.000000. Based on these simple primitive operations, we can start to define more; interesting things. For example, here's a little function that determines; the number of iterations it takes for a certain function in the complex; plane to diverge:. ::. # Determine whether the specific location diverges.; # Solve for z = z^2 + c in the complex plane.; def mandelconverger(real imag iters creal cimag); if iters > 255 | (real*real + imag*imag > 4) then; iters; else; mandelconverger(real*real - imag*imag + creal,; 2*real*imag + cimag,; iters+1, creal, cimag);. # Return the number of iterations required for the iteration to escape; def mandelconverge(real imag); mandelconverger(real, imag, 0, real, imag);. This ""``z = z2 + c``"" function is a beautiful little creature that is; the basis for computation of the `Mandelbrot; Set <http://en.wikipedia.org/wiki/Mandelbrot_set>`_. Our; ``mandelconverge`` function returns the number of iterations that it; takes for a complex orbit to escape, saturating to 255. This is not a; very useful function by itsel",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl06.rst:16364,simpl,simple,16364,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl06.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl06.rst,1,['simpl'],['simple']
Usability,"ically-unreachable handlers; Not resolved. 2220; C++17; Hiding index variable in range-based for; Unknown. 2221; CD6; Copying volatile objects; Unknown. 2222; drafting; Additional contexts where instantiation is not required; Not resolved. 2223; drafting; Multiple alignas specifiers; Not resolved. 2224; C++17; Member subobjects and base-class casts; Unknown. 2225; NAD; reinterpret_cast to same floating-point type; Unknown. 2226; CD5; Xvalues vs lvalues in conditional expressions; Unknown. 2227; CD5; Destructor access and default member initializers; Unknown. 2228; open; Ambiguity resolution for cast to function type; Not resolved. 2229; CD5; Volatile unnamed bit-fields; Clang 7. 2230; NAD; Linkage of extern ""C"" function in unnamed namespace; Unknown. 2231; NAD; Class member access to static data member template; Unknown. 2232; open; thread_local anonymous unions; Not resolved. 2233; CD5; Function parameter packs following default arguments; Clang 11. 2234; CD5; Missing rules for simple-template-id as class-name; Unknown. 2235; CD5; Partial ordering and non-dependent types; Unknown. 2236; drafting; When is an alias template specialization dependent?; Not resolved. 2237; CD5; Can a template-id name a constructor?; Unknown. 2238; NAD; Contradictory alignment requirements for allocation; Unknown. 2239; NAD; Sized deallocation with a trivial destructor; Unknown. 2240; NAD; this is not odr-used in a constant expression; Unknown. 2241; CD5; Overload resolution is not invoked with a single function; Unknown. 2242; C++23; ODR violation with constant initialization possibly omitted; Unknown. 2243; drafting; Incorrect use of implicit conversion sequence; Not resolved. 2244; open; Base class access in aggregate initialization; Not resolved. 2245; drafting; Point of instantiation of incomplete class template; Not resolved. 2246; drafting; Access of indirect virtual base class constructors; Not resolved. 2247; C++17; Lambda capture and variable argument list; Unknown. 2248; C++17",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:152207,simpl,simple-template-id,152207,interpreter/llvm-project/clang/www/cxx_dr_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html,1,['simpl'],['simple-template-id']
Usability,"icator; Passes; ReportingGuide; ResponseGuide; Remarks; RemoveDIsDebugInfo; RISCVUsage; SourceLevelDebugging; SPIRVUsage; StackSafetyAnalysis; SupportLibrary; TableGen/index; TableGenFundamentals; Vectorizers; WritingAnLLVMPass; WritingAnLLVMNewPMPass; WritingAnLLVMBackend; yaml2obj. Clang; -----. :doc:`HowToBuildOnARM`; Notes on building and testing LLVM/Clang on ARM. :doc:`HowToBuildWithPGO`; Notes on building LLVM/Clang with PGO. :doc:`HowToCrossCompileLLVM`; Notes on cross-building and testing LLVM/Clang. `How to build the C, C++, ObjC, and ObjC++ front end`__; Instructions for building the clang front-end from source. .. __: https://clang.llvm.org/get_started.html. :doc:`CoverageMappingFormat`; This describes the format and encoding used for LLVM’s code coverage mapping. :doc:`CFIVerify`; A description of the verification tool for Control Flow Integrity. LLVM Builds and Distributions; -----------------------------. :doc:`BuildingADistribution`; A best-practices guide for using LLVM's CMake build system to package and; distribute LLVM-based tools. :doc:`CMake`; An addendum to the main Getting Started guide for those using the `CMake; build system <http://www.cmake.org>`_. :doc:`Docker`; A reference for using Dockerfiles provided with LLVM. :doc:`Support Library <SupportLibrary>`; This document describes the LLVM Support Library (``lib/Support``) and; how to keep LLVM source code portable. :doc:`AdvancedBuilds`; This document describes more advanced build configurations. Optimizations; -------------. :doc:`WritingAnLLVMPass`; Information on how to write LLVM transformations and analyses. :doc:`WritingAnLLVMNewPMPass`; Information on how to write LLVM transformations under the new pass; manager. :doc:`Passes`; A list of optimizations and analyses implemented in LLVM. :doc:`StackSafetyAnalysis`; This document describes the design of the stack safety analysis of local; variables. :doc:`MergeFunctions`; Describes functions merging optimization. :doc:`AliasAnalysis`; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/UserGuides.rst:2082,guid,guide,2082,interpreter/llvm-project/llvm/docs/UserGuides.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/UserGuides.rst,1,['guid'],['guide']
Usability,"icitly version locked so you'll need to make sure; you're using a Clang built from the same git revision or release as the LLVM; library you're using. As always, it's *strongly* recommended that you track; tip of tree development, particularly during bring up of a new project. The Basics; ^^^^^^^^^^^. #. Make sure that your Modules contain both a data layout specification and; target triple. Without these pieces, non of the target specific optimization; will be enabled. This can have a major effect on the generated code quality. #. For each function or global emitted, use the most private linkage type; possible (private, internal or linkonce_odr preferably). Doing so will; make LLVM's inter-procedural optimizations much more effective. #. Avoid high in-degree basic blocks (e.g. basic blocks with dozens or hundreds; of predecessors). Among other issues, the register allocator is known to; perform badly with confronted with such structures. The only exception to; this guidance is that a unified return block with high in-degree is fine. Use of allocas; ^^^^^^^^^^^^^^. An alloca instruction can be used to represent a function scoped stack slot,; but can also represent dynamic frame expansion. When representing function; scoped variables or locations, placing alloca instructions at the beginning of; the entry block should be preferred. In particular, place them before any; call instructions. Call instructions might get inlined and replaced with; multiple basic blocks. The end result is that a following alloca instruction; would no longer be in the entry basic block afterward. The SROA (Scalar Replacement Of Aggregates) and Mem2Reg passes only attempt; to eliminate alloca instructions that are in the entry basic block. Given; SSA is the canonical form expected by much of the optimizer; if allocas can; not be eliminated by Mem2Reg or SROA, the optimizer is likely to be less; effective than it could be. Avoid loads and stores of large aggregate type; ^^^^^^^^^^^^^^^^^^^^^^^^",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Frontend/PerformanceTips.rst:2043,guid,guidance,2043,interpreter/llvm-project/llvm/docs/Frontend/PerformanceTips.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Frontend/PerformanceTips.rst,1,['guid'],['guidance']
Usability,"ickling:. .. code-block:: python. >>> from cppyy.gbl import Namespace; >>> Concrete == Namespace.Concrete; False; >>> n = Namespace.Concrete.NestedClass(); >>> type(n); <class cppyy.gbl.Namespace.Concrete.NestedClass at 0x22114c0>; >>> type(n).__name__; NestedClass; >>> type(n).__module__; cppyy.gbl.Namespace.Concrete; >>> type(n).__cpp_name__; Namespace::Concrete::NestedClass; >>>. `Constructors`; --------------. Python and C++ both make a distinction between allocation (``__new__`` in; Python, ``operator new`` in C++) and initialization (``__init__`` in Python,; the constructor call in C++).; When binding, however, there comes a subtle semantic difference: the Python; ``__new__`` allocates memory for the proxy object only, and ``__init__``; initializes the proxy by creating or binding the C++ object.; Thus, no C++ memory is allocated until ``__init__``.; The advantages are simple: the proxy can now check whether it is initialized,; because the pointer to C++ memory will be NULL if not; it can be a reference; to another proxy holding the actual C++ memory; and it can now transparently; implement a C++ smart pointer.; If ``__init__`` is never called, eg. when a call to the base class; ``__init__`` is missing in a derived class override, then accessing the proxy; will result in a Python ``ReferenceError`` exception. `Destructors`; -------------. There should no be reason to call a destructor directly in CPython, but e.g.; PyPy uses a garbage collector and that makes it sometimes useful to destruct; a C++ object exactly when you want it destroyed.; Destructors are by convention accessible through the ``__destruct__`` method; (since ""~"" can not be part of a Python method name).; If a Python-side derived class overrides ``__destruct__``, that method will; be called when the instance gets deleted in C++.; The Python destructor, ``__del__``, gets called when the Python proxy goes; away, which will only delete the C++ instance if owned by Python.; Note that ``__del__`` is n",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/classes.rst:2260,simpl,simple,2260,bindings/pyroot/cppyy/cppyy/doc/source/classes.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/classes.rst,1,['simpl'],['simple']
Usability,"ieces; is not defined by neighbors, but by `containment`. In other words,; volumes are put one inside another making an in-depth hierarchy. From; outside, the whole thing looks like a big pack that you can open finding; out other smaller packs nicely arranged waiting to be opened at their; turn. The biggest one containing all others defines the ""`world`"" of the; model. We will often call this `master reference system (MARS)`. Going; on and opening our packs, we will obviously find out some empty ones,; otherwise, something is very wrong... We will call these leaves (by; analogy with a tree structure). On the other hand, any volume is a small world by itself - what we need; to do is to take it out and to ignore all the rest since it is a; self-contained object. In fact, the modeller can act like this,; considering a given volume as temporary MARS, but we will describe this; feature later on. Let us focus on the biggest pack - it is mandatory to; define one. Consider the simplest geometry that is made of a single box.; Here is an example on how to build it:. ### Example 1: Creating the World. We first need to load the geometry library. This is not needed if one; does `make map` in root folder. ``` {.cpp}; root[] gSystem->Load(""libGeom"");; ```. Second, we have to create an instance of the geometry manager class.; This takes care of all the modeller components, performing several tasks; to insure geometry validity and containing the user interface for; building and interacting with the geometry. After its creation, the; geometry manager class can be accessed with the global; ***`gGeoManager`***:. ``` {.cpp}; root[] new TGeoManager(""world"", ""the simplest geometry"");; ```. We want to create a single volume in our geometry, but since any volume; needs to have an associated medium, we will create a dummy one. You can; safely ignore the following lines for the time being, since materials; and media will be explained in detail later on. ``` {.cpp}; root[] TGeoMaterial *mat = n",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:1988,simpl,simplest,1988,documentation/users-guide/Geometry.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md,1,['simpl'],['simplest']
Usability,"ields.io/badge/License-LGPL%20v2.1+-blue.svg)](https://www.gnu.org/licenses/lgpl.html); [![CII Best Practices](https://bestpractices.coreinfrastructure.org/projects/5060/badge)](https://bestpractices.coreinfrastructure.org/projects/5060). ## Contribution Guidelines; - [How to contribute](https://github.com/root-project/root/blob/master/CONTRIBUTING.md); - [Coding conventions](https://root.cern/coding-conventions); - [Meetings](https://root.cern/meetings). ## Cite; When citing ROOT, please use both the reference reported below and the DOI specific to your ROOT version available [on Zenodo](https://zenodo.org/badge/latestdoi/10994345) [![DOI](https://zenodo.org/badge/10994345.svg)](https://zenodo.org/badge/latestdoi/10994345). For example, you can copy-paste and fill in the following citation:. Rene Brun and Fons Rademakers, ROOT - An Object Oriented Data Analysis Framework,; Proceedings AIHENP'96 Workshop, Lausanne, Sep. 1996,; Nucl. Inst. & Meth. in Phys. Res. A 389 (1997) 81-86.; See also ""ROOT"" [software], Release vX.YY/ZZ, dd/mm/yyyy. ## Live Demo for CERN Users; [![](https://img.shields.io/badge/Launch-SWAN-orange)](http://cern.ch/swanserver/cgi-bin/go?projurl=https://github.com/cernphsft/rootbinder.git). See more screenshots on our [gallery](https://root.cern/gallery). ## Installation and Getting Started; See https://root.cern/install for installation instructions.; For instructions on how to build ROOT from these source files, see https://root.cern/install/build_from_source. Our [""Getting started with ROOT""](https://root.cern/learn) page is then the perfect place to get familiar with ROOT. ## Help and Support; - [Forum](https://root.cern/forum/); - [Issue tracker](https://github.com/root-project/root/issues); * [Previous now read-only Jira issue tracker](https://sft.its.cern.ch/jira/projects/ROOT/issues/ROOT-5820?filter=allopenissues); - [Documentation](https://root.cern/guides/reference-guide); - [Tutorials](https://root.cern/doc/master/group__Tutorials.html)",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README.md:3344,learn,learn,3344,README.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README.md,3,"['guid', 'learn']","['guide', 'guides', 'learn']"
Usability,"ies ``GlobalsAA``, one that always stops at ``MemoryPhi`` nodes, etc). Default walker APIs; ^^^^^^^^^^^^^^^^^^^. There are two main APIs used to retrieve the clobbering access using the walker:. - ``MemoryAccess *getClobberingMemoryAccess(MemoryAccess *MA);`` return the; clobbering memory access for ``MA``, caching all intermediate results; computed along the way as part of each access queried. - ``MemoryAccess *getClobberingMemoryAccess(MemoryAccess *MA, const MemoryLocation &Loc);``; returns the access clobbering memory location ``Loc``, starting at ``MA``.; Because this API does not request the clobbering access of a specific memory; access, there are no results that can be cached. Locating clobbers yourself; ^^^^^^^^^^^^^^^^^^^^^^^^^^. If you choose to make your own walker, you can find the clobber for a; ``MemoryAccess`` by walking every ``MemoryDef`` that dominates said; ``MemoryAccess``. The structure of ``MemoryDef``\ s makes this relatively simple;; they ultimately form a linked list of every clobber that dominates the; ``MemoryAccess`` that you're trying to optimize. In other words, the; ``definingAccess`` of a ``MemoryDef`` is always the nearest dominating; ``MemoryDef`` or ``MemoryPhi`` of said ``MemoryDef``. Use and Def optimization; ------------------------. ``MemoryUse``\ s keep a single operand, which is their defining or optimized; access.; Traditionally ``MemorySSA`` optimized ``MemoryUse``\ s at build-time, up to a; given threshold.; Specifically, the operand of every ``MemoryUse`` was optimized to point to the; actual clobber of said ``MemoryUse``. This can be seen in the above example; the; second ``MemoryUse`` in ``if.end`` has an operand of ``1``, which is a; ``MemoryDef`` from the entry block. This is done to make walking,; value numbering, etc, faster and easier.; As of `this revision <https://reviews.llvm.org/D121381>`_, the default was; changed to not optimize uses at build time, in order to provide the option to; reduce compile-time if th",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MemorySSA.rst:10675,simpl,simple,10675,interpreter/llvm-project/llvm/docs/MemorySSA.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MemorySSA.rst,1,['simpl'],['simple']
Usability,"ies; involved tasked to resolve the issues, still making sure the solution doesn't; break or invalidate the core tier.; * Impose sub-optimal implementation strategies on core tier components as a; result of idiosyncrasies in the peripheral component.; * Have build infrastructure that spams all developers about their breakages.; * Fall into disrepair. This is a reflection of lack of an active sub-community; and will result in removal. Code in this tier should:; * Have infrastructure to test, whenever meaningful, with either no warnings or; notification contained within the sub-community.; * Have support and testing that scales with the complexity and resilience of; the component, with the bar for simple and gracefully-degrading components; (such as editor bindings) much lower than for complex components that must; remain fresh with HEAD (such as experimental back-ends or alternative build; systems).; * Have a document making clear the status of implementation, level of support; available, who the sub-community is and, if applicable, roadmap for inclusion; into the core tier.; * Be restricted to a specific directory or have a consistent pattern (ex.; unique file suffix), making it easy to remove when necessary. Inclusion Policy; ================. To add a new peripheral component, send an RFC to the appropriate dev list; proposing its addition and explaining how it will meet the support requirements; listed above. Different types of components could require different levels of; detail. when in doubt, ask the community what's the best approach. Inclusion must reach consensus in the RFC by the community and the approval of; the corresponding review (by multiple members of the community) is the official; note of acceptance. After merge, there often is a period of transition, where teething issues on; existing buildbots are discovered and fixed. If those cannot be fixed straight; away, the sub-community is responsible for tracking and reverting all the; pertinent patches a",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SupportPolicy.rst:6377,clear,clear,6377,interpreter/llvm-project/llvm/docs/SupportPolicy.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SupportPolicy.rst,1,['clear'],['clear']
Usability,"igation and Tracking. Tracking is the feature allowing the transport of a given particle; knowing its kinematics. A state is determined by any combination of the; position \f$\vec{r}\f$ and direction \f$\vec{n}\f$ with respect to the world; reference frame. The direction \f$\vec{n}\f$ must be a unit vector having as; components the director cosines. The full classification of a given; state will provide the following information: the deepest physical node; containing the position vector, the distance to the closest boundary; along the direction vector, the next physical node after propagating the; current point with this distance and the safety distance to the nearest; boundary. This information allows the propagation of particles inside a; detector geometry by taking into account both geometrical and physical; constraints. We will hereby describe the user interface of `TGeo` to access; tracking functionality. This allows either developing a tracker for; simple navigation within a given geometry, either interfacing to an; external tracking engine such as GEANT. Note that the abstract interface; for external trackers can be found in `$ROOTSYS/vmc` folder and it can; be used to run GEANT3, GEANT4 and FLUKA-based simulations (\*) by using; directly a geometry described with %ROOT. The interface methods related to tracking are incorporated into; TGeoManager class and implemented in the navigator class; TGeoNavigator. In order to be able to start tracking, one has to; define the initial state providing the starting point \f$\vec{r_0}\f$; and direction \f$\vec{n_0}\f$ .; There are several ways of doing that. \anchor GP02a; ### TGeoNavigator Class. One geometry may have several independent navigators to query to; localize points or compute distances. The geometry manager holds a list; of active navigators accessible via:. ~~~{.cpp}; TObjArray *navigators = gGeoManager->GetListOfNavigators();; ~~~. Upon closing the geometry a default navigator is provided as first one; in t",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md:62206,simpl,simple,62206,geom/geom/doc/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md,1,['simpl'],['simple']
Usability,"ights that; you have. You must make sure that they, too, receive or can get the; source code. And you must show them these terms so they know their; rights. We protect your rights with two steps: (1) copyright the software, and; (2) offer you this license which gives you legal permission to copy,; distribute and/or modify the software. Also, for each author's protection and ours, we want to make certain; that everyone understands that there is no warranty for this free; software. If the software is modified by someone else and passed on, we; want its recipients to know that what they have is not the original, so; that any problems introduced by others will not reflect on the original; authors' reputations. Finally, any free program is threatened constantly by software; patents. We wish to avoid the danger that redistributors of a free; program will individually obtain patent licenses, in effect making the; program proprietary. To prevent this, we have made it clear that any; patent must be licensed for everyone's free use or not licensed at all. The precise terms and conditions for copying, distribution and; modification follow. GNU GENERAL PUBLIC LICENSE; TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION. 0. This License applies to any program or other work which contains; a notice placed by the copyright holder saying it may be distributed; under the terms of this General Public License. The ""Program"", below,; refers to any such program or work, and a ""work based on the Program""; means either the Program or any derivative work under copyright law:; that is to say, a work containing the Program or a portion of it,; either verbatim or with modifications and/or translated into another; language. (Hereinafter, translation is included without limitation in; the term ""modification"".) Each licensee is addressed as ""you"". Activities other than copying, distribution and modification are not; covered by this License; they are outside its scope. The act of; runn",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/misc/rootql/LICENSE.txt:2646,clear,clear,2646,misc/rootql/LICENSE.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/misc/rootql/LICENSE.txt,2,['clear'],['clear']
Usability,"igned and built by experienced compiler developers who are; increasingly frustrated with the problems that existing open source; compilers have. Clang is carefully and thoughtfully designed and; built to provide the foundation of a whole new generation of; C/C++/Objective C development tools, and we intend for it to be; production quality.; Being a production quality compiler means many things: it means being high; performance, being solid and (relatively) bug free, and it means eventually; being used and depended on by a broad range of people. While we are still in; the early development stages, we strongly believe that this will become a; reality. A simple and hackable code base. Our goal is to make it possible for anyone with a basic understanding; of compilers and working knowledge of the C/C++/ObjC languages to understand and; extend the clang source base. A large part of this falls out of our decision to; make the AST mirror the languages as closely as possible: you have your friendly; if statement, for statement, parenthesis expression, structs, unions, etc, all; represented in a simple and explicit way.; In addition to a simple design, we work to make the source base approachable; by commenting it well, including citations of the language standards where; appropriate, and designing the code for simplicity. Beyond that, clang offers; a set of AST dumpers, printers, and visualizers that make it easy to put code in; and see how it is represented. A single unified parser for C, Objective C, C++,; and Objective C++. Clang is the ""C Language Family Front-end"", which means we intend to support; the most popular members of the C family. We are convinced that the right; parsing technology for this class of languages is a hand-built recursive-descent; parser. Because it is plain C++ code, recursive descent makes it very easy for; new developers to understand the code, it easily supports ad-hoc rules and other; strange hacks required by C/C++, and makes it straight-forw",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/features.html:12381,simpl,simple,12381,interpreter/llvm-project/clang/www/features.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/features.html,1,['simpl'],['simple']
Usability,"igned to eliminate unreachable internal globals from the; program. It uses an aggressive algorithm, searching out globals that are known; to be alive. After it finds all of the globals which are needed, it deletes; whatever is left over. This allows it to delete recursive chunks of the; program which are unreachable. ``globalopt``: Global Variable Optimizer; ----------------------------------------. This pass transforms simple global variables that never have their address; taken. If obviously true, it marks read/write globals as constant, deletes; variables only stored to, etc. ``gvn``: Global Value Numbering; -------------------------------. This pass performs global value numbering to eliminate fully and partially; redundant instructions. It also performs redundant load elimination. .. _passes-indvars:. ``indvars``: Canonicalize Induction Variables; ---------------------------------------------. This transformation analyzes and transforms the induction variables (and; computations derived from them) into simpler forms suitable for subsequent; analysis and transformation. This transformation makes the following changes to each loop with an; identifiable induction variable:. * All loops are transformed to have a *single* canonical induction variable; which starts at zero and steps by one.; * The canonical induction variable is guaranteed to be the first PHI node in; the loop header block.; * Any pointer arithmetic recurrences are raised to use array subscripts. If the trip count of a loop is computable, this pass also makes the following; changes:. * The exit condition for the loop is canonicalized to compare the induction; value against the exit value. This turns loops like:. .. code-block:: c++. for (i = 7; i*i < 1000; ++i). into. .. code-block:: c++. for (i = 0; i != 25; ++i). * Any use outside of the loop of an expression derived from the indvar is; changed to compute the derived value outside of the loop, eliminating the; dependence on the exit value of the ind",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Passes.rst:17742,simpl,simpler,17742,interpreter/llvm-project/llvm/docs/Passes.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Passes.rst,1,['simpl'],['simpler']
Usability,"igned with the local coordinates;; - Algorithms for dividing the shape along a given axis. The modeller currently provides a set of 20 basic shapes, which we will; call `primitives`. It also provides a special class allowing the; creation of shapes as a result of Boolean operations between primitives.; These are called `composite shapes` and the composition operation can be; recursive (combined composites). This allows the creation of a quite; large number of different shape topologies and combinations. You can; have a look and run the tutorial: geodemo.C. \image html geom_primitive_shapes.png Primitive Shapes - the general inheritance scheme. Shapes are named objects and all primitives have constructors like:. ~~~ {.cpp}; TGeoXXX(const char *name,<type> param1,<type> param2, ...);; TGeoXXX(<type> param1,<type> param2, ...);; ~~~. Naming shape primitive is mandatory only for the primitives used in; Boolean composites (see ""Composite Shapes""). For the sake of simplicity,; we will describe only the constructors in the second form. \anchor SHAPES01; ### Primitive Shapes. - Boxes: TGeoBBox class; - Parallelepiped: TGeoPara class; - Trapezoids: TGeoTrd1, TGeoTrd2 classes; - General Trapezoid: TGeoTrap class; - Twisted Trapezoid: TGeoGtra class; - Arbitrary 8 vertices shapes: TGeoArb8 class; - Tubes: TGeoTube class; - Tube Segments: TGeoTubeSeg class; - Cut Tubes: TGeoCtub class; - Elliptical Tubes: TGeoEltu class; - Hyperboloids: TGeoHype class; - Cones: TGeoCone class; - Cone Segments: TGeoConeSeg class; - Sphere: TGeoSphere class; - Torus: TGeoTorus class; - Paraboloid: TGeoParaboloid class; - Polycone: TGeoPcon class; - Polygon: TGeoPgon class; - Polygonal extrusion: TGeoXtru class; - Half Spaces: TGeoHalfSpace class; - Composite Shapes: TGeoCompositeShape class. \anchor SHAPES02; ### Navigation Methods Performed By Shapes. Shapes are named objects and register themselves to the `manager class`; at creation time. This is responsible for their final deletion. Shapes; c",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/shapes.md:2294,simpl,simplicity,2294,geom/geom/doc/shapes.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/shapes.md,1,['simpl'],['simplicity']
Usability,"ild the plugin, and then call clang with the plugin from the; source tree:. .. code-block:: console. $ export BD=/path/to/build/directory; $ (cd $BD && make PrintFunctionNames ); $ clang++ -D_GNU_SOURCE -D_DEBUG -D__STDC_CONSTANT_MACROS \; -D__STDC_FORMAT_MACROS -D__STDC_LIMIT_MACROS -D_GNU_SOURCE \; -I$BD/tools/clang/include -Itools/clang/include -I$BD/include -Iinclude \; tools/clang/tools/clang-check/ClangCheck.cpp -fsyntax-only \; -Xclang -load -Xclang $BD/lib/PrintFunctionNames.so -Xclang \; -plugin -Xclang print-fns. Also see the print-function-name plugin example's; `README <https://github.com/llvm/llvm-project/blob/main/clang/examples/PrintFunctionNames/README.txt>`_. Using the clang command line; ----------------------------. Using `-fplugin=plugin` on the clang command line passes the plugin; through as an argument to `-load` on the cc1 command line. If the plugin; class implements the ``getActionType`` method then the plugin is run; automatically. For example, to run the plugin automatically after the main AST; action (i.e. the same as using `-add-plugin`):. .. code-block:: c++. // Automatically run the plugin after the main AST action; PluginASTAction::ActionType getActionType() override {; return AddAfterMainAction;; }. Interaction with ``-clear-ast-before-backend``; ----------------------------------------------. To reduce peak memory usage of the compiler, plugins are recommended to run; *before* the main action, which is usually code generation. This is because; having any plugins that run after the codegen action automatically turns off; ``-clear-ast-before-backend``. ``-clear-ast-before-backend`` reduces peak; memory by clearing the Clang AST after generating IR and before running IR; optimizations. Use ``CmdlineBeforeMainAction`` or ``AddBeforeMainAction`` as; ``getActionType`` to run plugins while still benefitting from; ``-clear-ast-before-backend``. Plugins must make sure not to modify the AST,; otherwise they should run after the main action. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangPlugins.rst:7259,clear,clear-ast-before-backend,7259,interpreter/llvm-project/clang/docs/ClangPlugins.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangPlugins.rst,5,['clear'],"['clear-ast-before-backend', 'clearing']"
Usability,"ilders are; constructed explicitly. In general, ``Stencil``\ s produce text from a match result. So, they are not; limited to generating source code, but can also be used to generate diagnostic; messages that reference (named) elements of the matched code, like we saw in the; example of rewriting method calls. Further details of the ``Stencil`` type are documented in the header file; `clang/Tooling/Transformer/Stencil.h <https://github.com/llvm/llvm-project/blob/main/clang/include/clang/Tooling/Transformer/Stencil.h>`_. Edits; ^^^^^. Transformer supports additional forms of edits. First, in a ``changeTo``, we can; specify the particular portion of code to be replaced, using the same; ``RangeSelector`` we saw earlier. For example, we could change the function name; in a function declaration with:. .. code-block:: c++. makeRule(functionDecl(hasName(""bad"")).bind(f),; 	 changeTo(name(f), cat(""good"")),; 	 cat(""bad is now good""));. We also provide simpler editing primitives for insertion and deletion:; ``insertBefore``, ``insertAfter`` and ``remove``. These can all be found in the header; file; `clang/Tooling/Transformer/RewriteRule.h <https://github.com/llvm/llvm-project/blob/main/clang/include/clang/Tooling/Transformer/RewriteRule.h>`_. We are not limited one edit per match found. Some situations require making; multiple edits for each match. For example, suppose we wanted to swap two; arguments of a function call. For this, we provide an overload of ``makeRule`` that takes a list of edits,; rather than just a single one. Our example might look like:. .. code-block:: c++. makeRule(callExpr(...),; 	 {changeTo(node(arg0), cat(node(arg2))),; 	 changeTo(node(arg2), cat(node(arg0)))},; 	 cat(""swap the first and third arguments of the call""));. ``EditGenerator``\ s (Advanced); ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. The particular edits we've seen so far are all instances of the ``ASTEdit`` class,; or a list of such. But, not all edits can be expressed as ``ASTEdit``\ s. So, we; als",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangTransformerTutorial.rst:12781,simpl,simpler,12781,interpreter/llvm-project/clang/docs/ClangTransformerTutorial.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangTransformerTutorial.rst,1,['simpl'],['simpler']
Usability,"iler it is generally advised to perform a; bootstrap build of the compiler. That means building a ""stage 1"" compiler with; your host toolchain, then building the ""stage 2"" compiler using the ""stage 1""; compiler. This is done so that the compiler you distribute benefits from all the; bug fixes, performance optimizations and general improvements provided by the; new compiler. In deciding how to build your distribution there are a few trade-offs that you; will need to evaluate. The big two are:. #. Compile time of the distribution against performance of the built compiler. #. Binary size of the distribution against performance of the built compiler. The guidance for maximizing performance of the generated compiler is to use LTO,; PGO, and statically link everything. This will result in an overall larger; distribution, and it will take longer to generate, but it provides the most; opportunity for the compiler to optimize. The guidance for minimizing distribution size is to dynamically link LLVM and; Clang libraries into the tools to reduce code duplication. This will come at a; substantial performance penalty to the generated binary both because it reduces; optimization opportunity, and because dynamic linking requires resolving symbols; at process launch time, which can be very slow for C++ code. .. _shared_libs:. .. warning::; One very important note: Distributions should never be built using the; *BUILD_SHARED_LIBS* CMake option. That option exists for optimizing developer; workflow only. Due to design and implementation decisions, LLVM relies on; global data which can end up being duplicated across shared libraries; resulting in bugs. As such this is not a safe way to distribute LLVM or; LLVM-based tools. The simplest example of building a distribution with reasonable performance is; captured in the DistributionExample CMake cache file located at; clang/cmake/caches/DistributionExample.cmake. The following command will perform; and install the distribution build:. .",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/BuildingADistribution.rst:1691,guid,guidance,1691,interpreter/llvm-project/llvm/docs/BuildingADistribution.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/BuildingADistribution.rst,1,['guid'],['guidance']
Usability,"ile} 'pr-44884-dwarf-gcc.o' -> elf32-littlearm. [001] {CompileUnit} 'pr-44884.cpp'; [002] {Producer} 'GNU C++14 10.2.1 20201103'; [002] 1 {Function} extern not_inlined 'bar' -> 'int'; [003] 1 {Parameter} 'Input' -> 'float'; [003] 1 {Line}; [003] 1 {Line}; [003] 1 {Line}; [002] 3 {Function} extern not_inlined 'foo' -> 'unsigned int'; [003] {Block}; [004] {Block}; [005] 9 {Variable} 'Added' -> 'FLOAT'; [005] 9 {Line}; [005] 9 {Line}; [005] 9 {Line}; [005] 10 {Line}; [005] 13 {Line}; [004] 7 {TypeAlias} 'FLOAT' -> 'float'; [003] 3 {Parameter} 'Param' -> 'char'; [003] 4 {TypeAlias} 'INT' -> 'int'; [003] 5 {Variable} 'Value' -> 'INT'; [003] 3 {Line}; [003] 5 {Line}; [003] 13 {Line}; [003] 14 {Line}; [003] 14 {Line}. From the previous logical views, we can see that the Clang compiler; emits **both typedefs at the same lexical scope (3)**, which is wrong.; GCC and MSVC emit correct lexical scope for both typedefs. Using the :program:`llvm-debuginfo-analyzer` selection facilities, we; can produce a simple tabular output showing just the logical types that; are **Typedef**. .. code-block:: none. llvm-debuginfo-analyzer --attribute=level,format; --output-sort=name; --select-types=Typedef; --report=list; --print=types; pr-44884-*.o. Logical View:; [000] {File} 'pr-44884-codeview-clang.o' -> COFF-x86-64. [001] {CompileUnit} 'pr_44884.cpp'; [003] {TypeAlias} 'FLOAT' -> 'float'; [003] {TypeAlias} 'INT' -> 'int'. Logical View:; [000] {File} 'pr-44884-codeview-msvc.o' -> COFF-i386. [001] {CompileUnit} 'pr_44884.cpp'; [004] {TypeAlias} 'FLOAT' -> 'float'; [003] {TypeAlias} 'INT' -> 'int'. Logical View:; [000] {File} 'pr-44884-dwarf-clang.o' -> elf64-x86-64. [001] {CompileUnit} 'pr_44884.cpp'; [003] 7 {TypeAlias} 'FLOAT' -> 'float'; [003] 4 {TypeAlias} 'INT' -> 'int'. Logical View:; [000] {File} 'pr-44884-dwarf-gcc.o' -> elf32-littlearm. [001] {CompileUnit} 'pr_44884.cpp'; [004] 7 {TypeAlias} 'FLOAT' -> 'float'; [003] 4 {TypeAlias} 'INT' -> 'int'. It also shows, that the CodeView debu",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-debuginfo-analyzer.rst:40861,simpl,simple,40861,interpreter/llvm-project/llvm/docs/CommandGuide/llvm-debuginfo-analyzer.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-debuginfo-analyzer.rst,1,['simpl'],['simple']
Usability,"ill in progress, results in the blog post show that; ThinLTO already performs well compared to LTO, in many cases matching; the performance improvement. Current Status; ==============. Clang/LLVM; ----------; .. _compiler:. The 3.9 release of clang includes ThinLTO support. However, ThinLTO; is under active development, and new features, improvements and bugfixes; are being added for the next release. For the latest ThinLTO support,; `build a recent version of clang and LLVM; <https://llvm.org/docs/CMake.html>`_. Linkers; -------; .. _linkers:; .. _linker:. ThinLTO is currently supported for the following linkers:. - **gold (via the gold-plugin)**:; Similar to monolithic LTO, this requires using; a `gold linker configured with plugins enabled; <https://llvm.org/docs/GoldPlugin.html>`_.; - **ld64**:; Starting with `Xcode 8 <https://developer.apple.com/xcode/>`_.; - **lld**:; Starting with r284050 for ELF, r298942 for COFF. Usage; =====. Basic; -----. To utilize ThinLTO, simply add the -flto=thin option to compile and link. E.g. .. code-block:: console. % clang -flto=thin -O2 file1.c file2.c -c; % clang -flto=thin -O2 file1.o file2.o -o a.out. When using lld-link, the -flto option need only be added to the compile step:. .. code-block:: console. % clang-cl -flto=thin -O2 -c file1.c file2.c; % lld-link /out:a.exe file1.obj file2.obj. As mentioned earlier, by default the linkers will launch the ThinLTO backend; threads in parallel, passing the resulting native object files back to the; linker for the final native link. As such, the usage model is the same as; non-LTO. With gold, if you see an error during the link of the form:. .. code-block:: console. /usr/bin/ld: error: /path/to/clang/bin/../lib/LLVMgold.so: could not load plugin library: /path/to/clang/bin/../lib/LLVMgold.so: cannot open shared object file: No such file or directory. Then either gold was not configured with plugins enabled, or clang; was not built with ``-DLLVM_BINUTILS_INCDIR`` set properly. See; th",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThinLTO.rst:2481,simpl,simply,2481,interpreter/llvm-project/clang/docs/ThinLTO.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThinLTO.rst,1,['simpl'],['simply']
Usability,"ime to time. Such new versions will; be similar in spirit to the present version, but may differ in detail to; address new problems or concerns. Each version is given a distinguishing version number. If the Program; specifies a version number of this License which applies to it and ""any; later version"", you have the option of following the terms and conditions; either of that version or of any later version published by the Free; Software Foundation. If the Program does not specify a version number of; this License, you may choose any version ever published by the Free Software; Foundation. 10. If you wish to incorporate parts of the Program into other free; programs whose distribution conditions are different, write to the author; to ask for permission. For software which is copyrighted by the Free; Software Foundation, write to the Free Software Foundation; we sometimes; make exceptions for this. Our decision will be guided by the two goals; of preserving the free status of all derivatives of our free software and; of promoting the sharing and reuse of software generally. NO WARRANTY. 11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY; FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW. EXCEPT WHEN; OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES; PROVIDE THE PROGRAM ""AS IS"" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED; OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF; MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE ENTIRE RISK AS; TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU. SHOULD THE; PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING,; REPAIR OR CORRECTION. 12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING; WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR; REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES,; INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARI",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/misc/rootql/LICENSE.txt:13608,guid,guided,13608,misc/rootql/LICENSE.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/misc/rootql/LICENSE.txt,2,['guid'],['guided']
Usability,"imple: they are fixed strings that; must occur in order. FileCheck defaults to ignoring horizontal whitespace; differences (e.g. a space is allowed to match a tab) but otherwise, the contents; of the ""``CHECK:``"" line is required to match some thing in the test file exactly. One nice thing about FileCheck (compared to grep) is that it allows merging; test cases together into logical groups. For example, because the test above; is checking for the ""``sub1:``"" and ""``inc4:``"" labels, it will not match; unless there is a ""``subl``"" in between those labels. If it existed somewhere; else in the file, that would not count: ""``grep subl``"" matches if ""``subl``""; exists anywhere in the file. The FileCheck -check-prefix option; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. The FileCheck `-check-prefix` option allows multiple test; configurations to be driven from one `.ll` file. This is useful in many; circumstances, for example, testing different architectural variants with; :program:`llc`. Here's a simple example:. .. code-block:: llvm. ; RUN: llvm-as < %s | llc -mtriple=i686-apple-darwin9 -mattr=sse41 \; ; RUN: | FileCheck %s -check-prefix=X32; ; RUN: llvm-as < %s | llc -mtriple=x86_64-apple-darwin9 -mattr=sse41 \; ; RUN: | FileCheck %s -check-prefix=X64. define <4 x i32> @pinsrd_1(i32 %s, <4 x i32> %tmp) nounwind {; %tmp1 = insertelement <4 x i32>; %tmp, i32 %s, i32 1; ret <4 x i32> %tmp1; ; X32: pinsrd_1:; ; X32: pinsrd $1, 4(%esp), %xmm0. ; X64: pinsrd_1:; ; X64: pinsrd $1, %edi, %xmm0; }. In this case, we're testing that we get the expected code generation with; both 32-bit and 64-bit code generation. The ""COM:"" directive; ~~~~~~~~~~~~~~~~~~~~. Sometimes you want to disable a FileCheck directive without removing it; entirely, or you want to write comments that mention a directive by name. The; ""``COM:``"" directive makes it easy to do this. For example, you might have:. .. code-block:: llvm. ; X32: pinsrd_1:; ; X32: pinsrd $1, 4(%esp), %xmm0. ; COM: FIXME: X64 isn't working corr",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/FileCheck.rst:10135,simpl,simple,10135,interpreter/llvm-project/llvm/docs/CommandGuide/FileCheck.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/FileCheck.rst,1,['simpl'],['simple']
Usability,"improvements in the experimental Intel DAOS backend. - `RNTupleWriter::Fill()` now returns the number of uncompressed bytes written, which is align with TTree behavior. - Support for user-defined classes that behave as a collection via the `TVirtualCollectionProxy` interface.; Fields created via `RFieldBase::Create()` automatically detect the presence of a collection proxy at run-time. However, if `RField<T>` (`T` being a class) is used instead, the trait `IsCollectionProxy<T>` must be set for the given type (see PR [#11525](https://github.com/root-project/root/pull/11525) for details).; Note that associative collections are not yet supported. - Some internal support for per field post-read callbacks. This functionality will be presented in upcoming releases through custom I/O rules. Please, report any issues regarding the abovementioned features should you encounter them.; RNTuple is still experimental and is scheduled to become production grade in 2024. Thus, we appreciate feedback and suggestions for improvement. ## RDataFrame. ### New features. - Add [`GraphAsymmErrors`](https://root.cern/doc/master/classROOT_1_1RDF_1_1RInterface.html#acea30792eef607489d498bf6547a00a6) action that fills a TGraphAsymmErrors object.; - Introduce [`RDatasetSpec`](https://root.cern/doc/master/classROOT_1_1RDF_1_1Experimental_1_1RDatasetSpec.html) as an; experimental class to specify the input dataset to an RDataFrame.; - Arbitrary metadata can be associated to the samples in the dataset specified via `RDatasetSpect`. The metadata of each; sample can then be retrieved during the execution by calling `DefinePerSample`.; - Users can create an RDataFrame with a dataset specification written in a JSON file via the factory function; [ROOT::RDF::Experimental::FromSpec](https://root.cern/doc/master/namespaceROOT_1_1RDF_1_1Experimental.html#a7193987f3c1b65c649399656cc6acce8). ### Notable bug fixes and improvements. - Fix the node counter of [`SaveGraph`](https://root.cern/doc/master/namespac",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v628/index.md:10634,feedback,feedback,10634,README/ReleaseNotes/v628/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v628/index.md,1,['feedback'],['feedback']
Usability,"in a; unique section. It will also place all basic blocks of functions ``bar``; in unique sections. Further, section clusters can also be specified using the ``list=<arg>``; option. For example, ``list=spec.txt`` where ``spec.txt`` contains:. ::. !foo; !!1 !!3 !!5; !!2 !!4 !!6. will create two unique sections for function ``foo`` with the first; containing the odd numbered basic blocks and the second containing the; even numbered basic blocks. Basic block sections allow the linker to reorder basic blocks and enables; link-time optimizations like whole program inter-procedural basic block; reordering. Profile Guided Optimization; ---------------------------. Profile information enables better optimization. For example, knowing that a; branch is taken very frequently helps the compiler make better decisions when; ordering basic blocks. Knowing that a function ``foo`` is called more; frequently than another function ``bar`` helps the inliner. Optimization; levels ``-O2`` and above are recommended for use of profile guided optimization. Clang supports profile guided optimization with two different kinds of; profiling. A sampling profiler can generate a profile with very low runtime; overhead, or you can build an instrumented version of the code that collects; more detailed profile information. Both kinds of profiles can provide execution; counts for instructions in the code and information on branches taken and; function invocation. Regardless of which kind of profiling you use, be careful to collect profiles; by running your code with inputs that are representative of the typical; behavior. Code that is not exercised in the profile will be optimized as if it; is unimportant, and the compiler may make poor optimization choices for code; that is disproportionately used while profiling. Differences Between Sampling and Instrumentation; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Although both techniques are used for similar purposes, there are important; differences ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:89978,guid,guided,89978,interpreter/llvm-project/clang/docs/UsersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst,1,['guid'],['guided']
Usability,"in batch:; ; {; TCanvas *canvas = new TCanvas(""c5"",""c5"",900,900);; TH1F *histo = new TH1F(""Histo"",""123456x_{i}abcdefy^{2}"",100,0,20);; canvas->Print(""drawing.gif"");; }; ; Suppress annoying messages like:; ; root : looking for image ""filename"" in path [/home/username/icons]; ; printed by libAfterImage when using TImage::Open(""filename""); In TImageDump the hollow filled areas were not correct:; ; they used the line attributes,; a line was drawn around the polygons filled with patterns. This fixes the problem mentionned here:; https://savannah.cern.ch/bugs/index.php?59263; as well as the test #22 in stressGraphics (no need to change; the reference file). Interface to graphviz. Thanks to three new classes (TGraphStruct, TGraphNode and; TGraphEdge) ROOT provides; an interface to the graphs visualization package graphviz. Graph; visualization is a way of representing structural information as diagrams of; abstract graphs and networks. Example:. The previous image is produced by the following ROOT macro:; ; // Draw a simple graph structure.; // The graph layout is made using graphviz. This macro creates some; // nodes and edges and change a few graphical attributes on some of them.; // Author: Olivier Couet; {; TGraphStruct *gs = new TGraphStruct();. // create some nodes and put them in the graph in one go ...; TGraphNode *n0 = gs->AddNode(""n0"",""Node 0"");; TGraphNode *n1 = gs->AddNode(""n1"",""First node"");; TGraphNode *n2 = gs->AddNode(""n2"",""Second node"");; TGraphNode *n3 = gs->AddNode(""n3"",""Third node"");; TGraphNode *n4 = gs->AddNode(""n4"",""Fourth node"");; TGraphNode *n5 = gs->AddNode(""n5"",""5th node"");; TGraphNode *n6 = gs->AddNode(""n6"",""Node number six"");; TGraphNode *n7 = gs->AddNode(""n7"",""Node 7"");; TGraphNode *n8 = gs->AddNode(""n8"",""Node 8"");; TGraphNode *n9 = gs->AddNode(""n9"",""Node 9"");. n4->SetTextSize(0.03);; n6->SetTextSize(0.03);; n2->SetTextSize(0.04);. n3->SetTextFont(132);. n0->SetTextColor(kRed);. n9->SetFillColor(kRed-10);; n0->SetFillColor(kYellow-9);; n7->SetF",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/doc/v526/index.html:1797,simpl,simple,1797,graf2d/doc/v526/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/doc/v526/index.html,1,['simpl'],['simple']
Usability,"in one of these modifiers:. - - `%txt` : to print the text label associated with the slice. - - `%val` : to print the numeric value of the slice. - - `%frac` : to print the relative fraction of this slice. - - `%perc` : to print the % of this slice. ``` {.cpp}; mypie->SetLabelFormat(""%txt (%frac)"");; ```. See the macro `$ROOTSYS/tutorials/graphics/piechart.C` . ![The picture generated by tutorial macro piechart.C](pictures/03000042.png). ## The User Interface for Histograms. The classes **`T`** **`H1`** **`Editor`** and **`T`** **`H2`**; **`Editor`** provides the user interface for setting histogram's; attributes and rebinning interactively. ### TH1Editor. ![](pictures/03000043.png). #### The Style Tab. ##### Title. sets the title of the histogram. ##### Plot. draw a 2D or 3D plot; according to the dimension, different drawing; possibilities can be set. ##### Error; add different error bars to the histogram (no errors, simple, etc.). ##### Add; further things which can be added to the histogram (None,; simple/smooth line, fill area, etc.). #### 2-D Plot. ##### Simple Drawing; draw a simple histogram without errors (= ""HIST"" draw; option). In combination with some other draw options an outer line is; drawn on top of the histogram. ##### Show markers; draw a marker on to of each bin (=""P"" draw option). ##### Draw bar chart; draw a bar chart (=""B"" draw option). ##### Bar option; draw a bar chart (=""BAR"" draw option); if selected, it will; show an additional interface elements for bars: width, offset,; percentage and the possibility to draw horizontal bars. #### 3-D Plot. ##### Add; set histogram type Lego-Plot or Surface draw (Lego, Lego1.2, Surf,; Surf1...5). ##### Coords; set the coordinate system (Cartesian, Spheric, etc.). ##### Error; same as for 2D plot. ##### Bar; set the bar attributes: width and offset. ##### Horizontal Bar; draw a horizontal bar chart. #### The Binning tab; The binning tab has two different layouts. One is for a histogram,; which is not drawn",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md:71865,simpl,simple,71865,documentation/users-guide/Histograms.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md,1,['simpl'],['simple']
Usability,"in the frame; co_await await_counter{};; a = load __int_32_0; std::cout << a+1 << ""\n"";; std::cout << a+2 << ""\n"";; std::cout << a+3 << ""\n"";; co_await await_counter{};; a = load __int_32_0; std::cout << a+4 << ""\n"";; std::cout << a+5 << ""\n"";; }. It should now be obvious why the value of `__int_32_0` remains unchanged; throughout the function. It is important to recognize that `__int_32_0`; does not directly correspond to `a`, but is instead a variable generated; to assist the compiler in code generation. The variables in an optimized; coroutine frame should not be thought of as directly representing the; variables in the C++ source. Get the suspended points; ========================. An important requirement for debugging coroutines is to understand suspended; points, which are where the coroutine is currently suspended and awaiting. For simple cases like the above, inspecting the value of the `__coro_index`; variable in the coroutine frame works well. However, it is not quite so simple in really complex situations. In these; cases, it is necessary to use the coroutine libraries to insert the; line-number. For example:. .. code-block:: c++. // For all the promise_type we want:; class promise_type {; ...; + unsigned line_number = 0xffffffff;; };. #include <source_location>. // For all the awaiter types we need:; class awaiter {; ...; template <typename Promise>; void await_suspend(std::coroutine_handle<Promise> handle,; std::source_location sl = std::source_location::current()) {; ...; handle.promise().line_number = sl.line();; }; };. In this case, we use `std::source_location` to store the line number of the; await inside the `promise_type`. Since we can locate the coroutine function; from the address of the coroutine, we can identify suspended points this way; as well. The downside here is that this comes at the price of additional runtime cost.; This is consistent with the C++ philosophy of ""Pay for what you use"". Get the asynchronous stack; =====================",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DebuggingCoroutines.rst:10805,simpl,simple,10805,interpreter/llvm-project/clang/docs/DebuggingCoroutines.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DebuggingCoroutines.rst,1,['simpl'],['simple']
Usability,"in; Python via ""import KF5.Config"".; * The bindings are loaded lazily, which limits the discoverability of the; content of the bindings.; * ``cppyy`` supports customization of the bindings via 'Pythonization' but; there is no automated way to load them. These issues are addressed by the CMake support. This is a blend of Python; packaging and CMake where CMake provides:. * Platform-independent scripting of the creation of a Python 'wheel' package; for the bindings.; * An facility for CMake-based projects to automate the entire bindings; generation process, including basic automated tests. .. note::. The JIT needs to resolve linker symbols in order to call them through; generated wrappers.; Thus, any classes, functions, and data that will be used in Python need; to be exported.; This is the default behavior on Mac and Linux, but not on Windows.; On that platform, use ``__declspec(dllexport)`` to explicitly export the; classes and function you expect to call.; CMake has simple `support for exporting all`_ C++ symbols. Python packaging; ----------------. Modern Python packaging usage is based on the 'wheel'. This is places the onus; on the creation of binary artifacts in the package on the distributor. In this; case, this includes the platform-dependent steps necessary to compile the .cpp; file. The generated package also takes advantage of the __init__.py load-time; mechanism to enhance the bindings:. * The bindings are rehosted in a ""native"" namespace so that C++ code from; KF5::Config appears in Python via ""import KF5.Config"".; * (TBD) Load Pythonizations. Both of these need/can use the output of the; :ref:`cppyy-generator <cppyy-generator>` (included in the package) as well as; other runtime support included in ``cppyy``. CMake usage; -----------. The CMake usage is via two modules:. * FindLibClang.cmake provides some bootstrap support needed to locate clang.; This is provided mostly as a temporary measure; hopefully upstream support; will allow this to be eliminate",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/cmake_interface.rst:1571,simpl,simple,1571,bindings/pyroot/cppyy/cppyy/doc/source/cmake_interface.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/cmake_interface.rst,1,['simpl'],['simple']
Usability,"inatorTree`` is called by pass; manager before returning a reference to the desired pass. If your pass is capable of updating analyses if they exist (e.g.,; ``BreakCriticalEdges``, as described above), you can use the; ``getAnalysisIfAvailable`` method, which returns a pointer to the analysis if; it is active. For example:. .. code-block:: c++. if (DominatorSet *DS = getAnalysisIfAvailable<DominatorSet>()) {; // A DominatorSet is active. This code will update it.; }. Implementing Analysis Groups; ----------------------------. Now that we understand the basics of how passes are defined, how they are used,; and how they are required from other passes, it's time to get a little bit; fancier. All of the pass relationships that we have seen so far are very; simple: one pass depends on one other specific pass to be run before it can; run. For many applications, this is great, for others, more flexibility is; required. In particular, some analyses are defined such that there is a single simple; interface to the analysis results, but multiple ways of calculating them.; Consider alias analysis for example. The most trivial alias analysis returns; ""may alias"" for any alias query. The most sophisticated analysis a; flow-sensitive, context-sensitive interprocedural analysis that can take a; significant amount of time to execute (and obviously, there is a lot of room; between these two extremes for other implementations). To cleanly support; situations like this, the LLVM Pass Infrastructure supports the notion of; Analysis Groups. Analysis Group Concepts; ^^^^^^^^^^^^^^^^^^^^^^^. An Analysis Group is a single simple interface that may be implemented by; multiple different passes. Analysis Groups can be given human readable names; just like passes, but unlike passes, they need not derive from the ``Pass``; class. An analysis group may have one or more implementations, one of which is; the ""default"" implementation. Analysis groups are used by client passes just like other passes a",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/WritingAnLLVMPass.rst:35071,simpl,simple,35071,interpreter/llvm-project/llvm/docs/WritingAnLLVMPass.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/WritingAnLLVMPass.rst,1,['simpl'],['simple']
Usability,"include(LLVMExternalProjectUtils). set(CLANG_PGO_TRAINING_DATA ""${CMAKE_CURRENT_SOURCE_DIR}"" CACHE PATH; ""The path to a lit testsuite containing samples for PGO and order file generation""; ); set(CLANG_PGO_TRAINING_DATA_SOURCE_DIR OFF CACHE STRING ""Path to source directory containing cmake project with source files to use for generating pgo data""); set(CLANG_PGO_TRAINING_DEPS """" CACHE STRING ""Extra dependencies needed to build the PGO training data.""). if(LLVM_BUILD_INSTRUMENTED); configure_lit_site_cfg(; ${CMAKE_CURRENT_SOURCE_DIR}/lit.site.cfg.in; ${CMAKE_CURRENT_BINARY_DIR}/pgo-data/lit.site.cfg; ). add_lit_testsuite(generate-profraw ""Generating clang PGO data""; ${CMAKE_CURRENT_BINARY_DIR}/pgo-data/; EXCLUDE_FROM_CHECK_ALL; DEPENDS clang clear-profraw ${CLANG_PGO_TRAINING_DEPS}; ). add_custom_target(clear-profraw; COMMAND ""${Python3_EXECUTABLE}"" ${CMAKE_CURRENT_SOURCE_DIR}/perf-helper.py clean ${CMAKE_CURRENT_BINARY_DIR} ${CMAKE_BINARY_DIR}/profiles/ profraw; COMMENT ""Clearing old profraw data""). if(NOT LLVM_PROFDATA); find_program(LLVM_PROFDATA llvm-profdata); endif(). if(NOT LLVM_PROFDATA); message(STATUS ""To enable merging PGO data LLVM_PROFDATA has to point to llvm-profdata""); else(); add_custom_target(generate-profdata; COMMAND ""${Python3_EXECUTABLE}"" ${CMAKE_CURRENT_SOURCE_DIR}/perf-helper.py merge ${LLVM_PROFDATA} ${CMAKE_CURRENT_BINARY_DIR}/clang.profdata ${CMAKE_CURRENT_BINARY_DIR} ${CMAKE_BINARY_DIR}/profiles/; COMMENT ""Merging profdata""; DEPENDS generate-profraw); if (CLANG_PGO_TRAINING_DATA_SOURCE_DIR); llvm_ExternalProject_Add(generate-profraw-external ${CLANG_PGO_TRAINING_DATA_SOURCE_DIR}; USE_TOOLCHAIN EXLUDE_FROM_ALL NO_INSTALL DEPENDS generate-profraw); add_dependencies(generate-profdata generate-profraw-external); endif(); endif(); endif(). find_program(DTRACE dtrace); # TODO: Look into supporting this for the driver build. It will require changing; # the perf-helper.py file to understand to call `llvm` as `llvm clang`.; if(APPLE AND DTRACE AND N",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/perf-training/CMakeLists.txt:751,clear,clear-profraw,751,interpreter/llvm-project/clang/utils/perf-training/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/perf-training/CMakeLists.txt,2,['clear'],['clear-profraw']
Usability,"include`` directives for headers that they actually depend on. As with the problem of conflicting definitions, this only affects unlucky users who don't happen to include headers in the right order. With modules, the headers of a particular module will be parsed in isolation, so the module may fail to build if there are missing includes. **Headers that vend multiple APIs at different times**; Some systems have headers that contain a number of different kinds of API definitions, only some of which are made available with a given include. For example, the header may vend ``size_t`` only when the macro ``__need_size_t`` is defined before that header is included, and also vend ``wchar_t`` only when the macro ``__need_wchar_t`` is defined. Such headers are often included many times in a single translation unit, and will have no include guards. There is no sane way to map this header to a submodule. One can either eliminate the header (e.g., by splitting it into separate headers, one per actual API) or simply ``exclude`` it in the module map. To detect and help address some of these problems, the ``clang-tools-extra`` repository contains a ``modularize`` tool that parses a set of given headers and attempts to detect these problems and produce a report. See the tool's in-source documentation for information on how to check your system or library headers. Future Directions; =================; Modules support is under active development, and there are many opportunities remaining to improve it. Here are a few ideas:. **Detect unused module imports**; Unlike with ``#include`` directives, it should be fairly simple to track whether a directly-imported module has ever been used. By doing so, Clang can emit ``unused import`` or ``unused #include`` diagnostics, including Fix-Its to remove the useless imports/includes. **Fix-Its for missing imports**; It's fairly common for one to make use of some API while writing code, only to get a compiler error about ""unknown type"" or ""no fun",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst:55653,simpl,simply,55653,interpreter/llvm-project/clang/docs/Modules.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst,1,['simpl'],['simply']
Usability,"includes functions, constant global variables, and the null pointer.; Locally-invariant memory is memory that we know is invariant for the lifetime; of its SSA value, but not necessarily for the life of the program: for example,; the memory pointed to by ``readonly`` ``noalias`` parameters is known-invariant; for the duration of the corresponding function call. Given Mod/Ref information; ``MRI`` for a memory location ``Loc``, ``MRI`` can be refined with a statement; like ``MRI &= AA.getModRefInfoMask(Loc);``. Another useful idiom is; ``isModSet(AA.getModRefInfoMask(Loc))``; this checks to see if the given; location can be modified at all. For convenience, there is also a method; ``pointsToConstantMemory(Loc)``; this is synonymous with; ``isNoModRef(AA.getModRefInfoMask(Loc))``. .. _never access memory or only read memory:. The ``doesNotAccessMemory`` and ``onlyReadsMemory`` methods; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. These methods are used to provide very simple mod/ref information for function; calls. The ``doesNotAccessMemory`` method returns true for a function if the; analysis can prove that the function never reads or writes to memory, or if the; function only reads from constant memory. Functions with this property are; side-effect free and only depend on their input arguments, allowing them to be; eliminated if they form common subexpressions or be hoisted out of loops. Many; common functions behave this way (e.g., ``sin`` and ``cos``) but many others do; not (e.g., ``acos``, which modifies the ``errno`` variable). The ``onlyReadsMemory`` method returns true for a function if analysis can prove; that (at most) the function only reads from non-volatile memory. Functions with; this property are side-effect free, only depending on their input arguments and; the state of memory when they are called. This property allows calls to these; functions to be eliminated and moved around, as long as there is no store; instruction that changes the",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst:8359,simpl,simple,8359,interpreter/llvm-project/llvm/docs/AliasAnalysis.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst,1,['simpl'],['simple']
Usability,"indows. 1. Download binary win32 build like https://cef-builds.spotifycdn.com/cef_binary_95.7.12%2Bg99c4ac0%2Bchromium-95.0.4638.54_windows32.tar.bz2. 2. Extract in directory without spaces like `C:\Soft\cef`. 3. Modify `cmake/cef_variables.cmake` to set dynamic linking, replace ""/MT"" by ""/MD"" in approx line 389. 4. Start ""x86 Native tools Command Prompt for VS 2019"". Do:; ~~~; $ cd C:\Soft\cef; $ mkdir build; $ cd build; $ cmake -G""Visual Studio 16 2019"" -A Win32 -Thost=x64 ..; $ cmake --build . --config Release --target libcef_dll_wrapper; ~~~. 5. Before compiling ROOT, `set CEF_ROOT=C:\Soft\cef` variable. ## Using plain CEF in ROOT batch mode on Linux. Default CEF builds, provided by [https://cef-builds.spotifycdn.com/index.html](https://cef-builds.spotifycdn.com/index.html), do; not include support of Ozone framework, which the only support headless mode in CEF. To run ROOT in headless (or batch) made with such CEF distribution,; one can use `Xvfb` server. Most simple way is to use `xvfb-run` utility like:. ~~~; $ xvfb-run --server-args='-screen 0, 1024x768x16' root.exe -l --web=cef $ROOTSYS/tutorials/rcanvas/rline.cxx -q; ~~~. Or run `Xvfb` before starting ROOT:. ~~~; $ Xvfb :99 &; $ export DISPLAY=:99; $ root.exe -l --web=cef $ROOTSYS/tutorials/rcanvas/rline.cxx -q; ~~~. ## Compile CEF with ozone support. Since March 2019 one can compile [CEF without X11](https://bitbucket.org/chromiumembedded/cef/issues/2296/), but such builds not provided.; Therefore to be able to use real headless mode in CEF, one should compile it from sources.; On [CEF build tutorial](https://bitbucket.org/chromiumembedded/cef/wiki/AutomatedBuildSetup.md) one can find complete compilation documentation.; Several Ubuntu distributions are supported by CEF, all others may require extra work. Once all depndencies are installed,; CEF with ozone support can be compiled with following commands:. ~~~; $ export GN_DEFINES=""is_official_build=true use_sysroot=true use_allocator=none symbol_level=1 i",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/cefdisplay/Readme.md:2774,simpl,simple,2774,gui/cefdisplay/Readme.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/cefdisplay/Readme.md,1,['simpl'],['simple']
Usability,"ine XX``"" idiom to prevent multiple; inclusion. If a buffer does, subsequent includes can be ignored if the; ""``XX``"" macro is defined. .. _TokenLexer:. The ``TokenLexer`` class; ------------------------. The ``TokenLexer`` class is a token provider that returns tokens from a list of; tokens that came from somewhere else. It typically used for two things: 1); returning tokens from a macro definition as it is being expanded 2) returning; tokens from an arbitrary buffer of tokens. The later use is used by; ``_Pragma`` and will most likely be used to handle unbounded look-ahead for the; C++ parser. .. _MultipleIncludeOpt:. The ``MultipleIncludeOpt`` class; --------------------------------. The ``MultipleIncludeOpt`` class implements a really simple little state; machine that is used to detect the standard ""``#ifndef XX`` / ``#define XX``""; idiom that people typically use to prevent multiple inclusion of headers. If a; buffer uses this idiom and is subsequently ``#include``'d, the preprocessor can; simply check to see whether the guarding condition is defined or not. If so,; the preprocessor can completely ignore the include of the header. .. _Parser:. The Parser Library; ==================. This library contains a recursive-descent parser that polls tokens from the; preprocessor and notifies a client of the parsing progress. Historically, the parser used to talk to an abstract ``Action`` interface that; had virtual methods for parse events, for example ``ActOnBinOp()``. When Clang; grew C++ support, the parser stopped supporting general ``Action`` clients --; it now always talks to the :ref:`Sema library <Sema>`. However, the Parser; still accesses AST objects only through opaque types like ``ExprResult`` and; ``StmtResult``. Only :ref:`Sema <Sema>` looks at the AST node contents of these; wrappers. .. _AST:. The AST Library; ===============. .. _ASTPhilosophy:. Design philosophy; -----------------. Immutability; ^^^^^^^^^^^^. Clang AST nodes (types, declarations, state",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:56630,simpl,simply,56630,interpreter/llvm-project/clang/docs/InternalsManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst,1,['simpl'],['simply']
Usability,"ine arguments, we need to tell the; system which ones we want, and what type of arguments they are. The CommandLine; library uses a declarative syntax to model command line arguments with the; global variable declarations that capture the parsed values. This means that; for every command line option that you would like to support, there should be a; global variable declaration to capture the result. For example, in a compiler,; we would like to support the Unix-standard '``-o <filename>``' option to specify; where to put the output. With the CommandLine library, this is represented like; this:. .. _scalars arguments:; .. _here:. .. code-block:: c++. cl::opt<string> OutputFilename(""o"", cl::desc(""Specify output filename""), cl::value_desc(""filename""));. This declares a global variable ""``OutputFilename``"" that is used to capture the; result of the ""``o``"" argument (first parameter). We specify that this is a; simple scalar option by using the ""``cl::opt``"" template (as opposed to the; ""``cl::list``"" template), and tell the CommandLine library that the data; type that we are parsing is a string. The second and third parameters (which are optional) are used to specify what to; output for the ""``-help``"" option. In this case, we get a line that looks like; this:. ::. USAGE: compiler [options]. OPTIONS:; -h - Alias for -help; -help - display available options (-help-hidden for more); -o <filename> - Specify output filename. Because we specified that the command line option should parse using the; ``string`` data type, the variable declared is automatically usable as a real; string in all contexts that a normal C++ string object may be used. For; example:. .. code-block:: c++. ...; std::ofstream Output(OutputFilename.c_str());; if (Output.good()) ...; ... There are many different options that you can use to customize the command line; option handling library, but the above example shows the general interface to; these options. The options can be specified in any order, and ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandLine.rst:5286,simpl,simple,5286,interpreter/llvm-project/llvm/docs/CommandLine.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandLine.rst,1,['simpl'],['simple']
Usability,"ine frame to; be available in the continuation function. This frame is stored as a tail to the; `async context`. Every suspend point takes an `context projection function` argument which; describes how-to obtain the continuations `async context` and every suspend; point has an associated `resume function` denoted by the; `llvm.coro.async.resume` intrinsic. The coroutine is resumed by calling this; `resume function` passing the `async context` as the one of its arguments; argument. The `resume function` can restore its (the caller's) `async context`; by applying a `context projection function` that is provided by the frontend as; a parameter to the `llvm.coro.suspend.async` intrinsic. .. code-block:: c. // For example:; struct async_context {; struct async_context *caller_context;; ...; }. char *context_projection_function(struct async_context *callee_ctxt) {; return callee_ctxt->caller_context;; }. .. code-block:: llvm. %resume_func_ptr = call ptr @llvm.coro.async.resume(); call {ptr, ptr, ptr} (ptr, ptr, ...) @llvm.coro.suspend.async(; ptr %resume_func_ptr,; ptr %context_projection_function. The frontend should provide a `async function pointer` struct associated with; each async coroutine by `llvm.coro.id.async`'s argument. The initial size and; alignment of the `async context` must be provided as arguments to the; `llvm.coro.id.async` intrinsic. Lowering will update the size entry with the; coroutine frame requirements. The frontend is responsible for allocating the; memory for the `async context` but can use the `async function pointer` struct; to obtain the required size. .. code-block:: c. struct async_function_pointer {; uint32_t relative_function_pointer_to_async_impl;; uint32_t context_size;; }. Lowering will split an async coroutine into a ramp function and one resume; function per suspend point. How control-flow is passed between caller, suspension point, and back to; resume function is left up to the frontend. The suspend point takes a function and its ar",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst:9244,resume,resume,9244,interpreter/llvm-project/llvm/docs/Coroutines.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst,1,['resume'],['resume']
Usability,"ineType(""electron"", 1);` |; | `cat[""muon""] = 2;` | `cat.defineType(""muon"", 2);` |. See also [Category reference guide](https://root.cern.ch/doc/master/classRooCategory.html). ### Type-safe proxies for RooFit objects; RooFit's proxy classes have been modernised. The class `RooTemplateProxy` allows for access to other RooFit objects; similarly to a smart pointer. In older versions of RooFit, the objects held by *e.g.* `RooRealProxy` had to be; accessed like this:; RooAbsArg* absArg = realProxy.absArg();; RooAbsPdf* pdf = dynamic_cast<RooAbsPdf*>(absArg);; assert(pdf); // This *should* work, but the proxy doesn't have a way to check; pdf->fitTo(...);; That is, a `RooRealProxy` stores a pointer to a RooAbsArg, and this pointer has to be cast. There was no type; safety, *i.e.*, any object deriving from RooAbsArg could be stored in that proxy, and the user had to take care; of ensuring that types are correct.; Now, if one uses; RooTemplateProxy<RooAbsPdf> pdfProxy;; instead of; RooRealProxy realProxy;; in RooFit classes, the above code can be simplified to; pdfProxy->fitTo(...);. Check the [doxygen reference guide](https://root.cern.ch/doc/master/classRooTemplateProxy.html) for `RooTemplateProxy` for; more information on how to modernise old code. ### HistFactory. #### Switch default statistical MC errors to Poisson; When defining HistFactory samples with statistical errors from C++, e.g.; Sample background1( ""background1"", ""background1"", InputFile );; background1.ActivateStatError();; statistical MC errors now have Poisson instead of Gaussian constraints. This better reflects the uncertainty of the MC simulations.; This can be reverted as follows:; // C++:; Channel chan(""channel1"");; chan.SetStatErrorConfig( 0.05, ""Gauss"" );; // Within <Channel ... > XML:; <StatErrorConfig RelErrorThreshold=""0.05"" ConstraintType=""Gauss"" />. #### Less verbose HistFactory; HistFactory was very verbose, writing to the terminal with lots of `cout`. Now, many HistFactory messages are going; in",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v622/index.md:4947,simpl,simplified,4947,README/ReleaseNotes/v622/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v622/index.md,1,['simpl'],['simplified']
Usability,"ined behavior if the coroutine; executes a call to ``llvm.coro.suspend.retcon`` after resuming in any way. Coroutine Transformation Passes; ===============================; CoroEarly; ---------; The pass CoroEarly lowers coroutine intrinsics that hide the details of the; structure of the coroutine frame, but, otherwise not needed to be preserved to; help later coroutine passes. This pass lowers `coro.frame`_, `coro.done`_,; and `coro.promise`_ intrinsics. .. _CoroSplit:. CoroSplit; ---------; The pass CoroSplit builds coroutine frame and outlines resume and destroy parts; into separate functions. CoroElide; ---------; The pass CoroElide examines if the inlined coroutine is eligible for heap; allocation elision optimization. If so, it replaces; `coro.begin` intrinsic with an address of a coroutine frame placed on its caller; and replaces `coro.alloc` and `coro.free` intrinsics with `false` and `null`; respectively to remove the deallocation code.; This pass also replaces `coro.resume` and `coro.destroy` intrinsics with direct; calls to resume and destroy functions for a particular coroutine where possible. CoroCleanup; -----------; This pass runs late to lower all coroutine related intrinsics not replaced by; earlier passes. Attributes; ==========. coro_only_destroy_when_complete; -------------------------------. When the coroutine are marked with coro_only_destroy_when_complete, it indicates; the coroutine must reach the final suspend point when it get destroyed. This attribute only works for switched-resume coroutines now. Metadata; ========. '``coro.outside.frame``' Metadata; ---------------------------------. ``coro.outside.frame`` metadata may be attached to an alloca instruction to; to signify that it shouldn't be promoted to the coroutine frame, useful for; filtering allocas out by the frontend when emitting internal control mechanisms.; Additionally, this metadata is only used as a flag, so the associated; node must be empty. .. code-block:: text. %__coro_gro",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst:57110,resume,resume,57110,interpreter/llvm-project/llvm/docs/Coroutines.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst,1,['resume'],['resume']
Usability,"ined if the object location; description becomes invalid between the two expression evaluations.*. A change of a thread's program location may not make a location description; invalid, yet may still render it as no longer meaningful. Accessing such a; location description, or using it as the object context or initial stack context; of an expression evaluation, may produce an undefined result. *For example, a location description may specify a register that no longer holds; the intended program object after a program location change. One way to avoid; such problems is to recompute location descriptions associated with threads when; their program locations change.*. .. _amdgpu-dwarf-operation-expressions:. A.2.5.4 DWARF Operation Expressions; +++++++++++++++++++++++++++++++++++. An operation expression is comprised of a stream of operations, each consisting; of an opcode followed by zero or more operands. The number of operands is; implied by the opcode. Operations represent a postfix operation on a simple stack machine. Each stack; entry can hold either a value or a location description. Operations can act on; entries on the stack, including adding entries and removing entries. If the kind; of a stack entry does not match the kind required by the operation and is not; implicitly convertible to the required kind (see; :ref:`amdgpu-dwarf-memory-location-description-operations`), then the DWARF; operation expression is ill-formed. Evaluation of an operation expression starts with an empty stack on which the; entries from the initial stack provided by the context are pushed in the order; provided. Then the operations are evaluated, starting with the first operation; of the stream. Evaluation continues until either an operation has an evaluation; error, or until one past the last operation of the stream is reached. The result of the evaluation is:. * If an operation has an evaluation error, or an operation evaluates an; expression that has an evaluation error, then the re",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst:64323,simpl,simple,64323,interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,1,['simpl'],['simple']
Usability,"information like ""file not found"", ""insufficient; privileges"", etc. while other errors are much harder like ""out of space"", ""bad; disk sector"", or ""system call interrupted"". We'll call the first group ""*soft*""; errors and the second group ""*hard*"" errors. ``lib/Support`` must always attempt to minimize soft errors. This is a design; requirement because the minimization of soft errors can affect the granularity; and the nature of the interface. In general, if you find that you're wanting to; throw soft errors, you must review the granularity of the interface because it; is likely you're trying to implement something that is too low level. The rule; of thumb is to provide interface functions that **can't** fail, except when; faced with hard errors. For a trivial example, suppose we wanted to add an ""``OpenFileForWriting``""; function. For many operating systems, if the file doesn't exist, attempting to; open the file will produce an error. However, ``lib/Support`` should not simply; throw that error if it occurs because its a soft error. The problem is that the; interface function, ``OpenFileForWriting`` is too low level. It should be; ``OpenOrCreateFileForWriting``. In the case of the soft ""doesn't exist"" error,; this function would just create it and then open it for writing. This design principle needs to be maintained in ``lib/Support`` because it; avoids the propagation of soft error handling throughout the rest of LLVM.; Hard errors will generally just cause a termination for an LLVM tool so don't; be bashful about throwing them. Rules of thumb:. #. Don't throw soft errors, only hard errors. #. If you're tempted to throw a soft error, re-think the interface. #. Handle internally the most common normal/good/soft error conditions; so the rest of LLVM doesn't have to. No throw Specifications; -----------------------. None of the ``lib/Support`` interface functions may be declared with C++; ``throw()`` specifications on them. This requirement makes sure that the; com",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SupportLibrary.rst:8504,simpl,simply,8504,interpreter/llvm-project/llvm/docs/SupportLibrary.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SupportLibrary.rst,1,['simpl'],['simply']
Usability,"ing and objects drawing, one can provide number of URL parameters in address string like:. - file - name of the file, which will be automatically open with page loading; - files - array of file names for loading; - json - name of JSON file with stored ROOT object like histogram or canvas; - item - item name to be displayed; - opt - drawing option for the item; - items - array of items name to be displayed; - opts - array of drawing options for the items; - expand - item name(s) to be expanded in the hierarchy browser; - focus - item name to be focused on in the hierarchy browser; - title - set browser title; - dir - list files in directory on http server, see https://github.com/root-project/jsroot/issues/283; - layout - can be 'simple', 'flex', 'tabs', 'gridNxM', 'horizNMK', 'vertNMK'; - browser - layout of the browser 'fix' (default), 'float', 'no' (hidden), 'off' (fully disabled); - nobrowser - do not display file browser (same as browser=no); - float - display floating browser (same as browser=float); - status - configure status line 'no' (default), 'off' (completely disable), 'size'; - inject - name of extra JavaScript to load, see several examples in demo/ subdir; - optimize - drawing optimization 0:off, 1:only large histograms (default), 2:always; - palette - id of default color palette, 51..121 - new ROOT6 palette (default 57); - interactive - enable/disable interactive functions 0 - disable all, 1 - enable all; - noselect - hide file-selection part in the browser (only when file name is specified); - mathjax - use MathJax for latex output; - latex - 'off', 'symbols', 'normal', 'mathjax', 'alwaysmath' control of TLatex processor; - style - name of TStyle object to define global JSROOT style; - toolbar - show canvas tool buttons 'off', 'on' and 'popup', 'left' or 'right' for position, 'vert' for vertical; - divsize - fixed size in pixels for main div element like &dvisize=1500x800; - canvsize - default canvas size in pixels like &canvsize=1200x800; - optstat - ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/JSROOT/JSROOT.md:1730,simpl,simple,1730,documentation/JSROOT/JSROOT.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/JSROOT/JSROOT.md,1,['simpl'],['simple']
Usability,"ing at the body of the loop that the; container isn't being modified, which makes it easier to read the code and; understand what it does. While the second form of the loop is a few extra keystrokes, we do strongly; prefer it. ``#include <iostream>`` is Forbidden; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. The use of ``#include <iostream>`` in library files is hereby **forbidden**,; because many common implementations transparently inject a `static constructor`_; into every translation unit that includes it. Note that using the other stream headers (``<sstream>`` for example) is not; problematic in this regard --- just ``<iostream>``. However, ``raw_ostream``; provides various APIs that are better performing for almost every use than; ``std::ostream`` style APIs. .. note::. New code should always use `raw_ostream`_ for writing, or the; ``llvm::MemoryBuffer`` API for reading files. .. _raw_ostream:. Use ``raw_ostream``; ^^^^^^^^^^^^^^^^^^^. LLVM includes a lightweight, simple, and efficient stream implementation in; ``llvm/Support/raw_ostream.h``, which provides all of the common features of; ``std::ostream``. All new code should use ``raw_ostream`` instead of; ``ostream``. Unlike ``std::ostream``, ``raw_ostream`` is not a template and can be forward; declared as ``class raw_ostream``. Public headers should generally not include; the ``raw_ostream`` header, but use forward declarations and constant references; to ``raw_ostream`` instances. Avoid ``std::endl``; ^^^^^^^^^^^^^^^^^^^. The ``std::endl`` modifier, when used with ``iostreams`` outputs a newline to; the output stream specified. In addition to doing this, however, it also; flushes the output stream. In other words, these are equivalent:. .. code-block:: c++. std::cout << std::endl;; std::cout << '\n' << std::flush;. Most of the time, you probably have no reason to flush the output stream, so; it's better to use a literal ``'\n'``. Don't use ``inline`` when defining a function in a class definition; ^^^^^^^^^^^^^^^^",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodingStandards.rst:55710,simpl,simple,55710,interpreter/llvm-project/llvm/docs/CodingStandards.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodingStandards.rst,1,['simpl'],['simple']
Usability,"ing multiple tests divided into logical blocks, one; or more ``CHECK:`` directives may inadvertently succeed by matching lines in a; later block. While an error will usually eventually be generated, the check; flagged as causing the error may not actually bear any relationship to the; actual source of the problem. In order to produce better error messages in these cases, the ""``CHECK-LABEL:``""; directive can be used. It is treated identically to a normal ``CHECK``; directive except that FileCheck makes an additional assumption that a line; matched by the directive cannot also be matched by any other check present in; ``match-filename``; this is intended to be used for lines containing labels or; other unique identifiers. Conceptually, the presence of ``CHECK-LABEL`` divides; the input stream into separate blocks, each of which is processed independently,; preventing a ``CHECK:`` directive in one block matching a line in another block.; If ``--enable-var-scope`` is in effect, all local variables are cleared at the; beginning of the block. For example,. .. code-block:: llvm. define %struct.C* @C_ctor_base(%struct.C* %this, i32 %x) {; entry:; ; CHECK-LABEL: C_ctor_base:; ; CHECK: mov [[SAVETHIS:r[0-9]+]], r0; ; CHECK: bl A_ctor_base; ; CHECK: mov r0, [[SAVETHIS]]; %0 = bitcast %struct.C* %this to %struct.A*; %call = tail call %struct.A* @A_ctor_base(%struct.A* %0); %1 = bitcast %struct.C* %this to %struct.B*; %call2 = tail call %struct.B* @B_ctor_base(%struct.B* %1, i32 %x); ret %struct.C* %this; }. define %struct.D* @D_ctor_base(%struct.D* %this, i32 %x) {; entry:; ; CHECK-LABEL: D_ctor_base:. The use of ``CHECK-LABEL:`` directives in this case ensures that the three; ``CHECK:`` directives only accept lines corresponding to the body of the; ``@C_ctor_base`` function, even if the patterns match lines found later in; the file. Furthermore, if one of these three ``CHECK:`` directives fail,; FileCheck will recover by continuing to the next block, allowing multiple test; fa",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/FileCheck.rst:22387,clear,cleared,22387,interpreter/llvm-project/llvm/docs/CommandGuide/FileCheck.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/FileCheck.rst,1,['clear'],['cleared']
Usability,"ing the block ID we are describing, *not* the ``BLOCKINFO`` block; itself. The abbreviations defined in ``BLOCKINFO`` blocks receive abbreviation; IDs as described in `DEFINE_ABBREV`_. The ``BLOCKNAME`` record (code 2) can optionally occur in this block. The; elements of the record are the bytes of the string name of the block.; llvm-bcanalyzer can use this to dump out bitcode files symbolically. The ``SETRECORDNAME`` record (code 3) can also optionally occur in this block.; The first operand value is a record ID number, and the rest of the elements of; the record are the bytes for the string name of the record. llvm-bcanalyzer can; use this to dump out bitcode files symbolically. Note that although the data in ``BLOCKINFO`` blocks is described as ""metadata,""; the abbreviations they contain are essential for parsing records from the; corresponding blocks. It is not safe to skip them. .. _wrapper:. Bitcode Wrapper Format; ======================. Bitcode files for LLVM IR may optionally be wrapped in a simple wrapper; structure. This structure contains a simple header that indicates the offset; and size of the embedded BC file. This allows additional information to be; stored alongside the BC file. The structure of this file header is:. :raw-html:`<tt><blockquote>`; [Magic\ :sub:`32`, Version\ :sub:`32`, Offset\ :sub:`32`, Size\ :sub:`32`, CPUType\ :sub:`32`]; :raw-html:`</blockquote></tt>`. Each of the fields are 32-bit fields stored in little endian form (as with the; rest of the bitcode file fields). The Magic number is always ``0x0B17C0DE`` and; the version is currently always ``0``. The Offset field is the offset in bytes; to the start of the bitcode stream in the file, and the Size field is the size; in bytes of the stream. CPUType is a target-specific value that can be used to; encode the CPU of the target. .. _native object file:. Native Object File Wrapper Format; =================================. Bitcode files for LLVM IR may also be wrapped in a native obj",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/BitCodeFormat.rst:18047,simpl,simple,18047,interpreter/llvm-project/llvm/docs/BitCodeFormat.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/BitCodeFormat.rst,1,['simpl'],['simple']
Usability,"ing"" some volumes ""inside"" others.; Any volume is an un-positioned object in the sense that it defines only; a ""local frame"" (matching the one of its ""shape""). In order; to fully define the mother-daughter relationship between two volumes one; has to specify how the daughter will be positioned inside. This is; accomplished by defining a ""local geometrical transformation"" of; the daughter with respect to the mother coordinate system. These; transformations will be subsequently used in the example. **Q:** ""I see the lines defining the top level volume as in the previous example,; but what about the other volumes named REPLICA and ROOT?"". **A:** You will also notice that several other volumes are created; by using lines like:. ~~~{.cpp}; TGeoVolume *someVolume = gGeoManager->MakeXXX(""someName"",; ptrMedium, /* parameters coresponding to XXX ...*/); ~~~. In the method above XXX represent some shape name (Box, Tube,; etc.). This is just a simple way of creating a volume having a given; shape in one-step (see also section: ""Creating and Positioning; Volumes""). As for REPLICA and %ROOT volumes, they are just some; ""virtual volumes"" used for grouping and positioning together other; ""real volumes"". See ""Positioned Volumes (Nodes)"". The same; structure represented by (a real or) a virtual volume can be; ""replicated"" several times in the geometry. **Q:** ""Fine, so probably the real volumes are the ones composing the letters R,; O and T. Why one have to define so many volumes to make an R?"". **A:** Well, in real life some objects have much more complex shapes; that an ""R"". The modeller cannot just know all of them; the idea; is to make a complex object by using elementary building blocks that; have known shapes (called ""primitive shapes""). Gluing these; together in the appropriate way is the user responsibility. **Q:** ""I am getting the global picture but not making much out of it... There; are also a lot of calls to TGeoVolume::AddNode() that I do not understand."". **A:** A vol",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md:9163,simpl,simple,9163,geom/geom/doc/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md,1,['simpl'],['simple']
Usability,"ing, static analysis, code generation,; etc.); Allow tight integration with IDEs; Use the LLVM 'Apache 2'; License. Internal Design and; Implementation:. A real-world, production quality compiler; A simple and hackable code base; A single unified parser for C, Objective C, C++, and Objective C++; Conformance with C/C++/ObjC and their variants. Of course this is only a rough outline of the goals and features of; Clang. To get a true sense of what it is all about, see the Features section, which breaks; each of these down and explains them in more detail. Why?. Development of the new front-end was started out of a need; for a compiler that allows better diagnostics, better integration with; IDEs, a license that is compatible with commercial products, and a; nimble compiler that is easy to develop and maintain. All of these were; motivations for starting work on a new front-end that could; meet these needs. Current Status. Clang is considered to; be a production quality C, Objective-C, C++ and Objective-C++ compiler when; targeting any target supported by LLVM. As example, Clang is used in; production to build performance-critical software like Chrome or Firefox.; If you are looking for source analysis or source-to-source; transformation tools, Clang is probably a great solution for you. Please see; the C++ status page or the; C status page for more information about what; standard modes and features are supported. Get it and get involved!. Start by getting the code, building it, and; playing with it. This will show you the sorts of things we can do; today and will let you have the ""Clang experience"" first hand: hopefully; it will ""resonate"" with you. :); Once you've done that, please consider getting; involved in the Clang community. The Clang developers include numerous; volunteer contributors with a variety of backgrounds. If you're; interested in; following the development of Clang, signing up for a mailing list is a good; way to learn about how the project works. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/index.html:2699,learn,learn,2699,interpreter/llvm-project/clang/www/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/index.html,1,['learn'],['learn']
Usability,"ings. Other binders do not have this initial memory overhead, but do of course; occur an overhead per module, class, function, etc.; At scale, however, cppyy has some advantages: all binding is lazy (including; the option of automatic loading), standard classes are never duplicated, and; there is no additional ""per-module"" overhead.; Thus, eventually (depending on the number of classes bound, across how many; modules, what use fraction, etc.), this initial cost is recouped when; compared to other binders.; As a rule of thumb, if about 10% of classes are used, it takes several; hundreds of bound classes before the cppyy-approach is beneficial.; In High Energy Physics, from which it originated, cppyy is regularly used in; software stacks of many thousands of classes, where this advantage is very; important. `Distributing headers`; ----------------------. cppyy requires C/C++ headers to be available at run-time, which was never a; problem in the developer-centric world from which it originated: software; always had supported C++ APIs already, made available through header files,; and Python simply piggy-backed onto those.; JIT-ing code in those headers, which potentially picked up system headers; that were configured differently, was thus also never a problem.; Or rather, the same problem exists for C++, and configuration for C++ to; resolve potential issues translates transparently to Python. There are only two alternatives: precompile headers into LLVM bitcode and; distribute those or provide a restricted set of headers.; Precompiled headers (and modules) were never designed to be portable and; relocatable, however, thus that may not be the panacea it seems.; A restricted set of headers is some work, but cppyy can operate on abstract; interface classes just fine (including Python-side cross-inheritance). `Large deployment`; ------------------. The single biggest headache in maintaining an installation of Python; extension modules is that Python patch releases can bre",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/philosophy.rst:9885,simpl,simply,9885,bindings/pyroot/cppyy/cppyy/doc/source/philosophy.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/philosophy.rst,1,['simpl'],['simply']
Usability,"insic and ``D`` be the convergent operation that; defines the token value used as the ``convergencectrl`` operand to ``U``. Two; threads execute converged dynamic instances of ``U`` if and only if:. 1. The token value in both threads was returned by converged dynamic; instances of ``D``, and,; 2. There is an integer *n* such that both threads execute ``U`` for the *n*'th time; with that token value. It is an error to omit the ``convergencectrl`` operand bundle on a; call to this intrinsic. If this intrinsic occurs in a basic block, then it must precede any other; convergent operation in the same basic block. .. _convergence_cycle_heart:. **Heart of a Cycle:**. If a :ref:`cycle <cycle-terminology>` ``C`` contains an occurrence ``H`` of; this intrinsic whose token operand is defined outside ``C``, then ``H`` is; called the heart of ``C``. .. note::. The static rules for cycles imply that a heart can occur only in the header; of a natural loop. This ensures that the heart closely represents the; intuitive notion of a loop iteration. If this restriction is relaxed, the; resulting semantics provides a new notion of ""cycle iteration"" even for; irreducible cycles. But this allows a natural loop to have a heart in a; node other than its header, which has interesting consequences on the; meaning of a loop iteration in terms of convergence. For now, we disallow; this situation since its practical application is very rare. .. _llvm.experimental.convergence.anchor:. ``llvm.experimental.convergence.anchor``; ----------------------------------------. .. code-block:: llvm. token @llvm.experimental.convergence.anchor() convergent readnone. This intrinsic produces an initial convergence token that is independent from; any ""outer scope"". The set of threads executing converged dynamic instances of; this intrinsic is implementation-defined. It is an error to pass a ``convergencectrl`` operand bundle at a; call to this intrinsic. .. note::. The expectation is that all threads within a g",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ConvergentOperations.rst:25906,intuit,intuitive,25906,interpreter/llvm-project/llvm/docs/ConvergentOperations.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ConvergentOperations.rst,1,['intuit'],['intuitive']
Usability,"insic behaves as if there were a `coro.save` immediately preceding; the `coro.suspend` intrinsic. The second argument indicates whether this suspension point is `final`_.; The second argument only accepts constants. If more than one suspend point is; designated as final, the resume and destroy branches should lead to the same; basic blocks. Example (normal suspend point):; """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""". .. code-block:: llvm. %0 = call i8 @llvm.coro.suspend(token none, i1 false); switch i8 %0, label %suspend [i8 0, label %resume; i8 1, label %cleanup]. Example (final suspend point):; """""""""""""""""""""""""""""""""""""""""""""""""""""""""""". .. code-block:: llvm. while.end:; %s.final = call i8 @llvm.coro.suspend(token none, i1 true); switch i8 %s.final, label %suspend [i8 0, label %trap; i8 1, label %cleanup]; trap:; call void @llvm.trap(); unreachable. Semantics:; """""""""""""""""""". If a coroutine that was suspended at the suspend point marked by this intrinsic; is resumed via `coro.resume`_ the control will transfer to the basic block; of the 0-case. If it is resumed via `coro.destroy`_, it will proceed to the; basic block indicated by the 1-case. To suspend, coroutine proceed to the; default label. If suspend intrinsic is marked as final, it can consider the `true` branch; unreachable and can perform optimizations that can take advantage of that fact. .. _coro.save:. 'llvm.coro.save' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^; ::. declare token @llvm.coro.save(ptr <handle>). Overview:; """""""""""""""""". The '``llvm.coro.save``' marks the point where a coroutine need to update its; state to prepare for resumption to be considered suspended (and thus eligible; for resumption). It is illegal to merge two '``llvm.coro.save``' calls unless their; '``llvm.coro.suspend``' users are also merged. So '``llvm.coro.save``' is currently; tagged with the `no_merge` function attribute. Arguments:; """""""""""""""""""". The first argument points to a coroutine handle of the enclosing coroutine. Semantics:; """""""""""""""""""". Wh",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst:51265,resume,resume,51265,interpreter/llvm-project/llvm/docs/Coroutines.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst,1,['resume'],['resume']
Usability,"install with sudo or within a virtual; environment. Under Windows, install Python for all users and then run; ``pip install psutil`` in an elevated command prompt. For more information on using the :program:`lit` tool, see ``llvm-lit --help``; or the :doc:`lit man page <CommandGuide/lit>`. Debugging Information tests; ---------------------------. To run debugging information tests simply add the ``cross-project-tests``; project to your ``LLVM_ENABLE_PROJECTS`` define on the cmake; command-line. Regression test structure; =========================. The LLVM regression tests are driven by :program:`lit` and are located in the; ``llvm/test`` directory. This directory contains a large array of small tests that exercise; various features of LLVM and to ensure that regressions do not occur.; The directory is broken into several sub-directories, each focused on a; particular area of LLVM. Writing new regression tests; ----------------------------. The regression test structure is very simple, but does require some; information to be set. This information is gathered via ``cmake``; and is written to a file, ``test/lit.site.cfg.py`` in the build directory.; The ``llvm/test`` Makefile does this work for you. In order for the regression tests to work, each directory of tests must; have a ``lit.local.cfg`` file. :program:`lit` looks for this file to determine; how to run the tests. This file is just Python code and thus is very; flexible, but we've standardized it for the LLVM regression tests. If; you're adding a directory of tests, just copy ``lit.local.cfg`` from; another directory to get running. The standard ``lit.local.cfg`` simply; specifies which files to look in for tests. Any directory that contains; only directories does not need the ``lit.local.cfg`` file. Read the :doc:`Lit; documentation <CommandGuide/lit>` for more information. Each test file must contain lines starting with ""RUN:"" that tell :program:`lit`; how to run it. If there are no RUN lines, :program:`lit`",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TestingGuide.rst:7397,simpl,simple,7397,interpreter/llvm-project/llvm/docs/TestingGuide.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TestingGuide.rst,1,['simpl'],['simple']
Usability,"instance variable which is named, possibly implicitly, by the; ``@synthesize`` declaration. If the associated instance variable already; exists, then its ownership qualification must equal the ownership of the; property; otherwise, the instance variable is created with that ownership; qualification. A property of retainable object pointer type which is synthesized without a; source of ownership has the ownership of its associated instance variable, if it; already exists; otherwise, :when-revised:`[beginning Apple 3.1, LLVM 3.1]`; :revision:`its ownership is implicitly` ``strong``. Prior to this revision, it; was ill-formed to synthesize such a property. .. admonition:: Rationale. Using ``strong`` by default is safe and consistent with the generic ARC rule; about :ref:`inferring ownership <arc.ownership.inference.variables>`. It is,; unfortunately, inconsistent with the non-ARC rule which states that such; properties are implicitly ``assign``. However, that rule is clearly; untenable in ARC, since it leads to default-unsafe code. The main merit to; banning the properties is to avoid confusion with non-ARC practice, which did; not ultimately strike us as sufficient to justify requiring extra syntax and; (more importantly) forcing novices to understand ownership rules just to; declare a property when the default is so reasonable. Changing the rule away; from non-ARC practice was acceptable because we had conservatively banned the; synthesis in order to give ourselves exactly this leeway. Applying ``__attribute__((NSObject))`` to a property not of retainable object; pointer type has the same behavior it does outside of ARC: it requires the; property type to be some sort of pointer and permits the use of modifiers other; than ``assign``. These modifiers only affect the synthesized getter and; setter; direct accesses to the ivar (even if synthesized) still have primitive; semantics, and the value in the ivar will not be automatically released during; deallocation. .. _arc",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst:36331,clear,clearly,36331,interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,1,['clear'],['clearly']
Usability,"instruction selector. Note that; physical registers should have a short lifetime for good code generation, and; all physical registers are assumed dead on entry to and exit from basic blocks; (before register allocation). Thus, if you need a value to be live across basic; block boundaries, it *must* live in a virtual register. Call-clobbered registers; ^^^^^^^^^^^^^^^^^^^^^^^^. Some machine instructions, like calls, clobber a large number of physical; registers. Rather than adding ``<def,dead>`` operands for all of them, it is; possible to use an ``MO_RegisterMask`` operand instead. The register mask; operand holds a bit mask of preserved registers, and everything else is; considered to be clobbered by the instruction. Machine code in SSA form; ^^^^^^^^^^^^^^^^^^^^^^^^. ``MachineInstr``'s are initially selected in SSA-form, and are maintained in; SSA-form until register allocation happens. For the most part, this is; trivially simple since LLVM is already in SSA form; LLVM PHI nodes become; machine code PHI nodes, and virtual registers are only allowed to have a single; definition. After register allocation, machine code is no longer in SSA-form because there; are no virtual registers left in the code. .. _MachineBasicBlock:. The ``MachineBasicBlock`` class; -------------------------------. The ``MachineBasicBlock`` class contains a list of machine instructions; (:raw-html:`<tt>` `MachineInstr`_ :raw-html:`</tt>` instances). It roughly; corresponds to the LLVM code input to the instruction selector, but there can be; a one-to-many mapping (i.e. one LLVM basic block can map to multiple machine; basic blocks). The ``MachineBasicBlock`` class has a ""``getBasicBlock``"" method,; which returns the LLVM basic block that it comes from. .. _MachineFunction:. The ``MachineFunction`` class; -----------------------------. The ``MachineFunction`` class contains a list of machine basic blocks; (:raw-html:`<tt>` `MachineBasicBlock`_ :raw-html:`</tt>` instances). It; corresponds on",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodeGenerator.rst:21817,simpl,simple,21817,interpreter/llvm-project/llvm/docs/CodeGenerator.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodeGenerator.rst,1,['simpl'],['simple']
Usability,"int** to consider; any options starting with ""``-``"" to be part of the **--args** option, not as; options to **bugpoint** itself. **--tool-args** *tool args*. Pass all arguments specified after **--tool-args** to the LLVM tool under test; (**llc**, **lli**, etc.) whenever it runs. You should use this option in the; following way:. .. code-block:: bash. bugpoint [bugpoint args] --tool-args -- [tool args]. The ""``--``"" right after the **--tool-args** option tells **bugpoint** to; consider any options starting with ""``-``"" to be part of the **--tool-args**; option, not as options to **bugpoint** itself. (See **--args**, above.). **--safe-tool-args** *tool args*. Pass all arguments specified after **--safe-tool-args** to the ""safe"" execution; tool. **--gcc-tool-args** *gcc tool args*. Pass all arguments specified after **--gcc-tool-args** to the invocation of; **gcc**. **--opt-args** *opt args*. Pass all arguments specified after **--opt-args** to the invocation of **opt**. **--disable-{dce,simplifycfg}**. Do not run the specified passes to clean up and reduce the size of the test; program. By default, **bugpoint** uses these passes internally when attempting to; reduce test programs. If you're trying to find a bug in one of these passes,; **bugpoint** may crash. **--enable-valgrind**. Use valgrind to find faults in the optimization phase. This will allow; bugpoint to find otherwise asymptomatic problems caused by memory; mis-management. **-find-bugs**. Continually randomize the specified passes and run them on the test program; until a bug is found or the user kills **bugpoint**. **-help**. Print a summary of command line options. **--input** *filename*. Open *filename* and redirect the standard input of the test program, whenever; it runs, to come from that file. **--load** *plugin*. Load the dynamic object *plugin* into **bugpoint** itself. This object should; register new optimization passes. Once loaded, the object will add new command; line options to enable variou",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/bugpoint.rst:2502,simpl,simplifycfg,2502,interpreter/llvm-project/llvm/docs/CommandGuide/bugpoint.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/bugpoint.rst,1,['simpl'],['simplifycfg']
Usability,"inted; to standard error, and the tool returns 1. USING MARKERS TO ANALYZE SPECIFIC CODE BLOCKS; ---------------------------------------------; :program:`llvm-mca` allows for the optional usage of special code comments to; mark regions of the assembly code to be analyzed. A comment starting with; substring ``LLVM-MCA-BEGIN`` marks the beginning of an analysis region. A; comment starting with substring ``LLVM-MCA-END`` marks the end of a region.; For example:. .. code-block:: none. # LLVM-MCA-BEGIN; ...; # LLVM-MCA-END. If no user-defined region is specified, then :program:`llvm-mca` assumes a; default region which contains every instruction in the input file. Every region; is analyzed in isolation, and the final performance report is the union of all; the reports generated for every analysis region. Analysis regions can have names. For example:. .. code-block:: none. # LLVM-MCA-BEGIN A simple example; add %eax, %eax; # LLVM-MCA-END. The code from the example above defines a region named ""A simple example"" with a; single instruction in it. Note how the region name doesn't have to be repeated; in the ``LLVM-MCA-END`` directive. In the absence of overlapping regions,; an anonymous ``LLVM-MCA-END`` directive always ends the currently active user; defined region. Example of nesting regions:. .. code-block:: none. # LLVM-MCA-BEGIN foo; add %eax, %edx; # LLVM-MCA-BEGIN bar; sub %eax, %edx; # LLVM-MCA-END bar; # LLVM-MCA-END foo. Example of overlapping regions:. .. code-block:: none. # LLVM-MCA-BEGIN foo; add %eax, %edx; # LLVM-MCA-BEGIN bar; sub %eax, %edx; # LLVM-MCA-END foo; add %eax, %edx; # LLVM-MCA-END bar. Note that multiple anonymous regions cannot overlap. Also, overlapping regions; cannot have the same name. There is no support for marking regions from high-level source code, like C or; C++. As a workaround, inline assembly directives may be used:. .. code-block:: c++. int foo(int a, int b) {; __asm volatile(""# LLVM-MCA-BEGIN foo"":::""memory"");; a += 42;; __asm vol",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-mca.rst:9038,simpl,simple,9038,interpreter/llvm-project/llvm/docs/CommandGuide/llvm-mca.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-mca.rst,1,['simpl'],['simple']
Usability,"inter to the coroutine object and returns; `void`. Because the resume and destroy functions are shared across all suspend; points, suspend points must store the index of the active suspend in; the coroutine object, and the resume/destroy functions must switch over; that index to get back to the correct point. Hence the name of this; lowering. Pointers to the resume and destroy functions are stored in the coroutine; object at known offsets which are fixed for all coroutines. A completed; coroutine is represented with a null resume function. There is a somewhat complex protocol of intrinsics for allocating and; deallocating the coroutine object. It is complex in order to allow the; allocation to be elided due to inlining. This protocol is discussed; in further detail below. The frontend may generate code to call the coroutine function directly;; this will become a call to the ramp function and will return a pointer; to the coroutine object. The frontend should always resume or destroy; the coroutine using the corresponding intrinsics. Returned-Continuation Lowering; ------------------------------. In returned-continuation lowering, signaled by the use of; `llvm.coro.id.retcon` or `llvm.coro.id.retcon.once`, some aspects of; the ABI must be handled more explicitly by the frontend. In this lowering, every suspend point takes a list of ""yielded values""; which are returned back to the caller along with a function pointer,; called the continuation function. The coroutine is resumed by simply; calling this continuation function pointer. The original coroutine; is divided into the ramp function and then an arbitrary number of; these continuation functions, one for each suspend point. LLVM actually supports two closely-related returned-continuation; lowerings:. - In normal returned-continuation lowering, the coroutine may suspend; itself multiple times. This means that a continuation function; itself returns another continuation pointer, as well as a list of; yielded values. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst:5200,resume,resume,5200,interpreter/llvm-project/llvm/docs/Coroutines.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst,1,['resume'],['resume']
Usability,"interface to use in own; applications and a graphical user interface for interactive data analysis. The; purpose of this document is to serve as a beginners guide and provides extendable; examples for your own use cases, based on typical problems addressed in; student labs. This guide will hopefully lay the ground for more complex; applications in your future scientific work building on a modern,; state-of the art tool for data analysis. This guide in form of a tutorial is intended to introduce you quickly to the; ROOT package. This goal will be accomplished using concrete examples, according; to the ""learning by doing"" principle. Also because of this reason, this guide; cannot cover all the complexity of the ROOT package. Nevertheless, once you feel; confident with the concepts presented in the following chapters, you will be; able to appreciate the ROOT Users Guide [@ROOT_Users_Guide] and navigate through; the Class Reference [@ROOT_Class_Reference] to find all the details you might be; interested in. You can even look at the code itself, since ROOT is a; free, open-source product. Use these documents in parallel to this; tutorial!. The ROOT Data Analysis Framework itself is written in and heavily relies; on the `C++` programming language: some knowledge about `C++` is required.; Jus take advantage from the immense available literature about `C++` if you do; not have any idea of what this language is about. ROOT is available for many platforms (Linux, Mac OS X, Windows...), but; in this guide we will implicitly assume that you are using Linux. The; first thing you need to do with ROOT is install it, don't you ? Obtaining; the latest ROOT version is straightforward. Just seek the ""Pro"" version; on this webpage <http://root.cern.ch/downloading-root>.; You will find precompiled versions for the different architectures, or; the ROOT source code to compile yourself. Just pick up the flavour you; need and follow the installation instructions. **Let's dive into ROOT!**; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/Introduction.md:4718,guid,guide,4718,documentation/primer/Introduction.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/Introduction.md,1,['guid'],['guide']
Usability,"ion `f` will contain only the; code responsible for creation and initialization of the coroutine frame and; execution of the coroutine until a suspend point is reached:. .. code-block:: llvm. define ptr @f(i32 %n) {; entry:; %id = call token @llvm.coro.id(i32 0, ptr null, ptr null, ptr null); %alloc = call noalias ptr @malloc(i32 24); %frame = call noalias ptr @llvm.coro.begin(token %id, ptr %alloc); %1 = getelementptr %f.frame, ptr %frame, i32 0, i32 0; store ptr @f.resume, ptr %1; %2 = getelementptr %f.frame, ptr %frame, i32 0, i32 1; store ptr @f.destroy, ptr %2. %inc = add nsw i32 %n, 1; %inc.spill.addr = getelementptr inbounds %f.Frame, ptr %FramePtr, i32 0, i32 2; store i32 %inc, ptr %inc.spill.addr; call void @print(i32 %n). ret ptr %frame; }. Outlined resume part of the coroutine will reside in function `f.resume`:. .. code-block:: llvm. define internal fastcc void @f.resume(ptr %frame.ptr.resume) {; entry:; %inc.spill.addr = getelementptr %f.frame, ptr %frame.ptr.resume, i64 0, i32 2; %inc.spill = load i32, ptr %inc.spill.addr, align 4; %inc = add i32 %inc.spill, 1; store i32 %inc, ptr %inc.spill.addr, align 4; tail call void @print(i32 %inc); ret void; }. Whereas function `f.destroy` will contain the cleanup code for the coroutine:. .. code-block:: llvm. define internal fastcc void @f.destroy(ptr %frame.ptr.destroy) {; entry:; tail call void @free(ptr %frame.ptr.destroy); ret void; }. Avoiding Heap Allocations; -------------------------. A particular coroutine usage pattern, which is illustrated by the `main`; function in the overview section, where a coroutine is created, manipulated and; destroyed by the same calling function, is common for coroutines implementing; RAII idiom and is suitable for allocation elision optimization which avoid; dynamic allocation by storing the coroutine frame as a static `alloca` in its; caller. In the entry block, we will call `coro.alloc`_ intrinsic that will return `true`; when dynamic allocation is required, and `false` i",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst:15710,resume,resume,15710,interpreter/llvm-project/llvm/docs/Coroutines.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst,1,['resume'],['resume']
Usability,"ion in; ROOT and it is important to understand how it is constructed. The; example program is written as a named script. See ""Cling the C++; Interpreter"". Remember that the named script can be executed via. ``` {.cpp}; root[] .x example.C; ```. only if the filename (without extension) and the function entry point; are both the same. ![](pictures/02000202.jpg). We need to say a few words about the parent-children relationship; between the widgets before going through the real code. The widgets'; behaviors are based on this relationship. Every parent widget is; responsible for where the children are and it ensures all properties and; behavior for them. For example, if you want to hide several widgets, it; will be enough to hide their parent widget. Later you can show the; parent and the children will appear too. Writing your code you have to; specify the parent-child relationship. Usually in a child constructor; the address of the parent is passed as an argument. In general frames; are parents of simple widgets. In this example you will see how we; organize the parent-children relationship by using frame widgets in; addition to the canvas window and button widgets. Let's now go through the code of the `example.C`. The first lines include ROOT header files. The header file names are; almost always as the class names (**`TApplication`**, **`TF1`**,; **`TCanvas`**), but there are cases when similar classes are grouped; together in one header file: all frames are declared in `TGFrame.h`, all; buttons - in `TGButton.h`, etc. Our small example is based on an object; of the class `MyMainFrame`. ``` {.cpp}; new MyMainFrame(gClient->GetRoot(),200,200);; ```. The first parameter `gClient->GetRoot()` makes the initial connection to; the window server. It is a pointer to the root window of the screen,; which is obtained from ***`gClient`***. The next two parameters; initialize the width and height of the application window in pixels. Let; see what `MyMainFrame` is. The three argu",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md:4148,simpl,simple,4148,documentation/users-guide/WritingGUI.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md,1,['simpl'],['simple']
Usability,"ion is at this point necessary:. - Lines *1-3*: A simple function to ease the make-up of lines.; Remember that the class `TF1` inherits from `TAttLine`. - Lines *5-7* : Definition of a customised function, namely a Gaussian; (the ""signal"") plus a parabolic function, the ""background"". - Lines *10-12*: Some make-up for the Canvas. In particular we want; that the parameters of the fit appear very clearly and nicely on the; plot. - Lines *20-25*: Define and initialise an instance of `TF1`. - Lines *27-31*: Define and fill a histogram. - Lines *33-38*: For convenience, the same function as for the; generation of the pseudo-data is used in the fit; hence, we need to; reset the function parameters. This part of the code is very; important for each fit procedure, as it sets the initial values of; the fit. - Line *41*: A very simple command, well known by now: fit the; function to the histogram. - Lines *42-46*: Retrieve the output from the fit. Here, we simply; print the fit result and access and print the covariance matrix of; the parameters. - Lines *54-end*: Plot the pseudo-data, the fitted function and the; signal and background components at the best-fit values. [f61]: figures/functions.png ""f61""; <a name=""f61""></a>. ![Fit of pseudo data: a signal shape over a background trend. This plot; is another example of how making a plot ""self-explanatory"" can help you; better displaying your results. \label{f61}][f61]. ## Toy Monte Carlo Experiments ##. Let us look at a simple example of a toy experiment comparing two; methods to fit a function to a histogram, the $\chi^{2}$. method and a method called ""binned log-likelihood fit"", both available in ROOT. As a very simple yet powerful quantity to check the quality of the fit; results, we construct for each pseudo-data set the so-called ""pull"", the; difference of the estimated and the true value of a parameter,; normalised to the estimated error on the parameter,; $\frac{(p_{estim} - p_{true})}{\sigma_{p}}$. If everything is OK, t",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/functions_and_parameter_estimation.md:3542,simpl,simply,3542,documentation/primer/functions_and_parameter_estimation.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/functions_and_parameter_estimation.md,1,['simpl'],['simply']
Usability,"ion is reading or writing a `ROOT::RVec` object from/to a ROOT file. We assume this is an; exceedingly rare case, as the ROOT interface typically used to manipulate `RVec`s is `RDataFrame`, and `RDataFrame` performs an on-the-fly; `RVec <-> std::vector` conversion rather than writing `RVec`s to disk. Note that, currently, `RVecs` written e.g. in a `TTree` cannot be read back; using certain ROOT interfaces (e.g. `TTreeReaderArray`, `RDataFrame` and the experimental `RNTuple`). All these limitations will be lifted in v6.26.; - Portable implementation of the RANLUX++ generator, see [RanluxppEngine](https://root.cern/doc/master/classROOT_1_1Math_1_1RanluxppEngine.html) and [our blog post](https://root.cern/blog/ranluxpp/). ## TMVA. - Introducing TMVA PyTorch Interface, a method to use PyTorch internally with TMVA for deep learning. This can be used as an alternative to PyKeras Interface for complex models providing more flexibility and power. ## RooFit Libraries. - Extension / updates of the doxygen reference guide.; - Allow for removing RooPlot from global directory management, see [RooPlot::AddDirectory](https://root.cern/doc/v624/classRooPlot.html#a47f7ba71dcaca30ad9ee295dee89c9b8); and [RooPlot::SetDirectory](https://root.cern/doc/v624/classRooPlot.html#a5938bc6d5c47d94c2f04fdcc10c1c026); - Hash-assisted finding of elements in RooWorkspace. Large RooWorkspace objects were slow in finding elements.; This was improved using a hash map.; - Stabilise RooStats::HypoTestInverter. It can now tolerate a few failed fits when conducting hypothesis tests.; This is relevant when a few points in a parameter scan don't converge due to numerical or model instabilities.; These points will be skipped, and HypoTestInverter can continue.; - Tweak pull / residual plots. ROOT automatically zoomed out a bit when a pull / residual plot is created. Now, the; axis range of the original plot is transferred to the residual plot, so the pulls can be drawn below the main plot. ### Massive speed",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v624/index.md:13909,guid,guide,13909,README/ReleaseNotes/v624/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v624/index.md,1,['guid'],['guide']
Usability,"ion itself, but within; its entire cluster, since neighboring regions may be accessed via pointer; arithmetic. Region invalidation typically does even more than this, however. Because it; usually represents the complete escape of a region from the analyzer's model,; its *contents* must also be transitively invalidated. (For example, if a region; ``p`` of type ``int **`` is invalidated, the contents of ``*p`` and ``**p`` may; have changed as well.) The algorithm that traverses this transitive closure of; accessible regions is known as ClusterAnalysis, and is also used for finding; all live bindings in the store (in order to throw away the dead ones). The name; ""ClusterAnalysis"" predates the cluster-based organization of bindings, but; refers to the same concept: during invalidation and liveness analysis, all; bindings within a cluster must be treated in the same way for a conservative; model of program behavior. Default Bindings; ----------------. Most bindings in RegionStore are simple scalar values -- integers and pointers.; These are known as ""Direct"" bindings. However, RegionStore supports a second; type of binding called a ""Default"" binding. These are used to provide values to; all the elements of an aggregate type (struct or array) without having to; explicitly specify a binding for each individual element. When there is no Direct binding for a particular region, the store manager; looks at each super-region in turn to see if there is a Default binding. If so,; this value is used as the value of the original region. The search ends when; the base region is reached, at which point the RegionStore will pick an; appropriate default value for the region (usually a symbolic value, but; sometimes zero, for static data, or ""uninitialized"", for stack variables). .. code-block:: cpp. int manyInts[10];; manyInts[1] = 42; // Creates a Direct binding for manyInts[1].; print(manyInts[1]); // Retrieves the Direct binding for manyInts[1];; print(manyInts[0]); // There is no D",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/RegionStore.rst:4976,simpl,simple,4976,interpreter/llvm-project/clang/docs/analyzer/developer-docs/RegionStore.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/RegionStore.rst,1,['simpl'],['simple']
Usability,"ion of the migration. If you want to contribute to LLVM; now, please use GitHub. For more information about the workflow of using GitHub; Pull Requests see our :ref:`GitHub <github-reviews>` documentation. To make sure the right people see your patch, please select suitable reviewers; and add them to your patch when requesting a review. Suitable reviewers are the; code owner (see CODE_OWNERS.txt) and other people doing work in the area your; patch touches. Github will normally suggest some reviewers based on rules or; people that have worked on the code before. If you are a new contributor, you; will not be able to select reviewers in such a way, in which case you can still; get the attention of potential reviewers by CC'ing them in a comment -- just; @name them. A reviewer may request changes or ask questions during the review. If you are; uncertain on how to provide test cases, documentation, etc., feel free to ask; for guidance during the review. Please address the feedback and re-post an; updated version of your patch. This cycle continues until all requests and comments; have been addressed and a reviewer accepts the patch with a `Looks good to me` or `LGTM`.; Once that is done the change can be committed. If you do not have commit; access, please let people know during the review and someone should commit it; on your behalf. If you have received no comments on your patch for a week, you can request a; review by 'ping'ing the GitHub PR with ""Ping"". The common courtesy 'ping' rate; is once a week. Please remember that you are asking for valuable time from other; professional developers. For more information on LLVM's code-review process, please see :doc:`CodeReview`. .. _commit_from_git:. For developers to commit changes from Git; -----------------------------------------. Once a patch is reviewed, you can select the ""Squash and merge"" button in the; GitHub web interface. You might need to rebase your change before pushing; it to the repo. LLVM currently has a li",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Contributing.rst:4585,feedback,feedback,4585,interpreter/llvm-project/llvm/docs/Contributing.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Contributing.rst,1,['feedback'],['feedback']
Usability,"ion provides code conventions used when the target triple OS is; ``amdpal`` (see :ref:`amdgpu-target-triples`). .. _amdgpu-amdpal-code-object-metadata-section:. Code Object Metadata; ~~~~~~~~~~~~~~~~~~~~. .. note::. The metadata is currently in development and is subject to major; changes. Only the current version is supported. *When this document; was generated the version was 2.6.*. Code object metadata is specified by the ``NT_AMDGPU_METADATA`` note; record (see :ref:`amdgpu-note-records-v3-onwards`). The metadata is represented as Message Pack formatted binary data (see; [MsgPack]_). The top level is a Message Pack map that includes the keys; defined in table :ref:`amdgpu-amdpal-code-object-metadata-map-table`; and referenced tables. Additional information can be added to the maps. To avoid conflicts, any; key names should be prefixed by ""*vendor-name*."" where ``vendor-name``; can be the name of the vendor and specific vendor tool that generates the; information. The prefix is abbreviated to simply ""."" when it appears; within a map that has been added by the same *vendor-name*. .. table:: AMDPAL Code Object Metadata Map; :name: amdgpu-amdpal-code-object-metadata-map-table. =================== ============== ========= ======================================================================; String Key Value Type Required? Description; =================== ============== ========= ======================================================================; ""amdpal.version"" sequence of Required PAL code object metadata (major, minor) version. The current values; 2 integers are defined by *Util::Abi::PipelineMetadata(Major|Minor)Version*.; ""amdpal.pipelines"" sequence of Required Per-pipeline metadata. See; map :ref:`amdgpu-amdpal-code-object-pipeline-metadata-map-table` for the; definition of the keys included in that map.; =================== ============== ========= ======================================================================. .. .. table:: AMDPAL Code Object Pip",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst:402175,simpl,simply,402175,interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,1,['simpl'],['simply']
Usability,"ions...; double evaluate() override {; // Do some bookkeeping; return doFoo();; };; double analyticalIntegral(Int_t code, const char* rangeName) override {; // Select the right paths for integration using codes or whatever.; return integralFoo();; }; };; ```. \note All RooFit classes are deriving from the RooAbsReal object, but; its details are not relevant to the current example. Note how the `evaluate()` function overrides the `RooAbsReal` for the RooFoo; class. Similarly, the `analyticalIntegral()` function has also been overridden; from the `RooAbsReal` class. The `evaluate()` function includes some bookkeeping steps (commented out in; above example) that are not relevant to AD. The important part is that it; calls a specific function (doFoo() in this example), and returns the results. Similarly, the `analyticalIntegral()` function calls a specific function (; `integralFoo()` in this example), and returns the results. It may also include; some code that may need to be looked at, but for simplicity, its contents are; commented out in this example. #### Adding Code Generation Support to RooFoo class. Before creating the translate() function, move the mathematical logic (; `doFoo()` function in this example) out of the source class (RooFoo in this; example) and into a separate header file called `MathFuncs.h`. Also note; that the parameters a and b have been defined as inputs, instead of them just; being class members. ``` {.cpp}; ///// The MathFuncs.h file; int doFoo(int a, int b) { return a* b + a + b; }; ```. > Directory path: [roofit/roofitcore/inc/RooFit/Detail/MathFuncs.h](https://github.com/root-project/root/blob/master/roofit/roofitcore/inc/RooFit/Detail/MathFuncs.h). So now that the `doFoo()` function exists in the `MathFuncs` namespace, we; need to comment out its original function definition in the RooFoo class and; also add the namespace `MathFuncs` to wherever `doFoo()` it is referenced; (and also define input parameters for it). ``` {.cpp}; class RooFo",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/developers/roofit_ad.md:20495,simpl,simplicity,20495,roofit/doc/developers/roofit_ad.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/developers/roofit_ad.md,1,['simpl'],['simplicity']
Usability,"ions; Not resolved. 197; CD1; Issues with two-stage lookup of dependent names; Yes. 198; CD1; Definition of ""use"" in local and nested classes; Yes. 199; CD1; Order of destruction of temporaries; Unknown. 200; dup; Partial ordering and explicit arguments; Duplicate of 214. 201; CD1; Order of destruction of temporaries in initializers; Unknown. 202; TC1; Use of overloaded function name; Clang 3.1. 203; NAD; Type of address-of-member expression; Unknown. 204; CD1; Exported class templates; No. 205; drafting; Templates and static data members; Not resolved. 206; TC1; Semantic constraints on non-dependent names; Yes. 207; CD1; using-declarations and protected access; Yes. 208; CD1; Rethrowing exceptions in nested handlers; Unknown. 209; NAD; Must friend declaration names be; accessible?; Clang 3.2. 210; TC1; What is the type matched by an exception handler?; Unknown. 211; NAD; Constructors should not be allowed to return normally after an exception; Yes. 212; CD4; Implicit instantiation is not described clearly enough; Unknown. 213; TC1; Lookup in dependent base classes; Yes. 214; CD1; Partial ordering of function templates is underspecified; Yes. 215; CD1; Template parameters are not allowed in nested-name-specifiers; Clang 2.9. 216; CD1; Linkage of nameless class-scope enumeration types; No. 217; TC1; Default arguments for non-template member functions of class templates; Yes. 218; CD1; Specification of Koenig lookup; Yes. 219; NAD; Cannot defend against destructors that throw exceptions; N/A. 220; CD1; All deallocation functions should be required not to throw; N/A. 221; CD1; Must compound assignment operators be member functions?; Clang 3.6. 222; CD1; Sequence points and lvalue-returning operators; Duplicate of 637. 223; CD3; The meaning of deprecation; N/A. 224; CD1; Definition of dependent names; Clang 16. 225; NAD; Koenig lookup and fundamental types; Yes. 226; CD1; Default template arguments for function templates; No. 227; TC1; How many scopes in an if statement?",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:13995,clear,clearly,13995,interpreter/llvm-project/clang/www/cxx_dr_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html,1,['clear'],['clearly']
Usability,"ior to obtaining commit access, it is common practice to request that; someone with commit access commits on your behalf. When doing so, please; provide the name and email address you would like to use in the Author; property of the commit. For external tracking purposes, committed changes are automatically reflected; on a commits mailing list soon after the commit lands (e.g. llvm-commits_).; Note that these mailing lists are moderated, and it is not unusual for a large; commit to require a moderator to approve the email, so do not be concerned if a; commit does not immediately appear in the archives. If you have recently been granted commit access, these policies apply:. #. You are granted *commit-after-approval* to all parts of LLVM. For; information on how to get approval for a patch, please see :doc:`CodeReview`.; When approved, you may commit it yourself. #. You are allowed to commit patches without approval which you think are; obvious. This is clearly a subjective decision --- we simply expect you to; use good judgement. Examples include: fixing build breakage, reverting; obviously broken patches, documentation/comment changes, any other minor; changes. Avoid committing formatting- or whitespace-only changes outside of; code you plan to make subsequent changes to. Also, try to separate; formatting or whitespace changes from functional changes, either by; correcting the format first (ideally) or afterward. Such changes should be; highly localized and the commit message should clearly state that the commit; is not intended to change functionality, usually by stating it is; :ref:`NFC <nfc>`. #. You are allowed to commit patches without approval to those portions of LLVM; that you have contributed or maintain (i.e., have been assigned; responsibility for), with the proviso that such commits must not break the; build. This is a ""trust but verify"" policy, and commits of this nature are; reviewed after they are committed. #. Multiple violations of these policies or ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/DeveloperPolicy.rst:24506,clear,clearly,24506,interpreter/llvm-project/llvm/docs/DeveloperPolicy.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/DeveloperPolicy.rst,2,"['clear', 'simpl']","['clearly', 'simply']"
Usability,"ipated in one (if any) security issue in the last year.; - If already in the LLVM Security Group, has actively participated in most membership discussions in the last year.; - If already in the LLVM Security Group, has actively participated in writing or reviewing a transparency report in the last year.; - When employed by a company or other entity, the parent entity has no more than three members already in the LLVM Security Group.; - When nominated as a vendor contact, their position with that vendor remains the same as when originally nominated.; - Nominees are trusted by existing Security Group members to keep communications embargoed while still active. Nomination process; ------------------. Anyone who feels they meet these criteria can nominate themselves, or may be nominated by a third party such as an existing LLVM Security Group member. The nomination should state whether the nominee is nominated as an individual, researcher, or as a vendor contact. It should clearly describe the grounds for nomination. For the moment, nominations are generally proposed, discussed, and voted on using Phabricator. An `example nomination is available here`_. The use of Phabricator helps keep membership discussions open, transparent, and easily accessible to LLVM developers in many ways. If, for any reason, a fully-world-readable nomination seems inappropriate, you may `open a new issue`_, and a discussion can be had about the best way to approach nomination, given the constraints that individuals are under. Our recommended method of nomination may change as our `Discussion Medium`_ story evolves over time. Choosing new members; --------------------. If a nomination for LLVM Security Group membership is supported by a majority of existing LLVM Security Group members, then it carries within five business days unless an existing member of the Security Group objects. If an objection is raised, the LLVM Security Group members should discuss the matter and try to come to consensus;",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Security.rst:5374,clear,clearly,5374,interpreter/llvm-project/llvm/docs/Security.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Security.rst,1,['clear'],['clearly']
Usability,"ire provides a barrier of the sort necessary to acquire a lock to access; other memory with normal loads and stores. Relevant standard; This corresponds to the C++/C ``memory_order_acquire``. It should also be; used for C++/C ``memory_order_consume``. Notes for frontends; If you are writing a frontend which uses this directly, use with caution.; Acquire only provides a semantic guarantee when paired with a Release; operation. Notes for optimizers; Optimizers not aware of atomics can treat this like a nothrow call. It is; also possible to move stores from before an Acquire load or read-modify-write; operation to after it, and move non-Acquire loads from before an Acquire; operation to after it. Notes for code generation; Architectures with weak memory ordering (essentially everything relevant today; except x86 and SPARC) require some sort of fence to maintain the Acquire; semantics. The precise fences required varies widely by architecture, but for; a simple implementation, most architectures provide a barrier which is strong; enough for everything (``dmb`` on ARM, ``sync`` on PowerPC, etc.). Putting; such a fence after the equivalent Monotonic operation is sufficient to; maintain Acquire semantics for a memory operation. Release; -------. Release is similar to Acquire, but with a barrier of the sort necessary to; release a lock. Relevant standard; This corresponds to the C++/C ``memory_order_release``. Notes for frontends; If you are writing a frontend which uses this directly, use with caution.; Release only provides a semantic guarantee when paired with an Acquire; operation. Notes for optimizers; Optimizers not aware of atomics can treat this like a nothrow call. It is; also possible to move loads from after a Release store or read-modify-write; operation to before it, and move non-Release stores from after a Release; operation to before it. Notes for code generation; See the section on Acquire; a fence before the relevant operation is usually; sufficient for Rel",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Atomics.rst:12439,simpl,simple,12439,interpreter/llvm-project/llvm/docs/Atomics.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Atomics.rst,1,['simpl'],['simple']
Usability,"irective is used to verify that a string doesn't occur; between two matches (or before the first match, or after the last match). For; example, to verify that a load is removed by a transformation, a test like this; can be used:. .. code-block:: llvm. define i8 @coerce_offset0(i32 %V, i32* %P) {; store i32 %V, i32* %P. %P2 = bitcast i32* %P to i8*; %P3 = getelementptr i8* %P2, i32 2. %A = load i8* %P3; ret i8 %A; ; CHECK: @coerce_offset0; ; CHECK-NOT: load; ; CHECK: ret i8; }. The ""CHECK-COUNT:"" directive; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~. If you need to match multiple lines with the same pattern over and over again; you can repeat a plain ``CHECK:`` as many times as needed. If that looks too; boring you can instead use a counted check ""``CHECK-COUNT-<num>:``"", where; ``<num>`` is a positive decimal number. It will match the pattern exactly; ``<num>`` times, no more and no less. If you specified a custom check prefix,; just use ""``<PREFIX>-COUNT-<num>:``"" for the same effect.; Here is a simple example:. .. code-block:: text. Loop at depth 1; Loop at depth 1; Loop at depth 1; Loop at depth 1; Loop at depth 2; Loop at depth 3. ; CHECK-COUNT-6: Loop at depth {{[0-9]+}}; ; CHECK-NOT: Loop at depth {{[0-9]+}}. The ""CHECK-DAG:"" directive; ~~~~~~~~~~~~~~~~~~~~~~~~~~. If it's necessary to match strings that don't occur in a strictly sequential; order, ""``CHECK-DAG:``"" could be used to verify them between two matches (or; before the first match, or after the last match). For example, clang emits; vtable globals in reverse order. Using ``CHECK-DAG:``, we can keep the checks; in the natural order:. .. code-block:: c++. // RUN: %clang_cc1 %s -emit-llvm -o - | FileCheck %s. struct Foo { virtual void method(); };; Foo f; // emit vtable; // CHECK-DAG: @_ZTV3Foo =. struct Bar { virtual void method(); };; Bar b;; // CHECK-DAG: @_ZTV3Bar =. ``CHECK-NOT:`` directives could be mixed with ``CHECK-DAG:`` directives to; exclude strings between the surrounding ``CHECK-DAG:`` directives. As a r",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/FileCheck.rst:17643,simpl,simple,17643,interpreter/llvm-project/llvm/docs/CommandGuide/FileCheck.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/FileCheck.rst,1,['simpl'],['simple']
Usability,"irectories. - `cycle` =\* means all cycles (memory and file). - `cycle` ="""" means apply to a memory object. - `cycle` = 9999 also means apply to a memory object. - `namecycle` = """" means the same as `namecycle` =""T\*"". - `namecycle` = `T*` delete subdirectories. For example to delete a directory from a file, you must specify the; directory cycle:. ``` {.cpp}; root[] f->Delete(""Wed011003;1""); ```. Some other examples of `namecycle` format are:. - `foo`:delete the object named `foo` from memory. - `foo;1`: delete the cycle 1 of the object named `foo` from the file. - `foo;*`: delete all cycles of `foo` from the file and also from; memory. - `*;2`: delete all objects with cycle number 2 from the file. - `*;*: delete` all objects from memory and from the file. - `T*;*`: delete all objects from memory and from the file including; all subdirectories. ## Streamers. To follow the discussion on `Streamers`, you need to know what a; *simple* data type is. A variable is of a simple data type if it cannot; be decomposed into other types. Examples of simple data types are longs,; shorts, floats, and chars. In contrast, a variable is of a *composite*; data type if it can be decomposed. For example, classes, structures, and; arrays are composite types. Simple types are also called primitive; types, basic types, and Cling sometimes calls them fundamental types. When we say, ""writing an object to a file"", we actually mean writing the; current values of the data members. The most common way to do this is to; decompose (also called the serialization of) the object into its data; members and write them to disk. The decomposition is the job of the; `Streamer`. Every class with ambitions to be stored in a file has a; `Streamer `that decomposes it and ""streams"" its members into a buffer. The methods of the class are not written to the file, it contains only; the persistent data members. To decompose the parent classes, the; `Streamer `calls the `Streamer `of the parent classes. It moves u",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md:41972,simpl,simple,41972,documentation/users-guide/InputOutput.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md,1,['simpl'],['simple']
Usability,"irement to be satisfied to perform I/O of instances; of a certain class is that the ROOT type system is aware of the layout; in memory of that class.; This topic is beyond the scope of this document: it is worth to mention; that I/O can be performed out of the box for the almost complete set; of ROOT classes. We can explore this functionality with histograms and two simple macros. ``` {.cpp}; @ROOT_INCLUDE_FILE macros/write_to_file.C; ```. Not bad, eh ? Especially for a language that does not foresees; persistency natively like C++. The *RECREATE* option forces ROOT to; create a new file even if a file with the same name exists on disk. Now, you may use the Cling command line to access information in the file; and draw the previously written histogram:. ``` {.cpp}; > root my_rootfile.root; root [0]; Attaching file my_rootfile.root as _file0...; root [1] _file0->ls(); TFile** my_rootfile.root; TFile* my_rootfile.root; KEY: TH1F	my_histogram;1 My Title; root [2] my_histogram->Draw(); ```; \newpage; Alternatively, you can use a simple macro to carry out the job:. ``` {.cpp}; @ROOT_INCLUDE_FILE macros/read_from_file.C; ```. ## N-tuples in ROOT ##. ### Storing simple N-tuples ###. Up to now we have seen how to manipulate input read from ASCII files.; ROOT offers the possibility to do much better than that, with its own; n-tuple classes. Among the many advantages provided by these classes one; could cite. - Optimised disk I/O. - Possibility to store many n-tuple rows. - Write the n-tuples in ROOT files. - Interactive inspection with `TBrowser`. - Store not only numbers, but also *objects* in the columns. In this section we will discuss briefly the `TNtuple` class, which is a; simplified version of the `TTree` class. A ROOT `TNtuple` object can; store rows of float entries. Let's tackle the problem according to the; usual strategy commenting a minimal example. ``` {.cpp}; @ROOT_INCLUDE_FILE macros/write_ntuple_to_file.C; ```. This data written to this example n-tuple repres",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/filio.md:1381,simpl,simple,1381,documentation/primer/filio.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/filio.md,1,['simpl'],['simple']
Usability,"is being worked on. .. _submit_patch:. How to Submit a Patch; =====================; Once you have a patch ready, it is time to submit it. The patch should:. * include a small unit test; * conform to the :doc:`CodingStandards`. You can use the `clang-format-diff.py`_ or `git-clang-format`_ tools to automatically format your patch properly.; * not contain any unrelated changes; * be an isolated change. Independent changes should be submitted as separate patches as this makes reviewing easier.; * have a single commit (unless stacked on another Differential), up-to-date with the upstream ``origin/main`` branch, and don't have merges. .. _format patches:. Before sending a patch for review, please also try to ensure it is; formatted properly. We use ``clang-format`` for this, which has git integration; through the ``git-clang-format`` script. On some systems, it may already be; installed (or be installable via your package manager). If so, you can simply; run it -- the following command will format only the code changed in the most; recent commit:. .. code-block:: console. % git clang-format HEAD~1. Note that this modifies the files, but doesn't commit them -- you'll likely want; to run. .. code-block:: console. % git commit --amend -a. in order to update the last commit with all pending changes. .. note::; If you don't already have ``clang-format`` or ``git clang-format`` installed; on your system, the ``clang-format`` binary will be built alongside clang, and; the git integration can be run from; ``clang/tools/clang-format/git-clang-format``. The LLVM project has migrated to GitHub Pull Requests as its review process.; We still have an active :ref:`Phabricator <phabricator-reviews>`; instance for the duration of the migration. If you want to contribute to LLVM; now, please use GitHub. For more information about the workflow of using GitHub; Pull Requests see our :ref:`GitHub <github-reviews>` documentation. To make sure the right people see your patch, please select su",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Contributing.rst:2827,simpl,simply,2827,interpreter/llvm-project/llvm/docs/Contributing.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Contributing.rst,1,['simpl'],['simply']
Usability,"is can be used in PDF and PS file names.; - In PDF files, italic greek characters were not correct for non null; text angle. ### TImageDump; - Fix a `TBox` clipping issue. ### TSVG; - Some markers did not show in Google-Chrome. ### New class TTeXDump: Graphics interface to TeX. This class allow to generate `PGF/TikZ` vector graphics output; which can be included in TeX and LaTeX documents. `PGF` is a TeX macro package for generating graphics. It is platform; and format-independent and works together with the most important TeX; backend drivers, including pdftex and dvips. It comes with a; user-friedly syntax layer called `TikZ`. To generate a such file it is enough to do:. ```; gStyle->SetPaperSize(10.,10.);; hpx->Draw();; gPad->Print(""hpx.tex"");; ```. Then, the generated file (<tt>hpx.tex</tt>) can be included in a; LaTeX document (`simple.tex`) in the following way:. ```; \documentclass{article}; \usepackage{tikz}; \usetikzlibrary{patterns}; \title{A simple LaTeX example}; \date{July 2013}; \begin{document}; \maketitle; The following image as been generated using the TTeXDump class:; \par; \input{hpx.tex}; \end{document}; ```. Note the two directive needed at the top of the LaTeX file:. ```; \usepackage{tikz}; \usetikzlibrary{patterns}; ```. Then including the picture in the document is done with the; `\input` directive. The command `pdflatex simple.tex` will generate the corresponding pdf; file `simple.pdf`. ### X11 fonts. - A coverity fix in `Rotated.cxx` had a side effect on rotated text; drawn with X11 fonts. ### TCanvas and TPad. - `TPad::SaveAs` produces named macros in .C files.; - Change the way the string input is done in the Pad toolbar for text; and Pave Label. It doesn't use anymore the `TGX11` function `RequestString`.; Now the text appears directly as it will show and it is possible to; enter several text string. The input is not block in the `RequestString` event loop.; - The toolbar methods now work without XOR mode (useful for OpenGL()).; - A new """,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/doc/v600/index.md:1330,simpl,simple,1330,graf2d/doc/v600/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/doc/v600/index.md,1,['simpl'],['simple']
Usability,"is instance random numbers distributed according to; different probability density functions, like the Uniform one at; lines *27-29*. See the on-line documentation to appreciate the full; power of this ROOT feature. - Line *8*: You are already familiar with the `TF1` class. This is; its two-dimensional version. At line *16* two random numbers; distributed according to the `TF2` formula are drawn with the method; `TF2::GetRandom2(double& a, double&b)`. - Line *27-29*: Fitting a 2-dimensional function just works like in; the one-dimensional case, i.e. initialisation of parameters and; calling of the `Fit()` method. - Line *34*: The *Surf1* option draws the `TF2` objects (but also; bi-dimensional histograms) as coloured surfaces with a wire-frame on; three-dimensional canvases. See Figure [4.3](#f43). - Line *35-40*: Retrieve the axis pointer and define the axis titles. - Line *41*: Draw the cloud of points on top of the coloured surface. - Line *43-49*: Here you learn how to create a canvas, partition it in; two sub-pads and access them. It is very handy to show multiple; plots in the same window or image. [f43]: figures/fitted2dFunction.png ""f43""; <a name=""f43""></a>. ![A dataset fitted with a bidimensional function visualised as a colored; surface.\label{f43}][f43]. \newpage. ## Multiple graphs ##. The class `TMultigraph` allows to manipulate a set of graphs as a single entity.; It is a collection of `TGraph` (or derived) objects. When drawn, the X and Y axis; ranges are automatically computed such as all the graphs will be visible. ``` {.cpp .numberLines}; @ROOT_INCLUDE_FILE macros/multigraph.C; ```; - Line *6* creates the multigraph. - Line *9-28*: create two graphs with errors and add them in the multigraph. - Line *30-32*: draw the multigraph. The axis limits are computed automatically; to make sure all the graphs' points will be in range. [f44]: figures/multigraph.png ""f44""; <a name=""f44""></a>. ![A set of graphs grouped in a multigraph.\label{f44}][f44]. [^3] ht",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/graphs.md:4380,learn,learn,4380,documentation/primer/graphs.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/graphs.md,1,['learn'],['learn']
Usability,"is lowered when a coroutine is split into; the start, resume and destroy parts. In the start part, it is a no-op,; in resume and destroy parts, it is replaced with `ret void` instruction and; the rest of the block containing `coro.end` instruction is discarded.; In landing pads it is replaced with an appropriate instruction to unwind to; caller. The handling of coro.end differs depending on whether the target is; using landingpad or WinEH exception model. For landingpad based exception model, it is expected that frontend uses the; `coro.end`_ intrinsic as follows:. .. code-block:: llvm. ehcleanup:; %InResumePart = call i1 @llvm.coro.end(ptr null, i1 true, token none); br i1 %InResumePart, label %eh.resume, label %cleanup.cont. cleanup.cont:; ; rest of the cleanup. eh.resume:; %exn = load ptr, ptr %exn.slot, align 8; %sel = load i32, ptr %ehselector.slot, align 4; %lpad.val = insertvalue { ptr, i32 } undef, ptr %exn, 0; %lpad.val29 = insertvalue { ptr, i32 } %lpad.val, i32 %sel, 1; resume { ptr, i32 } %lpad.val29. The `CoroSpit` pass replaces `coro.end` with ``True`` in the resume functions,; thus leading to immediate unwind to the caller, whereas in start function it; is replaced with ``False``, thus allowing to proceed to the rest of the cleanup; code that is only needed during initial invocation of the coroutine. For Windows Exception handling model, a frontend should attach a funclet bundle; referring to an enclosing cleanuppad as follows:. .. code-block:: llvm. ehcleanup:; %tok = cleanuppad within none []; %unused = call i1 @llvm.coro.end(ptr null, i1 true, token none) [ ""funclet""(token %tok) ]; cleanupret from %tok unwind label %RestOfTheCleanup. The `CoroSplit` pass, if the funclet bundle is present, will insert; ``cleanupret from %tok unwind to caller`` before; the `coro.end`_ intrinsic and will remove the rest of the block. In the unwind path (when the argument is `true`), `coro.end` will mark the coroutine; as done, making it undefined behavior to resume th",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst:45175,resume,resume,45175,interpreter/llvm-project/llvm/docs/Coroutines.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst,1,['resume'],['resume']
Usability,"is pass, only available in ``opt``, prints the post dominator tree into a; ``.dot`` graph. This graph can then be processed with the :program:`dot` tool; to convert it to postscript or some other suitable format. ``dot-post-dom-only``: Print postdominance tree of function to ""dot"" file (with no function bodies); ---------------------------------------------------------------------------------------------------. This pass, only available in ``opt``, prints the post dominator tree into a; ``.dot`` graph, omitting the function bodies. This graph can then be processed; with the :program:`dot` tool to convert it to postscript or some other suitable; format. ``globals-aa``: Simple mod/ref analysis for globals; ---------------------------------------------------. This simple pass provides alias and mod/ref information for global values that; do not have their address taken, and keeps track of whether functions read or; write memory (are ""pure""). For this simple (but very common) case, we can; provide pretty accurate and useful information. ``instcount``: Counts the various types of ``Instruction``\ s; -------------------------------------------------------------. This pass collects the count of all instructions and reports them. ``iv-users``: Induction Variable Users; --------------------------------------. Bookkeeping for ""interesting"" users of expressions computed from induction; variables. ``lazy-value-info``: Lazy Value Information Analysis; ----------------------------------------------------. Interface for lazy computation of value constraint information. ``lint``: Statically lint-checks LLVM IR; ----------------------------------------. This pass statically checks for common and easily-identified constructs which; produce undefined or likely unintended behavior in LLVM IR. It is not a guarantee of correctness, in two ways. First, it isn't; comprehensive. There are checks which could be done statically which are not; yet implemented. Some of these are indicated by TO",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Passes.rst:5715,simpl,simple,5715,interpreter/llvm-project/llvm/docs/Passes.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Passes.rst,1,['simpl'],['simple']
Usability,"is still in active development. This document may become outdated; over time. If you see something that's incorrect, please update it. Use Cases; ---------. MIR patterns are supported in the following places:. * GlobalISel ``GICombineRule``; * GlobalISel ``GICombinePatFrag``. Syntax; ------. MIR patterns use the DAG datatype in TableGen. .. code-block:: text. (inst operand0, operand1, ...). ``inst`` must be a def which inherits from ``Instruction`` (e.g. ``G_FADD``); or ``GICombinePatFrag``. Operands essentially fall into one of two categories:. * immediates. * untyped, unnamed: ``0``; * untyped, named: ``0:$y``; * typed, unnamed: ``(i32 0)``; * typed, named: ``(i32 0):$y``. * machine operands. * untyped: ``$x``; * typed: ``i32:$x``. Semantics:. * A typed operand always adds an operand type check to the matcher.; * There is a trivial type inference system to propagate types. * e.g. You only need to use ``i32:$x`` once in any pattern of a; ``GICombinePatFrag`` alternative or ``GICombineRule``, then all; other patterns in that rule/alternative can simply use ``$x``; (``i32:$x`` is redundant). * A named operand's behavior depends on whether the name has been seen before. * For match patterns, reusing an operand name checks that the operands; are identical (see example 2 below).; * For apply patterns, reusing an operand name simply copies that operand into; the new instruction (see example 2 below). Operands are ordered just like they would be in a MachineInstr: the defs (outs); come first, then the uses (ins). Patterns are generally grouped into another DAG datatype with a dummy operator; such as ``match``, ``apply`` or ``pattern``. Finally, any DAG datatype in TableGen can be named. This also holds for; patterns. e.g. the following is valid: ``(G_FOO $root, (i32 0):$cst):$mypat``.; This may also be helpful to debug issues. Patterns are *always* named, and if; they don't have a name, an ""anonymous"" one is given to them. If you're trying; to debug an error related to a M",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GlobalISel/MIRPatterns.rst:1334,simpl,simply,1334,interpreter/llvm-project/llvm/docs/GlobalISel/MIRPatterns.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GlobalISel/MIRPatterns.rst,1,['simpl'],['simply']
Usability,"ise; * Assumes BasicBlocks are dead unless proven otherwise; * Proves values to be constant, and replaces them with constants; * Proves conditional branches to be unconditional. Note that this pass has a habit of making definitions be dead. It is a good; idea to run a :ref:`DCE <passes-dce>` pass sometime after running this pass. .. _passes-simplifycfg:. ``simplifycfg``: Simplify the CFG; ---------------------------------. Performs dead code elimination and basic block merging. Specifically:. * Removes basic blocks with no predecessors.; * Merges a basic block into its predecessor if there is only one and the; predecessor only has one successor.; * Eliminates PHI nodes for basic blocks with a single predecessor.; * Eliminates a basic block that only contains an unconditional branch. ``sink``: Code sinking; ----------------------. This pass moves instructions into successor blocks, when possible, so that they; aren't executed on paths where their results aren't needed. .. _passes-simple-loop-unswitch:. ``simple-loop-unswitch``: Unswitch loops; ----------------------------------------. This pass transforms loops that contain branches on loop-invariant conditions; to have multiple loops. For example, it turns the left into the right code:. .. code-block:: c++. for (...) if (lic); A for (...); if (lic) A; B; C; B else; C for (...); A; C. This can increase the size of the code exponentially (doubling it every time a; loop is unswitched) so we only unswitch if the resultant code will be smaller; than a threshold. This pass expects :ref:`LICM <passes-licm>` to be run before it to hoist; invariant conditions out of the loop, to make the unswitching opportunity; obvious. ``strip``: Strip all symbols from a module; ------------------------------------------. Performs code stripping. This transformation can delete:. * names for virtual registers; * symbols for internal globals and functions; * debug information. Note that this transformation makes code much less readable, so it",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Passes.rst:35368,simpl,simple-loop-unswitch,35368,interpreter/llvm-project/llvm/docs/Passes.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Passes.rst,1,['simpl'],['simple-loop-unswitch']
Usability,"isfy both it and this License would be to; refrain entirely from distribution of the Program. If any portion of this section is held invalid or unenforceable under; any particular circumstance, the balance of the section is intended to; apply and the section as a whole is intended to apply in other; circumstances. It is not the purpose of this section to induce you to infringe any; patents or other property right claims or to contest validity of any; such claims; this section has the sole purpose of protecting the; integrity of the free software distribution system, which is; implemented by public license practices. Many people have made; generous contributions to the wide range of software distributed; through that system in reliance on consistent application of that; system; it is up to the author/donor to decide if he or she is willing; to distribute software through any other system and a licensee cannot; impose that choice. This section is intended to make thoroughly clear what is believed to; be a consequence of the rest of this License. 8. If the distribution and/or use of the Program is restricted in; certain countries either by patents or by copyrighted interfaces, the; original copyright holder who places the Program under this License; may add an explicit geographical distribution limitation excluding; those countries, so that distribution is permitted only in or among; countries not thus excluded. In such case, this License incorporates; the limitation as if written in the body of this License. 9. The Free Software Foundation may publish revised and/or new versions; of the General Public License from time to time. Such new versions will; be similar in spirit to the present version, but may differ in detail to; address new problems or concerns. Each version is given a distinguishing version number. If the Program; specifies a version number of this License which applies to it and ""any; later version"", you have the option of following the terms and conditio",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/misc/rootql/LICENSE.txt:12021,clear,clear,12021,misc/rootql/LICENSE.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/misc/rootql/LICENSE.txt,2,['clear'],['clear']
Usability,"ist of metadata that; describe the IR. For our purposes, we need to declare a metadata node that; assigns the ""kernel"" attribute to the LLVM IR function that should be emitted; as a PTX `kernel` function. These metadata nodes take the form:. .. code-block:: text. !{<function ref>, metadata !""kernel"", i32 1}. For the previous example, we have:. .. code-block:: llvm. !nvvm.annotations = !{!0}; !0 = !{void (float addrspace(1)*,; float addrspace(1)*,; float addrspace(1)*)* @kernel, !""kernel"", i32 1}. Here, we have a single metadata declaration in ``nvvm.annotations``. This; metadata annotates our ``@kernel`` function with the ``kernel`` attribute. Running the Kernel; ------------------. Generating PTX from LLVM IR is all well and good, but how do we execute it on; a real GPU device? The CUDA Driver API provides a convenient mechanism for; loading and JIT compiling PTX to a native GPU device, and launching a kernel.; The API is similar to OpenCL. A simple example showing how to load and; execute our vector addition code is shown below. Note that for brevity this; code does not perform much error checking!. .. note::. You can also use the ``ptxas`` tool provided by the CUDA Toolkit to offline; compile PTX to machine code (SASS) for a specific GPU architecture. Such; binaries can be loaded by the CUDA Driver API in the same way as PTX. This; can be useful for reducing startup time by precompiling the PTX kernels. .. code-block:: c++. #include <iostream>; #include <fstream>; #include <cassert>; #include ""cuda.h"". void checkCudaErrors(CUresult err) {; assert(err == CUDA_SUCCESS);; }. /// main - Program entry point; int main(int argc, char **argv) {; CUdevice device;; CUmodule cudaModule;; CUcontext context;; CUfunction function;; CUlinkState linker;; int devCount;. // CUDA initialization; checkCudaErrors(cuInit(0));; checkCudaErrors(cuDeviceGetCount(&devCount));; checkCudaErrors(cuDeviceGet(&device, 0));. char name[128];; checkCudaErrors(cuDeviceGetName(name, 128, device));; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/NVPTXUsage.rst:19081,simpl,simple,19081,interpreter/llvm-project/llvm/docs/NVPTXUsage.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/NVPTXUsage.rst,1,['simpl'],['simple']
Usability,"ist+e1; ...&item=[histo1,histo2]&opt=[hist,e1]; 6. Support loading of TStyle object, providing in URL; ...&style=item_name or ...&style=json_file_name; All values are copied directly to JSROOT.gStyle object.; 7. Add callback argument into JSROOT.draw() function.; Function will be called after drawing of object is completed.; Painter for drawn object will be provided as first argument (or null in case of error).; 8. Improve cleanup of JSROOT objects. ## Changes in 4.7.1; 1. Workaround for MathJax output - scaling not always works in Firefox; 2. Fix - bin scaling for box draw option for TH2 and TH3 histograms; 3. Fix - increase points limits for contour plots; 4. Fix - position of 3D canvas in WebKit browsers; 5. Fix - use abs bin content in RMS calculations; 6. Fix - support char star* and object arrays in I/O; 7. Fix - correct decoding of TAxis time offset; 8. Fix - checksum reading for foreign classes. ## Changes in 4.7.0; 1. Implement simple TTree::Draw over single leaf (#80); Support basic types, fixed-size arrays and several vector types; 2. Display of TEveTrack(s) and TEvePointSet(s) over drawn geometry (drag and drop); Also browsing, toggling, highlight of tracks and hits are done.; 3. Let set default geo colors as TGeoManager::DefaultColors() does; 4. Let use original ROOT macros to configure visibility of geometry volumes. Like:; &file=files/alice2.root&item=Geometry;1&opt=macro:macros/geomAlice.C; One can set default colors or colors/transparency for selected volumes.; Also volume, selected for drawing in the macro, will be used in the JSROOT; 5. Support drawing of TH2Poly class with 'col' and 'lego' options; 6. Implement 'CONT', 'ARR' and 'SURF' draw options for TH2 class; 7. Support basic drawing of TPolyLine class; 8. Interactive axis zooming in 3D with mouse, very much like to 2D; 9. Zooming and tool buttons via keyboards. ## Changes in 4.6.0; 1. Improvements in TGeo drawings; - support of large (~10M volumes) models, only most significant volumes are sh",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/changes.md:51596,simpl,simple,51596,js/changes.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/changes.md,1,['simpl'],['simple']
Usability,"isting `RooNLLVar` functionality, e.g. ranges are not yet supported. For more details, consult the usage notes in the [TestStatistics README.md](https://github.com/root-project/root/tree/master/roofit/roofitcore/src/TestStatistics/README.md).; For benchmarking results on the prototype version of the parallelized gradient calculator, see the corresponding [CHEP19 proceedings paper](https://doi.org/10.1051/epjconf/202024506027). ### New pythonizations. Various new pythonizations are introduced to streamline your RooFit code in Python. For a complete list of all pythonized classes and functions, please see the [RooFit pythonizations page in the reference guide](https://root.cern/doc/v626/group__RoofitPythonizations.html).; All RooFit Python tutorials have been updated to profit from all available pythonizations. Some notable highlights are listed in the following. #### Keyword argument pythonizations. All functions that take RooFit command arguments as parameters now accept equivalent Python keyword arguments, for example simplifying calls to [RooAbsPdf::fitTo()](https://root.cern/doc/v626/classRooAbsPdf.html#a5f79f16f4a26a19c9e66fb5c080f59c5) such as:; ```Python; model.fitTo(data, ROOT.RooFit.Range(""left,right""), ROOT.RooFit.Save()); ```; which becomes:; ```Python; model.fitTo(data, Range=""left,right"", Save=True); ```. #### String to enum pythonizations. Many functions that take an enum as a parameter now accept also a string with the enum label. Take for example this expression:; ```Python; data.plotOn(frame, ROOT.RooFit.DataError(ROOT.RooAbsData.SumW2); ```; Combining the enum pythonization with the keyword argument pythonization explained before, this becomes:; ```Python; data.plotOn(frame, DataError=""SumW2""); ```. This pythonization is also useful for your calls to [RooFit::LineColor()](https://root.cern/doc/v626/group__Plotting.html#gad309cf5f63ec87ae5a7025d530f0398f) or [RooFit::LineStyle](https://root.cern/doc/v626/group__Plotting.html#gaf1f7922ba5965c1a5a9791a0",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v626/index.md:19386,simpl,simplifying,19386,README/ReleaseNotes/v626/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v626/index.md,1,['simpl'],['simplifying']
Usability,"istogram. - Lines *33-38*: For convenience, the same function as for the; generation of the pseudo-data is used in the fit; hence, we need to; reset the function parameters. This part of the code is very; important for each fit procedure, as it sets the initial values of; the fit. - Line *41*: A very simple command, well known by now: fit the; function to the histogram. - Lines *42-46*: Retrieve the output from the fit. Here, we simply; print the fit result and access and print the covariance matrix of; the parameters. - Lines *54-end*: Plot the pseudo-data, the fitted function and the; signal and background components at the best-fit values. [f61]: figures/functions.png ""f61""; <a name=""f61""></a>. ![Fit of pseudo data: a signal shape over a background trend. This plot; is another example of how making a plot ""self-explanatory"" can help you; better displaying your results. \label{f61}][f61]. ## Toy Monte Carlo Experiments ##. Let us look at a simple example of a toy experiment comparing two; methods to fit a function to a histogram, the $\chi^{2}$. method and a method called ""binned log-likelihood fit"", both available in ROOT. As a very simple yet powerful quantity to check the quality of the fit; results, we construct for each pseudo-data set the so-called ""pull"", the; difference of the estimated and the true value of a parameter,; normalised to the estimated error on the parameter,; $\frac{(p_{estim} - p_{true})}{\sigma_{p}}$. If everything is OK, the; distribution of the pull values is a standard normal distribution, i.e.; a Gaussian distribution centred around zero with a standard deviation of one. The macro performs a rather big number of toy experiments, where a; histogram is repeatedly filled with Gaussian distributed numbers,; representing the pseudo-data in this example. Each time, a fit is; performed according to the selected method, and the pull is calculated; and filled into a histogram. Here is the code:. ``` {.cpp .numberLines}; @ROOT_INCLUDE_FILE macros",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/functions_and_parameter_estimation.md:4065,simpl,simple,4065,documentation/primer/functions_and_parameter_estimation.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/functions_and_parameter_estimation.md,1,['simpl'],['simple']
Usability,"it (``changeTo(...)``) says to *change* the code matched by the; pattern *to* the text ""MakeX"". Finally, we use ``cat`` again to build a message; that explains the change. Here are some example changes that this rule would make:. +--------------------------+----------------------------+; | Original | Result |; +==========================+============================+; | ``X x = MkX(3);`` | ``X x = MakeX(3);`` |; +--------------------------+----------------------------+; | ``CallFactory(MkX, 3);`` | ``CallFactory(MakeX, 3);`` |; +--------------------------+----------------------------+; | ``auto f = MkX;`` | ``auto f = MakeX;`` |; +--------------------------+----------------------------+. Example: method to function; ^^^^^^^^^^^^^^^^^^^^^^^^^^^. Next, let's write a rule to replace a method call with a (free) function call,; applied to the original method call's target object. Specifically, ""change; ``s.size()`` to ``Size(s)``, where ``s`` is a ``string``."" We start with a simpler; change that ignores the type of ``s``. That is, it will modify *any* method call; where the method is named ""size"":. .. code-block:: c++. llvm::StringRef s = ""str"";; makeRule(; cxxMemberCallExpr(; on(expr().bind(s)),; callee(cxxMethodDecl(hasName(""size"")))),; changeTo(cat(""Size("", node(s), "")"")),; cat(""Method ``size`` is deprecated in favor of free function ``Size``""));. We express the pattern with the given AST matcher, which binds the method call's; target to ``s`` [#f1]_. For the edit, we again use ``changeTo``, but this; time we construct the term from multiple parts, which we compose with ``cat``. The; second part of our term is ``node(s)``, which selects the source code; corresponding to the AST node ``s`` that was bound when a match was found in the; AST for our rule's pattern. ``node(s)`` constructs a ``RangeSelector``, which, when; used in ``cat``, indicates that the selected source should be inserted in the; output at that point. Now, we probably don't want to rewrite *all* invocat",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangTransformerTutorial.rst:5822,simpl,simpler,5822,interpreter/llvm-project/clang/docs/ClangTransformerTutorial.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangTransformerTutorial.rst,1,['simpl'],['simpler']
Usability,"it is initialized as follows:. .. code-block:: c. struct __block_literal_1 __block_literal_1 = {; &_NSConcreteGlobalBlock,; (1<<28)|(1<<29), <uninitialized>,; __block_invoke_1,; &__block_descriptor_1; };. that is, a different address is provided as the first value and a particular; (1<<28) bit is set in the ``flags`` field, and otherwise it is the same as for; stack based ``Block`` literals. This is an optimization that can be used for; any ``Block`` literal that imports no ``const`` or ``__block`` storage; variables. Imported Variables; ==================. Variables of ``auto`` storage class are imported as ``const`` copies. Variables; of ``__block`` storage class are imported as a pointer to an enclosing data; structure. Global variables are simply referenced and not considered as; imported. Imported ``const`` copy variables; ---------------------------------. Automatic storage variables not marked with ``__block`` are imported as; ``const`` copies. The simplest example is that of importing a variable of type ``int``:. .. code-block:: c. int x = 10;; void (^vv)(void) = ^{ printf(""x is %d\n"", x); }; x = 11;; vv();. which would be compiled to:. .. code-block:: c. struct __block_literal_2 {; void *isa;; int flags;; int reserved;; void (*invoke)(struct __block_literal_2 *);; struct __block_descriptor_2 *descriptor;; const int x;; };. void __block_invoke_2(struct __block_literal_2 *_block) {; printf(""x is %d\n"", _block->x);; }. static struct __block_descriptor_2 {; unsigned long int reserved;; unsigned long int Block_size;; } __block_descriptor_2 = { 0, sizeof(struct __block_literal_2) };. and:. .. code-block:: c. struct __block_literal_2 __block_literal_2 = {; &_NSConcreteStackBlock,; (1<<29), <uninitialized>,; __block_invoke_2,; &__block_descriptor_2,; x; };. In summary, scalars, structures, unions, and function pointers are generally; imported as ``const`` copies with no need for helper functions. Imported ``const`` copy of ``Block`` reference; ----------------------",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Block-ABI-Apple.rst:7061,simpl,simplest,7061,interpreter/llvm-project/clang/docs/Block-ABI-Apple.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Block-ABI-Apple.rst,1,['simpl'],['simplest']
Usability,"it value of the induction variable. If the only purpose; of the loop is to compute the exit value of some derived expression, this; transformation will make the loop dead. This transformation should be followed by strength reduction after all of the; desired loop transformations have been performed. Additionally, on targets; where it is profitable, the loop could be transformed to count down to zero; (the ""do loop"" optimization). ``inline``: Function Integration/Inlining; -----------------------------------------. Bottom-up inlining of functions into callees. .. _passes-instcombine:. ``instcombine``: Combine redundant instructions; -----------------------------------------------. Combine instructions to form fewer, simple instructions. This pass does not; modify the CFG. This pass is where algebraic simplification happens. This pass combines things like:. .. code-block:: llvm. %Y = add i32 %X, 1; %Z = add i32 %Y, 1. into:. .. code-block:: llvm. %Z = add i32 %X, 2. This is a simple worklist driven algorithm. This pass guarantees that the following canonicalizations are performed on the; program:. #. If a binary operator has a constant operand, it is moved to the right-hand; side.; #. Bitwise operators with constant operands are always grouped so that shifts; are performed first, then ``or``\ s, then ``and``\ s, then ``xor``\ s.; #. Compare instructions are converted from ``<``, ``>``, ``≤``, or ``≥`` to; ``=`` or ``≠`` if possible.; #. All ``cmp`` instructions on boolean values are replaced with logical; operations.; #. ``add X, X`` is represented as ``mul X, 2`` ⇒ ``shl X, 1``; #. Multiplies with a constant power-of-two argument are transformed into; shifts.; #. … etc. This pass can also simplify calls to specific well-known function calls (e.g.; runtime library functions). For example, a call ``exit(3)`` that occurs within; the ``main()`` function can be transformed into simply ``return 3``. Whether or; not library calls are simplified is controlled by the; :ref:`-",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Passes.rst:19690,simpl,simple,19690,interpreter/llvm-project/llvm/docs/Passes.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Passes.rst,1,['simpl'],['simple']
Usability,"itch i8 %2, label %suspend [i8 0, label %loop.resume; i8 1, label %cleanup]; loop.resume:; %inc = add nsw i32 %n.addr, 1; %sub = xor i32 %n.addr, -1; call void @print(i32 %sub); %3 = call i8 @llvm.coro.suspend(token none, i1 false); switch i8 %3, label %suspend [i8 0, label %loop; i8 1, label %cleanup]. In this case, the coroutine frame would include a suspend index that will; indicate at which suspend point the coroutine needs to resume. .. code-block:: llvm. %f.frame = type { ptr, ptr, i32, i32 }. The resume function will use an index to jump to an appropriate basic block and will look; as follows:. .. code-block:: llvm. define internal fastcc void @f.Resume(ptr %FramePtr) {; entry.Resume:; %index.addr = getelementptr inbounds %f.Frame, ptr %FramePtr, i64 0, i32 2; %index = load i8, ptr %index.addr, align 1; %switch = icmp eq i8 %index, 0; %n.addr = getelementptr inbounds %f.Frame, ptr %FramePtr, i64 0, i32 3; %n = load i32, ptr %n.addr, align 4. br i1 %switch, label %loop.resume, label %loop. loop.resume:; %sub = sub nsw i32 0, %n; call void @print(i32 %sub); br label %suspend; loop:; %inc = add nsw i32 %n, 1; store i32 %inc, ptr %n.addr, align 4; tail call void @print(i32 %inc); br label %suspend. suspend:; %storemerge = phi i8 [ 0, %loop ], [ 1, %loop.resume ]; store i8 %storemerge, ptr %index.addr, align 1; ret void; }. If different cleanup code needs to get executed for different suspend points,; a similar switch will be in the `f.destroy` function. .. note ::. Using suspend index in a coroutine state and having a switch in `f.resume` and; `f.destroy` is one of the possible implementation strategies. We explored; another option where a distinct `f.resume1`, `f.resume2`, etc. are created for; every suspend point, and instead of storing an index, the resume and destroy; function pointers are updated at every suspend. Early testing showed that the; current approach is easier on the optimizer than the latter so it is a; lowering strategy implemented at the moment",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst:19477,resume,resume,19477,interpreter/llvm-project/llvm/docs/Coroutines.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst,1,['resume'],['resume']
Usability,"itial adjustment. .. code-block:: c++. enum RelocationType {; reloc_pcrel_word = 0, // add reloc value after adjusting for the PC loc; reloc_picrel_word = 1, // add reloc value after adjusting for the PIC base; reloc_absolute_word = 2, // absolute relocation; no additional adjustment; reloc_absolute_dword = 3 // absolute relocation; no additional adjustment; };. Target JIT Info; ---------------. ``XXXJITInfo.cpp`` implements the JIT interfaces for target-specific; code-generation activities, such as emitting machine code and stubs. At; minimum, a target-specific version of ``XXXJITInfo`` implements the following:. * ``getLazyResolverFunction`` --- Initializes the JIT, gives the target a; function that is used for compilation. * ``emitFunctionStub`` --- Returns a native function with a specified address; for a callback function. * ``relocate`` --- Changes the addresses of referenced globals, based on; relocation types. * Callback function that are wrappers to a function stub that is used when the; real target is not initially known. ``getLazyResolverFunction`` is generally trivial to implement. It makes the; incoming parameter as the global ``JITCompilerFunction`` and returns the; callback function that will be used a function wrapper. For the Alpha target; (in ``AlphaJITInfo.cpp``), the ``getLazyResolverFunction`` implementation is; simply:. .. code-block:: c++. TargetJITInfo::LazyResolverFn AlphaJITInfo::getLazyResolverFunction(; JITCompilerFn F) {; JITCompilerFunction = F;; return AlphaCompilationCallback;; }. For the X86 target, the ``getLazyResolverFunction`` implementation is a little; more complicated, because it returns a different callback function for; processors with SSE instructions and XMM registers. The callback function initially saves and later restores the callee register; values, incoming arguments, and frame and return address. The callback; function needs low-level access to the registers or stack, so it is typically; implemented with assembler.; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/WritingAnLLVMBackend.rst:83024,simpl,simply,83024,interpreter/llvm-project/llvm/docs/WritingAnLLVMBackend.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/WritingAnLLVMBackend.rst,1,['simpl'],['simply']
Usability,"itize-coverage=trace-pc-guard; % ASAN_OPTIONS=coverage=1 ./a.out; wc -c *.sancov; main; SanitizerCoverage: ./a.out.7312.sancov 2 PCs written; 24 a.out.7312.sancov; % ASAN_OPTIONS=coverage=1 ./a.out foo ; wc -c *.sancov; foo; main; SanitizerCoverage: ./a.out.7316.sancov 3 PCs written; 24 a.out.7312.sancov; 32 a.out.7316.sancov. Every time you run an executable instrumented with SanitizerCoverage; one ``*.sancov`` file is created during the process shutdown.; If the executable is dynamically linked against instrumented DSOs,; one ``*.sancov`` file will be also created for every DSO. Sancov data format; ------------------. The format of ``*.sancov`` files is very simple: the first 8 bytes is the magic,; one of ``0xC0BFFFFFFFFFFF64`` and ``0xC0BFFFFFFFFFFF32``. The last byte of the; magic defines the size of the following offsets. The rest of the data is the; offsets in the corresponding binary/DSO that were executed during the run. Sancov Tool; -----------. A simple ``sancov`` tool is provided to process coverage files.; The tool is part of LLVM project and is currently supported only on Linux.; It can handle symbolization tasks autonomously without any extra support; from the environment. You need to pass .sancov files (named; ``<module_name>.<pid>.sancov`` and paths to all corresponding binary elf files.; Sancov matches these files using module names and binaries file names. .. code-block:: console. USAGE: sancov [options] <action> (<binary file>|<.sancov file>)... Action (required); -print - Print coverage addresses; -covered-functions - Print all covered functions.; -not-covered-functions - Print all not covered functions.; -symbolize - Symbolizes the report. Options; -blocklist=<string> - Blocklist file (sanitizer blocklist format).; -demangle - Print demangled function name.; -strip_path_prefix=<string> - Strip this prefix from file paths in reports. Coverage Reports; ----------------. **Experimental**. ``.sancov`` files do not contain enough information to gener",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SanitizerCoverage.rst:17328,simpl,simple,17328,interpreter/llvm-project/clang/docs/SanitizerCoverage.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SanitizerCoverage.rst,1,['simpl'],['simple']
Usability,"its |; | Maximum number of clusters per group | 4B (foreseen: <10k) | List frame limits, cluster group summary encoding |; | Maximum number of pages per cluster per column | 4B | List frame limits |; | Maximum number of entries per cluster | 2^56 | Cluster summary encoding |; | Maximum string length (meta-data) | 4GB | String encoding |; | Maximum RBlob size | 128 PiB | 1GiB / 8B * 1GiB (with maxKeySize=1GiB, offsetSize=8B) |. ## Glossary. ### Anchor. The anchor is a data block that represents the entry point to an RNTuple.; The anchor is specific to the RNTuple container in which the RNTuple data are embedded (e.g., a ROOT file or an object store).; The anchor must provide the information to load the header and the footer **envelopes**. ### Cluster. A cluster is a set of **pages** that contain all the data belonging to an entry range.; The data set is partitioned in clusters.; A typical cluster size is tens to hundreds of megabytes. ### Column. A column is a storage backed vector of a number of **elements** of a simple type.; Column elements have a fixed bit-length that depends on the column type.; Some column types allow setting the bit lengths within specific limits (e.g. for floats with truncated mantissa). ### Envelope. An envelope is a data block with RNTuple meta-data, such as the header and the footer. ### Field. A field describes a serialized C++ type.; A field can have a hierarchy of subfields representing a composed C++ type (e.g., a vector of integers).; A field has zero, one, or multiple **columns** attached to it.; The columns contain the data related to the field but not to its subfields, which have their own columns. ### Frame. A frame is a byte range with metadata information in an **envelope**.; A frame starts with its size and thus can be extended in a forward-compatible way. ### Locator. A locator is a generalized way to identify a byte range in the RNTuple container.; For a file container, for instance, a locator consists of an offset and a size",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/doc/BinaryFormatSpecification.md:50533,simpl,simple,50533,tree/ntuple/v7/doc/BinaryFormatSpecification.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/doc/BinaryFormatSpecification.md,1,['simpl'],['simple']
Usability,"itself. This can be done using the following syntax:. .. code-block:: c++. // expected-error@path/include.h:15 {{error message}}. The path can be absolute or relative and the same search paths will be used as; for ``#include`` directives. The line number in an external file may be; substituted with ``*`` meaning that any line number will match (useful where; the included file is, for example, a system header where the actual line number; may change and is not critical). As an alternative to specifying a fixed line number, the location of a; diagnostic can instead be indicated by a marker of the form ``#<marker>``.; Markers are specified by including them in a comment, and then referenced by; appending the marker to the diagnostic with ``@#<marker>``, as with:. .. code-block:: c++. #warning some text // #1; // ... other code ...; // expected-warning@#1 {{some text}}. The name of a marker used in a directive must be unique within the compilation. The simple syntax above allows each specification to match exactly one; diagnostic. You can use the extended syntax to customize this. The extended; syntax is ``expected-<type> <n> {{diag text}}``, where ``<type>`` is one of; ``error``, ``warning``, ``remark``, or ``note``, and ``<n>`` is a positive; integer. This allows the diagnostic to appear as many times as specified. For; example:. .. code-block:: c++. void f(); // expected-note 2 {{previous declaration is here}}. Where the diagnostic is expected to occur a minimum number of times, this can; be specified by appending a ``+`` to the number. For example:. .. code-block:: c++. void f(); // expected-note 0+ {{previous declaration is here}}; void g(); // expected-note 1+ {{previous declaration is here}}. In the first example, the diagnostic becomes optional, i.e. it will be; swallowed if it occurs, but will not generate an error if it does not occur. In; the second example, the diagnostic must occur at least once. As a short-hand,; ""one or more"" can be specified simply by ``",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:159444,simpl,simple,159444,interpreter/llvm-project/clang/docs/InternalsManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst,1,['simpl'],['simple']
Usability,"itted to the repository. Must Code Be Reviewed Prior to Being Committed?; -----------------------------------------------. Code can be reviewed either before it is committed or after. We expect; significant patches to be reviewed before being committed. Smaller patches; (or patches where the developer owns the component) that meet; likely-community-consensus requirements (as apply to all patch approvals) can; be committed prior to an explicit review. In situations where there is any; uncertainty, a patch should be reviewed prior to being committed. Please note that the developer responsible for a patch is also; responsible for making all necessary review-related changes, including; those requested during any post-commit review. .. _post_commit_review:. Can Code Be Reviewed After It Is Committed?; -------------------------------------------. Post-commit review is encouraged, and can be accomplished using any of the; tools detailed below. There is a strong expectation that authors respond; promptly to post-commit feedback and address it. Failure to do so is cause for; the patch to be :ref:`reverted <revert_policy>`. If a community member expresses a concern about a recent commit, and this; concern would have been significant enough to warrant a conversation during; pre-commit review (including around the need for more design discussions),; they may ask for a revert to the original author who is responsible to revert; the patch promptly. Developers often disagree, and erring on the side of the; developer asking for more review prevents any lingering disagreement over; code in the tree. This does not indicate any fault from the patch author,; this is inherent to our post-commit review practices.; Reverting a patch ensures that design discussions can happen without blocking; other development; it's entirely possible the patch will end up being reapplied; essentially as-is once concerns have been resolved. Before being recommitted, the patch generally should undergo furthe",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodeReview.rst:1861,feedback,feedback,1861,interpreter/llvm-project/llvm/docs/CodeReview.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodeReview.rst,1,['feedback'],['feedback']
Usability,"ivation for this design is to allow a runtime to; commandeer a stack frame when execution reaches an instruction address; associated with a stack map. The runtime must be able to rebuild a; stack frame and resume program execution using the information; provided by the stack map. For example, execution may resume in an; interpreter or a recompiled version of the same function. This usage restricts LLVM optimization. Clearly, LLVM must not move; stores across a stack map. However, loads must also be handled; conservatively. If the load may trigger an exception, hoisting it; above a stack map could be invalid. For example, the runtime may; determine that a load is safe to execute without a type check given; the current state of the type system. If the type system changes while; some activation of the load's function exists on the stack, the load; becomes unsafe. The runtime can prevent subsequent execution of that; load by immediately patching any stack map location that lies between; the current call site and the load (typically, the runtime would; simply patch all stack map locations to invalidate the function). If; the compiler had hoisted the load above the stack map, then the; program could crash before the runtime could take back control. To enforce these semantics, stackmap and patchpoint intrinsics are; considered to potentially read and write all memory. This may limit; optimization more than some clients desire. This limitation may be; avoided by marking the call site as ""readonly"". In the future we may; also allow meta-data to be added to the intrinsic call to express; aliasing, thereby allowing optimizations to hoist certain loads above; stack maps. Direct Stack Map Entries; ^^^^^^^^^^^^^^^^^^^^^^^^. As shown in :ref:`stackmap-section`, a Direct stack map location; records the address of frame index. This address is itself the value; that the runtime requested. This differs from Indirect locations,; which refer to a stack locations from which the requested ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/StackMaps.rst:18551,simpl,simply,18551,interpreter/llvm-project/llvm/docs/StackMaps.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/StackMaps.rst,1,['simpl'],['simply']
Usability,"iven that ROOT injects `using namespace std` directive, _all_ the names in the `std` namespace become available in the global scope. However, in some circumstances users inadvertently introduce a declaration that conflicts with a name in `std` making references to the former declaration result in ambiguous lookup.; A fairly common case is trying to declare a global variable named `data` which conflict with [`std::data`](https://en.cppreference.com/w/cpp/iterator/data) [C++17]. See [ROOT-5971](https://sft.its.cern.ch/jira/browse/ROOT-5971) for a discussion.; As of v6.28, such declarations result in; ```; root [] int data;; ROOT_prompt_0:1:1: warning: 'data' shadows a declaration with the same name in the 'std' namespace; use '::data' to reference this declaration; int data;; ^; ```. - Line editing at the ROOT interactive prompt has been improved. This version introduces useful shortcuts for common actions, e.g. Xterm-like fast movement between words using Ctrl+Left and Ctrl+Right, Ctrl+Del to delete the word under the cursor, or clearing the screen using Ctrl+L. Most users coming from a GUI will find these shortcuts convenient.; A list of the available key bindings is printed by; ```; root [] .help edit; ```. ## I/O Libraries. ### Faster reading from EOS. A new cross-protocol redirection has been added to allow files on EOS mounts to be opened; by `TFile::Open` via XRootD protocol rather than via FUSE when that is possible. The; redirection uses the `eos.url.xroot` extended file attribute that is present on files in EOS.; The attribute can be viewed with `getfattr -n eos.url.xroot [file]` on the command line.; When the URL passed into `TFile::Open` is a for a file on an EOS mount, the extended; attribute is used to attempt the redirection to XRootD protocol. If the redirection fails,; the file is opened using the plain file path as before. This feature is controlled by the; pre-existing configuration option `TFile.CrossProtocolRedirects` and is enabled by default.; I",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v628/index.md:7443,clear,clearing,7443,README/ReleaseNotes/v628/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v628/index.md,1,['clear'],['clearing']
Usability,"ize Offsetting of Location Descriptions; --------------------------------------------------. The ``DW_OP_plus`` and ``DW_OP_minus`` operations can be defined to operate on a; memory location description in the default target architecture specific address; space and a generic type value to produce an updated memory location; description. This allows them to continue to be used to offset an address. To generalize offsetting to any location description, including location; descriptions that describe when bytes are in registers, are implicit, or a; composite of these, the ``DW_OP_LLVM_offset``, ``DW_OP_LLVM_offset_uconst``, and; ``DW_OP_LLVM_bit_offset`` offset operations are added. The offset operations can operate on location storage of any size. For example,; implicit location storage could be any number of bits in size. It is simpler to; define offsets that exceed the size of the location storage as being an; evaluation error, than having to force an implementation to support potentially; infinite precision offsets to allow it to correctly track a series of positive; and negative offsets that may transiently overflow or underflow, but end up in; range. This is simple for the arithmetic operations as they are defined in terms; of two's complement arithmetic on a base type of a fixed size. Therefore, the; offset operation define that integer overflow is ill-formed. This is in contrast; to the ``DW_OP_plus``, ``DW_OP_plus_uconst``, and ``DW_OP_minus`` arithmetic; operations which define that it causes wrap-around. Having the offset operations allows ``DW_OP_push_object_address`` to push a; location description that may be in a register, or be an implicit value. The; DWARF expression of ``DW_TAG_ptr_to_member_type`` can use the offset operations; without regard to what kind of location description was pushed. Since; :ref:`amdgpu-dwarf-allow-location-description-on-the-dwarf-evaluation-stack` has; generalized location storage to be bit indexable, ``DW_OP_LLVM_bit_offset``",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst:11565,simpl,simpler,11565,interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,1,['simpl'],['simpler']
Usability,"ized: true, runtimeVersion: 0, emissionKind: FullDebug, enums: !2); !1 = !DIFile(filename: ""debugify-sample.ll"", directory: ""/""); !2 = !{}; !3 = !{i32 5}; !4 = !{i32 2}; !5 = !{i32 2, !""Debug Info Version"", i32 3}; !6 = distinct !DISubprogram(name: ""f"", linkageName: ""f"", scope: null, file: !1, line: 1, type: !7, isLocal: false, isDefinition: true, scopeLine: 1, isOptimized: true, unit: !0, retainedNodes: !8); !7 = !DISubroutineType(types: !2); !8 = !{!9, !11}; !9 = !DILocalVariable(name: ""1"", scope: !6, file: !1, line: 1, type: !10); !10 = !DIBasicType(name: ""ty64"", size: 64, encoding: DW_ATE_unsigned); !11 = !DILocalVariable(name: ""2"", scope: !6, file: !1, line: 3, type: !10); !12 = !DILocation(line: 1, column: 1, scope: !6); !13 = !DILocation(line: 2, column: 1, scope: !6); !14 = !DILocation(line: 3, column: 1, scope: !6); !15 = !DILocation(line: 4, column: 1, scope: !6); !16 = !DILocation(line: 5, column: 1, scope: !6). Using ``debugify``; ^^^^^^^^^^^^^^^^^^. A simple way to use ``debugify`` is as follows:. .. code-block:: bash. $ opt -debugify -pass-to-test -check-debugify sample.ll. This will inject synthetic DI to ``sample.ll`` run the ``pass-to-test`` and; then check for missing DI. The ``-check-debugify`` step can of course be; omitted in favor of more customizable FileCheck directives. Some other ways to run debugify are available:. .. code-block:: bash. # Same as the above example.; $ opt -enable-debugify -pass-to-test sample.ll. # Suppresses verbose debugify output.; $ opt -enable-debugify -debugify-quiet -pass-to-test sample.ll. # Prepend -debugify before and append -check-debugify -strip after; # each pass on the pipeline (similar to -verify-each).; $ opt -debugify-each -O2 sample.ll. In order for ``check-debugify`` to work, the DI must be coming from; ``debugify``. Thus, modules with existing DI will be skipped. ``debugify`` can be used to test a backend, e.g:. .. code-block:: bash. $ opt -debugify < sample.ll | llc -o -. There is also a MIR-level debug",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToUpdateDebugInfo.rst:12005,simpl,simple,12005,interpreter/llvm-project/llvm/docs/HowToUpdateDebugInfo.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToUpdateDebugInfo.rst,1,['simpl'],['simple']
Usability,"ject/releases>`_.; Select the last link: ``Source code (zip)`` and unpack the downloaded file using; Windows Explorer built-in zip support or any other unzip tool. 12. Finally, configure LLVM using CMake:. .. code-block:: bat. cmake -S llvm\llvm -B build -DLLVM_ENABLE_PROJECTS=clang -DLLVM_TARGETS_TO_BUILD=X86 -Thost=x64; exit. ``LLVM_ENABLE_PROJECTS`` specifies any additional LLVM projects you want to; build while ``LLVM_TARGETS_TO_BUILD`` selects the compiler targets. If; ``LLVM_TARGETS_TO_BUILD`` is omitted by default all targets are built; slowing compilation and using more disk space.; See the :doc:`LLVM CMake guide <CMake>` for detailed information about; how to configure the LLVM build. The ``cmake`` command line tool is bundled with Visual Studio but its GUI is; not. You may install `CMake <http://www.cmake.org/>`_ to use its GUI to change; CMake variables or modify the above command line. * Once CMake is installed then the simplest way is to just start the; CMake GUI, select the directory where you have LLVM extracted to, and; the default options should all be fine. One option you may really; want to change, regardless of anything else, might be the; ``CMAKE_INSTALL_PREFIX`` setting to select a directory to INSTALL to; once compiling is complete, although installation is not mandatory for; using LLVM. Another important option is ``LLVM_TARGETS_TO_BUILD``,; which controls the LLVM target architectures that are included on the; build.; * CMake generates project files for all build types. To select a specific; build type, use the Configuration manager from the VS IDE or the; ``/property:Configuration`` command line option when using MSBuild.; * By default, the Visual Studio project files generated by CMake use the; 32-bit toolset. If you are developing on a 64-bit version of Windows and; want to use the 64-bit toolset, pass the ``-Thost=x64`` flag when; generating the Visual Studio solution. This requires CMake 3.8.0 or later. 13. Start Visual Studio and select",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GettingStartedVS.rst:5704,simpl,simplest,5704,interpreter/llvm-project/llvm/docs/GettingStartedVS.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GettingStartedVS.rst,1,['simpl'],['simplest']
Usability,"jectLayer to link the object file produced by our compiler. So far we have learned how to optimize and compile our LLVM IR, but we have; not focused on when compilation happens. Our current REPL optimizes and; compiles each function as soon as it is referenced by any other code,; regardless of whether it is ever called at runtime. In the next chapter we; will introduce a fully lazy compilation, in which functions are not compiled; until they are first called at run-time. At this point the trade-offs get much; more interesting: the lazier we are, the quicker we can start executing the; first function, but the more often we will have to pause to compile newly; encountered functions. If we only code-gen lazily, but optimize eagerly, we; will have a longer startup time (as everything is optimized at that time) but; relatively short pauses as each function just passes through code-gen. If we; both optimize and code-gen lazily we can start executing the first function; more quickly, but we will have longer pauses as each function has to be both; optimized and code-gen'd when it is first executed. Things become even more; interesting if we consider interprocedural optimizations like inlining, which; must be performed eagerly. These are complex trade-offs, and there is no; one-size-fits all solution to them, but by providing composable layers we leave; the decisions to the person implementing the JIT, and make it easy for them to; experiment with different configurations. `Next: Adding Per-function Lazy Compilation <BuildingAJIT3.html>`_. Full Code Listing; =================. Here is the complete code listing for our running example with an; IRTransformLayer added to enable optimization. To build this example, use:. .. code-block:: bash. # Compile; clang++ -g toy.cpp `llvm-config --cxxflags --ldflags --system-libs --libs core orcjit native` -O3 -o toy; # Run; ./toy. Here is the code:. .. literalinclude:: ../../examples/Kaleidoscope/BuildingAJIT/Chapter2/KaleidoscopeJIT.h; :",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/BuildingAJIT2.rst:11312,pause,pauses,11312,interpreter/llvm-project/llvm/docs/tutorial/BuildingAJIT2.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/BuildingAJIT2.rst,1,['pause'],['pauses']
Usability,"jects located; at multiple places. Collectively these changes expand the set of architectures; that can be supported and improves support for optimized code. Several approaches were considered, and the one presented, together with the; extensions it enables, appears to be the simplest and cleanest one that offers; the greatest improvement of DWARF's ability to support debugging optimized GPU; and non-GPU code. Examining the GDB debugger and LLVM compiler, it appears only; to require modest changes as they both already have to support general use of; location descriptions. It is anticipated that will also be the case for other; debuggers and compilers. GDB has been modified to evaluate DWARF Version 5 expressions with location; descriptions as stack entries and with implicit conversions. All GDB tests have; passed, except one that turned out to be an invalid test case by DWARF Version 5; rules. The code in GDB actually became simpler as all evaluation is done on a; single stack and there was no longer a need to maintain a separate structure for; the location description results. This gives confidence in backwards; compatibility. See :ref:`amdgpu-dwarf-expressions` and nested sections. This extension is separately described at *Allow Location Descriptions on the; DWARF Expression Stack* [:ref:`AMDGPU-DWARF-LOC; <amdgpu-dwarf-AMDGPU-DWARF-LOC>`]. 2.2 Generalize CFI to Allow Any Location Description Kind; ---------------------------------------------------------. CFI describes restoring callee saved registers that are spilled. Currently CFI; only allows a location description that is a register, memory address, or; implicit location description. AMDGPU optimized code may spill scalar registers; into portions of vector registers. This requires extending CFI to allow any; location description kind to be supported. See :ref:`amdgpu-dwarf-call-frame-information`. 2.3 Generalize DWARF Operation Expressions to Support Multiple Places; -----------------------------------------",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst:7708,simpl,simpler,7708,interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,1,['simpl'],['simpler']
Usability,"k, nor is there; any streamerinfo for such a member. A data member that is a C++ pointer (not to be confused with ""pointers to persistent; objects"" described below) is never written to disk as a pointer value. If it is a; pointer to an object, the object itself (or 0 (4 bytes) if the pointer value is NULL); is written. If the declaration line has a comment beginning with ""//->"", this indicates; that the pointer value will never be null, which allows a performance optimization.; Another optimization is that if two or more pointers pointing to the same object are; streamed in the same I/O operation, the object is written only once. The remaining; pointers reference the object through a unique object identifier. This saves space; and avoids the infinite loop that might otherwise arise if the directed graph of object; instance pointer references contains a cycle. If a data member is a pointer to a simple type, the Streamer presumes it is an array,; with the dimension defined in a comment of the form ""//[<length>]"", where length is; either an integer constant or a variable that is an integer data member of the class.; If a variable is used, it must be defined ahead of its use or in a base class. The above describes the function of the StreamerInfo record in decomposing a; self-identifying object if the user uses the streamer generated by ""rootcint"".; There are two reasons why a user may need to write a specialized streamer for a class.; One reason is that it may be necessary to execute some code before or after data is read; or written, for example, to initialize some non-persistent data members after the; persistent data is read. In this case, the custom streamer can use the StreamerInfo record; to decompose a self-identifying object in the exact same manner as the generated; streamer would have done. An example is given (for the Event class) in the Root User's; Guide (URL below) (Input/Output chapter, Streamers subchapter). On the other hand, if; the user needs to writ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/doc/TFile/README.md:8511,simpl,simple,8511,io/doc/TFile/README.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/doc/TFile/README.md,1,['simpl'],['simple']
Usability,"kay. Now we'll build Clang!. .. code-block:: console. cd ~/clang-llvm; mkdir build && cd build; cmake -G Ninja ../llvm-project/llvm -DLLVM_ENABLE_PROJECTS=""clang;clang-tools-extra"" -DCMAKE_BUILD_TYPE=Release -DLLVM_BUILD_TESTS=ON; ninja; ninja check # Test LLVM only.; ninja clang-test # Test Clang only.; ninja install. And we're live. All of the tests should pass. Finally, we want to set Clang as its own compiler. .. code-block:: console. cd ~/clang-llvm/build; ccmake ../llvm-project/llvm. The second command will bring up a GUI for configuring Clang. You need; to set the entry for ``CMAKE_CXX_COMPILER``. Press ``'t'`` to turn on; advanced mode. Scroll down to ``CMAKE_CXX_COMPILER``, and set it to; ``/usr/bin/clang++``, or wherever you installed it. Press ``'c'`` to; configure, then ``'g'`` to generate CMake's files. Finally, run ninja one last time, and you're done. Step 1: Create a ClangTool; ==========================. Now that we have enough background knowledge, it's time to create the; simplest productive ClangTool in existence: a syntax checker. While this; already exists as ``clang-check``, it's important to understand what's; going on. First, we'll need to create a new directory for our tool and tell CMake; that it exists. As this is not going to be a core clang tool, it will; live in the ``clang-tools-extra`` repository. .. code-block:: console. cd ~/clang-llvm/llvm-project; mkdir clang-tools-extra/loop-convert; echo 'add_subdirectory(loop-convert)' >> clang-tools-extra/CMakeLists.txt; vim clang-tools-extra/loop-convert/CMakeLists.txt. CMakeLists.txt should have the following contents:. ::. set(LLVM_LINK_COMPONENTS support). add_clang_executable(loop-convert; LoopConvert.cpp; ); target_link_libraries(loop-convert; PRIVATE; clangAST; clangASTMatchers; clangBasic; clangFrontend; clangSerialization; clangTooling; ). With that done, Ninja will be able to compile our tool. Let's give it; something to compile! Put the following into; ``clang-tools-extra/loop-conve",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersTutorial.rst:2516,simpl,simplest,2516,interpreter/llvm-project/clang/docs/LibASTMatchersTutorial.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersTutorial.rst,1,['simpl'],['simplest']
Usability,"kdir PATH_TO_MINIUT2_BUILD; cd PATH_TO_MINUIT2_BUILD; cmake PATH_TO_MINUIT2_SOURCE; cmake --build .; ```. Of course, GUIs, IDEs, etc. that work with [CMake] will work with this package. The standard method of CMake building, with a build directory inside the Minuit2 source directory and using the makefile generator, would look like:. ```bash; cd PATH_TO_MINUIT2_SOURCE; mkdir build; cd build; cmake ..; make; ```. The standard [CMake] variables, such as `CMAKE_BUILD_TYPE` and `CMAKE_INSTALL_PREFIX`, work with Minuit2. There are two other options:. * `minuit2_mpi` activates the (outdated C++) MPI bindings.; * `minuit2_omp` activates OpenMP (make sure all FCNs are threadsafe). ## Testing. You can run `ctest` or `make test` to run the Minuit2 test suite. ## Installing or using in another package. You can install the package using `cmake --build --target install .` (or `make install` if directly using the make system), or you can use it from the build directory. You can also include it in another CMake project using `add_subdirectory()` and linking to the `Minuit2` target. Since this package also exports targets, `find_package(Minuit2)` will also work once this package is built or installed. (For the curious, CMake adds a config script to `~/.cmake/packages` when building or; `$CMAKE_INSTALL_PREFIX/share/cmake/Modules` when installing a package that has export commands.). To repeat; using this in your own CMake project usually amounts to:. ```cmake; find_package(Minuit2); # OR; add_subdirectory(Minuit2). target_link_libraries(MyExeOrLib PUBLIC Minuit2::Minuit2); ```. You do not need to add include directories or anything else for Minuit2; the CMake target system handles all of this for you. ## Packaging. To build a binary package (add other generators with `-G`):; ```bash; make package; ```. [DEVELOP.md]: ./DEVELOP.md; [ROOT]: https://root.cern; [minuitdoc]: https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html#minuit2-package; [CMake]: https://cmake.org; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/README.md:2565,guid,guides,2565,math/minuit2/README.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/README.md,2,['guid'],"['guide', 'guides']"
Usability,"ke check LIT_ARGS=""-v --vg --vg-leak"". to enable testing with valgrind and with leak checking enabled. To run individual tests or subsets of tests, you can use the ``llvm-lit``; script which is built as part of LLVM. For example, to run the; ``Integer/BitPacked.ll`` test by itself you can run:. .. code-block:: bash. % llvm-lit ~/llvm/test/Integer/BitPacked.ll. or to run all of the ARM CodeGen tests:. .. code-block:: bash. % llvm-lit ~/llvm/test/CodeGen/ARM. The regression tests will use the Python psutil module only if installed in a; **non-user** location. Under Linux, install with sudo or within a virtual; environment. Under Windows, install Python for all users and then run; ``pip install psutil`` in an elevated command prompt. For more information on using the :program:`lit` tool, see ``llvm-lit --help``; or the :doc:`lit man page <CommandGuide/lit>`. Debugging Information tests; ---------------------------. To run debugging information tests simply add the ``cross-project-tests``; project to your ``LLVM_ENABLE_PROJECTS`` define on the cmake; command-line. Regression test structure; =========================. The LLVM regression tests are driven by :program:`lit` and are located in the; ``llvm/test`` directory. This directory contains a large array of small tests that exercise; various features of LLVM and to ensure that regressions do not occur.; The directory is broken into several sub-directories, each focused on a; particular area of LLVM. Writing new regression tests; ----------------------------. The regression test structure is very simple, but does require some; information to be set. This information is gathered via ``cmake``; and is written to a file, ``test/lit.site.cfg.py`` in the build directory.; The ``llvm/test`` Makefile does this work for you. In order for the regression tests to work, each directory of tests must; have a ``lit.local.cfg`` file. :program:`lit` looks for this file to determine; how to run the tests. This file is just Python code a",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TestingGuide.rst:6788,simpl,simply,6788,interpreter/llvm-project/llvm/docs/TestingGuide.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TestingGuide.rst,1,['simpl'],['simply']
Usability,"ke.org/cmake/help/v3.4/manual/cmake-language.7.html>`_. 10,000 ft View; ==============. CMake is a tool that reads script files in its own language that describe how a; software project builds. As CMake evaluates the scripts it constructs an; internal representation of the software project. Once the scripts have been; fully processed, if there are no errors, CMake will generate build files to; actually build the project. CMake supports generating build files for a variety; of command line build tools as well as for popular IDEs. When a user runs CMake it performs a variety of checks similar to how autoconf; worked historically. During the checks and the evaluation of the build; description scripts CMake caches values into the CMakeCache. This is useful; because it allows the build system to skip long-running checks during; incremental development. CMake caching also has some drawbacks, but that will be; discussed later. Scripting Overview; ==================. CMake's scripting language has a very simple grammar. Every language construct; is a command that matches the pattern _name_(_args_). Commands come in three; primary types: language-defined (commands implemented in C++ in CMake), defined; functions, and defined macros. The CMake distribution also contains a suite of; CMake modules that contain definitions for useful functionality. The example below is the full CMake build for building a C++ ""Hello World""; program. The example uses only CMake language-defined functions. .. code-block:: cmake. cmake_minimum_required(VERSION 3.20.0); project(HelloWorld); add_executable(HelloWorld HelloWorld.cpp). The CMake language provides control flow constructs in the form of foreach loops; and if blocks. To make the example above more complicated you could add an if; block to define ""APPLE"" when targeting Apple platforms:. .. code-block:: cmake. cmake_minimum_required(VERSION 3.20.0); project(HelloWorld); add_executable(HelloWorld HelloWorld.cpp); if(APPLE); target_compile_def",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CMakePrimer.rst:1726,simpl,simple,1726,interpreter/llvm-project/llvm/docs/CMakePrimer.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CMakePrimer.rst,1,['simpl'],['simple']
Usability,"ke:. .. code-block:: c++. if (auto Err =; handleErrors(; processFormattedFile(...),; [](const BadFileFormat &BFF) {; report(""Unable to process "" + BFF.Path + "": bad format"");; },; [](const FileNotFound &FNF) {; report(""File not found "" + FNF.Path);; })); return Err;. In cases where you truly know that the handler list is exhaustive the; ``handleAllErrors`` function can be used instead. This is identical to; ``handleErrors`` except that it will terminate the program if an unhandled; error is passed in, and can therefore return void. The ``handleAllErrors``; function should generally be avoided: the introduction of a new error type; elsewhere in the program can easily turn a formerly exhaustive list of errors; into a non-exhaustive list, risking unexpected program termination. Where; possible, use handleErrors and propagate unknown errors up the stack instead. For tool code, where errors can be handled by printing an error message then; exiting with an error code, the :ref:`ExitOnError <err_exitonerr>` utility; may be a better choice than handleErrors, as it simplifies control flow when; calling fallible functions. In situations where it is known that a particular call to a fallible function; will always succeed (for example, a call to a function that can only fail on a; subset of inputs with an input that is known to be safe) the; :ref:`cantFail <err_cantfail>` functions can be used to remove the error type,; simplifying control flow. StringError; """""""""""""""""""""". Many kinds of errors have no recovery strategy, the only action that can be; taken is to report them to the user so that the user can attempt to fix the; environment. In this case representing the error as a string makes perfect; sense. LLVM provides the ``StringError`` class for this purpose. It takes two; arguments: A string error message, and an equivalent ``std::error_code`` for; interoperability. It also provides a ``createStringError`` function to simplify; common usage of this class:. .. code-block:: c++",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:26217,simpl,simplifies,26217,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,1,['simpl'],['simplifies']
Usability,"ken for long periods of time (weeks or more).; * Clearly superior alternatives are in use and maintenance is painful.; * Builds and tests are harder / take longer, increasing the cost of; maintenance, overtaking the perceived benefits. If the maintenance cost is higher than it is acceptable by the majority of; developers, it means that either the sub-community is too small (and the extra; cost should be paid locally), or not active enough (and the problems won't be; fixed any time soon). In either case, removal of such problematic component is; justified. Steps for removal; -----------------. However clear the needs for removal are, we should take an incremental approach; to deprecating code, especially when there's still a sub-community that cares; about it. In that sense, code will never be removed outright without a series; of steps are taken. A minimum set of steps should be:; #. A proposal for removal / deactivation should be made to the Discourse forums ; (under the appropriate category), with a clear; statement of the maintenance costs imposed and the alternatives, if; applicable.; #. There must be enough consensus on the list that removal is warranted, and no; pending proposals to fix the situation from a sub-community.; #. An announcement for removal must be made on the same lists, with ample time; for downstream users to take action on their local infrastructure. The time; will depend on what is being removed. #. If a script or documents are to be removed, they can always be pulled; from previous revision, and can be removed within days.; #. if a whole target is removed, we need to first announce publicly, and; potentially mark as deprecated in one release, only to remove on the; next release.; #. Everything else will fall in between those two extremes.; #. The removal is made by either the proposer or the sub-community that used to; maintain it, with replacements and arrangements made atomically on the same; commit. If a proposal for removal is delayed by",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SupportPolicy.rst:9541,clear,clear,9541,interpreter/llvm-project/llvm/docs/SupportPolicy.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SupportPolicy.rst,1,['clear'],['clear']
Usability,"ken>). Overview:; """""""""""""""""". The '``llvm.coro.end``' marks the point where execution of the resume part of; the coroutine should end and control should return to the caller. Arguments:; """""""""""""""""""". The first argument should refer to the coroutine handle of the enclosing; coroutine. A frontend is allowed to supply null as the first parameter, in this; case `coro-early` pass will replace the null with an appropriate coroutine; handle value. The second argument should be `true` if this coro.end is in the block that is; part of the unwind sequence leaving the coroutine body due to an exception and; `false` otherwise. Non-trivial (non-none) token argument can only be specified for unique-suspend; returned-continuation coroutines where it must be a token value produced by; '``llvm.coro.end.results``' intrinsic. Only none token is allowed for coro.end calls in unwind sections. Semantics:; """"""""""""""""""""; The purpose of this intrinsic is to allow frontends to mark the cleanup and; other code that is only relevant during the initial invocation of the coroutine; and should not be present in resume and destroy parts. In returned-continuation lowering, ``llvm.coro.end`` fully destroys the; coroutine frame. If the second argument is `false`, it also returns from; the coroutine with a null continuation pointer, and the next instruction; will be unreachable. If the second argument is `true`, it falls through; so that the following logic can resume unwinding. In a yield-once; coroutine, reaching a non-unwind ``llvm.coro.end`` without having first; reached a ``llvm.coro.suspend.retcon`` has undefined behavior. The remainder of this section describes the behavior under switched-resume; lowering. This intrinsic is lowered when a coroutine is split into; the start, resume and destroy parts. In the start part, it is a no-op,; in resume and destroy parts, it is replaced with `ret void` instruction and; the rest of the block containing `coro.end` instruction is discarded.; In landing pads it i",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst:43555,resume,resume,43555,interpreter/llvm-project/llvm/docs/Coroutines.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst,1,['resume'],['resume']
Usability,"know that the handler list is exhaustive the; ``handleAllErrors`` function can be used instead. This is identical to; ``handleErrors`` except that it will terminate the program if an unhandled; error is passed in, and can therefore return void. The ``handleAllErrors``; function should generally be avoided: the introduction of a new error type; elsewhere in the program can easily turn a formerly exhaustive list of errors; into a non-exhaustive list, risking unexpected program termination. Where; possible, use handleErrors and propagate unknown errors up the stack instead. For tool code, where errors can be handled by printing an error message then; exiting with an error code, the :ref:`ExitOnError <err_exitonerr>` utility; may be a better choice than handleErrors, as it simplifies control flow when; calling fallible functions. In situations where it is known that a particular call to a fallible function; will always succeed (for example, a call to a function that can only fail on a; subset of inputs with an input that is known to be safe) the; :ref:`cantFail <err_cantfail>` functions can be used to remove the error type,; simplifying control flow. StringError; """""""""""""""""""""". Many kinds of errors have no recovery strategy, the only action that can be; taken is to report them to the user so that the user can attempt to fix the; environment. In this case representing the error as a string makes perfect; sense. LLVM provides the ``StringError`` class for this purpose. It takes two; arguments: A string error message, and an equivalent ``std::error_code`` for; interoperability. It also provides a ``createStringError`` function to simplify; common usage of this class:. .. code-block:: c++. // These two lines of code are equivalent:; make_error<StringError>(""Bad executable"", errc::executable_format_error);; createStringError(errc::executable_format_error, ""Bad executable"");. If you're certain that the error you're building will never need to be converted; to a ``std::error_code",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:26576,simpl,simplifying,26576,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,1,['simpl'],['simplifying']
Usability,"ks; which are outside of the loop that have predecessors inside of the loop) only; have predecessors from inside of the loop (and are thus dominated by the loop; header). This simplifies transformations such as store-sinking that are built; into LICM. This pass also guarantees that loops will have exactly one backedge. Note that the :ref:`simplifycfg <passes-simplifycfg>` pass will clean up blocks; which are split out but end up being unnecessary, so usage of this pass should; not pessimize generated code. This pass obviously modifies the CFG, but updates loop information and; dominator information. ``loop-unroll``: Unroll loops; -----------------------------. This pass implements a simple loop unroller. It works best when loops have; been canonicalized by the :ref:`indvars <passes-indvars>` pass, allowing it to; determine the trip counts of loops easily. ``loop-unroll-and-jam``: Unroll and Jam loops; ---------------------------------------------. This pass implements a simple unroll and jam classical loop optimisation pass.; It transforms loop from:. .. code-block:: c++. for i.. i+= 1 for i.. i+= 4; for j.. for j..; code(i, j) code(i, j); code(i+1, j); code(i+2, j); code(i+3, j); remainder loop. Which can be seen as unrolling the outer loop and ""jamming"" (fusing) the inner; loops into one. When variables or loads can be shared in the new inner loop, this; can lead to significant performance improvements. It uses; :ref:`Dependence Analysis <passes-da>` for proving the transformations are safe. ``lower-global-dtors``: Lower global destructors; ------------------------------------------------. This pass lowers global module destructors (``llvm.global_dtors``) by creating; wrapper functions that are registered as global constructors in; ``llvm.global_ctors`` and which contain a call to ``__cxa_atexit`` to register; their destructor functions. ``loweratomic``: Lower atomic intrinsics to non-atomic form; -----------------------------------------------------------. This pa",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Passes.rst:28265,simpl,simple,28265,interpreter/llvm-project/llvm/docs/Passes.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Passes.rst,1,['simpl'],['simple']
Usability,"l :ref:`operand bundles <opbundles>` list. Semantics:; """""""""""""""""""". This instruction is designed to operate as a standard '``call``'; instruction in most regards. The primary difference is that it; establishes an association with additional labels to define where control; flow goes after the call. The output values of a '``callbr``' instruction are available only to; the '``fallthrough``' block, not to any '``indirect``' blocks(s). The only use of this today is to implement the ""goto"" feature of gcc inline; assembly where additional labels can be provided as locations for the inline; assembly to jump to. Example:; """""""""""""""". .. code-block:: llvm. ; ""asm goto"" without output constraints.; callbr void asm """", ""r,!i""(i32 %x); to label %fallthrough [label %indirect]. ; ""asm goto"" with output constraints.; <result> = callbr i32 asm """", ""=r,r,!i""(i32 %x); to label %fallthrough [label %indirect]. .. _i_resume:. '``resume``' Instruction; ^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. resume <type> <value>. Overview:; """""""""""""""""". The '``resume``' instruction is a terminator instruction that has no; successors. Arguments:; """""""""""""""""""". The '``resume``' instruction requires one argument, which must have the; same type as the result of any '``landingpad``' instruction in the same; function. Semantics:; """""""""""""""""""". The '``resume``' instruction resumes propagation of an existing; (in-flight) exception whose unwinding was interrupted with a; :ref:`landingpad <i_landingpad>` instruction. Example:; """""""""""""""". .. code-block:: llvm. resume { ptr, i32 } %exn. .. _i_catchswitch:. '``catchswitch``' Instruction; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. <resultval> = catchswitch within <parent> [ label <handler1>, label <handler2>, ... ] unwind to caller; <resultval> = catchswitch within <parent> [ label <handler1>, label <handler2>, ... ] unwind label <default>. Overview:; """""""""""""""""". The '``catchswitch``' instruction is used by `LLVM's exception handling system; <ExceptionHandling.",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:369779,resume,resume,369779,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['resume'],['resume']
Usability,"l boundaries as 1-element vectors (which is the same as if they were loaded with ``LDR``). Bitconverts; -----------. .. image:: ARM-BE-bitcastfail.png; :align: right. The main problem with the ``LD1`` solution is dealing with bitconverts (or bitcasts, or reinterpret casts). These are pseudo instructions that only change the compiler's interpretation of data, not the underlying data itself. A requirement is that if data is loaded and then saved again (called a ""round trip""), the memory contents should be the same after the store as before the load. If a vector is loaded and is then bitconverted to a different vector type before storing, the round trip will currently be broken. Take for example this code sequence::. %0 = load <4 x i32> %x; %1 = bitcast <4 x i32> %0 to <2 x i64>; store <2 x i64> %1, <2 x i64>* %y. This would produce a code sequence such as that in the figure on the right. The mismatched ``LD1`` and ``ST1`` cause the stored data to differ from the loaded data. .. container:: clearer. When we see a bitcast from type ``X`` to type ``Y``, what we need to do is to change the in-register representation of the data to be *as if* it had just been loaded by a ``LD1`` of type ``Y``. .. image:: ARM-BE-bitcastsuccess.png; :align: right. Conceptually this is simple - we can insert a ``REV`` undoing the ``LD1`` of type ``X`` (converting the in-register representation to the same as if it had been loaded by ``LDR``) and then insert another ``REV`` to change the representation to be as if it had been loaded by an ``LD1`` of type ``Y``. For the previous example, this would be::. LD1 v0.4s, [x]. REV64 v0.4s, v0.4s // There is no REV128 instruction, so it must be synthesizedcd; EXT v0.16b, v0.16b, v0.16b, #8 // with a REV64 then an EXT to swap the two 64-bit elements. REV64 v0.2d, v0.2d; EXT v0.16b, v0.16b, v0.16b, #8. ST1 v0.2d, [y]. It turns out that these ``REV`` pairs can, in almost all cases, be squashed together into a single ``REV``. For the example above, a ``REV1",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/BigEndianNEON.rst:10667,clear,clearer,10667,interpreter/llvm-project/llvm/docs/BigEndianNEON.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/BigEndianNEON.rst,1,['clear'],['clearer']
Usability,"l data classes as needed for; analysis were parsable by CINT and consequently, by using CINT for the; bindings, at the very least one could run any analysis in Python.; This was key. Besides not being able to parse some code (a problem that's history for cppyy; since moving to Cling), all automatic parsers suffer from the problem that; the bindings produced have a strong ""C++ look-and-feel"" and that choices need; to be made in cases that can be bound in different, equally valid, ways.; As an example of the latter, consider the return of an ``std::vector``:; should this be automatically converted to a Python ``list``?; Doing so is more ""pythonic"", but incurs a significant overhead, and no; automatic choice will satisfy all cases: user input is needed. The typical way to solve these issues, is to provide an intermediate language; where corner cases can be brushed up, code can be made more Python friendly,; and design choices can be resolved.; Unfortunately, learning an intermediate language is quite an investment in; time and effort.; With cppyy, however, no such extra language is needed: using Cling, C++ code; can be embedded and JIT-ed for the same purpose.; In particular, cppyy can handle `boxed` Python objects and the full Python; C-API is available through Cling, allowing complete manual control where; necessary, and all within a single code base.; Similarly, a more pythonistic look-and-feel can be achieved in Python itself.; As a rule, Python is always the best place, far more so than any intermediate; language, to do Python-thingies.; Since all bound proxies are normal Python classes, functions, etc., Python's; introspection (and regular expressions engine) can be used to provide rule; based improvements in a way similar to the use of directives in an; intermediate language. On a practical note, it's often said that an automatic binder can provide; bindings to 95% of your code out-of-the-box, with only the remaining part; needing manual intervention.; This is b",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/philosophy.rst:6423,learn,learning,6423,bindings/pyroot/cppyy/cppyy/doc/source/philosophy.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/philosophy.rst,1,['learn'],['learning']
Usability,"l data of an object, and that this reference will be; invalidated if the object is destroyed. When such a message is sent to an; object, the object's lifetime will be extended until at least the earliest of:. * the last use of the returned pointer, or any pointer derived from it, in the; calling function or; * the autorelease pool is restored to a previous state. .. admonition:: Rationale. Rationale: not all memory and resources are managed with reference counts; it; is common for objects to manage private resources in their own, private way.; Typically these resources are completely encapsulated within the object, but; some classes offer their users direct access for efficiency. If ARC is not; aware of methods that return such ""interior"" pointers, its optimizations can; cause the owning object to be reclaimed too soon. This attribute informs ARC; that it must tread lightly. The extension rules are somewhat intentionally vague. The autorelease pool; limit is there to permit a simple implementation to simply retain and; autorelease the receiver. The other limit permits some amount of; optimization. The phrase ""derived from"" is intended to encompass the results; both of pointer transformations, such as casts and arithmetic, and of loading; from such derived pointers; furthermore, it applies whether or not such; derivations are applied directly in the calling code or by other utility code; (for example, the C library routine ``strchr``). However, the implementation; never need account for uses after a return from the code which calls the; method returning an interior pointer. As an exception, no extension is required if the receiver is loaded directly; from a ``__strong`` object with :ref:`precise lifetime semantics; <arc.optimization.precise>`. .. admonition:: Rationale. Implicit autoreleases carry the risk of significantly inflating memory use,; so it's important to provide users a way of avoiding these autoreleases.; Tying this to precise lifetime semantics is ideal,",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst:100765,simpl,simple,100765,interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,2,['simpl'],"['simple', 'simply']"
Usability,"l have; just two functions:. 1. ``Error addModule(std::unique_ptr<Module> M)``: Make the given IR module; available for execution.; 2. ``Expected<ExecutorSymbolDef> lookup()``: Search for pointers to; symbols (functions or variables) that have been added to the JIT. A basic use-case for this API, executing the 'main' function from a module,; will look like:. .. code-block:: c++. JIT J;; J.addModule(buildModule());; auto *Main = J.lookup(""main"").getAddress().toPtr<int(*)(int, char *[])>();; int Result = Main();. The APIs that we build in these tutorials will all be variations on this simple; theme. Behind this API we will refine the implementation of the JIT to add; support for concurrent compilation, optimization and lazy compilation.; Eventually we will extend the API itself to allow higher-level program; representations (e.g. ASTs) to be added to the JIT. KaleidoscopeJIT; ===============. In the previous section we described our API, now we examine a simple; implementation of it: The KaleidoscopeJIT class [1]_ that was used in the; `Implementing a language with LLVM <LangImpl01.html>`_ tutorials. We will use; the REPL code from `Chapter 7 <LangImpl07.html>`_ of that tutorial to supply the; input for our JIT: Each time the user enters an expression the REPL will add a; new IR module containing the code for that expression to the JIT. If the; expression is a top-level expression like '1+1' or 'sin(x)', the REPL will also; use the lookup method of our JIT class find and execute the code for the; expression. In later chapters of this tutorial we will modify the REPL to enable; new interactions with our JIT class, but for now we will take this setup for; granted and focus our attention on the implementation of our JIT itself. Our KaleidoscopeJIT class is defined in the KaleidoscopeJIT.h header. After the; usual include guards and #includes [2]_, we get to the definition of our class:. .. code-block:: c++. #ifndef LLVM_EXECUTIONENGINE_ORC_KALEIDOSCOPEJIT_H; #define LLVM",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/BuildingAJIT1.rst:3797,simpl,simple,3797,interpreter/llvm-project/llvm/docs/tutorial/BuildingAJIT1.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/BuildingAJIT1.rst,1,['simpl'],['simple']
Usability,"l threads of the group may be available to; participate in this communication. This is the defining characteristic that; distinguishes convergent operations from other inter-thread communication:. A convergent operation involves inter-thread communication or synchronization; that occurs outside of the memory model, where the set of threads which; participate in communication is implicitly affected by control flow. For example, in the following GPU compute kernel, communication during the; convergent operation is expected to occur precisely among those threads of an; implementation-defined execution scope (such as workgroup or subgroup) for; which ``condition`` is true:. .. code-block:: c++. void example_kernel() {; ...; if (condition); convergent_operation();; ...; }. In structured programming languages, there is often an intuitive and; unambiguous way of determining the threads that are expected to communicate.; However, this is not always the case even in structured programming languages,; and the intuition breaks down entirely in unstructured control flow. This; document describes the formal semantics in LLVM, i.e. how to determine the set; of communicating threads for convergent operations. The definitions in this document leave many details open, such as how groups of; threads are formed in the first place. It focuses on the questions that are; relevant for deciding the correctness of generic program transforms and; convergence-related analyses such as :ref:`uniformity analysis; <convergence-and-uniformity>`. .. _convergent_operations:. Convergent Operations; =====================. In LLVM IR, the only way to communicate between threads as described; above is by calling target-defined convergent intrinsics. Hence, only; a call-site in LLVM IR (a :ref:`call <i_call>`, :ref:`invoke; <i_invoke>`, or :ref:`callbr <i_callbr>` instruction) can result in a; convergent operation. A function in LLVM IR is said to be *convergent* if it has the; :ref:`convergent <attr_con",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ConvergentOperations.rst:1607,intuit,intuition,1607,interpreter/llvm-project/llvm/docs/ConvergentOperations.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ConvergentOperations.rst,1,['intuit'],['intuition']
Usability,"l visible level put a; limitation on the maximum applied depth. Combined with visibility; settings per volume, these can tune quite well what should appear on the; screen. However, there are situations when users want to see a volume; branch displayed down to the maximum depth, keeping at the same time a; limitation or even suppressing others. In order to accomplish that, one; should use the volume attribute: `Visible daughters`. By default, all; daughters of all volumes are displayed if there is no limitation related; with their level depth with respect to the top drawn volume. ### Ray Tracing. Ray tracing is a quite known drawing technique based on tracking rays; from the eye position through all pixels of a view port device. The; pixel color is derived from the properties of the first crossed surface,; according some illumination model and material optical properties. While; there are currently existing quite sophisticated ray tracing models,; **`TGeo`** is currently using a very simple approach where the light; source is matching the eye position (no shadows or back-tracing of the; reflected ray). In future we are considering providing a base class in; order to be able to derive more complex models. Due to the fact that the number of rays that have to be tracked matches; the size in pixels of the pad, the time required by this algorithm is; proportional to the pad size. On the other hand, the speed is quite; acceptable for the default ROOT pad size and the images produced by; using this technique have high quality. Since the algorithm is; practically using all navigation features, producing ray-traced pictures; is also a geometry validation check. Ray tracing can be activated at; volume level as the normal `Draw()`. ![Ray-traced view in a pad](pictures/020001E4.jpg). ``` {.cpp}; myVolume->Raytrace(); ```. Once ray-tracing a view, this can be zoomed or rotated as a usual one.; Objects on the screen are no longer highlighted when picking the; vertices but the corre",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:143496,simpl,simple,143496,documentation/users-guide/Geometry.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md,1,['simpl'],['simple']
Usability,"l::ParseCommandLineOptions(argc, argv, ""This is a small program to demo the LLVM CommandLine API"");; ...; }. .. _cl::ParseCommandLineOptions:. The ``cl::ParseCommandLineOptions`` function; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. The ``cl::ParseCommandLineOptions`` function is designed to be called directly; from ``main``, and is used to fill in the values of all of the command line; option variables once ``argc`` and ``argv`` are available. The ``cl::ParseCommandLineOptions`` function requires two parameters (``argc``; and ``argv``), but may also take an optional third parameter which holds; `additional extra text`_ to emit when the ``-help`` option is invoked. The ``cl::SetVersionPrinter`` function; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. The ``cl::SetVersionPrinter`` function is designed to be called directly from; ``main`` and *before* ``cl::ParseCommandLineOptions``. Its use is optional. It; simply arranges for a function to be called in response to the ``--version``; option instead of having the ``CommandLine`` library print out the usual version; string for LLVM. This is useful for programs that are not part of LLVM but wish; to use the ``CommandLine`` facilities. Such programs should just define a small; function that takes no arguments and returns ``void`` and that prints out; whatever version information is appropriate for the program. Pass the address of; that function to ``cl::SetVersionPrinter`` to arrange for it to be called when; the ``--version`` option is given by the user. .. _cl::opt:; .. _scalar:. The ``cl::opt`` class; ^^^^^^^^^^^^^^^^^^^^^. The ``cl::opt`` class is the class used to represent scalar command line; options, and is the one used most of the time. It is a templated class which; can take up to three arguments (all except for the first have default values; though):. .. code-block:: c++. namespace cl {; template <class DataType, bool ExternalStorage = false,; class ParserClass = parser<DataType> >; class opt;; }. The first template",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandLine.rst:53719,simpl,simply,53719,interpreter/llvm-project/llvm/docs/CommandLine.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandLine.rst,1,['simpl'],['simply']
Usability,"l_array_with_indices(int *__counted_by(count) p, size_t count) {; // off-by-one error; for (size_t i = 0; i <= count; ++i); p[i] = i;; }. External bounds annotations include ``__counted_by``, ``__sized_by``, and; ``__ended_by``. These annotations do not change the pointer representation,; meaning they do not have ABI implications. * ``__counted_by(N)`` : The pointer points to memory that contains ``N``; elements of pointee type. ``N`` is an expression of integer type which can be; a simple reference to declaration, a constant including calls to constant; functions, or an arithmetic expression that does not have side effect. The; ``__counted_by`` annotation cannot apply to pointers to incomplete types or; types without size such as ``void *``. Instead, ``__sized_by`` can be used to; describe the byte count.; * ``__sized_by(N)`` : The pointer points to memory that contains ``N`` bytes.; Just like the argument of ``__counted_by``, ``N`` is an expression of integer; type which can be a constant, a simple reference to a declaration, or an; arithmetic expression that does not have side effects. This is mainly used for; pointers to incomplete types or types without size such as ``void *``.; * ``__ended_by(P)`` : The pointer has the upper bound of value ``P``, which is; one past the last element of the pointer. In other words, this annotation; describes a range that starts with the pointer that has this annotation and; ends with ``P`` which is the argument of the annotation. ``P`` itself may be; annotated with ``__ended_by(Q)``. In this case, the end of the range extends; to the pointer ``Q``. This is used for ""iterator"" support in C where you're; iterating from one pointer value to another until a final pointer value is; reached (and the final pointer value is not dereferencable). Accessing a pointer outside the specified bounds causes a run-time trap or a; compile-time error. Also, the model maintains correctness of bounds annotations; when the pointer and/or the related v",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafety.rst:10599,simpl,simple,10599,interpreter/llvm-project/clang/docs/BoundsSafety.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafety.rst,1,['simpl'],['simple']
Usability,"language's runtime; library. The compiler plugin is responsible for generating code which conforms; to the binary interface defined by library, most essentially the :ref:`stack map; <stack-map>`. To subclass ``llvm::GCStrategy`` and register it with the compiler:. .. code-block:: c++. // lib/MyGC/MyGC.cpp - Example LLVM GC plugin. #include ""llvm/CodeGen/GCStrategy.h""; #include ""llvm/CodeGen/GCMetadata.h""; #include ""llvm/Support/Compiler.h"". using namespace llvm;. namespace {; class LLVM_LIBRARY_VISIBILITY MyGC : public GCStrategy {; public:; MyGC() {}; };. GCRegistry::Add<MyGC>; X(""mygc"", ""My bespoke garbage collector."");; }. This boilerplate collector does nothing. More specifically:. * ``llvm.gcread`` calls are replaced with the corresponding ``load``; instruction. * ``llvm.gcwrite`` calls are replaced with the corresponding ``store``; instruction. * No safe points are added to the code. * The stack map is not compiled into the executable. Using the LLVM makefiles, this code; can be compiled as a plugin using a simple makefile:. .. code-block:: make. # lib/MyGC/Makefile. LEVEL := ../..; LIBRARYNAME = MyGC; LOADABLE_MODULE = 1. include $(LEVEL)/Makefile.common. Once the plugin is compiled, code using it may be compiled using ``llc; -load=MyGC.so`` (though MyGC.so may have some other platform-specific; extension):. ::. $ cat sample.ll; define void @f() gc ""mygc"" {; entry:; ret void; }; $ llvm-as < sample.ll | llc -load=MyGC.so. It is also possible to statically link the collector plugin into tools, such as; a language-specific compiler front-end. .. _collector-algos:. Overview of available features; ------------------------------. ``GCStrategy`` provides a range of features through which a plugin may do useful; work. Some of these are callbacks, some are algorithms that can be enabled,; disabled, or customized. This matrix summarizes the supported (and planned); features and correlates them with the collection techniques which typically; require them. .. |v| unicode:",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GarbageCollection.rst:25182,simpl,simple,25182,interpreter/llvm-project/llvm/docs/GarbageCollection.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GarbageCollection.rst,1,['simpl'],['simple']
Usability,"lar; shared variables. (`Java Specification; <http://docs.oracle.com/javase/specs/jls/se8/html/jls-17.html>`_). * gcc-compatible ``__sync_*`` builtins. (`Description; <https://gcc.gnu.org/onlinedocs/gcc/_005f_005fsync-Builtins.html>`_). * Other scenarios with atomic semantics, including ``static`` variables with; non-trivial constructors in C++. Atomic and volatile in the IR are orthogonal; ""volatile"" is the C/C++ volatile,; which ensures that every volatile load and store happens and is performed in the; stated order. A couple examples: if a SequentiallyConsistent store is; immediately followed by another SequentiallyConsistent store to the same; address, the first store can be erased. This transformation is not allowed for a; pair of volatile stores. On the other hand, a non-volatile non-atomic load can; be moved across a volatile load freely, but not an Acquire load. This document is intended to provide a guide to anyone either writing a frontend; for LLVM or working on optimization passes for LLVM with a guide for how to deal; with instructions with special semantics in the presence of concurrency. This; is not intended to be a precise guide to the semantics; the details can get; extremely complicated and unreadable, and are not usually necessary. .. _Optimization outside atomic:. Optimization outside atomic; ===========================. The basic ``'load'`` and ``'store'`` allow a variety of optimizations, but can; lead to undefined results in a concurrent environment; see `NotAtomic`_. This; section specifically goes into the one optimizer restriction which applies in; concurrent environments, which gets a bit more of an extended description; because any optimization dealing with stores needs to be aware of it. From the optimizer's point of view, the rule is that if there are not any; instructions with atomic ordering involved, concurrency does not matter, with; one exception: if a variable might be visible to another thread or signal; handler, a store cannot b",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Atomics.rst:2020,guid,guide,2020,interpreter/llvm-project/llvm/docs/Atomics.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Atomics.rst,2,['guid'],['guide']
Usability,"lassification cost-sensitive boosting}, Proceedings of the 16th International conference on machine learning (ICML 1999)}. With the currently; chosen DEFAULT settings (all costs equal and set to ""one""), it is equivalent to the ""real-AdaBoost"" (i.e. using the option !UseYesNoLeaf (which uses the leave node purity rather than a signal or background attribute in the leaf node of each individual tree). Unfortunatly, no reasonable performance has been achieved yet when choosing different cost parameters. c) BDT's with little tree depth (as favoured for good performance) do not *like* it if; there are very clean signal and background separation cuts available, which however ; have NOT been applied yet as preselection. Now there is a possibility to choose the option; ""DoPreselection"" that looks for suitable preselection cuts and applies them prior to ; the Decision Tree training. While that works fine, this clearly gives ""sharp"" peaks at +1 (-1); for the MVA output distribution and therefore the ""smoothing"" of this distribution used to; produce the ROC curve and efficiency estimates are somewhat thwarted.; ; --> It's better if you do these preselection cuts YOURSELF when defining training and test; sample!. d) Removed completely the (hopefully never used) option of treating negative events weights; via: PairNegWeightsInNode. e) Renamed option: IgnoreNegEvents --> IgnoreNegEventsInTraining; and removed the IDENTICAL option NoNegeventsInTraining. 6) SVM; All but the Gauss kernel options have been ""removed"" (guess that was done already some; time ago, probably with the introduction of ""regression"", but was not properly announced; so far. 5) minor bug fixes . a) fix calculation of mean values of the MVA distribution; for signal and background samples, which is used to; decide if a cut on the MVA variable selects signal or; background. Due to the bug it sometimes was swapped. b) equalize the interpolation of the PDF-class that is used to; smooth the Gauss-Transformation, betwee",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/tmva/UsersGuide/ReleaseNotes4.2.0.txt:2966,clear,clearly,2966,documentation/tmva/UsersGuide/ReleaseNotes4.2.0.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/tmva/UsersGuide/ReleaseNotes4.2.0.txt,1,['clear'],['clearly']
Usability,"late <class DataType, class Storage = bool,; class ParserClass = parser<DataType> >; class bits;; }. This class works the exact same as the `cl::list`_ class, except that the second; argument must be of **type** ``unsigned`` if external storage is used. .. _cl::alias:. The ``cl::alias`` class; ^^^^^^^^^^^^^^^^^^^^^^^. The ``cl::alias`` class is a nontemplated class that is used to form aliases for; other arguments. .. code-block:: c++. namespace cl {; class alias;; }. The `cl::aliasopt`_ attribute should be used to specify which option this is an; alias for. Alias arguments default to being `cl::Hidden`_, and use the aliased; options parser to do the conversion from string to data. .. _cl::extrahelp:. The ``cl::extrahelp`` class; ^^^^^^^^^^^^^^^^^^^^^^^^^^^. The ``cl::extrahelp`` class is a nontemplated class that allows extra help text; to be printed out for the ``-help`` option. .. code-block:: c++. namespace cl {; struct extrahelp;; }. To use the extrahelp, simply construct one with a ``const char*`` parameter to; the constructor. The text passed to the constructor will be printed at the; bottom of the help message, verbatim. Note that multiple ``cl::extrahelp``; **can** be used, but this practice is discouraged. If your tool needs to print; additional help information, put all that help into a single ``cl::extrahelp``; instance. For example:. .. code-block:: c++. cl::extrahelp(""\nADDITIONAL HELP:\n\n This is the extra help\n"");. .. _cl::OptionCategory:. The ``cl::OptionCategory`` class; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. The ``cl::OptionCategory`` class is a simple class for declaring; option categories. .. code-block:: c++. namespace cl {; class OptionCategory;; }. An option category must have a name and optionally a description which are; passed to the constructor as ``const char*``. Note that declaring an option category and associating it with an option before; parsing options (e.g. statically) will change the output of ``-help`` from; uncategorized to categor",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandLine.rst:57408,simpl,simply,57408,interpreter/llvm-project/llvm/docs/CommandLine.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandLine.rst,1,['simpl'],['simply']
Usability,"lation offers the; possibility to test the effects of different assumptions. A powerful software framework addressing all of the above requirements; is ROOT, an open source project coordinated by the European Organisation for; Nuclear Research, CERN in Geneva. ROOT is very flexible and provides both a programming interface to use in own; applications and a graphical user interface for interactive data analysis. The; purpose of this document is to serve as a beginners guide and provides extendable; examples for your own use cases, based on typical problems addressed in; student labs. This guide will hopefully lay the ground for more complex; applications in your future scientific work building on a modern,; state-of the art tool for data analysis. This guide in form of a tutorial is intended to introduce you quickly to the; ROOT package. This goal will be accomplished using concrete examples, according; to the ""learning by doing"" principle. Also because of this reason, this guide; cannot cover all the complexity of the ROOT package. Nevertheless, once you feel; confident with the concepts presented in the following chapters, you will be; able to appreciate the ROOT Users Guide [@ROOT_Users_Guide] and navigate through; the Class Reference [@ROOT_Class_Reference] to find all the details you might be; interested in. You can even look at the code itself, since ROOT is a; free, open-source product. Use these documents in parallel to this; tutorial!. The ROOT Data Analysis Framework itself is written in and heavily relies; on the `C++` programming language: some knowledge about `C++` is required.; Jus take advantage from the immense available literature about `C++` if you do; not have any idea of what this language is about. ROOT is available for many platforms (Linux, Mac OS X, Windows...), but; in this guide we will implicitly assume that you are using Linux. The; first thing you need to do with ROOT is install it, don't you ? Obtaining; the latest ROOT version is straig",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/Introduction.md:3877,guid,guide,3877,documentation/primer/Introduction.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/Introduction.md,1,['guid'],['guide']
Usability,"lck1, lck2;. void test() {; if (lck_mtx_try_lock(&lck1) == 0); return;. lck_mtx_lock(&lck2);; lck_mtx_unlock(&lck1);; // warn: this was not the most recently acquired lock; }. .. _alpha-unix-SimpleStream:. alpha.unix.SimpleStream (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""; Check for misuses of stream APIs. Check for misuses of stream APIs: ``fopen, fclose``; (demo checker, the subject of the demo (`Slides <https://llvm.org/devmtg/2012-11/Zaks-Rose-Checker24Hours.pdf>`_ ,; `Video <https://youtu.be/kdxlsP5QVPw>`_) by Anna Zaks and Jordan Rose presented at the; `2012 LLVM Developers' Meeting <https://llvm.org/devmtg/2012-11/>`_). .. code-block:: c. void test() {; FILE *F = fopen(""myfile.txt"", ""w"");; } // warn: opened file is never closed. void test() {; FILE *F = fopen(""myfile.txt"", ""w"");. if (F); fclose(F);. fclose(F); // warn: closing a previously closed file stream; }. .. _alpha-unix-Stream:. alpha.unix.Stream (C); """"""""""""""""""""""""""""""""""""""""""; Check stream handling functions: ``fopen, tmpfile, fclose, fread, fwrite, fseek, ftell, rewind, fgetpos,``; ``fsetpos, clearerr, feof, ferror, fileno``. .. code-block:: c. void test() {; FILE *p = fopen(""foo"", ""r"");; } // warn: opened file is never closed. void test() {; FILE *p = fopen(""foo"", ""r"");; fseek(p, 1, SEEK_SET); // warn: stream pointer might be NULL; fclose(p);; }. void test() {; FILE *p = fopen(""foo"", ""r"");. if (p); fseek(p, 1, 3);; // warn: third arg should be SEEK_SET, SEEK_END, or SEEK_CUR. fclose(p);; }. void test() {; FILE *p = fopen(""foo"", ""r"");; fclose(p);; fclose(p); // warn: already closed; }. void test() {; FILE *p = tmpfile();; ftell(p); // warn: stream pointer might be NULL; fclose(p);; }. .. _alpha-unix-cstring-BufferOverlap:. alpha.unix.cstring.BufferOverlap (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Checks for overlap in two buffer arguments. Applies to: ``memcpy, mempcpy, wmemcpy, wmempcpy``. .. code-block:: c. void test() {; int a[4] = {0};; memcpy(a + 2, a + 1, 8); // warn; }. .. _alpha-unix-cstring-NotNullTermina",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:77107,clear,clearerr,77107,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst,1,['clear'],['clearerr']
Usability,"ld contain an entry for each DWARF DIE whose; ``DW_TAG`` is a ``DW_TAG_label``, ``DW_TAG_inlined_subroutine``, or; ``DW_TAG_subprogram`` that has address attributes: ``DW_AT_low_pc``,; ``DW_AT_high_pc``, ``DW_AT_ranges`` or ``DW_AT_entry_pc``. It also contains; ``DW_TAG_variable`` DIEs that have a ``DW_OP_addr`` in the location (global and; static variables). All global and static variables should be included,; including those scoped within functions and classes. For example using the; following code:. .. code-block:: c. static int var = 0;. void f (); {; static int var = 0;; }. Both of the static ``var`` variables would be included in the table. All; functions should emit both their full names and their basenames. For C or C++,; the full name is the mangled name (if available) which is usually in the; ``DW_AT_MIPS_linkage_name`` attribute, and the ``DW_AT_name`` contains the; function basename. If global or static variables have a mangled name in a; ``DW_AT_MIPS_linkage_name`` attribute, this should be emitted along with the; simple name found in the ``DW_AT_name`` attribute. ""``.apple_types``"" sections should contain an entry for each DWARF DIE whose; tag is one of:. * DW_TAG_array_type; * DW_TAG_class_type; * DW_TAG_enumeration_type; * DW_TAG_pointer_type; * DW_TAG_reference_type; * DW_TAG_string_type; * DW_TAG_structure_type; * DW_TAG_subroutine_type; * DW_TAG_typedef; * DW_TAG_union_type; * DW_TAG_ptr_to_member_type; * DW_TAG_set_type; * DW_TAG_subrange_type; * DW_TAG_base_type; * DW_TAG_const_type; * DW_TAG_immutable_type; * DW_TAG_file_type; * DW_TAG_namelist; * DW_TAG_packed_type; * DW_TAG_volatile_type; * DW_TAG_restrict_type; * DW_TAG_atomic_type; * DW_TAG_interface_type; * DW_TAG_unspecified_type; * DW_TAG_shared_type. Only entries with a ``DW_AT_name`` attribute are included, and the entry must; not be a forward declaration (``DW_AT_declaration`` attribute with a non-zero; value). For example, using the following code:. .. code-block:: c. int main (); {; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst:78400,simpl,simple,78400,interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,1,['simpl'],['simple']
Usability,"ld; like JIT'd code to be able to ""dlopen"" and ""dlclose"" JITDylibs, running all of; their initializers/deinitializers on the current thread. This would require; support from the runtime library described above. 3. **Debugging support**. ORC currently supports the GDBRegistrationListener API when using RuntimeDyld; as the underlying JIT linker. We will need a new solution for JITLink based; platforms. Further Future Work; -------------------. 1. **Speculative Compilation**. ORC's support for concurrent compilation allows us to easily enable; *speculative* JIT compilation: compilation of code that is not needed yet,; but which we have reason to believe will be needed in the future. This can be; used to hide compile latency and improve JIT throughput. A proof-of-concept; example of speculative compilation with ORC has already been developed (see; ``llvm/examples/SpeculativeJIT``). Future work on this is likely to focus on; re-using and improving existing profiling support (currently used by PGO) to; feed speculation decisions, as well as built-in tools to simplify use of; speculative compilation. .. [1] Formats/architectures vary in terms of supported features. MachO and; ELF tend to have better support than COFF. Patches very welcome!. .. [2] The ``LazyEmittingLayer``, ``RemoteObjectClientLayer`` and; ``RemoteObjectServerLayer`` do not have counterparts in the new; system. In the case of ``LazyEmittingLayer`` it was simply no longer; needed: in ORCv2, deferring compilation until symbols are looked up is; the default. The removal of ``RemoteObjectClientLayer`` and; ``RemoteObjectServerLayer`` means that JIT stacks can no longer be split; across processes, however this functionality appears not to have been; used. .. [3] Weak definitions are currently handled correctly within dylibs, but if; multiple dylibs provide a weak definition of a symbol then each will end; up with its own definition (similar to how weak definitions are handled; in Windows DLLs). This will be fix",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ORCv2.rst:37616,simpl,simplify,37616,interpreter/llvm-project/llvm/docs/ORCv2.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ORCv2.rst,1,['simpl'],['simplify']
Usability,"le extends from the; ``defvar`` statement to the end of the body. It cannot be set to a different; value within its scope. The ``defvar`` statement can also be used in the statement; list of a ``foreach``, which establishes a scope. A variable named ``V`` in an inner scope shadows (hides) any variables ``V``; in outer scopes. In particular, there are several cases:. * ``V`` in a record body shadows a global ``V``. * ``V`` in a record body shadows template argument ``V``. * ``V`` in template arguments shadows a global ``V``. * ``V`` in a ``foreach`` statement list shadows any ``V`` in surrounding record or; global scopes. Variables defined in a ``foreach`` go out of scope at the end of; each loop iteration, so their value in one iteration is not available in; the next iteration. The following ``defvar`` will not work::. defvar i = !add(i, 1). How records are built; ---------------------. The following steps are taken by TableGen when a record is built. Classes are simply; abstract records and so go through the same steps. 1. Build the record name (:token:`NameValue`) and create an empty record. 2. Parse the parent classes in the :token:`ParentClassList` from left to; right, visiting each parent class's ancestor classes from top to bottom. a. Add the fields from the parent class to the record.; b. Substitute the template arguments into those fields.; c. Add the parent class to the record's list of inherited classes. 3. Apply any top-level ``let`` bindings to the record. Recall that top-level; bindings only apply to inherited fields. 4. Parse the body of the record. * Add any fields to the record.; * Modify the values of fields according to local ``let`` statements.; * Define any ``defvar`` variables. 5. Make a pass over all the fields to resolve any inter-field references. 6. Add the record to the final record list. Because references between fields are resolved (step 5) after ``let`` bindings are; applied (step 3), the ``let`` statement has unusual power. For example:",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TableGen/ProgRef.rst:53350,simpl,simply,53350,interpreter/llvm-project/llvm/docs/TableGen/ProgRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TableGen/ProgRef.rst,1,['simpl'],['simply']
Usability,"le of; minor places where it is more picky, particularly due to outright GAS bugs.; One specific example is that the assembler rejects ambiguous X86 instructions; that don't have suffixes. For example:. asm(""add %al, (%rax)"");; asm(""addw $4, (%rax)"");; asm(""add $4, (%rax)"");. Both clang and GAS accept the first instruction: because the first; instruction uses the 8-bit %al register as an operand, it is clear that; it is an 8-bit add. The second instruction is accepted by both because the ""w""; suffix indicates that it is a 16-bit add. The last instruction is accepted by; GAS even though there is nothing that specifies the size of the instruction (and; the assembler randomly picks a 32-bit add). Because it is ambiguous, Clang; rejects the instruction with this error message:. <inline asm>:3:1: error: ambiguous instructions require an explicit suffix (could be 'addb', 'addw', 'addl', or 'addq'); add $4, (%rax); ^. To fix this compatibility issue, add an explicit suffix to the instruction:; this makes your code more clear and is compatible with both GCC and Clang. Objective-C compatibility. Cast of super. GCC treats the super identifier as an expression that; can, among other things, be cast to a different type. Clang treats; super as a context-sensitive keyword, and will reject a; type-cast of super:. super.m:11:12: error: cannot cast 'super' (it isn't an expression); [(Super*)super add:4];; ~~~~~~~~^. To fix this problem, remove the type cast, e.g. [super add:4];. Size of interfaces. When using the ""non-fragile"" Objective-C ABI in use, the size of an; Objective-C class may change over time as instance variables are added; (or removed). For this reason, Clang rejects the application of the; sizeof operator to an Objective-C class when using this; ABI:. sizeof.m:4:14: error: invalid application of 'sizeof' to interface 'NSArray' in non-fragile ABI; int size = sizeof(NSArray);; ^ ~~~~~~~~~. Code that relies on the size of an Objective-C class is likely to; be broken anyw",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html:8768,clear,clear,8768,interpreter/llvm-project/clang/www/compatibility.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html,1,['clear'],['clear']
Usability,"le to create our wire with a single line:. ``` {.cpp}; TGeoVolume *wire_co = gGeoManager->MakeTube(""WIRE_CO"",ptrCOPPER,; 0,0.01,1); //(*); ```. **(\*)** The same applies for all primitive shapes, for which there can; be found corresponding `MakeSHAPE()` methods. Their usage is much more; convenient unless a shape has to be shared between more volumes. Let us make now an aluminum wire having the same shape, supposing that; we have created the copper wire with the line above:. ``` {.cpp}; TGeoVolume *wire_al = new TGeoVolume(""WIRE_AL"",wire_co>GetShape(),; ptrAL);; ```. We would like now to position our wire in the middle of a gas chamber.; We need first to define the gas chamber:. ``` {.cpp}; TGeoVolume *chamber = gGeoManager->MakeTube(""CHAMBER"",ptrGAS,; 0,1,1);; ```. Now we can put the wire inside:. ``` {.cpp}; chamber->AddNode(wire_co,1);; ```. If we inspect now the chamber volume in a browser, we will notice that; it has one daughter. Of course, the gas has some container also, but let; us keeps it like that for the sake of simplicity. Since we did not; supply the third argument, the wire will be positioned with an identity; transformation inside the chamber. #### Overlapping Volumes. Positioning volumes that does not overlap their neighbors nor extrude; their container is sometimes quite strong constraint. Having a limited; set of geometric shapes might force sometimes overlaps. Since; overlapping is contradictory to containment, a point belonging to an; overlapping region will naturally belong to all overlapping partners.; The answer provided by the modeller to ""Where am I?"" is no longer; deterministic if there is no priority assigned. There are two ways out provided by the modeller in such cases and we; will illustrate them by examples. - Suppose we have 2 crossing tubes that we have to describe. Such a; structure cannot be decomposed in a containment schema. This is a; typical example of simple structure that can be handled by using; composite shapes. What we ha",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:74919,simpl,simplicity,74919,documentation/users-guide/Geometry.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md,1,['simpl'],['simplicity']
Usability,"le, and each pair in the map is store in a single allocation (the string data; is stored in the same allocation as the Value of a pair). StringMap also provides query methods that take byte ranges, so it only ever; copies a string if a value is inserted into the table. StringMap iteration order, however, is not guaranteed to be deterministic, so; any uses which require that should instead use a std::map. .. _dss_indexmap:. llvm/ADT/IndexedMap.h; ^^^^^^^^^^^^^^^^^^^^^. IndexedMap is a specialized container for mapping small dense integers (or; values that can be mapped to small dense integers) to some other type. It is; internally implemented as a vector with a mapping function that maps the keys; to the dense integer range. This is useful for cases like virtual registers in the LLVM code generator: they; have a dense mapping that is offset by a compile-time constant (the first; virtual register ID). .. _dss_densemap:. llvm/ADT/DenseMap.h; ^^^^^^^^^^^^^^^^^^^. DenseMap is a simple quadratically probed hash table. It excels at supporting; small keys and values: it uses a single allocation to hold all of the pairs; that are currently inserted in the map. DenseMap is a great way to map; pointers to pointers, or map other small types to each other. There are several aspects of DenseMap that you should be aware of, however.; The iterators in a DenseMap are invalidated whenever an insertion occurs,; unlike map. Also, because DenseMap allocates space for a large number of; key/value pairs (it starts with 64 by default), it will waste a lot of space if; your keys or values are large. Finally, you must implement a partial; specialization of DenseMapInfo for the key that you want, if it isn't already; supported. This is required to tell DenseMap about two special marker values; (which can never be inserted into the map) that it needs internally. DenseMap's find_as() method supports lookup operations using an alternate key; type. This is useful in cases where the normal key typ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:90681,simpl,simple,90681,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,1,['simpl'],['simple']
Usability,"le. But it may produce surprising results if the; debugging code depends on consistent use of ``NDEBUG`` also in other translation units. Definitions consistency; ^^^^^^^^^^^^^^^^^^^^^^^. The C++ language defines that same declarations in different translation units should have; the same definition, as known as ODR (One Definition Rule). Prior to modules, the translation; units don't dependent on each other and the compiler itself can't perform a strong; ODR violation check. With the introduction of modules, now the compiler have; the chance to perform ODR violations with language semantics across translation units. However, in the practice, we found the existing ODR checking mechanism is not stable; enough. Many people suffers from the false positive ODR violation diagnostics, AKA,; the compiler are complaining two identical declarations have different definitions; incorrectly. Also the true positive ODR violations are rarely reported.; Also we learned that MSVC don't perform ODR check for declarations in the global module; fragment. So in order to get better user experience, save the time checking ODR and keep consistent; behavior with MSVC, we disabled the ODR check for the declarations in the global module; fragment by default. Users who want more strict check can still use the; ``-Xclang -fno-skip-odr-check-in-gmf`` flag to get the ODR check enabled. It is also; encouraged to report issues if users find false positive ODR violations or false negative ODR; violations with the flag enabled. ABI Impacts; -----------. The declarations in a module unit which are not in the global module fragment have new linkage names. For example,. .. code-block:: c++. export module M;; namespace NS {; export int foo();; }. The linkage name of ``NS::foo()`` would be ``_ZN2NSW1M3fooEv``.; This couldn't be demangled by previous versions of the debugger or demangler.; As of LLVM 15.x, users can utilize ``llvm-cxxfilt`` to demangle this:. .. code-block:: console. $ llvm-cxxfilt _ZN2NSW",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst:17749,learn,learned,17749,interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst,1,['learn'],['learned']
Usability,"le;; auto await_ready() { return false; }; auto await_suspend(std::coroutine_handle<> continuation) {; handle.promise().continuation = continuation;; return handle;; }; int await_resume() {; int ret = handle.promise().result;; handle.destroy();; return ret;; }; };; return Awaiter{std::exchange(handle, nullptr)};; }. int syncStart() {; handle.resume();; return handle.promise().result;; }. private:; std::coroutine_handle<promise_type> handle;; };. task task::promise_type::get_return_object() {; return std::coroutine_handle<promise_type>::from_promise(*this);; }. namespace detail {; template <int N>; task chain_fn() {; co_return N + co_await chain_fn<N - 1>();; }. template <>; task chain_fn<0>() {; // This is the default breakpoint.; __builtin_debugtrap();; co_return 0;; }; } // namespace detail. task chain() {; co_return co_await detail::chain_fn<30>();; }. int main() {; std::cout << chain().syncStart() << ""\n"";; return 0;; }. In the example, the ``task`` coroutine holds a ``continuation`` field,; which would be resumed once the ``task`` completes.; In another word, the ``continuation`` is the asynchronous caller for the ``task``.; Just like the normal function returns to its caller when the function completes. So we can use the ``continuation`` field to construct the asynchronous stack:. .. code-block:: python. # debugging-helper.py; import gdb; from gdb.FrameDecorator import FrameDecorator. class SymValueWrapper():; def __init__(self, symbol, value):; self.sym = symbol; self.val = value. def __str__(self):; return str(self.sym) + "" = "" + str(self.val). def get_long_pointer_size():; return gdb.lookup_type('long').pointer().sizeof. def cast_addr2long_pointer(addr):; return gdb.Value(addr).cast(gdb.lookup_type('long').pointer()). def dereference(addr):; return long(cast_addr2long_pointer(addr).dereference()). class CoroutineFrame(object):; def __init__(self, task_addr):; self.frame_addr = task_addr; self.resume_addr = task_addr; self.destroy_addr = task_addr + get_long",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DebuggingCoroutines.rst:14614,resume,resumed,14614,interpreter/llvm-project/clang/docs/DebuggingCoroutines.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DebuggingCoroutines.rst,1,['resume'],['resumed']
Usability,"le`, `Event.cxx`, and `Event.h` for an example, or follow this; link: <http://root.cern.ch/root/RootCintMan.html>. ## genreflex: A Comfortable Interface to rootcling. Version 5 supported both `Cint` and `Reflex` dictionaries. The tool to create; `Reflex` dictionaries was a Python script called `genreflex` and was very; successful in the user community.; Even if version 6 has only one type of dictionaries, `cling` dictionaries,; a re-implementation of `genreflex` is provided.; More precisely, in ROOT6, `genreflex` is nothing but a wrapper around; `rootcling`, which offers an identical CLI and behaviour to the old Python; tool.; The input to `genreflex` is a C++ header file, a set of switches and a; *selection XML file*. The output, as for `rootcling`, is a C++ dictionary; source and a `pcm` files.; An exhaustive documentation of the CLI switches of `genreflex` can be; inspected with the `genreflex --help` command. The entity corresponding to the `LinkDef` file for `genreflex` is the; *selection XML file*, also called *selection XML* or simply *selection file*.; A *selection XML file* allows to describe a list of classes for which; the dictionaries are to be created. In addition, it allows to specify; properties of classes or data members, without the need to add comments in; the source code. This is of primary importance when dictionaries must be; created for classes residing in code which cannot be modified.; For a complete description of the structure of the *selection XML files*; and the way in which attributes can be set, refer to the `genreflex --help`; command. It is important to observe that *selection XML files* can be used in presence; of `rootcling` invocations instead of `LinkDef` files. ### The `ROOT::Meta::Selection` namespace. Not only `LinkDef` and `selection` files allow to select the classes for which; the dictionaries must be created: a third method is available. This is; represented by the `ROOT::Meta::Selection` namespace. The idea behind this; tec",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/AddingaClass.md:34566,simpl,simply,34566,documentation/users-guide/AddingaClass.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/AddingaClass.md,1,['simpl'],['simply']
Usability,"ledVGPRs"" integer Number of stores from; a vector register to; a register allocator; created spill; location.; ============================ ============== ========= =====================. .. _amdgpu-amdhsa-code-object-metadata-v3:. Code Object V3 Metadata; +++++++++++++++++++++++. .. warning::; Code object V3 generation is no longer supported by this version of LLVM. Code object V3 and above metadata is specified by the ``NT_AMDGPU_METADATA`` note; record (see :ref:`amdgpu-note-records-v3-onwards`). The metadata is represented as Message Pack formatted binary data (see; [MsgPack]_). The top level is a Message Pack map that includes the; keys defined in table; :ref:`amdgpu-amdhsa-code-object-metadata-map-table-v3` and referenced; tables. Additional information can be added to the maps. To avoid conflicts,; any key names should be prefixed by ""*vendor-name*."" where; ``vendor-name`` can be the name of the vendor and specific vendor; tool that generates the information. The prefix is abbreviated to; simply ""."" when it appears within a map that has been added by the; same *vendor-name*. .. table:: AMDHSA Code Object V3 Metadata Map; :name: amdgpu-amdhsa-code-object-metadata-map-table-v3. ================= ============== ========= =======================================; String Key Value Type Required? Description; ================= ============== ========= =======================================; ""amdhsa.version"" sequence of Required - The first integer is the major; 2 integers version. Currently 1.; - The second integer is the minor; version. Currently 0.; ""amdhsa.printf"" sequence of Each string is encoded information; strings about a printf function call. The; encoded information is organized as; fields separated by colon (':'):. ``ID:N:S[0]:S[1]:...:S[N-1]:FormatString``. where:. ``ID``; A 32-bit integer as a unique id for; each printf function call. ``N``; A 32-bit integer equal to the number; of arguments of printf function call; minus 1. ``S[i]`` (where i = 0, 1, .",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst:130264,simpl,simply,130264,interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,1,['simpl'],['simply']
Usability,"ler itself.; Fortunately, our current setup makes it very easy to add global; variables: just have value lookup check to see if an unresolved; variable is in the global variable symbol table before rejecting it.; To create a new global variable, make an instance of the LLVM; ``GlobalVariable`` class.; - **typed variables** - Kaleidoscope currently only supports variables; of type double. This gives the language a very nice elegance, because; only supporting one type means that you never have to specify types.; Different languages have different ways of handling this. The easiest; way is to require the user to specify types for every variable; definition, and record the type of the variable in the symbol table; along with its Value\*.; - **arrays, structs, vectors, etc** - Once you add types, you can start; extending the type system in all sorts of interesting ways. Simple; arrays are very easy and are quite useful for many different; applications. Adding them is mostly an exercise in learning how the; LLVM `getelementptr <../../LangRef.html#getelementptr-instruction>`_ instruction; works: it is so nifty/unconventional, it `has its own; FAQ <../../GetElementPtr.html>`_!; - **standard runtime** - Our current language allows the user to access; arbitrary external functions, and we use it for things like ""printd""; and ""putchard"". As you extend the language to add higher-level; constructs, often these constructs make the most sense if they are; lowered to calls into a language-supplied runtime. For example, if; you add hash tables to the language, it would probably make sense to; add the routines to a runtime, instead of inlining them all the way.; - **memory management** - Currently we can only access the stack in; Kaleidoscope. It would also be useful to be able to allocate heap; memory, either with calls to the standard libc malloc/free interface; or with a garbage collector. If you would like to use garbage; collection, note that LLVM fully supports `Accurate Garbage",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl10.rst:2542,learn,learning,2542,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl10.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl10.rst,1,['learn'],['learning']
Usability,"ler. Disable scheduling after register allocation. .. option:: -disable-spill-fusing. Disable fusing of spill code into instructions. .. option:: -jit-enable-eh. Exception handling should be enabled in the just-in-time compiler. .. option:: -join-liveintervals. Coalesce copies (default=true). .. option:: -nozero-initialized-in-bss. Don't place zero-initialized symbols into the BSS section. .. option:: -pre-RA-sched=scheduler. Instruction schedulers available (before register allocation):. .. code-block:: text. =default: Best scheduler for the target; =none: No scheduling: breadth first sequencing; =simple: Simple two pass scheduling: minimize critical path and maximize processor utilization; =simple-noitin: Simple two pass scheduling: Same as simple except using generic latency; =list-burr: Bottom-up register reduction list scheduling; =list-tdrr: Top-down register reduction list scheduling; =list-td: Top-down list scheduler. .. option:: -regalloc=allocator. Register allocator to use (default=linearscan). .. code-block:: text. =bigblock: Big-block register allocator; =linearscan: linear scan register allocator; =local: local register allocator; =simple: simple register allocator. .. option:: -relocation-model=model. Choose relocation model from:. .. code-block:: text. =default: Target default relocation model; =static: Non-relocatable code; =pic: Fully relocatable, position independent code; =dynamic-no-pic: Relocatable external references, non-relocatable code. .. option:: -spiller. Spiller to use (default=local). .. code-block:: text. =simple: simple spiller; =local: local spiller. .. option:: -x86-asm-syntax=syntax. Choose style of code to emit from X86 backend:. .. code-block:: text. =att: Emit AT&T-style assembly; =intel: Emit Intel-style assembly. EXIT STATUS; -----------. If :program:`lli` fails to load the program, it will exit with an exit code of 1.; Otherwise, it will return the exit code of the program it executes. SEE ALSO; --------. :manpage:`llc(1)`; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/lli.rst:5001,simpl,simple,5001,interpreter/llvm-project/llvm/docs/CommandGuide/lli.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/lli.rst,4,['simpl'],['simple']
Usability,"lick on any button to execute another example. To see the; source, open the corresponding source file (for example `fit1.C`). Once; you are done, and want to quit the ROOT session, you can do so by typing; **`.q`**. ``` {.cpp}; root[] .x demos.C; root[] .q; ```. ## \$ROOTSYS/test. The test directory contains a set of examples that represent all areas; of the framework. When a new release is cut, the examples in this; directory are compiled and run to test the new release's backward; compatibility. We see these source files:. +-------------------+--------------------------------------------------------+; | `Makefile` | Makefile to build all test programs. |; +-------------------+--------------------------------------------------------+; | `hsimple.cxx` | Simple test program that creates and saves some |; | | histograms |; +-------------------+--------------------------------------------------------+; | `MainEvent.cxx` | Simple test program that creates a ROOT Tree object |; | | and fills it with some simple structures but also with |; | | complete histograms. This program uses the files |; | | `Event.cxx`, `EventCint.cxx` and `Event.h`. An example |; | | of a procedure to link this program is in |; | | `bind_Event`. Note that the `Makefile` invokes the |; | | `rootcling` utility to generate the Cling interface |; | | `EventCint.cxx` |; +-------------------+--------------------------------------------------------+; | `Event.cxx` | Implementation for classes Event and Track |; +-------------------+--------------------------------------------------------+; | `minexam.cxx` | Simple test program for data fitting |; +-------------------+--------------------------------------------------------+; | `tcollex.cxx` | Example usage of the ROOT collection classes |; +-------------------+--------------------------------------------------------+; | `tcollbm.cxx` | Benchmarks of ROOT collection classes |; +-------------------+--------------------------------------------------------+",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/TutorialsandTests.md:2234,simpl,simple,2234,documentation/users-guide/TutorialsandTests.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/TutorialsandTests.md,1,['simpl'],['simple']
Usability,"lidity of the pointer value. In particular if the; pointer points, directly or indirectly, back to the current object, this; will result in an infinite recursion and the abrupt end of the process. ``` {.cpp}; TClonesArray *fTracks; //->; TH1F *fH; //->; ```. ### Variable Length Array. When the `Streamer `comes across a pointer to a simple type, it assumes; it is an array. Somehow, it has to know how many elements are in the; array to reserve enough space in the buffer and write out the; appropriate number of elements. This is done in the class definition.; For example:. ``` {.cpp}; class Event : public TObject {; private:; char fType[20];; Int_t fNtrack;; Int_t fNseg;; Int_t fNvertex;; ...; Float_t *fClosestDistance; //[fNvertex]; ```. The array `fClosestDistance` is defined as a pointer of floating point; numbers. A comment mark (//), and the number in square brackets tell the; `Streamer `the length of the array for this object. In general the; syntax is:. ``` {.cpp}; <simple type> *<name>//[<length>]; ```. The length cannot be an expression. If a variable is used, it needs to; be an integer data member of the class. It must be defined ahead of its; use, or in a base class. The same notation also applies to variable length array of object and; variable length array of pointer to objects. ``` {.cpp}; MyObject *obj; //[fNojbs]; MyObject **objs; //[fDatas]; ```. ### Double32\_t. Math operations very often require double precision, but on saving; single usually precision is sufficient. For this purpose we support the; typedef Double32\_t which is stored in memory as a double and on disk as; a float or integer. The actual size of disk (before compression) is; determined by the parameter next to the data member declaration. For; example:. ``` {.cpp}; Double32_t m_data; //[min,max<,nbits>]; ```. If the comment is absent or does not contain `min`, `max`,; `nbits`, the member is saved as a `float`. If `min` and `max` are present, they are saved with 32 bits precision.; `min`",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md:47394,simpl,simple,47394,documentation/users-guide/InputOutput.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md,1,['simpl'],['simple']
Usability,"lify>`. Loop pre-header insertion guarantees that there is a single, non-critical entry; edge from outside of the loop to the loop header. This simplifies a number of; analyses and transformations, such as :ref:`LICM <passes-licm>`. Loop exit-block insertion guarantees that all exit blocks from the loop (blocks; which are outside of the loop that have predecessors inside of the loop) only; have predecessors from inside of the loop (and are thus dominated by the loop; header). This simplifies transformations such as store-sinking that are built; into LICM. This pass also guarantees that loops will have exactly one backedge. Note that the :ref:`simplifycfg <passes-simplifycfg>` pass will clean up blocks; which are split out but end up being unnecessary, so usage of this pass should; not pessimize generated code. This pass obviously modifies the CFG, but updates loop information and; dominator information. ``loop-unroll``: Unroll loops; -----------------------------. This pass implements a simple loop unroller. It works best when loops have; been canonicalized by the :ref:`indvars <passes-indvars>` pass, allowing it to; determine the trip counts of loops easily. ``loop-unroll-and-jam``: Unroll and Jam loops; ---------------------------------------------. This pass implements a simple unroll and jam classical loop optimisation pass.; It transforms loop from:. .. code-block:: c++. for i.. i+= 1 for i.. i+= 4; for j.. for j..; code(i, j) code(i, j); code(i+1, j); code(i+2, j); code(i+3, j); remainder loop. Which can be seen as unrolling the outer loop and ""jamming"" (fusing) the inner; loops into one. When variables or loads can be shared in the new inner loop, this; can lead to significant performance improvements. It uses; :ref:`Dependence Analysis <passes-da>` for proving the transformations are safe. ``lower-global-dtors``: Lower global destructors; ------------------------------------------------. This pass lowers global module destructors (``llvm.global_dtors``) by cr",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Passes.rst:27972,simpl,simple,27972,interpreter/llvm-project/llvm/docs/Passes.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Passes.rst,1,['simpl'],['simple']
Usability,"lit - LLVM Integrated Tester; ============================. .. program:: lit. SYNOPSIS; --------. :program:`lit` [*options*] [*tests*]. DESCRIPTION; -----------. :program:`lit` is a portable tool for executing LLVM and Clang style test; suites, summarizing their results, and providing indication of failures.; :program:`lit` is designed to be a lightweight testing tool with as simple a; user interface as possible. :program:`lit` should be run with one or more *tests* to run specified on the; command line. Tests can be either individual test files or directories to; search for tests (see :ref:`test-discovery`). Each specified test will be executed (potentially concurrently) and once all; tests have been run :program:`lit` will print summary information on the number; of tests which passed or failed (see :ref:`test-status-results`). The; :program:`lit` program will execute with a non-zero exit code if any tests; fail. By default :program:`lit` will use a succinct progress display and will only; print summary information for test failures. See :ref:`output-options` for; options controlling the :program:`lit` progress display and output. :program:`lit` also includes a number of options for controlling how tests are; executed (specific features may depend on the particular test format). See; :ref:`execution-options` for more information. Finally, :program:`lit` also supports additional options for only running a; subset of the options specified on the command line, see; :ref:`selection-options` for more information. :program:`lit` parses options from the environment variable ``LIT_OPTS`` after; parsing options from the command line. ``LIT_OPTS`` is primarily useful for; supplementing or overriding the command-line options supplied to :program:`lit`; by ``check`` targets defined by a project's build system. :program:`lit` can also read options from response files which are specified as; inputs using the ``@path/to/file.rsp`` syntax. Arguments read from a file must; be one p",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/lit.rst:379,simpl,simple,379,interpreter/llvm-project/llvm/docs/CommandGuide/lit.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/lit.rst,1,['simpl'],['simple']
Usability,"lities -; check this out:. ::. ready> extern sin(x);; Read extern:; declare double @sin(double). ready> extern cos(x);; Read extern:; declare double @cos(double). ready> sin(1.0);; Read top-level expression:; define double @2() {; entry:; ret double 0x3FEAED548F090CEE; }. Evaluated to 0.841471. ready> def foo(x) sin(x)*sin(x) + cos(x)*cos(x);; Read function definition:; define double @foo(double %x) {; entry:; %calltmp = call double @sin(double %x); %multmp = fmul double %calltmp, %calltmp; %calltmp2 = call double @cos(double %x); %multmp4 = fmul double %calltmp2, %calltmp2; %addtmp = fadd double %multmp, %multmp4; ret double %addtmp; }. ready> foo(4.0);; Read top-level expression:; define double @3() {; entry:; %calltmp = call double @foo(double 4.000000e+00); ret double %calltmp; }. Evaluated to 1.000000. Whoa, how does the JIT know about sin and cos? The answer is surprisingly; simple: The KaleidoscopeJIT has a straightforward symbol resolution rule that; it uses to find symbols that aren't available in any given module: First; it searches all the modules that have already been added to the JIT, from the; most recent to the oldest, to find the newest definition. If no definition is; found inside the JIT, it falls back to calling ""``dlsym(""sin"")``"" on the; Kaleidoscope process itself. Since ""``sin``"" is defined within the JIT's; address space, it simply patches up calls in the module to call the libm; version of ``sin`` directly. But in some cases this even goes further:; as sin and cos are names of standard math functions, the constant folder; will directly evaluate the function calls to the correct result when called; with constants like in the ""``sin(1.0)``"" above. In the future we'll see how tweaking this symbol resolution rule can be used to; enable all sorts of useful features, from security (restricting the set of; symbols available to JIT'd code), to dynamic code generation based on symbol; names, and even lazy compilation. One immediate benefit of the symb",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl04.rst:22642,simpl,simple,22642,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl04.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl04.rst,1,['simpl'],['simple']
Usability,"lity guarantees for the raw; profile format. Raw profiles may be dependent on the specific compiler; revision used to generate them. It's inadvisable to store raw profiles for; long periods of time. * Tools must retain **backwards** compatibility with indexed profile formats.; These formats are not forwards-compatible: i.e, a tool which uses format; version X will not be able to understand format version (X+k). * Tools must also retain **backwards** compatibility with the format of the; coverage mappings emitted into instrumented binaries. These formats are not; forwards-compatible. * The JSON coverage export format has a (major, minor, patch) version triple.; Only a major version increment indicates a backwards-incompatible change. A; minor version increment is for added functionality, and patch version; increments are for bugfixes. Impact of llvm optimizations on coverage reports; ================================================. llvm optimizations (such as inlining or CFG simplification) should have no; impact on coverage report quality. This is due to the fact that the mapping; from source regions to profile counters is immutable, and is generated before; the llvm optimizer kicks in. The optimizer can't prove that profile counter; instrumentation is safe to delete (because it's not: it affects the profile the; program emits), and so leaves it alone. Note that this coverage feature does not rely on information that can degrade; during the course of optimization, such as debug info line tables. Using the profiling runtime without static initializers; =======================================================. By default the compiler runtime uses a static initializer to determine the; profile output path and to register a writer function. To collect profiles; without using static initializers, do this manually:. * Export a ``int __llvm_profile_runtime`` symbol from each instrumented shared; library and executable. When the linker finds a definition of this symbol, it; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SourceBasedCodeCoverage.rst:14756,simpl,simplification,14756,interpreter/llvm-project/clang/docs/SourceBasedCodeCoverage.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SourceBasedCodeCoverage.rst,1,['simpl'],['simplification']
Usability,"lity. - The following code should produce a plot. It did not. ``` {.cpp}; TH1F* h=new TH1F(""hist"", ""histogram"", 10, 0, 3);; h->FillRandom(""gaus"");; h->Draw(""same"");; ```; - Make sure histograms having quotes in title are properly saved in .C files. ### TH2, TH3. - Add new functions `TH2::QuantilesX` and `TH2::QuantilesY` to return in a 1D histogram the projected quantiles distribution along; the other Y or X axis. The return histogram will have as bin error an approximate error on the quantile assuming a normal distribution of the; bin contents in the other axis. - Update Projection methods of both TH2 and TH3 to not return a null; pointer when an histogram with the same name already existed and it; was not compatible. Now just set the new correct binning on the; previously existing histogram. ### TGraph. - `TGraph::Draw()` needed at least the option `AL` to draw the graph; axis even when there was no active canvas or when the active canvas; did not have any axis defined. This was counter-intuitive. Now if; `TGraph::Draw()` is invoked without parameter and if there is no; axis defined in the current canvas, the option `ALP` is automatically; set.; - Change `SavePrimtive()` to improve speed compilation on generated macros. ### TGraph2D. - When `GetX(YZ)axis` were called on a `TGraph2D`, the frame limit and; plotting options were changed.; - Modify the `Clear` function in order to be able to reuse a; `TGraph2D` after a `Clear` is performed.; - In `GetHistogram()` the lower and higher axis limits are always; different.; - Protection added to avoid a Seg Fault on `.q` when `SetHistogram()`; is called on a `TGraph2D`. ### TMultiGraph. - In `TMultiGraph::Add(TMultiGraph *multigraph, Option_t *chopt)`; If `chopt` is defined all the graphs in `multigraph` will be added; with the `chopt` option. If `chopt` is undefined each graph will; be added with the option it had in `multigraph`.; - The option ""A"" in the `Draw()` was not cleaning properly the; current pad.; - Implement t",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/doc/v600/index.md:10845,intuit,intuitive,10845,hist/doc/v600/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/doc/v600/index.md,1,['intuit'],['intuitive']
Usability,"ll call; ``abandon`` to indicate that some error occurred during linking. A call to the; ``InFlightAlloc::finalize`` method should cause content for the allocation to be; transferred from working to executor memory, and permissions to be run. A call; to ``abandon`` should result in both kinds of memory being deallocated. On successful finalization, the ``InFlightAlloc::finalize`` method should; construct a ``FinalizedAlloc`` object (an opaque uint64_t id that the; ``JITLinkMemoryManager`` can use to identify executor memory for deallocation); and pass it to the ``OnFinalized`` callback. Finalized allocations (represented by ``FinalizedAlloc`` objects) can be; deallocated by calling the ``JITLinkMemoryManager::dealloc`` method. This method; takes a vector of ``FinalizedAlloc`` objects, since it is common to deallocate; multiple objects at the same time and this allows us to batch these requests for; transmission to the executing process. JITLink provides a simple in-process implementation of this interface:; ``InProcessMemoryManager``. It allocates pages once and re-uses them as both; working and target memory. ORC provides a cross-process-capable ``MapperJITLinkMemoryManager`` that can use; shared memory or ORC-RPC-based communication to transfer content to the executing; process. JITLinkMemoryManager and Security; ---------------------------------. JITLink's ability to link JIT'd code for a separate executor process can be; used to improve the security of a JIT system: The executor process can be; sandboxed, run within a VM, or even run on a fully separate machine. JITLink's memory manager interface is flexible enough to allow for a range of; trade-offs between performance and security. For example, on a system where code; pages must be signed (preventing code from being updated), the memory manager; can deallocate working memory pages after linking to free memory in the process; running JITLink. Alternatively, on a system that allows RWX pages, the memory; manager",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/JITLink.rst:30330,simpl,simple,30330,interpreter/llvm-project/llvm/docs/JITLink.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/JITLink.rst,1,['simpl'],['simple']
Usability,"ll double @foo(); br label %ifcont. else: ; preds = %entry; %calltmp1 = call double @bar(); br label %ifcont. ifcont: ; preds = %else, %then; %iftmp = phi double [ %calltmp, %then ], [ %calltmp1, %else ]; ret double %iftmp; }. To visualize the control flow graph, you can use a nifty feature of the; LLVM '`opt <https://llvm.org/cmds/opt.html>`_' tool. If you put this LLVM; IR into ""t.ll"" and run ""``llvm-as < t.ll | opt -passes=view-cfg``"", `a; window will pop up <../../ProgrammersManual.html#viewing-graphs-while-debugging-code>`_ and you'll; see this graph:. .. figure:: LangImpl05-cfg.png; :align: center; :alt: Example CFG. Example CFG. Another way to get this is to call ""``F->viewCFG()``"" or; ""``F->viewCFGOnly()``"" (where F is a ""``Function*``"") either by; inserting actual calls into the code and recompiling or by calling these; in the debugger. LLVM has many nice features for visualizing various; graphs. Getting back to the generated code, it is fairly simple: the entry block; evaluates the conditional expression (""x"" in our case here) and compares; the result to 0.0 with the ""``fcmp one``"" instruction ('one' is ""Ordered; and Not Equal""). Based on the result of this expression, the code jumps; to either the ""then"" or ""else"" blocks, which contain the expressions for; the true/false cases. Once the then/else blocks are finished executing, they both branch back; to the 'ifcont' block to execute the code that happens after the; if/then/else. In this case the only thing left to do is to return to the; caller of the function. The question then becomes: how does the code; know which expression to return?. The answer to this question involves an important SSA operation: the; `Phi; operation <http://en.wikipedia.org/wiki/Static_single_assignment_form>`_.; If you're not familiar with SSA, `the wikipedia; article <http://en.wikipedia.org/wiki/Static_single_assignment_form>`_; is a good introduction and there are various other introductions to it; available on your favorite sea",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl05.rst:6574,simpl,simple,6574,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl05.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl05.rst,1,['simpl'],['simple']
Usability,"ll page budget is reached,; pages larger than the page at hand are flushed before the page at hand is flushed.; For the parallel writer, every fill context maintains the page memory budget independently. Note that the total amount of memory consumed for writing is usually larger than the write page budget.; For instance, if buffered writing is used (the default), additional memory is required.; Use RNTupleModel::EstimateWriteMemoryUsage() for the total estimated memory use for writing. The default values are tuned for a total write memory of around 300 MB per writer resp. fill context.; In order to decrease the memory consumption,; users should decrease the target cluster size before tuning more intricate memory settings. Notes; =====. Approximation of the compressed cluster size; --------------------------------------------. The estimator for the compressed cluster size uses the average compression factor; of the so far written clusters.; This has been choosen as a simple, yet expectedly accurate enough estimator (to be validated).; The following alternative strategies were discussed:. - The average compression factor of all so-far written pages.; Easy to implement.; It would better prevent outlier clusters from skewing the estimate of the successor clusters.; It would be slower though in adjusting to systematic changes in the data set,; e.g. ones that are caused by changing experimental conditions during data taking. - The average over a window of the last $k$ clusters, possibly with exponential smoothing.; More code compared to the average compression factor or all so-far written clusters.; It would be faster in adjusting to systematic changes in the data set,; e.g. ones that are caused by changing experimental conditions during data taking.; Could be a viable option if cluster compression ratios turn out to change significantly in a single file. - Calculate the cluster compression ratio from column-based individual estimators.; More complex to implement and to r",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/doc/tuning.md:3345,simpl,simple,3345,tree/ntuple/v7/doc/tuning.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/doc/tuning.md,1,['simpl'],['simple']
Usability,"ll use JSROOT provided with ROOT installation. This allows to use notebooks; without internet connection (offline). ## JavaScript ROOT; - Provide monitoring capabilities for TGeoManager object. Now geomtry with some tracks can be displayed and; updated in web browser, using THttpServer monitoring capability like histogram objects. ## Tutorials; - Add the ""Legacy"" category collecting the old tutorials which do not represent any more best practices. ## Class Reference Guide; - Images in tutorials can now be displayed à JavaScript thanks to the (js) option; added next to the directive `\macro_image`; - As the tutorial `palettes.C` is often hit when searching the keyword `palette`; in the reference guide, a direct link from this example to the full list of; predefined palettes given in `TColor` has been added.; - Revisited the TSpectrum2 documentation. All the static images have been replaced; by macros generating images at reference guide build time. These macros have; been added in the tutorial section of the reference guide.; - The Reference Guide can now be accessed directly from the ROOT prompt thanks to; a great extension (implemented by Desislava Kalaydjieva) of the `.help` command.; For example to access the Reference Guide for `TTree` it is enough to type:; ~~~ {.cpp}; root[0] .help TTree; ~~~; To open the reference guide for a function/member:; ~~~ {.cpp}; root[0] .help TTree::Draw; ~~~. ## Build, Configuration and Testing Infrastructure. - Make MLP optional via the `-Dmlp={OFF,ON}` switch for CMake; - Make Spectrum optional via the `-Dspectrum={OFF,ON}` switch for CMake; - ROOT now fails to configure when any package is missing; when `-Dfail-on-missing=ON` is passed to CMake; - The `-Dall=ON` now switches the default value of all optional packages to `ON`; - The options `astiff`, `cling`, `pch`, `thread`, and `explicitlink` have been; removed and are now ignored. They either had no effect (their value was not; being used in the build system), or could not be ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v620/index.md:7422,guid,guide,7422,README/ReleaseNotes/v620/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v620/index.md,1,['guid'],['guide']
Usability,"ll.; If '``address``' is ``poison`` or ``undef``, this instruction has undefined; behavior. Implementation:; """""""""""""""""""""""""""""". This is typically implemented with a jump through a register. Example:; """""""""""""""". .. code-block:: llvm. indirectbr ptr %Addr, [ label %bb1, label %bb2, label %bb3 ]. .. _i_invoke:. '``invoke``' Instruction; ^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. <result> = invoke [cconv] [ret attrs] [addrspace(<num>)] <ty>|<fnty> <fnptrval>(<function args>) [fn attrs]; [operand bundles] to label <normal label> unwind label <exception label>. Overview:; """""""""""""""""". The '``invoke``' instruction causes control to transfer to a specified; function, with the possibility of control flow transfer to either the; '``normal``' label or the '``exception``' label. If the callee function; returns with the ""``ret``"" instruction, control flow will return to the; ""normal"" label. If the callee (or any indirect callees) returns via the; "":ref:`resume <i_resume>`"" instruction or other exception handling; mechanism, control is interrupted and continued at the dynamically; nearest ""exception"" label. The '``exception``' label is a `landing; pad <ExceptionHandling.html#overview>`_ for the exception. As such,; '``exception``' label is required to have the; "":ref:`landingpad <i_landingpad>`"" instruction, which contains the; information about the behavior of the program after unwinding happens,; as its first non-PHI instruction. The restrictions on the; ""``landingpad``"" instruction's tightly couples it to the ""``invoke``""; instruction, so that the important information contained within the; ""``landingpad``"" instruction can't be lost through normal code motion. Arguments:; """""""""""""""""""". This instruction requires several arguments:. #. The optional ""cconv"" marker indicates which :ref:`calling; convention <callingconv>` the call should use. If none is; specified, the call defaults to using C calling conventions.; #. The optional :ref:`Parameter Attributes <paramattrs>` list for ret",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:362071,resume,resume,362071,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['resume'],['resume']
Usability,"llection::iterator()`: same; - `RooAbsCollection::fwdIterator()`: same. - `RooWorkspace::componentIterator()`: use `RooWorkspace::components()` with range-based loop. ### Deprecation of legacy test statistics classes in public interface. Instantiating the following classes and even including their header files is deprecated, and the headers will be removed in ROOT 6.34:. * RooAbsTestStatistic; * RooAbsOptTestStatistic; * RooNLLVar; * RooChi2Var; * RooXYChi2Var. Please use the higher-level functions `RooAbsPdf::createNLL()` and `RooAbsPdf::createChi2()` if you want to create objects that represent test statistics. ### Change of RooParamHistFunc. The `RooParamHistFunc` didn't take any observable `RooRealVar` as constructor; argument. It assumes as observable the internal variables in the passed; RooDataHist. This means it was in most contexts unusable, because the input; can't be changed, other than loading a different bin in the dataset. Furthermore, there was actually a constructor that took a `RooAbsArg x`, but it; was simply ignored. To fix all these problems, the existing constructors were replaced by a new one; that takes the observable explicitly. Since the old constructors resulted in wrong computation graphs that caused; trouble with the new CPU evaluation backend, they had to be removed without; deprecation. Please adapt your code if necessary. ### Renaming of some RooFit classes. The `RooPower` was renamed to `RooPowerSum`, and `RooExpPoly` was renamed to `RooLegacyExpPoly`. This was a necessary change, because the names of these classes introduced in ROOT 6.28 collided with some classes in CMS combine, which were around already long before. Therefore, the classes had to be renamed to not cause any problems for CMS. In the unlikeliy case where you should have used these new classes for analysis already, please adapt your code to the new names and re-create your workspaces. ## RDataFrame. * The `RDataFrame` constructors that take in input one or more file nam",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v632/index.md:13560,simpl,simply,13560,README/ReleaseNotes/v632/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v632/index.md,1,['simpl'],['simply']
Usability,"lling the ``emit`` method of its base; layer. For example, in this tutorial our IRTransformLayer calls through to; our IRCompileLayer to compile the transformed IR, and our IRCompileLayer in; turn calls our ObjectLayer to link the object file produced by our compiler. So far we have learned how to optimize and compile our LLVM IR, but we have; not focused on when compilation happens. Our current REPL optimizes and; compiles each function as soon as it is referenced by any other code,; regardless of whether it is ever called at runtime. In the next chapter we; will introduce a fully lazy compilation, in which functions are not compiled; until they are first called at run-time. At this point the trade-offs get much; more interesting: the lazier we are, the quicker we can start executing the; first function, but the more often we will have to pause to compile newly; encountered functions. If we only code-gen lazily, but optimize eagerly, we; will have a longer startup time (as everything is optimized at that time) but; relatively short pauses as each function just passes through code-gen. If we; both optimize and code-gen lazily we can start executing the first function; more quickly, but we will have longer pauses as each function has to be both; optimized and code-gen'd when it is first executed. Things become even more; interesting if we consider interprocedural optimizations like inlining, which; must be performed eagerly. These are complex trade-offs, and there is no; one-size-fits all solution to them, but by providing composable layers we leave; the decisions to the person implementing the JIT, and make it easy for them to; experiment with different configurations. `Next: Adding Per-function Lazy Compilation <BuildingAJIT3.html>`_. Full Code Listing; =================. Here is the complete code listing for our running example with an; IRTransformLayer added to enable optimization. To build this example, use:. .. code-block:: bash. # Compile; clang++ -g toy.cpp `",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/BuildingAJIT2.rst:11136,pause,pauses,11136,interpreter/llvm-project/llvm/docs/tutorial/BuildingAJIT2.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/BuildingAJIT2.rst,1,['pause'],['pauses']
Usability,"llo; World Pass"". The last two arguments describe its behavior: if a pass walks CFG; without modifying it then the third argument is set to ``true``; if a pass is; an analysis pass, for example dominator tree pass, then ``true`` is supplied as; the fourth argument. As a whole, the ``.cpp`` file looks like:. .. code-block:: c++. #include ""llvm/Pass.h""; #include ""llvm/IR/Function.h""; #include ""llvm/Support/raw_ostream.h"". #include ""llvm/IR/LegacyPassManager.h"". using namespace llvm;. namespace {; struct Hello : public FunctionPass {; static char ID;; Hello() : FunctionPass(ID) {}. bool runOnFunction(Function &F) override {; errs() << ""Hello: "";; errs().write_escaped(F.getName()) << '\n';; return false;; }; }; // end of struct Hello; } // end of anonymous namespace. char Hello::ID = 0;; static RegisterPass<Hello> X(""hello"", ""Hello World Pass"",; false /* Only looks at CFG */,; false /* Analysis Pass */);. Now that it's all together, compile the file with a simple ""``gmake``"" command; from the top level of your build directory and you should get a new file; ""``lib/LLVMHello.so``"". Note that everything in this file is; contained in an anonymous namespace --- this reflects the fact that passes; are self contained units that do not need external interfaces (although they; can have them) to be useful. Running a pass with ``opt``; ---------------------------. Now that you have a brand new shiny shared object file, we can use the; :program:`opt` command to run an LLVM program through your pass. Because you; registered your pass with ``RegisterPass``, you will be able to use the; :program:`opt` tool to access it, once loaded. To test it, follow the example at the end of the :doc:`GettingStarted` to; compile ""Hello World"" to LLVM. We can now run the bitcode file (hello.bc) for; the program through our transformation like this (or course, any bitcode file; will work):. .. code-block:: console. $ opt -load lib/LLVMHello.so -hello < hello.bc > /dev/null; Hello: __main; Hello: puts;",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/WritingAnLLVMPass.rst:7296,simpl,simple,7296,interpreter/llvm-project/llvm/docs/WritingAnLLVMPass.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/WritingAnLLVMPass.rst,1,['simpl'],['simple']
Usability,"llowed by glue nodes. A SelectionDAG has designated ""Entry"" and ""Root"" nodes. The Entry node is; always a marker node with an Opcode of ``ISD::EntryToken``. The Root node is; the final side-effecting node in the token chain. For example, in a single basic; block function it would be the return node. One important concept for SelectionDAGs is the notion of a ""legal"" vs.; ""illegal"" DAG. A legal DAG for a target is one that only uses supported; operations and supported types. On a 32-bit PowerPC, for example, a DAG with a; value of type i1, i8, i16, or i64 would be illegal, as would a DAG that uses a; SREM or UREM operation. The `legalize types`_ and `legalize operations`_ phases; are responsible for turning an illegal DAG into a legal DAG. .. _SelectionDAG-Process:. SelectionDAG Instruction Selection Process; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. SelectionDAG-based instruction selection consists of the following steps:. #. `Build initial DAG`_ --- This stage performs a simple translation from the; input LLVM code to an illegal SelectionDAG. #. `Optimize SelectionDAG`_ --- This stage performs simple optimizations on the; SelectionDAG to simplify it, and recognize meta instructions (like rotates; and ``div``/``rem`` pairs) for targets that support these meta operations.; This makes the resultant code more efficient and the `select instructions; from DAG`_ phase (below) simpler. #. `Legalize SelectionDAG Types`_ --- This stage transforms SelectionDAG nodes; to eliminate any types that are unsupported on the target. #. `Optimize SelectionDAG`_ --- The SelectionDAG optimizer is run to clean up; redundancies exposed by type legalization. #. `Legalize SelectionDAG Ops`_ --- This stage transforms SelectionDAG nodes to; eliminate any operations that are unsupported on the target. #. `Optimize SelectionDAG`_ --- The SelectionDAG optimizer is run to eliminate; inefficiencies introduced by operation legalization. #. `Select instructions from DAG`_ --- Finally, the target in",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodeGenerator.rst:36985,simpl,simple,36985,interpreter/llvm-project/llvm/docs/CodeGenerator.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodeGenerator.rst,1,['simpl'],['simple']
Usability,"llvm-cxxfilt - LLVM symbol name demangler; =========================================. .. program:: llvm-cxxfilt. SYNOPSIS; --------. :program:`llvm-cxxfilt` [*options*] [*mangled names...*]. DESCRIPTION; -----------. :program:`llvm-cxxfilt` is a symbol demangler that can be used as a replacement; for the GNU :program:`c++filt` tool. It takes a series of symbol names and; prints their demangled form on the standard output stream. If a name cannot be; demangled, it is simply printed as is. If no names are specified on the command-line, names are read interactively from; the standard input stream. When reading names from standard input, each input; line is split on characters that are not part of valid Itanium name manglings,; i.e. characters that are not alphanumeric, '.', '$', or '_'. Separators between; names are copied to the output as is. EXAMPLE; -------. .. code-block:: console. $ llvm-cxxfilt _Z3foov _Z3bari not_mangled; foo(); bar(int); not_mangled; $ cat input.txt; | _Z3foov *** _Z3bari *** not_mangled |; $ llvm-cxxfilt < input.txt; | foo() *** bar(int) *** not_mangled |. OPTIONS; -------. .. option:: --format=<value>, -s. Mangling scheme to assume. Valid values are ``auto`` (default, auto-detect the; style) and ``gnu`` (assume GNU/Itanium style). .. option:: --help, -h. Print a summary of command line options. .. option:: --no-params, -p. Do not demangle function parameters or return types. .. option:: --no-strip-underscore, -n. Do not strip a leading underscore. This is the default for all platforms; except Mach-O based hosts. .. option:: --strip-underscore, -_. Strip a single leading underscore, if present, from each input name before; demangling. On by default on Mach-O based platforms. .. option:: --types, -t. Attempt to demangle names as type names as well as function names. .. option:: --version. Display the version of the :program:`llvm-cxxfilt` executable. .. option:: @<FILE>. Read command-line options from response file `<FILE>`. EXIT STATUS; -------",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-cxxfilt.rst:471,simpl,simply,471,interpreter/llvm-project/llvm/docs/CommandGuide/llvm-cxxfilt.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-cxxfilt.rst,1,['simpl'],['simply']
Usability,"llvm-nm - list LLVM bitcode and object file's symbol table; ==========================================================. .. program:: llvm-nm. SYNOPSIS; --------. :program:`llvm-nm` [*options*] [*filenames...*]. DESCRIPTION; -----------. The :program:`llvm-nm` utility lists the names of symbols from LLVM bitcode; files, object files, and archives. Each symbol is listed along with some simple; information about its provenance. If no filename is specified, *a.out* is used; as the input. If *-* is used as a filename, :program:`llvm-nm` will read a file; from its standard input stream. :program:`llvm-nm`'s default output format is the traditional BSD :program:`nm`; output format. Each such output record consists of an (optional) 8-digit; hexadecimal address, followed by a type code character, followed by a name, for; each symbol. One record is printed per line; fields are separated by spaces.; When the address is omitted, it is replaced by 8 spaces. The supported type code characters are as follows. Where both lower and; upper-case characters are listed for the same meaning, a lower-case character; represents a local symbol, whilst an upper-case character represents a global; (external) symbol:. a, A. Absolute symbol. b, B. Uninitialized data (bss) object. C. Common symbol. Multiple definitions link together into one definition. d, D. Writable data object. i, I. COFF: .idata symbol or symbol in a section with IMAGE_SCN_LNK_INFO set. n. ELF: local symbol from non-alloc section. COFF: debug symbol. N. ELF: debug section symbol, or global symbol from non-alloc section. s, S. COFF: section symbol. Mach-O: absolute symbol or symbol from a section other than __TEXT_EXEC __text,; __TEXT __text, __DATA __data, or __DATA __bss. r, R. Read-only data object. t, T. Code (text) object. u. ELF: GNU unique symbol. U. Named object is undefined in this file. v. ELF: Undefined weak object. It is not a link failure if the object is not; defined. V. ELF: Defined weak object symbol. This defi",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-nm.rst:387,simpl,simple,387,interpreter/llvm-project/llvm/docs/CommandGuide/llvm-nm.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-nm.rst,1,['simpl'],['simple']
Usability,"llvm-profgen - LLVM SPGO profile generation tool; ================================================. .. program:: llvm-profgen. SYNOPSIS; --------. :program:`llvm-profgen` [*commands*] [*options*]. DESCRIPTION; -----------. The :program:`llvm-profgen` utility generates a profile data file; from given perf script data files for sample-based profile guided; optimization(SPGO). COMMANDS; --------; At least one of the following commands are required:. .. option:: --perfscript=<string[,string,...]>. Path of perf-script trace created by Linux perf tool with `script`; command(the raw perf.data should be profiled with -b). .. option:: --binary=<string[,string,...]>. Path of the input profiled binary files. .. option:: --output=<string>. Path of the output profile file. OPTIONS; -------; :program:`llvm-profgen` supports the following options:. .. option:: --format=[text|binary|extbinary|compbinary|gcc]. Specify the format of the generated profile. Supported <format> are `text`,; `binary`, `extbinary`, `compbinary`, `gcc`, see `llvm-profdata` for more; descriptions of the format. .. option:: --show-mmap-events. Print mmap events. .. option:: --show-disassembly. Print disassembled code. .. option:: --x86-asm-syntax=[att|intel]. Specify whether to print assembly code in AT&T syntax (the default) or Intel; syntax.; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-profgen.rst:349,guid,guided,349,interpreter/llvm-project/llvm/docs/CommandGuide/llvm-profgen.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-profgen.rst,1,['guid'],['guided']
Usability,"llvm; define void @f(void ()* %fp) {; call void %fp() [ ""ptrauth""(i32 <key>, i64 <data>) ]; ret void; }; ```. is functionally equivalent to:. ```llvm; define void @f(void ()* %fp) {; %fp_i = ptrtoint void ()* %fp to i64; %fp_auth = call i64 @llvm.ptrauth.auth(i64 %fp_i, i32 <key>, i64 <data>); %fp_auth_p = inttoptr i64 %fp_auth to void ()*; call void %fp_auth_p(); ret void; }; ```. but with the added guarantee that `%fp_i`, `%fp_auth`, and `%fp_auth_p`; are not stored to (and reloaded from) memory. ## AArch64 Support. AArch64 is currently the only architecture with full support of the pointer; authentication primitives, based on Armv8.3-A instructions. ### Armv8.3-A PAuth Pointer Authentication Code. The Armv8.3-A architecture extension defines the PAuth feature, which provides; support for instructions that manipulate Pointer Authentication Codes (PAC). #### Keys. 5 keys are supported by the PAuth feature. Of those, 4 keys are interchangeably usable to specify the key used in IR; constructs:; * `ASIA`/`ASIB` are instruction keys (encoded as respectively 0 and 1).; * `ASDA`/`ASDB` are data keys (encoded as respectively 2 and 3). `ASGA` is a special key that cannot be explicitly specified, and is only ever; used implicitly, to implement the; [`llvm.ptrauth.sign_generic`](#llvm-ptrauth-sign-generic) intrinsic. #### Instructions. The IR [Intrinsics](#intrinsics) described above map onto these; instructions as such:; * [`llvm.ptrauth.sign`](#llvm-ptrauth-sign): `PAC{I,D}{A,B}{Z,SP,}`; * [`llvm.ptrauth.auth`](#llvm-ptrauth-auth): `AUT{I,D}{A,B}{Z,SP,}`; * [`llvm.ptrauth.strip`](#llvm-ptrauth-strip): `XPAC{I,D}`; * [`llvm.ptrauth.blend`](#llvm-ptrauth-blend): The semantics of the blend; operation are specified by the ABI. In both the ELF PAuth ABI Extension and; arm64e, it's a `MOVK` into the high 16 bits. Consequently, this limits; the width of the integer discriminator used in blends to 16 bits.; * [`llvm.ptrauth.sign_generic`](#llvm-ptrauth-sign-generic): `PACGA`; * [`",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/PointerAuth.md:8131,usab,usable,8131,interpreter/llvm-project/llvm/docs/PointerAuth.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/PointerAuth.md,1,['usab'],['usable']
Usability,"llvm_stackmaps"". The segment name is ""__LLVM_STACKMAPS"". For ELF (e.g. on Linux), the stack map section name is; "".llvm_stackmaps"". The segment name is ""__LLVM_STACKMAPS"". Stack Map Usage; ===============. The stack map support described in this document can be used to; precisely determine the location of values at a specific position in; the code. LLVM does not maintain any mapping between those values and; any higher-level entity. The runtime must be able to interpret the; stack map record given only the ID, offset, and the order of the; locations, records, and functions, which LLVM preserves. Note that this is quite different from the goal of debug information,; which is a best-effort attempt to track the location of named; variables at every instruction. An important motivation for this design is to allow a runtime to; commandeer a stack frame when execution reaches an instruction address; associated with a stack map. The runtime must be able to rebuild a; stack frame and resume program execution using the information; provided by the stack map. For example, execution may resume in an; interpreter or a recompiled version of the same function. This usage restricts LLVM optimization. Clearly, LLVM must not move; stores across a stack map. However, loads must also be handled; conservatively. If the load may trigger an exception, hoisting it; above a stack map could be invalid. For example, the runtime may; determine that a load is safe to execute without a type check given; the current state of the type system. If the type system changes while; some activation of the load's function exists on the stack, the load; becomes unsafe. The runtime can prevent subsequent execution of that; load by immediately patching any stack map location that lies between; the current call site and the load (typically, the runtime would; simply patch all stack map locations to invalidate the function). If; the compiler had hoisted the load above the stack map, then the; program could cr",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/StackMaps.rst:17693,resume,resume,17693,interpreter/llvm-project/llvm/docs/StackMaps.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/StackMaps.rst,1,['resume'],['resume']
Usability,"load into a compare. The; pattern is written as (cmp reg, (load p)). Because the compare isn't; commutative, it is not matched with the load on both sides. The dag combiner; should be made smart enough to canonicalize the load into the RHS of a compare; when it can invert the result of the compare for free. //===---------------------------------------------------------------------===//. In many cases, LLVM generates code like this:. _test:; movl 8(%esp), %eax; cmpl %eax, 4(%esp); setl %al; movzbl %al, %eax; ret. on some processors (which ones?), it is more efficient to do this:. _test:; movl 8(%esp), %ebx; xor %eax, %eax; cmpl %ebx, 4(%esp); setl %al; ret. Doing this correctly is tricky though, as the xor clobbers the flags. //===---------------------------------------------------------------------===//. We should generate bts/btr/etc instructions on targets where they are cheap or; when codesize is important. e.g., for:. void setbit(int *target, int bit) {; *target |= (1 << bit);; }; void clearbit(int *target, int bit) {; *target &= ~(1 << bit);; }. //===---------------------------------------------------------------------===//. Instead of the following for memset char*, 1, 10:. 	movl $16843009, 4(%edx); 	movl $16843009, (%edx); 	movw $257, 8(%edx). It might be better to generate. 	movl $16843009, %eax; 	movl %eax, 4(%edx); 	movl %eax, (%edx); 	movw al, 8(%edx); 	; when we can spare a register. It reduces code size. //===---------------------------------------------------------------------===//. Evaluate what the best way to codegen sdiv X, (2^C) is. For X/8, we currently; get this:. define i32 @test1(i32 %X) {; %Y = sdiv i32 %X, 8; ret i32 %Y; }. _test1:; movl 4(%esp), %eax; movl %eax, %ecx; sarl $31, %ecx; shrl $29, %ecx; addl %ecx, %eax; sarl $3, %eax; ret. GCC knows several different ways to codegen it, one of which is this:. _test1:; movl 4(%esp), %eax; cmpl $-1, %eax; leal 7(%eax), %ecx; cmovle %ecx, %eax; sarl $3, %eax; ret. which is probably slower, but it's",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/README.txt:3685,clear,clearbit,3685,interpreter/llvm-project/llvm/lib/Target/X86/README.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/README.txt,1,['clear'],['clearbit']
Usability,"loading from null is undefined:. struct S { int w, x, y, z; };; struct T { int r; struct S s; };; void bar (struct S, int);; void foo (int a, struct T b); {; struct S *c = 0;; if (a); c = &b.s;; bar (*c, a);; }. //===---------------------------------------------------------------------===//. simplifylibcalls should do several optimizations for strspn/strcspn:. strcspn(x, ""a"") -> inlined loop for up to 3 letters (similarly for strspn):. size_t __strcspn_c3 (__const char *__s, int __reject1, int __reject2,; int __reject3) {; register size_t __result = 0;; while (__s[__result] != '\0' && __s[__result] != __reject1 &&; __s[__result] != __reject2 && __s[__result] != __reject3); ++__result;; return __result;; }. This should turn into a switch on the character. See PR3253 for some notes on; codegen. 456.hmmer apparently uses strcspn and strspn a lot. 471.omnetpp uses strspn. //===---------------------------------------------------------------------===//. simplifylibcalls should turn these snprintf idioms into memcpy (GCC PR47917). char buf1[6], buf2[6], buf3[4], buf4[4];; int i;. int foo (void) {; int ret = snprintf (buf1, sizeof buf1, ""abcde"");; ret += snprintf (buf2, sizeof buf2, ""abcdef"") * 16;; ret += snprintf (buf3, sizeof buf3, ""%s"", i++ < 6 ? ""abc"" : ""def"") * 256;; ret += snprintf (buf4, sizeof buf4, ""%s"", i++ > 10 ? ""abcde"" : ""defgh"")*4096;; return ret;; }. //===---------------------------------------------------------------------===//. ""gas"" uses this idiom:; else if (strchr (""+-/*%|&^:[]()~"", *intel_parser.op_string)); ..; else if (strchr (""<>"", *intel_parser.op_string). Those should be turned into a switch. SimplifyLibCalls only gets the second; case. //===---------------------------------------------------------------------===//. 252.eon contains this interesting code:. %3072 = getelementptr [100 x i8]* %tempString, i32 0, i32 0; %3073 = call i8* @strcpy(i8* %3072, i8* %3071) nounwind; %strlen = call i32 @strlen(i8* %3072) ; uses = 1; %endptr = getelementptr [1",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/README.txt:37448,simpl,simplifylibcalls,37448,interpreter/llvm-project/llvm/lib/Target/README.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/README.txt,1,['simpl'],['simplifylibcalls']
Usability,"lobal i32 0. define i32 @test(i1 %Condition) {; entry:; br i1 %Condition, label %cond_true, label %cond_false. cond_true:; %X.0 = load i32, i32* @G; br label %cond_next. cond_false:; %X.1 = load i32, i32* @H; br label %cond_next. cond_next:; %X.01 = phi i32 [ %X.1, %cond_false ], [ %X.0, %cond_true ]; ret i32 %X.01; }. The mem2reg pass implements the standard ""iterated dominance frontier""; algorithm for constructing SSA form and has a number of optimizations; that speed up (very common) degenerate cases. The mem2reg optimization; pass is the answer to dealing with mutable variables, and we highly; recommend that you depend on it. Note that mem2reg only works on; variables in certain circumstances:. #. mem2reg is alloca-driven: it looks for allocas and if it can handle; them, it promotes them. It does not apply to global variables or heap; allocations.; #. mem2reg only looks for alloca instructions in the entry block of the; function. Being in the entry block guarantees that the alloca is only; executed once, which makes analysis simpler.; #. mem2reg only promotes allocas whose uses are direct loads and stores.; If the address of the stack object is passed to a function, or if any; funny pointer arithmetic is involved, the alloca will not be; promoted.; #. mem2reg only works on allocas of `first; class <../../LangRef.html#first-class-types>`_ values (such as pointers,; scalars and vectors), and only if the array size of the allocation is; 1 (or missing in the .ll file). mem2reg is not capable of promoting; structs or arrays to registers. Note that the ""sroa"" pass is; more powerful and can promote structs, ""unions"", and arrays in many; cases. All of these properties are easy to satisfy for most imperative; languages, and we'll illustrate it below with Kaleidoscope. The final; question you may be asking is: should I bother with this nonsense for my; front-end? Wouldn't it be better if I just did SSA construction; directly, avoiding use of the mem2reg optimization pass?",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl07.rst:8091,simpl,simpler,8091,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl07.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl07.rst,1,['simpl'],['simpler']
Usability,"loc(i32 %size); br label %coro.begin; coro.begin:; %phi = phi ptr [ null, %entry ], [ %alloc, %dyn.alloc ]; %hdl = call noalias ptr @llvm.coro.begin(token %id, ptr %phi); br label %loop; loop:; %n.val = phi i32 [ %n, %coro.begin ], [ %inc, %loop ]; %inc = add nsw i32 %n.val, 1; store i32 %n.val, ptr %promise; %0 = call i8 @llvm.coro.suspend(token none, i1 false); switch i8 %0, label %suspend [i8 0, label %loop; i8 1, label %cleanup]; cleanup:; %mem = call ptr @llvm.coro.free(token %id, ptr %hdl); call void @free(ptr %mem); br label %suspend; suspend:; %unused = call i1 @llvm.coro.end(ptr %hdl, i1 false, token none); ret ptr %hdl; }. A coroutine consumer can rely on the `coro.promise`_ intrinsic to access the; coroutine promise. .. code-block:: llvm. define i32 @main() {; entry:; %hdl = call ptr @f(i32 4); %promise.addr = call ptr @llvm.coro.promise(ptr %hdl, i32 4, i1 false); %val0 = load i32, ptr %promise.addr; call void @print(i32 %val0); call void @llvm.coro.resume(ptr %hdl); %val1 = load i32, ptr %promise.addr; call void @print(i32 %val1); call void @llvm.coro.resume(ptr %hdl); %val2 = load i32, ptr %promise.addr; call void @print(i32 %val2); call void @llvm.coro.destroy(ptr %hdl); ret i32 0; }. After example in this section is compiled, result of the compilation will be:. .. code-block:: llvm. define i32 @main() {; entry:; tail call void @print(i32 4); tail call void @print(i32 5); tail call void @print(i32 6); ret i32 0; }. .. _final:; .. _final suspend:. Final Suspend; -------------. A coroutine author or a frontend may designate a particular suspend to be final,; by setting the second argument of the `coro.suspend`_ intrinsic to `true`.; Such a suspend point has two properties:. * it is possible to check whether a suspended coroutine is at the final suspend; point via `coro.done`_ intrinsic;. * a resumption of a coroutine stopped at the final suspend point leads to; undefined behavior. The only possible action for a coroutine at a final; suspend point is dest",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst:23969,resume,resume,23969,interpreter/llvm-project/llvm/docs/Coroutines.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst,1,['resume'],['resume']
Usability,"local; jump tables, this is easily arranged by testing the input to the jump table; within each destination (not yet implemented, use retpolines):; ```; pushq %rax; xorl %eax, %eax # Zero out initial predicate state.; movq $-1, %r8 # Put all-ones mask into a register.; jmpq *.LJTI0_0(,%rdi,8) # Indirect jump through table.; .LBB0_2: # %sw.bb; testq $0, %rdi # Validate index used for jump table.; cmovneq %r8, %rax # Conditionally update predicate state.; ...; jmp _Z4leaki # TAILCALL. .LBB0_3: # %sw.bb1; testq $1, %rdi # Validate index used for jump table.; cmovneq %r8, %rax # Conditionally update predicate state.; ...; jmp _Z4leaki # TAILCALL. .LBB0_5: # %sw.bb10; testq $2, %rdi # Validate index used for jump table.; cmovneq %r8, %rax # Conditionally update predicate state.; ...; jmp _Z4leaki # TAILCALL; ... .section .rodata,""a"",@progbits; .p2align 3; .LJTI0_0:; .quad .LBB0_2; .quad .LBB0_3; .quad .LBB0_5; ...; ```. Returns have a simple mitigation technique on x86-64 (or other ABIs which have; what is called a ""red zone"" region beyond the end of the stack). This region is; guaranteed to be preserved across interrupts and context switches, making the; return address used in returning to the current code remain on the stack and; valid to read. We can emit code in the caller to verify that a return edge was; not mispredicted:; ```; callq other_function; return_addr:; testq -8(%rsp), return_addr # Validate return address.; cmovneq %r8, %rax # Update predicate state.; ```. For an ABI without a ""red zone"" (and thus unable to read the return address; from the stack), we can compute the expected return address prior to the call; into a register preserved across the call and use that similarly to the above. Indirect calls (and returns in the absence of a red zone ABI) pose the most; significant challenge to propagate. The simplest technique would be to define a; new ABI such that the intended call target is passed into the called function; and checked in the entry. Unfortunat",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SpeculativeLoadHardening.md:19107,simpl,simple,19107,interpreter/llvm-project/llvm/docs/SpeculativeLoadHardening.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SpeculativeLoadHardening.md,1,['simpl'],['simple']
Usability,"logo.png ""OpenSSL Logo"")](https://www.openssl.org/). [![Mbed TLS](https://raw.githubusercontent.com/civetweb/civetweb/master/resources/mbedTLS_logo.png ""mbedTLS Logo"")](https://github.com/ARMmbed/mbedtls). Support; -------. This project is very easy to install and use.; Please read the [documentation](https://github.com/civetweb/civetweb/blob/master/docs/); and have a look at the [examples](https://github.com/civetweb/civetweb/blob/master/examples/). Recent questions and discussions usually use [GitHub issues](https://github.com/civetweb/civetweb/issues).; Some old information may be found on the [mailing list](https://groups.google.com/d/forum/civetweb), ; but this information may be outdated. Feel free to create a GitHub issue for bugs, feature requests, questions, suggestions or if you want to share tips and tricks.; When creating an issues for a bug, add enough description to reproduce the issue - at least add CivetWeb version and operating system.; Please see also the guidelines for [Contributions](https://github.com/civetweb/civetweb/blob/master/docs/Contribution.md) and the [Security Policy](https://github.com/civetweb/civetweb/blob/master/SECURITY.md). Note: We do not take any liability or warranty for any linked contents. Visit these pages and try the community support suggestions at your own risk.; Any link provided in this project (including source and documentation) is provided in the hope that this information will be helpful.; However, we cannot accept any responsibility for any content on an external page. Contributions; -------------. Contributions are welcome provided all contributions carry the MIT license. DO NOT APPLY fixes copied from Mongoose to this project to prevent GPL tainting.; Since 2013, CivetWeb and Mongoose are developed independently.; By now the code base differs, so patches cannot be safely transferred in either direction. Some guidelines can be found in [docs/Contribution.md](https://github.com/civetweb/civetweb/blob/master/docs/C",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/http/civetweb/README.md:8866,guid,guidelines,8866,net/http/civetweb/README.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/http/civetweb/README.md,1,['guid'],['guidelines']
Usability,"ls all bytes of the object with ``poison``. .. _int_lifeend:. '``llvm.lifetime.end``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare void @llvm.lifetime.end(i64 <size>, ptr nocapture <ptr>). Overview:; """""""""""""""""". The '``llvm.lifetime.end``' intrinsic specifies the end of a memory object's; lifetime. Arguments:; """""""""""""""""""". The first argument is a constant integer representing the size of the; object, or -1 if it is variable sized. The second argument is a pointer; to the object. Semantics:; """""""""""""""""""". If ``ptr`` is a stack-allocated object and it points to the first byte of the; object, the object is dead.; ``ptr`` is conservatively considered as a non-stack-allocated object if; the stack coloring algorithm that is used in the optimization pipeline cannot; conclude that ``ptr`` is a stack-allocated object. Calling ``llvm.lifetime.end`` on an already dead alloca is no-op. If ``ptr`` is a non-stack-allocated object or it does not point to the first; byte of the object, it is equivalent to simply filling all bytes of the object; with ``poison``. '``llvm.invariant.start``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """"""""""""""; This is an overloaded intrinsic. The memory object can belong to any address space. ::. declare ptr @llvm.invariant.start.p0(i64 <size>, ptr nocapture <ptr>). Overview:; """""""""""""""""". The '``llvm.invariant.start``' intrinsic specifies that the contents of; a memory object will not change. Arguments:; """""""""""""""""""". The first argument is a constant integer representing the size of the; object, or -1 if it is variable sized. The second argument is a pointer; to the object. Semantics:; """""""""""""""""""". This intrinsic indicates that until an ``llvm.invariant.end`` that uses; the return value, the referenced memory location is constant and; unchanging. '``llvm.invariant.end``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """"""""""""""; This is an overloaded intrinsic. The memory object can belong to any address space.",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:863538,simpl,simply,863538,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['simpl'],['simply']
Usability,"ls.; * Core idea of masking out loaded bits was part of the original mitigation; suggested by Jann Horn when these attacks were reported. ### Indirect Branches, Calls, and Returns. It is possible to attack control flow other than conditional branches with; variant #1 style mispredictions.; * A prediction towards a hot call target of a virtual method can lead to it; being speculatively executed when an expected type is used (often called; ""type confusion"").; * A hot case may be speculatively executed due to prediction instead of the; correct case for a switch statement implemented as a jump table.; * A hot common return address may be predicted incorrectly when returning from; a function. These code patterns are also vulnerable to Spectre variant #2, and as such are; best mitigated with a; [retpoline](https://support.google.com/faqs/answer/7625886) on x86 platforms.; When a mitigation technique like retpoline is used, speculation simply cannot; proceed through an indirect control flow edge (or it cannot be mispredicted in; the case of a filled RSB) and so it is also protected from variant #1 style; attacks. However, some architectures, micro-architectures, or vendors do not; employ the retpoline mitigation, and on future x86 hardware (both Intel and; AMD) it is expected to become unnecessary due to hardware-based mitigation. When not using a retpoline, these edges will need independent protection from; variant #1 style attacks. The analogous approach to that used for conditional; control flow should work:; ```; uintptr_t all_ones_mask = std::numerical_limits<uintptr_t>::max();; uintptr_t all_zeros_mask = 0;; void leak(int data);; void example(int* pointer1, int* pointer2) {; uintptr_t predicate_state = all_ones_mask;; switch (condition) {; case 0:; // Assuming ?: is implemented using branchless logic...; predicate_state = (condition != 0) ? all_zeros_mask : predicate_state;; // ... lots of code ...; //; // Harden the pointer so it can't be loaded; pointer1 &= predica",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SpeculativeLoadHardening.md:9151,simpl,simply,9151,interpreter/llvm-project/llvm/docs/SpeculativeLoadHardening.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SpeculativeLoadHardening.md,1,['simpl'],['simply']
Usability,"ls; might reference the same underlying values.; . To summarize, MemRegions are unique names for blocks of memory. Symbols are; unique names for abstract symbolic values. Some MemRegions represents abstract; symbolic chunks of memory, and thus are also based on symbols. SVals are just; references to values, and can reference either MemRegions, Symbols, or concrete; values (e.g., the number 1). Idea for a Checker; Here are several questions which you should consider when evaluating your; checker idea:; ; Can the check be effectively implemented without path-sensitive; analysis? See AST Visitors.; How high the false positive rate is going to be? Looking at the occurrences; of the issue you want to write a checker for in the existing code bases might; give you some ideas. ; How the current limitations of the analysis will effect the false alarm; rate? Currently, the analyzer only reasons about one procedure at a time (no; inter-procedural analysis). Also, it uses a simple range tracking based; solver to model symbolic execution.; Consult the GitHub Issues; to get some ideas for new checkers and consider starting with improving/fixing; bugs in the existing checkers. Once an idea for a checker has been chosen, there are two key decisions that; need to be made:; ; Which events the checker should be tracking. This is discussed in more; detail in the section Events, Callbacks, and; Checker Class Structure.; What checker-specific data needs to be stored as part of the program; state (if any). This should be minimized as much as possible. More detail about; implementing custom program state is given in section Custom Program States.; ; Checker Registration; All checker implementation files are located in; clang/lib/StaticAnalyzer/Checkers folder. The steps below describe; how the checker SimpleStreamChecker, which checks for misuses of; stream APIs, was registered with the analyzer.; Similar steps should be followed for a new checker. A new checker implementation file, SimpleS",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/checker_dev_manual.html:7886,simpl,simple,7886,interpreter/llvm-project/clang/www/analyzer/checker_dev_manual.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/checker_dev_manual.html,1,['simpl'],['simple']
Usability,"luded in TeX and LaTeX documents. `PGF` is a TeX macro package for generating graphics. It is platform; and format-independent and works together with the most important TeX; backend drivers, including pdftex and dvips. It comes with a; user-friedly syntax layer called `TikZ`. To generate a such file it is enough to do:. ```; gStyle->SetPaperSize(10.,10.);; hpx->Draw();; gPad->Print(""hpx.tex"");; ```. Then, the generated file (<tt>hpx.tex</tt>) can be included in a; LaTeX document (`simple.tex`) in the following way:. ```; \documentclass{article}; \usepackage{tikz}; \usetikzlibrary{patterns}; \title{A simple LaTeX example}; \date{July 2013}; \begin{document}; \maketitle; The following image as been generated using the TTeXDump class:; \par; \input{hpx.tex}; \end{document}; ```. Note the two directive needed at the top of the LaTeX file:. ```; \usepackage{tikz}; \usetikzlibrary{patterns}; ```. Then including the picture in the document is done with the; `\input` directive. The command `pdflatex simple.tex` will generate the corresponding pdf; file `simple.pdf`. ### X11 fonts. - A coverity fix in `Rotated.cxx` had a side effect on rotated text; drawn with X11 fonts. ### TCanvas and TPad. - `TPad::SaveAs` produces named macros in .C files.; - Change the way the string input is done in the Pad toolbar for text; and Pave Label. It doesn't use anymore the `TGX11` function `RequestString`.; Now the text appears directly as it will show and it is possible to; enter several text string. The input is not block in the `RequestString` event loop.; - The toolbar methods now work without XOR mode (useful for OpenGL()).; - A new ""vertex compression"" algorithm added to deal with complex histograms; (thousands/millions of bins - polygons with thousands/millions of vertices) -; optimization/fix for X11 crashes. ### TGaxis and TAxis. - The time axis behavior should now be correct along time zone and; summer saving time. A fix has been done with the of Philippe Gras; (CEA Saclay. IRFU/S",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/doc/v600/index.md:1730,simpl,simple,1730,graf2d/doc/v600/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/doc/v600/index.md,1,['simpl'],['simple']
Usability,"lueType`` register type values that are; defined in ``include/llvm/CodeGen/ValueTypes.td``. Defined values include; integer types (such as ``i16``, ``i32``, and ``i1`` for Boolean),; floating-point types (``f32``, ``f64``), and vector types (for example,; ``v8i16`` for an ``8 x i16`` vector). All registers in a ``RegisterClass``; must have the same ``ValueType``, but some registers may store vector data in; different configurations. For example a register that can process a 128-bit; vector may be able to handle 16 8-bit integer elements, 8 16-bit integers, 4; 32-bit integers, and so on. * The third argument of the ``RegisterClass`` definition specifies the; alignment required of the registers when they are stored or loaded to; memory. * The final argument, ``regList``, specifies which registers are in this class.; If an alternative allocation order method is not specified, then ``regList``; also defines the order of allocation used by the register allocator. Besides; simply listing registers with ``(add R0, R1, ...)``, more advanced set; operators are available. See ``include/llvm/Target/Target.td`` for more; information. In ``SparcRegisterInfo.td``, three ``RegisterClass`` objects are defined:; ``FPRegs``, ``DFPRegs``, and ``IntRegs``. For all three register classes, the; first argument defines the namespace with the string ""``SP``"". ``FPRegs``; defines a group of 32 single-precision floating-point registers (``F0`` to; ``F31``); ``DFPRegs`` defines a group of 16 double-precision registers; (``D0-D15``). .. code-block:: text. // F0, F1, F2, ..., F31; def FPRegs : RegisterClass<""SP"", [f32], 32, (sequence ""F%u"", 0, 31)>;. def DFPRegs : RegisterClass<""SP"", [f64], 64,; (add D0, D1, D2, D3, D4, D5, D6, D7, D8,; D9, D10, D11, D12, D13, D14, D15)>;. def IntRegs : RegisterClass<""SP"", [i32], 32,; (add L0, L1, L2, L3, L4, L5, L6, L7,; I0, I1, I2, I3, I4, I5,; O0, O1, O2, O3, O4, O5, O7,; G1,; // Non-allocatable regs:; G2, G3, G4,; O6, // stack ptr; I6, // frame ptr; I7, // r",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/WritingAnLLVMBackend.rst:22599,simpl,simply,22599,interpreter/llvm-project/llvm/docs/WritingAnLLVMBackend.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/WritingAnLLVMBackend.rst,1,['simpl'],['simply']
Usability,"ly 3 sessions. Additional requests are queued; and run as soon as one of the running; sessions goes idle. The current policy is FIFO, so that there is a; rotation among queued; sessions. In the case of load-based worker assignment, the max number; of running; queries is determined dynamically.; Add support for repeat functionality in the xrd.worker; directive. To avoid repeating the same line N times; one can just add; 'repeat=N'; in the line; for; example;            ;     xpd.worker worker; proofwrks:2093 repeat=4; will define 4 workers on port 2093 of machine 'proofwrks'.; Add support for port specification via the directive; 'xpd.port'; Enable variable; substitution in 'xpd.' directives using the standard; Scalla mechanism described in; http://xrootd.slac.stanford.edu/doc/dev/Syntax_config.htm .; Build also a binary named 'xproofd' which runs; a xrootd; daemon with only the XrdProofdProtocol (i.e. no data serving).; This simplifies setups when data serving is not needed and also allows; to better disantagle problems related to one specific protocol. The new; binary accepts the same arguments as 'xrootd' and parses the same; directives form the same configuration file, with the exception of; 'xpd.protocol xproofd libXrdProofd.so' which should now be dropped. AN; alternative port can be specified via the new 'xpd.port' directive (see; above).; Add support for 'MasterOnly' mode in starting a PROOF; session. This avoids starting the workers when one wants just to browse; the datasets or retrieve results. To start a session in 'MasterOnly'; mode enter ""masteronly""; as second argument to TProof::Open, e.g.;  ;          root[]; TProof *p = TProof::Open(""<masterurl>"", ""masteronly""); Add full support for placeholders; <uid>,; <gid>, <group> and <homedir>; for the directives specified via 'xpd.putenv'; Add the configuration directive 'proofservparents' to; allow specifying a different list of parent names for the 'proofserv'; tasks. This is needed to avoid untimely killing",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/doc/v524/index.html:1591,simpl,simplifies,1591,proof/doc/v524/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/doc/v524/index.html,1,['simpl'],['simplifies']
Usability,"ly acceptable course of action.; * Negatively affect development of core tier code, with the sub-community; involved responsible for making changes to address specific concerns.; * Negatively affect other peripheral tier code, with the sub-communities; involved tasked to resolve the issues, still making sure the solution doesn't; break or invalidate the core tier.; * Impose sub-optimal implementation strategies on core tier components as a; result of idiosyncrasies in the peripheral component.; * Have build infrastructure that spams all developers about their breakages.; * Fall into disrepair. This is a reflection of lack of an active sub-community; and will result in removal. Code in this tier should:; * Have infrastructure to test, whenever meaningful, with either no warnings or; notification contained within the sub-community.; * Have support and testing that scales with the complexity and resilience of; the component, with the bar for simple and gracefully-degrading components; (such as editor bindings) much lower than for complex components that must; remain fresh with HEAD (such as experimental back-ends or alternative build; systems).; * Have a document making clear the status of implementation, level of support; available, who the sub-community is and, if applicable, roadmap for inclusion; into the core tier.; * Be restricted to a specific directory or have a consistent pattern (ex.; unique file suffix), making it easy to remove when necessary. Inclusion Policy; ================. To add a new peripheral component, send an RFC to the appropriate dev list; proposing its addition and explaining how it will meet the support requirements; listed above. Different types of components could require different levels of; detail. when in doubt, ask the community what's the best approach. Inclusion must reach consensus in the RFC by the community and the approval of; the corresponding review (by multiple members of the community) is the official; note of acceptance. Aft",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SupportPolicy.rst:6144,simpl,simple,6144,interpreter/llvm-project/llvm/docs/SupportPolicy.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SupportPolicy.rst,1,['simpl'],['simple']
Usability,"ly allows it via; the ``lib/Support`` interface. Use Standard C Headers; ----------------------. The **standard** C headers (the ones beginning with ""c"") are allowed to be; exposed through the ``lib/Support`` interface. These headers and the things they; declare are considered to be platform agnostic. LLVM source files may include; them directly or obtain their inclusion through ``lib/Support`` interfaces. Use Standard C++ Headers; ------------------------. The **standard** C++ headers from the standard C++ library and standard; template library may be exposed through the ``lib/Support`` interface. These; headers and the things they declare are considered to be platform agnostic.; LLVM source files may include them or obtain their inclusion through; ``lib/Support`` interfaces. High Level Interface; --------------------. The entry points specified in the interface of ``lib/Support`` must be aimed at; completing some reasonably high level task needed by LLVM. We do not want to; simply wrap each operating system call. It would be preferable to wrap several; operating system calls that are always used in conjunction with one another by; LLVM. For example, consider what is needed to execute a program, wait for it to; complete, and return its result code. On Unix, this involves the following; operating system calls: ``getenv``, ``fork``, ``execve``, and ``wait``. The; correct thing for ``lib/Support`` to provide is a function, say; ``ExecuteProgramAndWait``, that implements the functionality completely. what; we don't want is wrappers for the operating system calls involved. There must **not** be a one-to-one relationship between operating system; calls and the Support library's interface. Any such interface function will be; suspicious. No Unused Functionality; -----------------------. There must be no functionality specified in the interface of ``lib/Support``; that isn't actually used by LLVM. We're not writing a general purpose operating; system wrapper here, just enou",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SupportLibrary.rst:4099,simpl,simply,4099,interpreter/llvm-project/llvm/docs/SupportLibrary.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SupportLibrary.rst,1,['simpl'],['simply']
Usability,"ly styled function createIntegral running integrals and c.d.f. can be created; over any number of observables, e.g createCdf(RooArgSet(x,y,z)) will create a three-dimensional; cumulative distribution function. C.d.f and running integrals that are calculated from p.d.fs that have; support for analytical integration are constructed from an appropriately reconnected RooRealIntegral.; If numeric integration is required, the c.d.f or running integral is calculated by a dedicated class; RooRunningIntegral that precalculates results for all observable values, which is more efficient; in most use cases. Cumulative distributions functions that are calculated numerically are handled slightly differently; that standard running integrals: their values is constructed to converge to exactly zero at the lower bound; and exactly 1 at the upper bound so that algorithms that make use of that property of c.d.f can do so reliably. Constraints management. New tools have been added to simplify studies with fits involving (external) constraints on parameters.; The general philosophy is that constraints on parameters can be represented as probability density functions; and can thus be modeled by RooAbsPdf classes (e.g. a RooGaussian for a simple Gaussian constraint on a parameter).; There are two modes of operation: you can add parameter constraints to your problem definition by multiplying; the constraint p.d.f.s with your 'master' p.d.f. or you specify them externally in each operation. The; first mode of operation keeps all information in your master p.d.f and may make the logistics of non-trivial; fitting problems easier. It works as follows: first you define your regular p.d.f, then you define your; constraint p.d.f and you multiply them with RooProdPdf. // Construct constraint; RooGaussian fconstraint(""fconstraint"",""fconstraint"",f,RooConst(0.8),RooConst(0.1)) ;. // Multiply constraint with p.d.f; RooProdPdf pdfc(""pdfc"",""p.d.f with constraint"",RooArgSet(p.d.f,fconstraint)) ;. If your ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v520/index.html:6632,simpl,simplify,6632,roofit/doc/v520/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v520/index.html,1,['simpl'],['simplify']
Usability,"ly these entries / subentries are used to fill histograms. About the class . The class derives from TEntryList and can be used basically in the same way. This same class is used to keep entries and subentries, so there are two types of TEntryListArray's:. The ones that only hold subentries; fEntry is set to the entry# for which the subentries correspond; fSubLists must be 0; The ones that hold entries and eventually lists with subentries in fSubLists.; fEntry = -1 for those; If there are no sublists for a given entry, all the subentries will be used in the selection. Additions with respect to TEntryList ; Data members:; fSubLists: a container to hold the sublists; fEntry: the entry number if the list is used to hold subentries; fLastSubListQueried and fSubListIter: a pointer to the last sublist queried and an iterator to resume the loop from the last sublist queried (to speed up selection and insertion in TTree::Draw); Public methods:; Contains, Enter and Remove with subentry as argument; GetSubListForEntry: to return the sublist corresponding to the given entry; Protected methods:; AddEntriesAndSubLists: called by Add when adding two TEntryList arrays with sublists; ConvertToTEntryListArray: convert TEntryList to TEntryListArray; RemoveSubList: to remove the given sublist; RemoveSubListForEntry: to remove the sublist corresponding to the given entry; SetEntry: to get / set a sublist for the given entry. Others changes. Reduced the memory used by a TTree in half by refactoring the code reading and writing the TBasket data;; A single transient buffer holding the compressed data is now managed by TTree (and could be made thread local); rather than having one per TBranch. Updated TBranchElement::Unroll to no longer split a base class; that can not be split (i.e. respect the information returned; by TStreamerElement::CannotSplit (and thus TClass::CanSplit). This disabling is currently _not_ done automatically for backward compatibility reasons and because; ; Without TCl",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/doc/v532/index.html:1684,resume,resume,1684,tree/doc/v532/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/doc/v532/index.html,1,['resume'],['resume']
Usability,"m is ill-formed, because the result of reading an element; is always an Objective-C object pointer and no binary operators are; legal on such pointers. If the expression appears in any other position,; the element is read as described below. It is an error to take the; address of a subscript expression, or (in C++) to bind a reference to; it. Programs can use object subscripting with Objective-C object pointers of; type ``id``. Normal dynamic message send rules apply; the compiler must; see *some* declaration of the subscripting methods, and will pick the; declaration seen first. Caveats; =======. Objects created using the literal or boxed expression syntax are not; guaranteed to be uniqued by the runtime, but nor are they guaranteed to; be newly-allocated. As such, the result of performing direct comparisons; against the location of an object literal (using ``==``, ``!=``, ``<``,; ``<=``, ``>``, or ``>=``) is not well-defined. This is usually a simple; mistake in code that intended to call the ``isEqual:`` method (or the; ``compare:`` method). This caveat applies to compile-time string literals as well.; Historically, string literals (using the ``@""...""`` syntax) have been; uniqued across translation units during linking. This is an; implementation detail of the compiler and should not be relied upon. If; you are using such code, please use global string constants instead; (``NSString * const MyConst = @""...""``) or use ``isEqual:``. Grammar Additions; =================. To support the new syntax described above, the Objective-C; ``@``-expression grammar has the following new productions:. ::. objc-at-expression : '@' (string-literal | encode-literal | selector-literal | protocol-literal | object-literal); ;. object-literal : ('+' | '-')? numeric-constant; | character-constant; | boolean-constant; | array-literal; | dictionary-literal; ;. boolean-constant : '__objc_yes' | '__objc_no' | 'true' | 'false' /* boolean keywords. */; ;. array-literal : '[' assignment-expres",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ObjectiveCLiterals.rst:17435,simpl,simple,17435,interpreter/llvm-project/clang/docs/ObjectiveCLiterals.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ObjectiveCLiterals.rst,1,['simpl'],['simple']
Usability,"m/ADT/Twine.h; ^^^^^^^^^^^^^^^^. The Twine class is used as an intermediary datatype for APIs that want to take a; string that can be constructed inline with a series of concatenations. Twine; works by forming recursive instances of the Twine datatype (a simple value; object) on the stack as temporary objects, linking them together into a tree; which is then linearized when the Twine is consumed. Twine is only safe to use; as the argument to a function, and should always be a const reference, e.g.:. .. code-block:: c++. void foo(const Twine &T);; ...; StringRef X = ...; unsigned i = ...; foo(X + ""."" + Twine(i));. This example forms a string like ""blarg.42"" by concatenating the values; together, and does not form intermediate strings containing ""blarg"" or ""blarg."". Because Twine is constructed with temporary objects on the stack, and because; these instances are destroyed at the end of the current statement, it is an; inherently dangerous API. For example, this simple variant contains undefined; behavior and will probably crash:. .. code-block:: c++. void foo(const Twine &T);; ...; StringRef X = ...; unsigned i = ...; const Twine &Tmp = X + ""."" + Twine(i);; foo(Tmp);. ... because the temporaries are destroyed before the call. That said, Twine's; are much more efficient than intermediate std::string temporaries, and they work; really well with StringRef. Just be aware of their limitations. .. _dss_smallstring:. llvm/ADT/SmallString.h; ^^^^^^^^^^^^^^^^^^^^^^. SmallString is a subclass of :ref:`SmallVector <dss_smallvector>` that adds some; convenience APIs like += that takes StringRef's. SmallString avoids allocating; memory in the case when the preallocated space is enough to hold its data, and; it calls back to general heap allocation when required. Since it owns its data,; it is very safe to use and supports full mutation of the string. Like SmallVector's, the big downside to SmallString is their sizeof. While they; are optimized for small strings, they themselves a",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:74526,simpl,simple,74526,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,1,['simpl'],['simple']
Usability,"m/civetweb/civetweb/blob/master/docs/Building.md) - Building the Server (quick start guide); - [docs/Embedding.md](https://github.com/civetweb/civetweb/blob/master/docs/Embedding.md) - Embedding (how to add HTTP support to an existing application); - [docs/OpenSSL.md](https://github.com/civetweb/civetweb/blob/master/docs/OpenSSL.md) - Adding HTTPS (SSL/TLS) support using OpenSSL.; - [API documentation](https://github.com/civetweb/civetweb/tree/master/docs/api) - Additional documentation on the civetweb application programming interface ([civetweb.h](https://github.com/civetweb/civetweb/blob/master/include/civetweb.h)).; - [RELEASE_NOTES.md](https://github.com/civetweb/civetweb/blob/master/RELEASE_NOTES.md) - Release Notes; - [SECURITY.md](https://github.com/civetweb/civetweb/blob/master/SECURITY.md) - Security Policy; - [LICENSE.md](https://github.com/civetweb/civetweb/blob/master/LICENSE.md) - Copyright License. Overview; --------. CivetWeb keeps the balance between functionality and; simplicity by a carefully selected list of features:. - Liberal, commercial-friendly, permissive,; [MIT license](http://en.wikipedia.org/wiki/MIT_License); - Free from copy-left licenses, like GPL, because you should innovate without; restrictions.; - Forked from [Mongoose](https://code.google.com/p/mongoose/) in 2013, before; it changed the licence from MIT to commercial + GPL. A lot of enhancements; have been added since that time, see; [RELEASE_NOTES.md](https://github.com/civetweb/civetweb/blob/master/RELEASE_NOTES.md).; - Works on Windows, Mac, Linux, UNIX, iPhone, Android, Buildroot, and many; other platforms.; - Scripting and database support (CGI, SQLite database, Lua Server Pages,; Server side Lua scripts, Server side JavaScript).; This provides a ready to go, powerful web development platform in a one; single-click executable with **no dependencies**.0; - Support for CGI, SSI, HTTP digest (MD5) authorization, WebSocket,; WebDAV.; - HTTPS (SSL/TLS) support using [OpenSSL](htt",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/http/civetweb/README.md:5222,simpl,simplicity,5222,net/http/civetweb/README.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/http/civetweb/README.md,1,['simpl'],['simplicity']
Usability,"main source file. For example, if you misuse a C++ function declared in a header the primary diagnostic will be in the caller (in the main source file). The full expanded path, however, will show the bug in the header code as well. These kind of cross-file issues are currently only support by Xcode, not the HTML output.; This build is built with LLVM's Link-Time Optimization (LTO), which should make it slightly faster.; LTO also reduces the download size (about 19% smaller than checker-274).; Many sundry fixes. checker-274; built: April 23, 2013; download: checker-274.tar.bz2; highlights:. Improved use-after-free and mismatched deallocator checking.; Diagnostic polish.; Fixes crashes found in checker-273. checker-273; built: April 8, 2013; download: checker-273.tar.bz2; highlights:. Additional checks for misuse of Foundation collection APIs.; New C++ checker for attempting to create a reference to null.; New use-after-free checker for C++ 'delete'.; New checker for simple cases of mismatched allocators and deallocators, e.g. ""delete malloc(4);""; Support for basic interprocedural analysis of C++ destructors.; Additional heuristics for suppressing null pointer false positives.; Misc. bug fixes and performance enhancements. checker-272; built: March 1, 2013; highlights:. Better modeling of C++ constructors:; ; Interprocedural analysis support for constructors of types with trivial destructors; Efficient model of trivial copy and move constructors. Better diagnostics for loops that execute 0 times; Fixes a linking issue that prevented the checker from running on OS X v10.6 and earlier; Fixes for misc. crashes and false positives. checker-271; built: February 8, 2013; highlights:. Faster analysis for scan-build xcodebuild when using Xcode 4.6 and higher:; ; scan-build now uses Xcode's built-in interposition mechanism for the static analyzer to provide faster builds while doing static analysis (PCH files are now built).; This change also allows scan-build to have better s",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/release_notes.html:4870,simpl,simple,4870,interpreter/llvm-project/clang/www/analyzer/release_notes.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/release_notes.html,1,['simpl'],['simple']
Usability,"main() {; entry:; call void @print(i32 4); call void @print(i32 5); call void @print(i32 6); ret i32 0; }. Multiple Suspend Points; -----------------------. Let's consider the coroutine that has more than one suspend point:. .. code-block:: c++. void *f(int n) {; for(;;) {; print(n++);; <suspend>; print(-n);; <suspend>; }; }. Matching LLVM code would look like (with the rest of the code remaining the same; as the code in the previous section):. .. code-block:: llvm. loop:; %n.addr = phi i32 [ %n, %entry ], [ %inc, %loop.resume ]; call void @print(i32 %n.addr) #4; %2 = call i8 @llvm.coro.suspend(token none, i1 false); switch i8 %2, label %suspend [i8 0, label %loop.resume; i8 1, label %cleanup]; loop.resume:; %inc = add nsw i32 %n.addr, 1; %sub = xor i32 %n.addr, -1; call void @print(i32 %sub); %3 = call i8 @llvm.coro.suspend(token none, i1 false); switch i8 %3, label %suspend [i8 0, label %loop; i8 1, label %cleanup]. In this case, the coroutine frame would include a suspend index that will; indicate at which suspend point the coroutine needs to resume. .. code-block:: llvm. %f.frame = type { ptr, ptr, i32, i32 }. The resume function will use an index to jump to an appropriate basic block and will look; as follows:. .. code-block:: llvm. define internal fastcc void @f.Resume(ptr %FramePtr) {; entry.Resume:; %index.addr = getelementptr inbounds %f.Frame, ptr %FramePtr, i64 0, i32 2; %index = load i8, ptr %index.addr, align 1; %switch = icmp eq i8 %index, 0; %n.addr = getelementptr inbounds %f.Frame, ptr %FramePtr, i64 0, i32 3; %n = load i32, ptr %n.addr, align 4. br i1 %switch, label %loop.resume, label %loop. loop.resume:; %sub = sub nsw i32 0, %n; call void @print(i32 %sub); br label %suspend; loop:; %inc = add nsw i32 %n, 1; store i32 %inc, ptr %n.addr, align 4; tail call void @print(i32 %inc); br label %suspend. suspend:; %storemerge = phi i8 [ 0, %loop ], [ 1, %loop.resume ]; store i8 %storemerge, ptr %index.addr, align 1; ret void; }. If different cleanup code",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst:18922,resume,resume,18922,interpreter/llvm-project/llvm/docs/Coroutines.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst,1,['resume'],['resume']
Usability,"make an R?"". ***`A:`*** Well, in real life some objects have much more complex shapes; that an ***`R`***. The modeller cannot just know all of them; the idea; is to make a complex object by using elementary building blocks that; have known shapes (called ***`primitive shapes`***). Gluing these; together in the appropriate way is the user responsibility. ***`Q:`*** ""I am getting the global picture but not making much out of it... There; are also a lot of calls to TGeoVolume::AddNode() that I do not understand."". ***`A:`*** A volume is positioned inside another one by using this; method. The relative geometrical transformation as well as a copy number; must be specified. When positioned, a volume becomes a ***`node`*** of; its container and a new object of the class **`TGeoNode`** is; automatically created. This method is therefore the key element for the; creation of a hierarchical link between two volumes. As it will be; described further on in this document, there are few other methods; performing similar actions, but let us keep things simple for the time; being. In addition, notice that there are some visualization-related; calls in the example followed by a final `TGeoVolume::Draw() `call for; the top volume. These are explained in details in the section; ""Visualization Settings and Attributes"". At this point, you will; probably like to see how this geometry looks like. You just need to run; the example and you will get the following picture that you can rotate; using the mouse; or you can zoom / move it around (see what the Help; menu of the GL window displays). ``` {.cpp}; % root rootgeom.C; ```. ![](pictures/020001B1.jpg). Now let us browse the hierarchy that was just created. Start a browser; and double-click on the item simple1 representing the; ***`gGeoManager`*** object. Note that right click opens the context menu; of the manager class where several global methods are available. ``` {.cpp}; root[] new TBrowser;; ```. ![](pictures/020001B2.jpg). The folde",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:8112,simpl,simple,8112,documentation/users-guide/Geometry.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md,1,['simpl'],['simple']
Usability,"maller; changes increases the odds that any of the work will be committed to the main; repository. To address these problems, LLVM uses an incremental development style and we; require contributors to follow this practice when making a large/invasive; change. Some tips:. * Large/invasive changes usually have a number of secondary changes that are; required before the big change can be made (e.g. API cleanup, etc). These; sorts of changes can often be done before the major change is done,; independently of that work. * The remaining inter-related work should be decomposed into unrelated sets of; changes if possible. Once this is done, define the first increment and get; consensus on what the end goal of the change is. * Each change in the set can be stand alone (e.g. to fix a bug), or part of a; planned series of changes that works towards the development goal. * Each change should be kept as small as possible. This simplifies your work; (into a logical progression), simplifies code review and reduces the chance; that you will get negative feedback on the change. Small increments also; facilitate the maintenance of a high quality code base. * Often, an independent precursor to a big change is to add a new API and slowly; migrate clients to use the new API. Each change to use the new API is often; ""obvious"" and can be committed without review. Once the new API is in place; and used, it is much easier to replace the underlying implementation of the; API. This implementation change is logically separate from the API; change. If you are interested in making a large change, and this scares you, please make; sure to first `discuss the change/gather consensus`_ then ask about the best way; to go about making the change. Attribution of Changes; ----------------------. When contributors submit a patch to an LLVM project, other developers with; commit access may commit it for the author once appropriate (based on the; progression of code review, etc.). When doing so, it is impo",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/DeveloperPolicy.rst:28779,simpl,simplifies,28779,interpreter/llvm-project/llvm/docs/DeveloperPolicy.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/DeveloperPolicy.rst,3,"['feedback', 'simpl']","['feedback', 'simplifies']"
Usability,"mat::reformat(...)`` functions, the format is specified; by supplying the `clang::format::FormatStyle; <https://clang.llvm.org/doxygen/structclang_1_1format_1_1FormatStyle.html>`_; structure. Configurable Format Style Options; =================================. This section lists the supported style options. Value type is specified for; each option. For enumeration types possible values are specified both as a C++; enumeration member (with a prefix, e.g. ``LS_Auto``), and as a value usable in; the configuration (without a prefix: ``Auto``). .. _BasedOnStyle:. **BasedOnStyle** (``String``) :ref:`¶ <BasedOnStyle>`; The style used for all options not specifically set in the configuration. This option is supported only in the :program:`clang-format` configuration; (both within ``-style='{...}'`` and the ``.clang-format`` file). Possible values:. * ``LLVM``; A style complying with the `LLVM coding standards; <https://llvm.org/docs/CodingStandards.html>`_; * ``Google``; A style complying with `Google's C++ style guide; <https://google.github.io/styleguide/cppguide.html>`_; * ``Chromium``; A style complying with `Chromium's style guide; <https://chromium.googlesource.com/chromium/src/+/refs/heads/main/styleguide/styleguide.md>`_; * ``Mozilla``; A style complying with `Mozilla's style guide; <https://firefox-source-docs.mozilla.org/code-quality/coding-style/index.html>`_; * ``WebKit``; A style complying with `WebKit's style guide; <https://www.webkit.org/coding/coding-style.html>`_; * ``Microsoft``; A style complying with `Microsoft's style guide; <https://docs.microsoft.com/en-us/visualstudio/ide/editorconfig-code-style-settings-reference>`_; * ``GNU``; A style complying with the `GNU coding standards; <https://www.gnu.org/prep/standards/standards.html>`_; * ``InheritParentConfig``; Not a real style, but allows to use the ``.clang-format`` file from the; parent directory (or its parent if there is none). If there is no parent; file found it falls back to the ``fallback`` st",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:5532,guid,guide,5532,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,1,['guid'],['guide']
Usability,"mber = @true; // equivalent to [NSNumber numberWithBool:(BOOL)true]; NSNumber *falseNumber = @false; // equivalent to [NSNumber numberWithBool:(BOOL)false]; #endif; }. Discussion; ----------. NSNumber literals only support literal scalar values after the ``'@'``.; Consequently, ``@INT_MAX`` works, but ``@INT_MIN`` does not, because; they are defined like this:. .. code-block:: objc. #define INT_MAX 2147483647 /* max value for an int */; #define INT_MIN (-2147483647-1) /* min value for an int */. The definition of ``INT_MIN`` is not a simple literal, but a; parenthesized expression. Parenthesized expressions are supported using; the `boxed expression <#objc_boxed_expressions>`_ syntax, which is; described in the next section. Because ``NSNumber`` does not currently support wrapping ``long double``; values, the use of a ``long double NSNumber`` literal (e.g.; ``@123.23L``) will be rejected by the compiler. Previously, the ``BOOL`` type was simply a typedef for ``signed char``,; and ``YES`` and ``NO`` were macros that expand to ``(BOOL)1`` and; ``(BOOL)0`` respectively. To support ``@YES`` and ``@NO`` expressions,; these macros are now defined using new language keywords in; ``<objc/objc.h>``:. .. code-block:: objc. #if __has_feature(objc_bool); #define YES __objc_yes; #define NO __objc_no; #else; #define YES ((BOOL)1); #define NO ((BOOL)0); #endif. The compiler implicitly converts ``__objc_yes`` and ``__objc_no`` to; ``(BOOL)1`` and ``(BOOL)0``. The keywords are used to disambiguate; ``BOOL`` and integer literals. Objective-C++ also supports ``@true`` and ``@false`` expressions, which; are equivalent to ``@YES`` and ``@NO``. Boxed Expressions; =================. Objective-C provides a new syntax for boxing C expressions:. .. code-block:: objc. @( <expression> ). Expressions of scalar (numeric, enumerated, BOOL), C string pointer; and some C structures (via NSValue) are supported:. .. code-block:: objc. // numbers.; NSNumber *smallestInt = @(-INT_MAX - 1); // [NSNumber",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ObjectiveCLiterals.rst:3483,simpl,simply,3483,interpreter/llvm-project/clang/docs/ObjectiveCLiterals.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ObjectiveCLiterals.rst,1,['simpl'],['simply']
Usability,"mdArgs;; // ... + for (const Arg *A : Args.filtered(OPT_fpass_plugin_EQ)) {; + CmdArgs.push_back(Args.MakeArgString(Twine(""-fpass-plugin="") + A->getValue()));; + A->claim();; + }; }. The last step is implementing the ``-cc1`` command line argument; parsing/generation that initializes/serializes the option class (in our case; ``CodeGenOptions``) stored within ``CompilerInvocation``. This can be done; automatically by using the marshalling annotations on the option definition:. .. code-block:: diff. // Options.td. def fpass_plugin_EQ : Joined<[""-""], ""fpass-plugin="">,; Group<f_Group>, Flags<[CC1Option]>,; HelpText<""Load pass plugin from a dynamic shared object file."">,; + MarshallingInfoStringVector<CodeGenOpts<""PassPlugins"">>;. Inner workings of the system are introduced in the :ref:`marshalling; infrastructure <OptionMarshalling>` section and the available annotations are; listed :ref:`here <OptionMarshallingAnnotations>`. In case the marshalling infrastructure does not support the desired semantics,; consider simplifying it to fit the existing model. This makes the command line; more uniform and reduces the amount of custom, manually written code. Remember; that the ``-cc1`` command line interface is intended only for Clang developers,; meaning it does not need to mirror the driver interface, maintain backward; compatibility or be compatible with GCC. If the option semantics cannot be encoded via marshalling annotations, you can; resort to parsing/serializing the command line arguments manually:. .. code-block:: diff. // CompilerInvocation.cpp. static bool ParseCodeGenArgs(CodeGenOptions &Opts, ArgList &Args /*...*/) {; // ... + Opts.PassPlugins = Args.getAllArgValues(OPT_fpass_plugin_EQ);; }. static void GenerateCodeGenArgs(const CodeGenOptions &Opts,; SmallVectorImpl<const char *> &Args,; CompilerInvocation::StringAllocator SA /*...*/) {; // ... + for (const std::string &PassPlugin : Opts.PassPlugins); + GenerateArg(Args, OPT_fpass_plugin_EQ, PassPlugin, SA);; }. F",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:32566,simpl,simplifying,32566,interpreter/llvm-project/clang/docs/InternalsManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst,1,['simpl'],['simplifying']
Usability,"mdat. Instruction Reference; =====================. The LLVM instruction set consists of several different classifications; of instructions: :ref:`terminator instructions <terminators>`, :ref:`binary; instructions <binaryops>`, :ref:`bitwise binary; instructions <bitwiseops>`, :ref:`memory instructions <memoryops>`, and; :ref:`other instructions <otherops>`. .. _terminators:. Terminator Instructions; -----------------------. As mentioned :ref:`previously <functionstructure>`, every basic block in a; program ends with a ""Terminator"" instruction, which indicates which; block should be executed after the current block is finished. These; terminator instructions typically yield a '``void``' value: they produce; control flow, not values (the one exception being the; ':ref:`invoke <i_invoke>`' instruction). The terminator instructions are: ':ref:`ret <i_ret>`',; ':ref:`br <i_br>`', ':ref:`switch <i_switch>`',; ':ref:`indirectbr <i_indirectbr>`', ':ref:`invoke <i_invoke>`',; ':ref:`callbr <i_callbr>`'; ':ref:`resume <i_resume>`', ':ref:`catchswitch <i_catchswitch>`',; ':ref:`catchret <i_catchret>`',; ':ref:`cleanupret <i_cleanupret>`',; and ':ref:`unreachable <i_unreachable>`'. .. _i_ret:. '``ret``' Instruction; ^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. ret <type> <value> ; Return a value from a non-void function; ret void ; Return from void function. Overview:; """""""""""""""""". The '``ret``' instruction is used to return control flow (and optionally; a value) from a function back to the caller. There are two forms of the '``ret``' instruction: one that returns a; value and then causes control flow, and one that just causes control; flow to occur. Arguments:; """""""""""""""""""". The '``ret``' instruction optionally accepts a single argument, the; return value. The type of the return value must be a ':ref:`first; class <t_firstclass>`' type. A function is not :ref:`well formed <wellformed>` if it has a non-void; return type and contains a '``ret``' instruction with no return value or; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:355210,resume,resume,355210,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['resume'],['resume']
Usability,"me. Here we use the `cl::init`_ option to specify an initial; value for the command line option, which is used if the option is not specified; (if you do not specify a `cl::init`_ modifier for an option, then the default; constructor for the data type is used to initialize the value). Command line; options default to being optional, so if we would like to require that the user; always specify an input filename, we would add the `cl::Required`_ flag, and we; could eliminate the `cl::init`_ modifier, like this:. .. code-block:: c++. cl::opt<string> InputFilename(cl::Positional, cl::desc(""<input file>""), cl::Required);. Again, the CommandLine library does not require the options to be specified in; any particular order, so the above declaration is equivalent to:. .. code-block:: c++. cl::opt<string> InputFilename(cl::Positional, cl::Required, cl::desc(""<input file>""));. By simply adding the `cl::Required`_ flag, the CommandLine library will; automatically issue an error if the argument is not specified, which shifts all; of the command line option verification code out of your application into the; library. This is just one example of how using flags can alter the default; behaviour of the library, on a per-option basis. By adding one of the; declarations above, the ``-help`` option synopsis is now extended to:. ::. USAGE: compiler [options] <input file>. OPTIONS:; -h - Alias for -help; -help - display available options (-help-hidden for more); -o <filename> - Specify output filename. ... indicating that an input filename is expected. Boolean Arguments; -----------------. In addition to input and output filenames, we would like the compiler example to; support three boolean flags: ""``-f``"" to force writing binary output to a; terminal, ""``--quiet``"" to enable quiet mode, and ""``-q``"" for backwards; compatibility with some of our users. We can support these by declaring options; of boolean type like this:. .. code-block:: c++. cl::opt<bool> Force (""f"", cl::desc(""Enable ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandLine.rst:8115,simpl,simply,8115,interpreter/llvm-project/llvm/docs/CommandLine.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandLine.rst,1,['simpl'],['simply']
Usability,"med objects. .. _arc.misc.autoreleasepool:. ``@autoreleasepool``; --------------------. To simplify the use of autorelease pools, and to bring them under the control; of the compiler, a new kind of statement is available in Objective-C. It is; written ``@autoreleasepool`` followed by a *compound-statement*, i.e. by a new; scope delimited by curly braces. Upon entry to this block, the current state; of the autorelease pool is captured. When the block is exited normally,; whether by fallthrough or directed control flow (such as ``return`` or; ``break``), the autorelease pool is restored to the saved state, releasing all; the objects in it. When the block is exited with an exception, the pool is not; drained. ``@autoreleasepool`` may be used in non-ARC translation units, with equivalent; semantics. A program is ill-formed if it refers to the ``NSAutoreleasePool`` class. .. admonition:: Rationale. Autorelease pools are clearly important for the compiler to reason about, but; it is far too much to expect the compiler to accurately reason about control; dependencies between two calls. It is also very easy to accidentally forget; to drain an autorelease pool when using the manual API, and this can; significantly inflate the process's high-water-mark. The introduction of a; new scope is unfortunate but basically required for sane interaction with the; rest of the language. Not draining the pool during an unwind is apparently; required by the Objective-C exceptions implementation. .. _arc.misc.externally_retained:. Externally-Retained Variables; -----------------------------. In some situations, variables with strong ownership are considered; externally-retained by the implementation. This means that the variable is; retained elsewhere, and therefore the implementation can elide retaining and; releasing its value. Such a variable is implicitly ``const`` for safety. In; contrast with ``__unsafe_unretained``, an externally-retained variable still; behaves as a strong variable o",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst:91347,clear,clearly,91347,interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,1,['clear'],['clearly']
Usability,"ment is *only* loaded, then it can pass the value into the function instead; of the address of the value. This can cause recursive simplification of code; and lead to the elimination of allocas (especially in C++ template code like; the STL). This pass also handles aggregate arguments that are passed into a function,; scalarizing them if the elements of the aggregate are only loaded. Note that; it refuses to scalarize aggregates which would require passing in more than; three operands to the function, because passing thousands of operands for a; large array or structure is unprofitable!. Note that this transformation could also be done for arguments that are only; stored to (returning the value instead), but does not currently. This case; would be best handled when and if LLVM starts supporting multiple return values; from functions. ``block-placement``: Profile Guided Basic Block Placement; ---------------------------------------------------------. This pass is a very simple profile guided basic block placement algorithm. The; idea is to put frequently executed blocks together at the start of the function; and hopefully increase the number of fall-through conditional branches. If; there is no profile information for a particular function, this pass basically; orders blocks in depth-first order. ``break-crit-edges``: Break critical edges in CFG; -------------------------------------------------. Break all of the critical edges in the CFG by inserting a dummy basic block.; It may be ""required"" by passes that cannot deal with critical edges. This; transformation obviously invalidates the CFG, but can update forward dominator; (set, immediate dominators, tree, and frontier) information. ``codegenprepare``: Optimize for code generation; ------------------------------------------------. This pass munges the code in the input function to better prepare it for; SelectionDAG-based code generation. This works around limitations in its; basic-block-at-a-time approach. It shoul",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Passes.rst:13658,simpl,simple,13658,interpreter/llvm-project/llvm/docs/Passes.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Passes.rst,2,"['guid', 'simpl']","['guided', 'simple']"
Usability,ments vs the ODR; Unknown. 2368; CD5; Differences in relational and three-way constant comparisons; Unknown. 2369; CD6; Ordering between constraints and substitution; Unknown. 2370; CD6; friend declarations of namespace-scope functions; No. 2371; CD5; Use of the English term “attributes” is confusing; Unknown. 2372; CD5; Incorrect matching rules for block-scope extern declarations; Unknown. 2373; CD5; Incorrect handling of static member function templates in partial ordering; Unknown. 2374; C++20; Overly permissive specification of enum direct-list-initialization; Unknown. 2375; NAD; Multiple redeclarations of constexpr static data members; Unknown. 2376; CD5; Class template argument deduction with array declarator; Unknown. 2377; NAD; Explicit copy constructor vs function viability; Unknown. 2378; C++20; Inconsistent grammar for reference init-capture of pack; Unknown. 2379; CD5; Missing prohibition against constexpr in friend declaration; Unknown. 2380; CD5; capture-default makes too many references odr-usable; Unknown. 2381; CD5; Composite pointer type of pointers to plain and noexcept member functions; Unknown. 2382; CD5; Array allocation overhead for non-allocating placement new; Unknown. 2383; NAD; Variadic member functions of variadic class templates; Unknown. 2384; CD5; Conversion function templates and qualification conversions; Unknown. 2385; CD5; Lookup for conversion-function-ids; N/A. 2386; CD5; tuple_size requirements for structured binding; Clang 9. 2387; CD5; Linkage of const-qualified variable template; Clang 9. 2388; NAD; Applicability of contract-attribute-specifiers; Unknown. 2389; CD6; Agreement of deduced and explicitly-specified variable types; Unknown. 2390; CD5; Is the argument of __has_cpp_attribute macro-expanded?; Clang 14. 2391; dup; Additional template parameters following pack expansion; Unknown. 2392; C++23; new-expression size check and constant evaluation; Unknown. 2393; NAD; Pseudo-destructors and object lifetime; Unknown. 2394; CD,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:162631,usab,usable,162631,interpreter/llvm-project/clang/www/cxx_dr_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html,1,['usab'],['usable']
Usability,"ments, not; an exact sequence of operations that a program will be compiled into. .. _arc.objects.operands:. Retainable object pointers as operands and arguments; ----------------------------------------------------. In general, ARC does not perform retain or release operations when simply using; a retainable object pointer as an operand within an expression. This includes:. * loading a retainable pointer from an object with non-weak :ref:`ownership; <arc.ownership>`,; * passing a retainable pointer as an argument to a function or method, and; * receiving a retainable pointer as the result of a function or method call. .. admonition:: Rationale. While this might seem uncontroversial, it is actually unsafe when multiple; expressions are evaluated in ""parallel"", as with binary operators and calls,; because (for example) one expression might load from an object while another; writes to it. However, C and C++ already call this undefined behavior; because the evaluations are unsequenced, and ARC simply exploits that here to; avoid needing to retain arguments across a large number of calls. The remainder of this section describes exceptions to these rules, how those; exceptions are detected, and what those exceptions imply semantically. .. _arc.objects.operands.consumed:. Consumed parameters; ^^^^^^^^^^^^^^^^^^^. A function or method parameter of retainable object pointer type may be marked; as :arc-term:`consumed`, signifying that the callee expects to take ownership; of a +1 retain count. This is done by adding the ``ns_consumed`` attribute to; the parameter declaration, like so:. .. code-block:: objc. void foo(__attribute((ns_consumed)) id x);; - (void) foo: (id) __attribute((ns_consumed)) x;. This attribute is part of the type of the function or method, not the type of; the parameter. It controls only how the argument is passed and received. When passing such an argument, ARC retains the argument prior to making the; call. When receiving such an argument, ARC releases",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst:16278,simpl,simply,16278,interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,1,['simpl'],['simply']
Usability,"merged in one go. This is to guarantee; that all changes are good as a single block.; 6. After the initial merge, the target community can stop numbering patches and; start working asynchronously on the target to complete support. They should; still seek review from those who helped them in the initial phase, to make; sure the progress is still consistent.; 7. Once all official requirements have been fulfilled (as above), the code owner; should request the target to be enabled by default by sending another RFC to; the `LLVM Discourse forums`_. Adding an Established Project To the LLVM Monorepo; --------------------------------------------------. The `LLVM monorepo <https://github.com/llvm/llvm-project>`_ is the centerpoint; of development in the LLVM world, and has all of the primary LLVM components,; including the LLVM optimizer and code generators, Clang, LLDB, etc. `Monorepos; in general <https://en.wikipedia.org/wiki/Monorepo>`_ are great because they; allow atomic commits to the project, simplify CI, and make it easier for; subcommunities to collaborate. Like new targets, most projects already in the monorepo are considered to be in; the *core tier* of our :doc:`support policy<SupportPolicy>`. The burden to add; things to the LLVM monorepo needs to be very high - code that is added to this; repository is checked out by everyone in the community. As such, we hold; components to a high bar similar to ""official targets"", they:. * Must be generally aligned with the mission of the LLVM project to advance; compilers, languages, tools, runtimes, etc.; * Must conform to all of the policies laid out in this developer policy; document, including license, patent, coding standards, and code of conduct.; * Must have an active community that maintains the code, including established; code owners.; * Should have reasonable documentation about how it works, including a high; quality README file.; * Should have CI to catch breakage within the project itself or due to; underlying",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/DeveloperPolicy.rst:45351,simpl,simplify,45351,interpreter/llvm-project/llvm/docs/DeveloperPolicy.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/DeveloperPolicy.rst,1,['simpl'],['simplify']
Usability,"merging of different page sources into one page sink. This also means that RNTuples can be merged through `hadd`.; - Zero-copy bulk reading has been added, with extra optimizations for `ROOT::RVec` fields.; - It is now possible to use the `RNTupleView` with an external address with type erasure, e.g.:; ```cpp; std::shared_ptr<void> data{new float()};; auto view = reader->GetView(""pt"", data);; ```; This enables use cases such as reading one specific entry of one specific field into a previously allocated memory location.; - Further integration with [RDataFrame](#rdataframe): it is now possible to create RDataFrame for chains of RNTuples. This addition also comes with improvements to the multi-threaded work scheduling.; - Many additional bug fixes and improvements. Please, report any issues regarding the above mentioned features should you encounter them. RNTuple is still in pre-production. The on-disk format is scheduled to be finalized by the end of 2024. Thus, we appreciate feedback and suggestions for improvement. ## Histogram Libraries. - Implement the FLT_MAX mechanism for `THStack::GetMaximum()` and `THStack::GetMiniumum()`.; - Print a warning when the range given to `TAxis::SetRange` is invalid.; - Fix projection name in `TH3` as requested [here](https://root-forum.cern.ch/t/project3d-letter-d-in-name-option/57612). ## Parallelism; - The ROOT::Experimental::TFuture template has been removed. ## RooFit Libraries. ### New CPU likelihood evaluation backend by default. The new vectorizing CPU evaluation backend is not the default for RooFit likelihoods.; Likelihood minimization is now up to 10x faster on a single CPU core. If you experience unexpected problems related to the likelihood evaluation, you; can revert back to the old backend by passing `RooFit::EvalBackend(""legacy"")`; to `RooAbsPdf::fitTo()` or `RooAbsPdf::createNLL()`. In case you observe any slowdowns with the new likelihood evaluation, please; open a GitHub issue about this, as such a performance re",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v632/index.md:6557,feedback,feedback,6557,README/ReleaseNotes/v632/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v632/index.md,1,['feedback'],['feedback']
Usability,"meters. A function can also return an object to a caller by a means of an out parameter; (a pointer-to-OSObject-pointer is passed, and a callee writes a pointer to an; object into an argument).; Currently the analyzer does not track unannotated out; parameters by default, but with annotations we distinguish four separate cases:. 1. Non-retained out parameters, identified using; LIBKERN_RETURNS_NOT_RETAINED applied to parameters, e.g.:. void getterViaOutParam(LIBKERN_RETURNS_NOT_RETAINED OSObject **obj). Such functions write a non-retained object into an out parameter, and the; caller has no further obligations.; 2. Retained out parameters,; identified using LIBKERN_RETURNS_RETAINED:. void getterViaOutParam(LIBKERN_RETURNS_NOT_RETAINED OSObject **obj). In such cases a retained object is written into an out parameter, which the caller has then to release in order to avoid a leak. These two cases are simple - but in practice a functions returning an out-parameter usually also return a return code, and then an out parameter may or may not be written, which conditionally depends on the exit code, e.g.:. bool maybeCreateObject(LIBKERN_RETURNS_RETAINED OSObject **obj);. For such functions, the usual semantics is that an object is written into on ""success"", and not written into on ""failure"".; For LIBKERN_RETURNS_RETAINED we assume the following definition of; success:; For functions returning OSReturn or IOReturn; (any typedef to kern_return_t) success is defined as having an output of zero (kIOReturnSuccess is zero).; For all others, success is non-zero (e.g. non-nullptr for pointers); 3. Retained out parameters on zero return; The annotation LIBKERN_RETURNS_RETAINED_ON_ZERO states; that a retained object is written into if and only if the function returns a zero value:. bool OSUnserializeXML(void *data, LIBKERN_RETURNS_RETAINED_ON_ZERO OSString **errString);. Then the caller has to release an object if the function has returned zero.; 4. Retained out parameters on non-zero",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/annotations.html:18158,simpl,simple,18158,interpreter/llvm-project/clang/www/analyzer/annotations.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/annotations.html,1,['simpl'],['simple']
Usability,"milar to dead instruction elimination, but it; rechecks instructions that were used by removed instructions to see if they; are newly dead. ``deadargelim``: Dead Argument Elimination; ------------------------------------------. This pass deletes dead arguments from internal functions. Dead argument; elimination removes arguments which are directly dead, as well as arguments; only passed into function calls as dead arguments of other functions. This; pass also deletes dead arguments in a similar way. This pass is often useful as a cleanup pass to run after aggressive; interprocedural passes, which add possibly-dead arguments. ``dse``: Dead Store Elimination; -------------------------------. A trivial dead store elimination that only considers basic-block local; redundant stores. .. _passes-function-attrs:. ``function-attrs``: Deduce function attributes; ----------------------------------------------. A simple interprocedural pass which walks the call-graph, looking for functions; which do not access or only read non-local memory, and marking them; ``readnone``/``readonly``. In addition, it marks function arguments (of; pointer type) ""``nocapture``"" if a call to the function does not create any; copies of the pointer value that outlive the call. This more or less means; that the pointer is only dereferenced, and not returned from the function or; stored in a global. This pass is implemented as a bottom-up traversal of the; call-graph. ``globaldce``: Dead Global Elimination; --------------------------------------. This transform is designed to eliminate unreachable internal globals from the; program. It uses an aggressive algorithm, searching out globals that are known; to be alive. After it finds all of the globals which are needed, it deletes; whatever is left over. This allows it to delete recursive chunks of the; program which are unreachable. ``globalopt``: Global Variable Optimizer; ----------------------------------------. This pass transforms simple global varia",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Passes.rst:16076,simpl,simple,16076,interpreter/llvm-project/llvm/docs/Passes.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Passes.rst,1,['simpl'],['simple']
Usability,"mirroring our current SVN; repository.; 3. Add the required bots to implement the commit emails, as well as the; umbrella repository update (if the multirepo is selected) or the read-only; Git views for the sub-projects (if the monorepo is selected). Step #2 : Git Move; ------------------. 4. Update the buildbots to pick up updates and commits from the GitHub; repository. Not all bots have to migrate at this point, but it'll help; provide infrastructure testing.; 5. Update Phabricator to pick up commits from the GitHub repository.; 6. LNT and llvmlab have to be updated: they rely on unique monotonically; increasing integer across branch [MatthewsRevNum]_.; 7. Instruct downstream integrators to pick up commits from the GitHub; repository.; 8. Review and prepare an update for the LLVM documentation. Until this point nothing has changed for developers, it will just; boil down to a lot of work for buildbot and other infrastructure; owners. The migration will pause here until all dependencies have cleared, and all; problems have been solved. Step #3: Write Access Move; --------------------------. 9. Collect developers' GitHub account information, and add them to the project.; 10. Switch the SVN repository to read-only and allow pushes to the GitHub repository.; 11. Update the documentation.; 12. Mirror Git to SVN. Step #4 : Post Move; -------------------. 13. Archive the SVN repository.; 14. Update links on the LLVM website pointing to viewvc/klaus/phab etc. to; point to GitHub instead. GitHub Repository Description; =============================. Monorepo; ----------------. The LLVM git repository hosted at https://github.com/llvm/llvm-project contains all; sub-projects in a single source tree. It is often referred to as a monorepo and; mimics an export of the current SVN repository, with each sub-project having its; own top-level directory. Not all sub-projects are used for building toolchains.; For example, www/ and test-suite/ are not part of the monorepo. Putting all",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Proposals/GitHubMove.rst:7800,pause,pause,7800,interpreter/llvm-project/llvm/docs/Proposals/GitHubMove.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Proposals/GitHubMove.rst,2,"['clear', 'pause']","['cleared', 'pause']"
Usability,"mized with ""clang -emit-llvm-bc | opt -O3"". //===---------------------------------------------------------------------===//. int f(int i, int j) { return i < j + 1; }; int g(int i, int j) { return j > i - 1; }; Should combine to ""i <= j"" (the add/sub has nsw). Currently not; optimized with ""clang -emit-llvm-bc | opt -O3"". //===---------------------------------------------------------------------===//. unsigned f(unsigned x) { return ((x & 7) + 1) & 15; }; The & 15 part should be optimized away, it doesn't change the result. Currently; not optimized with ""clang -emit-llvm-bc | opt -O3"". //===---------------------------------------------------------------------===//. This was noticed in the entryblock for grokdeclarator in 403.gcc:. %tmp = icmp eq i32 %decl_context, 4 ; %decl_context_addr.0 = select i1 %tmp, i32 3, i32 %decl_context ; %tmp1 = icmp eq i32 %decl_context_addr.0, 1 ; %decl_context_addr.1 = select i1 %tmp1, i32 0, i32 %decl_context_addr.0. tmp1 should be simplified to something like:; (!tmp || decl_context == 1). This allows recursive simplifications, tmp1 is used all over the place in; the function, e.g. by:. %tmp23 = icmp eq i32 %decl_context_addr.1, 0 ; <i1> [#uses=1]; %tmp24 = xor i1 %tmp1, true ; <i1> [#uses=1]; %or.cond8 = and i1 %tmp23, %tmp24 ; <i1> [#uses=1]. later. //===---------------------------------------------------------------------===//. [STORE SINKING]. Store sinking: This code:. void f (int n, int *cond, int *res) {; int i;; *res = 0;; for (i = 0; i < n; i++); if (*cond); *res ^= 234; /* (*) */; }. On this function GVN hoists the fully redundant value of *res, but nothing; moves the store out. This gives us this code:. bb:		; preds = %bb2, %entry; 	%.rle = phi i32 [ 0, %entry ], [ %.rle6, %bb2 ]	; 	%i.05 = phi i32 [ 0, %entry ], [ %indvar.next, %bb2 ]; 	%1 = load i32* %cond, align 4; 	%2 = icmp eq i32 %1, 0; 	br i1 %2, label %bb2, label %bb1. bb1:		; preds = %bb; 	%3 = xor i32 %.rle, 234	; 	store i32 %3, i32* %res, align 4; 	br label %bb2",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/README.txt:27969,simpl,simplified,27969,interpreter/llvm-project/llvm/lib/Target/README.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/README.txt,1,['simpl'],['simplified']
Usability,"mmandLine library, this is represented like; this:. .. _scalars arguments:; .. _here:. .. code-block:: c++. cl::opt<string> OutputFilename(""o"", cl::desc(""Specify output filename""), cl::value_desc(""filename""));. This declares a global variable ""``OutputFilename``"" that is used to capture the; result of the ""``o``"" argument (first parameter). We specify that this is a; simple scalar option by using the ""``cl::opt``"" template (as opposed to the; ""``cl::list``"" template), and tell the CommandLine library that the data; type that we are parsing is a string. The second and third parameters (which are optional) are used to specify what to; output for the ""``-help``"" option. In this case, we get a line that looks like; this:. ::. USAGE: compiler [options]. OPTIONS:; -h - Alias for -help; -help - display available options (-help-hidden for more); -o <filename> - Specify output filename. Because we specified that the command line option should parse using the; ``string`` data type, the variable declared is automatically usable as a real; string in all contexts that a normal C++ string object may be used. For; example:. .. code-block:: c++. ...; std::ofstream Output(OutputFilename.c_str());; if (Output.good()) ...; ... There are many different options that you can use to customize the command line; option handling library, but the above example shows the general interface to; these options. The options can be specified in any order, and are specified; with helper functions like `cl::desc(...)`_, so there are no positional; dependencies to remember. The available options are discussed in detail in the; `Reference Guide`_. Continuing the example, we would like to have our compiler take an input; filename as well as an output filename, but we do not want the input filename to; be specified with a hyphen (ie, not ``-filename.c``). To support this style of; argument, the CommandLine library allows for `positional`_ arguments to be; specified for the program. These positional argumen",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandLine.rst:5942,usab,usable,5942,interpreter/llvm-project/llvm/docs/CommandLine.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandLine.rst,1,['usab'],['usable']
Usability,"mnemonics `Alt+D`, `Alt+E` for their; selection. The letter D and E appear underlined on the screen. All text; buttons should have a unique shortcut key with the exception of OK and; Cancel. These buttons are usually placed within a window to provide fast access; to frequently used or critical commands. They help in situations where a; command is not available through the menu bar. You already know that a; command string can be passed in the text button via the constructor:. ``` {.cpp}; TGTextButton(const TGWindow *p, const char *s, const char *cmd,; Int_t id, GContext_t norm, FontStruct_t font,; UInt_t options);; ```. A button label can be changed by `SetText(new_label).` There are; important guidelines to be followed about a button label. The text has; to provide a meaningful description of the performed action. The; single-word label should be used whenever possible, only two-three words; for clarity, if necessary. Do not number labels. Always follow all; platform presentation and usage guidelines for standard button; functions. Let's remember a few standard names and definitions of well; known buttons:. ***`OK`*** - any changed information in a window is accepted and the; window is closed;. ***`Cancel`*** - closes window without implementing submitted changes;. ***`Reset `***- resets defaults and cancels any changed information that; has not be submitted;. ***`Apply`*** - any changed information is accepted and again displayed; in the window that remains open;. ***`Close`*** - closes the window;. ***`Help`*** - opens online Help. Below are examples of text buttons. Note the two placement methods. The; first example should be used when there are one to three command; buttons; the second one when there are more than three buttons. ![](pictures/0200020E.jpg). Picture buttons are usually rectangular in shape with an icon or; graphics label. These buttons may appear alone or placed in a group at; the window's top or side. They are most frequently used to quickly; acc",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md:56681,guid,guidelines,56681,documentation/users-guide/WritingGUI.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md,1,['guid'],['guidelines']
Usability,"model. One specialty of experimental physics are the inevitable uncertainties; affecting each measurement, and visualisation tools have to include; these. In subsequent analysis, the statistical nature of the errors must; be handled properly. As the last step, measurements are compared to models, and free model; parameters need to be determined in this process. See Figure [1.1](#f11) for an; example of a function (model) fit to data points. Several standard methods are; available, and a data analysis tool should provide easy access to more; than one of them. Means to quantify the level of agreement between; measurements and model must also be available.; <!--; [f11]: figures/examplefit.png ""f11""; <a name=""f11""></a>. ![Measured data points with error bars and fitted quadratic; function.\label{f11}][f11]-->. Quite often, the data volume to be analyzed is large - think of; fine-granular measurements accumulated with the aid of computers. A; usable tool therefore must contain easy-to-use and efficient methods for; storing and handling data. In Quantum mechanics, models typically only predict the probability; density function (""pdf"") of measurements depending on a number of; parameters, and the aim of the experimental analysis is to extract the; parameters from the observed distribution of frequencies at which; certain values of the measurement are observed. Measurements of this; kind require means to generate and visualize frequency distributions,; so-called histograms, and stringent statistical treatment to extract the; model parameters from purely statistical distributions. Simulation of expected data is another important aspect in data; analysis. By repeated generation of ""pseudo-data"", which are analysed in; the same manner as intended for the real data, analysis procedures can; be validated or compared. In many cases, the distribution of the; measurement errors is not precisely known, and simulation offers the; possibility to test the effects of different assumptio",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/Introduction.md:1914,usab,usable,1914,documentation/primer/Introduction.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/Introduction.md,1,['usab'],['usable']
Usability,"modest performance improvement to boot, because of; fewer dictionary lookups), e.g.:. .. code-block:: python. import cppyy; std = cppyy.gbl.std; v = std.vector[int](range(10)). But even such rebinding becomes annoying for (brief) interactive sessions. For CPython only (and not with tools such as IPython or in IDEs that replace; the interactive prompt), there is a fix, using; ``from cppyy.interactive import *``.; This makes lookups in the global dictionary of the current frame also; consider everything under ``cppyy.gbl``.; This feature comes with a performance `penalty` and is not meant for; production code.; Example usage:. .. code-block:: python. >>> from cppyy.interactive import *; >>> v = std.vector[int](range(10)); >>> print(list(v)); [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]; >>>; >>> cppdef(""struct SomeStruct {};""); True; >>> s = SomeStruct() # <- dynamically made available; >>> s; <cppyy.gbl.SomeStruct object at 0x7fa9b8624320>; >>>. For PyPy, IPython, etc. ``cppyy.gbl`` is simply rebound as ``g`` and; ``cppyy.gbl.std`` is made available as ``std``.; Not as convenient as full lookup, and missing any other namespaces that may be; available, but still saves some typing in may cases. `Odds and ends`; ---------------. * **namespaces**: Are represented as python classes.; Namespaces are more open-ended than classes, so sometimes initial access may; result in updates as data and functions are looked up and constructed; lazily.; Thus the result of ``dir()`` on a namespace shows the classes and functions; available for binding, even if these may not have been created yet.; Once created, namespaces are registered as modules, to allow importing from; them.; The global namespace is ``cppyy.gbl``. * **NULL**: Is represented as ``cppyy.nullptr``.; Starting C++11, the keyword ``nullptr`` is used to represent ``NULL``.; For clarity of intent, it is recommended to use this instead of ``None``; (or the integer ``0``, which can serve in some cases), as ``None`` is better; understood as ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/misc.rst:5505,simpl,simply,5505,bindings/pyroot/cppyy/cppyy/doc/source/misc.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/misc.rst,1,['simpl'],['simply']
Usability,"monly change the program in ways that change the maximal; converged-with relations. This also means that a value that was; previously uniform can become divergent after such a transform.; Uniformity has to be recomputed after such transforms. Divergent Branch inside a Cycle; -------------------------------. .. figure:: convergence-divergent-inside.png; :name: convergence-divergent-inside. The above figure shows a divergent branch ``Q`` inside an irreducible; cyclic region. When two threads diverge at ``Q``, the convergence of; dynamic instances within the cyclic region depends on the cycle; hierarchy chosen:. 1. In an implementation that detects a single cycle ``C`` with header; ``P``, convergence inside the cycle is determined by ``P``. 2. In an implementation that detects two nested cycles with headers; ``R`` and ``S``, convergence inside those cycles is determined by; their respective headers. .. _convergence-diverged-entry:. A conservative approach would be to simply report all nodes inside; irreducible cycles as having divergent outputs. But it is desirable to; recognize m-converged nodes in the CFG in order to maximize; uniformity. This section describes one such pattern of nodes derived; from *closed paths*, which are a property of the CFG and do not depend; on the cycle hierarchy. **Diverged Entry Criterion:**. The dynamic instances of all the nodes in a closed path ``P`` are; m-converged only if for every divergent branch ``B`` and its; join node ``J`` that lie on ``P``, there is no entry to ``P`` which; lies on a diverged path from ``B`` to ``J``. .. figure:: convergence-closed-path.png; :name: convergence-closed-path. Consider the closed path ``P -> Q -> R -> S`` in the above figure.; ``P`` and ``R`` are :ref:`entries to the closed; path<cycle-closed-path>`. ``Q`` is a divergent branch and ``S`` is a; join for that branch, with diverged paths ``Q -> R -> S`` and ``Q ->; S``. - If a diverged entry ``R`` exists, then in some cycle hierarchy,; ``R`` is the h",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ConvergenceAndUniformity.rst:21605,simpl,simply,21605,interpreter/llvm-project/llvm/docs/ConvergenceAndUniformity.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ConvergenceAndUniformity.rst,1,['simpl'],['simply']
Usability,"mpile these two functions to the same thing:. #include <stdlib.h>; void f(int a, int b, int *P) {; *P = (a-b)>=0?(a-b):(b-a);; }; void g(int a, int b, int *P) {; *P = abs(a-b);; }. Further, they should compile to something better than:. _g:; subf r2, r4, r3; subfic r3, r2, 0; cmpwi cr0, r2, -1; bgt cr0, LBB2_2 ; entry; LBB2_1: ; entry; mr r2, r3; LBB2_2: ; entry; stw r2, 0(r5); blr. GCC produces:. _g:; subf r4,r4,r3; srawi r2,r4,31; xor r0,r2,r4; subf r0,r2,r0; stw r0,0(r5); blr. ... which is much nicer. This theoretically may help improve twolf slightly (used in dimbox.c:142?). ===-------------------------------------------------------------------------===. PR5945: This: ; define i32 @clamp0g(i32 %a) {; entry:; %cmp = icmp slt i32 %a, 0; %sel = select i1 %cmp, i32 0, i32 %a; ret i32 %sel; }. Is compile to this with the PowerPC (32-bit) backend:. _clamp0g:; cmpwi cr0, r3, 0; li r2, 0; blt cr0, LBB1_2; ; %bb.1: ; %entry; mr r2, r3; LBB1_2: ; %entry; mr r3, r2; blr. This could be reduced to the much simpler:. _clamp0g:; srawi r2, r3, 31; andc r3, r3, r2; blr. ===-------------------------------------------------------------------------===. int foo(int N, int ***W, int **TK, int X) {; int t, i;; ; for (t = 0; t < N; ++t); for (i = 0; i < 4; ++i); W[t / X][i][t % X] = TK[i][t];; ; return 5;; }. We generate relatively atrocious code for this loop compared to gcc. We could also strength reduce the rem and the div:; http://www.lcs.mit.edu/pubs/pdf/MIT-LCS-TM-600.pdf. ===-------------------------------------------------------------------------===. We generate ugly code for this:. void func(unsigned int *ret, float dx, float dy, float dz, float dw) {; unsigned code = 0;; if(dx < -dw) code |= 1;; if(dx > dw) code |= 2;; if(dy < -dw) code |= 4;; if(dy > dw) code |= 8;; if(dz < -dw) code |= 16;; if(dz > dw) code |= 32;; *ret = code;; }. ===-------------------------------------------------------------------------===. %struct.B = type { i8, [3 x i8] }. define void @bar(%struct.B* ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/README.txt:4330,simpl,simpler,4330,interpreter/llvm-project/llvm/lib/Target/PowerPC/README.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/README.txt,1,['simpl'],['simpler']
Usability,"mpile; cmake -Dr=ON ..; make -j 5; ~~~. ## How does it work ?; There is a class called TRInterface which is located at the header TRInterface.h and uses the namespace `ROOT::R`, it is in charge; of making calls to R to give and obtain data. This class has a series of overcharged operators which ease the passing and obtaining of data; and code from R to C++ and vice versa. To create an object of this class the user must use the static methods `ROOT::R::TRInterface::Instance`; and `ROOT::R::TRInterface::InstancePtr` which return a reference object and a pointer object respectively. ~~~{.cxx}; #include<TRInterface.h>; ROOT::R::TRInterface &r=ROOT::R::TRInterface::Instance();; ~~~. ## Running R code and passing/getting variables.; We have different ways to run R code and pass/obtain data to/from R environment: using the methods Execute(code) and; Eval(code). ~~~{.cxx}; #include<TRInterface.h>. //creating an instance; ROOT::R::TRInterface &r=ROOT::R::TRInterface::Instance();; //executing simple r commands with the operator <<; r<<""print('hello ROOTR')"";; r<<""vec=c(1,2,3)""<<""print(vec)"";. //executing R's code using the method Execute that doesn't return anything; r.Execute(""print('hello ROOTR')"");. //We execute the code using the method Eval which returns an instance of TRObjectProxy; //which can be converted to a ROOTR supported classes; std::vector<Int_t> v=r.Eval(""c(1,2,3)"");; std::cout<<v[0]<<"" ""<<v[1]<<"" ""<<v[2]<<std::endl;. std::vector<Double_t> vd(3);. //obtaining variables from R environment using the operators [] and >>; r[""seq(0,1,0.5)""]>>vd;; std::cout<<vd[0]<<"" ""<<vd[1]<<"" ""<<vd[2]<<std::endl;. std::vector<Int_t> v1(3);; v1[0]=0;; v1[1]=1;; v1[2]=2;. r[""v1""]<<v1;; r<<""print(v1)"";. TMatrixD m(2,2);. //Creating a matrix inside r environment and converting it into a TMatrixD; r<<""mat<-matrix(c(0.1,0.2,0.3,0.4),nrow=2)"";; r[""mat""]>>m;; m.Print();; ~~~; So, working with ROOTR is like working with flows of data to pass, obtain and process data. ## Passing functions f",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/r/doc/users-guide/ROOTR_Users_Guide.md:4042,simpl,simple,4042,bindings/r/doc/users-guide/ROOTR_Users_Guide.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/r/doc/users-guide/ROOTR_Users_Guide.md,1,['simpl'],['simple']
Usability,"mpiler IR, as an on-disk bitcode representation; (suitable for fast loading by a Just-In-Time compiler), and as a human; readable assembly language representation. This allows LLVM to provide a; powerful intermediate representation for efficient compiler; transformations and analysis, while providing a natural means to debug; and visualize the transformations. The three different forms of LLVM are; all equivalent. This document describes the human readable; representation and notation. The LLVM representation aims to be light-weight and low-level while; being expressive, typed, and extensible at the same time. It aims to be; a ""universal IR"" of sorts, by being at a low enough level that; high-level ideas may be cleanly mapped to it (similar to how; microprocessors are ""universal IR's"", allowing many source languages to; be mapped to them). By providing type information, LLVM can be used as; the target of optimizations: for example, through pointer analysis, it; can be proven that a C automatic variable is never accessed outside of; the current function, allowing it to be promoted to a simple SSA value; instead of a memory location. .. _wellformed:. Well-Formedness; ---------------. It is important to note that this document describes 'well formed' LLVM; assembly language. There is a difference between what the parser accepts; and what is considered 'well formed'. For example, the following; instruction is syntactically okay, but not well formed:. .. code-block:: llvm. %x = add i32 1, %x. because the definition of ``%x`` does not dominate all of its uses. The; LLVM infrastructure provides a verification pass that may be used to; verify that an LLVM module is well formed. This pass is automatically; run by the parser after parsing input assembly and by the optimizer; before it outputs bitcode. The violations pointed out by the verifier; pass indicate bugs in transformation passes or input to the parser. .. _identifiers:. Identifiers; ===========. LLVM identifiers come",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:1744,simpl,simple,1744,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['simpl'],['simple']
Usability,"mplate parameters; Clang 5. 1005; NAD; Qualified name resolution in member functions of class templates; Unknown. 1006; C++11; std::nullptr_t as a non-type template parameter; Unknown. 1007; NAD; Protected access and pointers to members; Unknown. 1008; NAD; Querying the alignment of an object; Unknown. 1009; C++11; Missing cases in the declarator-id of a function template declaration; Unknown. 1010; CD2; Address of object with dynamic storage duration in constant expression; Unknown. 1011; C++11; Standard conversions that cannot be inverted; Unknown. 1012; C++11; Undeprecating static; Unknown. 1013; CD3; Uninitialized std::nullptr_t objects; Unknown. 1014; NAD; Overload resolution between const T& and T&&; Unknown. 1015; C++11; Template arguments and argument-dependent lookup; Unknown. 1016; C++11; Overloadable declarations, function templates, and references; Unknown. 1017; C++11; Member access transformation in unevaluated operands; Unknown. 1018; C++11; Ambiguity between simple-declaration and attribute-declaration; Unknown. 1019; dup; Dependent simple-template-ids in base-specifiers and mem-initializers; Unknown. 1020; C++11; Implicitly-defined copy constructors and explicit base class constructors; Unknown. 1021; CD4; Definitions of namespace members; Unknown. 1022; C++11; Can an enumeration variable have values outside the values of the enumeration?; Unknown. 1023; dup; thread_local objects as non-type template arguments; Unknown. 1024; CD3; Limits on multicharacter literals; Unknown. 1025; C++11; Use of a reference as a non-type template argument; Unknown. 1026; NAD; Cv-qualified non-class rvalues; Unknown. 1027; review; Type consistency and reallocation of scalar types; Not resolved. 1028; CD6; Dependent names in non-defining declarations; Unknown. 1029; C++11; Type of a destructor call; Unknown. 1030; C++11; Evaluation order in initializer-lists used in aggregate initialization; Unknown. 1031; C++11; Optional elements in attributes; Unknown. 1032; C++11; Em",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:67134,simpl,simple-declaration,67134,interpreter/llvm-project/clang/www/cxx_dr_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html,1,['simpl'],['simple-declaration']
Usability,"mple:; ``""%plural{%100=0:even hundred|%100=[1,50]:lower half|:everything else}1""``. The parser is very unforgiving. A syntax error, even whitespace, will abort,; as will a failure to match the argument against any expression. **""ordinal"" format**. Example:; ``""ambiguity in %ordinal0 argument""``; Class:; Integers; Description:; This is a formatter which represents the argument number as an ordinal: the; value ``1`` becomes ``1st``, ``3`` becomes ``3rd``, and so on. Values less; than ``1`` are not supported. This formatter is currently hard-coded to use; English ordinals. **""objcclass"" format**. Example:; ``""method %objcclass0 not found""``; Class:; ``DeclarationName``; Description:; This is a simple formatter that indicates the ``DeclarationName`` corresponds; to an Objective-C class method selector. As such, it prints the selector; with a leading ""``+``"". **""objcinstance"" format**. Example:; ``""method %objcinstance0 not found""``; Class:; ``DeclarationName``; Description:; This is a simple formatter that indicates the ``DeclarationName`` corresponds; to an Objective-C instance method selector. As such, it prints the selector; with a leading ""``-``"". **""q"" format**. Example:; ``""candidate found by name lookup is %q0""``; Class:; ``NamedDecl *``; Description:; This formatter indicates that the fully-qualified name of the declaration; should be printed, e.g., ""``std::vector``"" rather than ""``vector``"". **""diff"" format**. Example:; ``""no known conversion %diff{from $ to $|from argument type to parameter type}1,2""``; Class:; ``QualType``; Description:; This formatter takes two ``QualType``\ s and attempts to print a template; difference between the two. If tree printing is off, the text inside the; braces before the pipe is printed, with the formatted text replacing the $.; If tree printing is on, the text after the pipe is printed and a type tree is; printed after the diagnostic message. **""sub"" format**. Example:; Given the following record definition of type ``TextSubstit",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:14127,simpl,simple,14127,interpreter/llvm-project/clang/docs/InternalsManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst,1,['simpl'],['simple']
Usability,"mplemented as Passes that traverse some; portion of a program to either collect information or transform the program.; The table below divides the passes that LLVM provides into three categories.; Analysis passes compute information that other passes can use or for debugging; or program visualization purposes. Transform passes can use (or invalidate); the analysis passes. Transform passes all mutate the program in some way.; Utility passes provides some utility but don't otherwise fit categorization.; For example passes to extract functions to bitcode or write a module to bitcode; are neither analysis nor transform passes. The table of contents above; provides a quick summary of each pass and links to the more complete pass; description later in the document. Analysis Passes; ===============. This section describes the LLVM Analysis Passes. ``aa-eval``: Exhaustive Alias Analysis Precision Evaluator; ----------------------------------------------------------. This is a simple N^2 alias analysis accuracy evaluator. Basically, for each; function in the program, it simply queries to see how the alias analysis; implementation answers alias queries between each pair of pointers in the; function. This is inspired and adapted from code by: Naveen Neelakantam, Francesco; Spadini, and Wojciech Stryjewski. ``basic-aa``: Basic Alias Analysis (stateless AA impl); ------------------------------------------------------. A basic alias analysis pass that implements identities (two different globals; cannot alias, etc), but does no stateful analysis. ``basiccg``: Basic CallGraph Construction; -----------------------------------------. Yet to be written. .. _passes-da:. ``da``: Dependence Analysis; ---------------------------. Dependence analysis framework, which is used to detect dependences in memory; accesses. ``domfrontier``: Dominance Frontier Construction; ------------------------------------------------. This pass is a simple dominator construction algorithm for finding forward",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Passes.rst:1263,simpl,simple,1263,interpreter/llvm-project/llvm/docs/Passes.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Passes.rst,1,['simpl'],['simple']
Usability,"mpt or; (preferably) humor. It be a curious world and it always beed."". > Basically, my argument for this type construction system is that it is; > VERY simple to use and understand (although it IS different than C, it is; > very simple and straightforward, which C is NOT). In fact, I would assert; > that most programmers TODAY do not understand pointers to member; > functions, and have to look up an example when they have to write them. Again, I don't disagree with this at all. But to some extent this; particular problem is inherently difficult. Your syntax for the above; example may be easier for you to read because this is the way you have been; thinking about it. Honestly, I don't find it much easier than the C syntax.; In either case, I would have to look up an example to write pointers to; member functions. But pointers to member functions are nowhere near as common as arrays. And; the old array syntax:; type [ int, int, ...]; is just much more familiar and clear to people than anything new you; introduce, no matter how logical it is. Introducing a new syntax that may; make function pointers easier but makes arrays much more difficult seems; very risky to me. > In my opinion, it is critically important to have clear and concise type; > specifications, because types are going to be all over the programs. I absolutely agree. But the question is, what is more clear and concise?; The syntax programmers are used to out of years of experience or a new; syntax that they have never seen that has a more logical structure. I think; the answer is the former. Sometimes, you have to give up a better idea; because you can't overcome sociological barriers to it. Qwerty keyboards; and Windows are two classic examples of bad technology that are difficult to; root out. P.S. Also, while I agree that most your syntax is more logical, there is; one part that isn't:. Arrays (without and with size):; type ::= '[' type ']' | '[' INT ',' type ']'. The arrays with size lists the dimens",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HistoricalNotes/2001-02-06-TypeNotationDebateResp1.txt:1801,clear,clear,1801,interpreter/llvm-project/llvm/docs/HistoricalNotes/2001-02-06-TypeNotationDebateResp1.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HistoricalNotes/2001-02-06-TypeNotationDebateResp1.txt,1,['clear'],['clear']
Usability,"ms byte swapping not on the entire 64 bits, but on the individual items within the vector. This means that the register content is the same as it would have been on a little endian system. It may seem that ``LD1`` should suffice to perform vector loads on a big endian machine. However there are pros and cons to the two approaches that make it less than simple which register format to pick. There are two options:. 1. The content of a vector register is the same *as if* it had been loaded with an ``LDR`` instruction.; 2. The content of a vector register is the same *as if* it had been loaded with an ``LD1`` instruction. Because ``LD1 == LDR + REV`` and similarly ``LDR == LD1 + REV`` (on a big endian system), we can simulate either type of load with the other type of load plus a ``REV`` instruction. So we're not deciding which instructions to use, but which format to use (which will then influence which instruction is best to use). .. The 'clearer' container is required to make the following section header come after the floated; images above.; .. container:: clearer. Note that throughout this section we only mention loads. Stores have exactly the same problems as their associated loads, so have been skipped for brevity. Considerations; ==============. LLVM IR Lane ordering; ---------------------. LLVM IR has first class vector types. In LLVM IR, the zero'th element of a vector resides at the lowest memory address. The optimizer relies on this property in certain areas, for example when concatenating vectors together. The intention is for arrays and vectors to have identical memory layouts - ``[4 x i8]`` and ``<4 x i8>`` should be represented the same in memory. Without this property there would be many special cases that the optimizer would have to cleverly handle. Use of ``LDR`` would break this lane ordering property. This doesn't preclude the use of ``LDR``, but we would have to do one of two things:. 1. Insert a ``REV`` instruction to reverse the lane order after e",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/BigEndianNEON.rst:4280,clear,clearer,4280,interpreter/llvm-project/llvm/docs/BigEndianNEON.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/BigEndianNEON.rst,1,['clear'],['clearer']
Usability,"mt_misc/register; % chmod u+x hello.bc (if needed); % ./hello.bc. This allows you to execute LLVM bitcode files directly. On Debian, you can also; use this command instead of the 'echo' command above:. .. code-block:: console. % sudo update-binfmts --install llvm /path/to/lli --magic 'BC'. .. _Program Layout:; .. _general layout:. Directory Layout; ================. One useful source of information about the LLVM source base is the LLVM `doxygen; <http://www.doxygen.org/>`_ documentation available at; `<https://llvm.org/doxygen/>`_. The following is a brief introduction to code; layout:. ``llvm/cmake``; --------------; Generates system build files. ``llvm/cmake/modules``; Build configuration for llvm user defined options. Checks compiler version and; linker flags. ``llvm/cmake/platforms``; Toolchain configuration for Android NDK, iOS systems and non-Windows hosts to; target MSVC. ``llvm/examples``; -----------------. - Some simple examples showing how to use LLVM as a compiler for a custom; language - including lowering, optimization, and code generation. - Kaleidoscope Tutorial: Kaleidoscope language tutorial run through the; implementation of a nice little compiler for a non-trivial language; including a hand-written lexer, parser, AST, as well as code generation; support using LLVM- both static (ahead of time) and various approaches to; Just In Time (JIT) compilation.; `Kaleidoscope Tutorial for complete beginner; <https://llvm.org/docs/tutorial/MyFirstLanguageFrontend/index.html>`_. - BuildingAJIT: Examples of the `BuildingAJIT tutorial; <https://llvm.org/docs/tutorial/BuildingAJIT1.html>`_ that shows how LLVM’s; ORC JIT APIs interact with other parts of LLVM. It also, teaches how to; recombine them to build a custom JIT that is suited to your use-case. ``llvm/include``; ----------------. Public header files exported from the LLVM library. The three main subdirectories:. ``llvm/include/llvm``. All LLVM-specific header files, and subdirectories for different porti",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GettingStarted.rst:34461,simpl,simple,34461,interpreter/llvm-project/llvm/docs/GettingStarted.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GettingStarted.rst,1,['simpl'],['simple']
Usability,"much more. Further, refactoring wants to look; across the whole program to ensure that it is making transformations; that are safe. Making this efficient and getting this right requires a; significant amount of engineering and algorithmic work that simply are; unnecessary for a simple static compiler.; The beauty of the clang approach is that it does not restrict how you use it.; In particular, it is possible to use the clang preprocessor and parser to build; an extremely quick and light-weight on-the-fly code generator (similar to TCC); that does not build an AST at all. As an intermediate step, clang supports; using the current AST generation and semantic analysis code and having a code; generation client free the AST for each function after code generation. Finally,; clang provides support for building and retaining fully-fledged ASTs, and even; supports writing them out to disk.; Designing the libraries with clean and simple APIs allows these high-level; policy decisions to be determined in the client, instead of forcing ""one true; way"" in the implementation of any of these libraries. Getting this right is; hard, and we don't always get it right the first time, but we fix any problems; when we realize we made a mistake. Integration with IDEs. We believe that Integrated Development Environments (IDE's) are a great way; to pull together various pieces of the development puzzle, and aim to make clang; work well in such an environment. The chief advantage of an IDE is that they; typically have visibility across your entire project and are long-lived; processes, whereas stand-alone compiler tools are typically invoked on each; individual file in the project, and thus have limited scope.; There are many implications of this difference, but a significant one has to; do with efficiency and caching: sharing an address space across different files; in a project, means that you can use intelligent caching and other techniques to; dramatically reduce analysis/compilation ti",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/features.html:8810,simpl,simple,8810,interpreter/llvm-project/clang/www/features.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/features.html,1,['simpl'],['simple']
Usability,"multilib variant; # to be a match.; Flags: [--target=thumbv7m-none-eabi, -mfpu=fpv4-sp-d16]. # The second section of the file is a list of regular expressions that are; # used to map from flags generated from command line options to custom flags.; # This is optional.; # Each regular expression must match a whole flag string.; # Flags in the ""Flags"" list will be added if any flag generated from command; # line options matches the regular expression.; Mappings:. # Set a ""--target=thumbv7m-none-eabi"" flag if the regular expression matches; # any of the flags generated from the command line options.; # Match is a POSIX extended regular expression string.; - Match: --target=thumbv([7-9]|[1-9][0-9]+).*; # Flags is a list of one or more strings.; Flags: [--target=thumbv7m-none-eabi]. Design principles; =================. Stable interface; ----------------. ``multilib.yaml`` and ``-print-multi-flags-experimental`` are new; interfaces to Clang. In order for them to be usable over time and across LLVM; versions their interfaces should be stable.; The new multilib system will be considered experimental in LLVM 17, but in; LLVM 18 it will be stable. In particular this is important to which multilib; selection flags Clang generates from command line options. Once a flag is; generated by a released version of Clang it may be used in ``multilib.yaml``; files that exist independently of the LLVM release cycle, and therefore; ceasing to generate the flag would be a breaking change and should be; avoided. However, an exception is the normalization of ``-march``.; ``-march`` for Arm architectures contains a list of enabled and disabled; extensions and this list is likely to grow. Therefore ``-march`` flags are; unstable. Incomplete interface; --------------------. The new multilib system does multilib selection based on only a limited set of; command line options, and limits which flags can be used for multilib; selection. This is in order to avoid committing to too large an interface",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Multilib.rst:9417,usab,usable,9417,interpreter/llvm-project/clang/docs/Multilib.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Multilib.rst,1,['usab'],['usable']
Usability,"n Clang. This documents describes the LibFormat interface and design as well; as some basic style discussions. If you just want to use `clang-format` as a tool or integrated into an editor,; checkout :doc:`ClangFormat`. Design; ------. FIXME: Write up design. Interface; ---------. The core routine of LibFormat is ``reformat()``:. .. code-block:: c++. tooling::Replacements reformat(const FormatStyle &Style, Lexer &Lex,; SourceManager &SourceMgr,; std::vector<CharSourceRange> Ranges);. This reads a token stream out of the lexer ``Lex`` and reformats all the code; ranges in ``Ranges``. The ``FormatStyle`` controls basic decisions made during; formatting. A list of options can be found under :ref:`style-options`. The style options are described in :doc:`ClangFormatStyleOptions`. .. _style-options:. Style Options; -------------. The style options describe specific formatting options that can be used in; order to make `ClangFormat` comply with different style guides. Currently,; several style guides are hard-coded:. .. code-block:: c++. /// Returns a format style complying with the LLVM coding standards:; /// https://llvm.org/docs/CodingStandards.html.; FormatStyle getLLVMStyle();. /// Returns a format style complying with Google's C++ style guide:; /// http://google-styleguide.googlecode.com/svn/trunk/cppguide.xml.; FormatStyle getGoogleStyle();. /// Returns a format style complying with Chromium's style guide:; /// https://chromium.googlesource.com/chromium/src/+/refs/heads/main/styleguide/styleguide.md; FormatStyle getChromiumStyle();. /// Returns a format style complying with the GNU coding standards:; /// https://www.gnu.org/prep/standards/standards.html; FormatStyle getGNUStyle();. /// Returns a format style complying with Mozilla's style guide; /// https://firefox-source-docs.mozilla.org/code-quality/coding-style/index.html; FormatStyle getMozillaStyle();. /// Returns a format style complying with Webkit's style guide:; /// https://webkit.org/code-style-guidelines/",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibFormat.rst:1115,guid,guides,1115,interpreter/llvm-project/clang/docs/LibFormat.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibFormat.rst,1,['guid'],['guides']
Usability,"n L comprised of one incomplete; composite location description SL is pushed on the stack. An incomplete composite location storage LS is created with a single; part P. P specifies the location description PL and has a bit size of S; scaled by 8 (the byte size). SL specifies LS with a bit offset of 0. * Otherwise, the DWARF expression is ill-formed. *Many compilers store a single variable in sets of registers or store a; variable partially in memory and partially in registers.* ``DW_OP_piece``; *provides a way of describing where a part of a variable is located.*. *If a non-0 byte displacement is required, the* ``DW_OP_LLVM_offset``; *operation can be used to update the location description before using it as; the part location description of a* ``DW_OP_piece`` *operation.*. *The evaluation rules for the* ``DW_OP_piece`` *operation allow it to be; compatible with the DWARF Version 5 definition.*. .. note::. Since these extensions allow location descriptions to be entries on the; stack, a simpler operation to create composite location descriptions could; be defined. For example, just one operation that specifies how many parts,; and pops pairs of stack entries for the part size and location; description. Not only would this be a simpler operation and avoid the; complexities of incomplete composite location descriptions, but it may; also have a smaller encoding in practice. However, the desire for; compatibility with DWARF Version 5 is likely a stronger consideration. 2. ``DW_OP_bit_piece``. ``DW_OP_bit_piece`` has two operands. The first is an unsigned LEB128; integer that represents the part bit size S. The second is an unsigned; LEB128 integer that represents a bit displacement B. The action is the same as for ``DW_OP_piece``, except that any part created; has the bit size S, and the location description PL of any created part is; updated as if the ``DW_OP_constu B; DW_OP_LLVM_bit_offset`` operations were; applied. ``DW_OP_bit_piece`` *is used instead of* ``DW_OP_pi",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst:135947,simpl,simpler,135947,interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,1,['simpl'],['simpler']
Usability,"n and self-servicing.** A user can restart their; personal PROOF cluster in case of troubles without waiting for a; system administrator's intervention. - **Efficient multiuser scheduling.** PROOF on Demand makes PROOF run on; top of an existing resource management system, moving the problem of; scheduling many concurrent users outside of PROOF. This guide particularly refers to the setup of a static PROOF cluster; running on physical hosts: the recommended setup is in practice the same; as the ready-to-go Virtual Analysis Facility. If you want to use PROOF; on the clouds there is no configuration to go through. Setup a resource management system; ----------------------------------. Although PROOF on Demand can run on a cluster of nodes without using a; resource management system (using `pod-ssh`), it is recommended to setup a; dedicated one to benefit from the scheduling in a multiuser environment, or a; dedicated queue on an existing one. As there's a variety of resource management systems, this guide does not cover; their setup. The RMS preconfigured for the Virtual Analysis Facility is; [HTCondor](http://research.cs.wisc.edu/htcondor/), which we recommend primarily; because it has dynamic addition of workers built in. Configuration steps for all nodes; ---------------------------------. ### Setup CernVM-FS. [CernVM-FS](http://cernvm.cern.ch/portal/filesystem) should be installed; on all machines as the preferred method for software distribution. > Configuration instructions for the latest CernVM-FS can be found; > [here](http://cernvm.cern.ch/portal/filesystem/techinformation). A brief step-by-step procedure to install CernVM-FS is hereby described. - Download and install the latest stable version from; [here](http://cernvm.cern.ch/portal/filesystem): pick one which is; appropriate to your operating system. You need the `cvmfs` package,; you *don't* need the `cvmfs-devel` or `cvmfs-server` ones. - As root user, run:. # cvmfs_config setup. - Start the `autofs` ser",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/doc/confman/ConfigProofPoD.md:1504,guid,guide,1504,proof/doc/confman/ConfigProofPoD.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/doc/confman/ConfigProofPoD.md,1,['guid'],['guide']
Usability,"n be compared for pointer equivalence to find out if they are the same symbol.; Note that pointer inequality does not guarantee the labels will end up at; different addresses though. It's perfectly legal to output something like this; to the .s file:. ::. foo:; bar:; .byte 4. In this case, both the foo and bar symbols will have the same address. The ``MCSection`` class; -----------------------. The ``MCSection`` class represents an object-file specific section. It is; subclassed by object file specific implementations (e.g. ``MCSectionMachO``,; ``MCSectionCOFF``, ``MCSectionELF``) and these are created and uniqued by; MCContext. The MCStreamer has a notion of the current section, which can be; changed with the SwitchToSection method (which corresponds to a "".section""; directive in a .s file). .. _MCInst:. The ``MCInst`` class; --------------------. The ``MCInst`` class is a target-independent representation of an instruction.; It is a simple class (much more so than `MachineInstr`_) that holds a; target-specific opcode and a vector of MCOperands. MCOperand, in turn, is a; simple discriminated union of three cases: 1) a simple immediate, 2) a target; register ID, 3) a symbolic expression (e.g. ""``Lfoo-Lbar+42``"") as an MCExpr. MCInst is the common currency used to represent machine instructions at the MC; layer. It is the type used by the instruction encoder, the instruction printer,; and the type generated by the assembly parser and disassembler. .. _ObjectFormats:. Object File Format; ------------------. The MC layer's object writers support a variety of object formats. Because of; target-specific aspects of object formats each target only supports a subset of; the formats supported by the MC layer. Most targets support emitting ELF; objects. Other vendor-specific objects are generally supported only on targets; that are supported by that vendor (i.e. MachO is only supported on targets; supported by Darwin, and XCOFF is only supported on targets that support AIX).; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodeGenerator.rst:30593,simpl,simple,30593,interpreter/llvm-project/llvm/docs/CodeGenerator.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodeGenerator.rst,1,['simpl'],['simple']
Usability,"n by the first static rule about cycles. A first formal argument why we have to do this is that the dynamic rule for; deciding whether two threads execute converged dynamic instances of; ``@convergent.op`` leads to a logical contradiction in this code.; Assume two threads execute converged dynamic instances of the anchor; followed by two iterations of the loop. Thread 1 executes dynamic instances; I1 and I2 of ``@convergent.op``, thread 2 executes dynamic instances J1 and J2.; Using all the rules, we can deduce:. 1. ``I1 != I2`` and ``J1 != J2`` by the basic rules of dynamic instances. 2. ``I1 == J1`` by the first dynamic rule about controlled convergent; operations: both threads execute the same static instruction while using; a convergence token value produced by converged dynamic instances of an; instruction (the anchor). 3. ``I1 == J2`` by the same argument. Also, ``I2 == J1`` and ``I2 == J2``. The fact that one may be *intuitively* tempted to think of ``I1`` and ``J2``; as being executed in different loop iterations is completely irrelevant for; the *formal* argument. There is no mechanism in LLVM IR semantics for; forming associations between loop iterations in different threads, *except*; for the rules defined in this document -- and the rules in this document; require a loop heart intrinsic for talking about loop iterations. 4. By transitivity, we have ``I1 == I2`` and ``J1 == J2``. That is a; contradiction. This problem goes away by inserting a loop heart intrinsic as follows, which; establishes a relationship between loop iterations across threads. .. code-block:: llvm. %anchor = call token @llvm.experimental.convergence.anchor(); for (;;) {; %loop = call token @llvm.experimental.convergence.loop() [ ""convergencectrl""(token %anchor) ]; ...; call void @convergent.op() [ ""convergencectrl""(token %loop) ]; ...; }. In the same scenario of two threads executing converged dynamic instances of the; anchor and then two iterations of the loop, the dynamic rule about",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ConvergentOperations.rst:40475,intuit,intuitively,40475,interpreter/llvm-project/llvm/docs/ConvergentOperations.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ConvergentOperations.rst,1,['intuit'],['intuitively']
Usability,"n bytes share a 4-byte origin trace ID. A; 4-byte origin trace ID contains a 4-bit depth and a 28-bit hash ID of a chain. A chain ID is calculated as a hash from a chain structure. A chain structure; contains a stack ID and the previous chain ID. The chain head has a zero; previous chain ID. A stack ID is a hash from a stack trace. The 4-bit depth; limits the maximal length of a path. The environment variable ``origin_history_size``; can set the depth limit. Non-positive values mean unlimited. Its default value; is 16. When reaching the limit, origin tracking ignores following propagation; chains. The first chain of a trace starts by `dfsan_set_label` with non-zero labels. A; new chain is appended at the end of a trace at stores or memory transfers when; ``-dfsan-track-origins`` is 1. Memory transfers include LLVM memory transfer; instructions, glibc memcpy and memmove. When ``-dfsan-track-origins`` is 2, a; new chain is also appended at loads. Other instructions do not create new chains, but simply propagate origin trace; IDs. If an instruction has more than one operands with non-zero labels, the origin; treace ID of the last operand with non-zero label is propagated to the result of; the instruction. Memory layout and label management; ----------------------------------. The following is the memory layout for Linux/x86\_64:. +---------------+---------------+--------------------+; | Start | End | Use |; +===============+===============+====================+; | 0x700000000000|0x800000000000 | application 3 |; +---------------+---------------+--------------------+; | 0x610000000000|0x700000000000 | unused |; +---------------+---------------+--------------------+; | 0x600000000000|0x610000000000 | origin 1 |; +---------------+---------------+--------------------+; | 0x510000000000|0x600000000000 | application 2 |; +---------------+---------------+--------------------+; | 0x500000000000|0x510000000000 | shadow 1 |; +---------------+---------------+--------------------+;",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DataFlowSanitizerDesign.rst:7453,simpl,simply,7453,interpreter/llvm-project/clang/docs/DataFlowSanitizerDesign.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DataFlowSanitizerDesign.rst,1,['simpl'],['simply']
Usability,"n control back to the caller if it is not an initial; invocation of the coroutine. The `loop` blocks represents the body of the coroutine. The `coro.suspend`_; intrinsic in combination with the following switch indicates what happens to; control flow when a coroutine is suspended (default case), resumed (case 0) or; destroyed (case 1). Coroutine Transformation; ------------------------. One of the steps of coroutine lowering is building the coroutine frame. The; def-use chains are analyzed to determine which objects need be kept alive across; suspend points. In the coroutine shown in the previous section, use of virtual register; `%inc` is separated from the definition by a suspend point, therefore, it; cannot reside on the stack frame since the latter goes away once the coroutine; is suspended and control is returned back to the caller. An i32 slot is; allocated in the coroutine frame and `%inc` is spilled and reloaded from that; slot as needed. We also store addresses of the resume and destroy functions so that the; `coro.resume` and `coro.destroy` intrinsics can resume and destroy the coroutine; when its identity cannot be determined statically at compile time. For our; example, the coroutine frame will be:. .. code-block:: llvm. %f.frame = type { ptr, ptr, i32 }. After resume and destroy parts are outlined, function `f` will contain only the; code responsible for creation and initialization of the coroutine frame and; execution of the coroutine until a suspend point is reached:. .. code-block:: llvm. define ptr @f(i32 %n) {; entry:; %id = call token @llvm.coro.id(i32 0, ptr null, ptr null, ptr null); %alloc = call noalias ptr @malloc(i32 24); %frame = call noalias ptr @llvm.coro.begin(token %id, ptr %alloc); %1 = getelementptr %f.frame, ptr %frame, i32 0, i32 0; store ptr @f.resume, ptr %1; %2 = getelementptr %f.frame, ptr %frame, i32 0, i32 1; store ptr @f.destroy, ptr %2. %inc = add nsw i32 %n, 1; %inc.spill.addr = getelementptr inbounds %f.Frame, ptr %FramePt",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst:14377,resume,resume,14377,interpreter/llvm-project/llvm/docs/Coroutines.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst,1,['resume'],['resume']
Usability,"n either execute the main script, or load the script and execute a; specific function. For example:. ``` {.cpp}; // execute the function that writes, reads, shows the tree; root[] x tree1.C; // use ACLiC to build shared library, check syntax, execute; root[] x tree1.C++; // Load the script and select a function to execute; root[] L tree1.C; root[] tree1w(); root[] tree1r(); ```. ## Example 1: A Tree with Simple Variables. This example shows how to write, view, and read a tree with several; simple (integers and floating-point) variables. ### Writing the Tree. Below is the function that writes the tree (`tree1w`). First, the; variables are defined (`px, py, pz,` `random` and `ev`). Then we add a; branch for each of the variables to the tree, by calling the; `TTree::Branch` method for each variable. ``` {.cpp}; void tree1w(){. // create a tree file tree1.root - create the file, the Tree and; // a few branches; TFile f(""tree1.root"",""recreate"");; TTree t1(""t1"",""a simple Tree with simple variables"");; Float_t px, py, pz;; Double_t random;; Int_t ev;; t1.Branch(""px"",&px,""px/F"");; t1.Branch(""py"",&py,""py/F"");; t1.Branch(""pz"",&pz,""pz/F"");; t1.Branch(""ev"",&ev,""ev/I"");. // fill the tree; for (Int_t i=0; i<10000; i++) {; gRandom->Rannor(px,py);; pz = px*px + py*py;; random = gRandom->Rndm();; ev = i;; t1.Fill();; }; // save the Tree heade; the file will be automatically closed; // when going out of the function scope; t1.Write();; }; ```. #### Creating Branches with A single Variable. This is the signature of `TTree::Branch` to create a branch with a list; of variables:. ``` {.cpp}; TBranch* TTree::Branch(const char* name,void* address,; const char* leaflist,; Int_t bufsize = 32000); ```. The first parameter is the branch name. The second parameter is the; address from which to read the value. The third parameter is the leaf; list with the name and type of each leaf. In this example, each branch; has only one leaf. In the box below, the branch is named `px` and has; one floating",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:35408,simpl,simple,35408,documentation/users-guide/Trees.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md,2,['simpl'],['simple']
Usability,"n one TFile and can be replayed again anytime.; Modifications in TRootCanvas menu:; Renamed 'Inspect' menu title to 'Tools'; Added 'Event Recorder' menu entry. Here is a screenshot of TGRecorder (GUI interface of the recorder):. New Class: TGPack; New Container class for vertical and horizontal grouping of frames.; It enforces a predictable resizing behaviour on children.; For an example of how to use it, see tutorials/eve/pack.C. TRootBrowser. Make the default url for the HTML plugin of TRootBrowser configurable via rootrc. TGTab. Added a 'Close Tab' icon in TGTabElement, allowing to close a tab element, and emitting a CloseTab(Int_t id) signal. The icon is active only on the actually activated tab.; Implement CloseTab slot usage in TRootBrowser and in TGRootIDE. TGTextEditor. Allow to execute a macro without having to save it first. TGSplitFrame. Added a new signal method Docked(TGFrame*) to notify when a embedded frame has been docked.; Added a new signal method Undocked(TGFrame*) to notify when a embedded frame has been undocked.; Added a new getter method GetUndocked() returning a pointer on undocked frame, if any. TGToolTip. Added new constructor with global x, y position.; If neither fWindow nor fPad are set use global fX, fY that was passed from outside. TGSplitter. Added option to handle frame resizing externally. TGView. Added a protection against possible negative scroll values. TGTextView. Fix bottom line not being properly updated while scrolling.; Solve a problem with vertical slider (avoid negative value when scrolling). TGTextEdit. Fix blinking cursor on some platforms/compilers. TGTextEntry. Added optional parameter 'Bool_t emit' to TGTextEntry::SetText(const char* text, Bool_t emit = kTRUE);; Made the same extension in sub-class TGNumberEntryField. TGCompositeFrame. Added new method virtual TGFrameElement* FindFrameElement(TGFrame *f) const; and use it in several TGCompositeFrame methods to simplify the code. GUIHTML; TGHtml. Implemented HTML <selec",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/doc/v522/index.html:1348,undo,undocked,1348,gui/doc/v522/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/doc/v522/index.html,1,['undo'],['undocked']
Usability,"n one instruction to read the series of bytes. Note that in cases where none of the atomic intrinsics are used, this; model places only one restriction on IR transformations on top of what; is required for single-threaded execution: introducing a store to a byte; which might not otherwise be stored is not allowed in general.; (Specifically, in the case where another thread might write to and read; from an address, introducing a store can change a load that may see; exactly one write into a load that may see multiple writes.). .. _ordering:. Atomic Memory Ordering Constraints; ----------------------------------. Atomic instructions (:ref:`cmpxchg <i_cmpxchg>`,; :ref:`atomicrmw <i_atomicrmw>`, :ref:`fence <i_fence>`,; :ref:`atomic load <i_load>`, and :ref:`atomic store <i_store>`) take; ordering parameters that determine which other atomic instructions on; the same address they *synchronize with*. These semantics implement; the Java or C++ memory models; if these descriptions aren't precise; enough, check those specs (see spec references in the; :doc:`atomics guide <Atomics>`). :ref:`fence <i_fence>` instructions; treat these orderings somewhat differently since they don't take an; address. See that instruction's documentation for details. For a simpler introduction to the ordering constraints, see the; :doc:`Atomics`. ``unordered``; The set of values that can be read is governed by the happens-before; partial order. A value cannot be read unless some operation wrote; it. This is intended to provide a guarantee strong enough to model; Java's non-volatile shared variables. This ordering cannot be; specified for read-modify-write operations; it is not strong enough; to make them atomic in any interesting way.; ``monotonic``; In addition to the guarantees of ``unordered``, there is a single; total order for modifications by ``monotonic`` operations on each; address. All modification orders must be compatible with the; happens-before order. There is no guarantee that the ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:152735,guid,guide,152735,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['guid'],['guide']
Usability,"n performs alias processing and then does actual; matching. Alias processing is the phase that canonicalizes different lexical forms of the; same instructions down to one representation. There are several different kinds; of alias that are possible to implement and they are listed below in the order; that they are processed (which is in order from simplest/weakest to most; complex/powerful). Generally you want to use the first alias mechanism that; meets the needs of your instruction, because it will allow a more concise; description. Mnemonic Aliases; ^^^^^^^^^^^^^^^^. The first phase of alias processing is simple instruction mnemonic remapping for; classes of instructions which are allowed with two different mnemonics. This; phase is a simple and unconditionally remapping from one input mnemonic to one; output mnemonic. It isn't possible for this form of alias to look at the; operands at all, so the remapping must apply for all forms of a given mnemonic.; Mnemonic aliases are defined simply, for example X86 has:. ::. def : MnemonicAlias<""cbw"", ""cbtw"">;; def : MnemonicAlias<""smovq"", ""movsq"">;; def : MnemonicAlias<""fldcww"", ""fldcw"">;; def : MnemonicAlias<""fucompi"", ""fucomip"">;; def : MnemonicAlias<""ud2a"", ""ud2"">;. ... and many others. With a MnemonicAlias definition, the mnemonic is remapped; simply and directly. Though MnemonicAlias's can't look at any aspect of the; instruction (such as the operands) they can depend on global modes (the same; ones supported by the matcher), through a Requires clause:. ::. def : MnemonicAlias<""pushf"", ""pushfq"">, Requires<[In64BitMode]>;; def : MnemonicAlias<""pushf"", ""pushfl"">, Requires<[In32BitMode]>;. In this example, the mnemonic gets mapped into a different one depending on; the current instruction set. Instruction Aliases; ^^^^^^^^^^^^^^^^^^^. The most general phase of alias processing occurs while matching is happening:; it provides new forms for the matcher to match along with a specific instruction; to generate. An instructi",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodeGenerator.rst:82574,simpl,simply,82574,interpreter/llvm-project/llvm/docs/CodeGenerator.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodeGenerator.rst,1,['simpl'],['simply']
Usability,"n that may trigger resumption of a coroutine from the same or; a different thread possibly prior to `async_op` call returning control back; to the coroutine:. .. code-block:: llvm. %save1 = call token @llvm.coro.save(ptr %hdl); call void @async_op1(ptr %hdl); %suspend1 = call i1 @llvm.coro.suspend(token %save1, i1 false); switch i8 %suspend1, label %suspend [i8 0, label %resume1; i8 1, label %cleanup]. .. _coro.suspend.async:. 'llvm.coro.suspend.async' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^; ::. declare {ptr, ptr, ptr} @llvm.coro.suspend.async(; ptr <resume function>,; ptr <context projection function>,; ... <function to call>; ... <arguments to function>). Overview:; """""""""""""""""". The '``llvm.coro.suspend.async``' intrinsic marks the point where; execution of an async coroutine is suspended and control is passed to a callee. Arguments:; """""""""""""""""""". The first argument should be the result of the `llvm.coro.async.resume` intrinsic.; Lowering will replace this intrinsic with the resume function for this suspend; point. The second argument is the `context projection function`. It should describe; how-to restore the `async context` in the continuation function from the first; argument of the continuation function. Its type is `ptr (ptr)`. The third argument is the function that models transfer to the callee at the; suspend point. It should take 3 arguments. Lowering will `musttail` call this; function. The fourth to six argument are the arguments for the third argument. Semantics:; """""""""""""""""""". The result of the intrinsic are mapped to the arguments of the resume function.; Execution is suspended at this intrinsic and resumed when the resume function is; called. .. _coro.prepare.async:. 'llvm.coro.prepare.async' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^; ::. declare ptr @llvm.coro.prepare.async(ptr <coroutine function>). Overview:; """""""""""""""""". The '``llvm.coro.prepare.async``' intrinsic is used to block inlining of the; async coroutine until after ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst:53785,resume,resume,53785,interpreter/llvm-project/llvm/docs/Coroutines.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst,1,['resume'],['resume']
Usability,"n the longer TBits that are passed the length; of the shorter TBits are zero (i.e. the default value of each; bits is zero).; Properly handle scripts with line longer than 1024 characters.; Repair the handling of ACLiC options on the command line (for example a.C+g).; In TClass::BuildEmulatedRealData properly handle the case of TNamed member that are not base class.; On the command line:; ; Fix the tab-completion of filenames in the sub-directories.; Prevent the unadvertent replacement of an arrow with a dot when the left side is actually a pointer. More user friendly stacktrace in case of a crash, with hints where; the problem might be. On Linux and MacOS X these stacktraces are generated; by the script $ROOTSYS/etc/gdb-backtrace.sh. Using the Root.StackTraceMessage; resource one can customize the message printed by the script. The entire; script can be replaced using the Root.StacktraceScript resource.; Numerous minor bug fixes... New module editline ; The new module editline enhances the prompt, giving type and syntax feedback using e.g. colors.; Class names are highlighted blue when typed, indicating that it is known to ROOT.; Matching parenthesis pairs are highlighted green when typed, or when the cursor is moved to a bracket. This works for () {} and [] brackets.; Any mismatched brackets (those without a matching partner) will be highlighted red when typed or when the cursor is moved to the bracket.; Tab completion output is colored magenta to differentiate between tab completion output and user input.; All of the colors are configurable in the .rootrc file.; They can be specified as #rgb or #rrggbb or color names:; black, red, green, yellow, blue, magenta, cyan or white.; They can be followed by an optional bold (alias light) or underlined.; Rint.ReverseColor allows to quickly toggle between the default ""light on dark"" (yes) instead of ""dark on light"" (no), depending on the terminal background.; An example configuration would be:. Rint.TypeColor: blue; Rint.B",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/doc/v526/index.html:1559,feedback,feedback,1559,core/doc/v526/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/doc/v526/index.html,1,['feedback'],['feedback']
Usability,"n the same plot. This technique allows seeing clearly; where the clusters are on an individual axis but it does not give any; hints about the correlations between the axes. Avery simple technique allows to make the clusters appearing:; Instead of painting solid lines we paint dotted lines. The cluttering of; each individual line is reduced and the clusters show clearly as we can; see on the next figure. The spacing between the dots is a parameter which; can be adjusted in order to get the best results. ![Using dotted lines is a very simple method to reduce the cluttering.](pictures/para5.png). Interactivity is a very important aspect of the Parallel Coordinates plots.; To really explore the data set it is essential to act directly with the; events and the axes. For instance, changing the axes order may show clusters; which were not visible in a different order. On the next figure the axes; order has been changed interactively. We can see that many more clusters; appear and all the “random spheres” we put in the data set are now; clearly visible. Having moved the variables `u,v,w` after the variables; `x,y,z` the correlation between these two sets of variables is clear also. ![Axis order is very important to show clusters.](pictures/para6.png). To pursue further data sets exploration we have implemented the possibility; to define selections interactively. A selection is a set of ranges combined; together. Within a selection, ranges along the same axis are combined with; logical OR, and ranges on different axes with logical AND. A selection is; displayed on top of the complete data set using its own color. Only the; events fulfilling the selection criteria (ranges) are displayed. Ranges; are defined interactively using cursors, like on the first axis on the; figure. Several selections can be defined at the same time,; each selection having its own color. ![Selections are set of ranges which can be defined interactively.](pictures/para7.png). Several selections can been",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:100043,clear,clearly,100043,documentation/users-guide/Trees.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md,1,['clear'],['clearly']
Usability,"n this style is virtually possible but; highly not recommended. #### The Structure of Composite Shapes. A composite shape can always be looked as the result of a Boolean; operation between only two shape components. All information identifying; these two components as well as their positions with respect to the; frame of the composite is represented by an object called Boolean node.; A composite shape has a pointer to such a Boolean node. Since the shape; components may also be composites, they will also contain binary Boolean; nodes branching out other two shapes in the hierarchy. Any such branch; ends-up when the final leaves are no longer composite shapes, but basic; primitives. The figure shows the composite shapes structure. ![The composite shapes structure](pictures/080001CA.png). Suppose that A, B, C and D represent basic shapes, we will illustrate; how the internal representation of few combinations look like. We do; this only for understanding how to create them in a proper way, since; the user interface for this purpose is in fact very simple. We will; ignore for the time being the positioning of components. The definition; of a composite shape takes an expression where the identifiers are shape; names. The expression is parsed and decomposed in 2 sub-expressions and; the top-level Boolean operator. 1. Union: `A+B+C`. Just to illustrate the Boolean expression parsing and the composite; shape structure, let's take a simple example. We will describe the union; of A, B and C. Both union operators are at the same level. Since:. `A+B+C = (A+B)+C = A+(B+C)`. The first` (+)` is taken as separator, hence the expression split in:; `A` and `(B+C)`. A Boolean node of type **`TGeoUnion`**`(""A"",""B+C"")` is; created. This tries to replace the 2 expressions by actual pointers to; corresponding shapes. The first expression (A) contains no operators; therefore is interpreted as representing a shape. The shape named ""A"" is; searched into the list of shapes handled by the man",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:44401,simpl,simple,44401,documentation/users-guide/Geometry.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md,1,['simpl'],['simple']
Usability,"n with this surprisingly long; // comment, so it would be unclear without the braces whether the following; // statement is in the scope of the `if`.; // Because the condition is documented, we can't really hoist this; // comment that applies to the body above the `if`.; handleOtherDecl(D);; }. // Use braces on the outer `if` to avoid a potential dangling `else`; // situation.; if (isa<VarDecl>(D)) {; if (shouldProcessAttr(A)); handleAttr(A);; }. // Use braces for the `if` block to keep it uniform with the `else` block.; if (isa<FunctionDecl>(D)) {; handleFunctionDecl(D);; } else {; // In this `else` case, it is necessary that we explain the situation with; // this surprisingly long comment, so it would be unclear without the braces; // whether the following statement is in the scope of the `if`.; handleOtherDecl(D);; }. // This should also omit braces. The `for` loop contains only a single; // statement, so it shouldn't have braces. The `if` also only contains a; // single simple statement (the `for` loop), so it also should omit braces.; if (isa<FunctionDecl>(D)); for (auto *A : D.attrs()); handleAttr(A);. // Use braces for a `do-while` loop and its enclosing statement.; if (Tok->is(tok::l_brace)) {; do {; Tok = Tok->Next;; } while (Tok);; }. // Use braces for the outer `if` since the nested `for` is braced.; if (isa<FunctionDecl>(D)) {; for (auto *A : D.attrs()) {; // In this `for` loop body, it is necessary that we explain the situation; // with this surprisingly long comment, forcing braces on the `for` block.; handleAttr(A);; }; }. // Use braces on the outer block because there are more than two levels of; // nesting.; if (isa<FunctionDecl>(D)) {; for (auto *A : D.attrs()); for (ssize_t i : llvm::seq<ssize_t>(count)); handleAttrOnDecl(D, A, i);; }. // Use braces on the outer block because of a nested `if`; otherwise the; // compiler would warn: `add explicit braces to avoid dangling else`; if (auto *D = dyn_cast<FunctionDecl>(D)) {; if (shouldProcess(D)); handl",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodingStandards.rst:64203,simpl,simple,64203,interpreter/llvm-project/llvm/docs/CodingStandards.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodingStandards.rst,1,['simpl'],['simple']
Usability,"n, as it; runs just before the pass that we are trying to test:. ``llc -stop-after=machine-cp bug-trigger.ll -o test.mir``. If the same pass is run multiple times, a run index can be included; after the name with a comma. ``llc -stop-after=dead-mi-elimination,1 bug-trigger.ll -o test.mir``. After generating the input MIR file, you'll have to add a run line that uses; the ``-run-pass`` option to it. In order to test the post register allocation; pseudo instruction expansion pass on X86-64, a run line like the one shown; below can be used:. ``# RUN: llc -o - %s -mtriple=x86_64-- -run-pass=postrapseudos | FileCheck %s``. The MIR files are target dependent, so they have to be placed in the target; specific test directories (``lib/CodeGen/TARGETNAME``). They also need to; specify a target triple or a target architecture either in the run line or in; the embedded LLVM IR module. Simplifying MIR files; ^^^^^^^^^^^^^^^^^^^^^. The MIR code coming out of ``-stop-after``/``-stop-before`` is very verbose;; Tests are more accessible and future proof when simplified:. - Use the ``-simplify-mir`` option with llc. - Machine function attributes often have default values or the test works just; as well with default values. Typical candidates for this are: `alignment:`,; `exposesReturnsTwice`, `legalized`, `regBankSelected`, `selected`.; The whole `frameInfo` section is often unnecessary if there is no special; frame usage in the function. `tracksRegLiveness` on the other hand is often; necessary for some passes that care about block livein lists. - The (global) `liveins:` list is typically only interesting for early; instruction selection passes and can be removed when testing later passes.; The per-block `liveins:` on the other hand are necessary if; `tracksRegLiveness` is true. - Branch probability data in block `successors:` lists can be dropped if the; test doesn't depend on it. Example:; `successors: %bb.1(0x40000000), %bb.2(0x40000000)` can be replaced with; `successors: %bb.1, ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MIRLangRef.rst:3136,simpl,simplified,3136,interpreter/llvm-project/llvm/docs/MIRLangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MIRLangRef.rst,1,['simpl'],['simplified']
Usability,"n, this stream is saved in the emitter class member; named ``OS``, although some ``run`` functions are simple and just use the; stream without saving it. The output can be produced by writing values; directly to the output stream, or by using the ``std::format()`` or; ``llvm::formatv()`` functions. .. code-block:: text. OS << ""#ifndef "" << NodeName << ""\n"";. OS << format(""0x%0*x, "", Digits, Value);. Instances of the following classes can be printed using the ``<<`` operator:; ``RecordKeeper``,; ``Record``,; ``RecTy``,; ``RecordVal``, and; ``Init``. The helper function ``emitSourceFileHeader()`` prints the header comment; that should be included at the top of every output file. A call to it is; included in the skeleton backend file ``TableGenBackendSkeleton.cpp``. Printing Error Messages; =======================. TableGen records are often derived from multiple classes and also often; defined through a sequence of multiclasses. Because of this, it can be; difficult for backends to report clear error messages with accurate source; file locations. To make error reporting easier, five error reporting; functions are provided, each with four overloads. * ``PrintWarning`` prints a message tagged as a warning. * ``PrintError`` prints a message tagged as an error. * ``PrintFatalError`` prints a message tagged as an error and then terminates. * ``PrintNote`` prints a note. It is often used after one of the previous; functions to provide more information. * ``PrintFatalNote`` prints a note and then terminates. Each of these five functions is overloaded four times. * ``PrintError(const Twine &Msg)``:; Prints the message with no source file location. * ``PrintError(ArrayRef<SMLoc> ErrorLoc, const Twine &Msg)``:; Prints the message followed by the specified source line,; along with a pointer to the item in error. The array of; source file locations is typically taken from a ``Record`` instance. * ``PrintError(const Record *Rec, const Twine &Msg)``:; Prints the message followed by",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TableGen/BackGuide.rst:23738,clear,clear,23738,interpreter/llvm-project/llvm/docs/TableGen/BackGuide.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TableGen/BackGuide.rst,1,['clear'],['clear']
Usability,"n. Almost all; relevant classes can be found in libraries returned by; `root-config -glibs`; the graphics libraries are retuned by; `root-config --libs`. These commands are commonly used in `Makefiles`.; Using `root-config` instead of enumerating the libraries by hand; allows you to link them in a platform independent way. Also, if ROOT; library names change you will not need to change your Makefile. A batch program that does not have a graphic display, which creates,; fills, and saves histograms and trees, only needs to link the core; libraries (`libCore`, `libRIO`), `libHist` and `libTree`.; If ROOT needs access to other libraries, it loads them dynamically.; For example, if the **`TreeViewer`** is used, `libTreePlayer` and all; libraries `libTreePlayer` depends on are loaded also. The dependent; libraries are shown in the ROOT reference guide's library dependency; graph. The difference between reference guide `libHist` and; `libHistPainter` is that the former needs to be explicitly linked and; the latter will be loaded automatically at runtime when ROOT needs it,; by means of the Plugin Manager. plugin manager. In the Figure 1-2, the libraries represented by green boxes outside of; the core are loaded via the plugin manager plugin manager or; equivalent techniques, while the white ones are not. Of course, if one; wants to access a plugin library directly, it has to be explicitly; linked. An example of a plugin library is `libMinuit`. To create and; fill histograms you need to link `libHist.so`. If the code has a call; to fit the histogram, the ""fitter"" will dynamically load libMinuit if; it is not yet loaded. #### Plugins: Runtime Library Dependencies for Linking. plugin manager The Plugin Manager **`TPluginManager`** allows; postponing library dependencies to runtime: a plugin library will only; be loaded when it is needed. Non-plugins will need to be linked, and; are thus loaded at start-up. Plugins are defined by a base class (e.g.; **`TFile`**) that will be im",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md:18198,guid,guide,18198,documentation/users-guide/Introduction.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md,1,['guid'],['guide']
Usability,"n. Implementing a Native Assembler; ===============================. Though you're probably reading this because you want to write or maintain a; compiler backend, LLVM also fully supports building a native assembler.; We've tried hard to automate the generation of the assembler from the .td files; (in particular the instruction syntax and encodings), which means that a large; part of the manual and repetitive data entry can be factored and shared with the; compiler. Instruction Parsing; -------------------. .. note::. To Be Written. Instruction Alias Processing; ----------------------------. Once the instruction is parsed, it enters the MatchInstructionImpl function.; The MatchInstructionImpl function performs alias processing and then does actual; matching. Alias processing is the phase that canonicalizes different lexical forms of the; same instructions down to one representation. There are several different kinds; of alias that are possible to implement and they are listed below in the order; that they are processed (which is in order from simplest/weakest to most; complex/powerful). Generally you want to use the first alias mechanism that; meets the needs of your instruction, because it will allow a more concise; description. Mnemonic Aliases; ^^^^^^^^^^^^^^^^. The first phase of alias processing is simple instruction mnemonic remapping for; classes of instructions which are allowed with two different mnemonics. This; phase is a simple and unconditionally remapping from one input mnemonic to one; output mnemonic. It isn't possible for this form of alias to look at the; operands at all, so the remapping must apply for all forms of a given mnemonic.; Mnemonic aliases are defined simply, for example X86 has:. ::. def : MnemonicAlias<""cbw"", ""cbtw"">;; def : MnemonicAlias<""smovq"", ""movsq"">;; def : MnemonicAlias<""fldcww"", ""fldcw"">;; def : MnemonicAlias<""fucompi"", ""fucomip"">;; def : MnemonicAlias<""ud2a"", ""ud2"">;. ... and many others. With a MnemonicAlias definition, th",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodeGenerator.rst:81923,simpl,simplest,81923,interpreter/llvm-project/llvm/docs/CodeGenerator.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodeGenerator.rst,1,['simpl'],['simplest']
Usability,"n.addr, align 4; tail call void @print(i32 %inc); br label %suspend. suspend:; %storemerge = phi i8 [ 0, %loop ], [ 1, %loop.resume ]; store i8 %storemerge, ptr %index.addr, align 1; ret void; }. If different cleanup code needs to get executed for different suspend points,; a similar switch will be in the `f.destroy` function. .. note ::. Using suspend index in a coroutine state and having a switch in `f.resume` and; `f.destroy` is one of the possible implementation strategies. We explored; another option where a distinct `f.resume1`, `f.resume2`, etc. are created for; every suspend point, and instead of storing an index, the resume and destroy; function pointers are updated at every suspend. Early testing showed that the; current approach is easier on the optimizer than the latter so it is a; lowering strategy implemented at the moment. Distinct Save and Suspend; -------------------------. In the previous example, setting a resume index (or some other state change that; needs to happen to prepare a coroutine for resumption) happens at the same time as; a suspension of a coroutine. However, in certain cases, it is necessary to control; when coroutine is prepared for resumption and when it is suspended. In the following example, a coroutine represents some activity that is driven; by completions of asynchronous operations `async_op1` and `async_op2` which get; a coroutine handle as a parameter and resume the coroutine once async; operation is finished. .. code-block:: text. void g() {; for (;;); if (cond()) {; async_op1(<coroutine-handle>); // will resume once async_op1 completes; <suspend>; do_one();; }; else {; async_op2(<coroutine-handle>); // will resume once async_op2 completes; <suspend>; do_two();; }; }; }. In this case, coroutine should be ready for resumption prior to a call to; `async_op1` and `async_op2`. The `coro.save`_ intrinsic is used to indicate a; point when coroutine should be ready for resumption (namely, when a resume index; should be stored in th",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst:20578,resume,resume,20578,interpreter/llvm-project/llvm/docs/Coroutines.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst,1,['resume'],['resume']
Usability,"n.png ""f51""; <a name=""f51""></a>. ![The result of a counting (pseudo) experiment. Only bins corresponding; to integer values are filled given the discrete nature of the poissonian; distribution. \label{f51}][f51]. Using histograms is rather simple. The main differences with respect to; graphs that emerge from the example are:. - line *5*: The histograms have a name and a title right from the; start, no predefined number of entries but a number of bins and a; lower-upper range. - line *15*: An entry is stored in the histogram through the; `TH1F::Fill` method. - line *18* and *21*: The histogram can be drawn also normalised, ROOT; automatically takes cares of the necessary rescaling. - line *24* to *30*: This small snippet shows how easy it is to access; the moments and associated errors of a histogram. ## Add and Divide Histograms ##. Quite a large number of operations can be carried out with histograms.; The most useful are addition and division. In the following macro we; will learn how to manage these procedures within ROOT. ``` {.cpp .numberLines}; @ROOT_INCLUDE_FILE macros/macro6.C; ```. The plots that you will obtain are shown in Figures [5.2](#f52) and [5.3](#f53). [f52]: figures/histo_sum.png ""f52""; <a name=""f52""></a>. ![The sum of two histograms.\label{f52}][f52]. [f53]: figures/histo_ratio.png ""f53""; <a name=""f53""></a>. ![The ratio of two histograms.\label{f53}][f53]. Some lines now need a bit of clarification:. - line *3*: Cling, as we know, is also able to interpret more than one; function per file. In this case the function simply sets up some; parameters to conveniently set the line of histograms. - line *19* to *21*: Some `C++` syntax for conditional; statements is used to fill the histograms with different numbers of; entries inside the loop. - line *30*: The sum of two histograms. A weight, which can be negative, can; be assigned to the added histogram. - line *41*: The division of two histograms is rather straightforward. - line *44* to *62*: When yo",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/histograms.md:1968,learn,learn,1968,documentation/primer/histograms.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/histograms.md,1,['learn'],['learn']
Usability,"n3_EXECUTABLE}"" ${CMAKE_CURRENT_SOURCE_DIR}/perf-helper.py merge ${LLVM_PROFDATA} ${CMAKE_CURRENT_BINARY_DIR}/clang.profdata ${CMAKE_CURRENT_BINARY_DIR} ${CMAKE_BINARY_DIR}/profiles/; COMMENT ""Merging profdata""; DEPENDS generate-profraw); if (CLANG_PGO_TRAINING_DATA_SOURCE_DIR); llvm_ExternalProject_Add(generate-profraw-external ${CLANG_PGO_TRAINING_DATA_SOURCE_DIR}; USE_TOOLCHAIN EXLUDE_FROM_ALL NO_INSTALL DEPENDS generate-profraw); add_dependencies(generate-profdata generate-profraw-external); endif(); endif(); endif(). find_program(DTRACE dtrace); # TODO: Look into supporting this for the driver build. It will require changing; # the perf-helper.py file to understand to call `llvm` as `llvm clang`.; if(APPLE AND DTRACE AND NOT LLVM_TOOL_LLVM_DRIVER_BUILD); configure_lit_site_cfg(; ${CMAKE_CURRENT_SOURCE_DIR}/order-files.lit.site.cfg.in; ${CMAKE_CURRENT_BINARY_DIR}/order-files/lit.site.cfg; ). add_lit_testsuite(generate-dtrace-logs ""Generating clang dtrace data""; ${CMAKE_CURRENT_BINARY_DIR}/order-files/; EXCLUDE_FROM_CHECK_ALL; ARGS -j 1; DEPENDS clang clear-dtrace-logs; ). add_custom_target(clear-dtrace-logs; COMMAND ""${Python3_EXECUTABLE}"" ${CMAKE_CURRENT_SOURCE_DIR}/perf-helper.py clean ${CMAKE_CURRENT_BINARY_DIR} dtrace; COMMENT ""Clearing old dtrace data""). if(NOT CLANG_ORDER_FILE); message(FATAL_ERROR ""Output clang order file is not set""); endif(). add_custom_target(generate-order-file; COMMAND ""${Python3_EXECUTABLE}"" ${CMAKE_CURRENT_SOURCE_DIR}/perf-helper.py gen-order-file --binary $<TARGET_FILE:clang> --output ${CLANG_ORDER_FILE} ${CMAKE_CURRENT_BINARY_DIR}; COMMENT ""Generating order file""; DEPENDS generate-dtrace-logs); endif(). if(CLANG_BOLT_INSTRUMENT AND NOT LLVM_BUILD_INSTRUMENTED); configure_lit_site_cfg(; ${CMAKE_CURRENT_SOURCE_DIR}/bolt.lit.site.cfg.in; ${CMAKE_CURRENT_BINARY_DIR}/bolt-fdata/lit.site.cfg; ). add_lit_testsuite(generate-bolt-fdata ""Generating BOLT profile for Clang""; ${CMAKE_CURRENT_BINARY_DIR}/bolt-fdata/; EXCLUDE_FROM_CHECK_ALL; DE",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/perf-training/CMakeLists.txt:2335,clear,clear-dtrace-logs,2335,interpreter/llvm-project/clang/utils/perf-training/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/perf-training/CMakeLists.txt,1,['clear'],['clear-dtrace-logs']
Usability,"n: Combine Rule root is a named pattern. def Foo : GICombineRule<; (defs root:$root),; (match (G_ZEXT $tmp, (i32 0)),; (G_STORE $tmp, $ptr):$root),; (apply (G_STORE (i32 0), $ptr):$root)>;. Combine Rules also allow mixing C++ code with MIR patterns, so that you; may perform additional checks when matching, or run additional code after; rewriting a pattern. The following expansions are available for MIR patterns:. * operand names (``MachineOperand &``); * pattern names (``MachineInstr *`` for ``match``,; ``MachineInstrBuilder &`` for apply). .. code-block:: text; :caption: Example C++ Expansions. def Foo : GICombineRule<; (defs root:$root),; (match (G_ZEXT $root, $src):$mi),; (apply ""foobar(${root}.getReg(), ${src}.getReg(), ${mi}->hasImplicitDef())"")>;. Common Pattern #1: Replace a Register with Another; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. The 'apply' pattern must always redefine all operands defined by the match root.; Sometimes, we do not need to create instructions, simply replace a def with; another matched register. The ``GIReplaceReg`` builtin can do just that. .. code-block:: text. def Foo : GICombineRule<; (defs root:$dst),; (match (G_FNEG $tmp, $src), (G_FNEG $dst, $tmp)),; (apply (GIReplaceReg $dst, $src))>;. This also works if the replacement register is a temporary register from the; ``apply`` pattern. .. code-block:: text. def ReplaceTemp : GICombineRule<; (defs root:$a),; (match (G_BUILD_VECTOR $tmp, $x, $y),; (G_UNMERGE_VALUES $a, $b, $tmp)),; (apply (G_UNMERGE_VALUES $a, i32:$new, $y),; (GIReplaceReg $b, $new))>. Common Pattern #2: Erasing a Def-less Root; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. If we simply want to erase a def-less match root, we can use the; ``GIEraseRoot`` builtin. .. code-block:: text. def Foo : GICombineRule<; (defs root:$mi),; (match (G_STORE $a, $b):$mi),; (apply (GIEraseRoot))>;. Common Pattern #3: Emitting a Constant Value; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. When an immediate operand appears in",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GlobalISel/MIRPatterns.rst:8361,simpl,simply,8361,interpreter/llvm-project/llvm/docs/GlobalISel/MIRPatterns.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GlobalISel/MIRPatterns.rst,1,['simpl'],['simply']
Usability,"n_nontemporal_store(T value, T *addr);. The types ``T`` currently supported are:. * Integer types.; * Floating-point types.; * Vector types. Note that the compiler does not guarantee that non-temporal loads or stores; will be used. C++ Coroutines support builtins; --------------------------------. .. warning::; This is a work in progress. Compatibility across Clang/LLVM releases is not; guaranteed. Clang provides experimental builtins to support C++ Coroutines as defined by; https://wg21.link/P0057. The following four are intended to be used by the; standard library to implement the ``std::coroutine_handle`` type. **Syntax**:. .. code-block:: c. void __builtin_coro_resume(void *addr);; void __builtin_coro_destroy(void *addr);; bool __builtin_coro_done(void *addr);; void *__builtin_coro_promise(void *addr, int alignment, bool from_promise). **Example of use**:. .. code-block:: c++. template <> struct coroutine_handle<void> {; void resume() const { __builtin_coro_resume(ptr); }; void destroy() const { __builtin_coro_destroy(ptr); }; bool done() const { return __builtin_coro_done(ptr); }; // ...; protected:; void *ptr;; };. template <typename Promise> struct coroutine_handle : coroutine_handle<> {; // ...; Promise &promise() const {; return *reinterpret_cast<Promise *>(; __builtin_coro_promise(ptr, alignof(Promise), /*from-promise=*/false));; }; static coroutine_handle from_promise(Promise &promise) {; coroutine_handle p;; p.ptr = __builtin_coro_promise(&promise, alignof(Promise),; /*from-promise=*/true);; return p;; }; };. Other coroutine builtins are either for internal clang use or for use during; development of the coroutine feature. See `Coroutines in LLVM; <https://llvm.org/docs/Coroutines.html#intrinsics>`_ for; more information on their semantics. Note that builtins matching the intrinsics; that take token as the first parameter (llvm.coro.begin, llvm.coro.alloc,; llvm.coro.free and llvm.coro.suspend) omit the token parameter and fill it to; an appropriate valu",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:145904,resume,resume,145904,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst,1,['resume'],['resume']
Usability,"nalyse the performance tree.; Add support for selector-by-object processing in PROOF. The; selector object, created and configured locally by the user, is added; to the input list and recuperated from there on the worker machines for; processing. Any input list setting in the selector itself is not; streamed but temporarly moved to then standard input list, so that user; can use the selector input list as container of processing information; if they find convenient to do so. Process(...) methods with the file; name argument replaced by 'TSelector *' have  introduced where; relevant (TProof, TProofPlayer and their derivatives, TDSet).  ; Add the possibility to force submerging at node level, i.e. one; submerger per physical machine. In this way the network traffic can be; minimized, for example when merging large output files. The new feature; is enabled by setting the Int_t parameter 'PROOF_MergersByHost' (or the; directive 'Proof.MergersByHost') to a non-null value.; Simplify enabling of basic feedback. In TProof::Process, add; support for switches ""fb=name1,name2,name3,... "" or; ""feedback=name1,name2,name3,... "" in the option field. This enables; feedback for the specified objects, creating a TDrawFeedback object; attached to the session. Feedback for the specified objects is disabled; at the end of the query and the created TDrawFeedback is destroyed. The; special name 'stats' enables the three feedback histograms required by; a dedicated new class TStatsFeedback, and uses a TStatsFeedback instead; of TDrawFeedback to display the feedback. . Improvements; ; Add to TProofMgr two static functions to upload files. These; functions are both called UploadFiles and differ in the first argument,; which is used to pass the files to be uploaded. These can be given as a; list (of TFileInfo or TObjString), a directory or specified in a text; file.; Add support for paralell dataset verification. This is; implemented via a dedicated TSelector (TSelVerifyDataSet) which is run;",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/doc/v534/index.html:1880,feedback,feedback,1880,proof/doc/v534/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/doc/v534/index.html,1,['feedback'],['feedback']
Usability,"naturally, and the store automagically sees reachable symbols, live; symbols, escapes, invalidations, whatever. > In my view this differs from ghost variables in that (1) this storage does; > actually exist (it is just a library implementation detail where that storage; > lives) and (2) it is perfectly valid for a pointer into that storage to be; > returned and for another part of the program to read or write from that; > storage. (Well, in this case just read since it is allowed to be read-only; > memory). > What I'm not OK with is modeling abstract analysis state (for example, the; > count of a NSMutableArray or the typestate of a file handle) as a value stored; > in some ginned up region in the store.This takes an easy problem that the; > analyzer does well at (modeling typestate) and turns it into a hard one that; > the analyzer is bad at (reasoning about the contents of the heap). Yeah, i tend to agree on that. For simple typestates, this is probably an; overkill, so let's definitely put aside the idea of ""ghost symbolic regions""; that i had earlier. But, to summarize a bit, in our current case, however, the typestate we're; looking for is the contents of the heap. And when we try to model such; typestates (complex in this specific manner, i.e. heap-like) in any checker, we; have a choice between re-doing this modeling in every such checker (which is; something analyzer is indeed good at, but at a price of making checkers heavy); or instead relying on the Store to do exactly what it's designed to do. > I think the key criterion here is: ""is the region accessible from outside; > the library"". That is, does the library expose the region as a pointer that; > can be read to or written from in the client program? If so, then it makes; > sense for this to be in the store: we are modeling reachable storage as; > storage. But if we're just modeling arbitrary analysis facts that need to be; > invalidated when a pointer escapes then we shouldn't try to gin up storage; > ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/InitializerLists.rst:14757,simpl,simple,14757,interpreter/llvm-project/clang/docs/analyzer/developer-docs/InitializerLists.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/InitializerLists.rst,1,['simpl'],['simple']
Usability,"nc-continuation lowering, signaled by the use of `llvm.coro.id.async`,; handling of control-flow must be handled explicitly by the frontend. In this lowering, a coroutine is assumed to take the current `async context` as; one of its arguments (the argument position is determined by; `llvm.coro.id.async`). It is used to marshal arguments and return values of the; coroutine. Therefore an async coroutine returns `void`. .. code-block:: llvm. define swiftcc void @async_coroutine(ptr %async.ctxt, ptr, ptr) {; }. Values live across a suspend point need to be stored in the coroutine frame to; be available in the continuation function. This frame is stored as a tail to the; `async context`. Every suspend point takes an `context projection function` argument which; describes how-to obtain the continuations `async context` and every suspend; point has an associated `resume function` denoted by the; `llvm.coro.async.resume` intrinsic. The coroutine is resumed by calling this; `resume function` passing the `async context` as the one of its arguments; argument. The `resume function` can restore its (the caller's) `async context`; by applying a `context projection function` that is provided by the frontend as; a parameter to the `llvm.coro.suspend.async` intrinsic. .. code-block:: c. // For example:; struct async_context {; struct async_context *caller_context;; ...; }. char *context_projection_function(struct async_context *callee_ctxt) {; return callee_ctxt->caller_context;; }. .. code-block:: llvm. %resume_func_ptr = call ptr @llvm.coro.async.resume(); call {ptr, ptr, ptr} (ptr, ptr, ...) @llvm.coro.suspend.async(; ptr %resume_func_ptr,; ptr %context_projection_function. The frontend should provide a `async function pointer` struct associated with; each async coroutine by `llvm.coro.id.async`'s argument. The initial size and; alignment of the `async context` must be provided as arguments to the; `llvm.coro.id.async` intrinsic. Lowering will update the size entry with the; corou",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst:8641,resume,resumed,8641,interpreter/llvm-project/llvm/docs/Coroutines.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst,2,['resume'],"['resume', 'resumed']"
Usability,"nction CFG or a subgraph of it, a *cycle*; is a maximal strongly connected region with at least one internal edge.; (Informational note --- The requirement for at least one internal edge; ensures that a single basic block is a cycle only if there is an edge; that goes back to the same basic block.); 2. A basic block in a cycle that can be reached from the entry of; the function along a path that does not visit any other basic block; in the cycle is called an *entry* of the cycle.; A cycle can have multiple entries.; 3. For a given depth-first search starting from the entry of the function, the; first node of a cycle to be visited is called the *header* of this cycle; with respect to this particular DFS. The header is always an entry node.; 4. In any depth-first search starting from the entry, the set of cycles; found in the CFG is the same. These are the *top-level cycles*; that do not themselves have a parent.; 5. The *child cycles* (or simply cycles) nested inside a cycle C with; header H are the cycles in the subgraph induced on the set of nodes (C - H).; C is said to be the *parent* of these cycles. Thus, cycles form an implementation-defined forest where each cycle C is; the parent of any child cycles nested inside C. The tree closely; follows the nesting of loops in the same function. The unique entry of; a reducible cycle (an LLVM loop) L dominates all its other nodes, and; is always chosen as the header of some cycle C regardless of the DFS; tree used. This cycle C is a superset of the loop L. For an; irreducible cycle, no one entry dominates the nodes of the cycle. One; of the entries is chosen as header of the cycle, in an; implementation-defined way. .. _cycle-irreducible:. A cycle is *irreducible* if it has multiple entries and it is; *reducible* otherwise. .. _cycle-parent-block:. A cycle C is said to be the *parent* of a basic block B if B occurs in; C but not in any child cycle of C. Then B is also said to be a *child*; of cycle C. .. _cycle-toplevel-b",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CycleTerminology.rst:1267,simpl,simply,1267,interpreter/llvm-project/llvm/docs/CycleTerminology.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CycleTerminology.rst,1,['simpl'],['simply']
Usability,"nction is split; out into some number of ""resume functions"". Any state which must persist; across suspensions is stored in the coroutine frame. The resume functions; must somehow be able to handle either a ""normal"" resumption, which continues; the normal execution of the coroutine, or an ""abnormal"" resumption, which; must unwind the coroutine without attempting to suspend it. Switched-Resume Lowering; ------------------------. In LLVM's standard switched-resume lowering, signaled by the use of; `llvm.coro.id`, the coroutine frame is stored as part of a ""coroutine; object"" which represents a handle to a particular invocation of the; coroutine. All coroutine objects support a common ABI allowing certain; features to be used without knowing anything about the coroutine's; implementation:. - A coroutine object can be queried to see if it has reached completion; with `llvm.coro.done`. - A coroutine object can be resumed normally if it has not already reached; completion with `llvm.coro.resume`. - A coroutine object can be destroyed, invalidating the coroutine object,; with `llvm.coro.destroy`. This must be done separately even if the; coroutine has reached completion normally. - ""Promise"" storage, which is known to have a certain size and alignment,; can be projected out of the coroutine object with `llvm.coro.promise`.; The coroutine implementation must have been compiled to define a promise; of the same size and alignment. In general, interacting with a coroutine object in any of these ways while; it is running has undefined behavior. The coroutine function is split into three functions, representing three; different ways that control can enter the coroutine:. 1. the ramp function that is initially invoked, which takes arbitrary; arguments and returns a pointer to the coroutine object;. 2. a coroutine resume function that is invoked when the coroutine is resumed,; which takes a pointer to the coroutine object and returns `void`;. 3. a coroutine destroy function that is",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst:3157,resume,resume,3157,interpreter/llvm-project/llvm/docs/Coroutines.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst,1,['resume'],['resume']
Usability,"nction, place your function call in a; scope and after the scope ends, the loop will also end. - `addToCodeBody()` helps add things to the body of the C++ function that; you're creating. It takes whatever string is computed in its arguments and; adds it to the overall function string (which will later be just-in-time; compiled). The `addToCodeBody()` function is important since not everything; can be added in-line and this function helps split the code into multiple; lines. ### Step 3. analyticalIntegral() Use Case. > Besides the `evaluate()` function, this tutorial illustrates how the; `analyticalIntegral()` can be updated. This highly dependent on the class that; is being transformed for AD support, but will be necessary in those specific; instances. Let's consider a fictional class RooFoo, that performs some arbitrary; mathematical operations called 'Foo' (as seen in doFoo() function below). > Note that doFoo is a simplified example, in many cases the mathematical; operations are not limited to a single function, so they need to be spotted; within the `evaluate()` function. ``` {.cpp}; class RooFoo : public RooAbsReal {; int a;; int b;; int doFoo() { return a* b + a + b; }; int integralFoo() { return /* whatever */;}; public:; // Other functions...; double evaluate() override {; // Do some bookkeeping; return doFoo();; };; double analyticalIntegral(Int_t code, const char* rangeName) override {; // Select the right paths for integration using codes or whatever.; return integralFoo();; }; };; ```. \note All RooFit classes are deriving from the RooAbsReal object, but; its details are not relevant to the current example. Note how the `evaluate()` function overrides the `RooAbsReal` for the RooFoo; class. Similarly, the `analyticalIntegral()` function has also been overridden; from the `RooAbsReal` class. The `evaluate()` function includes some bookkeeping steps (commented out in; above example) that are not relevant to AD. The important part is that it; calls a speci",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/developers/roofit_ad.md:19156,simpl,simplified,19156,roofit/doc/developers/roofit_ad.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/developers/roofit_ad.md,1,['simpl'],['simplified']
Usability,"nd SPARC. The backend may also be used to generate code targeted at SPUs; of the Cell processor or GPUs to support the execution of compute kernels. The document focuses on existing examples found in subdirectories of; ``llvm/lib/Target`` in a downloaded LLVM release. In particular, this document; focuses on the example of creating a static compiler (one that emits text; assembly) for a SPARC target, because SPARC has fairly standard; characteristics, such as a RISC instruction set and straightforward calling; conventions. Audience; --------. The audience for this document is anyone who needs to write an LLVM backend to; generate code for a specific hardware or software target. Prerequisite Reading; --------------------. These essential documents must be read before reading this document:. * `LLVM Language Reference Manual <LangRef.html>`_ --- a reference manual for; the LLVM assembly language. * :doc:`CodeGenerator` --- a guide to the components (classes and code; generation algorithms) for translating the LLVM internal representation into; machine code for a specified target. Pay particular attention to the; descriptions of code generation stages: Instruction Selection, Scheduling and; Formation, SSA-based Optimization, Register Allocation, Prolog/Epilog Code; Insertion, Late Machine Code Optimizations, and Code Emission. * :doc:`TableGen/index` --- a document that describes the TableGen; (``tblgen``) application that manages domain-specific information to support; LLVM code generation. TableGen processes input from a target description; file (``.td`` suffix) and generates C++ code that can be used for code; generation. * :doc:`WritingAnLLVMPass` --- The assembly printer is a ``FunctionPass``, as; are several ``SelectionDAG`` processing steps. To follow the SPARC examples in this document, have a copy of `The SPARC; Architecture Manual, Version 8 <http://www.sparc.org/standards/V8.pdf>`_ for; reference. For details about the ARM instruction set, refer to the `ARM; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/WritingAnLLVMBackend.rst:1566,guid,guide,1566,interpreter/llvm-project/llvm/docs/WritingAnLLVMBackend.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/WritingAnLLVMBackend.rst,1,['guid'],['guide']
Usability,"nd it much easier than the C syntax.; > In either case, I would have to look up an example to write pointers to; > member functions. I would argue that because the lexical structure of the language is self; consistent, any person who spent a significant amount of time programming; in LLVM directly would understand how to do it without looking it up in a; manual. The reason this does not work for C is because you rarely have to; declare these pointers, and the syntax is inconsistent with the method; declaration and calling syntax. > But pointers to member functions are nowhere near as common as arrays. Very true. If you're implementing an object oriented language, however,; remember that you have to do all the pointer to member function stuff; yourself.... so every time you invoke a virtual method one is involved; (instead of having C++ hide it for you behind ""syntactic sugar""). > And the old array syntax:; > type [ int, int, ...]; > is just much more familiar and clear to people than anything new you; > introduce, no matter how logical it is. . Erm... excuse me but how is this the ""old array syntax""? If you are; arguing for consistency with C, you should be asking for 'type int []',; which is significantly different than the above (beside the above; introduces a new operator and duplicates information; needlessly). Basically what I am suggesting is exactly the above without; the fluff. So instead of:. type [ int, int, ...]. you use:. type [ int ]. > Introducing a new syntax that may; > make function pointers easier but makes arrays much more difficult seems; > very risky to me. This is not about function pointers. This is about consistency in the; type system, and consistency with the rest of the language. The point; above does not make arrays any more difficult to use, and makes the; structure of types much more obvious than the ""c way"". > > In my opinion, it is critically important to have clear and concise type; > > specifications, because types are going to be a",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HistoricalNotes/2001-02-06-TypeNotationDebateResp4.txt:2574,clear,clear,2574,interpreter/llvm-project/llvm/docs/HistoricalNotes/2001-02-06-TypeNotationDebateResp4.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HistoricalNotes/2001-02-06-TypeNotationDebateResp4.txt,1,['clear'],['clear']
Usability,"nd leave out the x-points, the diagram will look like this:. ## 3D Graphics Libraries. ## Geometry Libraries. - Support with web geometry viewer image production in batch mode. Just do:; ```; ROOT::Experimental::RGeomViewer viewer(geom);; viewer.SaveImage(""rootgeom.jpeg"", 800, 600);; ```; This runs normal WebGL rendering in headless web browser (Chrome or Firefox) and; creates png or jpeg image out of it. ## Database Libraries. ## Networking Libraries. ### THttpServer. - upgrade civetweb code to version 1.15, supports SSL version 3.0; - resolve problem with symbolic links usage on Windows; - let disable/enable directory files listing via THttpServer (default is off); - enable usage of unix sockets, used by `rootssh` script for tunnel to remote session. ## GUI Libraries. - Provide web-based TTree viewer, integrated with RBrowser; - Support Edge browser on Windows for all kinds of web widgets; - Provide `rootssh` shell script to simplify use of web-based widgets on remote nodes:; ```; [localnode] rootssh user@remotenode; [remotenode] root --web -e 'new TBrowser'; ```; Script automatically configures ssh tunnel between local and remote nodes, one the remote node; unix socket with strict 0700 mode is used. When ROOT running on remote node wants to display; new web widget, script will automatically start web browser on local node with appropriate URL,; accessing widget via configured ssh tunnel. ## Montecarlo Libraries. ## PROOF Libraries. ## Language Bindings. ## JavaScript ROOT. - Major JSROOT upgrade to version 7, using ES6 modules and classes. ## Tutorials. - Several new tutorials have been added in both C++ and Python in the `tutorial/tmva` directory.; Tutorials like `TMVA_Higgs_Classification.py` shows the new pythonizations available in TMVA and; new `TMVA_SOFIE_...` tutorials show th eusage of SOFIE in both C++ or Python. ## Class Reference Guide. ## Build, Configuration and Testing Infrastructure. - Building external applications that use ROOT oftentimes fail if ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v628/index.md:32266,simpl,simplify,32266,README/ReleaseNotes/v628/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v628/index.md,1,['simpl'],['simplify']
Usability,"nd nested tuple) is the experimental evolution of TTree columnar data storage. RNTuple introduces; new interfaces that aim to be more robust. In particular, the new interfaces are type-safe through the use of; templates, and the ownership is well-defined through the use of smart pointers. For instance. tree->Branch(""px"", &Category, ""px/F"");. becomes. auto px = model->MakeField<float>(""px"");; // px is std::shared_ptr<float>. The physical layout changes slightly from big endian to little endian so that it matches the in-memory layout on; most modern architectures. Combined with a clear separation of offset/index data and payload data for collections,; uncompressed RNTuple data can be directly mapped to memory without further copies. Goals; -----. RNTuple shall investigate improvements of the TTree I/O in the following ways. 1. More speed; * Improve mapping to vectorized and parallel hardware; * For types known at compile / JIT time: generate optimized code; * Optimized for simple types (float, int, and vectors of them); * Better memory control: work with a fixed budget of pre-defined I/O buffers; * Naturally thread-safe and asynchronous interfaces. 2. More robust interfaces; * Compile-time type safety by default; * Decomposition into layers: logical layer, primitives layer, storage layer; * Separation of data model and live data; * Self-contained I/O code to support creation of a standalone I/O library. Concepts; --------. At the **logical layer**, the user defines a data model using the RNTupleModel class.; The data model is a collection of serializable C++ types with associated names, similar to branches in a TTree.; The data model can contain (nested) collections, e.g., a type can be `std::vector<std::vector<float>>`. Each serializable type is represented by a **field**, concretely by a templated version of RField,; e.g. `RField<double>`. A field can generate or adopt an associated **value**, which represents a memory location; storing a value of the given C++ type",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/doc/README.md:1052,simpl,simple,1052,tree/ntuple/v7/doc/README.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/doc/README.md,1,['simpl'],['simple']
Usability,"nd properties of the window used for our plot, and `TLegend` to; add a nice legend. For the moment, ignore the commented include; statements for header files, they will only become important at the end; in section [Interpretation and Compilation](#interpretation-and-compilation). ``` {.cpp .numberLines}; @ROOT_INCLUDE_FILE macros/macro1.C; ```. Let's comment it in detail:. - Line *13*: the name of the principal function (it plays the role of; the ""main"" function in compiled programs) in the macro file. It has; to be the same as the file name without extension. - Line *24-25*: instance of the `TGraphErrors` class. The constructor; takes the number of points and the pointers to the arrays of; x values, y values, x errors (in this case none,; represented by the NULL pointer) and y errors. The second line; defines in one shot the title of the graph and the titles of the two; axes, separated by a "";"". - Line *28-30*: These three lines are rather intuitive right ? To understand; better the enumerators for colours and styles see the reference for; the `TColor` and `TMarker` classes. - Line *33*: the canvas object that will host the drawn objects. The; ""memory leak"" is intentional, to make the object existing also out; of the macro1 scope. - Line *36*: the method *DrawClone* draws a clone of the object on the; canvas. It *has to be* a clone, to survive after the scope of; `macro1`, and be displayed on screen after the end of the macro; execution. The string option ""APE"" stands for:. - *A* imposes the drawing of the Axes. - *P* imposes the drawing of the graph's markers. - *E* imposes the drawing of the graph's error bars. - Line *39*: define a mathematical function. There are several ways to; accomplish this, but in this case the constructor accepts the name; of the function, the formula, and the function range. - Line *41*: maquillage. Try to give a look to the line styles at your; disposal visiting the documentation of the `TLine` class. - Line *43*: fits the *f* function ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/your_first_ROOT_macro.md:4069,intuit,intuitive,4069,documentation/primer/your_first_ROOT_macro.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/your_first_ROOT_macro.md,1,['intuit'],['intuitive']
Usability,"nd the objects, previously drawn or not; drawn, through the `addEntry` method. Observe how the legend is; drawn at the end: looks familiar now, right ?. - Line *55-57*: defines an arrow with a triangle on the right hand; side, a thickness of 2 and draws it. - Line *60-61*: interpret a Latex string which hast its lower left; corner located in the specified coordinate. The `#splitline{}{}`; construct allows to store multiple lines in the same `TLatex`; object. - Line *63*: save the canvas as image. The format is automatically; inferred from the file extension (it could have been eps, gif, ...). Let's give a look to the obtained plot in Figure [3.1](#f31). Beautiful; outcome for such a small bunch of lines, isn't it ?. [f31]: figures/graf_with_law.png ""f31""; <a name=""f31""></a>. ![Your first plot with data points, a fit of an analytical function, a; legend and some additional information in the form of graphics; primitives and text. A well formatted plot, clear for the reader is; crucial to communicate the relevance of your results to the; reader.\label{f31}][f31]. ## Summary of Visual effects. ### Colours and Graph Markers. We have seen that to specify a colour, some identifiers like kWhite,; kRed or kBlue can be specified for markers, lines, arrows etc. The; complete summary of colours is represented by the ROOT ""[colour; wheel](https://root.cern.ch/doc/master/classTColor.html#C02)"". To know more; about the full story, refer to the online documentation of `TColor`. ROOT provides several [graphics; markers](https://root.cern.ch/doc/master/classTAttMarker.html#M2) types. Select; the most suited symbols for your plot among dots, triangles, crosses or; stars. An alternative set of names for the markers is available. ### Arrows and Lines. The macro line *55* shows how to define an arrow and draw it. The class; representing arrows is `TArrow`, which inherits from `TLine`. The; constructors of lines and arrows always contain the coordinates of the; endpoints. Arrows also fore",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/your_first_ROOT_macro.md:6861,clear,clear,6861,documentation/primer/your_first_ROOT_macro.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/your_first_ROOT_macro.md,1,['clear'],['clear']
Usability,"nd; surface removal algorithms, OpenGL viewing\* or ray tracing. The method `TGeoManager::GetGeomPainter()`loads the painting library in; memory. This is generally not needed since it is called automatically by; `TGeoVolume::Draw()` as well as by few other methods setting; visualization attributes. ### Drawing Volumes and Hierarchies of Volumes. The first thing one would like to do after building some geometry is to; visualize the volume tree. This provides the fastest validation check; for most common coding or design mistakes. As soon as the geometry is; successfully closed, one should draw it starting from the top-level; volume:. ``` {.cpp}; //... code for geometry building; root[] gGeoManager->CloseGeometry();; root[] gGeoManager->GetMasterVolume()->Draw();; ```. Doing this ensures that the original top-level volume of the geometry is; drawn, even if another volume is currently the geometry `root`. OK, I; suppose you already did that with your simple geometry and immediately; noticed a new ROOT canvas popping-up and having some more or less; strange picture inside. Here are few questions that might come:. ***`Q:`*** ""The picture is strangely rotated; where are the coordinate axes?"". ***`A:`*** If drawn in a new canvas, any view has some default; viewpoint, center of view and size. One can then perform mouse/keyboard; actions to change them:. - Mouse left-click and drag will rotate the view;. - Some keys can be pressed when the view canvas is selected: J/K; zoom/un-zoom, U/I move up/down, L/H move left/right. The coordinate axes; display as well as changing top or side viewpoints can be activated from; the **`TView`** context menu: right-click on the picture when no object; is selected;. ***`Q:`*** ""Every line is black! I cannot figure out what is what..."". ***`A:`*** Volumes can have different colors (those known by ROOT of; course). Think at using them after each volume creation:; `myvolume->SetLineColor(Int_t color);` otherwise everything is by; default black.",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:137995,simpl,simple,137995,documentation/users-guide/Geometry.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md,1,['simpl'],['simple']
Usability,"nd; visualizing CFGs. For example, the method ``CFG::dump()`` dumps a; pretty-printed version of the CFG to standard error. This is especially useful; when one is using a debugger such as gdb. For example, here is the output of; ``FooCFG->dump()``:. .. code-block:: text. [ B5 (ENTRY) ]; Predecessors (0):; Successors (1): B4. [ B4 ]; 1: x = x + 1; 2: (x > 2); T: if [B4.2]; Predecessors (1): B5; Successors (2): B3 B2. [ B3 ]; 1: x++; Predecessors (1): B4; Successors (1): B1. [ B2 ]; 1: x += 2; 2: x *= 2; Predecessors (1): B4; Successors (1): B1. [ B1 ]; 1: return x;; Predecessors (2): B2 B3; Successors (1): B0. [ B0 (EXIT) ]; Predecessors (1): B1; Successors (0):. For each block, the pretty-printed output displays for each block the number of; *predecessor* blocks (blocks that have outgoing control-flow to the given; block) and *successor* blocks (blocks that have control-flow that have incoming; control-flow from the given block). We can also clearly see the special entry; and exit blocks at the beginning and end of the pretty-printed output. For the; entry block (block B5), the number of predecessor blocks is 0, while for the; exit block (block B0) the number of successor blocks is 0. The most interesting block here is B4, whose outgoing control-flow represents; the branching caused by the sole if-statement in ``foo``. Of particular; interest is the second statement in the block, ``(x > 2)``, and the terminator,; printed as ``if [B4.2]``. The second statement represents the evaluation of; the condition of the if-statement, which occurs before the actual branching of; control-flow. Within the ``CFGBlock`` for B4, the ``Stmt*`` for the second; statement refers to the actual expression in the AST for ``(x > 2)``. Thus; pointers to subclasses of ``Expr`` can appear in the list of statements in a; block, and not just subclasses of ``Stmt`` that refer to proper C statements. The terminator of block B4 is a pointer to the ``IfStmt`` object in the AST.; The pretty-printer o",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:116307,clear,clearly,116307,interpreter/llvm-project/clang/docs/InternalsManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst,1,['clear'],['clearly']
Usability,"ndamental assumptions about the; underlying architecture other than the ability to do branchless conditional; data updates and a lack of value prediction.; * It does not require programmers to identify all possible secret data using; static source code annotations or code vulnerable to a variant #1 style; attack. Limitations of this approach:; * It requires re-compiling source code to insert hardening instruction; sequences. Only software compiled in this mode is protected.; * The performance is heavily dependent on a particular architecture's; implementation strategy. We outline a potential x86 implementation below and; characterize its performance.; * It does not defend against secret data already loaded from memory and; residing in registers or leaked through other side-channels in; non-speculative execution. Code dealing with this, e.g cryptographic; routines, already uses constant-time algorithms and code to prevent; side-channels. Such code should also scrub registers of secret data following; [these; guidelines](https://github.com/HACS-workshop/spectre-mitigations/blob/master/crypto_guidelines.md).; * To achieve reasonable performance, many loads may not be checked, such as; those with compile-time fixed addresses. This primarily consists of accesses; at compile-time constant offsets of global and local variables. Code which; needs this protection and intentionally stores secret data must ensure the; memory regions used for secret data are necessarily dynamic mappings or heap; allocations. This is an area which can be tuned to provide more comprehensive; protection at the cost of performance.; * [Hardened loads](#hardening-the-address-of-the-load) may still load data from; _valid_ addresses if not _attacker-controlled_ addresses. To prevent these; from reading secret data, the low 2gb of the address space and 2gb above and; below any executable pages should be protected. Credit:; * The core idea of tracing misspeculation through data and marking pointers to; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SpeculativeLoadHardening.md:7074,guid,guidelines,7074,interpreter/llvm-project/llvm/docs/SpeculativeLoadHardening.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SpeculativeLoadHardening.md,1,['guid'],['guidelines']
Usability,"nder `clang/tools/clang-format/clang-format.py`. This can be integrated by adding the following to your `.vimrc`:. .. code-block:: vim. if has('python'); map <C-K> :pyf <path-to-this-file>/clang-format.py<cr>; imap <C-K> <c-o>:pyf <path-to-this-file>/clang-format.py<cr>; elseif has('python3'); map <C-K> :py3f <path-to-this-file>/clang-format.py<cr>; imap <C-K> <c-o>:py3f <path-to-this-file>/clang-format.py<cr>; endif. The first line enables :program:`clang-format` for NORMAL and VISUAL mode, the; second line adds support for INSERT mode. Change ""C-K"" to another binding if; you need :program:`clang-format` on a different key (C-K stands for Ctrl+k). With this integration you can press the bound key and clang-format will; format the current line in NORMAL and INSERT mode or the selected region in; VISUAL mode. The line or region is extended to the next bigger syntactic; entity. It operates on the current, potentially unsaved buffer and does not create; or save any files. To revert a formatting, just undo. An alternative option is to format changes when saving a file and thus to; have a zero-effort integration into the coding workflow. To do this, add this to; your `.vimrc`:. .. code-block:: vim. function! Formatonsave(); let l:formatdiff = 1; pyf <path-to-this-file>/clang-format.py; endfunction; autocmd BufWritePre *.h,*.cc,*.cpp call Formatonsave(). Emacs Integration; =================. Similar to the integration for :program:`vim`, there is an integration for; :program:`emacs`. It can be found at `clang/tools/clang-format/clang-format.el`; and used by adding this to your `.emacs`:. .. code-block:: common-lisp. (load ""<path-to-clang>/tools/clang-format/clang-format.el""); (global-set-key [C-M-tab] 'clang-format-region). This binds the function `clang-format-region` to C-M-tab, which then formats the; current line or selected region. BBEdit Integration; ==================. :program:`clang-format` cannot be used as a text filter with BBEdit, but works; well via a script.",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormat.rst:7604,undo,undo,7604,interpreter/llvm-project/clang/docs/ClangFormat.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormat.rst,1,['undo'],['undo']
Usability,"nderlying data itself. A requirement is that if data is loaded and then saved again (called a ""round trip""), the memory contents should be the same after the store as before the load. If a vector is loaded and is then bitconverted to a different vector type before storing, the round trip will currently be broken. Take for example this code sequence::. %0 = load <4 x i32> %x; %1 = bitcast <4 x i32> %0 to <2 x i64>; store <2 x i64> %1, <2 x i64>* %y. This would produce a code sequence such as that in the figure on the right. The mismatched ``LD1`` and ``ST1`` cause the stored data to differ from the loaded data. .. container:: clearer. When we see a bitcast from type ``X`` to type ``Y``, what we need to do is to change the in-register representation of the data to be *as if* it had just been loaded by a ``LD1`` of type ``Y``. .. image:: ARM-BE-bitcastsuccess.png; :align: right. Conceptually this is simple - we can insert a ``REV`` undoing the ``LD1`` of type ``X`` (converting the in-register representation to the same as if it had been loaded by ``LDR``) and then insert another ``REV`` to change the representation to be as if it had been loaded by an ``LD1`` of type ``Y``. For the previous example, this would be::. LD1 v0.4s, [x]. REV64 v0.4s, v0.4s // There is no REV128 instruction, so it must be synthesizedcd; EXT v0.16b, v0.16b, v0.16b, #8 // with a REV64 then an EXT to swap the two 64-bit elements. REV64 v0.2d, v0.2d; EXT v0.16b, v0.16b, v0.16b, #8. ST1 v0.2d, [y]. It turns out that these ``REV`` pairs can, in almost all cases, be squashed together into a single ``REV``. For the example above, a ``REV128 4s`` + ``REV128 2d`` is actually a ``REV64 4s``, as shown in the figure on the right. .. [1] One lane vectors may seem useless as a concept but they serve to distinguish between values held in general purpose registers and values held in NEON/VFP registers. For example, an ``i64`` would live in an ``x`` register, but ``<1 x i64>`` would live in a ``d`` register.; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/BigEndianNEON.rst:10944,simpl,simple,10944,interpreter/llvm-project/llvm/docs/BigEndianNEON.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/BigEndianNEON.rst,2,"['simpl', 'undo']","['simple', 'undoing']"
Usability,"nding, enhancing, or bug fixing already implemented code,; use the style that is already being used so that the source is uniform and; easy to follow.**. Note that some code bases (e.g. ``libc++``) have special reasons to deviate; from the coding standards. For example, in the case of ``libc++``, this is; because the naming and other conventions are dictated by the C++ standard. There are some conventions that are not uniformly followed in the code base; (e.g. the naming convention). This is because they are relatively new, and a; lot of code was written before they were put in place. Our long term goal is; for the entire codebase to follow the convention, but we explicitly *do not*; want patches that do large-scale reformatting of existing code. On the other; hand, it is reasonable to rename the methods of a class if you're about to; change it in some other way. Please commit such changes separately to; make code review easier. The ultimate goal of these guidelines is to increase the readability and; maintainability of our common source base. Languages, Libraries, and Standards; ===================================. Most source code in LLVM and other LLVM projects using these coding standards; is C++ code. There are some places where C code is used either due to; environment restrictions, historical restrictions, or due to third-party source; code imported into the tree. Generally, our preference is for standards; conforming, modern, and portable C++ code as the implementation language of; choice. For automation, build-systems and utility scripts Python is preferred and; is widely used in the LLVM repository already. C++ Standard Versions; ---------------------. Unless otherwise documented, LLVM subprojects are written using standard C++17; code and avoid unnecessary vendor-specific extensions. Nevertheless, we restrict ourselves to features which are available in the; major toolchains supported as host compilers (see :doc:`GettingStarted` page,; section `Software`).",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodingStandards.rst:1620,guid,guidelines,1620,interpreter/llvm-project/llvm/docs/CodingStandards.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodingStandards.rst,1,['guid'],['guidelines']
Usability,"ndows for querying debug information from; PDBs even without the user understanding the internals of the file format, a; large ecosystem of tools has been built for Windows to consume this format. In; order for Clang to be able to generate programs that can interoperate with these; tools, it is necessary for us to generate PDB files ourselves. At the same time, LLVM has a long history of being able to cross-compile from; any platform to any platform, and we wish for the same to be true here. So it; is necessary for us to understand the PDB file format at the byte-level so that; we can generate PDB files entirely on our own. This manual describes what we know about the PDB file format today. The layout; of the file, the various streams contained within, the format of individual; records within, and more. We would like to extend our heartfelt gratitude to Microsoft, without whom we; would not be where we are today. Much of the knowledge contained within this; manual was learned through reading code published by Microsoft on their `GitHub; repo <https://github.com/Microsoft/microsoft-pdb>`__. .. _pdb_layout:. File Layout; ===========. .. important::; Unless otherwise specified, all numeric values are encoded in little endian.; If you see a type such as ``uint16_t`` or ``uint64_t`` going forward, always; assume it is little endian!. .. toctree::; :hidden:. MsfFile; PdbStream; TpiStream; DbiStream; ModiStream; PublicStream; GlobalStream; HashTable; CodeViewSymbols; CodeViewTypes. .. _msf:. The MSF Container; -----------------; A PDB file is an MSF (Multi-Stream Format) file. An MSF file is a ""file system; within a file"". It contains multiple streams (aka files) which can represent; arbitrary data, and these streams are divided into blocks which may not; necessarily be contiguously laid out within the MSF container file.; Additionally, the MSF contains a stream directory (aka MFT) which describes how; the streams (files) are laid out within the MSF. For more information a",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/PDB/index.rst:1345,learn,learned,1345,interpreter/llvm-project/llvm/docs/PDB/index.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/PDB/index.rst,1,['learn'],['learned']
Usability,"nds checks:; // if (p + i < p || p + i + 1 > p + count) trap();; p[i] = i;; }; }. ``ConstraintElimination`` collects the following facts and determines if the; bounds checks can be safely removed:. * Inside the for-loop, ``0 <= i < count``, hence ``1 <= i + 1 <= count``.; * Pointer arithmetic ``p + count`` in the if-condition doesn’t wrap.; * ``-fbounds-safety`` treats pointer arithmetic overflow as deterministically; two’s complement computation, not an undefined behavior. Therefore,; getelementptr does not typically have inbounds keyword. However, the compiler; does emit inbounds for ``p + count`` in this case because; ``__counted_by(count)`` has the invariant that p has at least as many as; elements as count. Using this information, ``ConstraintElimination`` is able; to determine ``p + count`` doesn’t wrap.; * Accordingly, ``p + i`` and ``p + i + 1`` also don’t wrap.; * Therefore, ``p <= p + i`` and ``p + i + 1 <= p + count``.; * The if-condition simplifies to false and becomes dead code that the subsequent; optimization passes can remove. ``OptRemarks`` can be utilized to provide insights into performance tuning. It; has the capability to report on checks that it cannot eliminate, possibly with; reasons, allowing programmers to adjust their code to unlock further; optimizations. Debugging; =========. Internal bounds annotations; ---------------------------. Internal bounds annotations change a pointer into a wide pointer. The debugger; needs to understand that wide pointers are essentially pointers with a struct; layout. To handle this, a wide pointer is described as a record type in the; debug info. The type name has a special name prefix (e.g.,; ``__bounds_safety$bidi_indexable``) which can be recognized by a debug info; consumer to provide support that goes beyond showing the internal structure of; the wide pointer. There are no DWARF extensions needed to support wide pointers.; In our implementation, LLDB recognizes wide pointer types by name and; reconstruct",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafetyImplPlans.rst:7860,simpl,simplifies,7860,interpreter/llvm-project/clang/docs/BoundsSafetyImplPlans.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafetyImplPlans.rst,1,['simpl'],['simplifies']
Usability,"ne that has more than one suspend point:. .. code-block:: c++. void *f(int n) {; for(;;) {; print(n++);; <suspend>; print(-n);; <suspend>; }; }. Matching LLVM code would look like (with the rest of the code remaining the same; as the code in the previous section):. .. code-block:: llvm. loop:; %n.addr = phi i32 [ %n, %entry ], [ %inc, %loop.resume ]; call void @print(i32 %n.addr) #4; %2 = call i8 @llvm.coro.suspend(token none, i1 false); switch i8 %2, label %suspend [i8 0, label %loop.resume; i8 1, label %cleanup]; loop.resume:; %inc = add nsw i32 %n.addr, 1; %sub = xor i32 %n.addr, -1; call void @print(i32 %sub); %3 = call i8 @llvm.coro.suspend(token none, i1 false); switch i8 %3, label %suspend [i8 0, label %loop; i8 1, label %cleanup]. In this case, the coroutine frame would include a suspend index that will; indicate at which suspend point the coroutine needs to resume. .. code-block:: llvm. %f.frame = type { ptr, ptr, i32, i32 }. The resume function will use an index to jump to an appropriate basic block and will look; as follows:. .. code-block:: llvm. define internal fastcc void @f.Resume(ptr %FramePtr) {; entry.Resume:; %index.addr = getelementptr inbounds %f.Frame, ptr %FramePtr, i64 0, i32 2; %index = load i8, ptr %index.addr, align 1; %switch = icmp eq i8 %index, 0; %n.addr = getelementptr inbounds %f.Frame, ptr %FramePtr, i64 0, i32 3; %n = load i32, ptr %n.addr, align 4. br i1 %switch, label %loop.resume, label %loop. loop.resume:; %sub = sub nsw i32 0, %n; call void @print(i32 %sub); br label %suspend; loop:; %inc = add nsw i32 %n, 1; store i32 %inc, ptr %n.addr, align 4; tail call void @print(i32 %inc); br label %suspend. suspend:; %storemerge = phi i8 [ 0, %loop ], [ 1, %loop.resume ]; store i8 %storemerge, ptr %index.addr, align 1; ret void; }. If different cleanup code needs to get executed for different suspend points,; a similar switch will be in the `f.destroy` function. .. note ::. Using suspend index in a coroutine state and having a switch in",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst:18996,resume,resume,18996,interpreter/llvm-project/llvm/docs/Coroutines.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst,1,['resume'],['resume']
Usability,"ne to access information in the file; and draw the previously written histogram:. ``` {.cpp}; > root my_rootfile.root; root [0]; Attaching file my_rootfile.root as _file0...; root [1] _file0->ls(); TFile** my_rootfile.root; TFile* my_rootfile.root; KEY: TH1F	my_histogram;1 My Title; root [2] my_histogram->Draw(); ```; \newpage; Alternatively, you can use a simple macro to carry out the job:. ``` {.cpp}; @ROOT_INCLUDE_FILE macros/read_from_file.C; ```. ## N-tuples in ROOT ##. ### Storing simple N-tuples ###. Up to now we have seen how to manipulate input read from ASCII files.; ROOT offers the possibility to do much better than that, with its own; n-tuple classes. Among the many advantages provided by these classes one; could cite. - Optimised disk I/O. - Possibility to store many n-tuple rows. - Write the n-tuples in ROOT files. - Interactive inspection with `TBrowser`. - Store not only numbers, but also *objects* in the columns. In this section we will discuss briefly the `TNtuple` class, which is a; simplified version of the `TTree` class. A ROOT `TNtuple` object can; store rows of float entries. Let's tackle the problem according to the; usual strategy commenting a minimal example. ``` {.cpp}; @ROOT_INCLUDE_FILE macros/write_ntuple_to_file.C; ```. This data written to this example n-tuple represents, in the statistical; sense, three independent variables (Potential or Voltage, Pressure and; Temperature), and one variable (Current) which depends on the others; according to very simple laws, and an additional Gaussian smearing. This; set of variables mimics a measurement of an electrical resistance while; varying pressure and temperature. Imagine your task now consists in finding the relations among the; variables -- of course without knowing the code used to generate them.; You will see that the possibilities of the `NTuple` class enable you to; perform this analysis task. Open the ROOT file (`cond_data.root`); written by the macro above in an interactive session ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/filio.md:2039,simpl,simplified,2039,documentation/primer/filio.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/filio.md,1,['simpl'],['simplified']
Usability,"ne`. - A coroutine object can be resumed normally if it has not already reached; completion with `llvm.coro.resume`. - A coroutine object can be destroyed, invalidating the coroutine object,; with `llvm.coro.destroy`. This must be done separately even if the; coroutine has reached completion normally. - ""Promise"" storage, which is known to have a certain size and alignment,; can be projected out of the coroutine object with `llvm.coro.promise`.; The coroutine implementation must have been compiled to define a promise; of the same size and alignment. In general, interacting with a coroutine object in any of these ways while; it is running has undefined behavior. The coroutine function is split into three functions, representing three; different ways that control can enter the coroutine:. 1. the ramp function that is initially invoked, which takes arbitrary; arguments and returns a pointer to the coroutine object;. 2. a coroutine resume function that is invoked when the coroutine is resumed,; which takes a pointer to the coroutine object and returns `void`;. 3. a coroutine destroy function that is invoked when the coroutine is; destroyed, which takes a pointer to the coroutine object and returns; `void`. Because the resume and destroy functions are shared across all suspend; points, suspend points must store the index of the active suspend in; the coroutine object, and the resume/destroy functions must switch over; that index to get back to the correct point. Hence the name of this; lowering. Pointers to the resume and destroy functions are stored in the coroutine; object at known offsets which are fixed for all coroutines. A completed; coroutine is represented with a null resume function. There is a somewhat complex protocol of intrinsics for allocating and; deallocating the coroutine object. It is complex in order to allow the; allocation to be elided due to inlining. This protocol is discussed; in further detail below. The frontend may generate code to call the coro",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst:3991,resume,resume,3991,interpreter/llvm-project/llvm/docs/Coroutines.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst,2,['resume'],"['resume', 'resumed']"
Usability,"need anymore for the special version we had up to now. The; modifications we needed have been introduced in the official version.; This version also fixes the color problem on BigEndian machines.; On these machines (Mac and Solaris for instance) the color of the jpeg; and png images saved from the ""File"" menu in a TCanvas were; completely wrong.; Addition for image pixelization and color to alpha functionality.; Fixed bunch of compilation bugs showing up on old systems. Graphical Output; PDF. Text rotated at 270 degrees was not correct. The PDF rotation matrix; contained very small values close to 0 instead of 0. Acrobat reader; produced a wrong output and also printed result was wrong.; ""gv"" worked. PostScript. The character ""@"" could not be printed in PostScript files.; Change the Page numbering to make it appear nicer in postcript viewers; like ""gv"". It is compliant with the Adobe Postscript Document; Structuring Conventions (easily found on the web).; The fonts encoding has been simplified (use ISOLatin1Encoding). The new; way allows to print any character with accent etc.. like on the screen.; The new encoding was done by Pierre Juillot. TPad. In batch mode it was not possible to generate a bitmap file (gif,; jpeg etc..) with a filename containing "")"",; ""("", ""]"" or ""["".; The Tickx and Tixky attributes were not saved properly by SavePrimitive.; PaintPolyLineNDC was not working in case of PS output.; In ExecuteEvent. A problem was found Mathieu de Naurois; <denauroi@in2p3.fr>.; It can be reproduced by the following sequence:; ; do TCanvas c; do c->Divide(2,2); show the toolbar; click L to enter text; click on a pad to enter text; move the mouse without releasing the button.; entex text; hit Enter.; ; Before this bug fix, the canvas position changed on ""hit Enter"".; On a Windows dual core machine, the WaitPrimitive call returned; immediately. Miscellaneous; TView3D. Protection was missing in ctors in case gPad does not exits.; Allow interactive zooming on histogram",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/doc/v520/index.html:2748,simpl,simplified,2748,graf2d/doc/v520/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/doc/v520/index.html,1,['simpl'],['simplified']
Usability,"need to add code to your node's case statement in ``LegalizeOp``; to Promote your node's operands to a larger size, and perform the correct; operation. You will also need to add code to ``PromoteOp`` to do this as; well. For a good example, see ``ISD::BSWAP``, which promotes its operand to; a wider size, performs the byteswap, and then shifts the correct bytes right; to emulate the narrower byteswap in the wider type. #. ``lib/CodeGen/SelectionDAG/LegalizeDAG.cpp``:. Add a case for your node in ``ExpandOp`` to teach the legalizer how to; perform the action represented by the new node on a value that has been split; into high and low halves. This case will be used to support your node with a; 64 bit operand on a 32 bit target. #. ``lib/CodeGen/SelectionDAG/DAGCombiner.cpp``:. If your node can be combined with itself, or other existing nodes in a; peephole-like fashion, add a visit function for it, and call that function; from. There are several good examples for simple combines you can do;; ``visitFABS`` and ``visitSRL`` are good starting places. #. ``lib/Target/PowerPC/PPCISelLowering.cpp``:. Each target has an implementation of the ``TargetLowering`` class, usually in; its own file (although some targets include it in the same file as the; DAGToDAGISel). The default behavior for a target is to assume that your new; node is legal for all types that are legal for that target. If this target; does not natively support your node, then tell the target to either Promote; it (if it is supported at a larger type) or Expand it. This will cause the; code you wrote in ``LegalizeOp`` above to decompose your new node into other; legal nodes for this target. #. ``include/llvm/Target/TargetSelectionDAG.td``:. Most current targets supported by LLVM generate code using the DAGToDAG; method, where SelectionDAG nodes are pattern matched to target-specific; nodes, which represent individual instructions. In order for the targets to; match an instruction to your new node, you must add ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ExtendingLLVM.rst:6345,simpl,simple,6345,interpreter/llvm-project/llvm/docs/ExtendingLLVM.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ExtendingLLVM.rst,1,['simpl'],['simple']
Usability,"new TGLayoutHints(kLHintsCenterX,2,2,2,2));. // Sets window name and shows the main frame; SetWindowName(""Simple Example"");; MapSubwindows();; Resize(GetDefaultSize());; MapWindow();; }; ```. ## Widgets Overview. The word widget is a contraction of windows and gadget. Almost all GUI; elements are widgets. A button is a widget, a menu item is a widget, a; scrollbar is a widget, and a complete dialog box is a widget too. Some; widgets may have sub widgets. For example, a dialog box can contain; buttons, text fields, a combo-box, etc. On the screen widgets look like rectangular areas with special; behaviors. In terms of the object-oriented programming we can define a; widget in ROOT as an object of a class deriving from **`TGObject`**. This section presents all currently supported widgets in ROOT and their; most useful methods. All of them can be considered as building blocks; for an application, and most of them can be found in dialogs. Provided; snippets of the code will give you practical guidelines where and how to; use certain widgets. The macro `$ROOTSYS/tutorials/gui/guitest.C`; contains the complete source code. ![Widgets created by ROOT GUI classes](pictures/02000204.jpg). Any custom widget can be created by sub classing existing widgets. To; achieve a better understanding of the widgets' properties they are; separated by their type and their inheritance. As all of them inherit; from **`TGObject`** and most from **`TGWidget`**, these base classes are; described first. ### TGObject. **`TGObject`** is the base class for all ROOT GUI classes. It inherits; from **`TObject`**. The two data members of this class contain important; information about X11/Win32 window identifier and the connection to the; host's graphics system. Every GUI element, which derives from; **`TGObject`** has access to the **`TGClient`** via the data member; `fClient` of **`TGObject. TGClient`** creates the connection with the; host's graphics system and sets up the complete graphics system fo",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md:20449,guid,guidelines,20449,documentation/users-guide/WritingGUI.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md,1,['guid'],['guidelines']
Usability,"new value to hold the initial value of the array; access for the first iteration, and then creating a new GEP instruction in the; loop to increment the value by the appropriate amount. .. _passes-loop-rotate:. ``loop-rotate``: Rotate Loops; -----------------------------. A simple loop rotation transformation. A summary of it can be found in; :ref:`Loop Terminology for Rotated Loops <loop-terminology-loop-rotate>`. .. _passes-loop-simplify:. ``loop-simplify``: Canonicalize natural loops; ---------------------------------------------. This pass performs several transformations to transform natural loops into a; simpler form, which makes subsequent analyses and transformations simpler and; more effective. A summary of it can be found in; :ref:`Loop Terminology, Loop Simplify Form <loop-terminology-loop-simplify>`. Loop pre-header insertion guarantees that there is a single, non-critical entry; edge from outside of the loop to the loop header. This simplifies a number of; analyses and transformations, such as :ref:`LICM <passes-licm>`. Loop exit-block insertion guarantees that all exit blocks from the loop (blocks; which are outside of the loop that have predecessors inside of the loop) only; have predecessors from inside of the loop (and are thus dominated by the loop; header). This simplifies transformations such as store-sinking that are built; into LICM. This pass also guarantees that loops will have exactly one backedge. Note that the :ref:`simplifycfg <passes-simplifycfg>` pass will clean up blocks; which are split out but end up being unnecessary, so usage of this pass should; not pessimize generated code. This pass obviously modifies the CFG, but updates loop information and; dominator information. ``loop-unroll``: Unroll loops; -----------------------------. This pass implements a simple loop unroller. It works best when loops have; been canonicalized by the :ref:`indvars <passes-indvars>` pass, allowing it to; determine the trip counts of loops easily. ``loop-",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Passes.rst:27114,simpl,simplifies,27114,interpreter/llvm-project/llvm/docs/Passes.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Passes.rst,1,['simpl'],['simplifies']
Usability,"nfrastructure. LLVM Reference; --------------. ======================; Command Line Utilities; ======================. :doc:`LLVM Command Guide <CommandGuide/index>`; A reference manual for the LLVM command line utilities (""man"" pages for LLVM; tools). :doc:`Bugpoint`; Automatic bug finder and test-case reducer description and usage; information. :doc:`OptBisect`; A command line option for debugging optimization-induced failures. :doc:`SymbolizerMarkupFormat`; A reference for the log symbolizer markup accepted by ``llvm-symbolizer``. :doc:`The Microsoft PDB File Format <PDB/index>`; A detailed description of the Microsoft PDB (Program Database) file format. ==================; Garbage Collection; ==================. :doc:`GarbageCollection`; The interfaces source-language compilers should use for compiling GC'd; programs. :doc:`Statepoints`; This describes a set of experimental extensions for garbage; collection support. =========; LibFuzzer; =========. :doc:`LibFuzzer`; A library for writing in-process guided fuzzers. :doc:`FuzzingLLVM`; Information on writing and using Fuzzers to find bugs in LLVM. ========; LLVM IR; ========. :doc:`LLVM Language Reference Manual <LangRef>`; Defines the LLVM intermediate representation and the assembly form of the; different nodes. :doc:`InAlloca`; Description of the ``inalloca`` argument attribute. :doc:`BitCodeFormat`; This describes the file format and encoding used for LLVM ""bc"" files. :doc:`Machine IR (MIR) Format Reference Manual <MIRLangRef>`; A reference manual for the MIR serialization format, which is used to test; LLVM's code generation passes. :doc:`GlobalISel/index`; This describes the prototype instruction selection replacement, GlobalISel. :doc:`ConvergentOperations`; Description of ``convergent`` operation semantics and related intrinsics. =====================; Testing and Debugging; =====================. :doc:`LLVM Testing Infrastructure Guide <TestingGuide>`; A reference manual for using the LLVM testing infrast",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Reference.rst:2093,guid,guided,2093,interpreter/llvm-project/llvm/docs/Reference.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Reference.rst,1,['guid'],['guided']
Usability,"ng -fsyntax-only t.c; t.c:7:39: error: invalid operands to binary expression ('int' and 'struct A'); return y + func(y ? ((SomeA.X + 40) + SomeA) / 42 + SomeA.X : SomeA.X);; ~~~~~~~~~~~~~~ ^ ~~~~~. Here you can see that you don't even need to see the original source code to; understand what is wrong based on the Clang error: Because Clang prints a; caret, you know exactly which plus it is complaining about. The range; information highlights the left and right side of the plus which makes it; immediately obvious what the compiler is talking about, which is very useful for; cases involving precedence issues and many other situations.; Clang diagnostics are very polished and have many features. For more; information and examples, please see the Expressive; Diagnostics page. GCC Compatibility. GCC is currently the defacto-standard open source compiler today, and it; routinely compiles a huge volume of code. GCC supports a huge number of; extensions and features (many of which are undocumented) and a lot of; code and header files depend on these features in order to build.; While it would be nice to be able to ignore these extensions and focus on; implementing the language standards to the letter, pragmatics force us to; support the GCC extensions that see the most use. Many users just want their; code to compile, they don't care to argue about whether it is pedantically C99; or not.; As mentioned above, all; extensions are explicitly recognized as such and marked with extension; diagnostics, which can be mapped to warnings, errors, or just ignored. Utility and Applications. Library Based Architecture. A major design concept for clang is its use of a library-based; architecture. In this design, various parts of the front-end can be cleanly; divided into separate libraries which can then be mixed up for different needs; and uses. In addition, the library-based approach encourages good interfaces; and makes it easier for new developers to get involved (because they only ne",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/features.html:3217,undo,undocumented,3217,interpreter/llvm-project/clang/www/features.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/features.html,1,['undo'],['undocumented']
Usability,"ng ``-fprebuilt-module-path`` and ``-fprebuilt-implicit-modules``. .. code-block:: sh. rm -rf prebuilt; mkdir prebuilt; clang -cc1 -emit-obj -o use.o use.c -fmodules -fimplicit-module-maps -fmodules-cache-path=prebuilt; clang -cc1 -emit-obj -o use.o use.c -fmodules -fimplicit-module-maps -fmodules-cache-path=prebuilt -DENABLE_A; find prebuilt -name ""*.pcm""; # prebuilt/1AYBIGPM8R2GA/A-3L1K4LUA6O31.pcm; # prebuilt/1AYBIGPM8R2GA/B-3L1K4LUA6O31.pcm; # prebuilt/VH0YZMF1OIRK/A-3L1K4LUA6O31.pcm; # prebuilt/VH0YZMF1OIRK/B-3L1K4LUA6O31.pcm; clang -cc1 -emit-obj -o use.o use.c -fmodules -fimplicit-module-maps -fprebuilt-module-path=prebuilt -fprebuilt-implicit-modules; clang -cc1 -emit-obj -o use.o use.c -fmodules -fimplicit-module-maps -fprebuilt-module-path=prebuilt -fprebuilt-implicit-modules -DENABLE_A. Finally we want to allow implicit modules for configurations that were not prebuilt. When using the clang driver a module cache path is implicitly selected. Using ``-cc1``, we simply add use the ``-fmodules-cache-path`` option. .. code-block:: sh. clang -cc1 -emit-obj -o use.o use.c -fmodules -fimplicit-module-maps -fprebuilt-module-path=prebuilt -fprebuilt-implicit-modules -fmodules-cache-path=cache; clang -cc1 -emit-obj -o use.o use.c -fmodules -fimplicit-module-maps -fprebuilt-module-path=prebuilt -fprebuilt-implicit-modules -fmodules-cache-path=cache -DENABLE_A; clang -cc1 -emit-obj -o use.o use.c -fmodules -fimplicit-module-maps -fprebuilt-module-path=prebuilt -fprebuilt-implicit-modules -fmodules-cache-path=cache -DENABLE_A -DOTHER_OPTIONS. This way, a single directory containing multiple variants of modules can be prepared and reused. The options configuring the module cache are independent of other options. Module Semantics; ================. Modules are modeled as if each submodule were a separate translation unit, and a module import makes names from the other translation unit visible. Each submodule starts with a new preprocessor state and an empty translation un",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst:23328,simpl,simply,23328,interpreter/llvm-project/clang/docs/Modules.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst,1,['simpl'],['simply']
Usability,"ng a primary operator, we eat the operator as a; prefix and parse the remaining piece as another unary operator. This; allows us to handle multiple unary operators (e.g. ""!!x""). Note that; unary operators can't have ambiguous parses like binary operators can,; so there is no need for precedence information. The problem with this function, is that we need to call ParseUnary from; somewhere. To do this, we change previous callers of ParsePrimary to; call ParseUnary instead:. .. code-block:: c++. /// binoprhs; /// ::= ('+' unary)*; static std::unique_ptr<ExprAST> ParseBinOpRHS(int ExprPrec,; std::unique_ptr<ExprAST> LHS) {; ...; // Parse the unary expression after the binary operator.; auto RHS = ParseUnary();; if (!RHS); return nullptr;; ...; }; /// expression; /// ::= unary binoprhs; ///; static std::unique_ptr<ExprAST> ParseExpression() {; auto LHS = ParseUnary();; if (!LHS); return nullptr;. return ParseBinOpRHS(0, std::move(LHS));; }. With these two simple changes, we are now able to parse unary operators; and build the AST for them. Next up, we need to add parser support for; prototypes, to parse the unary operator prototype. We extend the binary; operator code above with:. .. code-block:: c++. /// prototype; /// ::= id '(' id* ')'; /// ::= binary LETTER number? (id, id); /// ::= unary LETTER (id); static std::unique_ptr<PrototypeAST> ParsePrototype() {; std::string FnName;. unsigned Kind = 0; // 0 = identifier, 1 = unary, 2 = binary.; unsigned BinaryPrecedence = 30;. switch (CurTok) {; default:; return LogErrorP(""Expected function name in prototype"");; case tok_identifier:; FnName = IdentifierStr;; Kind = 0;; getNextToken();; break;; case tok_unary:; getNextToken();; if (!isascii(CurTok)); return LogErrorP(""Expected unary operator"");; FnName = ""unary"";; FnName += (char)CurTok;; Kind = 1;; getNextToken();; break;; case tok_binary:; ... As with binary operators, we name unary operators with a name that; includes the operator character. This assists us at code gener",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl06.rst:12724,simpl,simple,12724,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl06.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl06.rst,1,['simpl'],['simple']
Usability,"ng column of the first mapping region in this function. |; +----------+-------------------------------------------------------------------------------------------------------------------------+; | ``0x02`` | The ending line of the first mapping region in this function. |; +----------+-------------------------------------------------------------------------------------------------------------------------+; | ``0x02`` | The ending column of the first mapping region in this function. |; +----------+-------------------------------------------------------------------------------------------------------------------------+. * The length of the substring that contains the encoded coverage mapping data; for the second function record is also 9. It's structured like the mapping data; for the first function record. * The two trailing bytes are zeroes and are used to pad the coverage mapping; data to give it the 8 byte alignment. Encoding; ========. The per-function coverage mapping data is encoded as a stream of bytes,; with a simple structure. The structure consists of the encoding; `types <cvmtypes_>`_ like variable-length unsigned integers, that; are used to encode `File ID Mapping`_, `Counter Expressions`_ and; the `Mapping Regions`_. The format of the structure follows:. ``[file id mapping, counter expressions, mapping regions]``. The translation unit filenames are encoded using the same encoding; `types <cvmtypes_>`_ as the per-function coverage mapping data, with the; following structure:. ``[numFilenames : LEB128, filename0 : string, filename1 : string, ...]``. .. _cvmtypes:. Types; -----. This section describes the basic types that are used by the encoding format; and can appear after ``:`` in the ``[foo : type]`` description. .. _LEB128:. LEB128; ^^^^^^. LEB128 is an unsigned integer value that is encoded using DWARF's LEB128; encoding, optimizing for the case where values are small; (1 byte for values less than 128). .. _CoverageStrings:. Strings; ^^^^^^^. ``[length",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CoverageMappingFormat.rst:22228,simpl,simple,22228,interpreter/llvm-project/llvm/docs/CoverageMappingFormat.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CoverageMappingFormat.rst,1,['simpl'],['simple']
Usability,ng for deduction from a type; Not resolved. 2426; C++20; Reference to destructor that cannot be invoked; Unknown. 2427; C++20; Deprecation of volatile operands and unevaluated contexts; Unknown. 2428; C++23; Deprecating a concept; Unknown. 2429; C++20; Initialization of thread_local variables referenced by lambdas; Unknown. 2430; C++20; Completeness of return and parameter types of member functions; Unknown. 2431; C++20; Full-expressions and temporaries bound to references; Unknown. 2432; C++20; Return types for defaulted <=>; Unknown. 2433; C++20; Variable templates in the ODR; Unknown. 2434; open; Mandatory copy elision vs non-class objects; Not resolved. 2435; open; Alias template specializations; Not resolved. 2436; C++20; Copy semantics of coroutine parameters; Unknown. 2437; C++20; Conversion of std::strong_ordering in a defaulted operator<=>; Unknown. 2438; open; Problems in the specification of qualification conversions; Not resolved. 2439; C++20; Undefined term in definition of “usable in constant expressions”; Unknown. 2440; C++23; Allocation in core constant expressions; Unknown. 2441; C++20; Inline function parameters; Unknown. 2442; C++20; Incorrect requirement for default arguments; Unknown. 2443; C++23; Meaningless template exports; Unknown. 2444; drafting; Constant expressions in initialization odr-use; Not resolved. 2445; C++20; Partial ordering with rewritten candidates; Unknown. 2446; C++20; Questionable type-dependency of concept-ids; Unknown. 2447; C++20; Unintended description of abbreviated function templates; Unknown. 2448; CD6; Cv-qualification of arithmetic types and deprecation of volatile; Unknown. 2449; extension; Thunks as an implementation technique for pointers to virtual functions; Extension. 2450; review; braced-init-list as a template-argument; Clang 18. 2451; C++23; promise.unhandled_exception() and final suspend point; Unknown. 2452; CD6; Flowing off the end of a coroutine; Unknown. 2453; NAD; Deduced return types and coroutine l,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:166984,usab,usable,166984,interpreter/llvm-project/clang/www/cxx_dr_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html,1,['usab'],['usable']
Usability,"ng is a code snippet from `RooPoisson` *after* it has AD support. ### Step 1. Refactor the `RooPoisson::evaluate()` Function. ``` {.cpp}; /// Implementation in terms of the TMath::Poisson() function. double RooPoisson::evaluate() const; {; double k = _noRounding ? x : floor(x);; if(_protectNegative && mean<0) {; RooNaNPacker np;; np.setPayload(-mean);; return np._payload;; }; return RooFit::Detail::MathFuncs::poisson(k, mean);; }; ```. Note that the `evaluate()` function was refactored in such a way that the; mathematical parts were moved to an inline function in a separate header file; named `MathFuncs`, so that Clad could see and differentiate that function.; The rest of the contents of the function remain unchanged. > All contents of the `evaluate()` function don't always need to be pulled; out, only the required parts (mathematical logic) should be moved to; `MathFuncs`. **What is MathFuncs?**. Moving away from the class-based hierarchy design, `MathFuncs.h` a simply; a flat file of function implementations. This file is required since Clad will not be able to see anything that is not; inlined and explicitly available to it during compilation (since it has to be; in the same translation). So other than of generating these functions on the; fly, your only other option is to place these functions in a separate header; file and make them inline. Theoretically, multiple header files can also be used and then mashed; together. > Directory path: [roofit/roofitcore/inc/RooFit/Detail/MathFuncs.h](https://github.com/root-project/root/blob/master/roofit/roofitcore/inc/RooFit/Detail/MathFuncs.h). ### Step 2. Override RooAbsArg::translate(). **translate() Example 1:** Continuing our RooPoisson example:. To translate the `RooPoisson` class, create a translate function and in it; include a call to the updated function. ``` {.cpp}; void RooPoisson::translate(RooFit::Detail::RooFit::Detail::CodeSquashContext &ctx) const; {; std::string xName = ctx.getResult(x);; if (!_noRounding",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/developers/roofit_ad.md:11350,simpl,simply,11350,roofit/doc/developers/roofit_ad.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/developers/roofit_ad.md,1,['simpl'],['simply']
Usability,"ng the approach (2) - it should be possible to avoid; performance overhead, and clarity seems nice. **Gabor:**. At this point, I am a bit wondering about two questions. * When should something belong to a checker and when should something belong to the engine?; Sometimes we model library aspects in the engine and model language constructs in checkers. * What is the checker programming model that we are aiming for? Maximum freedom or more easy checker development?. I think if we aim for maximum freedom, we do not need to worry about the; potential stress on checkers, and we can introduce abstractions to mitigate that; later on.; If we want to simplify the API, then maybe it makes more sense to move language; construct modeling to the engine when the checker API is not sufficient instead; of complicating the API. Right now I have no preference or objections between the alternatives but there; are some random thoughts:. * Maybe it would be great to have a guideline how to evolve the analyzer and; follow it, so it can help us to decide in similar situations. * I do care about performance in this case. The reason is that we have a; limited performance budget. And I think we should not expect most of the checker; writers to add modeling of language constructs. So, in my opinion, it is ok to; have less nice/more verbose API for language modeling if we can have better; performance this way, since it only needs to be done once, and is done by the; framework developers. **Artem:** These are some great questions, i guess it'd be better to discuss; them more openly. As a quick dump of my current mood:. * To me it seems obvious that we need to aim for a checker API that is both; simple and powerful. This can probably by keeping the API as powerful as; necessary while providing a layer of simple ready-made solutions on top of it.; Probably a few reusable components for assembling checkers. And this layer; should ideally be pleasant enough to work with, so that people would prefer",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/InitializerLists.rst:5499,guid,guideline,5499,interpreter/llvm-project/clang/docs/analyzer/developer-docs/InitializerLists.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/InitializerLists.rst,1,['guid'],['guideline']
Usability,"ng:. .. code-block:: bat. c:\llvm> python ..\build\Release\bin\llvm-lit.py llvm\test. This example assumes that Python is in your PATH variable, which would be; after **Add Python to the PATH** was selected during Python installation.; If you had opened a command window prior to Python installation, you would; have to close and reopen it to get the updated PATH. A specific test or test directory can be run with:. .. code-block:: bat. c:\llvm> python ..\build\Release\bin\llvm-lit.py llvm\test\Transforms\Util. Build the LLVM Suite:; ---------------------; * The projects may still be built individually, but to build them all do; not just select all of them in batch build (as some are meant as; configuration projects), but rather select and build just the; ``ALL_BUILD`` project to build everything, or the ``INSTALL`` project,; which first builds the ``ALL_BUILD`` project, then installs the LLVM; headers, libs, and other useful things to the directory set by the; ``CMAKE_INSTALL_PREFIX`` setting when you first configured CMake.; * The Fibonacci project is a sample program that uses the JIT. Modify the; project's debugging properties to provide a numeric command line argument; or run it from the command line. The program will print the; corresponding fibonacci value. Links; =====; This document is just an **introduction** to how to use LLVM to do some simple; things... there are many more interesting and complicated things that you can; do that aren't documented here (but we'll gladly accept a patch if you want to; write something up!). For more information about LLVM, check out:. * `LLVM homepage <https://llvm.org/>`_; * `LLVM doxygen tree <https://llvm.org/doxygen/>`_; * Additional information about the LLVM directory structure and tool chain; can be found on the main :doc:`GettingStarted` page.; * If you are having problems building or using LLVM, or if you have any other; general questions about LLVM, please consult the; :doc:`Frequently Asked Questions <FAQ>` page.; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GettingStartedVS.rst:10400,simpl,simple,10400,interpreter/llvm-project/llvm/docs/GettingStartedVS.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GettingStartedVS.rst,1,['simpl'],['simple']
Usability,"nge?. * Remember, it is normal and healthy to have patches reverted. Having a patch; reverted does not necessarily mean you did anything wrong.; * We encourage explicitly thanking the person who reverted the patch for doing; the task on your behalf.; * If you need more information to address the problem, please follow up in the; original commit thread with the reverting patch author. When should you revert your own change?. * Any time you learn of a serious problem with a change, you should revert it.; We strongly encourage ""revert to green"" as opposed to ""fixing forward"". We; encourage reverting first, investigating offline, and then reapplying the; fixed patch - possibly after another round of review if warranted.; * If you break a buildbot in a way which can't be quickly fixed, please revert.; * If a test case that demonstrates a problem is reported in the commit thread,; please revert and investigate offline.; * If you receive substantial :ref:`post-commit review <post_commit_review>`; feedback, please revert and address said feedback before recommitting.; (Possibly after another round of review.); * If you are asked to revert by another contributor, please revert and discuss; the merits of the request offline (unless doing so would further destabilize; tip of tree). When should you revert someone else's change?. * In general, if the author themselves would revert the change per these; guidelines, we encourage other contributors to do so as a courtesy to the; author. This is one of the major cases where our norms differ from others;; we generally consider reverting a normal part of development. We don't; expect contributors to be always available, and the assurance that a; problematic patch will be reverted and we can return to it at our next; opportunity enables this. What are the expectations around a revert?. * Use your best judgment. If you're uncertain, please start an email on; the commit thread asking for assistance. We aren't trying to enumerate; every ca",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/DeveloperPolicy.rst:19842,feedback,feedback,19842,interpreter/llvm-project/llvm/docs/DeveloperPolicy.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/DeveloperPolicy.rst,2,['feedback'],['feedback']
Usability,"nged by layout managers:. - horizontal layout, vertical layout, row layout, list layout, tile; layout, matrix layout. Using a combination of layout hints:. - left, right, center x, center y, top, bottom, expand x, expand y,; fixed offsets. Event handling by signals/slots and messaging (as opposed to callbacks):. - in response to actions widgets send messages and emit signals. - associated frames process these messages or the slot methods; connected to the signals are executed. ## TVirtualX. The GUI classes interface to the platform dependent low level graphics; system via the semi-abstract graphics base class **`TVirtualX`**.; Currently concrete implementations exist for X11 and Win32 (MacOS X is; fully supported via Apple's X11 implementation). Thanks to this single; graphics interface, porting the ROOT GUI to a new platform requires only; the implementation of **`TVirtualX`**. ![](pictures/02000201.jpg). ## A Simple Example. We will start with a simple example that builds a small application; containing a canvas and two buttons: Draw and Exit. Its functionality; will be very simple: every time you click on Draw button, the graphics; of the function `sin(x)/x` will be drawn in randomly chosen interval in; the canvas window, if you click on Exit - you close the application.; This example shows the basic concepts for almost any GUI-application in; ROOT and it is important to understand how it is constructed. The; example program is written as a named script. See ""Cling the C++; Interpreter"". Remember that the named script can be executed via. ``` {.cpp}; root[] .x example.C; ```. only if the filename (without extension) and the function entry point; are both the same. ![](pictures/02000202.jpg). We need to say a few words about the parent-children relationship; between the widgets before going through the real code. The widgets'; behaviors are based on this relationship. Every parent widget is; responsible for where the children are and it ensures all properties and; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md:2739,simpl,simple,2739,documentation/users-guide/WritingGUI.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md,1,['simpl'],['simple']
Usability,"nguished between unsigned and signed; integer types and ran into similar issues of no-op casts. The transition from; manifesting signedness in types to instructions happened early on in LLVM's; timeline to make LLVM easier to work with. Opaque Pointers Mode; ====================. During the transition phase, LLVM can be used in two modes: In typed pointer; mode all pointer types have a pointee type and opaque pointers cannot be used.; In opaque pointers mode (the default), all pointers are opaque. The opaque; pointer mode can be disabled using ``-opaque-pointers=0`` in; LLVM tools like ``opt``, or ``-Xclang -no-opaque-pointers`` in clang.; Additionally, opaque pointer mode is automatically disabled for IR and bitcode; files that explicitly mention ``i8*`` style typed pointers. In opaque pointer mode, all typed pointers used in IR, bitcode, or created; using ``PointerType::get()`` and similar APIs are automatically converted into; opaque pointers. This simplifies migration and allows testing existing IR with; opaque pointers. .. code-block:: llvm. define i8* @test(i8* %p) {; %p2 = getelementptr i8, i8* %p, i64 1; ret i8* %p2; }. ; Is automatically converted into the following if -opaque-pointers; ; is enabled:. define ptr @test(ptr %p) {; %p2 = getelementptr i8, ptr %p, i64 1; ret ptr %p2; }. Migration Instructions; ======================. In order to support opaque pointers, two types of changes tend to be necessary.; The first is the removal of all calls to ``PointerType::getElementType()`` and; ``Type::getPointerElementType()``. In the LLVM middle-end and backend, this is usually accomplished by inspecting; the type of relevant operations instead. For example, memory access related; analyses and optimizations should use the types encoded in the load and store; instructions instead of querying the pointer type. Here are some common ways to avoid pointer element type accesses:. * For loads, use ``getType()``.; * For stores, use ``getValueOperand()->getType()``.; * U",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/OpaquePointers.rst:5875,simpl,simplifies,5875,interpreter/llvm-project/llvm/docs/OpaquePointers.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/OpaquePointers.rst,1,['simpl'],['simplifies']
Usability,"nice way to look; at the LLVM IR for simple functions. For example:. ::. ready> 4+5;; Read top-level expression:; define double @0() {; entry:; ret double 9.000000e+00; }. Note how the parser turns the top-level expression into anonymous; functions for us. This will be handy when we add `JIT; support <LangImpl04.html#adding-a-jit-compiler>`_ in the next chapter. Also note that the; code is very literally transcribed, no optimizations are being performed; except simple constant folding done by IRBuilder. We will `add; optimizations <LangImpl04.html#trivial-constant-folding>`_ explicitly in the next; chapter. ::. ready> def foo(a b) a*a + 2*a*b + b*b;; Read function definition:; define double @foo(double %a, double %b) {; entry:; %multmp = fmul double %a, %a; %multmp1 = fmul double 2.000000e+00, %a; %multmp2 = fmul double %multmp1, %b; %addtmp = fadd double %multmp, %multmp2; %multmp3 = fmul double %b, %b; %addtmp4 = fadd double %addtmp, %multmp3; ret double %addtmp4; }. This shows some simple arithmetic. Notice the striking similarity to the; LLVM builder calls that we use to create the instructions. ::. ready> def bar(a) foo(a, 4.0) + bar(31337);; Read function definition:; define double @bar(double %a) {; entry:; %calltmp = call double @foo(double %a, double 4.000000e+00); %calltmp1 = call double @bar(double 3.133700e+04); %addtmp = fadd double %calltmp, %calltmp1; ret double %addtmp; }. This shows some function calls. Note that this function will take a long; time to execute if you call it. In the future we'll add conditional; control flow to actually make recursion useful :). ::. ready> extern cos(x);; Read extern:; declare double @cos(double). ready> cos(1.234);; Read top-level expression:; define double @1() {; entry:; %calltmp = call double @cos(double 1.234000e+00); ret double %calltmp; }. This shows an extern for the libm ""cos"" function, and a call to it. .. TODO:: Abandon Pygments' horrible `llvm` lexer. It just totally gives up; on highlighting this due to ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl03.rst:18798,simpl,simple,18798,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl03.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl03.rst,1,['simpl'],['simple']
Usability,"nking) them into the `test-suite/test-suite-externals/xxx` directory (example: `test-suite/test-suite-externals/speccpu2000`); - using a configuration option such as `-D TEST_SUITE_SPEC2000_ROOT=path/to/speccpu2000`. You can find further information in the respective README files such as; `test-suite/External/SPEC/README`. For the SPEC benchmarks you can switch between the `test`, `train` and; `ref` input datasets via the `TEST_SUITE_RUN_TYPE` configuration option.; The `train` dataset is used by default. Custom Suites; -------------. You can build custom suites using the test-suite infrastructure. A custom suite; has a `CMakeLists.txt` file at the top directory. The `CMakeLists.txt` will be; picked up automatically if placed into a subdirectory of the test-suite or when; setting the `TEST_SUITE_SUBDIRS` variable:. ```bash; % cmake -DTEST_SUITE_SUBDIRS=path/to/my/benchmark-suite ../test-suite; ```. Profile Guided Optimization; ---------------------------. Profile guided optimization requires to compile and run twice. First the; benchmark should be compiled with profile generation instrumentation enabled; and setup for training data. The lit runner will merge the profile files; using `llvm-profdata` so they can be used by the second compilation run. Example:; ```bash; # Profile generation run using LLVM IR PGO:; % cmake -DTEST_SUITE_PROFILE_GENERATE=ON \; -DTEST_SUITE_USE_IR_PGO=ON \; -DTEST_SUITE_RUN_TYPE=train \; ../test-suite; % make; % llvm-lit .; # Use the profile data for compilation and actual benchmark run:; % cmake -DTEST_SUITE_PROFILE_GENERATE=OFF \; -DTEST_SUITE_PROFILE_USE=ON \; -DTEST_SUITE_RUN_TYPE=ref \; .; % make; % llvm-lit -o result.json .; ```. To use Clang frontend's PGO instead of LLVM IR PGO, set `-DTEST_SUITE_USE_IR_PGO=OFF`. The `TEST_SUITE_RUN_TYPE` setting only affects the SPEC benchmark suites. Cross Compilation and External Devices; --------------------------------------. ### Compilation. CMake allows to cross compile to a different target ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TestSuiteGuide.md:9998,guid,guided,9998,interpreter/llvm-project/llvm/docs/TestSuiteGuide.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TestSuiteGuide.md,1,['guid'],['guided']
Usability,"not omnipotent, but they're so nice. * Separation between core and checkers is usually quite strange. Once we have; shared state traits, i generally wouldn't mind having region store or range; constraint manager as checkers (though it's probably not worth it to transform; them - just a mood). The main thing to avoid here would be the situation when; the checker overwrites stuff written by the core because it thinks it has a; better idea what's going on, so the core should provide a good default behavior. * Yeah, i totally care about performance as well, and if i try to implement; approach, i'd make sure it's good. **Artem:**. > Approach (2): We could teach the Store to scan itself for bindings to; > metadata-symbolic-based regions during scanReachableSymbols() whenever; > a region turns out to be reachable. This requires no work on checker side,; > but it sounds performance-heavy. Nope, this approach is wrong. Metadata symbols may become out-of-date: when the; object changes, metadata symbols attached to it aren't changing (because symbols; simply don't change). The same metadata may have different symbols to denote its; value in different moments of time, but at most one of them represents the; actual metadata value. So we'd be escaping more stuff than necessary. If only we had ""ghost fields""; (https://lists.llvm.org/pipermail/cfe-dev/2016-May/049000.html), it would have; been much easier, because the ghost field would only contain the actual; metadata, and the Store would always know about it. This example adds to my; belief that ghost fields are exactly what we need for most C++ checkers. **Devin:**. In this case, I would be fine with some sort of; AbstractStorageMemoryRegion that meant ""here is a memory region and somewhere; reachable from here exists another region of type T"". Or even multiple regions; with different identifiers. This wouldn't specify how the memory is reachable,; but it would allow for transfer functions to get at those regions and it would; al",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/InitializerLists.rst:7779,simpl,simply,7779,interpreter/llvm-project/clang/docs/analyzer/developer-docs/InitializerLists.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/InitializerLists.rst,1,['simpl'],['simply']
Usability,"nrelated source locations rather than just a line away, making the; confusion of showing the return site rather the call site quite severe. Often the first frame in a backtrace (""frame zero"") identifies the precise; code location of a fault, trap, or asynchronous interrupt rather than a return; address. At other times, even the first frame is actually a return address; (for example, backtraces collected at the time of an object allocation and; reported later when the allocated object is used or misused). When a system; supports in-thread trap handling, there may also be frames after the first; that represent a precise interrupted code location rather than a return; address, presented as the ""caller"" of a trap handler function (for example,; signal handlers in POSIX systems). Return address frames are identified by the ``:ra`` suffix. Precise code; location frames are identified by the ``:pc`` suffix. Traditional practice has often been to collect backtraces as simple address; lists, losing the distinction between return address code locations and; precise code locations. Some such code applies the ""subtract one"" adjustment; described above to the address values before reporting them, and it's not; always clear or consistent whether this adjustment has been applied or not.; These ambiguous cases are supported by the ``bt`` and ``pc`` forms with no; ``:ra`` or ``:pc`` suffix, which indicate it's unclear which sort of code; location this is. However, it's highly recommended that all emitters use the; suffixed forms and deliver address values with no adjustments applied. When; traditional practice has been ambiguous, the majority of cases seem to have; been of printing addresses that are return address code locations and printing; them without adjustment. So the symbolizing filter will usually apply the; ""subtract one byte"" adjustment to an address printed without a disambiguating; suffix. Assuming that a call instruction is longer than one byte on all; supported machin",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SymbolizerMarkupFormat.rst:12159,simpl,simple,12159,interpreter/llvm-project/llvm/docs/SymbolizerMarkupFormat.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SymbolizerMarkupFormat.rst,1,['simpl'],['simple']
Usability,"ns &Opts,; SmallVectorImpl<const char *> &Args,; CompilerInvocation::StringAllocator SA /*...*/) {; // ... + for (const std::string &PassPlugin : Opts.PassPlugins); + GenerateArg(Args, OPT_fpass_plugin_EQ, PassPlugin, SA);; }. Finally, you can specify the argument on the command line:; ``clang -fpass-plugin=a -fpass-plugin=b`` and use the new member variable as; desired. .. code-block:: diff. void EmitAssemblyHelper::EmitAssemblyWithNewPassManager(/*...*/) {; // ...; + for (auto &PluginFN : CodeGenOpts.PassPlugins); + if (auto PassPlugin = PassPlugin::Load(PluginFN)); + PassPlugin->registerPassBuilderCallbacks(PB);; }. .. _OptionMarshalling:. Option Marshalling Infrastructure; ---------------------------------. The option marshalling infrastructure automates the parsing of the Clang; ``-cc1`` frontend command line arguments into ``CompilerInvocation`` and their; generation from ``CompilerInvocation``. The system replaces lots of repetitive; C++ code with simple, declarative tablegen annotations and it's being used for; the majority of the ``-cc1`` command line interface. This section provides an; overview of the system. **Note:** The marshalling infrastructure is not intended for driver-only; options. Only options of the ``-cc1`` frontend need to be marshalled to/from; ``CompilerInvocation`` instance. To read and modify contents of ``CompilerInvocation``, the marshalling system; uses key paths, which are declared in two steps. First, a tablegen definition; for the ``CompilerInvocation`` member is created by inheriting from; ``KeyPathAndMacro``:. .. code-block:: text. // Options.td. class LangOpts<string field> : KeyPathAndMacro<""LangOpts->"", field, ""LANG_""> {}; // CompilerInvocation member ^^^^^^^^^^; // OPTION_WITH_MARSHALLING prefix ^^^^^. The first argument to the parent class is the beginning of the key path that; references the ``CompilerInvocation`` member. This argument ends with ``->`` if; the member is a pointer type or with ``.`` if it's a value type. The c",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:34283,simpl,simple,34283,interpreter/llvm-project/clang/docs/InternalsManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst,1,['simpl'],['simple']
Usability,"ns about the LLVM instruction set.; We should discuss some now, but can discuss many of them later, when we; revisit synchronization, type inference, and other issues.; (We have discussed some of the comments already.). o We should consider eliminating the type annotation in cases where it is; essentially obvious from the instruction type, e.g., in br, it is obvious; that the first arg. should be a bool and the other args should be labels:. 	br bool <cond>, label <iftrue>, label <iffalse>. I think your point was that making all types explicit improves clarity; and readability. I agree to some extent, but it also comes at the cost; of verbosity. And when the types are obvious from people's experience; (e.g., in the br instruction), it doesn't seem to help as much. o On reflection, I really like your idea of having the two different switch; types (even though they encode implementation techniques rather than; semantics). It should simplify building the CFG and my guess is it could; enable some significant optimizations, though we should think about which. o In the lookup-indirect form of the switch, is there a reason not to make; the val-type uint? Most HLL switch statements (including Java and C++); require that anyway. And it would also make the val-type uniform ; in the two forms of the switch. I did see the switch-on-bool examples and, while cute, we can just use; the branch instructions in that particular case. o I agree with your comment that we don't need 'neg'. o There's a trade-off with the cast instruction:; + it avoids having to define all the upcasts and downcasts that are; valid for the operands of each instruction (you probably have thought; of other benefits also); - it could make the bytecode significantly larger because there could; be a lot of cast operations. o Making the second arg. to 'shl' a ubyte seems good enough to me.; 255 positions seems adequate for several generations of machines; and is more compact than uint. o I still have some major con",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HistoricalNotes/2001-02-09-AdveComments.txt:981,simpl,simplify,981,interpreter/llvm-project/llvm/docs/HistoricalNotes/2001-02-09-AdveComments.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HistoricalNotes/2001-02-09-AdveComments.txt,1,['simpl'],['simplify']
Usability,"ns should be in an unnamed namespace ideally. If we treat; these collisions liberally then CTU analysis can find more results. Note, the; feature be able to choose between name conflict handling strategies is still an; ongoing work. .. _CFG:. The ``CFG`` class; -----------------. The ``CFG`` class is designed to represent a source-level control-flow graph; for a single statement (``Stmt*``). Typically instances of ``CFG`` are; constructed for function bodies (usually an instance of ``CompoundStmt``), but; can also be instantiated to represent the control-flow of any class that; subclasses ``Stmt``, which includes simple expressions. Control-flow graphs; are especially useful for performing `flow- or path-sensitive; <https://en.wikipedia.org/wiki/Data_flow_analysis#Sensitivities>`_ program; analyses on a given function. Basic Blocks; ^^^^^^^^^^^^. Concretely, an instance of ``CFG`` is a collection of basic blocks. Each basic; block is an instance of ``CFGBlock``, which simply contains an ordered sequence; of ``Stmt*`` (each referring to statements in the AST). The ordering of; statements within a block indicates unconditional flow of control from one; statement to the next. :ref:`Conditional control-flow; <ConditionalControlFlow>` is represented using edges between basic blocks. The; statements within a given ``CFGBlock`` can be traversed using the; ``CFGBlock::*iterator`` interface. A ``CFG`` object owns the instances of ``CFGBlock`` within the control-flow; graph it represents. Each ``CFGBlock`` within a CFG is also uniquely numbered; (accessible via ``CFGBlock::getBlockID()``). Currently the number is based on; the ordering the blocks were created, but no assumptions should be made on how; ``CFGBlocks`` are numbered other than their numbers are unique and that they; are numbered from 0..N-1 (where N is the number of basic blocks in the CFG). Entry and Exit Blocks; ^^^^^^^^^^^^^^^^^^^^^. Each instance of ``CFG`` contains two special blocks: an *entry* block; (access",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:112577,simpl,simply,112577,interpreter/llvm-project/clang/docs/InternalsManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst,1,['simpl'],['simply']
Usability,"ns that a large; part of the manual and repetitive data entry can be factored and shared with the; compiler. Instruction Parsing; -------------------. .. note::. To Be Written. Instruction Alias Processing; ----------------------------. Once the instruction is parsed, it enters the MatchInstructionImpl function.; The MatchInstructionImpl function performs alias processing and then does actual; matching. Alias processing is the phase that canonicalizes different lexical forms of the; same instructions down to one representation. There are several different kinds; of alias that are possible to implement and they are listed below in the order; that they are processed (which is in order from simplest/weakest to most; complex/powerful). Generally you want to use the first alias mechanism that; meets the needs of your instruction, because it will allow a more concise; description. Mnemonic Aliases; ^^^^^^^^^^^^^^^^. The first phase of alias processing is simple instruction mnemonic remapping for; classes of instructions which are allowed with two different mnemonics. This; phase is a simple and unconditionally remapping from one input mnemonic to one; output mnemonic. It isn't possible for this form of alias to look at the; operands at all, so the remapping must apply for all forms of a given mnemonic.; Mnemonic aliases are defined simply, for example X86 has:. ::. def : MnemonicAlias<""cbw"", ""cbtw"">;; def : MnemonicAlias<""smovq"", ""movsq"">;; def : MnemonicAlias<""fldcww"", ""fldcw"">;; def : MnemonicAlias<""fucompi"", ""fucomip"">;; def : MnemonicAlias<""ud2a"", ""ud2"">;. ... and many others. With a MnemonicAlias definition, the mnemonic is remapped; simply and directly. Though MnemonicAlias's can't look at any aspect of the; instruction (such as the operands) they can depend on global modes (the same; ones supported by the matcher), through a Requires clause:. ::. def : MnemonicAlias<""pushf"", ""pushfq"">, Requires<[In64BitMode]>;; def : MnemonicAlias<""pushf"", ""pushfl"">, Requires<[In32",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodeGenerator.rst:82189,simpl,simple,82189,interpreter/llvm-project/llvm/docs/CodeGenerator.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodeGenerator.rst,1,['simpl'],['simple']
Usability,"ns=2 --margin=30 -rf8.0 %f; Print.Printer: 32-rb20-hp; Print.Directory: .; Print.FileType: pdf; ```. Default histogram binnings used by `TTree::Draw()` method. ``` {.cpp}; Hist.Binning.1D.x: 100; Hist.Binning.2D.x: 40; Hist.Binning.2D.y: 40; Hist.Binning.2D.Prof: 100; Hist.Binning.3D.x: 20; Hist.Binning.3D.y: 20; Hist.Binning.3D.z: 20; Hist.Binning.3D.Profx: 100; Hist.Binning.3D.Profy: 100; ```. Default statistics names used for parameters in **`TPaveStats`**:. ``` {.cpp}; Hist.Stats.Entries Entries; Hist.Stats.Mean Mean; Hist.Stats.MeanX Mean x; Hist.Stats.MeanY Mean y; Hist.Stats.RMS RMS; Hist.Stats.RMSX RMS x; Hist.Stats.RMSY RMS y; Hist.Stats.Underflow Underflow; Hist.Stats.Overflow Overflow; Hist.Stats.Integral Integral; Hist.Stats.Skewness Skewness; Hist.Stats.SkewnessX Skewness x; Hist.Stats.SkewnessY Skewness y; Hist.Stats.Kurtosis Kurtosis; Hist.Stats.KurtosisX Kurtosis x; Hist.Stats.KurtosisY Kurtosis y; ```. ### THtml Specific Settings. See the reference guide documentation of **`THtml`** class at; <https://root.cern/doc/master/classTHtml.html> for more details. XHTML content charset (see; <http://www.w3.org/TR/2002/REC-xhtml1-20020801>, default: ISO-8859-1) is; set by:. ``` {.cpp}; Root.Html.Charset:; ```. Stem of a search engine for the documentation, where `%s` is replaced by; the term entered in the search text box (example:; `http://www.google.com/search?q=%s+site%3Aroot.cern.ch%2Froot%2Fhtml`,; default is `""""`). ``` {.cpp}; Root.Html.Search:; ```. Link to the site's search engine (default: `""""`, example:; `http://root.cern.ch/root/Search.phtml`). ``` {.cpp}; Root.Html.SearchEngine:; ```. String to prepend to `TClass::GetImplFileName()` names containing; directories when looking for source files (default: `""""`, `e`xample:; `../root`). ``` {.cpp}; Root.Html.SourcePrefix:; ```. Link stem to `ViewCVS` entry for classes, where a class name is assumed; to match a file name (default: `""""`, example:; `http://root.cern.ch/viewcvs`). ``` {.cpp}; Root.Html.Vie",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InstallandBuild.md:7311,guid,guide,7311,documentation/users-guide/InstallandBuild.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InstallandBuild.md,1,['guid'],['guide']
Usability,"ns` class. Steering options for the; minimiser, such as the convergence tolerance or the maximum number of; function calls, can also be set using the methods of this class. All; currently implemented minimisers are documented in the reference; documentation of ROOT: have a look for example to the; `ROOT::Math::Minimizer` class documentation.; \newpage; The complication level of the code below is intentionally a little; higher than in the previous examples. The graphical output of the macro; is shown in Figure [6.1](#f61):. ``` {.cpp .numberLines}; @ROOT_INCLUDE_FILE macros/macro8.C; ```. Some step by step explanation is at this point necessary:. - Lines *1-3*: A simple function to ease the make-up of lines.; Remember that the class `TF1` inherits from `TAttLine`. - Lines *5-7* : Definition of a customised function, namely a Gaussian; (the ""signal"") plus a parabolic function, the ""background"". - Lines *10-12*: Some make-up for the Canvas. In particular we want; that the parameters of the fit appear very clearly and nicely on the; plot. - Lines *20-25*: Define and initialise an instance of `TF1`. - Lines *27-31*: Define and fill a histogram. - Lines *33-38*: For convenience, the same function as for the; generation of the pseudo-data is used in the fit; hence, we need to; reset the function parameters. This part of the code is very; important for each fit procedure, as it sets the initial values of; the fit. - Line *41*: A very simple command, well known by now: fit the; function to the histogram. - Lines *42-46*: Retrieve the output from the fit. Here, we simply; print the fit result and access and print the covariance matrix of; the parameters. - Lines *54-end*: Plot the pseudo-data, the fitted function and the; signal and background components at the best-fit values. [f61]: figures/functions.png ""f61""; <a name=""f61""></a>. ![Fit of pseudo data: a signal shape over a background trend. This plot; is another example of how making a plot ""self-explanatory"" can help you; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/functions_and_parameter_estimation.md:2979,clear,clearly,2979,documentation/primer/functions_and_parameter_estimation.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/functions_and_parameter_estimation.md,1,['clear'],['clearly']
Usability,"nside a ``multiclass``; statement. See the ``multiclass`` section below for details. A record can inherit from one or more classes by specifying the; :token:`ParentClassList` clause at the beginning of its record body. All of; the fields in the parent classes are added to the record. If two or more; parent classes provide the same field, the record ends up with the field value; of the last parent class. As a special case, the name of a record can be passed as a template argument; to that record's parent classes. For example:. .. code-block:: text. class A <dag d> {; dag the_dag = d;; }. def rec1 : A<(ops rec1)>;. The DAG ``(ops rec1)`` is passed as a template argument to class ``A``. Notice; that the DAG includes ``rec1``, the record being defined. The steps taken to create a new record are somewhat complex. See `How; records are built`_. See `Examples: classes and records`_ for examples. Examples: classes and records; -----------------------------. Here is a simple TableGen file with one class and two record definitions. .. code-block:: text. class C {; bit V = true;; }. def X : C;; def Y : C {; let V = false;; string Greeting = ""Hello!"";; }. First, the abstract class ``C`` is defined. It has one field named ``V``; that is a bit initialized to true. Next, two records are defined, derived from class ``C``; that is, with ``C``; as their parent class. Thus they both inherit the ``V`` field. Record ``Y``; also defines another string field, ``Greeting``, which is initialized to; ``""Hello!""``. In addition, ``Y`` overrides the inherited ``V`` field,; setting it to false. A class is useful for isolating the common features of multiple records in; one place. A class can initialize common fields to default values, but; records inheriting from that class can override the defaults. TableGen supports the definition of parameterized classes as well as; nonparameterized ones. Parameterized classes specify a list of variable; declarations, which may optionally have defaults, that ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TableGen/ProgRef.rst:29120,simpl,simple,29120,interpreter/llvm-project/llvm/docs/TableGen/ProgRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TableGen/ProgRef.rst,1,['simpl'],['simple']
Usability,"nsider the following example function:. .. code-block:: llvm. define i16 @foo(i16 %a) {; %b = sext i16 %a to i32; %c = and i32 %b, 15; call void @llvm.dbg.value(metadata i32 %c, ...); %d = trunc i32 %c to i16; ret i16 %d; }. Now, here's what happens after the unnecessary truncation instruction ``%d`` is; replaced with a simplified instruction:. .. code-block:: llvm. define i16 @foo(i16 %a) {; call void @llvm.dbg.value(metadata i32 undef, ...); %simplified = and i16 %a, 15; ret i16 %simplified; }. Note that after deleting ``%d``, all uses of its operand ``%c`` become; trivially dead. The debug use which used to point to ``%c`` is now ``undef``,; and debug info is needlessly lost. To solve this problem, do:. .. code-block:: cpp. llvm::replaceAllDbgUsesWith(%c, theSimplifiedAndInstruction, ...). This results in better debug info because the debug use of ``%c`` is preserved:. .. code-block:: llvm. define i16 @foo(i16 %a) {; %simplified = and i16 %a, 15; call void @llvm.dbg.value(metadata i16 %simplified, ...); ret i16 %simplified; }. You may have noticed that ``%simplified`` is narrower than ``%c``: this is not; a problem, because ``llvm::replaceAllDbgUsesWith`` takes care of inserting the; necessary conversion operations into the DIExpressions of updated debug uses. Deleting a MIR-level MachineInstr; ---------------------------------. TODO. Rules for updating ``DIAssignID`` Attachments; =============================================. ``DIAssignID`` metadata attachments are used by Assignment Tracking, which is; currently an experimental debug mode. See :doc:`AssignmentTracking` for how to update them and for more info on; Assignment Tracking. How to automatically convert tests into debug info tests; ========================================================. .. _IRDebugify:. Mutation testing for IR-level transformations; ---------------------------------------------. An IR test case for a transformation can, in many cases, be automatically; mutated to test debug info handl",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToUpdateDebugInfo.rst:8490,simpl,simplified,8490,interpreter/llvm-project/llvm/docs/HowToUpdateDebugInfo.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToUpdateDebugInfo.rst,1,['simpl'],['simplified']
Usability,"nsient; frames will not delete, but just hide existing opened editors for later; reuse. Their lifetime is determined by the canvas to which the manager; editor is attached to, since these will be destroyed together. \image html geometry021.png ""Editors for shapes, materials, media, matrices"" width=600px. For most editors, the functionalities Apply and Undo are provided. For shapes, changing any of the shape parameters will activate the; ""Apply"" button only if the check button ""Delayed draw"" is checked,; otherwise the changes are immediately applied. Once the apply button is; pressed, the changes are applied to the edited shape and drawn. The; ""Undo"" button becomes active after the first modification has been; applied. It allows restoring the initial parameters of the shape. NOTE: In this version the ""Undo"" does not allow restoring an; intermediate state of the parameters that was applied - it will always; restore the parameters at the moment the shape was edited. All material properties changes are undoable. The mixture editor; currently allows adding elements one by one in the mixture composition.; This can be done either by element weight fraction or by number of; atoms. Once an element was added using one method the other method is not; selectable anymore. Summing component fractions up to 1 in the final; mixture is the user responsibility. Adding materials as components of a; mixture is not supported in this version. The elements that were added to the mixture appear in the bottom of the; mixture editor. The operations performed on mixture are not undoable. \anchor GP08d; ### Creation of New Objects. As described above, all geometry object creators are accessible within; the geometry manager editor frame. Generally, if the new object that; needs to be created does not depend on other objects, it will be built; with a set of default parameters. This is the case for all shapes; (except composite shapes) and matrices. For all the other objects the; interface forces",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md:131125,undo,undoable,131125,geom/geom/doc/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md,1,['undo'],['undoable']
Usability,"nst; ``N`` and another check to ensure that the increment step just; increments this same variable. The matcher for (2) is straightforward:; require a pre- or post-increment of the same variable declared in the; init portion. Unfortunately, such a matcher is impossible to write. Matchers contain; no logic for comparing two arbitrary AST nodes and determining whether; or not they are equal, so the best we can do is matching more than we; would like to allow, and punting extra comparisons to the callback. In any case, we can start building this sub-matcher. We can require that; the increment step be a unary increment like this:. .. code-block:: c++. hasIncrement(unaryOperator(hasOperatorName(""++""))). Specifying what is incremented introduces another quirk of Clang's AST:; Usages of variables are represented as ``DeclRefExpr``'s (""declaration; reference expressions"") because they are expressions which refer to; variable declarations. To find a ``unaryOperator`` that refers to a; specific declaration, we can simply add a second condition to it:. .. code-block:: c++. hasIncrement(unaryOperator(; hasOperatorName(""++""),; hasUnaryOperand(declRefExpr()))). Furthermore, we can restrict our matcher to only match if the; incremented variable is an integer:. .. code-block:: c++. hasIncrement(unaryOperator(; hasOperatorName(""++""),; hasUnaryOperand(declRefExpr(to(varDecl(hasType(isInteger()))))))). And the last step will be to attach an identifier to this variable, so; that we can retrieve it in the callback:. .. code-block:: c++. hasIncrement(unaryOperator(; hasOperatorName(""++""),; hasUnaryOperand(declRefExpr(to(; varDecl(hasType(isInteger())).bind(""incrementVariable"")))))). We can add this code to the definition of ``LoopMatcher`` and make sure; that our program, outfitted with the new matcher, only prints out loops; that declare a single variable initialized to zero and have an increment; step consisting of a unary increment of some variable. Now, we just need to add a matcher t",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersTutorial.rst:12231,simpl,simply,12231,interpreter/llvm-project/clang/docs/LibASTMatchersTutorial.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersTutorial.rst,1,['simpl'],['simply']
Usability,"nst`` copies of other; variables, and variables marked ``__block``. In Objective-C, variables may; additionally be objects. When a ``Block`` literal expression is used as the initial value of a global; or ``static`` local variable, it is initialized as follows:. .. code-block:: c. struct __block_literal_1 __block_literal_1 = {; &_NSConcreteGlobalBlock,; (1<<28)|(1<<29), <uninitialized>,; __block_invoke_1,; &__block_descriptor_1; };. that is, a different address is provided as the first value and a particular; (1<<28) bit is set in the ``flags`` field, and otherwise it is the same as for; stack based ``Block`` literals. This is an optimization that can be used for; any ``Block`` literal that imports no ``const`` or ``__block`` storage; variables. Imported Variables; ==================. Variables of ``auto`` storage class are imported as ``const`` copies. Variables; of ``__block`` storage class are imported as a pointer to an enclosing data; structure. Global variables are simply referenced and not considered as; imported. Imported ``const`` copy variables; ---------------------------------. Automatic storage variables not marked with ``__block`` are imported as; ``const`` copies. The simplest example is that of importing a variable of type ``int``:. .. code-block:: c. int x = 10;; void (^vv)(void) = ^{ printf(""x is %d\n"", x); }; x = 11;; vv();. which would be compiled to:. .. code-block:: c. struct __block_literal_2 {; void *isa;; int flags;; int reserved;; void (*invoke)(struct __block_literal_2 *);; struct __block_descriptor_2 *descriptor;; const int x;; };. void __block_invoke_2(struct __block_literal_2 *_block) {; printf(""x is %d\n"", _block->x);; }. static struct __block_descriptor_2 {; unsigned long int reserved;; unsigned long int Block_size;; } __block_descriptor_2 = { 0, sizeof(struct __block_literal_2) };. and:. .. code-block:: c. struct __block_literal_2 __block_literal_2 = {; &_NSConcreteStackBlock,; (1<<29), <uninitialized>,; __block_invoke_2,; &__block_d",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Block-ABI-Apple.rst:6845,simpl,simply,6845,interpreter/llvm-project/clang/docs/Block-ABI-Apple.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Block-ABI-Apple.rst,1,['simpl'],['simply']
Usability,"nstances"" or ""Coros contains 3 coroutine; objects."". In this document, we follow the common practice of using `coroutine` to refer; to an individual `coroutine instance`, since the terms `coroutine instance` and; `coroutine object` aren't sufficiently defined in this case. coroutine frame; ---------------. The C++ Standard uses `coroutine state` to describe the allocated storage. In; the compiler, we use `coroutine frame` to describe the generated data structure; that contains the necessary information. The structure of coroutine frames; =================================. The structure of coroutine frames is defined as:. .. code-block:: c++. struct {; void (*__r)(); // function pointer to the `resume` function; void (*__d)(); // function pointer to the `destroy` function; promise_type; // the corresponding `promise_type`; ... // Any other needed information; }. In the debugger, the function's name is obtainable from the address of the; function. And the name of `resume` function is equal to the name of the; coroutine function. So the name of the coroutine is obtainable once the; address of the coroutine is known. Print promise_type; ==================. Every coroutine has a `promise_type`, which defines the behavior; for the corresponding coroutine. In other words, if two coroutines have the; same `promise_type`, they should behave in the same way.; To print a `promise_type` in a debugger when stopped at a breakpoint inside a; coroutine, printing the `promise_type` can be done by:. .. parsed-literal::. print __promise. It is also possible to print the `promise_type` of a coroutine from the address; of the coroutine frame. For example, if the address of a coroutine frame is; 0x416eb0, and the type of the `promise_type` is `task::promise_type`, printing; the `promise_type` can be done by:. .. parsed-literal::. print (task::promise_type)*(0x416eb0+0x10). This is possible because the `promise_type` is guaranteed by the ABI to be at a; 16 bit offset from the coroutine fra",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DebuggingCoroutines.rst:3143,resume,resume,3143,interpreter/llvm-project/clang/docs/DebuggingCoroutines.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DebuggingCoroutines.rst,1,['resume'],['resume']
Usability,nstead of ``DW_OP_add`` when; acting on a location description. Need to provide examples of new features. .. _amdgpu-dwarf-references:. D. References; =============. .. _amdgpu-dwarf-AMD:. 1. [AMD] `Advanced Micro Devices <https://www.amd.com/>`__. .. _amdgpu-dwarf-AMD-ROCgdb:. 2. [AMD-ROCgdb] `AMD ROCm Debugger (ROCgdb) <https://github.com/ROCm-Developer-Tools/ROCgdb>`__. .. _amdgpu-dwarf-AMD-ROCm:. 3. [AMD-ROCm] `AMD ROCm Platform <https://rocm-documentation.readthedocs.io>`__. .. _amdgpu-dwarf-AMDGPU-DWARF-LOC:. 4. [AMDGPU-DWARF-LOC] `Allow Location Descriptions on the DWARF Expression Stack <https://llvm.org/docs/AMDGPUDwarfExtensionAllowLocationDescriptionOnTheDwarfExpressionStack/AMDGPUDwarfExtensionAllowLocationDescriptionOnTheDwarfExpressionStack.html>`__. .. _amdgpu-dwarf-AMDGPU-LLVM:. 5. [AMDGPU-LLVM] `User Guide for AMDGPU LLVM Backend <https://llvm.org/docs/AMDGPUUsage.html>`__. .. _amdgpu-dwarf-CUDA:. 6. [CUDA] `Nvidia CUDA Language <https://docs.nvidia.com/cuda/cuda-c-programming-guide/>`__. .. _amdgpu-dwarf-DWARF:. 7. [DWARF] `DWARF Debugging Information Format <http://dwarfstd.org/>`__. .. _amdgpu-dwarf-ELF:. 8. [ELF] `Executable and Linkable Format (ELF) <http://www.sco.com/developers/gabi/>`__. .. _amdgpu-dwarf-GCC:. 9. [GCC] `GCC: The GNU Compiler Collection <https://www.gnu.org/software/gcc/>`__. .. _amdgpu-dwarf-GDB:. 10. [GDB] `GDB: The GNU Project Debugger <https://www.gnu.org/software/gdb/>`__. .. _amdgpu-dwarf-HIP:. 11. [HIP] `HIP Programming Guide <https://rocm-documentation.readthedocs.io/en/latest/Programming_Guides/Programming-Guides.html#hip-programing-guide>`__. .. _amdgpu-dwarf-HSA:. 12. [HSA] `Heterogeneous System Architecture (HSA) Foundation <http://www.hsafoundation.com/>`__. .. _amdgpu-dwarf-LLVM:. 13. [LLVM] `The LLVM Compiler Infrastructure <https://llvm.org/>`__. .. _amdgpu-dwarf-OpenCL:. 14. [OpenCL] `The OpenCL Specification Version 2.0 <http://www.khronos.org/registry/cl/specs/opencl-2.0.pdf>`__. .. _amdgpu-dwarf-Perforce-To,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst:235254,guid,guide,235254,interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,1,['guid'],['guide']
Usability,"nstructExpr(requiresZeroInitialization())); will match the implicit array filler for pt[1]. Matcher<CXXConstructorDecl>isCopyConstructor; Matches constructor declarations that are copy constructors. Given; struct S {; S(); // #1; S(const S &); // #2; S(S &&); // #3; };; cxxConstructorDecl(isCopyConstructor()) will match #2, but not #1 or #3. Matcher<CXXConstructorDecl>isDefaultConstructor; Matches constructor declarations that are default constructors. Given; struct S {; S(); // #1; S(const S &); // #2; S(S &&); // #3; };; cxxConstructorDecl(isDefaultConstructor()) will match #1, but not #2 or #3. Matcher<CXXConstructorDecl>isDelegatingConstructor; Matches constructors that delegate to another constructor. Given; struct S {; S(); // #1; S(int) {} // #2; S(S &&) : S() {} // #3; };; S::S() : S(0) {} // #4; cxxConstructorDecl(isDelegatingConstructor()) will match #3 and #4, but not; #1 or #2. Matcher<CXXConstructorDecl>isExplicit; Matches constructor, conversion function, and deduction guide declarations; that have an explicit specifier if this explicit specifier is resolved to; true. Given; template<bool b>; struct S {; S(int); // #1; explicit S(double); // #2; operator int(); // #3; explicit operator bool(); // #4; explicit(false) S(bool) // # 7; explicit(true) S(char) // # 8; explicit(b) S(S) // # 9; };; S(int) -> S<true> // #5; explicit S(double) -> S<false> // #6; cxxConstructorDecl(isExplicit()) will match #2 and #8, but not #1, #7 or #9.; cxxConversionDecl(isExplicit()) will match #4, but not #3.; cxxDeductionGuideDecl(isExplicit()) will match #6, but not #5. Matcher<CXXConstructorDecl>isInheritingConstructor. Matcher<CXXConstructorDecl>isMoveConstructor; Matches constructor declarations that are move constructors. Given; struct S {; S(); // #1; S(const S &); // #2; S(S &&); // #3; };; cxxConstructorDecl(isMoveConstructor()) will match #3, but not #1 or #2. Matcher<CXXConversionDecl>isExplicit; Matches constructor, conversion function, and deduction guide declar",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:61238,guid,guide,61238,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,1,['guid'],['guide']
Usability,"nstrumented. Use these flags together with ``trace-pc-guard`` or ``trace-pc``,; like this: ``-fsanitize-coverage=func,trace-pc-guard``. When ``edge`` or ``bb`` is used, some of the edges/blocks may still be left; uninstrumented (pruned) if such instrumentation is considered redundant.; Use ``no-prune`` (e.g. ``-fsanitize-coverage=bb,no-prune,trace-pc-guard``); to disable pruning. This could be useful for better coverage visualization. Edge coverage; -------------. Consider this code:. .. code-block:: c++. void foo(int *a) {; if (a); *a = 0;; }. It contains 3 basic blocks, let's name them A, B, C:. .. code-block:: none. A; |\; | \; | B; | /; |/; C. If blocks A, B, and C are all covered we know for certain that the edges A=>B; and B=>C were executed, but we still don't know if the edge A=>C was executed.; Such edges of control flow graph are called; `critical <https://en.wikipedia.org/wiki/Control_flow_graph#Special_edges>`_.; The edge-level coverage simply splits all critical edges by introducing new; dummy blocks and then instruments those blocks:. .. code-block:: none. A; |\; | \; D B; | /; |/; C. Tracing data flow; =================. Support for data-flow-guided fuzzing.; With ``-fsanitize-coverage=trace-cmp`` the compiler will insert extra instrumentation; around comparison instructions and switch statements.; Similarly, with ``-fsanitize-coverage=trace-div`` the compiler will instrument; integer division instructions (to capture the right argument of division); and with ``-fsanitize-coverage=trace-gep`` --; the `LLVM GEP instructions <https://llvm.org/docs/GetElementPtr.html>`_; (to capture array indices).; Similarly, with ``-fsanitize-coverage=trace-loads`` and ``-fsanitize-coverage=trace-stores``; the compiler will instrument loads and stores, respectively. Currently, these flags do not work by themselves - they require one; of ``-fsanitize-coverage={trace-pc,inline-8bit-counters,inline-bool}``; flags to work. Unless ``no-prune`` option is provided, some of the",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SanitizerCoverage.rst:8583,simpl,simply,8583,interpreter/llvm-project/clang/docs/SanitizerCoverage.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SanitizerCoverage.rst,1,['simpl'],['simply']
Usability,"nt of a ``multiclass``, such as the use of ``Bar`` in::. multiclass Foo <int Bar> {; def : SomeClass<Bar>;; }. * A variable defined with the ``defvar`` or ``defset`` statements. * The iteration variable of a ``foreach``, such as the use of ``i`` in::. foreach i = 0...5 in; def Foo#i;. .. productionlist::; SimpleValue8: `ClassID` ""<"" `ArgValueList` "">"". This form creates a new anonymous record definition (as would be created by an; unnamed ``def`` inheriting from the given class with the given template; arguments; see `def`_) and the value is that record. A field of the record can be; obtained using a suffix; see `Suffixed Values`_. Invoking a class in this manner can provide a simple subroutine facility.; See `Using Classes as Subroutines`_ for more information. .. productionlist::; SimpleValue9: `BangOperator` [""<"" `Type` "">""] ""("" `ValueListNE` "")""; :| `CondOperator` ""("" `CondClause` ("","" `CondClause`)* "")""; CondClause: `Value` "":"" `Value`. The bang operators provide functions that are not available with the other; simple values. Except in the case of ``!cond``, a bang operator takes a list; of arguments enclosed in parentheses and performs some function on those; arguments, producing a value for that bang operator. The ``!cond`` operator; takes a list of pairs of arguments separated by colons. See `Appendix A:; Bang Operators`_ for a description of each bang operator. Suffixed values; ---------------. The :token:`SimpleValue` values described above can be specified with; certain suffixes. The purpose of a suffix is to obtain a subvalue of the; primary value. Here are the possible suffixes for some primary *value*. *value*\ ``{17}``; The final value is bit 17 of the integer *value* (note the braces). *value*\ ``{8...15}``; The final value is bits 8--15 of the integer *value*. The order of the; bits can be reversed by specifying ``{15...8}``. *value*\ ``[i]``; The final value is element `i` of the list *value* (note the brackets).; In other words, the brackets act as",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TableGen/ProgRef.rst:18288,simpl,simple,18288,interpreter/llvm-project/llvm/docs/TableGen/ProgRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TableGen/ProgRef.rst,1,['simpl'],['simple']
Usability,"nt to describe. The instance variables for an ARC-compiled class will be destroyed at some; point after control enters the ``dealloc`` method for the root class of the; class. The ordering of the destruction of instance variables is unspecified,; both within a single class and between subclasses and superclasses. .. admonition:: Rationale. The traditional, non-ARC pattern for destroying instance variables is to; destroy them immediately before calling ``[super dealloc]``. Unfortunately,; message sends from the superclass are quite capable of reaching methods in; the subclass, and those methods may well read or write to those instance; variables. Making such message sends from dealloc is generally discouraged,; since the subclass may well rely on other invariants that were broken during; ``dealloc``, but it's not so inescapably dangerous that we felt comfortable; calling it undefined behavior. Therefore we chose to delay destroying the; instance variables to a point at which message sends are clearly disallowed:; the point at which the root class's deallocation routines take over. In most code, the difference is not observable. It can, however, be observed; if an instance variable holds a strong reference to an object whose; deallocation will trigger a side-effect which must be carefully ordered with; respect to the destruction of the super class. Such code violates the design; principle that semantically important behavior should be explicit. A simple; fix is to clear the instance variable manually during ``dealloc``; a more; holistic solution is to move semantically important side-effects out of; ``dealloc`` and into a separate teardown phase which can rely on working with; well-formed objects. .. _arc.misc.autoreleasepool:. ``@autoreleasepool``; --------------------. To simplify the use of autorelease pools, and to bring them under the control; of the compiler, a new kind of statement is available in Objective-C. It is; written ``@autoreleasepool`` followed by a *c",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst:89713,clear,clearly,89713,interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,1,['clear'],['clearly']
Usability,"nt with new TWebCanvas - interactivity, attributes/position updates; 12. Provide initial WebVR support (#176), thanks to Diego Marcos (@dmarcos); 13. Upgrade three.js 86 -> 102, use SoftwareRenderer instead of CanvasRenderer; 14. Upgrade d3.js 4.4.4 -> 5.7.0; 15. Use d3.js and three.js from npm when running with node.js; 16. Fix - support clipping for tracks and points in geo painter; 17. Fix - drawing of TGeoNode with finder; 18. Fix - key press events processed only in active pad (ROOT-9128); 19. Fix - use X0/Y0 in xtru shape (#182), thanks to @altavir; 20. Move most of ui5-specific code into ROOT repository, where it will be maintained; 21. Provide special widget for object inspector. ## Changes in 5.6.4; 1. Fix - try workaround corrupted data in TTree; 2. Fix - support min0 draw option like ROOT does; 3. Fix - correctly handle TH2Poly draw options; 4. Fix - seldom error in JSROOT.cleanup; 5. Fix - repair TTree player UI; 6. Fix - error in TH3 filling; 7. Fix - correctly access top element in simple layout; 8. Fix - exclude duplicated points when drawing TH2 with SURF3 options. ## Changes in 5.6.3; 1. Fix - support clipping for tracks and points in geo painter; 2. Fix - geometry with TGeoNodeOffset was not correctly drawn; 3. Fix - use proper formatting for entries and integral (#179); 4. Fix - TTree::Draw for 3d histogram was not properly performed. ## Changes in 5.6.2; 1. Fix - correctly handle negative parameter values in TF1/TF2. ## Changes in 5.6.1; 1. Add TMath.BreitWigner function; 2. Support custom streamers for TMaterial and TMixture (very old examples); 3. Fix Y-scale drawing of THStack (https://root-forum.cern.ch/t/31266); 4. Fix - select palette from colz element; 5. Fix - LZ4 uncompression of large buffers. ## Changes in 5.6.0; 1. By drawing outline speed up (factor 10) canvas with many small sub-pads; 2. Let configure user click and double-click handlers, extend tooltip.htm example; 3. Implement workaround for standard THREE.SVGRenderer - no need fo",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/changes.md:31452,simpl,simple,31452,js/changes.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/changes.md,1,['simpl'],['simple']
Usability,"ntal progressive bars; TGVerticalFrame *vframe = new TGVerticalFrame(fMain, 10, 10);; fHProg1 = new TGHProgressBar(vframe,TGProgressBar::kStandard,300);; fHProg1->ShowPosition();; fHProg1->SetBarColor(""yellow"");; fHProg2 = new TGHProgressBar(vframe,TGProgressBar::kFancy,300);; fHProg2->SetBarColor(""lightblue"");; fHProg2->ShowPosition(kTRUE,kFALSE,""%.0f events"");; fHProg3 = new TGHProgressBar(vframe,TGProgressBar::kStandard,300);; fHProg3->SetFillType(TGProgressBar::kBlockFill);. vframe->AddFrame(fHProg1,new TGLayoutHints(kLHintsTop|kLHintsLeft|; kLHintsExpandX,5,5,5,10));; vframe->AddFrame(fHProg2,new TGLayoutHints(kLHintsTop|kLHintsLeft|; kLHintsExpandX,5,5,5,10));; vframe->AddFrame(fHProg3,new TGLayoutHints(kLHintsTop|kLHintsLeft|; kLHintsExpandX,5,5,5,10));; vframe->Resize(200, 200);; ```. ### Static Widgets. The classes **`TGLabel`** and **`TGIcon`** show some information - text; or graphics. The line below creates a label object. The syntax is very; simple: you specify the parent widget and a string object holding the; desired text. ``` {.cpp}; TGLabel *label = new TGLabel(parentWidget, ""Label's string"");; ```. Next sample creates an icon object. First we create an object of type; **`TGPicture`**. The **`TGPicture`** objects are never created directly; by the application code. We call **`TGClient`** telling it the pixmap's; file name to create a **`TGPicture`** object and, in turn, it will; return a pointer to the created object. If the pixmap file cannot be; found the returned pointer will be `NULL`. As usual, the first parameter; of a **`TGIcon`** constructor is the parent frame. The second one is the; **`TGPicture`** object holding the pixmap we want to show. Last two; parameters define the width and height of pixmap in pixels. In the end; we add the created icon object to its parent. ``` {.cpp}; // icon widget; const TGPicture *ipic=(TGPicture *)gClient->GetPicture(""leaf.xpm"");; TGIcon *icon = new TGIcon(parent,ipic,40,40);; parent->AddFrame(icon,new TGLayou",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md:89860,simpl,simple,89860,documentation/users-guide/WritingGUI.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md,1,['simpl'],['simple']
Usability,"nter as an argument (which it; then propagates). This can sometimes be useful, allowing you to combine; several null checks into one. These five templates can be used with any classes, whether they have a v-table; or not. If you want to add support for these templates, see the document; :doc:`How to set up LLVM-style RTTI for your class hierarchy; <HowToSetUpLLVMStyleRTTI>`. .. _string_apis:. Passing strings (the ``StringRef`` and ``Twine`` classes); ---------------------------------------------------------. Although LLVM generally does not do much string manipulation, we do have several; important APIs which take strings. Two important examples are the Value class; -- which has names for instructions, functions, etc. -- and the ``StringMap``; class which is used extensively in LLVM and Clang. These are generic classes, and they need to be able to accept strings which may; have embedded null characters. Therefore, they cannot simply take a ``const; char *``, and taking a ``const std::string&`` requires clients to perform a heap; allocation which is usually unnecessary. Instead, many LLVM APIs use a; ``StringRef`` or a ``const Twine&`` for passing strings efficiently. .. _StringRef:. The ``StringRef`` class; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^. The ``StringRef`` data type represents a reference to a constant string (a; character array and a length) and supports the common operations available on; ``std::string``, but does not require heap allocation. It can be implicitly constructed using a C style null-terminated string, an; ``std::string``, or explicitly with a character pointer and length. For; example, the ``StringMap`` find function is declared as:. .. code-block:: c++. iterator find(StringRef Key);. and clients can call it using any one of:. .. code-block:: c++. Map.find(""foo""); // Lookup ""foo""; Map.find(std::string(""bar"")); // Lookup ""bar""; Map.find(StringRef(""\0baz"", 4)); // Lookup ""\0baz"". Similarly, APIs which need to return a string may return a ``StringRef``; ins",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:8114,simpl,simply,8114,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,1,['simpl'],['simply']
Usability,"nts to the container. .. _ds_sequential:. Sequential Containers (std::vector, std::list, etc); ---------------------------------------------------. There are a variety of sequential containers available for you, based on your; needs. Pick the first in this section that will do what you want. .. _dss_arrayref:. llvm/ADT/ArrayRef.h; ^^^^^^^^^^^^^^^^^^^. The ``llvm::ArrayRef`` class is the preferred class to use in an interface that; accepts a sequential list of elements in memory and just reads from them. By; taking an ``ArrayRef``, the API can be passed a fixed size array, an; ``std::vector``, an ``llvm::SmallVector`` and anything else that is contiguous; in memory. .. _dss_fixedarrays:. Fixed Size Arrays; ^^^^^^^^^^^^^^^^^. Fixed size arrays are very simple and very fast. They are good if you know; exactly how many elements you have, or you have a (low) upper bound on how many; you have. .. _dss_heaparrays:. Heap Allocated Arrays; ^^^^^^^^^^^^^^^^^^^^^. Heap allocated arrays (``new[]`` + ``delete[]``) are also simple. They are good; if the number of elements is variable, if you know how many elements you will; need before the array is allocated, and if the array is usually large (if not,; consider a :ref:`SmallVector <dss_smallvector>`). The cost of a heap allocated; array is the cost of the new/delete (aka malloc/free). Also note that if you; are allocating an array of a type with a constructor, the constructor and; destructors will be run for every element in the array (re-sizable vectors only; construct those elements actually used). .. _dss_tinyptrvector:. llvm/ADT/TinyPtrVector.h; ^^^^^^^^^^^^^^^^^^^^^^^^. ``TinyPtrVector<Type>`` is a highly specialized collection class that is; optimized to avoid allocation in the case when a vector has zero or one; elements. It has two major restrictions: 1) it can only hold values of pointer; type, and 2) it cannot hold a null pointer. Since this container is highly specialized, it is rarely used. .. _dss_smallvector:. llvm/",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:58403,simpl,simple,58403,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,1,['simpl'],['simple']
Usability,"number of code blocks or edges covered by executing the current corpus.; ``ft:``; libFuzzer uses different signals to evaluate the code coverage:; edge coverage, edge counters, value profiles, indirect caller/callee pairs, etc.; These signals combined are called *features* (`ft:`).; ``corp:``; Number of entries in the current in-memory test corpus and its size in bytes.; ``lim:``; Current limit on the length of new entries in the corpus. Increases over time; until the max length (``-max_len``) is reached.; ``exec/s:``; Number of fuzzer iterations per second.; ``rss:``; Current memory consumption. For ``NEW`` and ``REDUCE`` events, the output line also includes information; about the mutation operation that produced the new input:. ``L:``; Size of the new input in bytes.; ``MS: <n> <operations>``; Count and list of the mutation operations used to generate the input. Examples; ========; .. contents::; :local:; :depth: 1. Toy example; -----------. A simple function that does something interesting if it receives the input; ""HI!""::. cat << EOF > test_fuzzer.cc; #include <stdint.h>; #include <stddef.h>; extern ""C"" int LLVMFuzzerTestOneInput(const uint8_t *data, size_t size) {; if (size > 0 && data[0] == 'H'); if (size > 1 && data[1] == 'I'); if (size > 2 && data[2] == '!'); __builtin_trap();; return 0;; }; EOF; # Build test_fuzzer.cc with asan and link against libFuzzer.; clang++ -fsanitize=address,fuzzer test_fuzzer.cc; # Run the fuzzer with no corpus.; ./a.out. You should get an error pretty quickly::. INFO: Seed: 1523017872; INFO: Loaded 1 modules (16 guards): [0x744e60, 0x744ea0),; INFO: -max_len is not provided, using 64; INFO: A corpus is not provided, starting from an empty corpus; #0	READ units: 1; #1	INITED cov: 3 ft: 2 corp: 1/1b exec/s: 0 rss: 24Mb; #3811	NEW cov: 4 ft: 3 corp: 2/2b exec/s: 0 rss: 25Mb L: 1 MS: 5 ChangeBit-ChangeByte-ChangeBit-ShuffleBytes-ChangeByte-; #3827	NEW cov: 5 ft: 4 corp: 3/4b exec/s: 0 rss: 25Mb L: 2 MS: 1 CopyPart-; #3963	NEW cov: 6 f",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LibFuzzer.rst:17682,simpl,simple,17682,interpreter/llvm-project/llvm/docs/LibFuzzer.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LibFuzzer.rst,1,['simpl'],['simple']
Usability,"nusual circumstances. .. _SymbolTable:. The ``ValueSymbolTable`` class; ------------------------------. The ``ValueSymbolTable`` (`doxygen; <https://llvm.org/doxygen/classllvm_1_1ValueSymbolTable.html>`__) class provides; a symbol table that the :ref:`Function <c_Function>` and Module_ classes use for; naming value definitions. The symbol table can provide a name for any Value_. Note that the ``SymbolTable`` class should not be directly accessed by most; clients. It should only be used when iteration over the symbol table names; themselves are required, which is very special purpose. Note that not all LLVM; Value_\ s have names, and those without names (i.e. they have an empty name) do; not exist in the symbol table. Symbol tables support iteration over the values in the symbol table with; ``begin/end/iterator`` and supports querying to see if a specific name is in the; symbol table (with ``lookup``). The ``ValueSymbolTable`` class exposes no; public mutator methods, instead, simply call ``setName`` on a value, which will; autoinsert it into the appropriate symbol table. .. _UserLayout:. The ``User`` and owned ``Use`` classes' memory layout; -----------------------------------------------------. The ``User`` (`doxygen <https://llvm.org/doxygen/classllvm_1_1User.html>`__); class provides a basis for expressing the ownership of ``User`` towards other; `Value instance <https://llvm.org/doxygen/classllvm_1_1Value.html>`_\ s. The; ``Use`` (`doxygen <https://llvm.org/doxygen/classllvm_1_1Use.html>`__) helper; class is employed to do the bookkeeping and to facilitate *O(1)* addition and; removal. .. _Use2User:. Interaction and relationship between ``User`` and ``Use`` objects; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. A subclass of ``User`` can choose between incorporating its ``Use`` objects or; refer to them out-of-line by means of a pointer. A mixed variant (some ``Use``; s inline others hung off) is impractical and breaks the invariant that the;",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:126478,simpl,simply,126478,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,1,['simpl'],['simply']
Usability,"ny '``indirect``' blocks(s). The only use of this today is to implement the ""goto"" feature of gcc inline; assembly where additional labels can be provided as locations for the inline; assembly to jump to. Example:; """""""""""""""". .. code-block:: llvm. ; ""asm goto"" without output constraints.; callbr void asm """", ""r,!i""(i32 %x); to label %fallthrough [label %indirect]. ; ""asm goto"" with output constraints.; <result> = callbr i32 asm """", ""=r,r,!i""(i32 %x); to label %fallthrough [label %indirect]. .. _i_resume:. '``resume``' Instruction; ^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. resume <type> <value>. Overview:; """""""""""""""""". The '``resume``' instruction is a terminator instruction that has no; successors. Arguments:; """""""""""""""""""". The '``resume``' instruction requires one argument, which must have the; same type as the result of any '``landingpad``' instruction in the same; function. Semantics:; """""""""""""""""""". The '``resume``' instruction resumes propagation of an existing; (in-flight) exception whose unwinding was interrupted with a; :ref:`landingpad <i_landingpad>` instruction. Example:; """""""""""""""". .. code-block:: llvm. resume { ptr, i32 } %exn. .. _i_catchswitch:. '``catchswitch``' Instruction; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. <resultval> = catchswitch within <parent> [ label <handler1>, label <handler2>, ... ] unwind to caller; <resultval> = catchswitch within <parent> [ label <handler1>, label <handler2>, ... ] unwind label <default>. Overview:; """""""""""""""""". The '``catchswitch``' instruction is used by `LLVM's exception handling system; <ExceptionHandling.html#overview>`_ to describe the set of possible catch handlers; that may be executed by the :ref:`EH personality routine <personalityfn>`. Arguments:; """""""""""""""""""". The ``parent`` argument is the token of the funclet that contains the; ``catchswitch`` instruction. If the ``catchswitch`` is not inside a funclet,; this operand may be the token ``none``. The ``default`` argument is the label of another basi",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:370117,resume,resume,370117,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,2,['resume'],"['resume', 'resumes']"
Usability,"o (and update) the list of files in the file browser (left panel) when opening a ROOT file from the ""Open File"" menu. TGListView. Keyboard navigation is now fully working in the list view. TGMainFrame. Allow to save a snapshot of the GUI in a picture file. The supported formats are gif, jpg, png, tiff, and xpm. TGFileDialog. Allow to change directory by typing its name in the text entry field of the dialog. TProofProgressDialog. Added a speedometer widget (TGSpeedo) to display the processing rate; Added a check button to enable/disable smooth update of the speedometer (enabled by default). This could be useful in the case of slow displays (e.g. when using it via ssh); Several layout improvements. TRecorder. Improvements and consolidation of the cross-platform interoperability, allowing to record and replay sessions between different platforms with less side effects. NB: Using different OS/WM (Window Managers) and using different ROOT GUI settings (via e.g. system.rootrc) between recording and replaying may still produce a wrong behavior of the recorder.; New tutorial guitest_playback.C replaying a recorded session showing and validating the GUI (using guitest.C). GUI Builder; New features, new user interface; Several important features have been added to the builder, and its user interface has been redesigned.; Editing modes are now clearly distinguished with enabled and disabled layout mode. Possibility to enable automatic layout fasten the interface development, as the positioning doesn't have to be done manually anymore; Major changes in the user interface:. Added a list tree displaying the complete structure of the GUI; The name of every element of the GUI is now editable; New, more intuitive interface for padding and layout hints; Color settings option was added to the widget editor; Extended commands in the top menu (open project, save project...); Added important warning dialogs, such as ""Save project"" dialog when closing the window; Added several tool tips. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/doc/v526/index.html:1925,clear,clearly,1925,gui/doc/v526/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/doc/v526/index.html,2,"['clear', 'intuit']","['clearly', 'intuitive']"
Usability,"o 0 allows to remove the end-caps both on the graph and the legend.; It was requested [here](https://sft.its.cern.ch/jira/browse/ROOT-9184); - New color palette ""cividis"" implemented by Sven Augustin.; This colormap aims to solve problems that people with color vision deficiency have; with the common colormaps. For more details see:; Nuñez J, Anderton C, and Renslow R. Optimizing colormaps with consideration; for color vision deficiency to enable accurate interpretation of scientific data.; See the article [here](https://arxiv.org/abs/1712.01662); - New graphics style ""ATLAS"" from M.Sutton.; - In `TGraphPainter` the fit parameters were painted too early. [In some cases graph's; error bars overlapped the stat box](https://root-forum.cern.ch/t/hide-error-bars-behind-tpavestats/27996).; - Implement the possibility to generate high definition bitmap pictures in `TImageDump`.; This done via `gStyle->SetImageScaling(x);` `x` being a multiplication factor.; This new feature is now used to generate the reference guide with `x=3`.; Pictures in the reference guide are now much shaper and in particular the text. ## 3D Graphics Libraries; - When a LEGO plot was drawn with Theta=90, the X and Y axis were misplaced. ## Geometry Libraries. ## Database Libraries; - Fix issue related to time stamps manipulation done by `TPgSQLStatement` as suggested [here](https://root-forum.cern.ch/t/please-correct-bug-reading-date-time-from-postgresql-tpgsqlstatement). ## Networking Libraries; - New THttpWSHandler class should be used to work with websockets. It includes all necessary methods to handle multiple connections correctly. See in tutorials/http/ws.C how it can be used.; - Interface of THttpWSEngine class was changed, all its instances handled internally in THttpWSHandler. ## GUI Libraries. ## Montecarlo Libraries. ## Parallelism; - `TTree::GetEntry`: if IMT is enabled, run work in tasks if we have at least more than one top level branch.; - Make EnableImplicitMT no-op if IMT is already ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v614/index.md:13933,guid,guide,13933,README/ReleaseNotes/v614/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v614/index.md,1,['guid'],['guide']
Usability,"o be any digit-only value specified; by the user, which permits testing the compiler against existing OpenACC; workloads in order to evaluate implementation progress. Target Specific Changes; -----------------------. AMDGPU Support; ^^^^^^^^^^^^^^; - Use pass-by-reference (byref) in stead of pass-by-value (byval) for struct; arguments in C ABI. Callee is responsible for allocating stack memory and; copying the value of the struct if modified. Note that AMDGPU backend still; supports byval for struct arguments.; - The default value for ``-mcode-object-version`` is now 5.; See `AMDHSA Code Object V5 Metadata <https://llvm.org/docs/AMDGPUUsage.html#code-object-v5-metadata>`_; for more details. X86 Support; ^^^^^^^^^^^. - Added option ``-m[no-]evex512`` to disable ZMM and 64-bit mask instructions; for AVX512 features.; - Support ISA of ``USER_MSR``.; * Support intrinsic of ``_urdmsr``.; * Support intrinsic of ``_uwrmsr``.; - Support ISA of ``AVX10.1``.; - ``-march=pantherlake`` and ``-march=clearwaterforest`` are now supported.; - Added ABI handling for ``__float128`` to match with GCC.; - Emit warnings for options to enable knl/knm specific ISAs: AVX512PF, AVX512ER; and PREFETCHWT1. From next version (LLVM 19), these ISAs' intrinsic supports; will be deprecated:; * intrinsic series of *_exp2a23_*; * intrinsic series of *_rsqrt28_*; * intrinsic series of *_rcp28_*; * intrinsic series of *_prefetch_i[3|6][2|4]gather_*; * intrinsic series of *_prefetch_i[3|6][2|4]scatter_*. Arm and AArch64 Support; ^^^^^^^^^^^^^^^^^^^^^^^. - C++ function name mangling has been changed to align with the specification; (https://github.com/ARM-software/abi-aa/blob/main/aapcs64/aapcs64.rst).; This affects C++ functions with SVE ACLE parameters. Clang will use the old; manglings if ``-fclang-abi-compat=17`` or lower is specified. - New AArch64 asm constraints have been added for r8-r11(Uci) and r12-r15(Ucj). - Support has been added for the following processors (-mcpu identifiers in parenthesis",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst:59955,clear,clearwaterforest,59955,interpreter/llvm-project/clang/docs/ReleaseNotes.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst,1,['clear'],['clearwaterforest']
Usability,"o do the logic of your analysis. The `TTree::MakeSelector` is the recommended method for ROOT data; analysis. It is especially important for large data set in a parallel; processing configuration where the analysis is distributed over several; processors and you can specify which entries to send to each processor.; With `MakeClass` the user has control over the event loop, with; `MakeSelector `the tree is in control of the event loop. ## Simple Analysis Using TTree::Draw. We will use the tree in `cernstaff.root` that was made by the macro in; `$ROOTSYS/tutorials/tree/staff.C`. First, open the file and lists its contents. ``` {.cpp}; root[] TFile f (""cernstaff.root""); root[] f.ls(); TFile** cernstaff.root; TFile* cernstaff.root; KEY: TTree T;1 staff data from ascii file; ```. We can see the **`TTree `**""`T`"" in the file. We will use it to; experiment with the **`TTree::Draw`** method, so let's create a pointer to it:. ``` {.cpp}; root[] TTree *MyTree = T; ```. Cling allows us to get simply the object by using it. Here we define a; pointer to a **`TTree`** object and assign it the value of ""`T`"", the; **`TTree`** in the file. Cling looks for an object named ""`T`"" in the; current ROOT file and returns it (this assumes that ""T"" has not; previously been used to declare a variable or function). In contrast, in compiled code, you can use:. ``` {.cpp}; TTree *MyTree;f.GetObject(""T"",MyTree);; ```. To show the different `Draw` options, we create a canvas with four; sub-pads. We will use one sub-pad for each `Draw` command. ``` {.cpp}; root[] TCanvas *myCanvas = new TCanvas(); root[] myCanvas->Divide(2,2); ```. We activate the first pad with the `TCanvas::cd` statement:. ``` {.cpp}; root[] myCanvas->cd(1); ```. We then draw the variable `Cost`:. ``` {.cpp}; root[] MyTree->Draw(""C; ```. As you can see, the last call `TTree::Draw` has only one parameter. It; is a string containing the leaf name. A histogram is automatically; created as a result of a `TTree::Draw`. The style of t",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:69116,simpl,simply,69116,documentation/users-guide/Trees.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md,1,['simpl'],['simply']
Usability,"o know the current direction `(nx,ny,nz)`. This; direction is stored as `Double_t fCurrentDirection[3]` by the navigator; and it represents a direction in the global frame. It can be retrieved; with:. ``` {.cpp}; Const Double_t *cdir = gGeoManager->GetCurrentDirection();; ```. The direction can be initialized in a similar manner as the current; point:. ``` {.cpp}; gGeoManager->SetCurrentDirection(nx,ny,nz);; // or:; gGeoManager->SetCurrentDirection(Double_t *dir);; ```. ### Initializing the State. Setting the initial point and direction is not enough for initializing; tracking. The modeller needs to find out where the initial point is; located in the geometrical hierarchy. Due to the containment based; architecture of the model, this is the deepest positioned object; containing the point. For illustrating this, imagine that we have a; simple structure with a top volume `A` and another one `B `positioned; inside. Since `A `is a top volume, its associated node `A_1` will define; `MARS` and our simple hierarchy of nodes (positioned volumes) will be:; `/A_1/B_1`. Suppose now that the initial point is contained by `B_1`.; This implies by default that the point is also contained by `A_1`, since; `B_1` have to be fully contained by this. After searching the point; location, the modeller will consider that the point is located inside; `B_1`, which will be considered as the representative object (node) for; the current state. This is stored as: **`TGeoNode`**; \*`TGeoManager::fCurrentNode `and can be asked from the manager class; only after the `'Where am I?'` was completed:. ``` {.cpp}; TGeoNode *current = gGeoManager->GetCurrentNode();; ```. In order to find the location of the current point inside the hierarchy; of nodes, after setting this point it is mandatory to call the; `‘Where am I?'` method:. ``` {.cpp}; gGeoManager->FindNode();; ```. In order to have more flexibility, there are in fact several alternative; ways of initializing a modeller state:. ``` {.cpp}; // Set",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:105621,simpl,simple,105621,documentation/users-guide/Geometry.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md,1,['simpl'],['simple']
Usability,"o not access or only read non-local memory, and marking them; ``readnone``/``readonly``. In addition, it marks function arguments (of; pointer type) ""``nocapture``"" if a call to the function does not create any; copies of the pointer value that outlive the call. This more or less means; that the pointer is only dereferenced, and not returned from the function or; stored in a global. This pass is implemented as a bottom-up traversal of the; call-graph. ``globaldce``: Dead Global Elimination; --------------------------------------. This transform is designed to eliminate unreachable internal globals from the; program. It uses an aggressive algorithm, searching out globals that are known; to be alive. After it finds all of the globals which are needed, it deletes; whatever is left over. This allows it to delete recursive chunks of the; program which are unreachable. ``globalopt``: Global Variable Optimizer; ----------------------------------------. This pass transforms simple global variables that never have their address; taken. If obviously true, it marks read/write globals as constant, deletes; variables only stored to, etc. ``gvn``: Global Value Numbering; -------------------------------. This pass performs global value numbering to eliminate fully and partially; redundant instructions. It also performs redundant load elimination. .. _passes-indvars:. ``indvars``: Canonicalize Induction Variables; ---------------------------------------------. This transformation analyzes and transforms the induction variables (and; computations derived from them) into simpler forms suitable for subsequent; analysis and transformation. This transformation makes the following changes to each loop with an; identifiable induction variable:. * All loops are transformed to have a *single* canonical induction variable; which starts at zero and steps by one.; * The canonical induction variable is guaranteed to be the first PHI node in; the loop header block.; * Any pointer arithmetic recur",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Passes.rst:17143,simpl,simple,17143,interpreter/llvm-project/llvm/docs/Passes.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Passes.rst,1,['simpl'],['simple']
Usability,"o open; a pull-request on GitHub. Review process; --------------. When you open a pull-request, some automation will add a comment and; notify different member of the projects depending on the component you; changed.; Within a few days, someone should start the review. They may add; themselves as a reviewer, or simply start leaving comments. You'll get; another email any time the review is updated. The details are in the; `https://llvm.org/docs/CodeReview/ <https://llvm.org/docs/CodeReview.html>`__. Comments; ~~~~~~~~. The reviewer can leave comments on the change, and you can reply. Some; comments are attached to specific lines, and appear interleaved with the; code. You can either reply to these, or address them and mark them as; ""done"". Note that in-line replies are **not** sent straight away! They; become ""draft"" comments and you must click ""Submit"" at the bottom of the; page. Updating your change; ~~~~~~~~~~~~~~~~~~~~. If you make changes in response to a reviewer's comments, simply update; your branch with more commits and push to your fork. It may be a good; idea to answer the comments from the reviewer explicitly. Accepting a revision; ~~~~~~~~~~~~~~~~~~~~. When the reviewer is happy with the change, they will **Accept** the; revision. They may leave some more minor comments that you should; address, but at this point the review is complete. It's time to get it; merged!. Commit by proxy; ---------------. As this is your first change, you won't have access to merge it; yourself yet. The reviewer **doesn't know this**, so you need to tell; them! Leave a message on the review like:. Thanks @somellvmdev. I don't have commit access, can you land this; patch for me?. The pull-request will be closed and you will be notified by GitHub. Review expectations; -------------------. In order to make LLVM a long-term sustainable effort, code needs to be; maintainable and well tested. Code reviews help to achieve that goal.; Especially for new contributors, that often means",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MyFirstTypoFix.rst:10781,simpl,simply,10781,interpreter/llvm-project/llvm/docs/MyFirstTypoFix.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MyFirstTypoFix.rst,1,['simpl'],['simply']
Usability,"o parse is not well-formed, the; parser should output an error message and return true. Otherwise it should; return false and set '``Val``' to the parsed value. In our example, we; implement ``parse`` as:. .. code-block:: c++. bool FileSizeParser::parse(cl::Option &O, StringRef ArgName,; const std::string &Arg, unsigned &Val) {; const char *ArgStart = Arg.c_str();; char *End;. // Parse integer part, leaving 'End' pointing to the first non-integer char; Val = (unsigned)strtol(ArgStart, &End, 0);. while (1) {; switch (*End++) {; case 0: return false; // No error; case 'i': // Ignore the 'i' in KiB if people use that; case 'b': case 'B': // Ignore B suffix; break;. case 'g': case 'G': Val *= 1024*1024*1024; break;; case 'm': case 'M': Val *= 1024*1024; break;; case 'k': case 'K': Val *= 1024; break;. default:; // Print an error message if unrecognized character!; return O.error(""'"" + Arg + ""' value invalid for file size argument!"");; }; }; }. This function implements a very simple parser for the kinds of strings we are; interested in. Although it has some holes (it allows ""``123KKK``"" for example),; it is good enough for this example. Note that we use the option itself to print; out the error message (the ``error`` method always returns true) in order to get; a nice error message (shown below). Now that we have our parser class, we can; use it like this:. .. code-block:: c++. static cl::opt<unsigned, false, FileSizeParser>; MFS(""max-file-size"", cl::desc(""Maximum file size to accept""),; cl::value_desc(""size""));. Which adds this to the output of our program:. ::. OPTIONS:; -help - display available options (-help-hidden for more); ...; -max-file-size=<size> - Maximum file size to accept. And we can test that our parse works correctly now (the test program just prints; out the max-file-size argument value):. ::. $ ./test; MFS: 0; $ ./test -max-file-size=123MB; MFS: 128974848; $ ./test -max-file-size=3G; MFS: 3221225472; $ ./test -max-file-size=dog; -max-file-size option: ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandLine.rst:65209,simpl,simple,65209,interpreter/llvm-project/llvm/docs/CommandLine.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandLine.rst,1,['simpl'],['simple']
Usability,"o relies on additional C89-specific behavior that cannot; be changed. All of this only applies to C code; the meaning of inline; in C++ is very different from its meaning in either GNU89 or C99. ""missing"" vector __builtin functions. The Intel and AMD manuals document a number ""<*mmintrin.h>""; header files, which define a standardized API for accessing vector operations; on X86 CPUs. These functions have names like _mm_xor_ps and; _mm256_addsub_pd. Compilers have leeway to implement these functions; however they want. Since Clang supports an excellent set of native vector operations,; the Clang headers implement these interfaces in terms of the native vector; operations. In contrast, GCC implements these functions mostly as a 1-to-1 mapping to; builtin function calls, like __builtin_ia32_paddw128. These builtin; functions are an internal implementation detail of GCC, and are not portable to; the Intel compiler, the Microsoft compiler, or Clang. If you get build errors; mentioning these, the fix is simple: switch to the *mmintrin.h functions.; The same issue occurs for NEON and Altivec for the ARM and PowerPC; architectures respectively. For these, make sure to use the <arm_neon.h>; and <altivec.h> headers.; For x86 architectures this script should help with; the manual migration process. It will rewrite your source files in place to; use the APIs instead of builtin function calls. Just call it like this:. builtins.py *.c *.h. and it will rewrite all of the .c and .h files in the current directory to; use the API calls instead of calls like __builtin_ia32_paddw128. Lvalue casts. Old versions of GCC permit casting the left-hand side of an assignment to a; different type. Clang produces an error on similar code, e.g.,. lvalue.c:2:3: error: assignment to cast is illegal, lvalue casts are not supported; (int*)addr = val;; ^~~~~~~~~~ ~. To fix this problem, move the cast to the right-hand side. In this; example, one could use:. addr = (float *)val;. Jumps to within __block ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html:4417,simpl,simple,4417,interpreter/llvm-project/clang/www/compatibility.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html,1,['simpl'],['simple']
Usability,"o replicate our chamber by positioning it 1000 times in; different positions of the pad. Unfortunately, this is far from being; the optimal way of doing what we want. Imagine that we would like to; find out which of the 1000 chambers is containing a `(x,y,z)` point; defined in the pad reference. You will never have to do that, since the; modeller will take care of it for you, but let's guess what it has to; do. The most simple algorithm will just loop over all daughters, convert; the point from mother to local reference and check if the current; chamber contains the point or not. This might be efficient for pads with; few chambers, but definitely not for 1000. Fortunately the modeller is; smarter than that and creates for each volume some optimization; structures called `voxels` to minimize the penalty having too many; daughters, but if you have 100 pads like this in your geometry you will; anyway lose a lot in your tracking performance. The way out when; volumes can be arranged according to simple patterns is the usage of; divisions. We will describe them in detail later on. Let's think now at; a different situation: instead of 1000 chambers of the same type, we may; have several types of chambers. Let's say all chambers are cylindrical; and have a wire inside, but their dimensions are different. However, we; would like all to be represented by a single volume family, since they; have the same properties. #### Volume Families. A volume family is represented by the class **`TGeoVolumeMulti`**. It; represents a class of volumes having the same shape type and each member; will be identified by the same name and volume ID. Any operation applied; to a **`TGeoVolumeMulti`** equally affects all volumes in that family.; The creation of a family is generally not a user task, but can be forced; in particular cases:. ``` {.cpp}; TGeoManager::Volume(const char *vname,const char *shape,; Int_t nmed);; ```. Where: `vname` is the family name, `nmed` is the medium number and; `shap",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:80672,simpl,simple,80672,documentation/users-guide/Geometry.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md,1,['simpl'],['simple']
Usability,"o replicate our chamber by positioning it 1000 times in; different positions of the pad. Unfortunately, this is far from being; the optimal way of doing what we want. Imagine that we would like to; find out which of the 1000 chambers is containing a `(x,y,z)` point; defined in the pad reference. You will never have to do that, since the; modeller will take care of it for you, but let's guess what it has to; do. The most simple algorithm will just loop over all daughters, convert; the point from mother to local reference and check if the current; chamber contains the point or not. This might be efficient for pads with; few chambers, but definitely not for 1000. Fortunately the modeller is; smarter than that and creates for each volume some optimization; structures called `voxels` to minimize the penalty having too many; daughters, but if you have 100 pads like this in your geometry you will; anyway lose a lot in your tracking performance. The way out when; volumes can be arranged according to simple patterns is the usage of; divisions. We will describe them in detail later on. Let's think now at; a different situation: instead of 1000 chambers of the same type, we may; have several types of chambers. Let's say all chambers are cylindrical; and have a wire inside, but their dimensions are different. However, we; would like all to be represented by a single volume family, since they; have the same properties. \anchor GP01bh; #### Volume Families. A volume family is represented by the class TGeoVolumeMulti. It; represents a class of volumes having the same shape type and each member; will be identified by the same name and volume ID. Any operation applied; to a TGeoVolumeMulti equally affects all volumes in that family.; The creation of a family is generally not a user task, but can be forced; in particular cases:. ~~~{.cpp}; TGeoManager::Volume(const char *vname,const char *shape, Int_t nmed);; ~~~. Where: `vname` is the family name, `nmed` is the medium number and; `sh",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md:41115,simpl,simple,41115,geom/geom/doc/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md,1,['simpl'],['simple']
Usability,"o share the bulk of the architecture specific; code (especially relocations) for each supported architecture. * Refactor ELF link graph construction. ELF's link graph construction is currently implemented in the `ELF_x86_64.cpp`; file, and tied to the x86-64 relocation parsing code. The bulk of the code is; generic and should be split into an ELFLinkGraphBuilder base class along the; same lines as the existing generic MachOLinkGraphBuilder. * Implement support for arm32. * Implement support for other new architectures. JITLink Availability and Feature Status; ---------------------------------------. The following table describes the status of the JITlink backends for various; format / architecture combinations (as of July 2023). Support levels:. * None: No backend. JITLink will return an ""architecture not supported"" error.; Represented by empty cells in the table below.; * Skeleton: A backend exists, but does not support commonly used relocations.; Even simple programs are likely to trigger an ""unsupported relocation"" error.; Backends in this state may be easy to improve by implementing new relocations.; Consider getting involved!; * Basic: The backend supports simple programs, isn't ready for general use yet.; * Usable: The backend is useable for general use for at least one code and; relocation model.; * Good: The backend supports almost all relocations. Advanced features like; native thread local storage may not be available yet.; * Complete: The backend supports all relocations and object format features. .. list-table:: Availability and Status; :widths: 10 30 30 30; :header-rows: 1; :stub-columns: 1. * - Architecture; - ELF; - COFF; - MachO; * - arm32; - Skeleton; -; -; * - arm64; - Usable; -; - Good; * - LoongArch; - Good; -; -; * - PowerPC 64; - Usable; -; -; * - RISC-V; - Good; -; -; * - x86-32; - Basic; -; -; * - x86-64; - Good; - Usable; - Good. .. [1] See ``llvm/examples/OrcV2Examples/LLJITWithObjectLinkingLayerPlugin`` for; a full worked example. .. [2] I",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/JITLink.rst:45669,simpl,simple,45669,interpreter/llvm-project/llvm/docs/JITLink.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/JITLink.rst,1,['simpl'],['simple']
Usability,"o, we will just need to; replicate the ones that we have already created. ~~~{.cpp}; chamber->AddNode(wire_co,1,new TGeoTranslation(0.2,0,0));; chamber->AddNode(wire_co,2,new TGeoTranslation(0.2,0,0));; ~~~. The 2 nodes that we have created inside chamber will both point to a; `wire_co` object, but will be completely distinct: `WIRE_CO_1` and; `WIRE_CO_2`. We will want now to place symmetrically 1000 chambers on a; pad, following a pattern of 20 rows and 50 columns. One way to do this; will be to replicate our chamber by positioning it 1000 times in; different positions of the pad. Unfortunately, this is far from being; the optimal way of doing what we want. Imagine that we would like to; find out which of the 1000 chambers is containing a `(x,y,z)` point; defined in the pad reference. You will never have to do that, since the; modeller will take care of it for you, but let's guess what it has to; do. The most simple algorithm will just loop over all daughters, convert; the point from mother to local reference and check if the current; chamber contains the point or not. This might be efficient for pads with; few chambers, but definitely not for 1000. Fortunately the modeller is; smarter than that and creates for each volume some optimization; structures called `voxels` to minimize the penalty having too many; daughters, but if you have 100 pads like this in your geometry you will; anyway lose a lot in your tracking performance. The way out when; volumes can be arranged according to simple patterns is the usage of; divisions. We will describe them in detail later on. Let's think now at; a different situation: instead of 1000 chambers of the same type, we may; have several types of chambers. Let's say all chambers are cylindrical; and have a wire inside, but their dimensions are different. However, we; would like all to be represented by a single volume family, since they; have the same properties. \anchor GP01bh; #### Volume Families. A volume family is represented b",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md:40532,simpl,simple,40532,geom/geom/doc/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md,1,['simpl'],['simple']
Usability,"o.suspend``' marks the point where execution of a; switched-resume coroutine is suspended and control is returned back; to the caller. Conditional branches consuming the result of this; intrinsic lead to basic blocks where coroutine should proceed when; suspended (-1), resumed (0) or destroyed (1). Arguments:; """""""""""""""""""". The first argument refers to a token of `coro.save` intrinsic that marks the; point when coroutine state is prepared for suspension. If `none` token is passed,; the intrinsic behaves as if there were a `coro.save` immediately preceding; the `coro.suspend` intrinsic. The second argument indicates whether this suspension point is `final`_.; The second argument only accepts constants. If more than one suspend point is; designated as final, the resume and destroy branches should lead to the same; basic blocks. Example (normal suspend point):; """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""". .. code-block:: llvm. %0 = call i8 @llvm.coro.suspend(token none, i1 false); switch i8 %0, label %suspend [i8 0, label %resume; i8 1, label %cleanup]. Example (final suspend point):; """""""""""""""""""""""""""""""""""""""""""""""""""""""""""". .. code-block:: llvm. while.end:; %s.final = call i8 @llvm.coro.suspend(token none, i1 true); switch i8 %s.final, label %suspend [i8 0, label %trap; i8 1, label %cleanup]; trap:; call void @llvm.trap(); unreachable. Semantics:; """""""""""""""""""". If a coroutine that was suspended at the suspend point marked by this intrinsic; is resumed via `coro.resume`_ the control will transfer to the basic block; of the 0-case. If it is resumed via `coro.destroy`_, it will proceed to the; basic block indicated by the 1-case. To suspend, coroutine proceed to the; default label. If suspend intrinsic is marked as final, it can consider the `true` branch; unreachable and can perform optimizations that can take advantage of that fact. .. _coro.save:. 'llvm.coro.save' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^; ::. declare token @llvm.coro.save(ptr <handle>). Overview:; """""""""""""""""". The '``",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst:50828,resume,resume,50828,interpreter/llvm-project/llvm/docs/Coroutines.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst,1,['resume'],['resume']
Usability,"o:. .. code-block:: c++. int main(int argc, const char **argv) {; auto ExpectedParser = CommonOptionsParser::create(argc, argv, MyToolCategory);; if (!ExpectedParser) {; // Fail gracefully for unsupported options.; llvm::errs() << ExpectedParser.takeError();; return 1;; }; CommonOptionsParser& OptionsParser = ExpectedParser.get();; ClangTool Tool(OptionsParser.getCompilations(),; OptionsParser.getSourcePathList());. LoopPrinter Printer;; MatchFinder Finder;; Finder.addMatcher(LoopMatcher, &Printer);. return Tool.run(newFrontendActionFactory(&Finder).get());; }. Now, you should be able to recompile and run the code to discover for; loops. Create a new file with a few examples, and test out our new; handiwork:. .. code-block:: console. cd ~/clang-llvm/build/; ninja loop-convert; vim ~/test-files/simple-loops.cc; bin/loop-convert ~/test-files/simple-loops.cc. Step 3.5: More Complicated Matchers; ===================================. Our simple matcher is capable of discovering for loops, but we would; still need to filter out many more ourselves. We can do a good portion; of the remaining work with some cleverly chosen matchers, but first we; need to decide exactly which properties we want to allow. How can we characterize for loops over arrays which would be eligible; for translation to range-based syntax? Range based loops over arrays of; size ``N`` that:. - start at index ``0``; - iterate consecutively; - end at index ``N-1``. We already check for (1), so all we need to add is a check to the loop's; condition to ensure that the loop's index variable is compared against; ``N`` and another check to ensure that the increment step just; increments this same variable. The matcher for (2) is straightforward:; require a pre- or post-increment of the same variable declared in the; init portion. Unfortunately, such a matcher is impossible to write. Matchers contain; no logic for comparing two arbitrary AST nodes and determining whether; or not they are equal, so the best we c",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersTutorial.rst:10567,simpl,simple,10567,interpreter/llvm-project/clang/docs/LibASTMatchersTutorial.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersTutorial.rst,1,['simpl'],['simple']
Usability,"o:. define i32 @foo(i8 zeroext %i) nounwind readnone ssp noredzone {; entry:; %conv = zext i8 %i to i32; %shl = shl i32 %conv, 8; %shl5 = shl i32 %conv, 16; %shl9 = shl i32 %conv, 24; %or = or i32 %shl9, %conv; %or6 = or i32 %or, %shl5; %or10 = or i32 %or6, %shl; ret i32 %or10; }. it would be better as:. unsigned int bar(unsigned char i) {; unsigned int j=i | (i << 8); ; return j | (j<<16);; }. aka:. define i32 @bar(i8 zeroext %i) nounwind readnone ssp noredzone {; entry:; %conv = zext i8 %i to i32; %shl = shl i32 %conv, 8; %or = or i32 %shl, %conv; %shl5 = shl i32 %or, 16; %or6 = or i32 %shl5, %or; ret i32 %or6; }. or even i*0x01010101, depending on the speed of the multiplier. The best way to; handle this is to canonicalize it to a multiply in IR and have codegen handle; lowering multiplies to shifts on cpus where shifts are faster. //===---------------------------------------------------------------------===//. We do a number of simplifications in simplify libcalls to strength reduce; standard library functions, but we don't currently merge them together. For; example, it is useful to merge memcpy(a,b,strlen(b)) -> strcpy. This can only; be done safely if ""b"" isn't modified between the strlen and memcpy of course. //===---------------------------------------------------------------------===//. We compile this program: (from GCC PR11680); http://gcc.gnu.org/bugzilla/attachment.cgi?id=4487. Into code that runs the same speed in fast/slow modes, but both modes run 2x; slower than when compile with GCC (either 4.0 or 4.2):. $ llvm-g++ perf.cpp -O3 -fno-exceptions; $ time ./a.out fast; 1.821u 0.003s 0:01.82 100.0%	0+0k 0+0io 0pf+0w. $ g++ perf.cpp -O3 -fno-exceptions; $ time ./a.out fast; 0.821u 0.001s 0:00.82 100.0%	0+0k 0+0io 0pf+0w. It looks like we are making the same inlining decisions, so this may be raw; codegen badness or something else (haven't investigated). //===---------------------------------------------------------------------===//. Divisibility by const",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/README.txt:18461,simpl,simplifications,18461,interpreter/llvm-project/llvm/lib/Target/README.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/README.txt,2,['simpl'],"['simplifications', 'simplify']"
Usability,"o; come up with a precise partitioning in all cases without variables to; represent every pair of possible aliases. Thus, partitioning; precisely may require introducing at least N^2 new virtual variables,; phi nodes, etc. Each of these variables may be clobbered at multiple def sites. To give an example, if you were to split up struct fields into; individual variables, all aliasing operations that may-def multiple struct; fields, will may-def more than one of them. This is pretty common (calls,; copies, field stores, etc). Experience with SSA forms for memory in other compilers has shown that; it is simply not possible to do this precisely, and in fact, doing it; precisely is not worth it, because now all the optimizations have to; walk tons and tons of virtual variables and phi nodes. So we partition. At the point at which you partition, again,; experience has shown us there is no point in partitioning to more than; one variable. It simply generates more IR, and optimizations still; have to query something to disambiguate further anyway. As a result, LLVM partitions to one variable. Precision in practice; ^^^^^^^^^^^^^^^^^^^^^. In practice, there are implementation details in LLVM that also affect the; results' precision provided by ``MemorySSA``. For example, AliasAnalysis has various; caps, or restrictions on looking through phis which can affect what ``MemorySSA``; can infer. Changes made by different passes may make MemorySSA either ""overly; optimized"" (it can provide a more accurate result than if it were recomputed; from scratch), or ""under optimized"" (it could infer more if it were recomputed).; This can lead to challenges to reproduced results in isolation with a single pass; when the result relies on the state acquired by ``MemorySSA`` due to being updated by; multiple subsequent passes.; Passes that use and update ``MemorySSA`` should do so through the APIs provided by the; ``MemorySSAUpdater``, or through calls on the Walker.; Direct optimizations to ``",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MemorySSA.rst:18302,simpl,simply,18302,interpreter/llvm-project/llvm/docs/MemorySSA.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MemorySSA.rst,1,['simpl'],['simply']
Usability,"o; quickly test clang on their projects. Flexible; --------. The driver was designed to be flexible and easily accommodate new uses; as we grow the clang and LLVM infrastructure. As one example, the driver; can easily support the introduction of tools which have an integrated; assembler; something we hope to add to LLVM in the future. Similarly, most of the driver functionality is kept in a library which; can be used to build other tools which want to implement or accept a gcc; like interface. Low Overhead; ------------. The driver should have as little overhead as possible. In practice, we; found that the gcc driver by itself incurred a small but meaningful; overhead when compiling many small files. The driver doesn't do much; work compared to a compilation, but we have tried to keep it as; efficient as possible by following a few simple principles:. - Avoid memory allocation and string copying when possible.; - Don't parse arguments more than once.; - Provide a few simple interfaces for efficiently searching arguments. Simple; ------. Finally, the driver was designed to be ""as simple as possible"", given; the other goals. Notably, trying to be completely compatible with the; gcc driver adds a significant amount of complexity. However, the design; of the driver attempts to mitigate this complexity by dividing the; process into a number of independent stages instead of a single; monolithic task. Internal Design and Implementation; ==================================. .. contents::; :local:; :depth: 1. Internals Introduction; ----------------------. In order to satisfy the stated goals, the driver was designed to; completely subsume the functionality of the gcc executable; that is, the; driver should not need to delegate to gcc to perform subtasks. On; Darwin, this implies that the Clang driver also subsumes the gcc; driver-driver, which is used to implement support for building universal; images (binaries and object files). This also implies that the driver; should be",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DriverInternals.rst:2112,simpl,simple,2112,interpreter/llvm-project/clang/docs/DriverInternals.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DriverInternals.rst,1,['simpl'],['simple']
Usability,"oAbsArg have RooAbsReal as an; intermediate base class, which is the base class for all RooAbsArg that; represent real-valued nodes in the computation graph.; As such RooFit objects are so prevalent in practice, the names RooAbsArg and; RooAbsReal are used interchangeably in this guide. Users take these classes to build a computational graph that represents the; PDF (also called ""model"") that they want to use for fitting the data.; The user then passes his final PDF and a RooAbsData object to the; RooAbsPdf::fitTo() method, which implicitly creates a negative-log likelihood; (NLL) that RooFit minimizes for parameter estimation.; The NLL object, internally created by RooAbsPdf::createNLL(), is a RooAbsArg; itself.; In technical terms, it's another larger computation graph that encompasses the; computation graph representing the PDF. To enable source code transformation AD for RooFit NLLs with Clad, RooFit has a; routine that can traverse a computation graph made of RooAbsArg objects and; transform it to much simpler C++ code that mathematically represents the same; computation, but without any overhead that is hard to digest by the AD tool. On a high level, this *code generation* is implemented as follows:. 1. The computation graph is visited recursively by a; RooFit::Detail::CodeSquashContext object, via the virtual; RooAbsArg::translate() function that implements the translation of a; given RooFit class to minimal C++ code. This is an example of the visitor; pattern. 2. The generated code is processed by a RooFuncWrapper object, which takes care; of just-in-time compiling it with the ROOT interpreter, generating the; gradient code with Clad, and compiling that as well. 3. Since the RooFuncWrapper is implementing a RooAbsArg itself, it can now be; used as a drop-in replacement for the RooAbsArg that was the top node of the; original computation graph, with the added benefit that it can be queried for; the gradient. In summary, the important ingredient to enable AD i",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/developers/roofit_ad.md:4210,simpl,simpler,4210,roofit/doc/developers/roofit_ad.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/developers/roofit_ad.md,1,['simpl'],['simpler']
Usability,"oFix; ==============. .. contents::; :local:. Introduction; ============. This tutorial will guide you through the process of making a change to; LLVM, and contributing it back to the LLVM project. We'll be making a; change to Clang, but the steps for other parts of LLVM are the same.; Even though the change we'll be making is simple, we're going to cover; steps like building LLVM, running the tests, and code review. This is; good practice, and you'll be prepared for making larger changes. We'll assume you:. - know how to use an editor,. - have basic C++ knowledge,. - know how to install software on your system,. - are comfortable with the command line,. - have basic knowledge of git. The change we're making; -----------------------. Clang has a warning for infinite recursion:. .. code:: console. $ echo ""void foo() { foo(); }"" > ~/test.cc; $ clang -c -Wall ~/test.cc; input.cc:1:14: warning: all paths through this function will call; itself [-Winfinite-recursion]. This is clear enough, but not exactly catchy. Let's improve the wording; a little:. .. code:: console. input.cc:1:14: warning: to understand recursion, you must first; understand recursion [-Winfinite-recursion]. Dependencies; ------------. We're going to need some tools:. - git: to check out the LLVM source code,. - a C++ compiler: to compile LLVM source code. You'll want `a recent; version <https://llvm.org/docs/GettingStarted.html#host-c-toolchain-both-compiler-and-standard-library>`__; of Clang, GCC, or Visual Studio. - CMake: used to configure how LLVM should be built on your system,. - ninja: runs the C++ compiler to (re)build specific parts of LLVM,. - python: to run the LLVM tests,. As an example, on Ubuntu:. .. code:: console. $ sudo apt-get install git clang cmake ninja-build python arcanist. Building LLVM; =============. Checkout; --------. The source code is stored `on; Github <https://github.com/llvm/llvm-project>`__ in one large repository; (""the monorepo""). It may take a while to download!. .",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MyFirstTypoFix.rst:1012,clear,clear,1012,interpreter/llvm-project/llvm/docs/MyFirstTypoFix.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MyFirstTypoFix.rst,1,['clear'],['clear']
Usability,"oads/sites/11/2018/01/Intel-Analysis-of-Speculative-Execution-Side-Channels.pdf).; On AMD systems `lfence` is currently a no-op, but can be made; dispatch-serializing by setting an MSR, and thus preclude misspeculation of the; code path ([mitigation G-2 +; V1-1](https://developer.amd.com/wp-content/resources/Managing-Speculation-on-AMD-Processors.pdf)). However, this relies on finding and enumerating all possible points in code; which could be attacked to leak information. While in some cases static; analysis is effective at doing this at scale, in many cases it still relies on; human judgement to evaluate whether code might be vulnerable. Especially for; software systems which receive less detailed scrutiny but remain sensitive to; these attacks, this seems like an impractical security model. We need an; automatic and systematic mitigation strategy. ### Automatic `lfence` on Conditional Edges. A natural way to scale up the existing hand-coded mitigations is simply to; inject an `lfence` instruction into both the target and fallthrough; destinations of every conditional branch. This ensures that no predicate or; bounds check can be bypassed speculatively. However, the performance overhead; of this approach is, simply put, catastrophic. Yet it remains the only truly; ""secure by default"" approach known prior to this effort and serves as the; baseline for performance. One attempt to address the performance overhead of this and make it more; realistic to deploy is [MSVC's /Qspectre; switch](https://blogs.msdn.microsoft.com/vcblog/2018/01/15/spectre-mitigations-in-msvc/).; Their technique is to use static analysis within the compiler to only insert; `lfence` instructions into conditional edges at risk of attack. However,; [initial](https://arstechnica.com/gadgets/2018/02/microsofts-compiler-level-spectre-fix-shows-how-hard-this-problem-will-be-to-solve/); [analysis](https://www.paulkocher.com/doc/MicrosoftCompilerSpectreMitigation.html); has shown that this approach is in",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SpeculativeLoadHardening.md:45170,simpl,simply,45170,interpreter/llvm-project/llvm/docs/SpeculativeLoadHardening.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SpeculativeLoadHardening.md,1,['simpl'],['simply']
Usability,"objects that; keep the coroutine state when a coroutine is suspended. This region of storage; is called the **coroutine frame**. It is created when a coroutine is called; and destroyed when a coroutine either runs to completion or is destroyed; while suspended. LLVM currently supports two styles of coroutine lowering. These styles; support substantially different sets of features, have substantially; different ABIs, and expect substantially different patterns of frontend; code generation. However, the styles also have a great deal in common. In all cases, an LLVM coroutine is initially represented as an ordinary LLVM; function that has calls to `coroutine intrinsics`_ defining the structure of; the coroutine. The coroutine function is then, in the most general case,; rewritten by the coroutine lowering passes to become the ""ramp function"",; the initial entrypoint of the coroutine, which executes until a suspend point; is first reached. The remainder of the original coroutine function is split; out into some number of ""resume functions"". Any state which must persist; across suspensions is stored in the coroutine frame. The resume functions; must somehow be able to handle either a ""normal"" resumption, which continues; the normal execution of the coroutine, or an ""abnormal"" resumption, which; must unwind the coroutine without attempting to suspend it. Switched-Resume Lowering; ------------------------. In LLVM's standard switched-resume lowering, signaled by the use of; `llvm.coro.id`, the coroutine frame is stored as part of a ""coroutine; object"" which represents a handle to a particular invocation of the; coroutine. All coroutine objects support a common ABI allowing certain; features to be used without knowing anything about the coroutine's; implementation:. - A coroutine object can be queried to see if it has reached completion; with `llvm.coro.done`. - A coroutine object can be resumed normally if it has not already reached; completion with `llvm.coro.resume`. - A ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst:2203,resume,resume,2203,interpreter/llvm-project/llvm/docs/Coroutines.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst,1,['resume'],['resume']
Usability,"oc:`CMake` or :doc:`CMakePrimer`; documentation useful. Some of the things covered in this document are the inner; workings of the builds described in the :doc:`AdvancedBuilds` document. General Distribution Guidance; =============================. When building a distribution of a compiler it is generally advised to perform a; bootstrap build of the compiler. That means building a ""stage 1"" compiler with; your host toolchain, then building the ""stage 2"" compiler using the ""stage 1""; compiler. This is done so that the compiler you distribute benefits from all the; bug fixes, performance optimizations and general improvements provided by the; new compiler. In deciding how to build your distribution there are a few trade-offs that you; will need to evaluate. The big two are:. #. Compile time of the distribution against performance of the built compiler. #. Binary size of the distribution against performance of the built compiler. The guidance for maximizing performance of the generated compiler is to use LTO,; PGO, and statically link everything. This will result in an overall larger; distribution, and it will take longer to generate, but it provides the most; opportunity for the compiler to optimize. The guidance for minimizing distribution size is to dynamically link LLVM and; Clang libraries into the tools to reduce code duplication. This will come at a; substantial performance penalty to the generated binary both because it reduces; optimization opportunity, and because dynamic linking requires resolving symbols; at process launch time, which can be very slow for C++ code. .. _shared_libs:. .. warning::; One very important note: Distributions should never be built using the; *BUILD_SHARED_LIBS* CMake option. That option exists for optimizing developer; workflow only. Due to design and implementation decisions, LLVM relies on; global data which can end up being duplicated across shared libraries; resulting in bugs. As such this is not a safe way to distribute LLVM o",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/BuildingADistribution.rst:1414,guid,guidance,1414,interpreter/llvm-project/llvm/docs/BuildingADistribution.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/BuildingADistribution.rst,1,['guid'],['guidance']
Usability,"ocal variables.; Clang does not zero initialize local block variables, and programs which rely; on such behavior will most likely break when built with Clang. Inline assembly. In general, Clang is highly compatible with the GCC inline assembly; extensions, allowing the same set of constraints, modifiers and operands as GCC; inline assembly.; On targets that use the integrated assembler (such as most X86 targets),; inline assembly is run through the integrated assembler instead of your system; assembler (which is most commonly ""gas"", the GNU assembler). The LLVM; integrated assembler is extremely compatible with GAS, but there are a couple of; minor places where it is more picky, particularly due to outright GAS bugs.; One specific example is that the assembler rejects ambiguous X86 instructions; that don't have suffixes. For example:. asm(""add %al, (%rax)"");; asm(""addw $4, (%rax)"");; asm(""add $4, (%rax)"");. Both clang and GAS accept the first instruction: because the first; instruction uses the 8-bit %al register as an operand, it is clear that; it is an 8-bit add. The second instruction is accepted by both because the ""w""; suffix indicates that it is a 16-bit add. The last instruction is accepted by; GAS even though there is nothing that specifies the size of the instruction (and; the assembler randomly picks a 32-bit add). Because it is ambiguous, Clang; rejects the instruction with this error message:. <inline asm>:3:1: error: ambiguous instructions require an explicit suffix (could be 'addb', 'addw', 'addl', or 'addq'); add $4, (%rax); ^. To fix this compatibility issue, add an explicit suffix to the instruction:; this makes your code more clear and is compatible with both GCC and Clang. Objective-C compatibility. Cast of super. GCC treats the super identifier as an expression that; can, among other things, be cast to a different type. Clang treats; super as a context-sensitive keyword, and will reject a; type-cast of super:. super.m:11:12: error: cannot cast 'su",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html:8146,clear,clear,8146,interpreter/llvm-project/clang/www/compatibility.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html,1,['clear'],['clear']
Usability,"ock:: console. $ cmake [..] -DBOOTSTRAP_CMAKE_CXX_FLAGS='-fno-addrsig' -DBOOTSTRAP_CMAKE_C_FLAGS='-fno-addrsig' [..]. The clang build system refers to builds as stages. A stage1 build is a standard; build using the compiler installed on the host, and a stage2 build is built; using the stage1 compiler. This nomenclature holds up to more stages too. In; general a stage*n* build is built using the output from stage*n-1*. Apple Clang Builds (A More Complex Bootstrap); =============================================. Apple's Clang builds are a slightly more complicated example of the simple; bootstrapping scenario. Apple Clang is built using a 2-stage build. The stage1 compiler is a host-only compiler with some options set. The stage1; compiler is a balance of optimization vs build time because it is a throwaway.; The stage2 compiler is the fully optimized compiler intended to ship to users. Setting up these compilers requires a lot of options. To simplify the; configuration the Apple Clang build settings are contained in CMake Cache files.; You can build an Apple Clang compiler using the following commands:. .. code-block:: console. $ cmake -G Ninja -C <path to source>/clang/cmake/caches/Apple-stage1.cmake <path to source>/llvm; $ ninja stage2-distribution. This CMake invocation configures the stage1 host compiler, and sets; CLANG_BOOTSTRAP_CMAKE_ARGS to pass the Apple-stage2.cmake cache script to the; stage2 configuration step. When you build the stage2-distribution target it builds the minimal stage1; compiler and required tools, then configures and builds the stage2 compiler; based on the settings in Apple-stage2.cmake. This pattern of using cache scripts to set complex settings, and specifically to; make later stage builds include cache scripts is common in our more advanced; build configurations. Multi-stage PGO; ===============. Profile-Guided Optimizations (PGO) is a really great way to optimize the code; clang generates. Our multi-stage PGO builds are a workflow f",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst:3832,simpl,simplify,3832,interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst,1,['simpl'],['simplify']
Usability,"ock`` is so common that the ``Instruction``; class and ``Instruction``-derived classes provide constructors which take a; pointer to a ``BasicBlock`` to be appended to. For example code that looked; like:. .. code-block:: c++. BasicBlock *pb = ...;; auto *newInst = new Instruction(...);. newInst->insertInto(pb, pb->end()); // Appends newInst to pb. becomes:. .. code-block:: c++. BasicBlock *pb = ...;; auto *newInst = new Instruction(..., pb);. which is much cleaner, especially if you are creating long instruction; streams. * Insertion using an instance of ``IRBuilder``. Inserting several ``Instruction``\ s can be quite laborious using the previous; methods. The ``IRBuilder`` is a convenience class that can be used to add; several instructions to the end of a ``BasicBlock`` or before a particular; ``Instruction``. It also supports constant folding and renaming named; registers (see ``IRBuilder``'s template arguments). The example below demonstrates a very simple use of the ``IRBuilder`` where; three instructions are inserted before the instruction ``pi``. The first two; instructions are Call instructions and third instruction multiplies the return; value of the two calls. .. code-block:: c++. Instruction *pi = ...;; IRBuilder<> Builder(pi);; CallInst* callOne = Builder.CreateCall(...);; CallInst* callTwo = Builder.CreateCall(...);; Value* result = Builder.CreateMul(callOne, callTwo);. The example below is similar to the above example except that the created; ``IRBuilder`` inserts instructions at the end of the ``BasicBlock`` ``pb``. .. code-block:: c++. BasicBlock *pb = ...;; IRBuilder<> Builder(pb);; CallInst* callOne = Builder.CreateCall(...);; CallInst* callTwo = Builder.CreateCall(...);; Value* result = Builder.CreateMul(callOne, callTwo);. See :doc:`tutorial/LangImpl03` for a practical use of the ``IRBuilder``. .. _schanges_deleting:. Deleting Instructions; ^^^^^^^^^^^^^^^^^^^^^. Deleting an instruction from an existing sequence of instructions that form a; Basi",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:117052,simpl,simple,117052,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,1,['simpl'],['simple']
Usability,"ocs/gcc/_005f_005fsync-Builtins.html>`_). * Other scenarios with atomic semantics, including ``static`` variables with; non-trivial constructors in C++. Atomic and volatile in the IR are orthogonal; ""volatile"" is the C/C++ volatile,; which ensures that every volatile load and store happens and is performed in the; stated order. A couple examples: if a SequentiallyConsistent store is; immediately followed by another SequentiallyConsistent store to the same; address, the first store can be erased. This transformation is not allowed for a; pair of volatile stores. On the other hand, a non-volatile non-atomic load can; be moved across a volatile load freely, but not an Acquire load. This document is intended to provide a guide to anyone either writing a frontend; for LLVM or working on optimization passes for LLVM with a guide for how to deal; with instructions with special semantics in the presence of concurrency. This; is not intended to be a precise guide to the semantics; the details can get; extremely complicated and unreadable, and are not usually necessary. .. _Optimization outside atomic:. Optimization outside atomic; ===========================. The basic ``'load'`` and ``'store'`` allow a variety of optimizations, but can; lead to undefined results in a concurrent environment; see `NotAtomic`_. This; section specifically goes into the one optimizer restriction which applies in; concurrent environments, which gets a bit more of an extended description; because any optimization dealing with stores needs to be aware of it. From the optimizer's point of view, the rule is that if there are not any; instructions with atomic ordering involved, concurrency does not matter, with; one exception: if a variable might be visible to another thread or signal; handler, a store cannot be inserted along a path where it might not execute; otherwise. Take the following example:. .. code-block:: c. /* C code, for readability; run through clang -O2 -S -emit-llvm to get; equivalent ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Atomics.rst:2256,guid,guide,2256,interpreter/llvm-project/llvm/docs/Atomics.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Atomics.rst,1,['guid'],['guide']
Usability,"ode-block:: c++. // Foo is non-trivial.; struct Foo { int a; Foo(); Foo(const &Foo); ~Foo(); };; Foo bar(Foo b);; int main() {; bar(bar(Foo()));; }. In this case, we want to be able to elide copies into ``bar``'s argument; slots. That means we need to have more than one set of argument frames; active at the same time. First, we need to allocate the frame for the; outer call so we can pass it in as the hidden struct return pointer to; the middle call. Then we do the same for the middle call, allocating a; frame and passing its address to ``Foo``'s default constructor. By; wrapping the evaluation of the inner ``bar`` with stack save and; restore, we can have multiple overlapping active call frames. Callee-cleanup Calling Conventions; ----------------------------------. Another wrinkle is the existence of callee-cleanup conventions. On; Windows, all methods and many other functions adjust the stack to clear; the memory used to pass their arguments. In some sense, this means that; the allocas are automatically cleared by the call. However, LLVM; instead models this as a write of undef to all of the inalloca values; passed to the call instead of a stack adjustment. Frontends should; still restore the stack pointer to avoid a stack leak. Exceptions; ----------. There is also the possibility of an exception. If argument evaluation; or copy construction throws an exception, the landing pad must do; cleanup, which includes adjusting the stack pointer to avoid a stack; leak. This means the cleanup of the stack memory cannot be tied to the; call itself. There needs to be a separate IR-level instruction that can; perform independent cleanup of arguments. Efficiency; ----------. Eventually, it should be possible to generate efficient code for this; construct. In particular, using inalloca should not require a base; pointer. If the backend can prove that all points in the CFG only have; one possible stack level, then it can address the stack directly from; the stack pointer. While",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/InAlloca.rst:5169,clear,cleared,5169,interpreter/llvm-project/llvm/docs/InAlloca.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/InAlloca.rst,1,['clear'],['cleared']
Usability,"ode-block:: text. typeTestAssumeConstVCalls: (ConstVCall[, ConstVCall]*). Where each ConstVCall has the format:. .. code-block:: text. (VFuncId, args: (Arg[, Arg]*)). and where each VFuncId has the format described for ``TypeTestAssumeVCalls``,; and each Arg is an integer argument number. TypeCheckedLoadConstVCalls; """""""""""""""""""""""""""""""""""""""""""""""""""". .. code-block:: text. typeCheckedLoadConstVCalls: (ConstVCall[, ConstVCall]*). Where each ConstVCall has the format described for; ``TypeTestAssumeConstVCalls``. .. _typeid_summary:. Type ID Summary Entry; ---------------------. Each type id summary entry corresponds to a type identifier resolution; which is generated during the LTO link portion of the compile when building; with `Control Flow Integrity <https://clang.llvm.org/docs/ControlFlowIntegrity.html>`_,; so these are only present in a combined summary index. Example:. .. code-block:: text. ^4 = typeid: (name: ""_ZTS1A"", summary: (typeTestRes: (kind: allOnes, sizeM1BitWidth: 7[, alignLog2: 0]?[, sizeM1: 0]?[, bitMask: 0]?[, inlineBits: 0]?)[, WpdResolutions]?)) ; guid = 7004155349499253778. The ``typeTestRes`` gives the type test resolution ``kind`` (which may; be ``unsat``, ``byteArray``, ``inline``, ``single``, or ``allOnes``), and; the ``size-1`` bit width. It is followed by optional flags, which default to 0,; and an optional WpdResolutions (whole program devirtualization resolution); field that looks like:. .. code-block:: text. wpdResolutions: ((offset: 0, WpdRes)[, (offset: 1, WpdRes)]*. where each entry is a mapping from the given byte offset to the whole-program; devirtualization resolution WpdRes, that has one of the following formats:. .. code-block:: text. wpdRes: (kind: branchFunnel); wpdRes: (kind: singleImpl, singleImplName: ""_ZN1A1nEi""); wpdRes: (kind: indir). Additionally, each wpdRes has an optional ``resByArg`` field, which; describes the resolutions for calls with all constant integer arguments:. .. code-block:: text. resByArg: (ResByArg[, ResByArg]*).",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:348897,guid,guid,348897,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['guid'],['guid']
Usability,"ode; // spectrum display mode (points, grid, contours, bars, x_lines,; // y_lines, bars_x, bars_y, needles, surface, triangles); int z_scale; // z scale (linear, log, sqrt); int nodesx; // number of nodes in x dimension of grid; int nodesy; // number of nodes in y dimension of grid; int count_reg; // width between contours, applies only for contours display mode; int alfa; // angles of display,alfa+beta must be less or equal to 90, alpha- angle; // between base line of Canvas and left lower edge of picture picture; // base plane; int beta; // angle between base line of Canvas and right lower edge of picture base plane; int view_angle; // rotation angle of the view, it can be 0, 90, 180, 270 degrees; int levels; // # of color levels for rainbowed display modes, it does not apply for; // simple display modes algorithm group; float rainbow1_step; // determines the first component step for neighboring color; // levels, applies only for rainbowed display modes, it does not apply; // for simple display modes algorithm group; float rainbow2_step; // determines the second component step for neighboring; // color levels, applies only for rainbowed display modes, it does not; // apply for simple display modes algorithm group; float rainbow3_step; // determines the third component step for neighboring; // color levels, applies only for rainbowed display modes, it does not; // apply for simple display modes algorithm group; int color_alg; // applies only for rainbowed display modes (rgb smooth algorithm,; // rgb modulo color component, cmy smooth algorithm, cmy modulo; // color component, cie smooth algorithm, cie modulo color component,; // yiq smooth algorithm, yiq modulo color component, hsv smooth; // algorithm, hsv modulo color component, it does not apply for simple; // display modes algorithm group [15]; float l_h_weight; // weight between shading according to fictive light source and; // according to channels counts, applies only for; // PICTURE2_MODE_GROUP_LIGHT_HEIGHT ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/spectrum/Spectrum.md:77587,simpl,simple,77587,documentation/spectrum/Spectrum.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/spectrum/Spectrum.md,1,['simpl'],['simple']
Usability,"odeView Type Records <CodeViewTypes>`. .. _type_indices:. Type Indices; ============. A type index is a 32-bit integer that uniquely identifies a type inside of an; object file's ``.debug$T`` section or a PDB file's TPI or IPI stream. The; value of the type index for the first type record from the TPI stream is given; by the ``TypeIndexBegin`` member of the :ref:`TPI Stream Header <tpi_header>`; although in practice this value is always equal to 0x1000 (4096). Any type index with a high bit set is considered to come from the IPI stream,; although this appears to be more of a hack, and LLVM does not generate type; indices of this nature. They can, however, be observed in Microsoft PDBs; occasionally, so one should be prepared to handle them. Note that having the; high bit set is not a necessary condition to determine whether a type index; comes from the IPI stream, it is only sufficient. Once the high bit is cleared, any type index >= ``TypeIndexBegin`` is presumed; to come from the appropriate stream, and any type index less than this is a; bitmask which can be decomposed as follows:. .. code-block:: none. .---------------------------.------.----------.; | Unused | Mode | Kind |; '---------------------------'------'----------'; |+32 |+12 |+8 |+0. - **Kind** - A value from the following enum:. .. code-block:: c++. enum class SimpleTypeKind : uint32_t {; None = 0x0000, // uncharacterized type (no type); Void = 0x0003, // void; NotTranslated = 0x0007, // type not translated by cvpack; HResult = 0x0008, // OLE/COM HRESULT. SignedCharacter = 0x0010, // 8 bit signed; UnsignedCharacter = 0x0020, // 8 bit unsigned; NarrowCharacter = 0x0070, // really a char; WideCharacter = 0x0071, // wide char; Character16 = 0x007a, // char16_t; Character32 = 0x007b, // char32_t; Character8 = 0x007c, // char8_t. SByte = 0x0068, // 8 bit signed int; Byte = 0x0069, // 8 bit unsigned int; Int16Short = 0x0011, // 16 bit signed; UInt16Short = 0x0021, // 16 bit unsigned; Int16 = 0x0072, // 16 bi",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/PDB/TpiStream.rst:4162,clear,cleared,4162,interpreter/llvm-project/llvm/docs/PDB/TpiStream.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/PDB/TpiStream.rst,1,['clear'],['cleared']
Usability,"odule); and stores it in the target ``JITDylib``, arranging for it to be passed back; to the layer's emit method when any symbol defined by that module is requested.; Each layer can complete its own work by calling the ``emit`` method of its base; layer. For example, in this tutorial our IRTransformLayer calls through to; our IRCompileLayer to compile the transformed IR, and our IRCompileLayer in; turn calls our ObjectLayer to link the object file produced by our compiler. So far we have learned how to optimize and compile our LLVM IR, but we have; not focused on when compilation happens. Our current REPL optimizes and; compiles each function as soon as it is referenced by any other code,; regardless of whether it is ever called at runtime. In the next chapter we; will introduce a fully lazy compilation, in which functions are not compiled; until they are first called at run-time. At this point the trade-offs get much; more interesting: the lazier we are, the quicker we can start executing the; first function, but the more often we will have to pause to compile newly; encountered functions. If we only code-gen lazily, but optimize eagerly, we; will have a longer startup time (as everything is optimized at that time) but; relatively short pauses as each function just passes through code-gen. If we; both optimize and code-gen lazily we can start executing the first function; more quickly, but we will have longer pauses as each function has to be both; optimized and code-gen'd when it is first executed. Things become even more; interesting if we consider interprocedural optimizations like inlining, which; must be performed eagerly. These are complex trade-offs, and there is no; one-size-fits all solution to them, but by providing composable layers we leave; the decisions to the person implementing the JIT, and make it easy for them to; experiment with different configurations. `Next: Adding Per-function Lazy Compilation <BuildingAJIT3.html>`_. Full Code Listing; ======",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/BuildingAJIT2.rst:10939,pause,pause,10939,interpreter/llvm-project/llvm/docs/tutorial/BuildingAJIT2.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/BuildingAJIT2.rst,1,['pause'],['pause']
Usability,"oes not not all of the callers. This includes functions; with normal external linkage as well as templates, C99 inline functions etc.; Specifically, it does nothing to:. define i32 @test(i32 %x, i32 %y, i32 %z) nounwind {; entry:; %0 = add nsw i32 %y, %z ; %1 = mul i32 %0, %x ; %2 = mul i32 %y, %z ; %3 = add nsw i32 %1, %2 ; ret i32 %3; }. define i32 @test2() nounwind {; entry:; %0 = call i32 @test(i32 1, i32 2, i32 4) nounwind; ret i32 %0; }. It would be interesting extend IPSCCP to be able to handle simple cases like; this, where all of the arguments to a call are constant. Because IPSCCP runs; before inlining, trivial templates and inline functions are not yet inlined.; The results for a function + set of constant arguments should be memoized in a; map. //===---------------------------------------------------------------------===//. The libcall constant folding stuff should be moved out of SimplifyLibcalls into; libanalysis' constantfolding logic. This would allow IPSCCP to be able to; handle simple things like this:. static int foo(const char *X) { return strlen(X); }; int bar() { return foo(""abcd""); }. //===---------------------------------------------------------------------===//. function-attrs doesn't know much about memcpy/memset. This function should be; marked readnone rather than readonly, since it only twiddles local memory, but; function-attrs doesn't handle memset/memcpy/memmove aggressively:. struct X { int *p; int *q; };; int foo() {; int i = 0, j = 1;; struct X x, y;; int **p;; y.p = &i;; x.q = &j;; p = __builtin_memcpy (&x, &y, sizeof (int *));; return **p;; }. This can be seen at:; $ clang t.c -S -o - -mkernel -O0 -emit-llvm | opt -function-attrs -S. //===---------------------------------------------------------------------===//. Missed instcombine transformation:; define i1 @a(i32 %x) nounwind readnone {; entry:; %cmp = icmp eq i32 %x, 30; %sub = add i32 %x, -30; %cmp2 = icmp ugt i32 %sub, 9; %or = or i1 %cmp, %cmp2; ret i1 %or; }; This should b",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/README.txt:46687,simpl,simple,46687,interpreter/llvm-project/llvm/lib/Target/README.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/README.txt,1,['simpl'],['simple']
Usability,"oexcept {}. struct FinalSuspend {; std::coroutine_handle<> continuation;; auto await_ready() noexcept { return false; }; auto await_suspend(std::coroutine_handle<> handle) noexcept {; return continuation;; }; void await_resume() noexcept {}; };; FinalSuspend final_suspend() noexcept { return {continuation}; }. void return_value(int res) { result = res; }. std::coroutine_handle<> continuation = std::noop_coroutine();; int result = 0;; };. task(std::coroutine_handle<promise_type> handle) : handle(handle) {}; ~task() {; if (handle); handle.destroy();; }. auto operator co_await() {; struct Awaiter {; std::coroutine_handle<promise_type> handle;; auto await_ready() { return false; }; auto await_suspend(std::coroutine_handle<> continuation) {; handle.promise().continuation = continuation;; return handle;; }; int await_resume() {; int ret = handle.promise().result;; handle.destroy();; return ret;; }; };; return Awaiter{std::exchange(handle, nullptr)};; }. int syncStart() {; handle.resume();; return handle.promise().result;; }. private:; std::coroutine_handle<promise_type> handle;; };. task task::promise_type::get_return_object() {; return std::coroutine_handle<promise_type>::from_promise(*this);; }. namespace detail {; template <int N>; task chain_fn() {; co_return N + co_await chain_fn<N - 1>();; }. template <>; task chain_fn<0>() {; // This is the default breakpoint.; __builtin_debugtrap();; co_return 0;; }; } // namespace detail. task chain() {; co_return co_await detail::chain_fn<30>();; }. int main() {; std::cout << chain().syncStart() << ""\n"";; return 0;; }. In the example, the ``task`` coroutine holds a ``continuation`` field,; which would be resumed once the ``task`` completes.; In another word, the ``continuation`` is the asynchronous caller for the ``task``.; Just like the normal function returns to its caller when the function completes. So we can use the ``continuation`` field to construct the asynchronous stack:. .. code-block:: python. # debugging-helper.py; im",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DebuggingCoroutines.rst:13932,resume,resume,13932,interpreter/llvm-project/clang/docs/DebuggingCoroutines.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DebuggingCoroutines.rst,1,['resume'],['resume']
Usability,"of a; packet containing various information about the performance related to; that file only.; Added support also for performance monitoring when writing. RGLITE: A ROOT GRID interface. RGLite plug-in - a ROOT plug-in module, which implements the ROOT Grid; interface and offers to ROOT users possibilities to perform a number of; operations using gLite middleware from within ROOT. Supported features:. Workload Management System operations:; ; job submission – normal, DAG and parametric; jobs (gLite; WMProxy API), ; smart look-up algorithm for WMP-Endpoints, ; job status querying (gLite LB API), ; job output retrieving (Globus GridFTP). . File Catalog operations (gLite/LCG LFC API):; ; smart session manager, ; set/query the current working catalog directory, ; list files, directories and their stats, ; add/remove files in a catalog namespace, ; add/remove directories, ; add/remove replicas from a given file. . An executive logging. ; Support of an external XML configuration file with; according XML; schema. . Usage examples:. Job operations. // loading RGLite plug-in. TGrid::Connect(""glite"");; // submitting Grid job. TGridJob *job = gGrid->Submit(""JDLs/simple.jdl"");; // getting status object. TGridJobStatus *status = job->GetJobStatus();; // getting status of the job. TGridJobStatus::EGridJobStatus st( status->GetStatus() );; // when the st is; TGridJobStatus::kDONE you can; retrieve job's output. job->GetOutputSandbox(""/tmp"");. File Catalog operations. // loading RGLite plug-in. TGrid::Connect(""glite"");; // changing the current directory to; ""/grid/dech"". gGrid->Cd(""/grid/dech"");; // using Mkdir to create a new; directory. Bool_t b = gGrid->Mkdir(""root_test2"");; // listing the current directory. TGridResult* result = gGrid->Ls();; // full file information. result->Print(""all"");; // removing the directory . b = gGrid->Rmdir(""root_test2"");. Documentation: ; http://www-linux.gsi.de/%7Emanafov/D-Grid/docz/RGLite/html/. and; http://www-linux.gsi.de/~manafov/D-Grid/docz/; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/doc/v520/index.html:4048,simpl,simple,4048,net/doc/v520/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/doc/v520/index.html,1,['simpl'],['simple']
Usability,"of the *axis* line is shown; in dark color, the positive in bright. The *axis* name and minimum /; maximum values are labeled in the same color. There are three options; for *axes* drawing - selected by radio buttons:. - None - not drawn (default). - Edge - draw axes on the (minimum) edge of the scene extents box. - Origin - drawn axes through the origin. For *edge axes*, the zero value for each axis is marked on the axis line; with a colored sphere. For *origin axes,* a single white sphere is shown; at the origin. *Edge axes* are depth clipped - i.e. are obscured by 3D objects in front; of them. *Origin axes* (which generally pass through the middle of the; 3D scene) are not depth clipped - so always visible. A single orange sphere of fixed view port (window) size can be shown at; any arbitrary position. Enable / disable the drawing with ‘*Show'*; checkbox. Enter X/Y/Z position in the edit boxes to set position.; Initial position is at the center of the scene. Set the guides using `TGLViewer::SetGuideState` e.g. to enable edge; axes, and enable a reference marker at world position 50, 60, 100:. ``` {.cpp}; Double_t refPos[3] = {50.0,60.0,100.0};; v->SetGuideState(TGLUtil::kAxesEdge, kTRUE, refPos);; ```. #### Selecting Scene Shapes. You can select a single shape from your scene by pressing ‘Shift' key,; pointing and left clicking anywhere on the shape in the viewer.; Selection is currently shown by drawing the shape-bounding box (not; depth clipped) in white (polygon or wire frame render styles) or red; (outline render style). Manipulators supported by the shape are drawn in; red, green and blue while the non-supported ones are drawn in grey. To; deselect a shape, either select another, or shift/click anywhere on the; background (empty space) in the viewer. You cannot select Manipulators; or Guides (Axes / Reference Marker). #### Editing Shapes. When a shape is selected, the viewer's control pane shows the user; interface that allows you to review and adjust the col",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md:118207,guid,guides,118207,documentation/users-guide/Graphics.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md,1,['guid'],['guides']
Usability,"of the compiler exist. Passes; perform the transformations and optimizations that make up the compiler, they; build the analysis results that are used by these transformations, and they; are, above all, a structuring technique for compiler code. Unlike passes under the legacy pass manager where the pass interface is; defined via inheritance, passes under the new pass manager rely on; concept-based polymorphism, meaning there is no explicit interface (see; comments in ``PassManager.h`` for more details). All LLVM passes inherit from; the CRTP mix-in ``PassInfoMixin<PassT>``. The pass should have a ``run()``; method which returns a ``PreservedAnalyses`` and takes in some unit of IR; along with an analysis manager. For example, a function pass would have a; ``PreservedAnalyses run(Function &F, FunctionAnalysisManager &AM);`` method. We start by showing you how to construct a pass, from setting up the build,; creating the pass, to executing and testing it. Looking at existing passes is; always a great way to learn details. .. warning::; This document deals with the new pass manager. LLVM uses the legacy pass; manager for the codegen pipeline. For more details, see; :doc:`WritingAnLLVMPass` and :doc:`NewPassManager`. Quick Start --- Writing hello world; ===================================. Here we describe how to write the ""hello world"" of passes. The ""HelloWorld""; pass is designed to simply print out the name of non-external functions that; exist in the program being compiled. It does not modify the program at all,; it just inspects it. The code below already exists; feel free to create a pass with a different; name alongside the HelloWorld source files. .. _writing-an-llvm-npm-pass-build:. Setting up the build; --------------------. First, configure and build LLVM as described in :doc:`GettingStarted`. Next, we will reuse an existing directory (creating a new directory involves; messing around with more CMake files than we want). For this example, we'll use; ``llvm/lib",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/WritingAnLLVMNewPMPass.rst:1322,learn,learn,1322,interpreter/llvm-project/llvm/docs/WritingAnLLVMNewPMPass.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/WritingAnLLVMNewPMPass.rst,1,['learn'],['learn']
Usability,"of the minimization is transformed into the user; representable format by M . For more explanations see [api:state]. ## Input to M ##. The following input combinations to M are possible:. - $\mbox{FCN}$ + parameters + uncertainties. - $\mbox{FCN}$ with gradient + parameters + uncertainties. - $\mbox{FCN}$ + parameters + covariance. - $\mbox{FCN}$ with gradient + parameters + covariance. For each of these combinations the user can chose between a minimal; required interface (using std::vector containers) for the parameters and; uncertainties or a more functional one provided by M . If the user wants; to interact with the parameters before minimization (fixing,; adding/removing limits), the minimal required interface cannot be used. ### What the user must supply ###. The user must supply to M. - a valid implementation of the FCNBase base class. - parameters with their starting values. - expected uncertainties on the parameters. The input parameters can be simply defined via an; std::vector$<$double$>$, which means that all parameters are variables.; If the user wants fix a parameter or put limits on it before; minimization, they have to instantiate a MnUserParameters object and then; add parameters one by one, giving them a name, value, uncertainty. Once; all parameters are added to MnUserParameters, they can fix a parameter or; put limits on another one before handing them over to Minuit for; minimization. ### What the user can supply ###. Optionally the user can supply their own gradient calculator by; implementing the FCNGradientBase interface or supply a full covariance; matrix for input if one is available. The covariance matrix can be; supplied in form of a std::vector$<$double$>$ in packed storage format; (upper triangular), or in a more user-friendly way by using the; interface provided by the MnUserCovariance. ## Running a M minimization ##. Two use cases are addressed for minimization:. - The user just wants the function to be minimized in one go. - The user ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md:32560,simpl,simply,32560,documentation/minuit2/Minuit2.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md,1,['simpl'],['simply']
Usability,"of your script. The default behavior of `rootcling` is to; not link in (i.e. generate the dictionary for) any of the symbols. In; particular, this means that the following lines are, in the; general case, unnecessary. ``` {.cpp}; #pragma link off all globals;; #pragma link off all classes;; #pragma link off all functions;; ```. This also means that linking the instantiation of a class template:. ``` {.cpp}; #pragma link C++ class mytemplate<int>;; ```. ONLY links this specific class. You need to; request the generation of the iterators explicitly. See the documentation of `rootcling` for details how `pragma` can be; used. NOTE: You should not call ACLiC with a script that has a function; called `main()`. ### Intermediate Steps and Files. ACLiC executes two steps and a third one if needed. These are:. - Calling `rootcling` to create a dictionary using `rootcling`.; - Calling the compiler to build the shared library from the script.; - If there are errors, it calls the compiler to build a dummy; executable to clearly report unresolved symbols. ACLiC makes a shared library with a dictionary containing the; classes and functions declared in the script. It also adds the; classes and functions declared in included files with the same name; as the script file and any of the following extensions: `.h`, `.hh`,; `.hpp`, `.hxx`, `.hPP`, `.hXX`. This means that, by default, you; cannot combine scripts from different files into one library by using; `#include` statements; you will need to compile each script; separately. In a future release, we plan to add the global variables; declared in the script to the dictionary also. If you are curious; about the specific calls, you can raise the ROOT debug level: gDebug=3; and ACLiC will print these steps. If you need to keep the intermediate; files around, for example when debugging the script using gdb, use; gDebug=7. ### Moving between Interpreter and Compiler. The best way to develop portable scripts is to make sure you can; always ru",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Cling.md:20291,clear,clearly,20291,documentation/users-guide/Cling.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Cling.md,1,['clear'],['clearly']
Usability,"ogic can resume unwinding. In a yield-once; coroutine, reaching a non-unwind ``llvm.coro.end`` without having first; reached a ``llvm.coro.suspend.retcon`` has undefined behavior. The remainder of this section describes the behavior under switched-resume; lowering. This intrinsic is lowered when a coroutine is split into; the start, resume and destroy parts. In the start part, it is a no-op,; in resume and destroy parts, it is replaced with `ret void` instruction and; the rest of the block containing `coro.end` instruction is discarded.; In landing pads it is replaced with an appropriate instruction to unwind to; caller. The handling of coro.end differs depending on whether the target is; using landingpad or WinEH exception model. For landingpad based exception model, it is expected that frontend uses the; `coro.end`_ intrinsic as follows:. .. code-block:: llvm. ehcleanup:; %InResumePart = call i1 @llvm.coro.end(ptr null, i1 true, token none); br i1 %InResumePart, label %eh.resume, label %cleanup.cont. cleanup.cont:; ; rest of the cleanup. eh.resume:; %exn = load ptr, ptr %exn.slot, align 8; %sel = load i32, ptr %ehselector.slot, align 4; %lpad.val = insertvalue { ptr, i32 } undef, ptr %exn, 0; %lpad.val29 = insertvalue { ptr, i32 } %lpad.val, i32 %sel, 1; resume { ptr, i32 } %lpad.val29. The `CoroSpit` pass replaces `coro.end` with ``True`` in the resume functions,; thus leading to immediate unwind to the caller, whereas in start function it; is replaced with ``False``, thus allowing to proceed to the rest of the cleanup; code that is only needed during initial invocation of the coroutine. For Windows Exception handling model, a frontend should attach a funclet bundle; referring to an enclosing cleanuppad as follows:. .. code-block:: llvm. ehcleanup:; %tok = cleanuppad within none []; %unused = call i1 @llvm.coro.end(ptr null, i1 true, token none) [ ""funclet""(token %tok) ]; cleanupret from %tok unwind label %RestOfTheCleanup. The `CoroSplit` pass, if the funclet bun",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst:44887,resume,resume,44887,interpreter/llvm-project/llvm/docs/Coroutines.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst,1,['resume'],['resume']
Usability,"ogonal:. ``` {.cpp}; const TMatrixD haar = THaarMatrixD(order);; TVectorD colj(1<<order);; TVectorD coll(1<<order);; for (Int_t j = haar.GetColLwb(); j <= haar.GetColUpb(); j++) {; colj = TMatrixDColumn_const(haar,j);; Assert(TMath::Abs(colj*colj-1.0) <= 1.0e-15);. for (Int_t l = j+1; l <= haar.GetColUpb(); l++) {; coll = TMatrixDColumn_const(haar,l);; Assert(TMath::Abs(colj*coll) <= 1.0e-15);; }; }; ```. Multiplying part of a matrix with another part of that matrix (they can overlap). ``` {.cpp}; TMatrixDSub(m,1,3,1,3) *= m.GetSub(5,7,5,7);; ```. ## Matrix Decompositions. The linear algebra package offers several classes to assist in matrix; decompositions. Each of the decomposition methods performs a set of; matrix transformations to facilitate solving a system of linear; equations, the formation of inverses as well as the estimation of; determinants and condition numbers. More specifically the classes; **`TDecompLU`**, **`TDecompBK`**, **`TDecompChol`**, **`TDecompQRH`** and; **`TDecompSVD`** give a simple and consistent interface to the LU,; Bunch-Kaufman, Cholesky, QR and SVD decompositions. All of these classes; are derived from the base class **`TDecompBase`** of which the important; methods are listed in next table:. +-----------------------------------------------------+--------------------------------------+; | Method | Action |; +-----------------------------------------------------+--------------------------------------+; | `Bool_t Decompose()` | perform the matrix decomposition |; +-----------------------------------------------------+--------------------------------------+; | `Double_t Condition()` | calculate ||*A*||1 ||*A*-1||1, |; | | see ""Condition number"" |; +-----------------------------------------------------+--------------------------------------+; | `void Det(Double_t &d1,Double_t &d2)` | the determinant is `d1` $2^{d_{2}}$. |; | | Expressing the determinant this |; | | way makes under/over-flow very |; | | unlikely |; +----------------------",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/LinearAlgebra.md:33806,simpl,simple,33806,documentation/users-guide/LinearAlgebra.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/LinearAlgebra.md,1,['simpl'],['simple']
Usability,"ointer is null.; for (unsigned e = R->Map->NumRoots; i != e; ++i); Visitor(&R->Roots[i], NULL);; }; }. The 'Erlang' and 'Ocaml' GCs; -----------------------------. LLVM ships with two example collectors which leverage the ``gcroot``; mechanisms. To our knowledge, these are not actually used by any language; runtime, but they do provide a reasonable starting point for someone interested; in writing an ``gcroot`` compatible GC plugin. In particular, these are the; only in tree examples of how to produce a custom binary stack map format using; a ``gcroot`` strategy. As there names imply, the binary format produced is intended to model that; used by the Erlang and OCaml compilers respectively. .. _statepoint_example_gc:. The Statepoint Example GC; -------------------------. .. code-block:: c++. F.setGC(""statepoint-example"");. This GC provides an example of how one might use the infrastructure provided; by ``gc.statepoint``. This example GC is compatible with the; :ref:`PlaceSafepoints` and :ref:`RewriteStatepointsForGC` utility passes; which simplify ``gc.statepoint`` sequence insertion. If you need to build a; custom GC strategy around the ``gc.statepoints`` mechanisms, it is recommended; that you use this one as a starting point. This GC strategy does not support read or write barriers. As a result, these; intrinsics are lowered to normal loads and stores. The stack map format generated by this GC strategy can be found in the; :ref:`stackmap-section` using a format documented :ref:`here; <statepoint-stackmap-format>`. This format is intended to be the standard; format supported by LLVM going forward. The CoreCLR GC; -------------------------. .. code-block:: c++. F.setGC(""coreclr"");. This GC leverages the ``gc.statepoint`` mechanism to support the; `CoreCLR <https://github.com/dotnet/coreclr>`__ runtime. Support for this GC strategy is a work in progress. This strategy will; differ from; :ref:`statepoint-example GC<statepoint_example_gc>` strategy in; certain aspects l",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GarbageCollection.rst:20312,simpl,simplify,20312,interpreter/llvm-project/llvm/docs/GarbageCollection.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GarbageCollection.rst,1,['simpl'],['simplify']
Usability,"ointers to member; > functions, and have to look up an example when they have to write them. Again, I don't disagree with this at all. But to some extent this; particular problem is inherently difficult. Your syntax for the above; example may be easier for you to read because this is the way you have been; thinking about it. Honestly, I don't find it much easier than the C syntax.; In either case, I would have to look up an example to write pointers to; member functions. But pointers to member functions are nowhere near as common as arrays. And; the old array syntax:; type [ int, int, ...]; is just much more familiar and clear to people than anything new you; introduce, no matter how logical it is. Introducing a new syntax that may; make function pointers easier but makes arrays much more difficult seems; very risky to me. > In my opinion, it is critically important to have clear and concise type; > specifications, because types are going to be all over the programs. I absolutely agree. But the question is, what is more clear and concise?; The syntax programmers are used to out of years of experience or a new; syntax that they have never seen that has a more logical structure. I think; the answer is the former. Sometimes, you have to give up a better idea; because you can't overcome sociological barriers to it. Qwerty keyboards; and Windows are two classic examples of bad technology that are difficult to; root out. P.S. Also, while I agree that most your syntax is more logical, there is; one part that isn't:. Arrays (without and with size):; type ::= '[' type ']' | '[' INT ',' type ']'. The arrays with size lists the dimensions and the type in a single list.; That is just too confusing:; [10, 40, int]; This seems to be a 3-D array where the third dimension is something strange.; It is too confusing to have a list of 3 things, some of which are dimensions; and one is a type. Either of the following would be better:. array [10, 40] of int; or; int [10, 40]. --Vikram. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HistoricalNotes/2001-02-06-TypeNotationDebateResp1.txt:2208,clear,clear,2208,interpreter/llvm-project/llvm/docs/HistoricalNotes/2001-02-06-TypeNotationDebateResp1.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HistoricalNotes/2001-02-06-TypeNotationDebateResp1.txt,1,['clear'],['clear']
Usability,"ollows:. ``` {.json}; ""<C++ class name>"": {; ""type"": ""<json-key>"",; ""proxies"": {; ""<name of proxy>"": ""<json-key of this element>"",; ""<name of proxy>"": ""<json-key of this element>"",; ...; }; }; ```. If you don't want to edit the central `json` files containing the; factory expressions or export keys, you can also put your custom; export keys or factory expressions into a different json file and load; that using `RooFit::JSONIO::loadExportKeys(const std::string; &fname)` and `RooFit::JSONIO::loadFactoryExpressions(const; std::string &fname)`. If either the importer or the exporter cannot be created with factory; expressions and export keys, you can instead write a custom `C++`; class to perform the import and export for you. ### Writing your own importers and exporters: Custom `C++` code. In order to implement your own importer or exporter, you can inherit; from the corresponding base classes `RooFit::JSONIO::Importer`; or `RooFit::JSONIO::Exporter`, respectively. You can find; [simple examples](https://github.com/root-project/root/blob/master/roofit/hs3/src/JSONFactories_RooFitCore.cxx); as well as; [more complicated ones](https://github.com/root-project/root/blob/master/roofit/hs3/src/JSONFactories_HistFactory.cxx); in `ROOT`. Any importer should take the following form:. ``` {.cpp}; class MyClassFactory : public RooFit::JSONIO::Importer {; public:; bool importFunction(RooJSONFactoryWSTool *tool, const JSONNode &p) const override; {; std::string name(RooJSONFactoryWSTool::name(p));. // check if the required keys are available in the JSON; if (!p.has_child(""<class member key #1>"")) {; RooJSONFactoryWSTool::error(""missing key '<class member key #1>' of '"" + name + ""'"");; }; if (!p.has_child(""<class member key #2>"")) {; RooJSONFactoryWSTool::error(""missing key '<class member key #2>' of '"" + name + ""'"");; }. std::string member1(p[""<class member key #1>""].val());; int member2(p[""<class member key #2>""].val_int());. MyClass theobj(name.c_str(), member1, member2);; tool->",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/developers/roofit_hs3.md:5019,simpl,simple,5019,roofit/doc/developers/roofit_hs3.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/developers/roofit_hs3.md,1,['simpl'],['simple']
Usability,"ols for neural; networks studies. ### The MLP. The multilayer perceptron is a simple feed-forward network with the; following structure showed on the left. ![](pictures/0300008D.png). It is made of neurons characterized by a bias and weighted links in; between - let's call those links synapses. The input neurons receive; the inputs, normalize them and forward them to the first hidden layer.; Each neuron in any subsequent layer first computes a linear; combination of the outputs of the previous layer. The output of the; neuron is then function of that combination with f being linear for; output neurons or a sigmoid for hidden layers. Such a structure is very useful because of two theorems:. 1- A linear combination of `sigmoids` can approximate any continuous; function. 2- Trained with `output=1` for the signal and 0 for the background,; the approximated function of inputs `X` is the probability of signal,; knowing `X`. ### Learning Methods. The aim of all learning methods is to minimize the total error on a; set of weighted examples. The error is defined as the sum in quadrate,; divided by two, of the error on each individual output neuron. In all; methods implemented in this library, one needs to compute the first; derivative of that error with respect to the weights. Exploiting the; well-known properties of the derivative, one can express this; derivative as the product of the local partial derivative by the; weighted sum of the outputs derivatives (for a neuron) or as the; product of the input value with the local partial derivative of the; output neuron (for a synapse). This computation is called; ""back-propagation of the errors"". Six learning methods are; implemented. #### Stochastic Minimization. This is the most trivial learning method. The Robbins-Monro stochastic; approximation is applied to multilayer perceptrons. The weights are; updated after each example according to the formula:. $$; w_{ij}(t+1) = w_{ij}(t) + \Delta w_{ij}(t); $$. with:. $$; \Delta w_{ij",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:71417,learn,learning,71417,documentation/users-guide/FittingHistograms.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md,1,['learn'],['learning']
Usability,"om the public interface. The `RooAbsMinimizerFcn` class and its implementation `RooMinimizerFcn` were removed from the public interface.; These classes are implementation details of the RooMinimizer and should not be used in your code.; In the unlikely case that this causes any problem for you, please open a GitHub issue requesting to extend the RooMinimizer by the needed functionality. ### Vectorize `RooAbsBinning` interface for bin index lookups. The `RooAbsBinning` interface for bin index lookups was changed to enable vectorized implementations.; Instead of having the override `RooAbsBinning::binNumber()`, the binning implementations now have to override the `RooAbsBinning::binNumbers()` function to evaluate the bin indices of multiple values in one function call. ### Disable relative and absolute epsilon in `RooAbsRealLValue::inRange()`. So far, the `RooAbsRealLValue::inRange()` function used the following; undocumented convention to check whether a value `x` is in the range with; limits `a` and `b`: test if `[x - eps * x, x + eps * x]` overlaps with `[a, b]`, where the; parameter `eps` is defined as `max(epsRel * x, epsAbs)`. The values of the relative and absolute epsilons were inconsistent among the overloads:. * [RooAbsRealLValue::inRange(const char* rangeName)](https://root.cern.ch/doc/v626/classRooAbsRealLValue.html#ab6050a0c3e5583b9d755a38fd7fb82f7): `epsRel = 1e-8, epsAbs = 0`; * [RooAbsRealLValue::inRange(double value, const char* rangeName, double* clippedValPtr)](https://root.cern.ch/doc/v626/classRooAbsRealLValue.html#afc2a8818f433a9a4ec0c437cbdad4e8a): `epsRel = 0, epsAbs = 1e-6`; * [RooAbsRealLValue::inRange(std::span<const double> values, std::string const& rangeName, std::vector<bool>& out)](https://root.cern.ch/doc/v626/classRooAbsRealLValue.html#af9217abd0afe34364562ad0c194f5d2c): `epsRel = 0, epsAbs = 1e-6`. With this release, the default absolute and relative epsilon is zero to avoid confusion.; You can change them with `RooNumber::setRangeEps",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v628/index.md:25114,undo,undocumented,25114,README/ReleaseNotes/v628/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v628/index.md,1,['undo'],['undocumented']
Usability,"om; operator delete[].; See tests cases in handle_constructors_with_new_array.cpp.; . Constructing an array requires invoking multiple (potentially unknown); amount of constructors with the same construct-expression.; Apart from the technical difficulties of juggling program points around; correctly to avoid accidentally merging paths together, we'll have to; be a judge on when to exit the loop and how to widen it.; Given that the constructor is going to be a default constructor,; a nice 95% solution might be to execute exactly one constructor and; then default-bind the resulting LazyCompoundVal to the whole array;; it'll work whenever the default constructor doesn't touch global state; but only initializes the object to various default values.; But if, say, we're making an array of strings,; depending on the implementation you might have to allocate a new buffer; for each string, and in this case default-binding won't cut it.; We might want to come up with an auxiliary analysis in order to perform; widening of these simple loops more precisely.; . Handle constructors that can be elided due to Named Return Value Optimization (NRVO); Local variables which are returned by values on all return statements; may be stored directly at the address for the return value,; eliding the copy or move constructor call.; Such variables can be identified using the AST call VarDecl::isNRVOVariable.; . Handle constructors of lambda captures; Variables which are captured by value into a lambda require a call to; a copy constructor.; This call is not currently modeled.; . Handle constructors for default arguments; Default arguments in C++ are recomputed at every call,; and are therefore local, and not static, variables.; See tests cases in handle_constructors_for_default_arguments.cpp.; . Default arguments are annoying because the initializer expression is; evaluated at the call site but doesn't syntactically belong to the; caller's AST; instead it belongs to the ParmVarDecl for the defa",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/open_projects.html:3878,simpl,simple,3878,interpreter/llvm-project/clang/www/analyzer/open_projects.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/open_projects.html,1,['simpl'],['simple']
Usability,"omatic storage duration do not have precise; lifetime semantics. Such objects are simply strong references which hold; values of retainable object pointer type, and these values are still fully; subject to the optimizations on values under local control. .. admonition:: Rationale. Applying these precise-lifetime semantics strictly would be prohibitive.; Many useful optimizations that might theoretically decrease the lifetime of; an object would be rendered impossible. Essentially, it promises too much. A local variable of retainable object owner type and automatic storage duration; may be annotated with the ``objc_precise_lifetime`` attribute to indicate that; it should be considered to be an object with precise lifetime semantics. .. admonition:: Rationale. Nonetheless, it is sometimes useful to be able to force an object to be; released at a precise time, even if that object does not appear to be used.; This is likely to be uncommon enough that the syntactic weight of explicitly; requesting these semantics will not be burdensome, and may even make the code; clearer. .. _arc.misc:. Miscellaneous; =============. .. _arc.misc.special_methods:. Special methods; ---------------. .. _arc.misc.special_methods.retain:. Memory management methods; ^^^^^^^^^^^^^^^^^^^^^^^^^. A program is ill-formed if it contains a method definition, message send, or; ``@selector`` expression for any of the following selectors:. * ``autorelease``; * ``release``; * ``retain``; * ``retainCount``. .. admonition:: Rationale. ``retainCount`` is banned because ARC robs it of consistent semantics. The; others were banned after weighing three options for how to deal with message; sends:. **Honoring** them would work out very poorly if a programmer naively or; accidentally tried to incorporate code written for manual retain/release code; into an ARC program. At best, such code would do twice as much work as; necessary; quite frequently, however, ARC and the explicit code would both; try to balance the",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst:84904,clear,clearer,84904,interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,1,['clear'],['clearer']
Usability,"ome tools rely on the package structure. The ``STDCXX`` envar can be used to control the C++ standard version; use; ``MAKE`` to change the ``make`` command; and ``MAKE_NPROCS`` to control the; maximum number of parallel jobs.; Compilation of the backend, which contains a customized version of; Clang/LLVM, can take a long time, so by default the setup script will use all; cores (x2 if hyperthreading is enabled). On MS Windows, some temporary path names may be too long, causing the build to; fail.; To resolve this issue, point the ``TMP`` and ``TEMP`` envars to an existing; directory with a short name before the build:; For example::. > set TMP=C:\TMP; > set TEMP=C:\TMP. The first package to build is ``cppyy-cling``.; It may take a long time, especially on a laptop (Mac ARM being a notable; exception), since Cling comes with a builtin version of LLVM/Clang.; Consider therefore for a moment your reasons for building from source: there; being no pre-built wheel for the platform that you're interested in or simply; needing the latest version from the repository; or perhaps you are planning; to develop/modify the sources. If the former, clone the repository, check out a specific tagged release as; needed, then run the following steps to add Cling and build a wheel.; Once built, install the wheel as appropriate::. $ git clone https://github.com/wlav/cppyy-backend.git; $ cd cppyy-backend/cling; $ python setup.py egg_info; $ python create_src_directory.py; $ python setup.py bdist_wheel; $ python -m pip install dist/cppyy_cling-* --upgrade. .. note::; ``cppyy-cling`` wheels do not depend on the Python interpreter and can; thus be re-used for any version of Python or PyPy. The ``egg_info`` setup command is needed for ``create_src_directory.py`` to; find the right version.; That script in turn downloads the proper release from `upstream`_, trims and; patches it,; and installs the result in the ""src"" directory.; When done, the structure of ``cppyy-cling`` looks again like a PyPA",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/repositories.rst:2564,simpl,simply,2564,bindings/pyroot/cppyy/cppyy/doc/source/repositories.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/repositories.rst,1,['simpl'],['simply']
Usability,"omeone has to; commit the change for you (with attribution). It is sufficient to add; a comment to the approved review indicating you cannot commit the patch; yourself. If you have commit access, there are multiple workflows to commit the; change. Whichever method you follow it is recommended that your commit message; ends with the line:. ::. Differential Revision: <URL>. where ``<URL>`` is the URL for the code review, starting with; ``https://reviews.llvm.org/``. This allows people reading the version history to see the review for; context. This also allows Phabricator to detect the commit, close the; review, and add a link from the review to the commit. Note that if you use the Arcanist tool the ``Differential Revision`` line will; be added automatically. If you don't want to use Arcanist, you can add the; ``Differential Revision`` line (as the last line) to the commit message; yourself. Using the Arcanist tool can simplify the process of committing reviewed code as; it will retrieve reviewers, the ``Differential Revision``, etc from the review; and place it in the commit message. You may also commit an accepted change; directly using ``git push``, per the section in the :ref:`getting started; guide <commit_from_git>`. Note that if you commit the change without using Arcanist and forget to add the; ``Differential Revision`` line to your commit message then it is recommended; that you close the review manually. In the web UI, under ""Leap Into Action"" put; the git revision number in the Comment, set the Action to ""Close Revision"" and; click Submit. Note the review must have been Accepted first. Committing someone's change from Phabricator; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. On a clean Git repository on an up to date ``main`` branch run the; following (where ``<Revision>`` is the Phabricator review number):. ::. arc patch D<Revision>. This will create a new branch called ``arcpatch-D<Revision>`` based on the; current ``main`` and will create a commit corres",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Phabricator.rst:14262,simpl,simplify,14262,interpreter/llvm-project/llvm/docs/Phabricator.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Phabricator.rst,1,['simpl'],['simplify']
Usability,"ommits that violate these quality standards (e.g. are very broken) may be; reverted. This is necessary when the change blocks other developers from making; progress. The developer is welcome to re-commit the change after the problem has; been fixed. .. _commit messages:. Commit messages; ---------------. Although we don't enforce the format of commit messages, we prefer that; you follow these guidelines to help review, search in logs, email formatting; and so on. These guidelines are very similar to rules used by other open source; projects. Most importantly, the contents of the message should be carefully written to; convey the rationale of the change (without delving too much in detail). It; also should avoid being vague or overly specific. For example, ""bits were not; set right"" will leave the reviewer wondering about which bits, and why they; weren't right, while ""Correctly set overflow bits in TargetInfo"" conveys almost; all there is to the change. Below are some guidelines about the format of the message itself:. * Separate the commit message into title and body separated by a blank line. * If you're not the original author, ensure the 'Author' property of the commit is; set to the original author and the 'Committer' property is set to yourself.; You can use a command similar to; ``git commit --amend --author=""John Doe <jdoe@llvm.org>""`` to correct the; author property if it is incorrect. See `Attribution of Changes`_ for more; information including the method we used for attribution before the project; migrated to git. In the rare situation where there are multiple authors, please use the `git; tag 'Co-authored-by:' to list the additional authors; <https://github.blog/2018-01-29-commit-together-with-co-authors/>`_. * The title should be concise. Because all commits are emailed to the list with; the first line as the subject, long titles are frowned upon. Short titles; also look better in `git log`. * When the changes are restricted to a specific part of the co",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/DeveloperPolicy.rst:15519,guid,guidelines,15519,interpreter/llvm-project/llvm/docs/DeveloperPolicy.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/DeveloperPolicy.rst,1,['guid'],['guidelines']
Usability,"ompare(const TObject *obj) const; { if (num < ((TObjNum*)obj)->num) return -1;; else if (num > ((TObjNum*)obj)->num) return 1;; else return 0; }; ULong_t Hash() const { return num; }; };; ```. ## The TIter Generic Iterator. As stated above, the **`TIterator`** class is abstract; it is not; possible to create **`TIterator`** objects. However, it should be; possible to write generic code to process all members of a collection so; there is a need for a generic iterator object. A **`TIter`** object acts; as generic iterator. It provides the same `Next()` and `Reset()` methods; as **`TIterator`** although it has no idea how to support them! It works; as follows:. - To create a **`TIter`** object its constructor must be passed an; object that inherits from **`TCollection`**. The **`TIter`**; constructor calls the `MakeIterator()` method of this collection to; get the appropriate iterator object that inherits from; **`TIterator`**. - The `Next()` and `Reset()` methods of **`TIter`** simply call the; `Next()` and `Reset()` methods of the iterator object. Therefore, **`TIter`** simply acts as a wrapper for an object of a; concrete class inheriting from **`TIterator`**. To see this working in practice, consider the **`TObjArray`**; collection. Its associated iterator is **`TObjArrayIter`**. Suppose; `myarray` is a pointer to a **`TObjArray`** that contains `MyClass`; objects, i.e. ``` {.cpp}; TObjArray *myarray;; ```. To create a **`TIter`** object called `myiter`:. ``` {.cpp}; TIter myiter(myarray);; ```. ![](pictures/020001A4.jpg). As shown in the diagram, this results in several methods being called:. - The **`TIter`** constructor is passed a **`TObjArray`**. - **`TIter`** asks embedded **`TCollection`** to make an iterator. - **`TCollection`** asks **`TObjArray`** to make an iterator. - **`TObjArray`** returns a **`TObjArrayIter`**. Now define a pointer for `MyClass` objects and set it to each member of; the **`TObjArray`**:. ``` {.cpp}; MyClass *myobject;; while ((myobje",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/CollectionClasses.md:11115,simpl,simply,11115,documentation/users-guide/CollectionClasses.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/CollectionClasses.md,1,['simpl'],['simply']
Usability,"ompared. In many cases, the distribution of the; measurement errors is not precisely known, and simulation offers the; possibility to test the effects of different assumptions. A powerful software framework addressing all of the above requirements; is ROOT, an open source project coordinated by the European Organisation for; Nuclear Research, CERN in Geneva. ROOT is very flexible and provides both a programming interface to use in own; applications and a graphical user interface for interactive data analysis. The; purpose of this document is to serve as a beginners guide and provides extendable; examples for your own use cases, based on typical problems addressed in; student labs. This guide will hopefully lay the ground for more complex; applications in your future scientific work building on a modern,; state-of the art tool for data analysis. This guide in form of a tutorial is intended to introduce you quickly to the; ROOT package. This goal will be accomplished using concrete examples, according; to the ""learning by doing"" principle. Also because of this reason, this guide; cannot cover all the complexity of the ROOT package. Nevertheless, once you feel; confident with the concepts presented in the following chapters, you will be; able to appreciate the ROOT Users Guide [@ROOT_Users_Guide] and navigate through; the Class Reference [@ROOT_Class_Reference] to find all the details you might be; interested in. You can even look at the code itself, since ROOT is a; free, open-source product. Use these documents in parallel to this; tutorial!. The ROOT Data Analysis Framework itself is written in and heavily relies; on the `C++` programming language: some knowledge about `C++` is required.; Jus take advantage from the immense available literature about `C++` if you do; not have any idea of what this language is about. ROOT is available for many platforms (Linux, Mac OS X, Windows...), but; in this guide we will implicitly assume that you are using Linux. The; first thi",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/Introduction.md:3813,learn,learning,3813,documentation/primer/Introduction.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/Introduction.md,1,['learn'],['learning']
Usability,"on and local to; that function. It means one can define another MakeHilbert class; (within another function or outside of any function, that is, in; the global scope), and it still will be OK. Note, this currently; is not yet supported by the interpreter CINT. Another example is applying of a simple function to each matrix element:. ~~~ {.cpp}; void foo(TMatrixD &m,TMatrixD &m1); {; typedef double (*dfunc_t)(double);; class ApplyFunction : public TElementActionD {; dfunc_t fFunc;; void Operation(Double_t &element); { element=fFunc(element); }; public:; ApplyFunction(dfunc_t func):fFunc(func) {}; };; ApplyFunction x(TMath::Sin);; m.Apply(x);; }; ~~~. Validation code `$ROOTSYS/test/vmatrix.cxx` and `vvector.cxx` contain; a few more examples of that kind. #### 6. Lazy matrices:. instead of returning an object return a ""recipe""; how to make it. The full matrix would be rolled out only when; and where it's needed:. ~~~ {.cpp}; TMatrixD haar = THaarMatrixD(5);; ~~~. THaarMatrixD() is a *class*, not a simple function. However; similar this looks to a returning of an object (see note #1; above), it's dramatically different. THaarMatrixD() constructs a; TMatrixDLazy, an object of just a few bytes long. A special; ""TMatrixD(const TMatrixDLazy &recipe)"" constructor follows the; recipe and makes the matrix haar() right in place. No matrix; element is moved whatsoever!. ### Acknowledgements. 1. Oleg E. Kiselyov; First implementations were based on the his code . We have diverged; quite a bit since then but the ideas/code for lazy matrix and; ""nested function"" are 100% his .; You can see him and his code in action at http://okmij.org/ftp; 2. Chris R. Birchenhall,; We adapted his idea of the implementation for the decomposition; classes instead of our messy installation of matrix inversion; His installation of matrix condition number, using an iterative; scheme using the Hage algorithm is worth looking at !; Chris has a nice writeup (matdoc.ps) on his matrix classes at; ftp://ftp.",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/matrix/doc/index.md:18616,simpl,simple,18616,math/matrix/doc/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/matrix/doc/index.md,1,['simpl'],['simple']
Usability,"on of `x` may be very subtle:. ```c++; void F(std::optional<int> &x);. void Example(std::optional<int> &x) {; if (x.has_value()) {; // Flow condition: x.has_value() == true.; unknown_function(x); // may change x.; // Flow condition: true.; use(x.value());; }; }; ```. ## Example: finding dead code behind A/B experiment flags. Finding dead code is a classic application of data flow analysis. Unused flags for A/B experiment hide dead code. However, this flavor of dead; code is invisible to the compiler because the flag can be turned on at any; moment. We could make a tool that deletes experiment flags. The user tells us which flag; they want to delete, and we assume that the it's value is a given constant. For example, the user could use the tool to remove `example_flag` from this; code:. ```c++; DEFINE_FLAG(std::string, example_flag, """", ""A sample flag."");. void Example() {; bool x = GetFlag(FLAGS_example_flag).empty();; f();; if (x) {; g();; } else {; h();; }; }; ```. The tool would simplify the code to:. ```c++; void Example() {; f();; g();; }; ```. We can solve this problem with a classic constant propagation lattice combined; with symbolic evaluation. ## Example: finding inefficient usages of associative containers. Real-world code often accidentally performs repeated lookups in associative; containers:. ```c++; map<int, Employee> xs;; xs[42]->name = ""..."";; xs[42]->title = ""..."";; ```. To find the above inefficiency we can use the available expressions analysis to; understand that `m[42]` is evaluated twice. ```c++; map<int, Employee> xs;; Employee &e = xs[42];; e->name = ""..."";; e->title = ""..."";; ```. We can also track the `m.contains()` check in the flow condition to find; redundant checks, like in the example below. ```c++; std::map<int, Employee> xs;; if (!xs.contains(42)) {; xs.insert({42, someEmployee});; }; ```. ## Example: refactoring types that implicitly convert to each other. Refactoring one strong type to another is difficult, but the compiler can he",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DataFlowAnalysisIntro.md:28582,simpl,simplify,28582,interpreter/llvm-project/clang/docs/DataFlowAnalysisIntro.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DataFlowAnalysisIntro.md,1,['simpl'],['simplify']
Usability,"on"");. // Create a hierarchy by adding sub tasks; run->Add(geomInit);; run->Add(matInit);; run->Add(event);; event->Add(tracker);; event->Add(global);; tracker->Add(tpc);; tracker->Add(its);; tracker->Add(muon);; tracker->Add(phos);; tracker->Add(rich);; tracker->Add(trd);. // Add the top level task; gROOT->GetListOfTasks()->Add(run);. // Add the task to the browser; gROOT->GetListOfBrowsables()->Add(run);; new TBrowser;; }; ```. ![Tasks in the ROOT browser](pictures/030000E5.png). Note that the first line loads the class definitions in `MyTasks.cxx`; with ACLiC. ACLiC builds a shared library and adds the classes to the; Cling dictionary. See ""Adding a Class with ACLiC"". To execute a **`TTask`**, you call the `ExecuteTask` method.; `ExecuteTask` will recursively call:. - the `TTask::Exec `method of the derived class;. - the `TTask::ExecuteTasks` to execute for each task the list of its; subtasks;. If the top level task is added to the list of ROOT browsable objects,; the tree of tasks can be seen in the ROOT browser. To add it to the; browser, get the list of browsable objects first and add it to the; collection. ``` {.cpp}; gROOT->GetListOfBrowsables()->Add(run);; ```. The first parameter of the `Add` method is a pointer to a **`TTask`**,; the second parameter is the string to show in the browser. If the string; is left out, the name of the task is used. After executing, the script above the browser will look like in this; figure. ## Execute and Debug Tasks. The browser can be used to start a task, set break points at the; beginning of a task or when the task has completed. At a breakpoint,; data structures generated by the execution up this point may be; inspected asynchronously and then the execution can be resumed by; selecting the ""`Continue`"" function of a task. A task may be active or inactive (controlled by `TTask::SetActive`).; When a task is inactive, its sub tasks are not executed. A task tree may; be made persistent, saving the status of all the tasks.; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FoldersTasks.md:10773,resume,resumed,10773,documentation/users-guide/FoldersTasks.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FoldersTasks.md,1,['resume'],['resumed']
Usability,"on** for an option, you; must specify **cl::location** first, so that when the command-line parser; sees **cl::init**, it knows where to put the initial value. (You will get an; error at runtime if you don't put them in the right order.). .. _cl::location:. * The **cl::location** attribute where to store the value for a parsed command; line option if using external storage. See the section on `Internal vs; External Storage`_ for more information. .. _cl::aliasopt:. * The **cl::aliasopt** attribute specifies which option a `cl::alias`_ option is; an alias for. .. _cl::values:. * The **cl::values** attribute specifies the string-to-value mapping to be used; by the generic parser. It takes a list of (option, value, description); triplets that specify the option name, the value mapped to, and the; description shown in the ``-help`` for the tool. Because the generic parser; is used most frequently with enum values, two macros are often useful:. #. The **clEnumVal** macro is used as a nice simple way to specify a triplet; for an enum. This macro automatically makes the option name be the same as; the enum name. The first option to the macro is the enum, the second is; the description for the command line option. #. The **clEnumValN** macro is used to specify macro options where the option; name doesn't equal the enum name. For this macro, the first argument is; the enum value, the second is the flag name, and the second is the; description. You will get a compile time error if you try to use cl::values with a parser; that does not support it. .. _cl::multi_val:. * The **cl::multi_val** attribute specifies that this option takes has multiple; values (example: ``-sectalign segname sectname sectvalue``). This attribute; takes one unsigned argument - the number of values for the option. This; attribute is valid only on ``cl::list`` options (and will fail with compile; error if you try to use it with other option types). It is allowed to use all; of the usual modifiers on mult",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandLine.rst:37525,simpl,simple,37525,interpreter/llvm-project/llvm/docs/CommandLine.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandLine.rst,1,['simpl'],['simple']
Usability,"on, one could enable monitoring flag in the browser - then objects view will be regularly updated. ## Accessing file system. THttpServer provides partial access to the files from file system.; First of all, JSROOT scripts and files can be accessed via ""jsrootsys/"" path like ""http://localhost:8080/jsrootsys/modules/core.mjs"".; Files from ROOT install directory can be get via ""rootsys/"" path like ""http://localhost:8080/rootsys/icons/about.xpm"".; Also files from current directory where ROOT is running can be accessed via ""currentdir/"" path like ""http://localhost:8080/currentdir/file.txt"". If necessary, one can add custom path as well, using [THttpServer::AddLocation](https://root.cern/doc/master/classTHttpServer.html#a5322c3bbfddb8eb6849297d83ccaf87f) method:. ```cpp; serv->AddLocation(""mydir/"", ""/home/user/specials"");; ```. Then files from that directory could be addressed via URL like ""http://localhost:8080/mydir/myfile.root"". ## Command interface. THttpServer class provide simple interface to invoke command from web browser.; One just register command like:. ```cpp; serv->RegisterCommand(""/DoSomething"", ""SomeFunction()"");; ```. Element with name `DoSomething` will appear in the web browser and can be clicked.; It will result in `gROOT->ProcessLineSync(""SomeFunction()"")` call. One could configure argument(s) for the command.; For that one should use `%arg1`, `%arg2` and so on identifiers. Like:. ```cpp; serv->RegisterCommand(""/DoSomething"", ""SomeFunction(%arg1%,%arg2%)"");; ```. User will be requested to enter arguments values, when command element clicked in the browser.; Example of the command which executes arbitrary string in application via ProcessLine looks like:. ```cpp; serv->RegisterCommand(""/Process"", ""%arg1%"");; ```. When registering command, one could specify icon name which will be displayed with the command. ```cpp; serv->RegisterCommand(""/DoSomething"", ""SomeFunction()"", ""rootsys/icons/ed_execute.png"");; ```. In example usage of images from `$ROOTSYS/icon",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/HttpServer/HttpServer.md:4934,simpl,simple,4934,documentation/HttpServer/HttpServer.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/HttpServer/HttpServer.md,1,['simpl'],['simple']
Usability,"on, we should get the numbers sequence and then create the hash number.; So, once again, *total-ordering* could be considered as a milestone for even; faster (in theory) random-access approach. MergeFunctions, main fields and runOnModule; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^; There are two main important fields in the class:. ``FnTree`` – the set of all unique functions. It keeps items that couldn't be; merged with each other. It is defined as:. ``std::set<FunctionNode> FnTree;``. Here ``FunctionNode`` is a wrapper for ``llvm::Function`` class, with; implemented “<” operator among the functions set (below we explain how it works; exactly; this is a key point in fast functions comparison). ``Deferred`` – merging process can affect bodies of functions that are in; ``FnTree`` already. Obviously, such functions should be rechecked again. In this; case, we remove them from ``FnTree``, and mark them to be rescanned, namely; put them into ``Deferred`` list. runOnModule; """"""""""""""""""""""; The algorithm is pretty simple:. 1. Put all module's functions into the *worklist*. 2. Scan *worklist*'s functions twice: first enumerate only strong functions and; then only weak ones:. 2.1. Loop body: take a function from *worklist* (call it *FCur*) and try to; insert it into *FnTree*: check whether *FCur* is equal to one of functions; in *FnTree*. If there *is* an equal function in *FnTree*; (call it *FExists*): merge function *FCur* with *FExists*. Otherwise add; the function from the *worklist* to *FnTree*. 3. Once the *worklist* scanning and merging operations are complete, check the; *Deferred* list. If it is not empty: refill the *worklist* contents with; *Deferred* list and redo step 2, if the *Deferred* list is empty, then exit; from method. Comparison and logarithmical search; """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Let's recall our task: for every function *F* from module *M*, we have to find; equal functions *F`* in the shortest time possible , and merge them into a; single func",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MergeFunctions.rst:8400,simpl,simple,8400,interpreter/llvm-project/llvm/docs/MergeFunctions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MergeFunctions.rst,1,['simpl'],['simple']
Usability,"on. Even more includes will be ""hidden"" when ROOT configured with `-Ddev=ON` build option.; In that case ROOT uses `#ifdef R__LESS_INCLUDES` to replace unused includes by class forward declarations.; Such `dev` builds can be used to verify that ROOT-based code really includes all necessary ROOT headers. ## RDataFrame. - Starting from this version, when `RSnapshotOptions.fMode` is `""UPDATE""` (i.e. the output file is opened in ""UPDATE""; mode), Snapshot will refuse to write out a TTree if one with the same name is already present in the output file.; Users can set the new flag `RSnapshotOption::fOverwriteIfExists` to `true` to force the deletion of the TTree that is; already present and the writing of a new TTree with the same name. See; [ROOT-10573](https://sft.its.cern.ch/jira/browse/ROOT-10573) for more details.; - RDataFrame changed its error handling strategy in case of unreadable input files. Instead of simply logging an error; and skipping the file, it now throws an exception if any of the input files is unreadable (this could also happen in; the middle of an event loop). See [ROOT-10549](https://sft.its.cern.ch/jira/browse/ROOT-10549) for more details.; - New analysis examples based on the recent ATLAS Open Data release ([`Higgs to two photons`](https://root.cern/doc/master/df104__HiggsToTwoPhotons_8py.html), [`W boson analysis`](https://root.cern/doc/master/df105__WBosonAnalysis_8py.html), [`Higgs to four leptons`](https://root.cern/doc/master/df106__HiggsToFourLeptons_8py.html)); - An exception is now thrown in case the size of ROOT's thread-pool changes between RDataFrame construction time and the time the event loop begins.; - Just-in-time compilation of large portions of the computation graph has been optimized, and it is now much faster. Please report any regressions you might encounter on [our issue tracker](https://sft.its.cern.ch/jira/projects/ROOT).; - `MakeRootDataFrame` is now a safe way to construct RDFs. It used to return RDFs with more limited fu",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v622/index.md:9796,simpl,simply,9796,README/ReleaseNotes/v622/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v622/index.md,1,['simpl'],['simply']
Usability,"on. However, some; clients of the ``ASTImporter`` may require a different, perhaps less; conservative and more liberal error handling strategy. E.g. static analysis clients may benefit if the node is created even if there; is a name conflict. During the CTU analysis of certain projects, we recognized; that there are global declarations which collide with declarations from other; translation units, but they are not referenced outside from their translation; unit. These declarations should be in an unnamed namespace ideally. If we treat; these collisions liberally then CTU analysis can find more results. Note, the; feature be able to choose between name conflict handling strategies is still an; ongoing work. .. _CFG:. The ``CFG`` class; -----------------. The ``CFG`` class is designed to represent a source-level control-flow graph; for a single statement (``Stmt*``). Typically instances of ``CFG`` are; constructed for function bodies (usually an instance of ``CompoundStmt``), but; can also be instantiated to represent the control-flow of any class that; subclasses ``Stmt``, which includes simple expressions. Control-flow graphs; are especially useful for performing `flow- or path-sensitive; <https://en.wikipedia.org/wiki/Data_flow_analysis#Sensitivities>`_ program; analyses on a given function. Basic Blocks; ^^^^^^^^^^^^. Concretely, an instance of ``CFG`` is a collection of basic blocks. Each basic; block is an instance of ``CFGBlock``, which simply contains an ordered sequence; of ``Stmt*`` (each referring to statements in the AST). The ordering of; statements within a block indicates unconditional flow of control from one; statement to the next. :ref:`Conditional control-flow; <ConditionalControlFlow>` is represented using edges between basic blocks. The; statements within a given ``CFGBlock`` can be traversed using the; ``CFGBlock::*iterator`` interface. A ``CFG`` object owns the instances of ``CFGBlock`` within the control-flow; graph it represents. Each ``CFGBlo",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:112215,simpl,simple,112215,interpreter/llvm-project/clang/docs/InternalsManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst,1,['simpl'],['simple']
Usability,"on:: -code-model=model. Choose the code model from:. .. code-block:: text. default: Target default code model; tiny: Tiny code model; small: Small code model; kernel: Kernel code model; medium: Medium code model; large: Large code model. .. option:: -disable-post-RA-scheduler. Disable scheduling after register allocation. .. option:: -disable-spill-fusing. Disable fusing of spill code into instructions. .. option:: -jit-enable-eh. Exception handling should be enabled in the just-in-time compiler. .. option:: -join-liveintervals. Coalesce copies (default=true). .. option:: -nozero-initialized-in-bss. Don't place zero-initialized symbols into the BSS section. .. option:: -pre-RA-sched=scheduler. Instruction schedulers available (before register allocation):. .. code-block:: text. =default: Best scheduler for the target; =none: No scheduling: breadth first sequencing; =simple: Simple two pass scheduling: minimize critical path and maximize processor utilization; =simple-noitin: Simple two pass scheduling: Same as simple except using generic latency; =list-burr: Bottom-up register reduction list scheduling; =list-tdrr: Top-down register reduction list scheduling; =list-td: Top-down list scheduler. .. option:: -regalloc=allocator. Register allocator to use (default=linearscan). .. code-block:: text. =bigblock: Big-block register allocator; =linearscan: linear scan register allocator; =local: local register allocator; =simple: simple register allocator. .. option:: -relocation-model=model. Choose relocation model from:. .. code-block:: text. =default: Target default relocation model; =static: Non-relocatable code; =pic: Fully relocatable, position independent code; =dynamic-no-pic: Relocatable external references, non-relocatable code. .. option:: -spiller. Spiller to use (default=local). .. code-block:: text. =simple: simple spiller; =local: local spiller. .. option:: -x86-asm-syntax=syntax. Choose style of code to emit from X86 backend:. .. code-block:: text. =att: Emit",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/lli.rst:4443,simpl,simple,4443,interpreter/llvm-project/llvm/docs/CommandGuide/lli.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/lli.rst,3,['simpl'],"['simple', 'simple-noitin']"
Usability,"on; from source files that are significantly easier to code than the output files would be, and also easier to maintain and modify over time. The information is coded in a declarative style involving classes and records,; which are then processed by TableGen. ```; class Hello <string _msg> {; string msg = !strconcat(""Hello "", _msg);; }. def HelloWorld: Hello<""world!""> {}; ```; ```; ------------- Classes -----------------; class Hello<string Hello:_msg = ?> {; string msg = !strconcat(""Hello "", Hello:_msg);; }; ------------- Defs -----------------; def HelloWorld { // Hello; string msg = ""Hello world!"";; }; ```; [Try this example on Compiler Explorer.](https://godbolt.org/z/13xo1P5oz). The internalized records are passed on to various backends, which extract; information from a subset of the records and generate one or more output files. These output files are typically .inc files for C++, but may be any type of file; that the backend developer needs. Resources for learning the language:; * [TableGen Overview](https://llvm.org/docs/TableGen/index.html); * [Programmer's reference guide](https://llvm.org/docs/TableGen/ProgRef.html); * [Tutorial](jupyter/tablegen_tutorial_part_1.ipynb); * [Tools for Learning LLVM TableGen](https://blog.llvm.org/posts/2023-12-07-tools-for-learning-llvm-tablegen/); * [Lessons in TableGen](https://www.youtube.com/watch?v=45gmF77JFBY) (video),; [slides](https://archive.fosdem.org/2019/schedule/event/llvm_tablegen/attachments/slides/3304/export/events/attachments/llvm_tablegen/slides/3304/tablegen.pdf); * [Improving Your TableGen Descriptions](https://www.youtube.com/watch?v=dIEVUlsiktQ); (video), [slides](https://llvm.org/devmtg/2019-10/slides/Absar-ImprovingYourTableGenDescription.pdf). Writing TableGen backends:; * [TableGen Backend Developer's Guide](https://llvm.org/docs/TableGen/BackGuide.html); * [How to write a TableGen backend](https://www.youtube.com/watch?v=UP-LBRbvI_U); (video), [slides](https://llvm.org/devmtg/2021-11/slides/2021",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/README.md:1073,learn,learning,1073,interpreter/llvm-project/llvm/utils/TableGen/README.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/README.md,1,['learn'],['learning']
Usability,"on; structures and perform some checks. Note the messages posted after the; statement is executed. We will describe the corresponding operations; later. ~~~{.cpp}; root[] gGeoManager->CloseGeometry();; ~~~. Now we are really done with geometry building stage, but we would like; to see our simple world:. ~~~{.cpp}; root[] top->SetLineColor(kMagenta);; root[] gGeoManager->SetTopVisible(); // the TOP is invisible; root[] top->Draw();; ~~~. \anchor GP00b; ### Example 2: A Geometrical Hierarchy Look and Feel. Before going further, let us get a look and feel of interacting with the; modeller. For this, we will use one of the examples illustrating the; geometry package. To get an idea on the geometry structure created in; this example, just look at rootgeom.C. You will; notice that this is a bit more complex that just creating the ""world""; since several other volumes are created and put together in a hierarchy.; The purpose here is just to learn how to interact with a geometry that; is already built, but just few hints on the building steps in this; example might be useful. The geometry here represents the word %ROOT that; is replicated in some symmetric manner. You might for instance ask some; questions after having a first look:. **Q:** ""OK, I understand the first lines that load the libGeom library and create; a geometry manager object. I also recognize from the previous example the following; lines creating some materials and media, but what about the geometrical transformations below?"". **A:** As explained before, the model that we are trying to create; is a hierarchy of volumes based on ""containment"". This is; accomplished by ""positioning"" some volumes ""inside"" others.; Any volume is an un-positioned object in the sense that it defines only; a ""local frame"" (matching the one of its ""shape""). In order; to fully define the mother-daughter relationship between two volumes one; has to specify how the daughter will be positioned inside. This is; accomplished by defining a",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md:7501,learn,learn,7501,geom/geom/doc/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md,1,['learn'],['learn']
Usability,"onAST::codegen() {; ...; Builder->SetInsertPoint(BB);. // Record the function arguments in the NamedValues map.; NamedValues.clear();; for (auto &Arg : TheFunction->args()) {; // Create an alloca for this variable.; AllocaInst *Alloca = CreateEntryBlockAlloca(TheFunction, Arg.getName());. // Store the initial value into the alloca.; Builder->CreateStore(&Arg, Alloca);. // Add arguments to variable symbol table.; NamedValues[std::string(Arg.getName())] = Alloca;; }. if (Value *RetVal = Body->codegen()) {; ... For each argument, we make an alloca, store the input value to the; function into the alloca, and register the alloca as the memory location; for the argument. This method gets invoked by ``FunctionAST::codegen()``; right after it sets up the entry block for the function. The final missing piece is adding the mem2reg pass, which allows us to; get good codegen once again:. .. code-block:: c++. // Promote allocas to registers.; TheFPM->add(createPromoteMemoryToRegisterPass());; // Do simple ""peephole"" optimizations and bit-twiddling optzns.; TheFPM->add(createInstructionCombiningPass());; // Reassociate expressions.; TheFPM->add(createReassociatePass());; ... It is interesting to see what the code looks like before and after the; mem2reg optimization runs. For example, this is the before/after code; for our recursive fib function. Before the optimization:. .. code-block:: llvm. define double @fib(double %x) {; entry:; %x1 = alloca double; store double %x, double* %x1; %x2 = load double, double* %x1; %cmptmp = fcmp ult double %x2, 3.000000e+00; %booltmp = uitofp i1 %cmptmp to double; %ifcond = fcmp one double %booltmp, 0.000000e+00; br i1 %ifcond, label %then, label %else. then: ; preds = %entry; br label %ifcont. else: ; preds = %entry; %x3 = load double, double* %x1; %subtmp = fsub double %x3, 1.000000e+00; %calltmp = call double @fib(double %subtmp); %x4 = load double, double* %x1; %subtmp5 = fsub double %x4, 2.000000e+00; %calltmp6 = call double @fib(double %su",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl07.rst:16662,simpl,simple,16662,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl07.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl07.rst,1,['simpl'],['simple']
Usability,"on`_ (v1), transpiling; Python code into C++ and interpreting the result with CINT.; In early 2003, I ported this code to boost.python v2, then recently released.; In practice, however, re-interpreting the transpiled code was unusably slow,; thus I modified the code to make direct use of CINT's internal reflection; system, gaining about 25x in performance.; I presented this work as `PyROOT` at the ROOT Users' Workshop in early 2004,; and, after removing the boost.python dependency by using the C-API directly; (gaining another factor 7 in speedup!), it was included in ROOT.; PyROOT was presented at the SciPy'06 conference, but was otherwise not; advocated outside of High Energy Physics (HEP). In 2010, the PyPy core developers and I held a `sprint at CERN`_ to use; `Reflex`, a standalone alternative to CINT's reflection of C++, to add; automatic C++ bindings, PyROOT-style, to `PyPy`_.; This is where the name ""cppyy"" originated.; Coined by Carl Friedrich Bolz, if you want to understand the meaning, just; pronounce it slowly: cpp-y-y. After the ROOT team replaced CINT with `Cling`_, PyROOT soon followed.; As part of Google's Summer of Code '16, Aditi Dutta moved PyPy/cppyy to Cling; as well, and packaged the code for use through `PyPI`_.; I continued this integration with the Python eco-system by forking PyROOT,; reducing its dependencies, and repackaging it as CPython/cppyy.; The combined result is the current cppyy project.; Mid 2018, version 1.0 was released. .. _`CERN`: https://cern.ch/; .. _`PyROOT`: https://root.cern.ch/root/htmldoc/guides/users-guide/ROOTUsersGuide.html#python-interface; .. _`CINT`: https://en.wikipedia.org/wiki/CINT; .. _`ROOT`: https://root.cern.ch; .. _`boost.python`: https://wiki.python.org/moin/boost.python/GettingStarted; .. _`sprint at CERN`: https://morepypy.blogspot.com/2010/07/cern-sprint-report-wrapping-c-libraries.html; .. _`PyPy`: https://www.pypy.org/; .. _`Cling`: https://github.com/vgvassilev/cling; .. _`PyPI`: https://pypi.org/; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/history.rst:2037,guid,guides,2037,bindings/pyroot/cppyy/cppyy/doc/source/history.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/history.rst,2,['guid'],"['guide', 'guides']"
Usability,"on``\ s from the current ``Module``.; #. Add or remove global variables from the current ``Module``.; #. Maintain state across invocations of :ref:`runOnFunction; <writing-an-llvm-pass-runOnFunction>` (including global data). Implementing a ``FunctionPass`` is usually straightforward (See the :ref:`Hello; World <writing-an-llvm-pass-basiccode>` pass for example).; ``FunctionPass``\ es may override three virtual methods to do their work. All; of these methods should return ``true`` if they modified the program, or; ``false`` if they didn't. .. _writing-an-llvm-pass-doInitialization-mod:. The ``doInitialization(Module &)`` method; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. .. code-block:: c++. virtual bool doInitialization(Module &M);. The ``doInitialization`` method is allowed to do most of the things that; ``FunctionPass``\ es are not allowed to do. They can add and remove functions,; get pointers to functions, etc. The ``doInitialization`` method is designed to; do simple initialization type of stuff that does not depend on the functions; being processed. The ``doInitialization`` method call is not scheduled to; overlap with any other pass executions (thus it should be very fast). A good example of how this method should be used is the `LowerAllocations; <https://llvm.org/doxygen/LowerAllocations_8cpp-source.html>`_ pass. This pass; converts ``malloc`` and ``free`` instructions into platform dependent; ``malloc()`` and ``free()`` function calls. It uses the ``doInitialization``; method to get a reference to the ``malloc`` and ``free`` functions that it; needs, adding prototypes to the module if necessary. .. _writing-an-llvm-pass-runOnFunction:. The ``runOnFunction`` method; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^. .. code-block:: c++. virtual bool runOnFunction(Function &F) = 0;. The ``runOnFunction`` method must be implemented by your subclass to do the; transformation or analysis work of your pass. As usual, a ``true`` value; should be returned if the function is modified. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/WritingAnLLVMPass.rst:18738,simpl,simple,18738,interpreter/llvm-project/llvm/docs/WritingAnLLVMPass.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/WritingAnLLVMPass.rst,1,['simpl'],['simple']
Usability,"onally identifying; information (""doxing"").; * Personal insults, especially those using racist or sexist terms.; * Unwelcome sexual attention.; * Advocating for, or encouraging, any of the above behavior. In general, if someone asks you to stop, then stop. Persisting in such; behavior after being asked to stop is considered harassment. .. _when we disagree, try to understand why:. * **When we disagree, try to understand why.** Disagreements, both social and; technical, happen all the time and LLVM is no exception. It is important that; we resolve disagreements and differing views constructively. Remember that; we're different. The strength of LLVM comes from its varied community, people; from a wide range of backgrounds. Different people have different; perspectives on issues. Being unable to understand why someone holds; a viewpoint doesn't mean that they're wrong. Don't forget that it is human to; err and blaming each other doesn't get us anywhere. Instead, focus on helping; to resolve issues and learning from mistakes. Reporting; =========. If you believe someone is violating the code of conduct you can always report; it to the LLVM Foundation Code of Conduct Committee by emailing; conduct@llvm.org. All reports will be kept confidential. This isn't a public; list and only members of the advisory committee will receive the report. For; details on what to include in the report, please see the :doc:`Reporting Guide; <ReportingGuide>`. If you believe anyone is in physical danger, please notify appropriate law; enforcement first. If you are unsure what law enforcement agency is; appropriate, please include this in your report and we will attempt to notify; them. If the violation occurs at an event such as a Developer Meeting and requires; immediate attention, you can also reach out to any of the event organizers or; staff. Event organizers and staff will be prepared to handle the incident and; able to help. If you cannot find one of the organizers, the venue staff can;",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodeOfConduct.rst:5402,learn,learning,5402,interpreter/llvm-project/llvm/docs/CodeOfConduct.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodeOfConduct.rst,1,['learn'],['learning']
Usability,"onfiguration.; Like server binding to specific host `root --notebook --ip=hostname`; - Remove `c.NotebookApp.ip = '*'` from default jupyter config. One has to provide ip address for server; binding using `root --notebook --ip=<hostaddr>` arguments; - Now Jupyter Notebooks will use JSROOT provided with ROOT installation. This allows to use notebooks; without internet connection (offline). ## JavaScript ROOT; - Provide monitoring capabilities for TGeoManager object. Now geomtry with some tracks can be displayed and; updated in web browser, using THttpServer monitoring capability like histogram objects. ## Tutorials; - Add the ""Legacy"" category collecting the old tutorials which do not represent any more best practices. ## Class Reference Guide; - Images in tutorials can now be displayed à JavaScript thanks to the (js) option; added next to the directive `\macro_image`; - As the tutorial `palettes.C` is often hit when searching the keyword `palette`; in the reference guide, a direct link from this example to the full list of; predefined palettes given in `TColor` has been added.; - Revisited the TSpectrum2 documentation. All the static images have been replaced; by macros generating images at reference guide build time. These macros have; been added in the tutorial section of the reference guide.; - The Reference Guide can now be accessed directly from the ROOT prompt thanks to; a great extension (implemented by Desislava Kalaydjieva) of the `.help` command.; For example to access the Reference Guide for `TTree` it is enough to type:; ~~~ {.cpp}; root[0] .help TTree; ~~~; To open the reference guide for a function/member:; ~~~ {.cpp}; root[0] .help TTree::Draw; ~~~. ## Build, Configuration and Testing Infrastructure. - Make MLP optional via the `-Dmlp={OFF,ON}` switch for CMake; - Make Spectrum optional via the `-Dspectrum={OFF,ON}` switch for CMake; - ROOT now fails to configure when any package is missing; when `-Dfail-on-missing=ON` is passed to CMake; - The `-Dall=",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v620/index.md:7093,guid,guide,7093,README/ReleaseNotes/v620/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v620/index.md,1,['guid'],['guide']
Usability,"online.; Compile time performance is important, but when using clang as an API, often; memory use is even more so: the less memory the code takes the more code you can; fit into memory at a time (useful for whole program analysis tools, for; example).; In addition to being efficient when pitted head-to-head against GCC in batch; mode, clang is built with a library based; architecture that makes it relatively easy to adapt it and build new tools; with it. This means that it is often possible to apply out-of-the-box thinking; and novel techniques to improve compilation in various ways. Expressive Diagnostics. In addition to being fast and functional, we aim to make Clang extremely user; friendly. As far as a command-line compiler goes, this basically boils down to; making the diagnostics (error and warning messages) generated by the compiler; be as useful as possible. There are several ways that we do this, but the; most important are pinpointing exactly what is wrong in the program,; highlighting related information so that it is easy to understand at a glance,; and making the wording as clear as possible.; Here is one simple example that illustrates the quality of Clang diagnostic:. $ clang -fsyntax-only t.c; t.c:7:39: error: invalid operands to binary expression ('int' and 'struct A'); return y + func(y ? ((SomeA.X + 40) + SomeA) / 42 + SomeA.X : SomeA.X);; ~~~~~~~~~~~~~~ ^ ~~~~~. Here you can see that you don't even need to see the original source code to; understand what is wrong based on the Clang error: Because Clang prints a; caret, you know exactly which plus it is complaining about. The range; information highlights the left and right side of the plus which makes it; immediately obvious what the compiler is talking about, which is very useful for; cases involving precedence issues and many other situations.; Clang diagnostics are very polished and have many features. For more; information and examples, please see the Expressive; Diagnostics page. GCC Compati",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/features.html:2123,clear,clear,2123,interpreter/llvm-project/clang/www/features.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/features.html,1,['clear'],['clear']
Usability,"only valid; operands for a named metadata. #. Named metadata are represented as a string of characters with the; metadata prefix. The rules for metadata names are the same as for; identifiers, but quoted names are not allowed. ``""\xx""`` type escapes; are still valid, which allows any character to be part of a name. Syntax::. ; Some unnamed metadata nodes, which are referenced by the named metadata.; !0 = !{!""zero""}; !1 = !{!""one""}; !2 = !{!""two""}; ; A named metadata.; !name = !{!0, !1, !2}. .. _paramattrs:. Parameter Attributes; --------------------. The return type and each parameter of a function type may have a set of; *parameter attributes* associated with them. Parameter attributes are; used to communicate additional information about the result or; parameters of a function. Parameter attributes are considered to be part; of the function, not of the function type, so functions with different; parameter attributes can have the same function type. Parameter attributes are simple keywords that follow the type specified.; If multiple parameter attributes are needed, they are space separated.; For example:. .. code-block:: llvm. declare i32 @printf(ptr noalias nocapture, ...); declare i32 @atoi(i8 zeroext); declare signext i8 @returns_signed_char(). Note that any attributes for the function result (``nonnull``,; ``signext``) come before the result type. Currently, only the following parameter attributes are defined:. ``zeroext``; This indicates to the code generator that the parameter or return; value should be zero-extended to the extent required by the target's; ABI by the caller (for a parameter) or the callee (for a return value).; ``signext``; This indicates to the code generator that the parameter or return; value should be sign-extended to the extent required by the target's; ABI (which is usually 32-bits) by the caller (for a parameter) or; the callee (for a return value).; ``inreg``; This indicates that this parameter or return value should be treated; in a ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:50107,simpl,simple,50107,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['simpl'],['simple']
Usability,"only* loop; in a given function, it is not touched. This is a pass most useful for; debugging via bugpoint. ``loop-reduce``: Loop Strength Reduction; ----------------------------------------. This pass performs a strength reduction on array references inside loops that; have as one or more of their components the loop induction variable. This is; accomplished by creating a new value to hold the initial value of the array; access for the first iteration, and then creating a new GEP instruction in the; loop to increment the value by the appropriate amount. .. _passes-loop-rotate:. ``loop-rotate``: Rotate Loops; -----------------------------. A simple loop rotation transformation. A summary of it can be found in; :ref:`Loop Terminology for Rotated Loops <loop-terminology-loop-rotate>`. .. _passes-loop-simplify:. ``loop-simplify``: Canonicalize natural loops; ---------------------------------------------. This pass performs several transformations to transform natural loops into a; simpler form, which makes subsequent analyses and transformations simpler and; more effective. A summary of it can be found in; :ref:`Loop Terminology, Loop Simplify Form <loop-terminology-loop-simplify>`. Loop pre-header insertion guarantees that there is a single, non-critical entry; edge from outside of the loop to the loop header. This simplifies a number of; analyses and transformations, such as :ref:`LICM <passes-licm>`. Loop exit-block insertion guarantees that all exit blocks from the loop (blocks; which are outside of the loop that have predecessors inside of the loop) only; have predecessors from inside of the loop (and are thus dominated by the loop; header). This simplifies transformations such as store-sinking that are built; into LICM. This pass also guarantees that loops will have exactly one backedge. Note that the :ref:`simplifycfg <passes-simplifycfg>` pass will clean up blocks; which are split out but end up being unnecessary, so usage of this pass should; not pessimize gene",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Passes.rst:26772,simpl,simpler,26772,interpreter/llvm-project/llvm/docs/Passes.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Passes.rst,2,['simpl'],['simpler']
Usability,"onse Guide <ResponseGuide>`. Confidentiality; ===============. All reports will be kept confidential with details shared only with the Code of; Conduct committee members. In the case that a CoC committee member is involved; in a report, the member will be asked to recuse themselves from ongoing; conversations, and they will not have access to any reports at any time.; Resolution action may also include removal of that member from the CoC; committee. Some incidents happen in one-on-one interactions, and though details are; anonymized, the reported person may be able to guess who made the report. If; you have concerns about retaliation or your personal safety, please note those; concerns in your report. You are still encouraged to report the incident so; that we can support you while keeping our community members safe. In some; cases, we can compile several anonymized reports into a pattern of behavior,; and take action on that pattern. . Transparency reports will be published but will retain confidentiality. See the; :doc:`Response Guide <ResponseGuide>`. for details on this. Following Up With Reporter(s); =============================. Once a report is filed, the Code of Conduct committee will handle the review; and follow up according to the procedures in the :doc:`Response Guide; <ResponseGuide>`. . Thanks!; =======. This guide was created and inspired by the following: the `Django Project`_,; `Carpentries Response Guide`_, and the `Write The Docs Response Guide`_. License; =======. All content on this page is licensed under a `Creative Commons Attribution 3.0; Unported License`_. .. _Django Project: https://www.djangoproject.com/conduct/; .. _Carpentries Response Guide: https://docs.carpentries.org/topic_folders/policies/enforcement-guidelines.html; .. _Write The Docs Response Guide: https://www.writethedocs.org/code-of-conduct/#guidelines-for-reporting-incidents; .. _Creative Commons Attribution 3.0 Unported License: http://creativecommons.org/licenses/by/3.0/. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReportingGuide.rst:4885,guid,guide,4885,interpreter/llvm-project/llvm/docs/ReportingGuide.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReportingGuide.rst,3,['guid'],"['guide', 'guidelines', 'guidelines-for-reporting-incidents']"
Usability,"ontents::; :local:. Description; ===========. ``bugpoint`` narrows down the source of problems in LLVM tools and passes. It; can be used to debug three types of failures: optimizer crashes, miscompilations; by optimizers, or bad native code generation (including problems in the static; and JIT compilers). It aims to reduce large test cases to small, useful ones.; For example, if ``opt`` crashes while optimizing a file, it will identify the; optimization (or combination of optimizations) that causes the crash, and reduce; the file down to a small example which triggers the crash. For detailed case scenarios, such as debugging ``opt``, or one of the LLVM code; generators, see :doc:`HowToSubmitABug`. Design Philosophy; =================. ``bugpoint`` is designed to be a useful tool without requiring any hooks into; the LLVM infrastructure at all. It works with any and all LLVM passes and code; generators, and does not need to ""know"" how they work. Because of this, it may; appear to do stupid things or miss obvious simplifications. ``bugpoint`` is; also designed to trade off programmer time for computer time in the; compiler-debugging process; consequently, it may take a long period of; (unattended) time to reduce a test case, but we feel it is still worth it. Note; that ``bugpoint`` is generally very quick unless debugging a miscompilation; where each test of the program (which requires executing it) takes a long time. Automatic Debugger Selection; ----------------------------. ``bugpoint`` reads each ``.bc`` or ``.ll`` file specified on the command line; and links them together into a single module, called the test program. If any; LLVM passes are specified on the command line, it runs these passes on the test; program. If any of the passes crash, or if they produce malformed output (which; causes the verifier to abort), ``bugpoint`` starts the `crash debugger`_. Otherwise, if the ``-output`` option was not specified, ``bugpoint`` runs the; test program with the ""safe""",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Bugpoint.rst:1145,simpl,simplifications,1145,interpreter/llvm-project/llvm/docs/Bugpoint.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Bugpoint.rst,1,['simpl'],['simplifications']
Usability,"onvertGeometry()`; . After the conversion is done, all existing TGeo functionality is available as for; a native geometry, only that most of the converted solids provide better navigation ; performance, despite the overhead introduced by the new adapter shape. Prerequisites: installation of VecGeom. ; The installation instructions are available at <http://geant.web.cern.ch/content/installation>; Due to the fact that VecGeom provides for the moment static libraries ; and depends on ROOT, is is advised to compile first ROOT without VecGeom support, ; then compile VecGeom against this ROOT version, then re-configure ROOT to enable ; VecGeom and Vc support, using the flags -Dvc=ON -Dvecgeom=on; ; This has been implemented by Mihaela Gheata <Mihaela.Gheata@cern.ch>. ## Database Libraries. * Fix `TPgSQLStatement::SetBinary` to actually handle binary data (previous limited to ascii). ## Networking Libraries. * When seeing too many requested ranges, Apache 2.4 now simply sends the whole file; (MaxRanges configuration parameter). TWebFile can handle this case now, but this can; trigger multiple transmissions of the full file. TWebFile warns when Apache reacts by; sending the full file. ## GUI Libraries. * A new `Browser.ExpandDirectories` option (the default is `yes`) has been added, allowing to prevent expanding the parent directory tree in the ROOT Browser (for example on nfs). ## Language Bindings. ### PyROOT. * Added a new configuration option to disable processing of the rootlogon[.py|C] macro in addition; ro the -n option in the command arguments. To disable processing the rootlogon do the following; before any other command that will trigger initialization:; ```; >>> import ROOT; >>> ROOT.PyConfig.DisableRootLogon = True; >>> ...; ```. ### Notebook integration. * Refactoring of the Jupyter integration layer into the new package JupyROOT.; * Added ROOT [Jupyter Kernel for ROOT](https://root.cern.ch/root-has-its-jupyter-kernel); * Magics are now invoked with standard syn",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v608/index.md:24775,simpl,simply,24775,README/ReleaseNotes/v608/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v608/index.md,1,['simpl'],['simply']
Usability,"ooFoo; example above only contains one integral function (`integralFoo()`). Similar to `doFoo()`, comment out `integralFoo()' in the original file and; move it to 'MathFuncs.h'. As with `doFoo()`. add the relevant inputs (a,b) as parameters, instead of; just class members. ``` {.cpp}; ///// The MathFuncs.h file; int integralFoo(int a, int b) { return /* whatever */;}; ```. > Directory path: [hist/hist/src/MathFuncs.h](https://github.com/root-project/root/blob/master/hist/hist/src/MathFuncs.h). Next, in the original RooFoo class, update all references to the; `integralFoo()` function with its new fully qualified path (; `EvaluateFunc::integralFoo`) and include the input parameters as well (; `EvaluateFunc::integralFoo(a, b)`). ``` {.cpp}; double analyticalIntegral(Int_t code, const char* rangeName) override {; // Select the right paths for integration using codes or whatever.; return EvaluateFunc::integralFoo(a, b);; }; ```. Next, in the `RooAbsReal::buildCallToAnalyticIntegral()` function, simply; return the output using the `buildCall()` function. ``` {.cpp}; std::string; buildCallToAnalyticIntegral(Int_t code, const char *rangeName, RooFit::Detail::RooFit::Detail::CodeSquashContext &ctx) const override {; return ctx.buildCall(""EvaluateFunc::integralFoo"", a, b);; }; ```. \note The implementation of the `RooAbsReal::buildCallToAnalyticIntegral()`; function is quite similar to the `translate()` function, except that in; `translate()`, you have to add to the result (using `addResult()`), while for; `buildCallToAnalyticIntegral()`, you only have to return the string (using; `buildCall()`). **Consolidated Code changes in RooFoo example**. Final RooFoo code:. ``` {.cpp}; class RooFoo : public RooAbsReal {; int a;; int b;; // int doFoo() { return a* b + a + b; }; // int integralFoo() { return /* whatever */;}; public:; // Other functions...; double evaluate() override {; // Do some bookkeeping; return EvaluateFunc::doFoo(a, b);; };; double analyticalIntegral(Int_t code, co",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/developers/roofit_ad.md:23733,simpl,simply,23733,roofit/doc/developers/roofit_ad.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/developers/roofit_ad.md,1,['simpl'],['simply']
Usability,"ool to clone and customize p.d.f.s into a RooSimultaneous p.d.f has been added. This new; tool succeeds the original RooSimPdfBuilder tool which had a similar functionality but; has a much cleaner interface, partly thanks to its use of the RooWorkspace class for both input; of prototype p.d.fs and output of built p.d.f.s. The simplest use case to to take a workspace p.d.f as prototype and 'split' a parameter of that p.d.f ; into two specialized parameters depending on a category in the dataset. ; For example, given a Gaussian p.d.f G(x,m,s) we want to construct a G_a(x,m_a,s) and a G_b(x,m_b,s); with different mean parameters to be fit to a dataset with observables; (x,c) where c is a category with states 'a' and 'b'.; Using RooSimWSTool one can create a simultaneous p.d.f from G_a and G_b; from G with the following command. RooSimWSTool wst(wspace) ;; wst.build(""G_sim"",""G"",SplitParam(""m"",""c"")) ;. From this simple example one can go to builds of arbitrary complexity; by specifying multiple SplitParam arguments on multiple parameters; involving multiple splitting categories. Splits can also be performed; in the product multiple categories, e.g. . SplitParam(""m"",""c,d"")) ;. splits parameter m in the product of states of c and d. Another possibility; is the 'constrained' split which clones the parameter for all but one state; and insert a formula specialization in a chosen state that evaluates; to 1 - sum_i(a_i) where a_i are all other specializations. For example,; given a category c with state ""A"",""B"",""C"",""D"" the specification. SplitParamConstrained(""m"",""c"",""D""). will result in parameters m_A,m_B,m_C and a formula expression m_D; that evaluates to (1-(m_A+m_B+m_C)). Constrained split can also be; specified in product of categories. In that case the name of the; remainder state follows the syntax {State1;State2} where State1; and State2 are the state names of the two spitting categories. Additional; functionality exists to work with multiple prototype p.d.f.s simultane",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v520/index.html:12366,simpl,simple,12366,roofit/doc/v520/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v520/index.html,1,['simpl'],['simple']
Usability,"opAnalysisManager>();; TheFAM = std::make_unique<FunctionAnalysisManager>();; TheCGAM = std::make_unique<CGSCCAnalysisManager>();; TheMAM = std::make_unique<ModuleAnalysisManager>();; ThePIC = std::make_unique<PassInstrumentationCallbacks>();; TheSI = std::make_unique<StandardInstrumentations>(*TheContext,; /*DebugLogging*/ true);; TheSI->registerCallbacks(*ThePIC, TheMAM.get());; ... After initializing the global module ``TheModule`` and the FunctionPassManager,; we need to initialize other parts of the framework. The four AnalysisManagers; allow us to add analysis passes that run across the four levels of the IR; hierarchy. PassInstrumentationCallbacks and StandardInstrumentations are; required for the pass instrumentation framework, which allows developers to; customize what happens between passes. Once these managers are set up, we use a series of ""addPass"" calls to add a; bunch of LLVM transform passes:. .. code-block:: c++. // Add transform passes.; // Do simple ""peephole"" optimizations and bit-twiddling optzns.; TheFPM->addPass(InstCombinePass());; // Reassociate expressions.; TheFPM->addPass(ReassociatePass());; // Eliminate Common SubExpressions.; TheFPM->addPass(GVNPass());; // Simplify the control flow graph (deleting unreachable blocks, etc).; TheFPM->addPass(SimplifyCFGPass());. In this case, we choose to add four optimization passes.; The passes we choose here are a pretty standard set; of ""cleanup"" optimizations that are useful for a wide variety of code. I won't; delve into what they do but, believe me, they are a good starting place :). Next, we register the analysis passes used by the transform passes. .. code-block:: c++. // Register analysis passes used in these transform passes.; PassBuilder PB;; PB.registerModuleAnalyses(*TheMAM);; PB.registerFunctionAnalyses(*TheFAM);; PB.crossRegisterProxies(*TheLAM, *TheFAM, *TheCGAM, *TheMAM);; }. Once the PassManager is set up, we need to make use of it. We do this by; running it after our newly created fun",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl04.rst:7054,simpl,simple,7054,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl04.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl04.rst,1,['simpl'],['simple']
Usability,"ope, functions are typed with just a count of their; arguments. Since all values are double precision floating point, the; type of each argument doesn't need to be stored anywhere. In a more; aggressive and realistic language, the ""ExprAST"" class would probably; have a type field. With this scaffolding, we can now talk about parsing expressions and; function bodies in Kaleidoscope. Parser Basics; =============. Now that we have an AST to build, we need to define the parser code to; build it. The idea here is that we want to parse something like ""x+y""; (which is returned as three tokens by the lexer) into an AST that could; be generated with calls like this:. .. code-block:: c++. auto LHS = std::make_unique<VariableExprAST>(""x"");; auto RHS = std::make_unique<VariableExprAST>(""y"");; auto Result = std::make_unique<BinaryExprAST>('+', std::move(LHS),; std::move(RHS));. In order to do this, we'll start by defining some basic helper routines:. .. code-block:: c++. /// CurTok/getNextToken - Provide a simple token buffer. CurTok is the current; /// token the parser is looking at. getNextToken reads another token from the; /// lexer and updates CurTok with its results.; static int CurTok;; static int getNextToken() {; return CurTok = gettok();; }. This implements a simple token buffer around the lexer. This allows us; to look one token ahead at what the lexer is returning. Every function; in our parser will assume that CurTok is the current token that needs to; be parsed. .. code-block:: c++. /// LogError* - These are little helper functions for error handling.; std::unique_ptr<ExprAST> LogError(const char *Str) {; fprintf(stderr, ""Error: %s\n"", Str);; return nullptr;; }; std::unique_ptr<PrototypeAST> LogErrorP(const char *Str) {; LogError(Str);; return nullptr;; }. The ``LogError`` routines are simple helper routines that our parser will; use to handle errors. The error recovery in our parser will not be the; best and is not particular user-friendly, but it will be enough fo",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl02.rst:5837,simpl,simple,5837,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl02.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl02.rst,1,['simpl'],['simple']
Usability,"operty, which specifies the; mapping information. The most common use of this parser is for parsing enum; values, which allows you to use the CommandLine library for all of the error; checking to make sure that only valid enum values are specified (as opposed to; accepting arbitrary strings). Despite this, however, the generic parser class; can be used for any data type. .. _boolean flags:; .. _bool parser:. * The **parser<bool> specialization** is used to convert boolean strings to a; boolean value. Currently accepted strings are ""``true``"", ""``TRUE``"",; ""``True``"", ""``1``"", ""``false``"", ""``FALSE``"", ""``False``"", and ""``0``"". * The **parser<boolOrDefault> specialization** is used for cases where the value; is boolean, but we also need to know whether the option was specified at all.; boolOrDefault is an enum with 3 values, BOU_UNSET, BOU_TRUE and BOU_FALSE.; This parser accepts the same strings as **``parser<bool>``**. .. _strings:. * The **parser<string> specialization** simply stores the parsed string into the; string value specified. No conversion or modification of the data is; performed. .. _integers:; .. _int:. * The **parser<int> specialization** uses the C ``strtol`` function to parse the; string input. As such, it will accept a decimal number (with an optional '+'; or '-' prefix) which must start with a non-zero digit. It accepts octal; numbers, which are identified with a '``0``' prefix digit, and hexadecimal; numbers with a prefix of '``0x``' or '``0X``'. .. _doubles:; .. _float:; .. _double:. * The **parser<double>** and **parser<float> specializations** use the standard; C ``strtod`` function to convert floating point strings into floating point; values. As such, a broad range of string formats is supported, including; exponential notation (ex: ``1.7e15``) and properly supports locales. .. _Extension Guide:; .. _extending the library:. Extension Guide; ===============. Although the CommandLine library has a lot of functionality built into it; already (",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandLine.rst:60501,simpl,simply,60501,interpreter/llvm-project/llvm/docs/CommandLine.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandLine.rst,1,['simpl'],['simply']
Usability,"optimization runs. For example, this is the before/after code; for our recursive fib function. Before the optimization:. .. code-block:: llvm. define double @fib(double %x) {; entry:; %x1 = alloca double; store double %x, double* %x1; %x2 = load double, double* %x1; %cmptmp = fcmp ult double %x2, 3.000000e+00; %booltmp = uitofp i1 %cmptmp to double; %ifcond = fcmp one double %booltmp, 0.000000e+00; br i1 %ifcond, label %then, label %else. then: ; preds = %entry; br label %ifcont. else: ; preds = %entry; %x3 = load double, double* %x1; %subtmp = fsub double %x3, 1.000000e+00; %calltmp = call double @fib(double %subtmp); %x4 = load double, double* %x1; %subtmp5 = fsub double %x4, 2.000000e+00; %calltmp6 = call double @fib(double %subtmp5); %addtmp = fadd double %calltmp, %calltmp6; br label %ifcont. ifcont: ; preds = %else, %then; %iftmp = phi double [ 1.000000e+00, %then ], [ %addtmp, %else ]; ret double %iftmp; }. Here there is only one variable (x, the input argument) but you can; still see the extremely simple-minded code generation strategy we are; using. In the entry block, an alloca is created, and the initial input; value is stored into it. Each reference to the variable does a reload; from the stack. Also, note that we didn't modify the if/then/else; expression, so it still inserts a PHI node. While we could make an; alloca for it, it is actually easier to create a PHI node for it, so we; still just make the PHI. Here is the code after the mem2reg pass runs:. .. code-block:: llvm. define double @fib(double %x) {; entry:; %cmptmp = fcmp ult double %x, 3.000000e+00; %booltmp = uitofp i1 %cmptmp to double; %ifcond = fcmp one double %booltmp, 0.000000e+00; br i1 %ifcond, label %then, label %else. then:; br label %ifcont. else:; %subtmp = fsub double %x, 1.000000e+00; %calltmp = call double @fib(double %subtmp); %subtmp5 = fsub double %x, 2.000000e+00; %calltmp6 = call double @fib(double %subtmp5); %addtmp = fadd double %calltmp, %calltmp6; br label %ifcont. ifcont",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl07.rst:17942,simpl,simple-minded,17942,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl07.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl07.rst,1,['simpl'],['simple-minded']
Usability,"or build systems that invokes the clang-scan-deps scanner per file, repeatedly; calculating the resource directory may be inefficient. In such cases, the build; system can cache the resource directory by itself and pass ``-resource-dir <resource-dir>``; explicitly in the command line options:. .. code-block:: console. $ clang-scan-deps -format=p1689 -- <path-to-compiler-executable>/clang++ -std=c++20 -resource-dir <resource-dir> mod.cppm -c -o mod.o. Possible Questions; ==================. How modules speed up compilation; --------------------------------. A classic theory for the reason why modules speed up the compilation is:; if there are ``n`` headers and ``m`` source files and each header is included by each source file,; then the complexity of the compilation is ``O(n*m)``;; But if there are ``n`` module interfaces and ``m`` source files, the complexity of the compilation is; ``O(n+m)``. So, using modules would be a big win when scaling.; In a simpler word, we could get rid of many redundant compilations by using modules. Roughly, this theory is correct. But the problem is that it is too rough.; The behavior depends on the optimization level, as we will illustrate below. First is ``O0``. The compilation process is described in the following graph. .. code-block:: none. ├-------------frontend----------┼-------------middle end----------------┼----backend----┤; │ │ │ │; └---parsing----sema----codegen--┴----- transformations ---- codegen ----┴---- codegen --┘. ┌---------------------------------------------------------------------------------------┐; | │; | source file │; | │; └---------------------------------------------------------------------------------------┘. ┌--------┐; │ │; │imported│; │ │; │ code │; │ │; └--------┘. Here we can see that the source file (could be a non-module unit or a module unit) would get processed by the; whole pipeline.; But the imported code would only get involved in semantic analysis, which is mainly about name lookup,; overload re",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst:40035,simpl,simpler,40035,interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst,1,['simpl'],['simpler']
Usability,"or each function:. .. code-block:: c++. KSDbgInfo.LexicalBlocks.push_back(SP);. Also, we may not forget to pop the scope back off of the scope stack at the; end of the code generation for the function:. .. code-block:: c++. // Pop off the lexical block for the function since we added it; // unconditionally.; KSDbgInfo.LexicalBlocks.pop_back();. Then we make sure to emit the location every time we start to generate code; for a new AST object:. .. code-block:: c++. KSDbgInfo.emitLocation(this);. Variables; =========. Now that we have functions, we need to be able to print out the variables; we have in scope. Let's get our function arguments set up so we can get; decent backtraces and see how our functions are being called. It isn't; a lot of code, and we generally handle it when we're creating the; argument allocas in ``FunctionAST::codegen``. .. code-block:: c++. // Record the function arguments in the NamedValues map.; NamedValues.clear();; unsigned ArgIdx = 0;; for (auto &Arg : TheFunction->args()) {; // Create an alloca for this variable.; AllocaInst *Alloca = CreateEntryBlockAlloca(TheFunction, Arg.getName());. // Create a debug descriptor for the variable.; DILocalVariable *D = DBuilder->createParameterVariable(; SP, Arg.getName(), ++ArgIdx, Unit, LineNo, KSDbgInfo.getDoubleTy(),; true);. DBuilder->insertDeclare(Alloca, D, DBuilder->createExpression(),; DILocation::get(SP->getContext(), LineNo, 0, SP),; Builder->GetInsertBlock());. // Store the initial value into the alloca.; Builder->CreateStore(&Arg, Alloca);. // Add arguments to variable symbol table.; NamedValues[std::string(Arg.getName())] = Alloca;; }. Here we're first creating the variable, giving it the scope (``SP``),; the name, source location, type, and since it's an argument, the argument; index. Next, we create an ``lvm.dbg.declare`` call to indicate at the IR; level that we've got a variable in an alloca (and it gives a starting; location for the variable), and setting a source location for the; beg",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl09.rst:13346,clear,clear,13346,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl09.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl09.rst,1,['clear'],['clear']
Usability,"or executions that enter the header. .. _loopinfo:. LoopInfo; ========. LoopInfo is the core analysis for obtaining information about loops.; There are few key implications of the definitions given above which; are important for working successfully with this interface. * LoopInfo does not contain information about non-loop cycles. As a; result, it is not suitable for any algorithm which requires complete; cycle detection for correctness. * LoopInfo provides an interface for enumerating all top level loops; (e.g. those not contained in any other loop). From there, you may; walk the tree of sub-loops rooted in that top level loop. * Loops which become statically unreachable during optimization *must*; be removed from LoopInfo. If this can not be done for some reason,; then the optimization is *required* to preserve the static; reachability of the loop. .. _loop-terminology-loop-simplify:. Loop Simplify Form; ==================. The Loop Simplify Form is a canonical form that makes; several analyses and transformations simpler and more effective.; It is ensured by the LoopSimplify; (:ref:`-loop-simplify <passes-loop-simplify>`) pass and is automatically; added by the pass managers when scheduling a LoopPass.; This pass is implemented in; `LoopSimplify.h <https://llvm.org/doxygen/LoopSimplify_8h_source.html>`_.; When it is successful, the loop has:. * A preheader.; * A single backedge (which implies that there is a single latch).; * Dedicated exits. That is, no exit block for the loop; has a predecessor that is outside the loop. This implies; that all exit blocks are dominated by the loop header. .. _loop-terminology-lcssa:. Loop Closed SSA (LCSSA); =======================. A program is in Loop Closed SSA Form if it is in SSA form; and all values that are defined in a loop are used only inside; this loop. Programs written in LLVM IR are always in SSA form but not necessarily; in LCSSA. To achieve the latter, for each value that is live across the; loop boundary, single",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LoopTerminology.rst:10071,simpl,simpler,10071,interpreter/llvm-project/llvm/docs/LoopTerminology.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LoopTerminology.rst,1,['simpl'],['simpler']
Usability,"or lanes:. * ``sN`` for scalars; * ``pN`` for pointers; * ``<N x sM>`` for vectors. ``LLT`` is intended to replace the usage of ``EVT`` in SelectionDAG. Here are some LLT examples and their ``EVT`` and ``Type`` equivalents:. ============= ========= ======================================; LLT EVT IR Type; ============= ========= ======================================; ``s1`` ``i1`` ``i1``; ``s8`` ``i8`` ``i8``; ``s32`` ``i32`` ``i32``; ``s32`` ``f32`` ``float``; ``s17`` ``i17`` ``i17``; ``s16`` N/A ``{i8, i8}`` [#abi-dependent]_; ``s32`` N/A ``[4 x i8]`` [#abi-dependent]_; ``p0`` ``iPTR`` ``i8*``, ``i32*``, ``%opaque*``; ``p2`` ``iPTR`` ``i8 addrspace(2)*``; ``<4 x s32>`` ``v4f32`` ``<4 x float>``; ``s64`` ``v1f64`` ``<1 x double>``; ``<3 x s32>`` ``v3i32`` ``<3 x i32>``; ============= ========= ======================================. Rationale: instructions already encode a specific interpretation of types; (e.g., ``add`` vs. ``fadd``, or ``sdiv`` vs. ``udiv``). Also encoding that; information in the type system requires introducing bitcast with no real; advantage for the selector. Pointer types are distinguished by address space. This matches IR, as opposed; to SelectionDAG where address space is an attribute on operations.; This representation better supports pointers having different sizes depending; on their addressspace. .. note::. .. caution::. Is this still true? I thought we'd removed the 1-element vector concept.; Hypothetically, it could be distinct from a scalar but I think we failed to; find a real occurrence. Currently, LLT requires at least 2 elements in vectors, but some targets have; the concept of a '1-element vector'. Representing them as their underlying; scalar type is a nice simplification. .. rubric:: Footnotes. .. [#abi-dependent] This mapping is ABI dependent. Here we've assumed no additional padding is required. Generic Opcode Reference; ------------------------. The Generic Opcodes that are available are described at :doc:`GenericOpcode`.; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GlobalISel/GMIR.rst:8900,simpl,simplification,8900,interpreter/llvm-project/llvm/docs/GlobalISel/GMIR.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GlobalISel/GMIR.rst,1,['simpl'],['simplification']
Usability,"ord definitions in; one place. A multiclass is a sort of macro that can be ""invoked"" to define; multiple concrete records all at once. A multiclass can inherit from other; multiclasses, which means that the multiclass inherits all the definitions; from its parent multiclasses. `Appendix C: Sample Record`_ illustrates a complex record in the Intel X86; target and the simple way in which it is defined. Source Files; ============. TableGen source files are plain ASCII text files. The files can contain; statements, comments, and blank lines (see `Lexical Analysis`_). The standard file; extension for TableGen files is ``.td``. TableGen files can grow quite large, so there is an include mechanism that; allows one file to include the content of another file (see `Include; Files`_). This allows large files to be broken up into smaller ones, and; also provides a simple library mechanism where multiple source files can; include the same library file. TableGen supports a simple preprocessor that can be used to conditionalize; portions of ``.td`` files. See `Preprocessing Facilities`_ for more; information. Lexical Analysis; ================. The lexical and syntax notation used here is intended to imitate; `Python's`_ notation. In particular, for lexical definitions, the productions; operate at the character level and there is no implied whitespace between; elements. The syntax definitions operate at the token level, so there is; implied whitespace between tokens. .. _`Python's`: http://docs.python.org/py3k/reference/introduction.html#notation. TableGen supports BCPL-style comments (``// ...``) and nestable C-style; comments (``/* ... */``).; TableGen also provides simple `Preprocessing Facilities`_. Formfeed characters may be used freely in files to produce page breaks when; the file is printed for review. The following are the basic punctuation tokens::. - + [ ] { } ( ) < > : ; . ... = ? #. Literals; --------. Numeric literals take one of the following forms:. .. productionl",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TableGen/ProgRef.rst:6264,simpl,simple,6264,interpreter/llvm-project/llvm/docs/TableGen/ProgRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TableGen/ProgRef.rst,1,['simpl'],['simple']
Usability,"ore detail: rf509_wsinteractive.C.; writeToFile -- A new utility method RooWorkspace::writeToFile() has been added; to simplify the process of saving a workspace to file; Named sets and parameter snapshots -- It is now possible to define and retrieve; named RooArgSets of objects that live in the workspace through methods; defineSet() and set(). While named sets merely group objects logically, methods loadSnapshot and; saveSnapshot allow to make copies of the values, errors and 'constant' status of; sets of variable objects that live in the workspace. A newly added tutorial macro rf510_namedsets.C illustrates the functionality of both; of these features.; Improved printing of contents -- Many operator p.d.f. and function components now show; a more intuitive natural representation of their contents (these changes are mostly in the; respective p.d.f.s, but are most relevant in the context of a workspace). New object factory interface to workspace to facilitate script driven model definition; A object factory has been added to RooFit to simplify the process of creating p.d.f.; and function expressions consisting of multiple objects. The factory has two goals:; the first is to provide a back-end for higher level factories and tools to process; the creation of objects. The second is to provide a simple end-user language to; populate a RooWorkspace with function and p.d.f. objects. For the latter purpose the object creation language is executed through the factory() method; of a workspace object. RooWorkspace w(""w"") ;; RooAbsArg* arg = w.factory(""expression_goes_here"") ;. Basic Syntax; The rules at its simplest level are as follows. Expressions with square brackets create variables (discrete and continuous). ""m[-10,10]"" - Creates a RooRealVar named 'm' with range [-10,10]; ""m[5,-10,10]"" - Idem, but with initial value 5; ""m[5]"" - Creates a constant RooRealVar with name 'm' and value 5. ""tagCat[Lep,Kao,NT1,NT2]"" -- Creates a RooCategory with name tagCat and labeled states Le",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v524/index.html:18194,simpl,simplify,18194,roofit/doc/v524/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v524/index.html,1,['simpl'],['simplify']
Usability,"ore information on `Xeus Cling's Read the Docs; <https://xeus-cling.readthedocs.io/en/latest/>`_ webpage. 2. **Interactive CUDA C++ with Cling:**. `CUDA <https://blogs.nvidia.com/blog/2012/09/10/what-is-cuda-2/>`_ is a platform; and Application Programming Interface (API) created by `NVIDIA; <https://www.nvidia.com/en-us/>`_. It controls `GPU; <https://en.wikipedia.org/wiki/Graphics_processing_unit>`_ (Graphical Processing; Unit) for parallel programming, enabling developers to harness the power of; graphic processing units (GPUs) to speed up applications. As an example,; `PIConGPU <https://github.com/ComputationalRadiationPhysics/picongpu>`_ is a; CUDA-based plasma physics application to solve the dynamics of a plasma by; computing the motion of electrons and ions in the plasma field. Interactive GPU; programming was made possible by extending Cling functionality to compile CUDA; C++ code. The new Cling-CUDA C++ can be used on Jupyter Notebook platform, and; enables big, interactive simulation with GPUs, easy GPU development and; debugging, and effective GPU programming learning. 3. **Clad:**. `Clad <https://compiler-research.org/clad/>`_ enables automatic differentiation; (AD) for C++. It was first developed as a plugin for Cling, and is now a plugin; for Clang compiler. Clad is based on source code transformation. Given C++; source code of a mathematical function, it can automatically generate C++ code; for computing derivatives of the function. It supports both forward-mode and; reverse-mode AD. 4. **Cling for live coding music and musical instruments:**. The artistic live coding community has been growing steadily since around the; year 2000. The Temporary Organisation for the Permanence of Live Art Programming; (TOPLAP) has been around since 2004, Algorave (algorithmic rave parties); recently celebrated its tenth birthday, and six editions of the International; Conference on Live Coding (ICLC) have been held. A great many live coding; systems have been develop",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/docs/chapters/applications.rst:1896,learn,learning,1896,interpreter/cling/docs/chapters/applications.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/docs/chapters/applications.rst,1,['learn'],['learning']
Usability,"ore likely a large project will have a pre-existing functional; decomposition that can be followed, with a dictionary per functional unit. Generation; ^^^^^^^^^^. There are two interfaces onto the same underlying dictionary generator:; ``rootcling`` and ``genreflex``.; The reason for having two is historic and they are not complete duplicates,; so one or the other may suit your preference better.; It is foreseen that both will be replaced once C++ modules become more; mainstream, as that will allow simplification and improved robustness. rootcling; """""""""""""""""". The first interface is called ``rootcling``::. $ rootcling; Usage: rootcling [-v][-v0-4] [-f] [out.cxx] [opts] file1.h[+][-][!] file2.h[+][-][!] ...[Linkdef.h]; For more extensive help type: /usr/local/lib/python2.7/dist-packages/cppyy_backend/bin/rootcling -h. Rather than providing command line options, the main steering of; ``rootcling`` behavior is done through; `#pragmas in a Linkdef.h <https://root.cern.ch/root/html/guides/users-guide/AddingaClass.html#the-linkdef.h-file>`_; file, with most pragmas dedicated to selecting/excluding (parts of) classes; and functions.; Additionally, the Linkdef.h file may contain preprocessor macros. The output consists of a dictionary file (to be compiled into a shared; library), a C++ module, and an optional mapping file, as described above. genreflex; """""""""""""""""". The second interface is called ``genreflex``::. $ genreflex; Generates dictionary sources and related ROOT pcm starting from an header.; Usage: genreflex headerfile.h [opts] [preproc. opts]; ... ``genreflex`` has a richer command line interface than ``rootcling`` as can; be seen from the full help message. .. _selection-files:. Selection/exclusion is driven through a `selection file`_ using an XML format; that allows both exact and pattern matching to namespace, class, enum,; function, and variable names. .. _`selection file`: https://linux.die.net/man/1/genreflex. Example; """""""""""""". Consider the following basic exam",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/utilities.rst:4247,guid,guides,4247,bindings/pyroot/cppyy/cppyy/doc/source/utilities.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/utilities.rst,2,['guid'],"['guide', 'guides']"
Usability,"ore the; function and do not draw it. ### Advances Options. The advance option button is enabled only after having performed the fit and provides; additional drawing options that can be used after having done the fit. These new drawing tools,; which can be selected by the ""Advanced Drawing Tool"" panel that pops up when clicking the ""Advanced"" button, are:. * *Contour*: to plot the confidence contour of two chosen parameters. One can select the number of points to draw the contour; (more points might require more time to compute it), the parameters and the desired confidence level . * *Scan* : to plot a scan of the minimization function (likelihood or chi-squared) around the minimum as function of the chosen parameter. * *Conf Interval* : to plot the confidence interval of the fitted function as a filled coloured band around its central value.; One can select the desired confidence level for the band to be plotted. ### Print Options. This set of options specifies the amount of feedback printed on the; root command line after performed fits. *‘Verbose'* - prints fit results after each iteration. *‘Quiet'* - no fit information is printed. *‘Default'* - between Verbose and Quiet. ### Command Buttons. *Fit button* - performs a fit taking different option settings via the; Fit Panel interface. *Reset* - sets the GUI elements and related fit settings to the; default ones. *Close* - closes the Fit panel window. ### Minimization Options. With this tab one can select specific options for minimization. These include. * The minimizer library ( *Minuit*, *Minuit2*, *Fumili*, *GSL*, *Genetics* ); * The method (algorithm) for minimization. For example for Minuit one can choose between (*Migrad*, *Simplex* or *Scan*); * Error definition; * Minimization tolerance; * Number of iterations/function calls; * Print Level: (*Default*, *Verbose* or *Quiet*). ## New ROOT::Fit classes. The fitting of the data objects in ROOT, histograms, graphs and tree is performed via some common classes,; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:25427,feedback,feedback,25427,documentation/users-guide/FittingHistograms.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md,1,['feedback'],['feedback']
Usability,"ore you use it. For; example, the C function:. .. code-block:: c. int X() { int i; return i; }. Is compiled to ""``ret i32 undef``"" because ""``i``"" never has a value specified; for it. Why does instcombine + simplifycfg turn a call to a function with a mismatched calling convention into ""unreachable""? Why not make the verifier reject it?; ----------------------------------------------------------------------------------------------------------------------------------------------------------; This is a common problem run into by authors of front-ends that are using; custom calling conventions: you need to make sure to set the right calling; convention on both the function and on each call to the function. For; example, this code:. .. code-block:: llvm. define fastcc void @foo() {; ret void; }; define void @bar() {; call void @foo(); ret void; }. Is optimized to:. .. code-block:: llvm. define fastcc void @foo() {; ret void; }; define void @bar() {; unreachable; }. ... with ""``opt -instcombine -simplifycfg``"". This often bites people because; ""all their code disappears"". Setting the calling convention on the caller and; callee is required for indirect calls to work, so people often ask why not; make the verifier reject this sort of thing. The answer is that this code has undefined behavior, but it is not illegal.; If we made it illegal, then every transformation that could potentially create; this would have to ensure that it doesn't, and there is valid code that can; create this sort of construct (in dead code). The sorts of things that can; cause this to happen are fairly contrived, but we still need to accept them.; Here's an example:. .. code-block:: llvm. define fastcc void @foo() {; ret void; }; define internal void @bar(void()* %FP, i1 %cond) {; br i1 %cond, label %T, label %F; T:; call void %FP(); ret void; F:; call fastcc void %FP(); ret void; }; define void @test() {; %X = or i1 false, false; call void @bar(void()* @foo, i1 %X); ret void; }. In this example, """,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/FAQ.rst:9845,simpl,simplifycfg,9845,interpreter/llvm-project/llvm/docs/FAQ.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/FAQ.rst,1,['simpl'],['simplifycfg']
Usability,"ore; information about what your pass does, and how it can be combined with other; passes. One of the main features of the LLVM Pass Framework is that it; schedules passes to run in an efficient way based on the constraints that your; pass meets (which are indicated by which class they derive from). We start by showing you how to construct a pass, everything from setting up the; code, to compiling, loading, and executing it. After the basics are down, more; advanced features are discussed. .. warning::; This document deals with the legacy pass manager. LLVM uses the new pass; manager for the optimization pipeline (the codegen pipeline; still uses the legacy pass manager), which has its own way of defining; passes. For more details, see :doc:`WritingAnLLVMNewPMPass` and; :doc:`NewPassManager`. Quick Start --- Writing hello world; ===================================. Here we describe how to write the ""hello world"" of passes. The ""Hello"" pass is; designed to simply print out the name of non-external functions that exist in; the program being compiled. It does not modify the program at all, it just; inspects it. The source code and files for this pass are available in the LLVM; source tree in the ``lib/Transforms/Hello`` directory. .. _writing-an-llvm-pass-makefile:. Setting up the build environment; --------------------------------. First, configure and build LLVM. Next, you need to create a new directory; somewhere in the LLVM source base. For this example, we'll assume that you; made ``lib/Transforms/Hello``. Finally, you must set up a build script; that will compile the source code for the new pass. To do this,; copy the following into ``CMakeLists.txt``:. .. code-block:: cmake. add_llvm_library( LLVMHello MODULE; Hello.cpp. PLUGIN_TOOL; opt; ). and the following line into ``lib/Transforms/CMakeLists.txt``:. .. code-block:: cmake. add_subdirectory(Hello). (Note that there is already a directory named ``Hello`` with a sample ""Hello""; pass; you may play with it -- in ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/WritingAnLLVMPass.rst:2093,simpl,simply,2093,interpreter/llvm-project/llvm/docs/WritingAnLLVMPass.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/WritingAnLLVMPass.rst,1,['simpl'],['simply']
Usability,"orial. In chapters 1 through 8, we've built a; decent little programming language with functions and variables.; What happens if something goes wrong though, how do you debug your; program?. Source level debugging uses formatted data that helps a debugger; translate from binary and the state of the machine back to the; source that the programmer wrote. In LLVM we generally use a format; called `DWARF <http://dwarfstd.org>`_. DWARF is a compact encoding; that represents types, source locations, and variable locations. The short summary of this chapter is that we'll go through the; various things you have to add to a programming language to; support debug info, and how you translate that into DWARF. Caveat: For now we can't debug via the JIT, so we'll need to compile; our program down to something small and standalone. As part of this; we'll make a few modifications to the running of the language and; how programs are compiled. This means that we'll have a source file; with a simple program written in Kaleidoscope rather than the; interactive JIT. It does involve a limitation that we can only; have one ""top level"" command at a time to reduce the number of; changes necessary. Here's the sample program we'll be compiling:. .. code-block:: python. def fib(x); if x < 3 then; 1; else; fib(x-1)+fib(x-2);. fib(10). Why is this a hard problem?; ===========================. Debug information is a hard problem for a few different reasons - mostly; centered around optimized code. First, optimization makes keeping source; locations more difficult. In LLVM IR we keep the original source location; for each IR level instruction on the instruction. Optimization passes; should keep the source locations for newly created instructions, but merged; instructions only get to keep a single location - this can cause jumping; around when stepping through optimized programs. Secondly, optimization; can move variables in ways that are either optimized out, shared in memory; with other variables",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl09.rst:1265,simpl,simple,1265,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl09.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl09.rst,1,['simpl'],['simple']
Usability,"orial_ProofEvent ProofEvent; \ingroup tutorial_proof; \brief Selector for generic processing with Event. Example of TSelector implementation to do generic; processing with the test 'Event' structure.; See tutorials/proof/runProof.C, option ""event"", for an; example of how to run this selector. \defgroup tutorial_ProofEventProc ProofEventProc; \ingroup tutorial_proof; \brief Selector to process trees containing Event structures. Example of TSelector implementation to process trees; containing 'Event' structures, e.g. the files under; http://root.cern/files/data .; See tutorials/proof/runProof.C, option ""eventproc"", for; an example of how to run this selector. \defgroup tutorial_ProofFriends ProofFriends; \ingroup tutorial_proof; \brief Selector to process tree friends. Example of TSelector implementation to process tree friends in PROOF.; See tutorials/proof/runProof.C, option ""eventproc"", for; an example of how to run this selector. \defgroup tutorial_ProofNtuple ProofNtuple; \ingroup tutorial_proof; \brief Selector to fill a simple ntuple. Example of TSelector implementation to do generic processing; (filling a simple ntuple, in this case).; See tutorials/proof/runProof.C, option ""ntuple"", for an; example of how to run this selector. \defgroup tutorial_ProofPythia ProofPythia; \ingroup tutorial_proof; \brief Selector to generate Monte Carlo events with Pythia8. Example of TSelector implementation to do a Monte Carlo; generation using Pythia8.; See tutorials/proof/runProof.C, option ""pythia8"", for an; example of how to run this selector. \defgroup tutorial_ProofSimple ProofSimple; \ingroup tutorial_proof; \brief Selector to fill a set of histograms. Example of TSelector implementation to do generic processing (filling a; set of histograms in this case).; See tutorials/proof/runProof.C, option ""simple"", for an; example of how to run this selector. \defgroup tutorial_ProofSimpleFile ProofSimpleFile; \ingroup tutorial_proof; \brief Selector to fill a set of histograms a",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tutorials/proof/index.md:1354,simpl,simple,1354,tutorials/proof/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tutorials/proof/index.md,1,['simpl'],['simple']
Usability,"orithm. This pass guarantees that the following canonicalizations are performed on the; program:. #. If a binary operator has a constant operand, it is moved to the right-hand; side.; #. Bitwise operators with constant operands are always grouped so that shifts; are performed first, then ``or``\ s, then ``and``\ s, then ``xor``\ s.; #. Compare instructions are converted from ``<``, ``>``, ``≤``, or ``≥`` to; ``=`` or ``≠`` if possible.; #. All ``cmp`` instructions on boolean values are replaced with logical; operations.; #. ``add X, X`` is represented as ``mul X, 2`` ⇒ ``shl X, 1``; #. Multiplies with a constant power-of-two argument are transformed into; shifts.; #. … etc. This pass can also simplify calls to specific well-known function calls (e.g.; runtime library functions). For example, a call ``exit(3)`` that occurs within; the ``main()`` function can be transformed into simply ``return 3``. Whether or; not library calls are simplified is controlled by the; :ref:`-function-attrs <passes-function-attrs>` pass and LLVM's knowledge of; library calls on different targets. .. _passes-aggressive-instcombine:. ``aggressive-instcombine``: Combine expression patterns; --------------------------------------------------------. Combine expression patterns to form expressions with fewer, simple instructions. For example, this pass reduce width of expressions post-dominated by TruncInst; into smaller width when applicable. It differs from instcombine pass in that it can modify CFG and contains pattern; optimization that requires higher complexity than the O(1), thus, it should run fewer; times than instcombine pass. ``internalize``: Internalize Global Symbols; -------------------------------------------. This pass loops over all of the functions in the input module, looking for a; main function. If a main function is found, all other functions and all global; variables with initializers are marked as internal. ``ipsccp``: Interprocedural Sparse Conditional Constant Propagat",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Passes.rst:20661,simpl,simplified,20661,interpreter/llvm-project/llvm/docs/Passes.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Passes.rst,1,['simpl'],['simplified']
Usability,"ork we built for other operators. Adding unary; operators is a bit more challenging, because we don't have any framework; for it yet - let's see what it takes. User-defined Unary Operators; ============================. Since we don't currently support unary operators in the Kaleidoscope; language, we'll need to add everything to support them. Above, we added; simple support for the 'unary' keyword to the lexer. In addition to; that, we need an AST node:. .. code-block:: c++. /// UnaryExprAST - Expression class for a unary operator.; class UnaryExprAST : public ExprAST {; char Opcode;; std::unique_ptr<ExprAST> Operand;. public:; UnaryExprAST(char Opcode, std::unique_ptr<ExprAST> Operand); : Opcode(Opcode), Operand(std::move(Operand)) {}. Value *codegen() override;; };. This AST node is very simple and obvious by now. It directly mirrors the; binary operator AST node, except that it only has one child. With this,; we need to add the parsing logic. Parsing a unary operator is pretty; simple: we'll add a new function to do it:. .. code-block:: c++. /// unary; /// ::= primary; /// ::= '!' unary; static std::unique_ptr<ExprAST> ParseUnary() {; // If the current token is not an operator, it must be a primary expr.; if (!isascii(CurTok) || CurTok == '(' || CurTok == ','); return ParsePrimary();. // If this is a unary operator, read it.; int Opc = CurTok;; getNextToken();; if (auto Operand = ParseUnary()); return std::make_unique<UnaryExprAST>(Opc, std::move(Operand));; return nullptr;; }. The grammar we add is pretty straightforward here. If we see a unary; operator when parsing a primary operator, we eat the operator as a; prefix and parse the remaining piece as another unary operator. This; allows us to handle multiple unary operators (e.g. ""!!x""). Note that; unary operators can't have ambiguous parses like binary operators can,; so there is no need for precedence information. The problem with this function, is that we need to call ParseUnary from; somewhere. To do this,",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl06.rst:11159,simpl,simple,11159,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl06.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl06.rst,1,['simpl'],['simple']
Usability,"orking on a fully-general operator precedence parser, this is all; we need to do to ""extend the grammar"". Now we have useful user-defined binary operators. This builds a lot on; the previous framework we built for other operators. Adding unary; operators is a bit more challenging, because we don't have any framework; for it yet - let's see what it takes. User-defined Unary Operators; ============================. Since we don't currently support unary operators in the Kaleidoscope; language, we'll need to add everything to support them. Above, we added; simple support for the 'unary' keyword to the lexer. In addition to; that, we need an AST node:. .. code-block:: c++. /// UnaryExprAST - Expression class for a unary operator.; class UnaryExprAST : public ExprAST {; char Opcode;; std::unique_ptr<ExprAST> Operand;. public:; UnaryExprAST(char Opcode, std::unique_ptr<ExprAST> Operand); : Opcode(Opcode), Operand(std::move(Operand)) {}. Value *codegen() override;; };. This AST node is very simple and obvious by now. It directly mirrors the; binary operator AST node, except that it only has one child. With this,; we need to add the parsing logic. Parsing a unary operator is pretty; simple: we'll add a new function to do it:. .. code-block:: c++. /// unary; /// ::= primary; /// ::= '!' unary; static std::unique_ptr<ExprAST> ParseUnary() {; // If the current token is not an operator, it must be a primary expr.; if (!isascii(CurTok) || CurTok == '(' || CurTok == ','); return ParsePrimary();. // If this is a unary operator, read it.; int Opc = CurTok;; getNextToken();; if (auto Operand = ParseUnary()); return std::make_unique<UnaryExprAST>(Opc, std::move(Operand));; return nullptr;; }. The grammar we add is pretty straightforward here. If we see a unary; operator when parsing a primary operator, we eat the operator as a; prefix and parse the remaining piece as another unary operator. This; allows us to handle multiple unary operators (e.g. ""!!x""). Note that; unary operators can",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl06.rst:10964,simpl,simple,10964,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl06.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl06.rst,1,['simpl'],['simple']
Usability,"ormationalMessage(...);; ... ... which is a real pain! Instead of defining two values for the same; condition, we can use the ""`cl::alias`_"" class to make the ""``-q``"" option an; **alias** for the ""``-quiet``"" option, instead of providing a value itself:. .. code-block:: c++. cl::opt<bool> Force (""f"", cl::desc(""Overwrite output files""));; cl::opt<bool> Quiet (""quiet"", cl::desc(""Don't print informational messages""));; cl::alias QuietA(""q"", cl::desc(""Alias for -quiet""), cl::aliasopt(Quiet));. The third line (which is the only one we modified from above) defines a ""``-q``""; alias that updates the ""``Quiet``"" variable (as specified by the `cl::aliasopt`_; modifier) whenever it is specified. Because aliases do not hold state, the only; thing the program has to query is the ``Quiet`` variable now. Another nice; feature of aliases is that they automatically hide themselves from the ``-help``; output (although, again, they are still visible in the ``-help-hidden output``). Now the application code can simply use:. .. code-block:: c++. ...; if (!Quiet) printInformationalMessage(...);; ... ... which is much nicer! The ""`cl::alias`_"" can be used to specify an; alternative name for any variable type, and has many uses. .. _unnamed alternatives using the generic parser:. Selecting an alternative from a set of possibilities; ----------------------------------------------------. So far we have seen how the CommandLine library handles builtin types like; ``std::string``, ``bool`` and ``int``, but how does it handle things it doesn't; know about, like enums or '``int*``'s?. The answer is that it uses a table-driven generic parser (unless you specify; your own parser, as described in the `Extension Guide`_). This parser maps; literal strings to whatever type is required, and requires you to tell it what; this mapping should be. Let's say that we would like to add four optimization levels to our optimizer,; using the standard flags ""``-g``"", ""``-O0``"", ""``-O1``"", and ""``-O2``"". We; co",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandLine.rst:12973,simpl,simply,12973,interpreter/llvm-project/llvm/docs/CommandLine.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandLine.rst,1,['simpl'],['simply']
Usability,"oroutine from the corresponding suspend point should be done at the point; of `coro.save` intrinsic. Example:; """""""""""""""". Separate save and suspend points are necessary when a coroutine is used to; represent an asynchronous control flow driven by callbacks representing; completions of asynchronous operations. In such a case, a coroutine should be ready for resumption prior to a call to; `async_op` function that may trigger resumption of a coroutine from the same or; a different thread possibly prior to `async_op` call returning control back; to the coroutine:. .. code-block:: llvm. %save1 = call token @llvm.coro.save(ptr %hdl); call void @async_op1(ptr %hdl); %suspend1 = call i1 @llvm.coro.suspend(token %save1, i1 false); switch i8 %suspend1, label %suspend [i8 0, label %resume1; i8 1, label %cleanup]. .. _coro.suspend.async:. 'llvm.coro.suspend.async' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^; ::. declare {ptr, ptr, ptr} @llvm.coro.suspend.async(; ptr <resume function>,; ptr <context projection function>,; ... <function to call>; ... <arguments to function>). Overview:; """""""""""""""""". The '``llvm.coro.suspend.async``' intrinsic marks the point where; execution of an async coroutine is suspended and control is passed to a callee. Arguments:; """""""""""""""""""". The first argument should be the result of the `llvm.coro.async.resume` intrinsic.; Lowering will replace this intrinsic with the resume function for this suspend; point. The second argument is the `context projection function`. It should describe; how-to restore the `async context` in the continuation function from the first; argument of the continuation function. Its type is `ptr (ptr)`. The third argument is the function that models transfer to the callee at the; suspend point. It should take 3 arguments. Lowering will `musttail` call this; function. The fourth to six argument are the arguments for the third argument. Semantics:; """""""""""""""""""". The result of the intrinsic are mapped to the arguments of the resu",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst:53353,resume,resume,53353,interpreter/llvm-project/llvm/docs/Coroutines.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst,1,['resume'],['resume']
Usability,"orpus.; ./a.out. You should get an error pretty quickly::. INFO: Seed: 1523017872; INFO: Loaded 1 modules (16 guards): [0x744e60, 0x744ea0),; INFO: -max_len is not provided, using 64; INFO: A corpus is not provided, starting from an empty corpus; #0	READ units: 1; #1	INITED cov: 3 ft: 2 corp: 1/1b exec/s: 0 rss: 24Mb; #3811	NEW cov: 4 ft: 3 corp: 2/2b exec/s: 0 rss: 25Mb L: 1 MS: 5 ChangeBit-ChangeByte-ChangeBit-ShuffleBytes-ChangeByte-; #3827	NEW cov: 5 ft: 4 corp: 3/4b exec/s: 0 rss: 25Mb L: 2 MS: 1 CopyPart-; #3963	NEW cov: 6 ft: 5 corp: 4/6b exec/s: 0 rss: 25Mb L: 2 MS: 2 ShuffleBytes-ChangeBit-; #4167	NEW cov: 7 ft: 6 corp: 5/9b exec/s: 0 rss: 25Mb L: 3 MS: 1 InsertByte-; ==31511== ERROR: libFuzzer: deadly signal; ...; artifact_prefix='./'; Test unit written to ./crash-b13e8756b13a00cf168300179061fb4b91fefbed. More examples; -------------. Examples of real-life fuzz targets and the bugs they find can be found; at http://tutorial.libfuzzer.info. Among other things you can learn how; to detect Heartbleed_ in one second. Advanced features; =================; .. contents::; :local:; :depth: 1. Dictionaries; ------------; LibFuzzer supports user-supplied dictionaries with input language keywords; or other interesting byte sequences (e.g. multi-byte magic values).; Use ``-dict=DICTIONARY_FILE``. For some input languages using a dictionary; may significantly improve the search speed.; The dictionary syntax is similar to that used by AFL_ for its ``-x`` option::. # Lines starting with '#' and empty lines are ignored. # Adds ""blah"" (w/o quotes) to the dictionary.; kw1=""blah""; # Use \\ for backslash and \"" for quotes.; kw2=""\""ac\\dc\""""; # Use \xAB for hex values; kw3=""\xF7\xF8""; # the name of the keyword followed by '=' may be omitted:; ""foo\x0Abar"". Tracing CMP instructions; ------------------------. With an additional compiler flag ``-fsanitize-coverage=trace-cmp``; (on by default as part of ``-fsanitize=fuzzer``, see SanitizerCoverageTraceDataFlow_); libFuzzer will int",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LibFuzzer.rst:19177,learn,learn,19177,interpreter/llvm-project/llvm/docs/LibFuzzer.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LibFuzzer.rst,1,['learn'],['learn']
Usability,"ory contains a large array of small tests that exercise; various features of LLVM and to ensure that regressions do not occur.; The directory is broken into several sub-directories, each focused on a; particular area of LLVM. Writing new regression tests; ----------------------------. The regression test structure is very simple, but does require some; information to be set. This information is gathered via ``cmake``; and is written to a file, ``test/lit.site.cfg.py`` in the build directory.; The ``llvm/test`` Makefile does this work for you. In order for the regression tests to work, each directory of tests must; have a ``lit.local.cfg`` file. :program:`lit` looks for this file to determine; how to run the tests. This file is just Python code and thus is very; flexible, but we've standardized it for the LLVM regression tests. If; you're adding a directory of tests, just copy ``lit.local.cfg`` from; another directory to get running. The standard ``lit.local.cfg`` simply; specifies which files to look in for tests. Any directory that contains; only directories does not need the ``lit.local.cfg`` file. Read the :doc:`Lit; documentation <CommandGuide/lit>` for more information. Each test file must contain lines starting with ""RUN:"" that tell :program:`lit`; how to run it. If there are no RUN lines, :program:`lit` will issue an error; while running a test. RUN lines are specified in the comments of the test program using the; keyword ``RUN`` followed by a colon, and lastly the command (pipeline); to execute. Together, these lines form the ""script"" that :program:`lit`; executes to run the test case. The syntax of the RUN lines is similar to a; shell's syntax for pipelines including I/O redirection and variable; substitution. However, even though these lines may *look* like a shell; script, they are not. RUN lines are interpreted by :program:`lit`.; Consequently, the syntax differs from shell in a few ways. You can specify; as many RUN lines as needed. :program:`lit` perfo",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TestingGuide.rst:8051,simpl,simply,8051,interpreter/llvm-project/llvm/docs/TestingGuide.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TestingGuide.rst,1,['simpl'],['simply']
Usability,"ossible from the coroutine address,; printing the details of the coroutine frame from an address is also possible:. ::. (gdb) # Get the address of coroutine frame; (gdb) print/x *0x418eb0; $1 = 0x4019e0; (gdb) # Get the linkage name for the coroutine; (gdb) x 0x4019e0; 0x4019e0 <_ZL9coro_taski>: 0xe5894855; (gdb) # Turn off the demangler temporarily to avoid the debugger misunderstanding the name.; (gdb) set demangle-style none; (gdb) # The coroutine frame type is 'linkage_name.coro_frame_ty'; (gdb) print ('_ZL9coro_taski.coro_frame_ty')*(0x418eb0); $2 = {__resume_fn = 0x4019e0 <coro_task(int)>, __destroy_fn = 0x402000 <coro_task(int)>, __promise = {...}, ...}. The above is possible because:. (1) The name of the debug type of the coroutine frame is the `linkage_name`,; plus the `.coro_frame_ty` suffix because each coroutine function shares the; same coroutine type. (2) The coroutine function name is accessible from the address of the coroutine; frame. The above commands can be simplified by placing them in debug scripts. Examples to print coroutine frames; ----------------------------------. The print examples below use the following definition:. .. code-block:: c++. #include <coroutine>; #include <iostream>. struct task{; struct promise_type {; task get_return_object() { return std::coroutine_handle<promise_type>::from_promise(*this); }; std::suspend_always initial_suspend() { return {}; }; std::suspend_always final_suspend() noexcept { return {}; }; void return_void() noexcept {}; void unhandled_exception() noexcept {}. int count = 0;; };. void resume() noexcept {; handle.resume();; }. task(std::coroutine_handle<promise_type> hdl) : handle(hdl) {}; ~task() {; if (handle); handle.destroy();; }. std::coroutine_handle<> handle;; };. class await_counter : public std::suspend_always {; public:; template<class PromiseType>; void await_suspend(std::coroutine_handle<PromiseType> handle) noexcept {; handle.promise().count++;; }; };. static task coro_task(int v) {; int a = v",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DebuggingCoroutines.rst:5869,simpl,simplified,5869,interpreter/llvm-project/clang/docs/DebuggingCoroutines.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DebuggingCoroutines.rst,1,['simpl'],['simplified']
Usability,"ot support; anywhere near all the options that gcc does, and we want to make sure; users know which ones are being used. To support this, the driver maintains a bit associated with each; argument of whether it has been used (at all) during the compilation.; This bit usually doesn't need to be set by hand, as the key ArgList; accessors will set it automatically. When a compilation is successful (there are no errors), the driver; checks the bit and emits an ""unused argument"" warning for any arguments; which were never accessed. This is conservative (the argument may not; have been used to do what the user wanted) but still catches the most; obvious cases. Relation to GCC Driver Concepts; -------------------------------. For those familiar with the gcc driver, this section provides a brief; overview of how things from the gcc driver map to the clang driver. - **Driver Driver**. The driver driver is fully integrated into the clang driver. The; driver simply constructs additional Actions to bind the architecture; during the *Pipeline* phase. The tool chain specific argument; translation is responsible for handling ``-Xarch_``. The one caveat is that this approach requires ``-Xarch_`` not be used; to alter the compilation itself (for example, one cannot provide; ``-S`` as an ``-Xarch_`` argument). The driver attempts to reject; such invocations, and overall there isn't a good reason to abuse; ``-Xarch_`` to that end in practice. The upside is that the clang driver is more efficient and does little; extra work to support universal builds. It also provides better error; reporting and UI consistency. - **Specs**. The clang driver has no direct correspondent for ""specs"". The; majority of the functionality that is embedded in specs is in the; Tool specific argument translation routines. The parts of specs which; control the compilation pipeline are generally part of the *Pipeline*; stage. - **Toolchains**. The gcc driver has no direct understanding of tool chains. Each gcc; bi",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DriverInternals.rst:15339,simpl,simply,15339,interpreter/llvm-project/clang/docs/DriverInternals.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DriverInternals.rst,1,['simpl'],['simply']
Usability,"ot,; consider a :ref:`SmallVector <dss_smallvector>`). The cost of a heap allocated; array is the cost of the new/delete (aka malloc/free). Also note that if you; are allocating an array of a type with a constructor, the constructor and; destructors will be run for every element in the array (re-sizable vectors only; construct those elements actually used). .. _dss_tinyptrvector:. llvm/ADT/TinyPtrVector.h; ^^^^^^^^^^^^^^^^^^^^^^^^. ``TinyPtrVector<Type>`` is a highly specialized collection class that is; optimized to avoid allocation in the case when a vector has zero or one; elements. It has two major restrictions: 1) it can only hold values of pointer; type, and 2) it cannot hold a null pointer. Since this container is highly specialized, it is rarely used. .. _dss_smallvector:. llvm/ADT/SmallVector.h; ^^^^^^^^^^^^^^^^^^^^^^. ``SmallVector<Type, N>`` is a simple class that looks and smells just like; ``vector<Type>``: it supports efficient iteration, lays out elements in memory; order (so you can do pointer arithmetic between elements), supports efficient; push_back/pop_back operations, supports efficient random access to its elements,; etc. The main advantage of SmallVector is that it allocates space for some number of; elements (N) **in the object itself**. Because of this, if the SmallVector is; dynamically smaller than N, no malloc is performed. This can be a big win in; cases where the malloc/free call is far more expensive than the code that; fiddles around with the elements. This is good for vectors that are ""usually small"" (e.g. the number of; predecessors/successors of a block is usually less than 8). On the other hand,; this makes the size of the SmallVector itself large, so you don't want to; allocate lots of them (doing so will waste a lot of space). As such,; SmallVectors are most useful when on the stack. In the absence of a well-motivated choice for the number of; inlined elements ``N``, it is recommended to use ``SmallVector<T>`` (that is,; omittin",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:59450,simpl,simple,59450,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,1,['simpl'],['simple']
Usability,"ot[] myCanvas->cd(1); ```. We then draw the variable `Cost`:. ``` {.cpp}; root[] MyTree->Draw(""C; ```. As you can see, the last call `TTree::Draw` has only one parameter. It; is a string containing the leaf name. A histogram is automatically; created as a result of a `TTree::Draw`. The style of the histogram is; inherited from the **`TTree`** attributes and the current style; (***`gStyle`***) is ignored. The **`TTree`** gets its attributes from; the current **`TStyle`** at the time it was created. You can call the; method `TTree::UseCurrentStyle` to change to the current style rather; than the **`TTree`** style. (See ***`gStyle`***; see also ""Graphics and; the Graphical User Interface"" ). In the next segment, we activate the second pad and draw a scatter plot; variables:. ``` {.cpp}; root[] myCanvas->cd(2); root[] MyTree->Draw(""Cost:Age""); ```. This signature still only has one parameter, but it now has two; dimensions separated by a colon `(""x:y"")`. The item to be plotted can be; an expression not just a simple variable. In general, this parameter is; a string that contains up to three expressions, one for each dimension,; separated by a colon (""`e1:e2:e3`""). A list of examples follows this; introduction. ### Using Selection with TTree:Draw. Change the active pad to 3, and add a selection to the list of; parameters of the draw command. ``` {.cpp}; root[] myCanvas->cd(3); root[] MyTree->Draw(""Cost:Age"",""Nation == ""FR""""); ```. This will draw the `Cost `vs. `Age` for the entries where the nation is; equal to ""`FR`"". You can use any C++ operator, and some functions; defined in **`TFormula`**, in the selection parameter. The value of the; selection is used as a weight when filling the histogram. If the; expression includes only Boolean operations as in the example above, the; result is 0 or 1. If the result is 0, the histogram is not filled. In; general, the expression is:. ``` {.cpp}; Selection = ""weight *(boolean expression)""; ```. If the Boolean expression evaluates t",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:70843,simpl,simple,70843,documentation/users-guide/Trees.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md,1,['simpl'],['simple']
Usability,"otect your rights, we need to make restrictions that forbid; distributors to deny you these rights or to ask you to surrender these; rights. These restrictions translate to certain responsibilities for; you if you distribute copies of the library or if you modify it. For example, if you distribute copies of the library, whether gratis; or for a fee, you must give the recipients all the rights that we gave; you. You must make sure that they, too, receive or can get the source; code. If you link other code with the library, you must provide; complete object files to the recipients, so that they can relink them; with the library after making changes to the library and recompiling; it. And you must show them these terms so they know their rights. We protect your rights with a two-step method: (1) we copyright the; library, and (2) we offer you this license, which gives you legal; permission to copy, distribute and/or modify the library. To protect each distributor, we want to make it very clear that; there is no warranty for the free library. Also, if the library is; modified by someone else and passed on, the recipients should know; that what they have is not the original version, so that the original; author's reputation will not be affected by problems that might be; introduced by others. Finally, software patents pose a constant threat to the existence of; any free program. We wish to make sure that a company cannot; effectively restrict the users of a free program by obtaining a; restrictive license from a patent holder. Therefore, we insist that; any patent license obtained for a version of the library must be; consistent with the full freedom of use specified in this license. Most GNU software, including some libraries, is covered by the; ordinary GNU General Public License. This license, the GNU Lesser; General Public License, applies to certain designated libraries, and; is quite different from the ordinary General Public License. We use; this license for certa",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/LICENSE.TXT:4889,clear,clear,4889,interpreter/cling/LICENSE.TXT,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/LICENSE.TXT,1,['clear'],['clear']
Usability,"otect your rights, we need to make restrictions that forbid; distributors to deny you these rights or to ask you to surrender these; rights. These restrictions translate to certain responsibilities for; you if you distribute copies of the library or if you modify it. For example, if you distribute copies of the library, whether gratis; or for a fee, you must give the recipients all the rights that we gave; you. You must make sure that they, too, receive or can get the source; code. If you link other code with the library, you must provide; complete object files to the recipients, so that they can relink them; with the library after making changes to the library and recompiling; it. And you must show them these terms so they know their rights. We protect your rights with a two-step method: (1) we copyright the; library, and (2) we offer you this license, which gives you legal; permission to copy, distribute and/or modify the library. To protect each distributor, we want to make it very clear that; there is no warranty for the free library. Also, if the library is; modified by someone else and passed on, the recipients should know; that what they have is not the original version, so that the original; author's reputation will not be affected by problems that might be; introduced by others.; ; Finally, software patents pose a constant threat to the existence of; any free program. We wish to make sure that a company cannot; effectively restrict the users of a free program by obtaining a; restrictive license from a patent holder. Therefore, we insist that; any patent license obtained for a version of the library must be; consistent with the full freedom of use specified in this license. Most GNU software, including some libraries, is covered by the; ordinary GNU General Public License. This license, the GNU Lesser; General Public License, applies to certain designated libraries, and; is quite different from the ordinary General Public License. We use; this license for c",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/LGPL2_1.txt:2602,clear,clear,2602,LGPL2_1.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/LGPL2_1.txt,1,['clear'],['clear']
Usability,"other things, it has the ROOT::iOS::Pad class, which is a version; of TPad for iOS (pad with TF2 example below). Two applications, based on this module, were developed for iOS (currently,; for iPad only): ""Tutorials"" and ""RootBrowser"".; They can be found in $ROOTSYS/test/ios. ""Tutorials"" app; Small application with several demos, ""iOS version"" of the $ROOTSYS/tutorlas/demos.C. ""Tutorials"" application:. supports portrait and landscape orientation; has several demos (can be selected by tapping on table's cells); supports different gestures (pinch, single and double tap, pan, etc. - active gestures are shown by hint icons); has ""zoom"" mode - pinch or double tap gesture will zoom in/out pad's contents; has ""selection"" mode - with single tap user can select different objects inside pad - axes, histograms, pavestats etc.; 3D objects can be rotated.; has a simple editor to modify pad's parameters : fill color, logarithmic scale, grid, ticks, etc. ""RootBrowser"" app; This application is a simplified version of TBrowser and TCanvas; for iOS. User can open ROOT's file (application uses TWebFile) and; browse file's contents.; RootBrower registers *.root file extension in a system, so for; example, attached root files from a mail client can be opened by; RootBrowser.; Application has several views. In a top level view, user can see; opened files, open new files, close files (long press gesture on; a file icon):. Tap gesture on a file's icon will open ""File contents"" view. This; view shows objects and nested directories. For objects small; previews are generated. Tapping on a directory's icon will open; new view with directory's contents. Simple search is supported; (in the current TDirectoryFile). Tap on a object's preview will open detailed view for this object.; Using pinch gesture or double tap, you can zoom in/zoom out pad's; contents.; If you have several objects in a file or directory, you can; navigate through directory contents by using swipe gesture,; scrolling your obj",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/doc/v532/index.html:2406,simpl,simplified,2406,graf2d/doc/v532/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/doc/v532/index.html,1,['simpl'],['simplified']
Usability,"ots mechanism in; a standalone executable program on `linux` platform with the `gcc`; compiler. `tst.C `. ``` {.cpp}; #include <TQObject.h>; #include <RQ_OBJECT.h>. class A {; RQ_OBJECT(""A""); private:; Int_t fValue;; public:; A() : fValue(0) { }; ~A() { }; void SetValue(Int_t value); // *SIGNAL*; void PrintValue() const { printf(""value = %d\n"", fValue); }; };; void A::SetValue(Int_t value) { // Set new value; // Emit signal ""SetValue(Int_t)"" with a single parameter; if (value != fValue) {; fValue = value;; Emit(""SetValue(Int_t)"", fValue);; }; }; // Main program; #ifdef STANDALONE; int main(int argc, char **argv) {; A* a = new A();; A* b = new A();; a->Connect(""SetValue(Int_t)"", ""A"", b, ""SetValue(Int_t)"");; printf(""n******* Test of SetValue(Int_t) signal *******n"");; b->SetValue(10);; printf(""nt***** b before ******n"");; b->PrintValue();; a->SetValue(20);; printf(""t***** b after a->SetValue(20) ******n"");; b->PrintValue();; return 0;; }; #endif; ```. ACLiC simplifies this procedure and allows the dictionary generation by:. ``` {.cpp}; root[] .L tst.C++; ```. It will create the shared library `tst_C.so.`. The next line will create an executable:. **`` g++ -otst tst.C `root-config --cflags --libs` ./tst_C.so -DSTANDALONE ``**. The library `tst_C.so` is a dynamically loaded library and should be; located in `$LD_LIBRARY_PATH`. The current working directory should be; added to `$LD_LIBRARY_PATH` via:. **`export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:./`**. To run it, you just do:. **`./tst`**. ## Widgets in Detail. ### Buttons. Buttons are a popular group of widgets designed to provide specific; interfaces for user interaction. **`TGButton`** is an abstract class; defining the general button behavior: width, height, state, its group,; tool tip text, etc. There are two main groups of buttons: command buttons with a text or; graphics inside that indicate the action to be accomplished and option; buttons well known as radio and check buttons that select or change; properties. The",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md:53396,simpl,simplifies,53396,documentation/users-guide/WritingGUI.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md,1,['simpl'],['simplifies']
Usability,"ot}.getReg(), ${src}.getReg(), ${mi}->hasImplicitDef())"")>;. Common Pattern #1: Replace a Register with Another; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. The 'apply' pattern must always redefine all operands defined by the match root.; Sometimes, we do not need to create instructions, simply replace a def with; another matched register. The ``GIReplaceReg`` builtin can do just that. .. code-block:: text. def Foo : GICombineRule<; (defs root:$dst),; (match (G_FNEG $tmp, $src), (G_FNEG $dst, $tmp)),; (apply (GIReplaceReg $dst, $src))>;. This also works if the replacement register is a temporary register from the; ``apply`` pattern. .. code-block:: text. def ReplaceTemp : GICombineRule<; (defs root:$a),; (match (G_BUILD_VECTOR $tmp, $x, $y),; (G_UNMERGE_VALUES $a, $b, $tmp)),; (apply (G_UNMERGE_VALUES $a, i32:$new, $y),; (GIReplaceReg $b, $new))>. Common Pattern #2: Erasing a Def-less Root; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. If we simply want to erase a def-less match root, we can use the; ``GIEraseRoot`` builtin. .. code-block:: text. def Foo : GICombineRule<; (defs root:$mi),; (match (G_STORE $a, $b):$mi),; (apply (GIEraseRoot))>;. Common Pattern #3: Emitting a Constant Value; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. When an immediate operand appears in an 'apply' pattern, the behavior; depends on whether it's typed or not. * If the immediate is typed, ``MachineIRBuilder::buildConstant`` is used; to create a ``G_CONSTANT``. A ``G_BUILD_VECTOR`` will be used for vectors.; * If the immediate is untyped, a simple immediate is added; (``MachineInstrBuilder::addImm``). There is of course a special case for ``G_CONSTANT``. Immediates for; ``G_CONSTANT`` must always be typed, and a CImm is added; (``MachineInstrBuilder::addCImm``). .. code-block:: text; :caption: Constant Emission Examples:. // Example output:; // %0 = G_CONSTANT i32 0; // %dst = COPY %0; def Foo : GICombineRule<; (defs root:$dst),; (match (G_FOO $dst, $src)),; (apply (COPY $dst, (i3",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GlobalISel/MIRPatterns.rst:9026,simpl,simply,9026,interpreter/llvm-project/llvm/docs/GlobalISel/MIRPatterns.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GlobalISel/MIRPatterns.rst,1,['simpl'],['simply']
Usability,"ou can; fit into memory at a time (useful for whole program analysis tools, for; example).; In addition to being efficient when pitted head-to-head against GCC in batch; mode, clang is built with a library based; architecture that makes it relatively easy to adapt it and build new tools; with it. This means that it is often possible to apply out-of-the-box thinking; and novel techniques to improve compilation in various ways. Expressive Diagnostics. In addition to being fast and functional, we aim to make Clang extremely user; friendly. As far as a command-line compiler goes, this basically boils down to; making the diagnostics (error and warning messages) generated by the compiler; be as useful as possible. There are several ways that we do this, but the; most important are pinpointing exactly what is wrong in the program,; highlighting related information so that it is easy to understand at a glance,; and making the wording as clear as possible.; Here is one simple example that illustrates the quality of Clang diagnostic:. $ clang -fsyntax-only t.c; t.c:7:39: error: invalid operands to binary expression ('int' and 'struct A'); return y + func(y ? ((SomeA.X + 40) + SomeA) / 42 + SomeA.X : SomeA.X);; ~~~~~~~~~~~~~~ ^ ~~~~~. Here you can see that you don't even need to see the original source code to; understand what is wrong based on the Clang error: Because Clang prints a; caret, you know exactly which plus it is complaining about. The range; information highlights the left and right side of the plus which makes it; immediately obvious what the compiler is talking about, which is very useful for; cases involving precedence issues and many other situations.; Clang diagnostics are very polished and have many features. For more; information and examples, please see the Expressive; Diagnostics page. GCC Compatibility. GCC is currently the defacto-standard open source compiler today, and it; routinely compiles a huge volume of code. GCC supports a huge number of; extensi",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/features.html:2155,simpl,simple,2155,interpreter/llvm-project/clang/www/features.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/features.html,1,['simpl'],['simple']
Usability,"ouble @foo(double %x) {; entry:; %calltmp = call double @sin(double %x); %multmp = fmul double %calltmp, %calltmp; %calltmp2 = call double @cos(double %x); %multmp4 = fmul double %calltmp2, %calltmp2; %addtmp = fadd double %multmp, %multmp4; ret double %addtmp; }. ready> foo(4.0);; Read top-level expression:; define double @3() {; entry:; %calltmp = call double @foo(double 4.000000e+00); ret double %calltmp; }. Evaluated to 1.000000. Whoa, how does the JIT know about sin and cos? The answer is surprisingly; simple: The KaleidoscopeJIT has a straightforward symbol resolution rule that; it uses to find symbols that aren't available in any given module: First; it searches all the modules that have already been added to the JIT, from the; most recent to the oldest, to find the newest definition. If no definition is; found inside the JIT, it falls back to calling ""``dlsym(""sin"")``"" on the; Kaleidoscope process itself. Since ""``sin``"" is defined within the JIT's; address space, it simply patches up calls in the module to call the libm; version of ``sin`` directly. But in some cases this even goes further:; as sin and cos are names of standard math functions, the constant folder; will directly evaluate the function calls to the correct result when called; with constants like in the ""``sin(1.0)``"" above. In the future we'll see how tweaking this symbol resolution rule can be used to; enable all sorts of useful features, from security (restricting the set of; symbols available to JIT'd code), to dynamic code generation based on symbol; names, and even lazy compilation. One immediate benefit of the symbol resolution rule is that we can now extend; the language by writing arbitrary C++ code to implement operations. For example,; if we add:. .. code-block:: c++. #ifdef _WIN32; #define DLLEXPORT __declspec(dllexport); #else; #define DLLEXPORT; #endif. /// putchard - putchar that takes a double and returns 0.; extern ""C"" DLLEXPORT double putchard(double X) {; fputc((char)X, stder",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl04.rst:23119,simpl,simply,23119,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl04.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl04.rst,1,['simpl'],['simply']
Usability,"ould be a; corresponding denormalization step. YAML I/O uses a non-invasive, traits based design. YAML I/O defines some; abstract base templates. You specialize those templates on your data types.; For instance, if you have an enumerated type FooBar you could specialize; ScalarEnumerationTraits on that type and define the enumeration() method:. .. code-block:: c++. using llvm::yaml::ScalarEnumerationTraits;; using llvm::yaml::IO;. template <>; struct ScalarEnumerationTraits<FooBar> {; static void enumeration(IO &io, FooBar &value) {; ...; }; };. As with all YAML I/O template specializations, the ScalarEnumerationTraits is used for; both reading and writing YAML. That is, the mapping between in-memory enum; values and the YAML string representation is only in one place.; This assures that the code for writing and parsing of YAML stays in sync. To specify a YAML mappings, you define a specialization on; llvm::yaml::MappingTraits.; If your native data structure happens to be a struct that is already normalized,; then the specialization is simple. For example:. .. code-block:: c++. using llvm::yaml::MappingTraits;; using llvm::yaml::IO;. template <>; struct MappingTraits<Person> {; static void mapping(IO &io, Person &info) {; io.mapRequired(""name"", info.name);; io.mapOptional(""hat-size"", info.hatSize);; }; };. A YAML sequence is automatically inferred if you data type has begin()/end(); iterators and a push_back() method. Therefore any of the STL containers; (such as std::vector<>) will automatically translate to YAML sequences. Once you have defined specializations for your data types, you can; programmatically use YAML I/O to write a YAML document:. .. code-block:: c++. using llvm::yaml::Output;. Person tom;; tom.name = ""Tom"";; tom.hatSize = 8;; Person dan;; dan.name = ""Dan"";; dan.hatSize = 7;; std::vector<Person> persons;; persons.push_back(tom);; persons.push_back(dan);. Output yout(llvm::outs());; yout << persons;. This would write the following:. .. code-block:: y",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/YamlIO.rst:3794,simpl,simple,3794,interpreter/llvm-project/llvm/docs/YamlIO.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/YamlIO.rst,1,['simpl'],['simple']
Usability,"ound in; :ref:`Loop Terminology for Rotated Loops <loop-terminology-loop-rotate>`. .. _passes-loop-simplify:. ``loop-simplify``: Canonicalize natural loops; ---------------------------------------------. This pass performs several transformations to transform natural loops into a; simpler form, which makes subsequent analyses and transformations simpler and; more effective. A summary of it can be found in; :ref:`Loop Terminology, Loop Simplify Form <loop-terminology-loop-simplify>`. Loop pre-header insertion guarantees that there is a single, non-critical entry; edge from outside of the loop to the loop header. This simplifies a number of; analyses and transformations, such as :ref:`LICM <passes-licm>`. Loop exit-block insertion guarantees that all exit blocks from the loop (blocks; which are outside of the loop that have predecessors inside of the loop) only; have predecessors from inside of the loop (and are thus dominated by the loop; header). This simplifies transformations such as store-sinking that are built; into LICM. This pass also guarantees that loops will have exactly one backedge. Note that the :ref:`simplifycfg <passes-simplifycfg>` pass will clean up blocks; which are split out but end up being unnecessary, so usage of this pass should; not pessimize generated code. This pass obviously modifies the CFG, but updates loop information and; dominator information. ``loop-unroll``: Unroll loops; -----------------------------. This pass implements a simple loop unroller. It works best when loops have; been canonicalized by the :ref:`indvars <passes-indvars>` pass, allowing it to; determine the trip counts of loops easily. ``loop-unroll-and-jam``: Unroll and Jam loops; ---------------------------------------------. This pass implements a simple unroll and jam classical loop optimisation pass.; It transforms loop from:. .. code-block:: c++. for i.. i+= 1 for i.. i+= 4; for j.. for j..; code(i, j) code(i, j); code(i+1, j); code(i+2, j); code(i+3, j); remainder l",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Passes.rst:27456,simpl,simplifies,27456,interpreter/llvm-project/llvm/docs/Passes.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Passes.rst,1,['simpl'],['simplifies']
Usability,"outfitted with the new matcher, only prints out loops; that declare a single variable initialized to zero and have an increment; step consisting of a unary increment of some variable. Now, we just need to add a matcher to check if the condition part of the; ``for`` loop compares a variable against the size of the array. There is; only one problem - we don't know which array we're iterating over; without looking at the body of the loop! We are again restricted to; approximating the result we want with matchers, filling in the details; in the callback. So we start with:. .. code-block:: c++. hasCondition(binaryOperator(hasOperatorName(""<""))). It makes sense to ensure that the left-hand side is a reference to a; variable, and that the right-hand side has integer type. .. code-block:: c++. hasCondition(binaryOperator(; hasOperatorName(""<""),; hasLHS(declRefExpr(to(varDecl(hasType(isInteger()))))),; hasRHS(expr(hasType(isInteger()))))). Why? Because it doesn't work. Of the three loops provided in; ``test-files/simple.cpp``, zero of them have a matching condition. A; quick look at the AST dump of the first for loop, produced by the; previous iteration of loop-convert, shows us the answer:. ::. (ForStmt 0x173b240; (DeclStmt 0x173afc8; 0x173af50 ""int i =; (IntegerLiteral 0x173afa8 'int' 0)""); <<>>; (BinaryOperator 0x173b060 '_Bool' '<'; (ImplicitCastExpr 0x173b030 'int'; (DeclRefExpr 0x173afe0 'int' lvalue Var 0x173af50 'i' 'int')); (ImplicitCastExpr 0x173b048 'int'; (DeclRefExpr 0x173b008 'const int' lvalue Var 0x170fa80 'N' 'const int'))); (UnaryOperator 0x173b0b0 'int' lvalue prefix '++'; (DeclRefExpr 0x173b088 'int' lvalue Var 0x173af50 'i' 'int')); (CompoundStatement ... We already know that the declaration and increments both match, or this; loop wouldn't have been dumped. The culprit lies in the implicit cast; applied to the first operand (i.e. the LHS) of the less-than operator,; an L-value to R-value conversion applied to the expression referencing; ``i``. Thankfully",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersTutorial.rst:14012,simpl,simple,14012,interpreter/llvm-project/clang/docs/LibASTMatchersTutorial.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersTutorial.rst,1,['simpl'],['simple']
Usability,"outine Structure Intrinsics; ------------------------------; Intrinsics described in this section are used within a coroutine to describe; the coroutine structure. They should not be used outside of a coroutine. .. _coro.size:. 'llvm.coro.size' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^; ::. declare i32 @llvm.coro.size.i32(); declare i64 @llvm.coro.size.i64(). Overview:; """""""""""""""""". The '``llvm.coro.size``' intrinsic returns the number of bytes; required to store a `coroutine frame`_. This is only supported for; switched-resume coroutines. Arguments:; """""""""""""""""""". None. Semantics:; """""""""""""""""""". The `coro.size` intrinsic is lowered to a constant representing the size of; the coroutine frame. .. _coro.align:. 'llvm.coro.align' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^; ::. declare i32 @llvm.coro.align.i32(); declare i64 @llvm.coro.align.i64(). Overview:; """""""""""""""""". The '``llvm.coro.align``' intrinsic returns the alignment of a `coroutine frame`_.; This is only supported for switched-resume coroutines. Arguments:; """""""""""""""""""". None. Semantics:; """""""""""""""""""". The `coro.align` intrinsic is lowered to a constant representing the alignment of; the coroutine frame. .. _coro.begin:. 'llvm.coro.begin' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^; ::. declare ptr @llvm.coro.begin(token <id>, ptr <mem>). Overview:; """""""""""""""""". The '``llvm.coro.begin``' intrinsic returns an address of the coroutine frame. Arguments:; """""""""""""""""""". The first argument is a token returned by a call to '``llvm.coro.id``'; identifying the coroutine. The second argument is a pointer to a block of memory where coroutine frame; will be stored if it is allocated dynamically. This pointer is ignored; for returned-continuation coroutines. Semantics:; """""""""""""""""""". Depending on the alignment requirements of the objects in the coroutine frame; and/or on the codegen compactness reasons the pointer returned from `coro.begin`; may be at offset to the `%mem` argument. (This could be beneficial if; in",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst:32136,resume,resume,32136,interpreter/llvm-project/llvm/docs/Coroutines.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst,1,['resume'],['resume']
Usability,"outu.be/C5Y977rLqpw. A good way for new contributors to increase their knowledge of the code base is; to review code. It is perfectly acceptable to review code and explicitly; defer to others for approval decisions. Experts Should Review Code; --------------------------. If you are an expert in an area of the compiler affected by a proposed patch,; then you are highly encouraged to review the code. If you are a relevant code; owner, and no other experts are reviewing a patch, you must either help arrange; for an expert to review the patch or review it yourself. Code Reviews, Speed, and Reciprocity; ------------------------------------. Sometimes code reviews will take longer than you might hope, especially for; larger features. Common ways to speed up review times for your patches are:. * Review other people's patches. If you help out, everybody will be more; willing to do the same for you; goodwill is our currency.; * Ping the patch. If it is urgent, provide reasons why it is important to you to; get this patch landed and ping it every couple of days. If it is; not urgent, the common courtesy ping rate is one week. Remember that you're; asking for valuable time from other professional developers.; * Ask for help on IRC. Developers on IRC will be able to either help you; directly, or tell you who might be a good reviewer.; * Split your patch into multiple smaller patches that build on each other. The; smaller your patch is, the higher the probability that somebody will take a quick; look at it. When doing this, it is helpful to add ""[N/M]"" (for 1 <= N <= M) to; the title of each patch in the series, so it is clear that there is an order; and what that order is. Developers should participate in code reviews as both reviewers and; authors. If someone is kind enough to review your code, you should return the; favor for someone else. Note that anyone is welcome to review and give feedback; on a patch, but approval of patches should be consistent with the policy above.; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodeReview.rst:12387,clear,clear,12387,interpreter/llvm-project/llvm/docs/CodeReview.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodeReview.rst,2,"['clear', 'feedback']","['clear', 'feedback']"
Usability,"ovl	$0x7, -0x4(%rbp)'; [004] {Code} 'jmp	0x6'; [004] 8 {Line}; [004] {Code} 'movl	-0x14(%rbp), %eax'; [003] 4 {TypeAlias} 'INTEGER' -> 'int'; [003] 2 {Line}; [003] {Code} 'pushq	%rbp'; [003] {Code} 'movq	%rsp, %rbp'; [003] {Code} 'movb	%dl, %al'; [003] {Code} 'movq	%rdi, -0x10(%rbp)'; [003] {Code} 'movl	%esi, -0x14(%rbp)'; [003] {Code} 'andb	$0x1, %al'; [003] {Code} 'movb	%al, -0x15(%rbp)'; [003] 3 {Line}; [003] {Code} 'testb	$0x1, -0x15(%rbp)'; [003] {Code} 'je	0x13'; [003] 8 {Line}; [003] {Code} 'movl	%eax, -0x4(%rbp)'; [003] 9 {Line}; [003] {Code} 'movl	-0x4(%rbp), %eax'; [003] {Code} 'popq	%rbp'; [003] {Code} 'retq'; [003] 9 {Line}; [002] 1 {TypeAlias} 'INTPTR' -> '* const int'. On closer inspection, we can see what could be a potential debug issue:. .. code-block:: none. [003] {Block}; [003] 4 {TypeAlias} 'INTEGER' -> 'int'. The **'INTEGER'** definition is at level **[003]**, the same lexical; scope as the anonymous **{Block}** ('true' branch for the 'if' statement); whereas in the original source code the typedef statement is clearly; inside that block, so the **'INTEGER'** definition should also be at; level **[004]** inside the block. SELECT LOGICAL ELEMENTS; """"""""""""""""""""""""""""""""""""""""""""""; The following prints all *instructions*, *symbols* and *types* that; contain **'inte'** or **'movl'** in their names or types, using a tab; layout and given the number of matches. .. code-block:: none. llvm-debuginfo-analyzer --attribute=level; --select-nocase --select-regex; --select=INTe --select=movl; --report=list; --print=symbols,types,instructions,summary; test-dwarf-clang.o. Logical View:; [000] {File} 'test-dwarf-clang.o'. [001] {CompileUnit} 'test.cpp'; [003] {Code} 'movl	$0x7, -0x1c(%rbp)'; [003] {Code} 'movl	$0x7, -0x4(%rbp)'; [003] {Code} 'movl	%eax, -0x4(%rbp)'; [003] {Code} 'movl	%esi, -0x14(%rbp)'; [003] {Code} 'movl	-0x14(%rbp), %eax'; [003] {Code} 'movl	-0x4(%rbp), %eax'; [003] 4 {TypeAlias} 'INTEGER' -> 'int'; [004] 5 {Variable} 'CONSTANT' -> 'const INTEGER'. --",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-debuginfo-analyzer.rst:26805,clear,clearly,26805,interpreter/llvm-project/llvm/docs/CommandGuide/llvm-debuginfo-analyzer.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-debuginfo-analyzer.rst,1,['clear'],['clearly']
Usability,"owed by appendix; :ref:`amdgpu-dwarf-changes-relative-to-dwarf-version-5` which contains the; textual changes for the extensions relative to the DWARF Version 5 standard.; There are a number of notes included that raise open questions, or provide; alternative approaches that may be worth considering. Then appendix; :ref:`amdgpu-dwarf-further-examples` links to the AMD GPU specific usage of the; extensions that includes an example. Finally, appendix; :ref:`amdgpu-dwarf-references` provides references to further information. .. _amdgpu-dwarf-extensions:. 2. Extensions; =============. The extensions continue to evolve through collaboration with many individuals and; active prototyping within the GDB debugger and LLVM compiler. Input has also; been very much appreciated from the developers working on the Perforce TotalView; HPC Debugger and GCC compiler. The inputs provided and insights gained so far have been incorporated into this; current version. The plan is to participate in upstreaming the work and; addressing any feedback. If there is general interest then some or all of these; extensions could be submitted as future DWARF standard proposals. The general principles in designing the extensions have been:. 1. Be backwards compatible with the DWARF Version 5 [:ref:`DWARF; <amdgpu-dwarf-DWARF>`] standard. 2. Be vendor and architecture neutral. They are intended to apply to other; heterogeneous hardware devices including GPUs, DSPs, FPGAs, and other; specialized hardware. These collectively include similar characteristics and; requirements as AMDGPU devices. 3. Provide improved optimization support for non-GPU code. For example, some; extensions apply to traditional CPU hardware that supports large vector; registers. Compilers can map source languages, and source language; extensions, that describe large scale parallel execution, onto the lanes of; the vector registers. This is common in programming languages used in ML and; HPC. 4. Fully define well-formed DWARF in a ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst:3632,feedback,feedback,3632,interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,1,['feedback'],['feedback']
Usability,"ows example reStructuredText markup constructs; that are meant to be read by you in your text editor after you have copied; this file into a new file for the documentation you are about to write. Example Section; ===============. An article can contain one or more sections (i.e., headings). Sections (like ``Example Section`` above) help give your document its; structure. Use the same kind of adornments (e.g. ``======`` vs. ``------``); as are used in this document. The adornment must be the same length as the; text above it. For Vim users, variations of ``yypVr=`` might be handy. Example Nested Subsection; -------------------------. Subsections can also be nested beneath other subsections. For more information on sections, see Sphinx's `reStructuredText Primer`_. .. _`reStructuredText Primer`: http://www.sphinx-doc.org/en/master/usage/restructuredtext/basics.html#sections. Text Formatting; ===============. Text can be *emphasized*, **bold**, or ``monospace``. To create a new paragraph, simply insert a blank line. Links; =====. You can format a link `like this <https://llvm.org/>`_. A more `sophisticated syntax`_ allows you to place the ``.. _`link text`: <URL>`` block; pretty much anywhere else in the document. This is useful when linking to especially long URLs. .. _`sophisticated syntax`: http://en.wikipedia.org/wiki/LLVM. Lists; =====. restructuredText allows you to create ordered lists... #. A list starting with ``#.`` will be automatically numbered. #. This is a second list element. #. Use indentation to create nested lists. ...as well as unordered lists:. * Stuff. + Deeper stuff. * More stuff. Code Blocks; ===========. You can make blocks of code like this:. .. code-block:: c++. int main() {; return 0;; }. For a shell session, use a ``console`` code block (some existing docs use; ``bash``):. .. code-block:: console. $ echo ""Goodbye cruel world!""; $ rm -rf /. If you need to show LLVM IR use the ``llvm`` code block. .. code-block:: llvm. define i32 @test1() {; en",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SphinxQuickstartTemplate.rst:3800,simpl,simply,3800,interpreter/llvm-project/llvm/docs/SphinxQuickstartTemplate.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SphinxQuickstartTemplate.rst,1,['simpl'],['simply']
Usability,"ows other language translations to; substitute reasonable words (or entire phrases) based on the semantics of the; diagnostic instead of having to do things textually. The selected string; does undergo formatting. **""plural"" format**. Example:; ``""you have %0 %plural{1:mouse|:mice}0 connected to your computer""``; Class:; Integers; Description:; This is a formatter for complex plural forms. It is designed to handle even; the requirements of languages with very complex plural forms, as many Baltic; languages have. The argument consists of a series of expression/form pairs,; separated by "":"", where the first form whose expression evaluates to true is; the result of the modifier. An expression can be empty, in which case it is always true. See the example; at the top. Otherwise, it is a series of one or more numeric conditions,; separated by "","". If any condition matches, the expression matches. Each; numeric condition can take one of three forms. * number: A simple decimal number matches if the argument is the same as the; number. Example: ``""%plural{1:mouse|:mice}0""``; * range: A range in square brackets matches if the argument is within the; range. Then range is inclusive on both ends. Example:; ``""%plural{0:none|1:one|[2,5]:some|:many}0""``; * modulo: A modulo operator is followed by a number, and equals sign and; either a number or a range. The tests are the same as for plain numbers; and ranges, but the argument is taken modulo the number first. Example:; ``""%plural{%100=0:even hundred|%100=[1,50]:lower half|:everything else}1""``. The parser is very unforgiving. A syntax error, even whitespace, will abort,; as will a failure to match the argument against any expression. **""ordinal"" format**. Example:; ``""ambiguity in %ordinal0 argument""``; Class:; Integers; Description:; This is a formatter which represents the argument number as an ordinal: the; value ``1`` becomes ``1st``, ``3`` becomes ``3rd``, and so on. Values less; than ``1`` are not supported. This formatter",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:12627,simpl,simple,12627,interpreter/llvm-project/clang/docs/InternalsManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst,1,['simpl'],['simple']
Usability,"owto:errordef]) should be $1.0$. If the $\mbox{FCN}$; is a negative-log-likelihood function, then the one-standard-deviation; value for FCNBase::up() to return is $0.5$. If the $\mbox{FCN}$ is a; chisquare, but the user wants two-standard-deviation errors, then; FCNBase::up() should return $= 4.0$, etc. Note that in the usual case where M is being used to perform a fit to; some experimental data, the parameter errors will be proportional to the; uncertainty in the data, and therefore meaningful parameter errors; cannot be obtained unless the measurement errors of the data are known.; In the common case of a least-squares fit, $\mbox{FCN}$ is usually; defined as a chisquare:. $$\chi^2 (\alpha) = \sum_{i=1}^{n} (\frac{f(x_i,\alpha) - m_i)^2}{\sigma_i^2}$$. where $\alpha$ is the vector of free parameters being fitted, and the; $\sigma_i$ are the uncertainties in the individual measurements $m_i$.; If these uncertainties are not known, and are simply left out of the; calculation, then the fit may still have meaning, but not the; quantitative values of the resulting parameter errors. (Only the; relative errors of different parameters with respect to each other may; be meaningful.). If the $\sigma_i$ are all overestimated by a factor $\beta$, then the; resulting parameter errors from the fit will be overestimated by the; same factor $\beta$. ### The error matrix ###. The M processors $\mbox{MIGRAD}$ (MnMigrad, see [api:migrad]) and; HESSE (MnHesse, see [api:hesse]) (normally) produce an error matrix.; This matrix is twice the inverse of the matrix of second derivatives of; the $\mbox{FCN}$, transformed if necessary into external coordinate; space[^2], and multiplied by FCNBase::up(). Therefore, errors based on; the M error matrix take account of all the parameter correlations, but; not the non-linearities. That is, from the error matrix alone,; two-standard-deviation errors are always exactly twice as big as; one-standard-deviation errors. When the error matrix has been ca",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md:14963,simpl,simply,14963,documentation/minuit2/Minuit2.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md,1,['simpl'],['simply']
Usability,"ozilla.org/en/http_access_control). Alternative - enable CORS requests in the browser. It can be easily done with [CORS Everywhere plugin](https://addons.mozilla.org/de/firefox/addon/cors-everywhere/) for the Firefox browser or [Allow CORS plugin](https://chrome.google.com/webstore/detail/allow-control-allow-origi/nlfbmbojpeacfghkpbjhddihlkkiljbi?hl=en) for the Chrome browser. Next solution - install JSROOT on the server hosting ROOT files. In such configuration JSROOT does not issue CORS requests, therefore server and browsers can be used with their default settings. A simplified variant of such solution - copy only the top index.htm file from JSROOT package and specify the full path to `modules/gui.mjs` script like:. ```javascript; <script type=""module"">; import { openFile, draw } from 'https://root.cern/js/latest/modules/gui.mjs';; // ...; </script>; ```. In the main `<div>` element one can specify many custom parameters like one do it in URL string:. ```html; <div id=""simpleGUI"" path=""files/path"" files=""userfile1.root;subdir/usefile2.root"">; loading scripts ...; </div>; ```. ## Reading local ROOT files. JSROOT can read files from local file system using HTML5 FileReader functionality.; Main limitation here - user should interactively select files for reading.; There is button __""...""__ on the main JSROOT page, which starts file selection dialog.; If valid ROOT file is selected, JSROOT will be able to normally read content of such file. ## JSROOT with THttpServer. THttpServer provides http access to objects from running ROOT application.; JSROOT is used to implement the user interface in the web browsers. The layout of the main page coming from THttpServer is very similar to normal JSROOT page.; One could browse existing items and display them. A snapshot of running; server can be seen on the [demo page](https://root.cern/js/latest/httpserver.C/). One could also specify similar URL parameters to configure the displayed items and drawing options. It is also possibl",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/JSROOT/JSROOT.md:29267,simpl,simpleGUI,29267,documentation/JSROOT/JSROOT.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/JSROOT/JSROOT.md,1,['simpl'],['simpleGUI']
Usability,"p and therefore must; be saved by the runtime. This is an important optimization when the; patchpoint intrinsic is used with a calling convention that by default; preserves most registers as callee-save. Each entry in the liveout register list contains a DWARF register; number and size in bytes. The stackmap format deliberately omits; specific subregister information. Instead the runtime must interpret; this information conservatively. For example, if the stackmap reports; one byte at ``%rax``, then the value may be in either ``%al`` or; ``%ah``. It doesn't matter in practice, because the runtime will; simply save ``%rax``. However, if the stackmap reports 16 bytes at; ``%ymm0``, then the runtime can safely optimize by saving only; ``%xmm0``. The stack map format is a contract between an LLVM SVN revision and; the runtime. It is currently experimental and may change in the short; term, but minimizing the need to update the runtime is; important. Consequently, the stack map design is motivated by; simplicity and extensibility. Compactness of the representation is; secondary because the runtime is expected to parse the data; immediately after compiling a module and encode the information in its; own format. Since the runtime controls the allocation of sections, it; can reuse the same stack map space for multiple modules. Stackmap support is currently only implemented for 64-bit; platforms. However, a 32-bit implementation should be able to use the; same format with an insignificant amount of wasted space. .. _stackmap-section:. Stack Map Section; ^^^^^^^^^^^^^^^^^. A JIT compiler can easily access this section by providing its own; memory manager via the LLVM C API; ``LLVMCreateSimpleMCJITMemoryManager()``. When creating the memory; manager, the JIT provides a callback:; ``LLVMMemoryManagerAllocateDataSectionCallback()``. When LLVM creates; this section, it invokes the callback and passes the section name. The; JIT can record the in-memory address of the section at th",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/StackMaps.rst:15593,simpl,simplicity,15593,interpreter/llvm-project/llvm/docs/StackMaps.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/StackMaps.rst,1,['simpl'],['simplicity']
Usability,"p bitcode; generation and optimization completely disjoint. Bit-for-bit compatibility is not (and never was) a guarantee, and we reserve; the right to change this at any time. Explicitly, users should not rely on; the produced bitcode or object code to match their non-LTO counterparts; precisely. They will exhibit similar performance characteristics, but may; not be bit-for-bit the same. Internally, the ``.llvm.lto`` section is created by running the; ``EmbedBitcodePass`` after the ``ThinLTOPreLinkDefaultPipeline``. This pass is; responsible for emitting the ``.llvm.lto`` section. Afterwards, the; ``ThinLTODefaultPipeline`` runs and the compiler can emit the fat object file. Limitations; ===========. Linkers; -------. Currently, using LTO with LLVM fat lto objects is supported by LLD and by the; GNU linkers via :doc:`GoldPlugin`. This may change in the future, but; extending support to other linkers isn't planned for now. .. NOTE; For standard linking the fat object files should be usable by any; linker capable of using ELF objects, since the ``.llvm.lto`` section is; marked ``SHF_EXCLUDE``. Supported File Formats; ----------------------. The current implementation only supports ELF files. At time of writing, it is; unclear if it will be useful to support other object file formats like ``COFF``; or ``Mach-O``. Usage; =====. Clang users can specify ``-ffat-lto-objects`` with ``-flto`` or ``-flto=thin``.; Without the ``-flto`` option, ``-ffat-lto-objects`` has no effect. Compile an object file using FatLTO:. .. code-block:: console. $ clang -flto -ffat-lto-objects example.c -c -o example.o. Link using the object code from the fat object without LTO. This turns; ``-ffat-lto-objects`` into a no-op, when ``-fno-lto`` is specified:. .. code-block:: console. $ clang -fno-lto -ffat-lto-objects -fuse-ld=lld example.o. Alternatively, you can omit any references to LTO with fat objects and retain standard linker behavior:. .. code-block:: console. $ clang -fuse-ld=lld example.",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/FatLTO.rst:2590,usab,usable,2590,interpreter/llvm-project/llvm/docs/FatLTO.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/FatLTO.rst,1,['usab'],['usable']
Usability,"p bug-trigger.ll -o test.mir``. If the same pass is run multiple times, a run index can be included; after the name with a comma. ``llc -stop-after=dead-mi-elimination,1 bug-trigger.ll -o test.mir``. After generating the input MIR file, you'll have to add a run line that uses; the ``-run-pass`` option to it. In order to test the post register allocation; pseudo instruction expansion pass on X86-64, a run line like the one shown; below can be used:. ``# RUN: llc -o - %s -mtriple=x86_64-- -run-pass=postrapseudos | FileCheck %s``. The MIR files are target dependent, so they have to be placed in the target; specific test directories (``lib/CodeGen/TARGETNAME``). They also need to; specify a target triple or a target architecture either in the run line or in; the embedded LLVM IR module. Simplifying MIR files; ^^^^^^^^^^^^^^^^^^^^^. The MIR code coming out of ``-stop-after``/``-stop-before`` is very verbose;; Tests are more accessible and future proof when simplified:. - Use the ``-simplify-mir`` option with llc. - Machine function attributes often have default values or the test works just; as well with default values. Typical candidates for this are: `alignment:`,; `exposesReturnsTwice`, `legalized`, `regBankSelected`, `selected`.; The whole `frameInfo` section is often unnecessary if there is no special; frame usage in the function. `tracksRegLiveness` on the other hand is often; necessary for some passes that care about block livein lists. - The (global) `liveins:` list is typically only interesting for early; instruction selection passes and can be removed when testing later passes.; The per-block `liveins:` on the other hand are necessary if; `tracksRegLiveness` is true. - Branch probability data in block `successors:` lists can be dropped if the; test doesn't depend on it. Example:; `successors: %bb.1(0x40000000), %bb.2(0x40000000)` can be replaced with; `successors: %bb.1, %bb.2`. - MIR code contains a whole IR module. This is necessary because there are; no equiv",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MIRLangRef.rst:3162,simpl,simplify-mir,3162,interpreter/llvm-project/llvm/docs/MIRLangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MIRLangRef.rst,1,['simpl'],['simplify-mir']
Usability,"p', etc in; # c++xx mode.; set(CMAKE_CXX_EXTENSIONS YES); else(); set(CMAKE_CXX_EXTENSIONS NO); endif(). if (NOT CMAKE_BUILD_TYPE AND NOT CMAKE_CONFIGURATION_TYPES); message(FATAL_ERROR ""; No build type selected. You need to pass -DCMAKE_BUILD_TYPE=<type> in order to configure LLVM.; Available options are:; * -DCMAKE_BUILD_TYPE=Release - For an optimized build with no assertions or debug info.; * -DCMAKE_BUILD_TYPE=Debug - For an unoptimized build with assertions and debug info.; * -DCMAKE_BUILD_TYPE=RelWithDebInfo - For an optimized build with no assertions but with debug info.; * -DCMAKE_BUILD_TYPE=MinSizeRel - For a build optimized for size instead of speed.; Learn more about these options in our documentation at https://llvm.org/docs/CMake.html#cmake-build-type; ""); endif(). # Set default build type for cmake's try_compile module.; # CMake 3.17 or newer sets CMAKE_DEFAULT_BUILD_TYPE to one of the; # items from CMAKE_CONFIGURATION_TYPES. Logic below can be further; # simplified once LLVM's minimum CMake version is updated to 3.17.; if(CMAKE_DEFAULT_BUILD_TYPE); set(CMAKE_TRY_COMPILE_CONFIGURATION ${CMAKE_DEFAULT_BUILD_TYPE}); else(); if(CMAKE_CONFIGURATION_TYPES); list(GET CMAKE_CONFIGURATION_TYPES 0 CMAKE_TRY_COMPILE_CONFIGURATION); elseif(CMAKE_BUILD_TYPE); set(CMAKE_TRY_COMPILE_CONFIGURATION ${CMAKE_BUILD_TYPE}); endif(); endif(). # Side-by-side subprojects layout: automatically set the; # LLVM_EXTERNAL_${project}_SOURCE_DIR using LLVM_ALL_PROJECTS; # This allows an easy way of setting up a build directory for llvm and another; # one for llvm+clang+... using the same sources.; set(LLVM_ALL_PROJECTS ""bolt;clang;clang-tools-extra;compiler-rt;cross-project-tests;libc;libclc;lld;lldb;mlir;openmp;polly;pstl""); # The flang project is not yet part of ""all"" projects (see C++ requirements); set(LLVM_EXTRA_PROJECTS ""flang""); # List of all known projects in the mono repo; set(LLVM_KNOWN_PROJECTS ""${LLVM_ALL_PROJECTS};${LLVM_EXTRA_PROJECTS}""); set(LLVM_ENABLE_PROJECTS """" ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/CMakeLists.txt:4659,simpl,simplified,4659,interpreter/llvm-project/llvm/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/CMakeLists.txt,1,['simpl'],['simplified']
Usability,"p; <writing-an-llvm-pass-runOnLoop>` for every loop in the program being compiled. .. _writing-an-llvm-pass-RegionPass:. The ``RegionPass`` class; ------------------------. ``RegionPass`` is similar to :ref:`LoopPass <writing-an-llvm-pass-LoopPass>`,; but executes on each single entry single exit region in the function.; ``RegionPass`` processes regions in nested order such that the outer most; region is processed last. ``RegionPass`` subclasses are allowed to update the region tree by using the; ``RGPassManager`` interface. You may override three virtual methods of; ``RegionPass`` to implement your own region pass. All these methods should; return ``true`` if they modified the program, or ``false`` if they did not. The ``doInitialization(Region *, RGPassManager &)`` method; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. .. code-block:: c++. virtual bool doInitialization(Region *, RGPassManager &RGM);. The ``doInitialization`` method is designed to do simple initialization type of; stuff that does not depend on the functions being processed. The; ``doInitialization`` method call is not scheduled to overlap with any other; pass executions (thus it should be very fast). ``RPPassManager`` interface; should be used to access ``Function`` or ``Module`` level analysis information. .. _writing-an-llvm-pass-runOnRegion:. The ``runOnRegion`` method; ^^^^^^^^^^^^^^^^^^^^^^^^^^. .. code-block:: c++. virtual bool runOnRegion(Region *, RGPassManager &RGM) = 0;. The ``runOnRegion`` method must be implemented by your subclass to do the; transformation or analysis work of your pass. As usual, a true value should be; returned if the region is modified. ``RGPassManager`` interface should be used to; update region tree. The ``doFinalization()`` method; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. .. code-block:: c++. virtual bool doFinalization();. The ``doFinalization`` method is an infrequently used method that is called; when the pass framework has finished calling :ref:`runOnReg",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/WritingAnLLVMPass.rst:23550,simpl,simple,23550,interpreter/llvm-project/llvm/docs/WritingAnLLVMPass.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/WritingAnLLVMPass.rst,1,['simpl'],['simple']
Usability,"pad in this; picture illustrates the **`THStack`** drawn with the `""nostack""`; option. ``` {.cpp}; hs->Draw(""nostack"");; ```. Next is a simple example, for a more complex one see; `$ROOTSYS/tutorials/hist/hstack.C.`. ``` {.cpp}; {; THStack hs(""hs"",""test stacked histograms"");; TH1F *h1 = new TH1F(""h1"",""test hstack"",100,-4,4);; h1->FillRandom(""gaus"",20000);; h1->SetFillColor(kRed);; hs.Add(h1);; TH1F *h2 = new TH1F(""h2"",""test hstack"",100,-4,4);; h2->FillRandom(""gaus"",15000);; h2->SetFillColor(kBlue);; hs.Add(h2);; TH1F *h3 = new TH1F(""h3"",""test hstack"",100,-4,4);; h3->FillRandom(""gaus"",10000);; h3->SetFillColor(kGreen);; hs.Add(h3);; TCanvas c1(""c1"",""stacked hists"",10,10,700,900);; c1.Divide (1,2);; c1.cd(1);; hs.Draw();; c1.cd(2);; hs->Draw(""nostack"");; }; ```. ## TH2Poly. `TH2Poly` is a 2D Histogram class allowing to define polygonal bins of; arbitrary shape. Each bin in the `TH2Poly` histogram is a `TH2PolyBin` object.; `TH2PolyBin` is a very simple class containing the vertices and; contents of the polygonal bin as well as several related functions. Bins are defined using one of the `AddBin()` methods. The bin; definition should be done before filling. The following very simple macro shows how to build and fill a; `TH2Poly`:. ``` {.cpp}; {; TH2Poly *h2p = new TH2Poly();; Double_t x1[] = {0, 5, 5};; Double_t y1[] = {0, 0, 5};; Double_t x2[] = {0, -1, -1, 0};; Double_t y2[] = {0, 0, -1, -1};; Double_t x3[] = {4, 3, 0, 1, 2.4};; Double_t y3[] = {4, 3.7, 1, 4.7, 3.5};; h2p->AddBin(3, x1, y1);; h2p->AddBin(3, x2, y2);; h2p->AddBin(3, x3, y3);; h2p->Fill( 3, 1, 3); // fill bin 1; h2p->Fill(-0.5, -0.5, 7); // fill bin 2; h2p->Fill(-0.7, -0.5, 1); // fill bin 2; h2p->Fill( 1, 3, 5); // fill bin 3; }; ```. More examples can bin found in `$ROOTSYS/tutorials/hist/th2poly*.C`. ![A TH2Poly histogram example](pictures/th2poly1.png). ## Profile Histograms. Profile histograms are in many cases an elegant replacement of; two-dimensional histograms. The relationship of two quantiti",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md:60418,simpl,simple,60418,documentation/users-guide/Histograms.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md,1,['simpl'],['simple']
Usability,"pe= 67, offset= 0, len=1, method=0; i= 1, TAttLine type= 0, offset= 28, len=1, method=142484480; i= 2, TAttFill type= 0, offset= 40, len=1, method=142496992; i= 3, TAttMarker type= 0, offset= 48, len=1, method=142509704; i= 4, fNcells type= 3, offset= 60, len=1, method=0; i= 5, fXaxis type= 61, offset= 64, len=1, method=1081287424; i= 6, fYaxis type= 61, offset=192, len=1, method=1081287548; i= 7, fZaxis type= 61, offset=320, len=1, method=1081287676; i= 8, fBarOffset type= 22, offset=448, len=2, method=0; i= 9, fEntries type= 28, offset=452, len=8, method=0; i=10, fContour type= 62, offset=516, len=1, method=1081287804; i=11, fSumw2 type= 62, offset=528, len=1, method=1081287924; i=12, fOption type= 65, offset=540, len=1, method=1081288044; i=13, fFunctions type= 63, offset=548, len=1, method=1081288164; ```. ### Optimized StreamerInfo. The entries starting with ""`i = 0`"" is the optimized format of the; `StreamerInfo`. Consecutive data members of the same simple type and; size are collapsed and read at once into an array for performance; optimization. ``` {.cpp}; i= 0, TNamed type= 67, offset= 0, len=1, method=0; i= 1, TAttLine type= 0, offset= 28, len=1, method=142484480; i= 2, TAttFill type= 0, offset= 40, len=1, method=142496992; i= 3, TAttMarker type= 0, offset= 48, len=1, method=142509704; ```. For example, the five data members beginning with `fEnties `and the; three data members beginning with `fMaximum`, are put into an array; called `fEntries` (`i = 9`) with the length 8. ``` {.cpp}; i= 9, fEntries type= 28, offset=452, len=8, method=0; ```. Only simple type data members are combined, object data members are not; combined. For example the three axis data members remain separate. The; ""method"" is a handle to the method that reads the object. ### Automatic Schema Evolution. When a class is defined in ROOT, it must include the `ClassDef` macro as; the last line in the header file inside the class definition. The syntax; is:. ``` {.cpp}; ClassDef(<ClassName>,<V",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md:74969,simpl,simple,74969,documentation/users-guide/InputOutput.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md,1,['simpl'],['simple']
Usability,"pecific address; space and a generic type value to produce an updated memory location; description. This allows them to continue to be used to offset an address. To generalize offsetting to any location description, including location; descriptions that describe when bytes are in registers, are implicit, or a; composite of these, the ``DW_OP_LLVM_offset``, ``DW_OP_LLVM_offset_uconst``, and; ``DW_OP_LLVM_bit_offset`` offset operations are added. The offset operations can operate on location storage of any size. For example,; implicit location storage could be any number of bits in size. It is simpler to; define offsets that exceed the size of the location storage as being an; evaluation error, than having to force an implementation to support potentially; infinite precision offsets to allow it to correctly track a series of positive; and negative offsets that may transiently overflow or underflow, but end up in; range. This is simple for the arithmetic operations as they are defined in terms; of two's complement arithmetic on a base type of a fixed size. Therefore, the; offset operation define that integer overflow is ill-formed. This is in contrast; to the ``DW_OP_plus``, ``DW_OP_plus_uconst``, and ``DW_OP_minus`` arithmetic; operations which define that it causes wrap-around. Having the offset operations allows ``DW_OP_push_object_address`` to push a; location description that may be in a register, or be an implicit value. The; DWARF expression of ``DW_TAG_ptr_to_member_type`` can use the offset operations; without regard to what kind of location description was pushed. Since; :ref:`amdgpu-dwarf-allow-location-description-on-the-dwarf-evaluation-stack` has; generalized location storage to be bit indexable, ``DW_OP_LLVM_bit_offset``; generalizes DWARF to work with bit fields. This is generally not possible in; DWARF Version 5. The ``DW_OP_*piece`` operations only allow literal indices. A way to use a; computed offset of an arbitrary location description (such as a v",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst:11906,simpl,simple,11906,interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,1,['simpl'],['simple']
Usability,"perator NSComparisonResult (^)(id, id)() const;. This conversion function returns a new block that simply forwards the two; parameters to the lambda object (which it captures by copy), then returns the; result. The returned block is first copied (with ``Block_copy``) and then; autoreleased. As an optimization, if a lambda expression is immediately; converted to a block pointer (as in the first example, above), then the block; is not copied and autoreleased: rather, it is given the same lifetime as a; block literal written at that point in the program, which avoids the overhead; of copying a block to the heap in the common case. The conversion from a lambda to a block pointer is only available in; Objective-C++, and not in C++ with blocks, due to its use of Objective-C memory; management (autorelease). Object Literals and Subscripting; --------------------------------. Clang provides support for :doc:`Object Literals and Subscripting; <ObjectiveCLiterals>` in Objective-C, which simplifies common Objective-C; programming patterns, makes programs more concise, and improves the safety of; container creation. There are several feature macros associated with object; literals and subscripting: ``__has_feature(objc_array_literals)`` tests the; availability of array literals; ``__has_feature(objc_dictionary_literals)``; tests the availability of dictionary literals;; ``__has_feature(objc_subscripting)`` tests the availability of object; subscripting. Objective-C Autosynthesis of Properties; ---------------------------------------. Clang provides support for autosynthesis of declared properties. Using this; feature, clang provides default synthesis of those properties not declared; @dynamic and not having user provided backing getter and setter methods.; ``__has_feature(objc_default_synthesize_properties)`` checks for availability; of this feature in version of clang being used. .. _langext-objc-retain-release:. Objective-C retaining behavior attributes; ----------------------",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:77066,simpl,simplifies,77066,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst,1,['simpl'],['simplifies']
Usability,"piler-rt`` --- to the public.; It is the Release Manager's responsibility to ensure that a high quality build; of LLVM is released. If you're looking for the document on how to test the release candidates and; create the binary packages, please refer to the :doc:`ReleaseProcess` instead. .. _timeline:. Release Timeline; ================. LLVM is released on a time based schedule --- with major releases roughly; every 6 months. In between major releases there may be dot releases.; The release manager will determine if and when to make a dot release based; on feedback from the community. Typically, dot releases should be made if; there are large number of bug-fixes in the stable branch or a critical bug; has been discovered that affects a large number of users. Unless otherwise stated, dot releases will follow the same procedure as; major releases. Annual Release Schedule; -----------------------. Here is the annual release schedule for LLVM. This is meant to be a; guide, and release managers are not required to follow this exactly.; Releases should be tagged on Tuesdays. =============================== =========================; Release Approx. Date; =============================== =========================; *release branch: even releases* *4th Tue in January*; *release branch: odd releases* *4th Tue in July*; X.1.0-rc1 3 days after branch.; X.1.0-rc2 2 weeks after branch.; X.1.0-rc3 4 weeks after branch; **X.1.0-final** **6 weeks after branch**; **X.1.1** **8 weeks after branch**; **X.1.2** **10 weeks after branch**; **X.1.3** **12 weeks after branch**; **X.1.4** **14 weeks after branch**; **X.1.5** **16 weeks after branch**; **X.1.6 (if necessary)** **18 weeks after branch**; =============================== =========================. Release Process Summary; -----------------------. * Announce release schedule to the LLVM community and update the website. Do; this at least 3 weeks before the -rc1 release. * Create release branch and begin release process. * Send ou",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToReleaseLLVM.rst:1234,guid,guide,1234,interpreter/llvm-project/llvm/docs/HowToReleaseLLVM.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToReleaseLLVM.rst,1,['guid'],['guide']
Usability,"plements an LLVM target. This will permit the target name to be used with; the :option:`-march` option so that code can be generated for that target. .. option:: -meabi=[default|gnu|4|5]. Specify which EABI version should conform to. Valid EABI versions are *gnu*,; *4* and *5*. Default value (*default*) depends on the triple. .. option:: -stack-size-section. Emit the .stack_sizes section which contains stack size metadata. The section; contains an array of pairs of function symbol values (pointer size) and stack; sizes (unsigned LEB128). The stack size values only include the space allocated; in the function prologue. Functions with dynamic stack allocations are not; included. .. option:: -remarks-section. Emit the __remarks (MachO) section which contains metadata about remark; diagnostics. Tuning/Configuration Options; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~. .. option:: --print-after-isel. Print generated machine code after instruction selection (useful for debugging). .. option:: --regalloc=<allocator>. Specify the register allocator to use.; Valid register allocators are:. *basic*. Basic register allocator. *fast*. Fast register allocator. It is the default for unoptimized code. *greedy*. Greedy register allocator. It is the default for optimized code. *pbqp*. Register allocator based on 'Partitioned Boolean Quadratic Programming'. .. option:: --spiller=<spiller>. Specify the spiller to use for register allocators that support it. Currently; this option is used only by the linear scan register allocator. The default; ``spiller`` is *local*. Valid spillers are:. *simple*. Simple spiller. *local*. Local spiller. Intel IA-32-specific Options; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~. .. option:: --x86-asm-syntax=[att|intel]. Specify whether to emit assembly code in AT&T syntax (the default) or Intel; syntax. EXIT STATUS; -----------. If :program:`llc` succeeds, it will exit with 0. Otherwise, if an error; occurs, it will exit with a non-zero value. SEE ALSO; --------. :manpage:`lli(1)`; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llc.rst:5995,simpl,simple,5995,interpreter/llvm-project/llvm/docs/CommandGuide/llc.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llc.rst,1,['simpl'],['simple']
Usability,"point, double low, double high) ###. Scans the value of the user function by varying parameter number; $\mbox{par}$, leaving all other parameters fixed at the current; value. If $\mbox{par}$ is not specified, all variable parameters are; scanned in sequence. The number of points $\mbox{npoints}$ in the; scan is 40 by default, and cannot exceed 100. The range of the scan is; by default 2 standard deviations on each side of the current best value,; but can be specified as from $\mbox{low}$ to $\mbox{high}$.; After each scan, if a new minimum is found, the best parameter values; are retained as start values for future scans or minimizations. The; curve resulting from each scan can be plotted on the output terminal; using MnPlot [api:plot] in order to show the approximate behaviour of; the function. ### ScanMinimizer ###. Although the $\mbox{SCAN}$ method is not intended for minimization; it can be used as a minimizer in its most primitive form. ## MnSimplex and SimplexMinimizer ##. [api:simplex]. $\mbox{SIMPLEX}$ is a function minimization method using the simplex; method of Nelder and Mead. MnSimplex provides minimization of the; function by the method of $\mbox{SIMPLEX}$ and the functionality for; parameters interaction. It also retains the result from the last; minimization in case the user may want to do subsequent minimization; steps with parameter interactions in between the minimization requests.; The minimization is done by the SimplexMinimizer. Minimization of the; function can be done by directly using the SimplexMinimizer if no; parameters interaction is required. As $\mbox{SIMPLEX}$ is a; stepping method it does not produce a covariance matrix. ### MnSimplex(const FCNBase&, const std::vector$<$double$>$&,\; const std::vector$<$double$>$&, unsigned int) ###. Constructor for the minimal required interface: $\mbox{FCN}$ and; starting values for parameters and uncertainties. Optional the strategy; level in MnStrategy can be specified. ### MnSimplex(const FCNBase",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md:48406,simpl,simplex,48406,documentation/minuit2/Minuit2.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md,1,['simpl'],['simplex']
Usability,"port for folding control flow into faulting machine instructions. :doc:`Atomics`; Information about LLVM's concurrency model. :doc:`ExceptionHandling`; This document describes the design and implementation of exception handling; in LLVM. :doc:`Extensions`; LLVM-specific extensions to tools and formats LLVM seeks compatibility with. :doc:`HowToSetUpLLVMStyleRTTI`; How to make ``isa<>``, ``dyn_cast<>``, etc. available for clients of your; class hierarchy. :doc:`BlockFrequencyTerminology`; Provides information about terminology used in the ``BlockFrequencyInfo``; analysis pass. :doc:`BranchWeightMetadata`; Provides information about Branch Prediction Information. :doc:`GetElementPtr`; Answers to some very frequent questions about LLVM's most frequently; misunderstood instruction. :doc:`ScudoHardenedAllocator`; A library that implements a security-hardened `malloc()`. :doc:`MemTagSanitizer`; Security hardening for production code aiming to mitigate memory; related vulnerabilities. Based on the Armv8.5-A Memory Tagging Extension. :doc:`Dependence Graphs <DependenceGraphs/index>`; A description of the design of the various dependence graphs such as; the DDG (Data Dependence Graph). :doc:`SpeculativeLoadHardening`; A description of the Speculative Load Hardening mitigation for Spectre v1. :doc:`SegmentedStacks`; This document describes segmented stacks and how they are used in LLVM. :doc:`MarkedUpDisassembly`; This document describes the optional rich disassembly output syntax. :doc:`StackMaps`; LLVM support for mapping instruction addresses to the location of; values and allowing code to be patched. :doc:`Coroutines`; LLVM support for coroutines. :doc:`PointerAuth`; A description of pointer authentication, its LLVM IR representation, and its; support in the backend. :doc:`YamlIO`; A reference guide for using LLVM's YAML I/O library. :doc:`ConvergenceAndUniformity`; A description of uniformity analysis in the presence of irreducible; control flow, and its implementation.; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Reference.rst:5316,guid,guide,5316,interpreter/llvm-project/llvm/docs/Reference.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Reference.rst,1,['guid'],['guide']
Usability,"ports a; limited number of ARM architectures. It does not yet fully support; ARMv5, for example. PowerPC; ^^^^^^^. The support for PowerPC (especially PowerPC64) is considered stable; on Linux and FreeBSD: it has been tested to correctly compile many; large C and C++ codebases. PowerPC (32bit) is still missing certain; features (e.g. PIC code on ELF platforms). Other platforms; ^^^^^^^^^^^^^^^. clang currently contains some support for other architectures (e.g. Sparc);; however, significant pieces of code generation are still missing, and they; haven't undergone significant testing. clang contains limited support for the MSP430 embedded processor, but; both the clang support and the LLVM backend support are highly; experimental. Other platforms are completely unsupported at the moment. Adding the; minimal support needed for parsing and semantic analysis on a new; platform is quite easy; see ``lib/Basic/Targets.cpp`` in the clang source; tree. This level of support is also sufficient for conversion to LLVM IR; for simple programs. Proper support for conversion to LLVM IR requires; adding code to ``lib/CodeGen/CGCall.cpp`` at the moment; this is likely to; change soon, though. Generating assembly requires a suitable LLVM; backend. Operating System Features and Limitations; -----------------------------------------. Windows; ^^^^^^^. Clang has experimental support for targeting ""Cygming"" (Cygwin / MinGW); platforms. See also :ref:`Microsoft Extensions <c_ms>`. Cygwin; """""""""""". Clang works on Cygwin-1.7. MinGW32; """""""""""""". Clang works on some mingw32 distributions. Clang assumes directories as; below;. - ``C:/mingw/include``; - ``C:/mingw/lib``; - ``C:/mingw/lib/gcc/mingw32/4.[3-5].0/include/c++``. On MSYS, a few tests might fail. MinGW-w64; """""""""""""""""". For 32-bit (i686-w64-mingw32), and 64-bit (x86\_64-w64-mingw32), Clang; assumes as below;. - ``GCC versions 4.5.0 to 4.5.3, 4.6.0 to 4.6.2, or 4.7.0 (for the C++ header search path)``; - ``some_directory/bin/gcc.exe``; - ``s",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:162673,simpl,simple,162673,interpreter/llvm-project/clang/docs/UsersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst,1,['simpl'],['simple']
Usability,"pport is experimental::. clang -g -O1 -fsanitize=fuzzer mytarget.c # Builds the fuzz target w/o sanitizers; clang -g -O1 -fsanitize=fuzzer,address mytarget.c # Builds the fuzz target with ASAN; clang -g -O1 -fsanitize=fuzzer,signed-integer-overflow mytarget.c # Builds the fuzz target with a part of UBSAN; clang -g -O1 -fsanitize=fuzzer,memory mytarget.c # Builds the fuzz target with MSAN. This will perform the necessary instrumentation, as well as linking with the libFuzzer library.; Note that ``-fsanitize=fuzzer`` links in the libFuzzer's ``main()`` symbol. If modifying ``CFLAGS`` of a large project, which also compiles executables; requiring their own ``main`` symbol, it may be desirable to request just the; instrumentation without linking::. clang -fsanitize=fuzzer-no-link mytarget.c. Then libFuzzer can be linked to the desired driver by passing in; ``-fsanitize=fuzzer`` during the linking stage. .. _libfuzzer-corpus:. Corpus; ------. Coverage-guided fuzzers like libFuzzer rely on a corpus of sample inputs for the; code under test. This corpus should ideally be seeded with a varied collection; of valid and invalid inputs for the code under test; for example, for a graphics; library the initial corpus might hold a variety of different small PNG/JPG/GIF; files. The fuzzer generates random mutations based around the sample inputs in; the current corpus. If a mutation triggers execution of a previously-uncovered; path in the code under test, then that mutation is saved to the corpus for; future variations. LibFuzzer will work without any initial seeds, but will be less; efficient if the library under test accepts complex,; structured inputs. The corpus can also act as a sanity/regression check, to confirm that the; fuzzing entrypoint still works and that all of the sample inputs run through; the code under test without problems. If you have a large corpus (either generated by fuzzing or acquired by other means); you may want to minimize it while still preserving the f",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LibFuzzer.rst:4066,guid,guided,4066,interpreter/llvm-project/llvm/docs/LibFuzzer.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LibFuzzer.rst,1,['guid'],['guided']
Usability,"pport the gcc extension for forward-declaring; function parameters; this has not shown up in any real-world code; yet, though, so it might never be implemented. This is not a complete list; if you find an unsupported extension; missing from this list, please send an e-mail to cfe-dev. This list; currently excludes C++; see :ref:`C++ Language Features <cxx>`. Also, this; list does not include bugs in mostly-implemented features; please see; the `bug; tracker <https://bugs.llvm.org/buglist.cgi?quicksearch=product%3Aclang+component%3A-New%2BBugs%2CAST%2CBasic%2CDriver%2CHeaders%2CLLVM%2BCodeGen%2Cparser%2Cpreprocessor%2CSemantic%2BAnalyzer>`_; for known existing bugs (FIXME: Is there a section for bug-reporting; guidelines somewhere?). Intentionally unsupported GCC extensions; ----------------------------------------. - clang does not support the gcc extension that allows variable-length; arrays in structures. This is for a few reasons: one, it is tricky to; implement, two, the extension is completely undocumented, and three,; the extension appears to be rarely used. Note that clang *does*; support flexible array members (arrays with a zero or unspecified; size at the end of a structure).; - GCC accepts many expression forms that are not valid integer constant; expressions in bit-field widths, enumerator constants, case labels,; and in array bounds at global scope. Clang also accepts additional; expression forms in these contexts, but constructs that GCC accepts due to; simplifications GCC performs while parsing, such as ``x - x`` (where ``x`` is a; variable) will likely never be accepted by Clang.; - clang does not support ``__builtin_apply`` and friends; this extension; is extremely obscure and difficult to implement reliably. .. _c_ms:. Microsoft extensions; --------------------. clang has support for many extensions from Microsoft Visual C++. To enable these; extensions, use the ``-fms-extensions`` command-line option. This is the default; for Windows targets. Clan",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:135737,undo,undocumented,135737,interpreter/llvm-project/clang/docs/UsersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst,1,['undo'],['undocumented']
Usability,"pproach is to use an std::vector (or other sequential container) with; std::sort+std::unique to remove duplicates. This approach works really well if; your usage pattern has these two distinct phases (insert then query), and can be; coupled with a good choice of :ref:`sequential container <ds_sequential>`. This combination provides the several nice properties: the result data is; contiguous in memory (good for cache locality), has few allocations, is easy to; address (iterators in the final vector are just indices or pointers), and can be; efficiently queried with a standard binary search (e.g.; ``std::lower_bound``; if you want the whole range of elements comparing; equal, use ``std::equal_range``). .. _dss_smallset:. llvm/ADT/SmallSet.h; ^^^^^^^^^^^^^^^^^^^. If you have a set-like data structure that is usually small and whose elements; are reasonably small, a ``SmallSet<Type, N>`` is a good choice. This set has; space for N elements in place (thus, if the set is dynamically smaller than N,; no malloc traffic is required) and accesses them with a simple linear search.; When the set grows beyond N elements, it allocates a more expensive; representation that guarantees efficient access (for most types, it falls back; to :ref:`std::set <dss_set>`, but for pointers it uses something far better,; :ref:`SmallPtrSet <dss_smallptrset>`. The magic of this class is that it handles small sets extremely efficiently, but; gracefully handles extremely large sets without loss of efficiency. .. _dss_smallptrset:. llvm/ADT/SmallPtrSet.h; ^^^^^^^^^^^^^^^^^^^^^^. ``SmallPtrSet`` has all the advantages of ``SmallSet`` (and a ``SmallSet`` of; pointers is transparently implemented with a ``SmallPtrSet``). If more than N; insertions are performed, a single quadratically probed hash table is allocated; and grows as needed, providing extremely efficient access (constant time; insertion/deleting/queries with low constant factors) and is very stingy with; malloc traffic. Note that, unlike :",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:78230,simpl,simple,78230,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,1,['simpl'],['simple']
Usability,"present a total of *n* bits. .. productionlist::; SimpleValue5: ""["" `ValueList` ""]"" [""<"" `Type` "">""]. This value is a list initializer (note the brackets). The values in brackets; are the elements of the list. The optional :token:`Type` can be used to; indicate a specific element type; otherwise the element type is inferred; from the given values. TableGen can usually infer the type, although; sometimes not when the value is the empty list (``[]``). .. productionlist::; SimpleValue6: ""("" `DagArg` [`DagArgList`] "")""; DagArgList: `DagArg` ("","" `DagArg`)*; DagArg: `Value` ["":"" `TokVarName`] | `TokVarName`. This represents a DAG initializer (note the parentheses). The first; :token:`DagArg` is called the ""operator"" of the DAG and must be a record.; See `Directed acyclic graphs (DAGs)`_ for more details. .. productionlist::; SimpleValue7: `TokIdentifier`. The resulting value is the value of the entity named by the identifier. The; possible identifiers are described here, but the descriptions will make more; sense after reading the remainder of this guide. .. The code for this is exceptionally abstruse. These examples are a; best-effort attempt. * A template argument of a ``class``, such as the use of ``Bar`` in::. class Foo <int Bar> {; int Baz = Bar;; }. * The implicit template argument ``NAME`` in a ``class`` or ``multiclass``; definition (see `NAME`_). * A field local to a ``class``, such as the use of ``Bar`` in::. class Foo {; int Bar = 5;; int Baz = Bar;; }. * The name of a record definition, such as the use of ``Bar`` in the; definition of ``Foo``::. def Bar : SomeClass {; int X = 5;; }. def Foo {; SomeClass Baz = Bar;; }. * A field local to a record definition, such as the use of ``Bar`` in::. def Foo {; int Bar = 5;; int Baz = Bar;; }. Fields inherited from the record's parent classes can be accessed the same way. * A template argument of a ``multiclass``, such as the use of ``Bar`` in::. multiclass Foo <int Bar> {; def : SomeClass<Bar>;; }. * A variable defined",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TableGen/ProgRef.rst:16447,guid,guide,16447,interpreter/llvm-project/llvm/docs/TableGen/ProgRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TableGen/ProgRef.rst,1,['guid'],['guide']
Usability,"procedure`` debugging information entry. Then the; ``DW_AT_location`` attribute expression is always executed separately; and pushes a location description (that may have multiple single; location descriptions), and the ``DW_AT_LLVM_proc`` attribute expression; is always executed on the same stack and can leave anything on the; stack. The ``DW_AT_LLVM_proc`` attribute could have the new classes; ``exprproc``, ``loclistproc``, and ``loclistsptrproc`` to indicate that; the expression is executed on the same stack. ``exprproc`` is the same; encoding as ``exprloc``. ``loclistproc`` and ``loclistsptrproc`` are the; same encoding as their non-\ ``proc`` counterparts, except the DWARF is; ill-formed if the location list does not match exactly one location list; entry and a default entry is required. These forms indicate explicitly; that the matched single operation expression must be executed on the; same stack. This is better than ad hoc special rules for ``loclistproc``; and ``loclistsptrproc`` which are currently clearly defined to always; return a location description. The producer then explicitly indicates; the intent through the attribute classes. Such a change would be a breaking change for how GDB implements; ``DW_OP_call*``. However, are the breaking cases actually occurring in; practice? GDB could implement the current approach for DWARF Version 5,; and the new semantics for DWARF Version 6 which has been done for some; other features. Another option is to limit the execution to be on the same stack only to; the evaluation of an expression E that is the value of a; ``DW_AT_location`` attribute of a ``DW_TAG_dwarf_procedure`` debugging; information entry. The DWARF would be ill-formed if E is a location list; expression that does not match exactly one location list entry. In all; other cases the evaluation of an expression E that is the value of a; ``DW_AT_location`` attribute would evaluate E with the current context,; except the result kind is a location descrip",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst:79135,clear,clearly,79135,interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,1,['clear'],['clearly']
Usability,"produced when all the tree events are plotted.](pictures/para3.png). If the 24000 events are plotted as solid lines and no special techniques; are used to clarify the picture, the result is the previous picture; which is very cluttered and useless. To improve the readability of the; Parallel Coordinates output and to explore interactively the data set,; many techniques are available. We have implemented a few in ROOT. First; of all, in order to show better where the clusters on the various axes; are, a 1D histogram is associated to each axis. These histograms; (one per axis) are filled according to the number of lines passing; through the bins. ![The histogram’s axis can be represented with colors or as bar charts.](pictures/para4.png). These histograms can be represented which colors (get from a palette; according to the bin contents) or as bar charts. Both representations; can be cumulated on the same plot. This technique allows seeing clearly; where the clusters are on an individual axis but it does not give any; hints about the correlations between the axes. Avery simple technique allows to make the clusters appearing:; Instead of painting solid lines we paint dotted lines. The cluttering of; each individual line is reduced and the clusters show clearly as we can; see on the next figure. The spacing between the dots is a parameter which; can be adjusted in order to get the best results. ![Using dotted lines is a very simple method to reduce the cluttering.](pictures/para5.png). Interactivity is a very important aspect of the Parallel Coordinates plots.; To really explore the data set it is essential to act directly with the; events and the axes. For instance, changing the axes order may show clusters; which were not visible in a different order. On the next figure the axes; order has been changed interactively. We can see that many more clusters; appear and all the “random spheres” we put in the data set are now; clearly visible. Having moved the variables `u,v,",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:99044,clear,clearly,99044,documentation/users-guide/Trees.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md,1,['clear'],['clearly']
Usability,"program(LLVM_LIT; NAMES llvm-lit lit.py lit; PATHS ""${ROOT_LLVM_MAIN_SRC_DIR}/utils/lit""; DOC ""Path to lit.py""); endif(). if(LLVM_LIT); # Define the default arguments to use with 'lit', and an option for the user; # to override.; set(LIT_ARGS_DEFAULT ""-sv""); if (MSVC OR XCODE); set(LIT_ARGS_DEFAULT ""${LIT_ARGS_DEFAULT} --no-progress-bar""); endif(); set(LLVM_LIT_ARGS ""${LIT_ARGS_DEFAULT}"" CACHE STRING ""Default options for lit""); set(LIT_COMMAND ""${LLVM_LIT}"" CACHE STRING ""Path to the LLVM LIT.""). # On Win32 hosts, provide an option to specify the path to the GnuWin32 tools.; if( WIN32 AND NOT CYGWIN ); set(LLVM_LIT_TOOLS_DIR """" CACHE PATH ""Path to GnuWin32 tools""); endif(); else(); set(LLVM_INCLUDE_TESTS OFF); endif(); endif(). set(LLVM_INCLUDE_DIRS ${LLVM_MAIN_INCLUDE_DIR}; CACHE STRING ""System LLVM include directories.""; ). # We checked above that LLVM_VERSION is what we require in ROOT_LLVM_VERSION_REQUIRED_MAJOR.; # To simplify code, just forward that requirement to the rest of ROOT, for example to; # construct the resource directory in core/clingutils.; set(LLVM_VERSION_MAJOR ${ROOT_LLVM_VERSION_REQUIRED_MAJOR} PARENT_SCOPE). # We are in the case of NOT builtin_llvm; if (builtin_clang); # remove clang-cpp from CLANG_LINKS_TO_CREATE to avoid clashes with; # install-clang-cpp target defined by LLVM's cmake module; set(CLANG_LINKS_TO_CREATE clang++ clang-cl). # Disable linking against shared LLVM; set(LLVM_LINK_LLVM_DYLIB OFF). add_subdirectory(llvm-project/clang EXCLUDE_FROM_ALL); endif(builtin_clang). set( CLANG_BUILT_STANDALONE 1 ); set(BACKEND_PACKAGE_STRING ""LLVM ${LLVM_PACKAGE_VERSION}""); endif(builtin_llvm). if (builtin_clang); if (builtin_llvm); # For builtin LLVM this is set in interpreter/llvm-project/llvm/CMakeLists.txt; set(Clang_DIR ""${LLVM_BINARY_DIR}/tools/clang/""); else(); set(Clang_DIR ""${CMAKE_BINARY_DIR}/interpreter/llvm-project/clang/""); set(Clang_Config_ExtraPathHints ""${Clang_DIR}cmake/modules/CMakeFiles""); endif(); set(CLANG_INCLUDE_DIRS; ${CM",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/CMakeLists.txt:19084,simpl,simplify,19084,interpreter/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/CMakeLists.txt,1,['simpl'],['simplify']
Usability,"prove the readability of the; Parallel Coordinates output and to explore interactively the data set,; many techniques are available. We have implemented a few in ROOT. First; of all, in order to show better where the clusters on the various axes; are, a 1D histogram is associated to each axis. These histograms; (one per axis) are filled according to the number of lines passing; through the bins. ![The histogram’s axis can be represented with colors or as bar charts.](pictures/para4.png). These histograms can be represented which colors (get from a palette; according to the bin contents) or as bar charts. Both representations; can be cumulated on the same plot. This technique allows seeing clearly; where the clusters are on an individual axis but it does not give any; hints about the correlations between the axes. Avery simple technique allows to make the clusters appearing:; Instead of painting solid lines we paint dotted lines. The cluttering of; each individual line is reduced and the clusters show clearly as we can; see on the next figure. The spacing between the dots is a parameter which; can be adjusted in order to get the best results. ![Using dotted lines is a very simple method to reduce the cluttering.](pictures/para5.png). Interactivity is a very important aspect of the Parallel Coordinates plots.; To really explore the data set it is essential to act directly with the; events and the axes. For instance, changing the axes order may show clusters; which were not visible in a different order. On the next figure the axes; order has been changed interactively. We can see that many more clusters; appear and all the “random spheres” we put in the data set are now; clearly visible. Having moved the variables `u,v,w` after the variables; `x,y,z` the correlation between these two sets of variables is clear also. ![Axis order is very important to show clusters.](pictures/para6.png). To pursue further data sets exploration we have implemented the possibility; to defi",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:99362,clear,clearly,99362,documentation/users-guide/Trees.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md,1,['clear'],['clearly']
Usability,"ps://root.cern.ch/js/3.9/) and the [JSRoot 3.9 release notes](https://github.com/linev/jsroot/releases/tag/3.9). ## Class Reference Guide. The ROOT [reference guide](https://root.cern.ch/doc/master/index.html) is moving; to the Doxygen system. Doxygen is the de-facto standard for code documentation. It offers; many nice features we are now exploring and trying to get the best of them. Having; [MathJax rendered math formula](https://root.cern.ch/doc/master/classTSpectrum2.html#a482a7f144b9cc1b0405d0ac0d8cc9bbb); is one of them. The documentation can be structured in a more logical way; [using groups](https://root.cern.ch/doc/master/modules.html). Still there is a lot; to do but big progresses have been done. We developed also a Doxygen filter allowing; to execute macros given as examples in the documentation and show the; [resulting picture directly in the documentation](https://root.cern.ch/doc/master/classTHistPainter.html#HP16). ## Tutorials. [The tutorials](https://root.cern.ch/doc/master/group__Tutorials.html) in; `$ROOTSYS/tutorials` are also presented on the web thanks to Doxygen. They; are now part of the reference guide allowing nice cross-referencing with the; classes documentation. Here also a filter has been developed to generate; [the resulting picture](https://root.cern.ch/doc/master/ContourList_8C.html). ## Build, Configuration and Testing Infrastructure. ROOT uses the CMake cross-platform build-generator tool as a primary build system. CMake does not build the project, it generates the files needed by your build tool (GNU make, Ninja, Visual Studio, etc) for building ROOT. The classic build with configure/make is is still available but it will not be evolving with the new features of ROOT. We added full support for C++14. Minor changes in the build system:. - Renamed build option POSTGRESQL_LIBRARIES to POSTGRESQL_LIBRARY; - Added build option `builtin_openssl` to build OpenSSL internally. This is specially needed for the latest Mac OSX (El Capitan); ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v606/index.md:24558,guid,guide,24558,README/ReleaseNotes/v606/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v606/index.md,1,['guid'],['guide']
Usability,"ques; are used to clarify the picture, the result is the previous picture; which is very cluttered and useless. To improve the readability of the; Parallel Coordinates output and to explore interactively the data set,; many techniques are available. We have implemented a few in ROOT. First; of all, in order to show better where the clusters on the various axes; are, a 1D histogram is associated to each axis. These histograms; (one per axis) are filled according to the number of lines passing; through the bins. ![The histogram’s axis can be represented with colors or as bar charts.](pictures/para4.png). These histograms can be represented which colors (get from a palette; according to the bin contents) or as bar charts. Both representations; can be cumulated on the same plot. This technique allows seeing clearly; where the clusters are on an individual axis but it does not give any; hints about the correlations between the axes. Avery simple technique allows to make the clusters appearing:; Instead of painting solid lines we paint dotted lines. The cluttering of; each individual line is reduced and the clusters show clearly as we can; see on the next figure. The spacing between the dots is a parameter which; can be adjusted in order to get the best results. ![Using dotted lines is a very simple method to reduce the cluttering.](pictures/para5.png). Interactivity is a very important aspect of the Parallel Coordinates plots.; To really explore the data set it is essential to act directly with the; events and the axes. For instance, changing the axes order may show clusters; which were not visible in a different order. On the next figure the axes; order has been changed interactively. We can see that many more clusters; appear and all the “random spheres” we put in the data set are now; clearly visible. Having moved the variables `u,v,w` after the variables; `x,y,z` the correlation between these two sets of variables is clear also. ![Axis order is very important to show",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:99177,simpl,simple,99177,documentation/users-guide/Trees.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md,1,['simpl'],['simple']
Usability,"quest will be closed and you will be notified by GitHub. Review expectations; -------------------. In order to make LLVM a long-term sustainable effort, code needs to be; maintainable and well tested. Code reviews help to achieve that goal.; Especially for new contributors, that often means many rounds of reviews; and push-back on design decisions that do not fit well within the; overall architecture of the project. For your first patches, this means:. - be kind, and expect reviewers to be kind in return - LLVM has a `Code; of Conduct <https://llvm.org/docs/CodeOfConduct.html>`__;. - be patient - understanding how a new feature fits into the; architecture of the project is often a time consuming effort, and; people have to juggle this with other responsibilities in their; lives; **ping the review once a week** when there is no response;. - if you can't agree, generally the best way is to do what the reviewer; asks; we optimize for readability of the code, which the reviewer is; in a better position to judge; if this feels like it's not the right; option, you can contact the cfe-dev mailing list to get more feedback; on the direction;. Commit access; =============. Once you've contributed a handful of patches to LLVM, start to think; about getting commit access yourself. It's probably a good idea if:. - you've landed 3-5 patches of larger scope than ""fix a typo"". - you'd be willing to review changes that are closely related to yours. - you'd like to keep contributing to LLVM. Getting commit access; ---------------------. LLVM uses Git for committing changes. The details are in the `developer; policy; document <https://llvm.org/docs/DeveloperPolicy.html#obtaining-commit-access>`__. With great power; ----------------. Actually, this would be a great time to read the rest of the `developer; policy <https://llvm.org/docs/DeveloperPolicy.html>`__, too. At minimum,; you need to be subscribed to the relevant commits list before landing; changes (e.g. llvm-commits@lists.llvm.",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MyFirstTypoFix.rst:12618,feedback,feedback,12618,interpreter/llvm-project/llvm/docs/MyFirstTypoFix.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MyFirstTypoFix.rst,1,['feedback'],['feedback']
Usability,"r (GUI interface of the recorder):. New Class: TGPack; New Container class for vertical and horizontal grouping of frames.; It enforces a predictable resizing behaviour on children.; For an example of how to use it, see tutorials/eve/pack.C. TRootBrowser. Make the default url for the HTML plugin of TRootBrowser configurable via rootrc. TGTab. Added a 'Close Tab' icon in TGTabElement, allowing to close a tab element, and emitting a CloseTab(Int_t id) signal. The icon is active only on the actually activated tab.; Implement CloseTab slot usage in TRootBrowser and in TGRootIDE. TGTextEditor. Allow to execute a macro without having to save it first. TGSplitFrame. Added a new signal method Docked(TGFrame*) to notify when a embedded frame has been docked.; Added a new signal method Undocked(TGFrame*) to notify when a embedded frame has been undocked.; Added a new getter method GetUndocked() returning a pointer on undocked frame, if any. TGToolTip. Added new constructor with global x, y position.; If neither fWindow nor fPad are set use global fX, fY that was passed from outside. TGSplitter. Added option to handle frame resizing externally. TGView. Added a protection against possible negative scroll values. TGTextView. Fix bottom line not being properly updated while scrolling.; Solve a problem with vertical slider (avoid negative value when scrolling). TGTextEdit. Fix blinking cursor on some platforms/compilers. TGTextEntry. Added optional parameter 'Bool_t emit' to TGTextEntry::SetText(const char* text, Bool_t emit = kTRUE);; Made the same extension in sub-class TGNumberEntryField. TGCompositeFrame. Added new method virtual TGFrameElement* FindFrameElement(TGFrame *f) const; and use it in several TGCompositeFrame methods to simplify the code. GUIHTML; TGHtml. Implemented HTML <select> with TGListBox/TGCombobox and emit InputSelected(const char *name, const char *val) when changing selection. TGHtmlBrowser. Added the possibility to save current html page in a local file. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/doc/v522/index.html:2250,simpl,simplify,2250,gui/doc/v522/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/doc/v522/index.html,1,['simpl'],['simplify']
Usability,"r are available on Mac; OS X. These are built to run on OS X 10.7 and later.; Builds are released frequently. Often the differences between build; numbers being a few bug fixes or minor feature improvements. When using; the analyzer, we recommend that you check back here occasionally for new; builds, especially if the build you are using is more than a couple; weeks old.; The latest build is:; . Packaged builds for other platforms may eventually be provided, but; we need volunteers who are willing to help provide such regular builds.; If you wish to help contribute regular builds of the analyzer on other; platforms, please email the Clang; Developers' mailing list.; Using Packaged Builds; To use a package build, simply unpack it anywhere. If the build; archive has the name checker-XXX.tar.bz2 then the; archive will expand to a directory called checker-XXX.; You do not need to place this directory or the contents of this; directory in any special place. Uninstalling the analyzer is as simple; as deleting this directory.; Most of the files in the checker-XXX directory will; be supporting files for the analyzer that you can simply ignore. Most; users will only care about two files, which are located at the top of; the checker-XXX directory:. scan-build: scan-build is the high-level command line utility for running the analyzer; scan-view: scan-view a companion command line; utility to scan-build, scan-view is used to view; analysis results generated by scan-build. There is an option; that one can pass to scan-build to cause scan-view to; run as soon as it the analysis of a build completes. Running scan-build; For specific details on using scan-build, please see; scan-build's documentation.; To run scan-build, either add the; checker-XXX directory to your path or specify a complete; path for scan-build when running it. It is also possible to use; a symbolic link to scan-build, such one located in a directory; in your path. When scan-build runs it will automatically; det",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/installation.html:1314,simpl,simple,1314,interpreter/llvm-project/clang/www/analyzer/installation.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/installation.html,1,['simpl'],['simple']
Usability,"r bindings generation, lower memory; footprint, and isolation from preprocessor macros and compiler flags.; The use of modules is transparent, other than the requirement that they; need to be co-located with the compiled dictionary shared library. Optionally, the dictionary generation process also produces a mapping file,; which lists the libraries needed to load C++ classes on request (for details,; see the section on the class loader below). Structurally, you could have a single dictionary for a project as a whole,; but more likely a large project will have a pre-existing functional; decomposition that can be followed, with a dictionary per functional unit. Generation; ^^^^^^^^^^. There are two interfaces onto the same underlying dictionary generator:; ``rootcling`` and ``genreflex``.; The reason for having two is historic and they are not complete duplicates,; so one or the other may suit your preference better.; It is foreseen that both will be replaced once C++ modules become more; mainstream, as that will allow simplification and improved robustness. rootcling; """""""""""""""""". The first interface is called ``rootcling``::. $ rootcling; Usage: rootcling [-v][-v0-4] [-f] [out.cxx] [opts] file1.h[+][-][!] file2.h[+][-][!] ...[Linkdef.h]; For more extensive help type: /usr/local/lib/python2.7/dist-packages/cppyy_backend/bin/rootcling -h. Rather than providing command line options, the main steering of; ``rootcling`` behavior is done through; `#pragmas in a Linkdef.h <https://root.cern.ch/root/html/guides/users-guide/AddingaClass.html#the-linkdef.h-file>`_; file, with most pragmas dedicated to selecting/excluding (parts of) classes; and functions.; Additionally, the Linkdef.h file may contain preprocessor macros. The output consists of a dictionary file (to be compiled into a shared; library), a C++ module, and an optional mapping file, as described above. genreflex; """""""""""""""""". The second interface is called ``genreflex``::. $ genreflex; Generates dictionary sources and",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/utilities.rst:3760,simpl,simplification,3760,bindings/pyroot/cppyy/cppyy/doc/source/utilities.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/utilities.rst,1,['simpl'],['simplification']
Usability,"r class: PDF. Option Array Default value Predefined values Description. NSmooth No 0 − Number of smoothing iterations for the input histograms. MinNSmooth No -1 − Min number of smoothing iterations, for bins with most data. MaxNSmooth No -1 − Max number of smoothing iterations, for bins with least data. NAvEvtPerBin No 50 − Average number of events per PDF bin. Nbins No 0 − Defined number of bins for the histogram from which the PDF is created. CheckHist No False − Whether or not to check the source histogram of the PDF. PDFInterpol No Spline2 Spline0, Spline1, Spline2, Spline3, Spline5, KDE Interpolation method for reference histograms (e.g. Spline2 or KDE). KDEtype No Gauss Gauss KDE kernel type (1=Gauss). KDEiter No Nonadaptive Nonadaptive, Adaptive Number of iterations (1=non-adaptive, 2=adaptive). KDEFineFactor No 1 − Fine tuning factor for Adaptive KDE: Factor to multyply the width of the kernel. KDEborder No None None, Renorm, Mirror Border effects treatment (1=no treatment , 2=kernel renormalization, 3=sample mirroring). Configuration options for Factory running :. Configuration options reference for class: Factory. Option Array Default value Predefined values Description. V No False − Verbose flag. Color No True − Flag for coloured screen output (default: True, if in batch mode: False). Transformations No − List of transformations to test; formatting example: Transformations=I;D;P;U;G,D, for identity, decorrelation, PCA, Uniform and Gaussianisation followed by decorrelation transformations. Silent No False − Batch mode: boolean silent flag inhibiting any output from TMVA after the creation of the factory class object (default: False). DrawProgressBar No True − Draw progress bar to display training, testing and evaluation schedule (default: True). AnalysisType No Auto Classification, Regression, Multiclass, Auto Set the analysis type (Classification, Regression, Multiclass, Auto) (default: Auto). Page created on Mon Jul 29 00:06:19 2013 (© TMVA, 2006−2009). ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/tmva/UsersGuide/optionRef.html:35212,progress bar,progress bar,35212,documentation/tmva/UsersGuide/optionRef.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/tmva/UsersGuide/optionRef.html,1,['progress bar'],['progress bar']
Usability,"r document usage of multi-thread RDataFrame: edge cases in which processing of an event could start; before processing of another event finished have been removed, making it easier for user to write safe parallel RDF operations.; See the [relevant documentation](https://root.cern.ch/doc/master/classROOT_1_1RDataFrame.html#parallel-execution) for more information. ### TTreeProcessorMT; - Parallelise search of cluster boundaries for input datasets with no friends or TEntryLists. The net effect is a faster initialization time in this common case.; - Handle gracefully the presence of chains the files associated to which are corrupted.; - Reduce number of expensive `TChain::LoadTree` calls by spawning nested TBB tasks to ensure clusters of a given file will be most likely processed by the same thread. ### TTree; - TTrees can be forced to only create new baskets at event cluster boundaries.; This simplifies file layout and I/O at the cost of memory. Recommended for; simple file formats such as ntuples but not more complex data types. To; enable, invoke `tree->SetBit(TTree::kOnlyFlushAtCluster)`. ## Histogram Libraries. ## Math Libraries. ### [Clad](https://github.com/vgvassilev/clad); - Enable experimental automatic differentiation techniques to compute; derivatives and gradients of functions. Automatic differentiation is; superior to the slow symbolic or often inaccurate numerical differentiation.; It uses the fact that every computer program can be divided into a set of; elementary operations (-,+,*,/) and functions (sin, cos, log, etc). By; applying the chain rule repeatedly to these operations, derivatives of; arbitrary order can be computed.; - Implement experimental `TFormula::GradientPar` derivative engine which; employs clad. ### VecOps; - Add `All` helper: return true if all of the elements equate to true, return false otherwise.; - Add `Any` helper: return true if any of the elements equates to true, return false otherwise.; - Add `ArgSort` helper: return an RVe",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v616/index.md:10726,simpl,simple,10726,README/ReleaseNotes/v616/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v616/index.md,1,['simpl'],['simple']
Usability,"r example in this section is compiled, result of the compilation will be:. .. code-block:: llvm. define i32 @main() {; entry:; tail call void @print(i32 4); tail call void @print(i32 5); tail call void @print(i32 6); ret i32 0; }. .. _final:; .. _final suspend:. Final Suspend; -------------. A coroutine author or a frontend may designate a particular suspend to be final,; by setting the second argument of the `coro.suspend`_ intrinsic to `true`.; Such a suspend point has two properties:. * it is possible to check whether a suspended coroutine is at the final suspend; point via `coro.done`_ intrinsic;. * a resumption of a coroutine stopped at the final suspend point leads to; undefined behavior. The only possible action for a coroutine at a final; suspend point is destroying it via `coro.destroy`_ intrinsic. From the user perspective, the final suspend point represents an idea of a; coroutine reaching the end. From the compiler perspective, it is an optimization; opportunity for reducing number of resume points (and therefore switch cases) in; the resume function. The following is an example of a function that keeps resuming the coroutine; until the final suspend point is reached after which point the coroutine is; destroyed:. .. code-block:: llvm. define i32 @main() {; entry:; %hdl = call ptr @f(i32 4); br label %while; while:; call void @llvm.coro.resume(ptr %hdl); %done = call i1 @llvm.coro.done(ptr %hdl); br i1 %done, label %end, label %while; end:; call void @llvm.coro.destroy(ptr %hdl); ret i32 0; }. Usually, final suspend point is a frontend injected suspend point that does not; correspond to any explicitly authored suspend point of the high level language.; For example, for a Python generator that has only one suspend point:. .. code-block:: python. def coroutine(n):; for i in range(n):; yield i. Python frontend would inject two more suspend points, so that the actual code; looks like this:. .. code-block:: c. void* coroutine(int n) {; int current_value;; <des",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst:25228,resume,resume,25228,interpreter/llvm-project/llvm/docs/Coroutines.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst,2,['resume'],['resume']
Usability,"r example, the type of ``X``; is ""``foo``"", not ""``int``""), and requires properly propagating it through the; various operators (for example, the type of ``*Y`` is ""``foo``"", not; ""``int``""). In order to retain this information, the type of these expressions; is an instance of the ``TypedefType`` class, which indicates that the type of; these expressions is a typedef for ""``foo``"". Representing types like this is great for diagnostics, because the; user-specified type is always immediately available. There are two problems; with this: first, various semantic checks need to make judgements about the; *actual structure* of a type, ignoring typedefs. Second, we need an efficient; way to query whether two types are structurally identical to each other,; ignoring typedefs. The solution to both of these problems is the idea of; canonical types. .. _CanonicalType:. Canonical Types; ^^^^^^^^^^^^^^^. Every instance of the ``Type`` class contains a canonical type pointer. For; simple types with no typedefs involved (e.g., ""``int``"", ""``int*``"",; ""``int**``""), the type just points to itself. For types that have a typedef; somewhere in their structure (e.g., ""``foo``"", ""``foo*``"", ""``foo**``"",; ""``bar``""), the canonical type pointer points to their structurally equivalent; type without any typedefs (e.g., ""``int``"", ""``int*``"", ""``int**``"", and; ""``int*``"" respectively). This design provides a constant time operation (dereferencing the canonical type; pointer) that gives us access to the structure of types. For example, we can; trivially tell that ""``bar``"" and ""``foo*``"" are the same type by dereferencing; their canonical type pointers and doing a pointer comparison (they both point; to the single ""``int*``"" type). Canonical types and typedef types bring up some complexities that must be; carefully managed. Specifically, the ``isa``/``cast``/``dyn_cast`` operators; generally shouldn't be used in code that is inspecting the AST. For example,; when type checking the indirection ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:63703,simpl,simple,63703,interpreter/llvm-project/clang/docs/InternalsManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst,1,['simpl'],['simple']
Usability,"r filesystem is called a *docker image*.; One can start a container from a prebuilt docker image. Docker images are built from a so-called *Dockerfile*, a source file written in; a specialized language that defines instructions to be used when build; the docker image (see `official; documentation <https://docs.docker.com/engine/reference/builder/>`_ for more; details). A minimal Dockerfile typically contains a base image and a number; of RUN commands that have to be executed to build the image. When building a new; image, docker will first download your base image, mount its filesystem as; read-only and then add a writable overlay on top of it to keep track of all; filesystem modifications, performed while building your image. When the build; process is finished, a diff between your image's final filesystem state and the; base image's filesystem is stored in the resulting image. Overview; ========; The ``llvm/utils/docker`` folder contains Dockerfiles and simple bash scripts to; serve as a basis for anyone who wants to create their own Docker image with; LLVM components, compiled from sources. The sources are checked out from the; upstream git repository when building the image. The resulting image contains only the requested LLVM components and a few extra; packages to make the image minimally useful for C++ development, e.g. libstdc++; and binutils. The interface to run the build is ``build_docker_image.sh`` script. It accepts a; list of LLVM repositories to checkout and arguments for CMake invocation. If you want to write your own docker image, start with an ``example/`` subfolder.; It provides an incomplete Dockerfile with (very few) FIXMEs explaining the steps; you need to take in order to make your Dockerfiles functional. Usage; =====; The ``llvm/utils/build_docker_image.sh`` script provides a rather high degree of; control on how to run the build. It allows you to specify the projects to; checkout from git and provide a list of CMake arguments to use during wh",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Docker.rst:2482,simpl,simple,2482,interpreter/llvm-project/llvm/docs/Docker.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Docker.rst,1,['simpl'],['simple']
Usability,"r for **`TClonesArray`** is called. The collection itself; cannot be a **`TClonesArray`**. If `name` is given, all branch names; will be prefixed with `name_`. *IMPORTANT NOTE1:* This function should not be called if `splitlevel<1`.; *IMPORTANT NOTE2:* The branches created by this function will have names; corresponding to the collection or object names. It is important to give; names to collections to avoid misleading branch names or identical; branch names. By default collections have a name equal to the; corresponding class name, e.g. the default name of **`TList`** is; ""`TList`"". ## Examples for Writing and Reading Trees. The following sections are examples of writing and reading trees; increasing in complexity from a simple tree with a few variables to a; tree containing folders and complex Event objects. Each example has a; named script in the `$ROOTSYS/tutorials/tree` directory. They are called; tree1.C to tree4.C. The examples are:. - `tree1.C`: a tree with several simple (integers and floating point); variables. - `tree2.C`: a tree built from a C structure (`struct`). This example; uses the `Geant3` C wrapper as an example of a FORTRAN common block; ported to C with a C structure. - `tree3.C:` in this example, we will show how to extend a tree with a; branch from another tree with the Friends feature. These trees have; branches with variable length arrays. Each entry has a variable; number of tracks, and each track has several variables. - `tree4.C:` a tree with a class (`Event`). The class Event is defined; in `$ROOTSYS/test`. In this example we first encounter the impact of; splitting a branch. Each script contains the main function, with the same name as the file; (i.e. `tree1`), the function to write - `tree1w`, and the function to; read - `tree1r`. If the script is not run in batch mode, it displays the; tree in the browser and tree viewer. To study the example scripts, you; can either execute the main script, or load the script and execute a; specific",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:33499,simpl,simple,33499,documentation/users-guide/Trees.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md,1,['simpl'],['simple']
Usability,"r is responsible for; accepting both and either forwarding the changing flag or discarding the flag; that would just set the key path to its default. The first argument to ``BoolOption`` is a prefix that is used to construct the; full names of both flags. The positive flag would then be named; ``flegacy-pass-manager`` and the negative ``fno-legacy-pass-manager``.; ``BoolOption`` also implies the ``-`` prefix for both flags. It's also possible; to use ``BoolFOption`` that implies the ``""f""`` prefix and ``Group<f_Group>``.; The ``PosFlag`` and ``NegFlag`` classes hold the associated boolean value,; arrays of elements passed to the ``Flag`` and ``Visibility`` classes and the; help text. The optional ``BothFlags`` class holds arrays of ``Flag`` and; ``Visibility`` elements that are common for both the positive and negative flag; and their common help text suffix. **String**. The key path defaults to the specified string, or an empty one, if omitted. When; the option appears on the command line, the argument value is simply copied. .. code-block:: text. def isysroot : JoinedOrSeparate<[""-""], ""isysroot"">,; Visibility<[ClangOption, CC1Option, FlangOption]>,; MarshallingInfoString<HeaderSearchOpts<""Sysroot"">, [{""/""}]>;. **List of Strings**. The key path defaults to an empty ``std::vector<std::string>``. Values specified; with each appearance of the option on the command line are appended to the; vector. .. code-block:: text. def frewrite_map_file : Separate<[""-""], ""frewrite-map-file"">,; Visibility<[ClangOption, CC1Option]>,; MarshallingInfoStringVector<CodeGenOpts<""RewriteMapFiles"">>;. **Integer**. The key path defaults to the specified integer value, or ``0`` if omitted. When; the option appears on the command line, its value gets parsed by ``llvm::APInt``; and the result is assigned to the key path on success. .. code-block:: text. def mstack_probe_size : Joined<[""-""], ""mstack-probe-size="">,; Visibility<[ClangOption, CC1Option]>,; MarshallingInfoInt<CodeGenOpts<""StackProbe",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:40706,simpl,simply,40706,interpreter/llvm-project/clang/docs/InternalsManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst,1,['simpl'],['simply']
Usability,"r markup element.; However, other markup elements may appear between SGR control sequences and the; color/bold state is expected to apply to the symbolic output that replaces the; markup element in the filter's output. The accepted SGR control sequences all have the form ``""\033[%um""`` (expressed here; using C string syntax), where ``%u`` is one of these:. ==== ============================ ===============================================; Code Effect Notes; ==== ============================ ===============================================; 0 Reset to default formatting.; 1 Bold text Combines with color states, doesn't reset them.; 30 Black foreground; 31 Red foreground; 32 Green foreground; 33 Yellow foreground; 34 Blue foreground; 35 Magenta foreground; 36 Cyan foreground; 37 White foreground; ==== ============================ ===============================================. Common markup element syntax; ============================. All the markup elements share a common syntactic structure to facilitate simple; matching and parsing code. Each element has the form::. {{{tag:fields}}}. ``tag`` identifies one of the element types described below, and is always a; short alphabetic string that must be in lower case. The rest of the element; consists of one or more fields. Fields are separated by ``:`` and cannot contain; any ``:`` or ``}`` characters. How many fields must be or may be present and; what they contain is specified for each element type. No markup elements or ANSI SGR control sequences are interpreted inside the; contents of a field. Implementations must ignore markup fields after those expected; this allows; adding new fields to backwards-compatibly extend elements. Implementations need; not ignore them silently, but the element should behave otherwise as if the; fields were removed. In the descriptions of each element type, ``printf``-style placeholders indicate; field contents:. ``%s``; A string of printable characters, not including ``:`` or ``}``. ``%p",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SymbolizerMarkupFormat.rst:6741,simpl,simple,6741,interpreter/llvm-project/llvm/docs/SymbolizerMarkupFormat.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SymbolizerMarkupFormat.rst,1,['simpl'],['simple']
Usability,"r open a private browser session.*. ## How to use; C++ Modules in ROOT are default since v6.20 (Unix) and v6.22 (OSX). Enjoy. To disable C++ Modules in ROOT use `-Druntime_cxxmodules=Off`. ## Citing ROOT's C++ Modules; ```latex; % Peer-Reviewed Publication; %; % 22nd International Conference on Computing in High Energy and Nuclear Physics (CHEP); % 8-14 October, 2016, San Francisco, USA; %; @inproceedings{Vassilev_ROOTModules,; author = {Vassilev,V.},; title = {{Optimizing ROOT's Performance Using C++ Modules}},; journal = {Journal of Physics: Conference Series},; year = 2017,; month = {oct},; volume = {898},; number = {7},; pages = {072023},; doi = {10.1088/1742-6596/898/7/072023},; url = {https://iopscience.iop.org/article/10.1088/1742-6596/898/7/072023/pdf},; publisher = {{IOP} Publishing}; }; ```; ; # Acknowledgement. We would like to thank the ROOT team. We would like to thank Liz Sexton-Kennedy (FNAL) in particular for supporting; this project. We would like to thank Axel Naumann for early feedback on this document. This work has been supported by an Intel Parallel Computing Center grant, by U.S.; National Science Foundation grants PHY-1450377 and PHY-1624356, and by the U.S.; Department of Energy, Office of Science. # References; (1): [Vassilev, V., 2017, October. Optimizing ROOT's Performance Using C++ Modules. In Journal of Physics: Conference Series (Vol. 898, No. 7, p. 072023). IOP Publishing.][1]. (2): [Clang Modules, Official Documentation][2]. (3): [Manuel Klimek, Deploying C++ Modules to 100s of Millions of Lines of Code, 2016, CppCon][3]. (4): [Precompiled Header and Modules Internals, Official Documentation][4]. (5): [Bloom Filter][5]. (6): [C++ Modules support (based on Clang), GitHub Repo][5]. (7): [Make your third party libraries modular][6]. (8): [Vassilev, V., Shadura, O., Takahashi, Y., IPCC-ROOT Showcase Presentation, Nov, 2018][7]. (9): [ROOT Continuous Performance Monitoring System][8]. [//]: # (Links); [1]: https://www.researchgate.net/prof",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/README.CXXMODULES.md:20329,feedback,feedback,20329,README/README.CXXMODULES.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/README.CXXMODULES.md,1,['feedback'],['feedback']
Usability,"r open source projects,; so we would appreciate help in improving the existing coverage we have both in; terms of layout of the tests as well as in coverage of the various standard; modes.; Complete the investigation into Clang's C and C++ Defect Report; conformance: Separate from (but related to) general conformance testing is; determining which C defect reports and; C++ defect reports Clang implements. These; lists currently have a number of entries marked as Unknown.; Completing the investigation involves adding test coverage for; C; and; C++; defect reports and updating the documentation accordingly.; Bug triage: Clang's ; issue trackercurrently has over 20,000 open issues, many of which are not; appropriately tagged, are no longer reproducible, could use a reduced test case,; or otherwise needs some manual interaction. We can always use help with; bug triage and; issue tracker maintenance. Improve build times with Clang: the time it takes Clang to process a; translation unit is very important to our users; the lower the build time, the; better the overall user experience. It would be good to improve Clang's; performance as well as to find ways to proactively alert us when we've; introduced a change that has significant negative impact on build times.; Complete support for the experimental constant expression interpreter; : Clang's production constant expression interpreter computes a constant; expression result by walking over AST nodes, performing calculations as it; goes. This does not have good performance properties, and so we've begun work; on an ; experimental constant expression interpreter that works by converting the; AST into bytecode that is interpreted. This effort has a long tail of work left; to complete because it requires implementing byte code for every kind of; expression and type that can be used in a constant expression for C++ and C. Improve clang-doc: Clang's library-based design allows it to be used; by a variety of tools that reason abou",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/OpenProjects.html:3086,user experience,user experience,3086,interpreter/llvm-project/clang/www/OpenProjects.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/OpenProjects.html,1,['user experience'],['user experience']
Usability,"r weights are those belonging to clusters.; It is possible to paint only the events having a weight above a given; value and the clusters appear. The next example “weight cut” applied on; the right plot is 50. Only the events with a weight greater than 50 are displayed. ![Applying a “weight cut” makes the clusters visible.](pictures/para11.png). In case only a few events are displayed, drawing them as smooth curves; instead of straight lines helps to differentiate them. ![Zoom on a Parallel Coordinates plot detail: curves differentiate better events.](pictures/para12.png). Interactivity and therefore the Graphical User Interface are very important; to manipulate the Parallel Coordinates plots. The ROOT framework allows; to easily implement the direct interactions on the graphical area and the; graphical editor facility provides dedicated GUI. ![Parallel Coordinates graphical editors.](pictures/para13.png). Transparency is very useful with parallel coordinates plots. It allows to; show clearly the clusters.; \index{transparency!parallel coordinates}. ![Parallel Coordinates with transparency.](pictures/para14.png). #### Box (Candle) Plots; \index{candle plot}; \index{candle stick plot}; \index{box-and whisker plot}. A Box Plot (also known as a “box-and whisker” plot or “candle stick” plot); is a convenient way to describe graphically a data distribution (D) with only; the five numbers. It was invented in 1977 by John Tukey. The five numbers are:. 1. The minimum value of the distribution D (Min).; 2. The lower quartile (Q1): 25% of the data points in D are less than Q1.; 3. The median (M): 50% of the data points in D are less than M.; 4. The upper quartile (Q3): 75% of the data points in D are less than Q3.; 5. The maximum value of the distribution D (Max). ![A box plot describes a distribution with only five numbers. ](pictures/bp1.png). In ROOT Box Plots (Candle Plots) can be produced from a TTree using the; “candle” option in TTree::Draw(). ``` {.cpp}; tree->Draw(“px",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:103608,clear,clearly,103608,documentation/users-guide/Trees.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md,1,['clear'],['clearly']
Usability,"r-config c++-template-inlining=[true | false]``. Currently, template functions are considered for inlining by default. The motivation behind this option is that very generic code can be a source; of false positives, either by considering paths that the caller considers; impossible (by some unstated precondition), or by inlining some but not all; of a deep implementation of a function. c++-stdlib-inlining; ^^^^^^^^^^^^^^^^^^^. This option controls whether functions from the C++ standard library, including; methods of the container classes in the Standard Template Library, should be; considered for inlining. ``-analyzer-config c++-stdlib-inlining=[true | false]``. Currently, C++ standard library functions are considered for inlining by; default. The standard library functions and the STL in particular are used ubiquitously; enough that our tolerance for false positives is even lower here. A false; positive due to poor modeling of the STL leads to a poor user experience, since; most users would not be comfortable adding assertions to system headers in order; to silence analyzer warnings. c++-container-inlining; ^^^^^^^^^^^^^^^^^^^^^^. This option controls whether constructors and destructors of ""container"" types; should be considered for inlining. ``-analyzer-config c++-container-inlining=[true | false]``. Currently, these constructors and destructors are NOT considered for inlining; by default. The current implementation of this setting checks whether a type has a member; named 'iterator' or a member named 'begin'; these names are idiomatic in C++,; with the latter specified in the C++11 standard. The analyzer currently does a; fairly poor job of modeling certain data structure invariants of container-like; objects. For example, these three expressions should be equivalent:. .. code-block:: cpp. std::distance(c.begin(), c.end()) == 0; c.begin() == c.end(); c.empty(). Many of these issues are avoided if containers always have unknown, symbolic; state, which is what hap",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/IPA.rst:3760,user experience,user experience,3760,interpreter/llvm-project/clang/docs/analyzer/developer-docs/IPA.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/IPA.rst,1,['user experience'],['user experience']
Usability,"r-rt/lib/fuzzer/afl>`__. How good is my fuzzer?; ----------------------. Once you implement your target function ``LLVMFuzzerTestOneInput`` and fuzz it to death,; you will want to know whether the function or the corpus can be improved further.; One easy to use metric is, of course, code coverage. We recommend to use; `Clang Coverage <https://clang.llvm.org/docs/SourceBasedCodeCoverage.html>`_,; to visualize and study your code coverage; (`example <https://github.com/google/fuzzer-test-suite/blob/master/tutorial/libFuzzerTutorial.md#visualizing-coverage>`_). User-supplied mutators; ----------------------. LibFuzzer allows to use custom (user-supplied) mutators, see; `Structure-Aware Fuzzing <https://github.com/google/fuzzing/blob/master/docs/structure-aware-fuzzing.md>`_; for more details. Startup initialization; ----------------------; If the library being tested needs to be initialized, there are several options. The simplest way is to have a statically initialized global object inside; `LLVMFuzzerTestOneInput` (or in global scope if that works for you):. .. code-block:: c++. extern ""C"" int LLVMFuzzerTestOneInput(const uint8_t *Data, size_t Size) {; static bool Initialized = DoInitialization();; ... Alternatively, you may define an optional init function and it will receive; the program arguments that you can read and modify. Do this **only** if you; really need to access ``argv``/``argc``. .. code-block:: c++. extern ""C"" int LLVMFuzzerInitialize(int *argc, char ***argv) {; ReadAndMaybeModify(argc, argv);; return 0;; }. Using libFuzzer as a library; ----------------------------; If the code being fuzzed must provide its own `main`, it's possible to; invoke libFuzzer as a library. Be sure to pass ``-fsanitize=fuzzer-no-link``; during compilation, and link your binary against the no-main version of; libFuzzer. On Linux installations, this is typically located at:. .. code-block:: bash. /usr/lib/<llvm-version>/lib/clang/<clang-version>/lib/linux/libclang_rt.fuzzer_no_",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LibFuzzer.rst:23926,simpl,simplest,23926,interpreter/llvm-project/llvm/docs/LibFuzzer.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LibFuzzer.rst,1,['simpl'],['simplest']
Usability,"r. This overrides the ``ssp`` and ``sspstrong`` function; attributes. Variables that are identified as requiring a protector will be arranged; on the stack such that they are adjacent to the stack protector guard.; The specific layout rules are:. #. Large arrays and structures containing large arrays; (``>= ssp-buffer-size``) are closest to the stack protector.; #. Small arrays and structures containing small arrays; (``< ssp-buffer-size``) are 2nd closest to the protector.; #. Variables that have had their address taken are 3rd closest to the; protector. If a function with an ``sspreq`` attribute is inlined into a calling; function which has an ``ssp`` or ``sspstrong`` attribute, the calling; function's attribute will be upgraded to ``sspreq``. ``strictfp``; This attribute indicates that the function was called from a scope that; requires strict floating-point semantics. LLVM will not attempt any; optimizations that require assumptions about the floating-point rounding; mode or that might alter the state of floating-point status flags that; might otherwise be set or cleared by calling this function. LLVM will; not introduce any new floating-point instructions that may trap. .. _denormal_fp_math:. ``""denormal-fp-math""``; This indicates the denormal (subnormal) handling that may be; assumed for the default floating-point environment. This is a; comma separated pair. The elements may be one of ``""ieee""``,; ``""preserve-sign""``, ``""positive-zero""``, or ``""dynamic""``. The; first entry indicates the flushing mode for the result of floating; point operations. The second indicates the handling of denormal inputs; to floating point instructions. For compatibility with older; bitcode, if the second value is omitted, both input and output; modes will assume the same mode. If this is attribute is not specified, the default is ``""ieee,ieee""``. If the output mode is ``""preserve-sign""``, or ``""positive-zero""``,; denormal outputs may be flushed to zero by standard floating-point; op",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:105921,clear,cleared,105921,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['clear'],['cleared']
Usability,"r. This; implies:. - do not share the layout-hints among GUI components;. - do not delete child widgets in the destructor as this is done; automatically. #### Using Several Tabs. Sometimes you might need to use several tabs to organize properly your; class-editor. Each editor tab is a resource shared among all the; class-editors. Tabs must be created from the constructor of your; editor-class by using the method:. ``` {.cpp}; TGVerticalFrame* TGedFrame::CreateEditorTabSubFrame(const Text_t *name),; ```. It returns a pointer to a new tab container frame ready for use in your; class. If you need to hide/show this frame depending on the object's; status, you should store it in a data member. See for examples:; **`TH1Editor`**, **`TH2Editor`**. #### Base-Class Editors Control. Full control over base-class editors can be achieved by re-implementing; virtual method void `TGedFrame::ActivateBaseClassEditors(TClass` `*cl)`.; It is called during each compound editor rebuild and the default; implementation simply offers all base-classes to the publishing; mechanism. To prevent inclusion of a base-class into the compound editor, call:. ``` {.cpp}; void TGedEditor::ExcludeClassEditor(TClass* class, Bool_t recurse); ```. Pointer to the compound GED-editor is available in **`TGedFrame`**‘s; data-member:. ``` {.cpp}; TGedEditor *fGedEditor; ```. Ordering of base-class editor frames follows the order of the classes in; the class hierarchy. This order can be changed by modifying the value of; **`TGedFrame`**'s data member `Int_t fPriority`. The default value is; 50; smaller values move the frame towards to the top. This priority; should be set in the editor constructor. ## Drag and Drop. Drag and Drop support is introduced for Linux (via Xdnd - the drag and; drop protocol for X window system) and for Windows (via Clipboard).; Users can selects something in ROOT with a mouse press, drags it (moves; the mouse while keeping the mouse button pressed) and releases the mouse; button somepl",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md:106857,simpl,simply,106857,documentation/users-guide/WritingGUI.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md,1,['simpl'],['simply']
Usability,"r2.png). The spider plot graphics editor provides two tabs to interact with; the spider plots’ output: the tab “Style” defining the spider layout; and the tab “Browse” to navigate in the tree. #### Parallel Coordinates Plots; \index{parallel coordinates}. The Parallel Coordinates Plots are a common way of studying and; visualizing multiple variables data sets. They were proposed by in; A.Inselberg in 1981 as a new way to represent multi-dimensional; information. In traditional Cartesian coordinates, axes are mutually; perpendicular. In Parallel coordinates, all axes are parallel which; allows representing data in much more than three dimensions. To show; a set of points in Parallel Coordinates, a set of parallel lines is; drawn, typically vertical and equally spaced. A point in n-dimensional; space is represented as a polyline with vertices on the parallel axes.; The position of the vertex on the i-th axis corresponds to the i-th; coordinate of the point. The three following figures show some very; simple examples:. ![The Parallel Coordinates representation of the six dimensional point `(-5,3,4,2,0,1)`.](pictures/para1.png). ![The line `y = -3x+20` and a circle in Parallel Coordinates.](pictures/para2.png). The Parallel Coordinates technique is good at: spotting irregular; events, seeing the data trend, finding correlations and clusters. Its; main weakness is the cluttering of the output. Because each “point” in; the multidimensional space is represented as a line, the output is very; quickly opaque and therefore it is difficult to see the data clusters.; Most of the work done about Parallel Coordinates is to find techniques; to reduce the output’s cluttering. The Parallel Coordinates plots in; ROOT have been implemented as a new plotting option “PARA” in the; `TTree::Draw()method`. To demonstrate how the Parallel Coordinates; works in ROOT we will use the tree produced by the following; “pseudo C++” code:. ``` {.cpp}; void parallel_example() {; TNtuple *nt = new TN",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:96052,simpl,simple,96052,documentation/users-guide/Trees.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md,1,['simpl'],['simple']
Usability,"r::Restrict() method.; Up to now general read-only flag was applied - either; everything read-only or everything is fully accessible.; Now one could restrict access to different parts of; objects hierarchy or even fully 'hide' them from the client.; Restriction based on user account name, which is applied; when htdigest authentication is configured.; One also able to allow execution of selected methods. Implement multi.bin and multi.json requests.; One could request many items with single HTTP request.; Let optimize communication between server and client. With *SNIFF* tag in ClassDef() comments one could expose different properties,; which than exposed by the TRootSniffer to the client with h.json requests.; Such possibility ease implementation of client-side code for custom classes. Allow to bind http port with loopback address.; This restrict access to http server only from localhost.; One could either specify 'loopback' option in constructor:; new THttpServer(""http:8080?loopback""); or in clear text specify IP address to which http socket should be bind:; new THttpServer(""http:127.0.0.1:8080""); If host has several network interfaces, one could select one for binding:; new THttpServer(""http:192.168.1.17:8080""). ### TNetXNGFileStager; Fixed ROOT-7703. This restores the behavior of Locate() to that found with; TXNetFileStager: Rather than return only the xrootd server's reply, the endpoint; hostname is looked up and Locate() returns the full url, including the path. ### TWebFile; Fixed ROOT-7809. Returns an error for a redirect which does not specify the new; URI, rather than going into a loop. Fixed ROOT-7817. Avoid a crash under some circumstances when trying to open an; invalid path. ## GUI Libraries. ## Montecarlo Libraries. ## Multi-processing. With this version we introduce a new module, core/multiproc, for multi-processing on multi-core machines. This module is based on fork technology and offers an interface inspired from Python multiprocessor module. The new",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v606/index.md:20223,clear,clear,20223,README/ReleaseNotes/v606/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v606/index.md,1,['clear'],['clear']
Usability,"rStr``' global whenever it; lexes an identifier. Also, since language keywords are matched by the; same loop, we handle them here inline. Numeric values are similar:. .. code-block:: c++. if (isdigit(LastChar) || LastChar == '.') { // Number: [0-9.]+; std::string NumStr;; do {; NumStr += LastChar;; LastChar = getchar();; } while (isdigit(LastChar) || LastChar == '.');. NumVal = strtod(NumStr.c_str(), 0);; return tok_number;; }. This is all pretty straightforward code for processing input. When; reading a numeric value from input, we use the C ``strtod`` function to; convert it to a numeric value that we store in ``NumVal``. Note that; this isn't doing sufficient error checking: it will incorrectly read; ""1.23.45.67"" and handle it as if you typed in ""1.23"". Feel free to; extend it! Next we handle comments:. .. code-block:: c++. if (LastChar == '#') {; // Comment until end of line.; do; LastChar = getchar();; while (LastChar != EOF && LastChar != '\n' && LastChar != '\r');. if (LastChar != EOF); return gettok();; }. We handle comments by skipping to the end of the line and then return; the next token. Finally, if the input doesn't match one of the above; cases, it is either an operator character like '+' or the end of the; file. These are handled with this code:. .. code-block:: c++. // Check for end of file. Don't eat the EOF.; if (LastChar == EOF); return tok_eof;. // Otherwise, just return the character as its ascii value.; int ThisChar = LastChar;; LastChar = getchar();; return ThisChar;; }. With this, we have the complete lexer for the basic Kaleidoscope; language (the `full code listing <LangImpl02.html#full-code-listing>`_ for the Lexer; is available in the `next chapter <LangImpl02.html>`_ of the tutorial).; Next we'll `build a simple parser that uses this to build an Abstract; Syntax Tree <LangImpl02.html>`_. When we have that, we'll include a; driver so that you can use the lexer and parser together. `Next: Implementing a Parser and AST <LangImpl02.html>`_. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl01.rst:6224,simpl,simple,6224,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl01.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl01.rst,1,['simpl'],['simple']
Usability,"ral (like 1.0), ``NumVal`` holds its; value. We use global variables for simplicity, but this is not the; best choice for a real language implementation :). The actual implementation of the lexer is a single function named; ``gettok``. The ``gettok`` function is called to return the next token; from standard input. Its definition starts as:. .. code-block:: c++. /// gettok - Return the next token from standard input.; static int gettok() {; static int LastChar = ' ';. // Skip any whitespace.; while (isspace(LastChar)); LastChar = getchar();. ``gettok`` works by calling the C ``getchar()`` function to read; characters one at a time from standard input. It eats them as it; recognizes them and stores the last character read, but not processed,; in LastChar. The first thing that it has to do is ignore whitespace; between tokens. This is accomplished with the loop above. The next thing ``gettok`` needs to do is recognize identifiers and; specific keywords like ""def"". Kaleidoscope does this with this simple; loop:. .. code-block:: c++. if (isalpha(LastChar)) { // identifier: [a-zA-Z][a-zA-Z0-9]*; IdentifierStr = LastChar;; while (isalnum((LastChar = getchar()))); IdentifierStr += LastChar;. if (IdentifierStr == ""def""); return tok_def;; if (IdentifierStr == ""extern""); return tok_extern;; return tok_identifier;; }. Note that this code sets the '``IdentifierStr``' global whenever it; lexes an identifier. Also, since language keywords are matched by the; same loop, we handle them here inline. Numeric values are similar:. .. code-block:: c++. if (isdigit(LastChar) || LastChar == '.') { // Number: [0-9.]+; std::string NumStr;; do {; NumStr += LastChar;; LastChar = getchar();; } while (isdigit(LastChar) || LastChar == '.');. NumVal = strtod(NumStr.c_str(), 0);; return tok_number;; }. This is all pretty straightforward code for processing input. When; reading a numeric value from input, we use the C ``strtod`` function to; convert it to a numeric value that we store in ``NumVal``",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl01.rst:4100,simpl,simple,4100,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl01.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl01.rst,1,['simpl'],['simple']
Usability,"ral generations of machines. Okay, that comment is removed. > and is more compact than uint. No, it isn't. Remember that the bytecode encoding saves value slots into; the bytecode instructions themselves, not constant values. This is; another case where we may introduce more cast instructions (but we will; also reduce the number of opcode variants that must be supported by a; virtual machine). Because most shifts are by constant values, I don't; think that we'll have to cast many shifts. :). > I still have some major concerns about including malloc and free in the; > language (either as builtin functions or instructions). Agreed. How about this proposal:. malloc/free are either built in functions or actual opcodes. They provide; all of the type safety that the document would indicate, blah blah; blah. :). Now, because of all of the excellent points that you raised, an; implementation may want to override the default malloc/free behavior of; the program. To do this, they simply implement a ""malloc"" and; ""free"" function. The virtual machine will then be defined to use the user; defined malloc/free function (which return/take void*'s, not type'd; pointers like the builtin function would) if one is available, otherwise; fall back on a system malloc/free. Does this sound like a good compromise? It would give us all of the; typesafety/elegance in the language while still allowing the user to do; all the cool stuff they want to... > 'alloca' on the other hand sounds like a good idea, and the; > implementation seems fairly language-independent so it doesn't have the; > problems with malloc listed above. Okay, once we get the above stuff figured out, I'll put it all in the; spec. > About indirect call:; > Your option #2 sounded good to me. I'm not sure I understand your; > concern about an explicit 'icall' instruction?. I worry too much. :) The other alternative has been removed. 'icall' is; now up in the instruction list next to 'call'. > I believe tail calls are relatively ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HistoricalNotes/2001-02-09-AdveCommentsResponse.txt:4411,simpl,simply,4411,interpreter/llvm-project/llvm/docs/HistoricalNotes/2001-02-09-AdveCommentsResponse.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HistoricalNotes/2001-02-09-AdveCommentsResponse.txt,1,['simpl'],['simply']
Usability,"ranch target injection; * GPZ Variant #3 (a.k.a. Meltdown): Rogue data cache load. For more details, see the Google Project Zero blog post and the Spectre research; paper:; * https://googleprojectzero.blogspot.com/2018/01/reading-privileged-memory-with-side.html; * https://spectreattack.com/spectre.pdf. The core problem of GPZ Variant #1 is that speculative execution uses branch; prediction to select the path of instructions speculatively executed. This path; is speculatively executed with the available data, and may load from memory and; leak the loaded values through various side channels that survive even when the; speculative execution is unwound due to being incorrect. Mispredicted paths can; cause code to be executed with data inputs that never occur in correct; executions, making checks against malicious inputs ineffective and allowing; attackers to use malicious data inputs to leak secret data. Here is an example,; extracted and simplified from the Project Zero paper:; ```; struct array {; unsigned long length;; unsigned char data[];; };; struct array *arr1 = ...; // small array; struct array *arr2 = ...; // array of size 0x400; unsigned long untrusted_offset_from_caller = ...;; if (untrusted_offset_from_caller < arr1->length) {; unsigned char value = arr1->data[untrusted_offset_from_caller];; unsigned long index2 = ((value&1)*0x100)+0x200;; unsigned char value2 = arr2->data[index2];; }; ```. The key of the attack is to call this with `untrusted_offset_from_caller` that; is far outside of the bounds when the branch predictor will predict that it; will be in-bounds. In that case, the body of the `if` will be executed; speculatively, and may read secret data into `value` and leak it via a; cache-timing side channel when a dependent access is made to populate `value2`. ## High Level Mitigation Approach. While several approaches are being actively pursued to mitigate specific; branches and/or loads inside especially risky software (most notably various OS; kerne",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SpeculativeLoadHardening.md:1471,simpl,simplified,1471,interpreter/llvm-project/llvm/docs/SpeculativeLoadHardening.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SpeculativeLoadHardening.md,1,['simpl'],['simplified']
Usability,"range-insertion and; copy-construction, which :ref:`SmallSet <dss_smallset>` and :ref:`SmallPtrSet; <dss_smallptrset>` do support. .. _dss_denseset:. llvm/ADT/DenseSet.h; ^^^^^^^^^^^^^^^^^^^. DenseSet is a simple quadratically probed hash table. It excels at supporting; small values: it uses a single allocation to hold all of the pairs that are; currently inserted in the set. DenseSet is a great way to unique small values; that are not simple pointers (use :ref:`SmallPtrSet <dss_smallptrset>` for; pointers). Note that DenseSet has the same requirements for the value type that; :ref:`DenseMap <dss_densemap>` has. .. _dss_sparseset:. llvm/ADT/SparseSet.h; ^^^^^^^^^^^^^^^^^^^^. SparseSet holds a small number of objects identified by unsigned keys of; moderate size. It uses a lot of memory, but provides operations that are almost; as fast as a vector. Typical keys are physical registers, virtual registers, or; numbered basic blocks. SparseSet is useful for algorithms that need very fast clear/find/insert/erase; and fast iteration over small sets. It is not intended for building composite; data structures. .. _dss_sparsemultiset:. llvm/ADT/SparseMultiSet.h; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^. SparseMultiSet adds multiset behavior to SparseSet, while retaining SparseSet's; desirable attributes. Like SparseSet, it typically uses a lot of memory, but; provides operations that are almost as fast as a vector. Typical keys are; physical registers, virtual registers, or numbered basic blocks. SparseMultiSet is useful for algorithms that need very fast; clear/find/insert/erase of the entire collection, and iteration over sets of; elements sharing a key. It is often a more efficient choice than using composite; data structures (e.g. vector-of-vectors, map-of-vectors). It is not intended for; building composite data structures. .. _dss_FoldingSet:. llvm/ADT/FoldingSet.h; ^^^^^^^^^^^^^^^^^^^^^. FoldingSet is an aggregate class that is really good at uniquing; expensive-to-create or polym",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:80830,clear,clear,80830,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,1,['clear'],['clear']
Usability,"rap 0x00`` Reserved by hardware.; debugger breakpoint ``s_trap 0x01`` *none* *none* Reserved for debugger to use for; breakpoints. Causes wave to be halted; with the PC at the trap instruction.; The debugger is responsible to resume; the wave, including the instruction; that the breakpoint overwrote.; ``llvm.trap`` ``s_trap 0x02`` ``SGPR0-1``: *none* Causes wave to be halted with the PC at; ``queue_ptr`` the trap instruction. The associated; queue is signalled to put it into the; error state. When the queue is put in; the error state, the waves executing; dispatches on the queue will be; terminated.; ``llvm.debugtrap`` ``s_trap 0x03`` *none* *none* - If debugger not enabled then behaves; as a no-operation. The trap handler; is entered and immediately returns to; continue execution of the wavefront.; - If the debugger is enabled, causes; the debug trap to be reported by the; debugger and the wavefront is put in; the halt state with the PC at the; instruction. The debugger must; increment the PC and resume the wave.; reserved ``s_trap 0x04`` Reserved.; reserved ``s_trap 0x05`` Reserved.; reserved ``s_trap 0x06`` Reserved.; reserved ``s_trap 0x07`` Reserved.; reserved ``s_trap 0x08`` Reserved.; reserved ``s_trap 0xfe`` Reserved.; reserved ``s_trap 0xff`` Reserved.; =================== =============== ================ ================= =======================================. .. _amdgpu-amdhsa-function-call-convention:. Call Convention; ~~~~~~~~~~~~~~~. .. note::. This section is currently incomplete and has inaccuracies. It is WIP that will; be updated as information is determined. See :ref:`amdgpu-dwarf-address-space-identifier` for information on swizzled; addresses. Unswizzled addresses are normal linear addresses. .. _amdgpu-amdhsa-function-call-convention-kernel-functions:. Kernel Functions; ++++++++++++++++. This section describes the call convention ABI for the outer kernel function. See :ref:`amdgpu-amdhsa-initial-kernel-execution-state` for the kernel call; con",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst:385425,resume,resume,385425,interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,1,['resume'],['resume']
Usability,"rate over ; the instlist, and access the instructions through the instlist. To add or remove an instruction from a basic block, we need to get an ; iterator to an instruction, which, given just an Instruction*, requires a ; linear search of the basic block the instruction is contained in... just ; to insert an instruction before another instruction, or to delete an ; instruction! This complicates algorithms that should be very simple (like ; simple constant propagation), because they aren't actually sparse anymore,; they have to traverse basic blocks to remove constant propogated ; instructions. Additionally, adding or removing instructions to a basic block ; _invalidates all iterators_ pointing into that block, which is really ; irritating. To fix these problems (and others), I would like to make the ordering of; the instructions be represented with a doubly linked list in the; instructions themselves, instead of an external data structure. This is ; how many other representations do it, and frankly I can't remember why I ; originally implemented it the way I did. Long term, all of the code that depends on the nasty features in the ; instruction list (which can be found by grep'ing for getInstList()) will ; be changed to do nice local transformations. In the short term, I'll ; change the representation, but preserve the interface (including ; getInstList()) so that all of the code doesn't have to change. Iteration over the instructions in a basic block remains the simple:; for (BasicBlock::iterator I = BB->begin(), E = BB->end(); I != E; ++I) ... But we will also support:; for (Instruction *I = BB->front(); I; I = I->getNext()) ... After converting instructions over, I'll convert basic blocks and ; functions to have a similar interface. The only negative aspect of this change that I see is that it increases ; the amount of memory consumed by one pointer per instruction. Given the ; benefits, I think this is a very reasonable tradeoff. . What do you think?. -Chris; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HistoricalNotes/2002-05-12-InstListChange.txt:2009,simpl,simple,2009,interpreter/llvm-project/llvm/docs/HistoricalNotes/2002-05-12-InstListChange.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HistoricalNotes/2002-05-12-InstListChange.txt,1,['simpl'],['simple']
Usability,"ration that created L.*. * If D has a ``DW_AT_const_value`` attribute, then an implicit location; storage RLS is created from the ``DW_AT_const_value`` attribute's value; with a size matching the size of the ``DW_AT_const_value`` attribute's; value. RL comprises one implicit location description SRL. SRL specifies; RLS with a bit offset of 0. .. note::. If using ``DW_AT_const_value`` for variables and formal parameters is; deprecated and instead ``DW_AT_location`` is used with an implicit; location description, then this rule would not be required. * Otherwise, it is an evaluation error. The bit offset of RL is updated as if the ``DW_OP_LLVM_offset_uconst B``; operation was applied. If a ``DW_OP_stack_value`` operation pops a value that is the same as IPV,; then it pushes a location description that is the same as L. It is an evaluation error if LS or IPV is accessed in any other manner. *The restrictions on how an implicit pointer location description created; by* ``DW_OP_implicit_pointer`` *and* ``DW_OP_LLVM_aspace_implicit_pointer``; *can be used are to simplify the DWARF consumer. Similarly, for an implicit; pointer value created by* ``DW_OP_deref*`` *and* ``DW_OP_stack_value``\ *.*. 4. ``DW_OP_LLVM_aspace_implicit_pointer`` *New*. ``DW_OP_LLVM_aspace_implicit_pointer`` has two operands that are the same as; for ``DW_OP_implicit_pointer``. It pops one stack entry that must be an integral type value that represents; a target architecture specific address space identifier AS. The location description L that is pushed on the stack is the same as for; ``DW_OP_implicit_pointer``, except that the address space identifier used is; AS. The DWARF expression is ill-formed if AS is not one of the values defined by; the target architecture specific ``DW_ASPACE_LLVM_*`` values. .. note::. This definition of ``DW_OP_LLVM_aspace_implicit_pointer`` may change when; full support for address classes is added as required for languages such; as OpenCL/SyCL. *Typically a* ``DW_OP_imp",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst:127359,simpl,simplify,127359,interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,1,['simpl'],['simplify']
Usability,"rator tables that are optimized for very quick lookups will benefit this; type of debugging experience greatly. We would like to generate name lookup tables that can be mapped into memory; from disk, and used as is, with little or no up-front parsing. We would also; be able to control the exact content of these different tables so they contain; exactly what we need. The Name Accelerator Tables were designed to fix these; issues. In order to solve these issues we need to:. * Have a format that can be mapped into memory from disk and used as is; * Lookups should be very fast; * Extensible table format so these tables can be made by many producers; * Contain all of the names needed for typical lookups out of the box; * Strict rules for the contents of tables. Table size is important and the accelerator table format should allow the reuse; of strings from common string tables so the strings for the names are not; duplicated. We also want to make sure the table is ready to be used as-is by; simply mapping the table into memory with minimal header parsing. The name lookups need to be fast and optimized for the kinds of lookups that; debuggers tend to do. Optimally we would like to touch as few parts of the; mapped table as possible when doing a name lookup and be able to quickly find; the name entry we are looking for, or discover there are no matches. In the; case of debuggers we optimized for lookups that fail most of the time. Each table that is defined should have strict rules on exactly what is in the; accelerator tables and documented so clients can rely on the content. Hash Tables; ^^^^^^^^^^^. Standard Hash Tables; """""""""""""""""""""""""""""""""""""""". Typical hash tables have a header, buckets, and each bucket points to the; bucket contents:. .. code-block:: none. .------------.; | HEADER |; |------------|; | BUCKETS |; |------------|; | DATA |; `------------'. The BUCKETS are an array of offsets to DATA for each hash:. .. code-block:: none. .------------.; | 0x00001000 | BUCKET",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst:60205,simpl,simply,60205,interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,1,['simpl'],['simply']
Usability,"raw files; you use llvm-profdata to merge the files into a single profdata file that you; can feed into the LLVM_PROFDATA_FILE option. Our PGO.cmake cache automates that whole process. You can use it for; configuration with CMake with the following command:. .. code-block:: console. $ cmake -G Ninja -C <path to source>/clang/cmake/caches/PGO.cmake \; <path to source>/llvm. There are several additional options that the cache file also accepts to modify; the build, particularly the PGO_INSTRUMENT_LTO option. Setting this option to; Thin or Full will enable ThinLTO or full LTO respectively, further enhancing; the performance gains from a PGO build by enabling interprocedural; optimizations. For example, to run a CMake configuration for a PGO build; that also enables ThinTLO, use the following command:. .. code-block:: console. $ cmake -G Ninja -C <path to source>/clang/cmake/caches/PGO.cmake \; -DPGO_INSTRUMENT_LTO=Thin \; <path to source>/llvm. By default, clang will generate profile data by compiling a simple; hello world program. You can also tell clang use an external; project for generating profile data that may be a better fit for your; use case. The project you specify must either be a lit test suite; (use the CLANG_PGO_TRAINING_DATA option) or a CMake project (use the; CLANG_PERF_TRAINING_DATA_SOURCE_DIR option). For example, If you wanted to use the; `LLVM Test Suite <https://github.com/llvm/llvm-test-suite/>`_ to generate; profile data you would use the following command:. .. code-block:: console. $ cmake -G Ninja -C <path to source>/clang/cmake/caches/PGO.cmake \; -DBOOTSTRAP_CLANG_PGO_TRAINING_DATA_SOURCE_DIR=<path to llvm-test-suite> \; -DBOOTSTRAP_CLANG_PGO_TRAINING_DEPS=runtimes. The BOOTSTRAP\_ prefixes tells CMake to pass the variables on to the instrumented; stage two build. And the CLANG_PGO_TRAINING_DEPS option let's you specify; additional build targets to build before building the external project. The; LLVM Test Suite requires compiler-rt to build",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst:6256,simpl,simple,6256,interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst,1,['simpl'],['simple']
Usability,"ray Collection. A **`TObjArray`** is a collection which supports traditional array; semantics via the overloading of `operator[]`. Objects can be directly; accessed via an index. The array expands automatically when objects are; added. At creation time one specifies the default array size (default =; 16) and lower bound (default = 0). Resizing involves a re-allocation and; a copy of the old array to the new. This can be costly if done too; often. If possible, set initial size close to expected final size. Index; validity is always checked (if you are 100% sure and maximum performance; is needed you can use `UnCheckedAt()` instead of `At()` or; `operator[]`). If the stored objects are sort able the array can be; sorted using `Sort()`. Once sorted, efficient searching is possible via; the `BinarySearch()` method. The figure shows the internal data; structure of a **`TObjArray`**:. ![The internal data structure of a TObjArray](pictures/020001A7.jpg). Iterating can be done using a **`TIter`** iterator or via a simple for; loop:. ``` {.cpp}; for (int i = 0; i <= fArr.GetLast(); i++); if ((track = (TTrack*)fArr[i])) // or fArr.At(i); track->Draw();; ```. Main features of **`TObjArray`** are simple, well-known array semantics.; **Overhead per element**: none, except possible over sizing of `fCont`. ## TClonesArray An Array of Identical Objects. A **`TClonesArray`** is an array of identical (clone) objects. The; memory for the objects stored in the array is allocated only once in the; lifetime of the clones array. All objects must be of the same class. For; the rest this class has the same properties as a **`TObjArray`**. ![The internal data structure of a TClonesArray](pictures/020001A8.jpg). The figure above shows the internal data structure of a; **`TClonesArray`**. The class is specially designed for repetitive data; analysis tasks, where in a loop many times the same objects, are created; and deleted. The only supported way to add objects to a; **`TClonesArray`** is via",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/CollectionClasses.md:15784,simpl,simple,15784,documentation/users-guide/CollectionClasses.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/CollectionClasses.md,1,['simpl'],['simple']
Usability,"rds. Even so, some fields of concrete; records may remain uninitialized. TableGen provides *multiclasses* to collect a group of record definitions in; one place. A multiclass is a sort of macro that can be ""invoked"" to define; multiple concrete records all at once. A multiclass can inherit from other; multiclasses, which means that the multiclass inherits all the definitions; from its parent multiclasses. `Appendix C: Sample Record`_ illustrates a complex record in the Intel X86; target and the simple way in which it is defined. Source Files; ============. TableGen source files are plain ASCII text files. The files can contain; statements, comments, and blank lines (see `Lexical Analysis`_). The standard file; extension for TableGen files is ``.td``. TableGen files can grow quite large, so there is an include mechanism that; allows one file to include the content of another file (see `Include; Files`_). This allows large files to be broken up into smaller ones, and; also provides a simple library mechanism where multiple source files can; include the same library file. TableGen supports a simple preprocessor that can be used to conditionalize; portions of ``.td`` files. See `Preprocessing Facilities`_ for more; information. Lexical Analysis; ================. The lexical and syntax notation used here is intended to imitate; `Python's`_ notation. In particular, for lexical definitions, the productions; operate at the character level and there is no implied whitespace between; elements. The syntax definitions operate at the token level, so there is; implied whitespace between tokens. .. _`Python's`: http://docs.python.org/py3k/reference/introduction.html#notation. TableGen supports BCPL-style comments (``// ...``) and nestable C-style; comments (``/* ... */``).; TableGen also provides simple `Preprocessing Facilities`_. Formfeed characters may be used freely in files to produce page breaks when; the file is printed for review. The following are the basic punctuation to",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TableGen/ProgRef.rst:6155,simpl,simple,6155,interpreter/llvm-project/llvm/docs/TableGen/ProgRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TableGen/ProgRef.rst,1,['simpl'],['simple']
Usability,"rdware; extension that would add native support to use a shadow stack to store/check; return addresses at call/return time. Being a hardware implementation, it; would not suffer from race conditions and would not incur the overhead of; function instrumentation, but it does require operating system support. .. _`Return Flow Guard`: https://xlab.tencent.com/en/2016/11/02/return-flow-guard/; .. _`Control-flow Enforcement Technology`: https://software.intel.com/sites/default/files/managed/4d/2a/control-flow-enforcement-technology-preview.pdf. Compatibility; -------------. A runtime is not provided in compiler-rt so one must be provided by the; compiled application or the operating system. Integrating the runtime into; the operating system should be preferred since otherwise all thread creation; and destruction would need to be intercepted by the application. The instrumentation makes use of the platform register ``x18`` on AArch64 and; ``x3`` (``gp``) on RISC-V. For simplicity we will refer to this as the; ``SCSReg``. On some platforms, ``SCSReg`` is reserved, and on others, it is; designated as a scratch register. This generally means that any code that may; run on the same thread as code compiled with ShadowCallStack must either target; one of the platforms whose ABI reserves ``SCSReg`` (currently Android, Darwin,; Fuchsia and Windows) or be compiled with a flag to reserve that register (e.g.,; ``-ffixed-x18``). If absolutely necessary, code compiled without reserving the; register may be run on the same thread as code that uses ShadowCallStack by; saving the register value temporarily on the stack (`example in Android`_) but; this should be done with care since it risks leaking the shadow call stack; address. .. _`example in Android`: https://android-review.googlesource.com/c/platform/frameworks/base/+/803717. Because it requires a dedicated register, the ShadowCallStack feature is; incompatible with any other feature that may use ``SCSReg``. However, there is; no inh",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ShadowCallStack.rst:2898,simpl,simplicity,2898,interpreter/llvm-project/clang/docs/ShadowCallStack.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ShadowCallStack.rst,1,['simpl'],['simplicity']
Usability,"re dozens of passes inside the compiler, each of these flags; take a regular expression that identifies the name of the pass which should; emit the associated diagnostic. For example, to get a report from the inliner,; compile the code with:. .. code-block:: console. $ clang -O2 -Rpass=inline code.cc -o code; code.cc:4:25: remark: foo inlined into bar [-Rpass=inline]; int bar(int j) { return foo(j, j - 2); }; ^. Note that remarks from the inliner are identified with `[-Rpass=inline]`.; To request a report from every optimization pass, you should use; `-Rpass=.*` (in fact, you can use any valid POSIX regular; expression). However, do not expect a report from every transformation; made by the compiler. Optimization remarks do not really make sense; outside of the major transformations (e.g., inlining, vectorization,; loop optimizations) and not every optimization pass supports this; feature. Note that when using profile-guided optimization information, profile hotness; information can be included in the remarks (see; :ref:`-fdiagnostics-show-hotness <opt_fdiagnostics-show-hotness>`). Current limitations; ^^^^^^^^^^^^^^^^^^^. 1. Optimization remarks that refer to function names will display the; mangled name of the function. Since these remarks are emitted by the; back end of the compiler, it does not know anything about the input; language, nor its mangling rules. 2. Some source locations are not displayed correctly. The front end has; a more detailed source location tracking than the locations included; in the debug info (e.g., the front end can locate code inside macro; expansions). However, the locations used by `-Rpass` are; translated from debug annotations. That translation can be lossy,; which results in some remarks having no location information. Options to Emit Resource Consumption Reports; --------------------------------------------. These are options that report execution time and consumed memory of different; compilations steps. .. option:: -fproc-stat-r",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:25251,guid,guided,25251,interpreter/llvm-project/clang/docs/UsersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst,1,['guid'],['guided']
Usability,"reachable code; 3 . Compute live ranges for CSE; 4 . [t] Jump threading (jumps to jumps with identical or inverse conditions); 5 . [t] CSE; 6 . *** Conversion to SSA ; 7 . [t] SSA Based DCE; 8 . *** Conversion to LLVM; 9 . UnSSA; 10. GCSE; 11. LICM; 12. Strength Reduction; 13. Loop unrolling; 14. [t] CSE; 15. [t] DCE; 16. Instruction combination, register movement, scheduling... etc. I've marked optimizations with a [t] to indicate things that I believe to; be relatively trivial to implement in LLVM itself. The time consuming; things to reimplement would be SSA based PRE, Strength reduction & loop; unrolling... these would be the major things we would miss out on if we; did LLVM creation from tree code [inlining and other high level; optimizations are done on the tree representation]. Given the lack of ""strong"" optimizations that would take a long time to; reimplement, I am leaning a bit more towards creating LLVM from the tree; code. Especially given that SGI has GPL'd their compiler, including many; SSA based optimizations that could be adapted (besides the fact that their; code looks MUCH nicer than GCC :). Even if we choose to do LLVM code emission from RTL, we will almost; certainly want to move LLVM emission from step 8 down until at least CSE; has been rerun... which causes me to wonder if the SSA generation code; will still work (due to global variable dependencies and stuff). I assume; that it can be made to work, but might be a little more involved than we; would like. I'm continuing to look at the Tree -> RTL code. It is pretty gross; because they do some of the translation a statement at a time, and some; of it a function at a time... I'm not quite clear why and how the; distinction is drawn, but it does not appear that there is a wonderful; place to attach extra info. Anyways, I'm proceeding with the RTL -> LLVM conversion phase for now. We; can talk about this more on Monday. Wouldn't it be nice if there were a obvious decision to be made? :). -Chris. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HistoricalNotes/2001-06-01-GCCOptimizations.txt:2117,clear,clear,2117,interpreter/llvm-project/llvm/docs/HistoricalNotes/2001-06-01-GCCOptimizations.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HistoricalNotes/2001-06-01-GCCOptimizations.txt,1,['clear'],['clear']
Usability,"reated and configured locally by the user, is added; to the input list and recuperated from there on the worker machines for; processing. Any input list setting in the selector itself is not; streamed but temporarly moved to then standard input list, so that user; can use the selector input list as container of processing information; if they find convenient to do so. Process(...) methods with the file; name argument replaced by 'TSelector *' have  introduced where; relevant (TProof, TProofPlayer and their derivatives, TDSet).  ; Add the possibility to force submerging at node level, i.e. one; submerger per physical machine. In this way the network traffic can be; minimized, for example when merging large output files. The new feature; is enabled by setting the Int_t parameter 'PROOF_MergersByHost' (or the; directive 'Proof.MergersByHost') to a non-null value.; Simplify enabling of basic feedback. In TProof::Process, add; support for switches ""fb=name1,name2,name3,... "" or; ""feedback=name1,name2,name3,... "" in the option field. This enables; feedback for the specified objects, creating a TDrawFeedback object; attached to the session. Feedback for the specified objects is disabled; at the end of the query and the created TDrawFeedback is destroyed. The; special name 'stats' enables the three feedback histograms required by; a dedicated new class TStatsFeedback, and uses a TStatsFeedback instead; of TDrawFeedback to display the feedback. . Improvements; ; Add to TProofMgr two static functions to upload files. These; functions are both called UploadFiles and differ in the first argument,; which is used to pass the files to be uploaded. These can be given as a; list (of TFileInfo or TObjString), a directory or specified in a text; file.; Add support for paralell dataset verification. This is; implemented via a dedicated TSelector (TSelVerifyDataSet) which is run; over the list of files in the dataset via TPacketizerFile. The file; order is preserved using the recently i",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/doc/v534/index.html:1969,feedback,feedback,1969,proof/doc/v534/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/doc/v534/index.html,1,['feedback'],['feedback']
Usability,"reation of a dictionary; given one (or more) class name(s) and the name(s) of its header files. gInterpreter->GenerateDictionary(""vector<vector<float> >;list<vector<float> >"",""list;vector"");; gInterpreter->GenerateDictionary(""myclass"",""myclass.h;myhelper.h"");; This replaces the recommendation of creating a small 'loader.C' script to create the dictionaries. Implement a ShowMembers function for interpreted classes, by querying the interpreter for the data member; information.; In order to fix possible buffer overflow of parent string buffer in TMemberInspector,; the signature of ShowMember() was changed to no longer require (nor request) the; caller to provide a buffer (of length unknown to the callee.); Improve the uniqueness of globally visible symbols to allow for the mixing of; dictionaries with very similar layout. Cont. New functions for TClonesArray:. AbsorbObjects(TClonesArray* otherTCA):; Allows one to directly move the object pointers from otherTCA to the calling; TCA without cloning (copying). The calling TCA takes over ownership of all of; the moved objects. otherTCA is left empty upon return. MultiSort(Int_t nTCs, TClonesArray** tcs):; Sorts multiple TClonesArrays simultaneously using the calling TCA's objects; as the sorting key. New function for TSeqCollection:. QSort(Object **a, Int_t nBs, TObject ***b):; Sort array a of TObject pointers using a quicksort algorithm. Arrays b will; be sorted just like a (a determines the sort; nBs is the number of TObject**; arrays in b). Uses ObjCompare() to compare objects. This function is used by; the new function TClonesArray::MultiSort(). Add a new option ""+"" in TClonesArray::Clear. When the option starts with ""C+"",; eg ""C+xyz"" the objects in the array are in turn cleared with the option ""xyz"".; Since the Collection objects do have a name and the Clone method does allow; for the name to change, TCollection::Clone was added to implement the name change properly. Thread. New static function TThread::IsInitialized. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/doc/v528/index.html:4998,clear,cleared,4998,core/doc/v528/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/doc/v528/index.html,1,['clear'],['cleared']
Usability,"rectories we explored above are available when downloading the; binaries. When downloading the source you also get a directory for; each library with the corresponding header and source files, located; in the `inc` and `src` subdirectories. To see what classes are in a; library, you can check the `<library>/inc` directory for the list of; class definitions. For example, the physics library `libPhysics.so`; contains these class definitions:. ``` {.cpp}; > ls -m $ROOTSYS/math/physics/inc/; LinkDef.h, TFeldmanCousins.h, TGenPhaseSpace.h, TLorentzRotation.h,; TLorentzVector.h, TQuaternion.h, TRobustEstimator.h, TRolke.h,; TRotation.h, TVector2.h, TVector3.h; ```. ## How to Find More Information. website The ROOT web site has up to date documentation. The ROOT; source code automatically generates this documentation, so each class; is explicitly documented on its own web page, which is always up to; date with the latest official release of ROOT. The ROOT Reference Guide web pages can be found at class index; reference guide <https://root.cern/doc/master/classes.html>. Each; page contains a class description, and an explanation of each method.; It shows the class inheritance tree and lets you jump to the parent; class page by clicking on the class name. If you want more details,; you can even see the source. There is a help page available in the; little box on the upper right hand side of each class documentation; page. You can see on the next page what a typical class documentation; web page looks like. The ROOT web site also contains in addition to; this Reference Guide, ""How To's"", a list of publications and example; applications. ### Class Reference Guide. The top of any class reference page lets you jump to different parts; of the documentation. The first line links to the class index and the; index for the current module (a group of classes, often a library).; The second line links to the ROOT homepage and the class overviews.; The third line links the source informat",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md:24487,guid,guide,24487,documentation/users-guide/Introduction.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md,1,['guid'],['guide']
Usability,"ree has one branch for; each data member of `Event`, `Track`, and `EventHeader`. Now we can use; `TTree::MakeClass` on our tree ""`T`"". `MakeClass` takes one parameter, a; string containing the name of the class to be made. In the command; below, the name of our class will be ""`MyClass`"". ``` {.cpp}; root[] T->MakeClass(""MyClass""); Files: MyClass.h and MyClass.C generated from Tree: T; ```. Cling informs us that it has created two files. `MyClass.`h contains the; class definition and `MyClass.C` contains the `MyClass::Loop()` method.; `MyClass` has more methods than just `Loop()`. The other methods are a; constructor, a destructor, `GetEntry()`, `LoadTree()`, `Notify()`,; `Cut()` and `Show()`. The implementations of these methods are in the .h; file. This division of methods was done intentionally. The .C file is; kept as short as possible, and contains only code that is intended for; you to customize. The .h file contains all the other methods. It is; clear that you want to be as independent as possible of the header file; (i.e. `MyClass.h`) generated by `MakeClass`. The solution is to; implement a derived class, for example `MyRealClass` deriving from; `MyClass` such that a change in your `Tree `or regeneration of; `MyClass.h` does not force you to change `MyRealClass.h`. You can; imagine deriving several classes from `MyClass.h`, each with a specific; algorithm. To understand both files, let's start with `MyClass.h` and; the class declaration:. ### MyClass.h. ``` {.cpp}; class MyClass {; public :; // Pointer to the analyzed TTree or TChain; TTree *fChain;; // Current Tree number in a TChain; Int_t fCurrent;; // Declaration of leaves types; UInt_t fUniqueID;; UInt_t fBits;; Char_t fType[20];; Int_t fNtrack;; Int_t fNseg;; Int_t fNvertex;; UInt_t fFlag;; Float_t fTemperature;; Int_t fEvtHdr_fEvtNum;; // List of branches; TBranch *b_fUniqueID;; TBranch *b_fBits;; TBranch *b_fType;; TBranch *b_fNtrack;; TBranch *b_fNseg;; TBranch *b_fNvertex;; TBranch *b_fFlag;; TBran",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:124665,clear,clear,124665,documentation/users-guide/Trees.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md,1,['clear'],['clear']
Usability,"ref); ...; DW_AT_artificial (true). A Fortran front-end may need to generate a *trampoline* function to call a; function defined in a different compilation unit. In this case, the front-end; can emit the following descriptor for the trampoline function:. .. code-block:: text. !DISubprogram(name: ""sub1_.t0p"", linkageName: ""sub1_.t0p"", scope: !4, file: !4, type: !5, spFlags: DISPFlagLocalToUnit | DISPFlagDefinition, unit: !7, retainedNodes: !24, targetFuncName: ""sub1_""). The targetFuncName field is the name of the function that the trampoline; calls. This descriptor results in the following DWARF tag:. .. code-block:: text. DW_TAG_subprogram; ...; DW_AT_linkage_name	(""sub1_.t0p""); DW_AT_name	(""sub1_.t0p""); DW_AT_trampoline	(""sub1_""). Debugging information format; ============================. Debugging Information Extension for Objective C Properties; ----------------------------------------------------------. Introduction; ^^^^^^^^^^^^. Objective C provides a simpler way to declare and define accessor methods using; declared properties. The language provides features to declare a property and; to let compiler synthesize accessor methods. The debugger lets developer inspect Objective C interfaces and their instance; variables and class variables. However, the debugger does not know anything; about the properties defined in Objective C interfaces. The debugger consumes; information generated by compiler in DWARF format. The format does not support; encoding of Objective C properties. This proposal describes DWARF extensions to; encode Objective C properties, which the debugger can use to let developers; inspect Objective C properties. Proposal; ^^^^^^^^. Objective C properties exist separately from class members. A property can be; defined only by ""setter"" and ""getter"" selectors, and be calculated anew on each; access. Or a property can just be a direct access to some declared ivar.; Finally it can have an ivar ""automatically synthesized"" for it by the compiler,; in wh",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst:49276,simpl,simpler,49276,interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,1,['simpl'],['simpler']
Usability,"ref:`Phabricator <phabricator-reviews>`; instance for the duration of the migration. If you want to contribute to LLVM; now, please use GitHub. For more information about the workflow of using GitHub; Pull Requests see our :ref:`GitHub <github-reviews>` documentation. To make sure the right people see your patch, please select suitable reviewers; and add them to your patch when requesting a review. Suitable reviewers are the; code owner (see CODE_OWNERS.txt) and other people doing work in the area your; patch touches. Github will normally suggest some reviewers based on rules or; people that have worked on the code before. If you are a new contributor, you; will not be able to select reviewers in such a way, in which case you can still; get the attention of potential reviewers by CC'ing them in a comment -- just; @name them. A reviewer may request changes or ask questions during the review. If you are; uncertain on how to provide test cases, documentation, etc., feel free to ask; for guidance during the review. Please address the feedback and re-post an; updated version of your patch. This cycle continues until all requests and comments; have been addressed and a reviewer accepts the patch with a `Looks good to me` or `LGTM`.; Once that is done the change can be committed. If you do not have commit; access, please let people know during the review and someone should commit it; on your behalf. If you have received no comments on your patch for a week, you can request a; review by 'ping'ing the GitHub PR with ""Ping"". The common courtesy 'ping' rate; is once a week. Please remember that you are asking for valuable time from other; professional developers. For more information on LLVM's code-review process, please see :doc:`CodeReview`. .. _commit_from_git:. For developers to commit changes from Git; -----------------------------------------. Once a patch is reviewed, you can select the ""Squash and merge"" button in the; GitHub web interface. You might need to rebase your",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Contributing.rst:4538,guid,guidance,4538,interpreter/llvm-project/llvm/docs/Contributing.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Contributing.rst,1,['guid'],['guidance']
Usability,"relations* and it should be used when a large number of input variables are; provided, otherwise TMVA will spend a long time in setting up the data set before training. ; ; - Build configuration:; - Add new cmake flags, `tmva-cpu` and `tmva-gpu`, which can be used to swicth on/off the CPU and GPU (based on CUDA) implementations of the TMVA Deep Learning module. `tmva-cpu` is enabled by; default if a Blas or CBlas library is found in the system. `tmva-gpu` is enabled when the cmake flag `cuda` is enabled and a compatible Cuda library is found. ; enabled if the corre; - Add possibility to independently configure building of optional pymva part of tmva with flag `-Dpymva=ON|OFF`. - New Cross Validation features:; - Add stratified splitting for cross validation.; - New plotting option in cross validation, average ROC curve. - Bugfixes:; - Fix bug in BDT training with imt=on; - Improved handling of large event numbers in cross validation using deterministic splitting. - Documentation:; - Update TMVA Users' guide. ## 2D Graphics Libraries. - Highlight mode is implemented for `TH1` and for `TGraph` classes. When; highlight mode is on, mouse movement over the bin will be represented; graphically. Histograms bins or graph points will be highlighted. Moreover,; any highlight emits signal `TCanvas::Highlighted()` which allows the user to; react and call their own function. For a better understanding see also; the tutorials `$ROOTSYS/tutorials/hist/hlHisto*.C` and; `$ROOTSYS/tutorials/graphs/hlGraph*.C` .; - Implement fonts embedding for PDF output. The ""EmbedFonts"" option allows to; embed the fonts used in a PDF file inside that file. This option relies on; the ""gs"" command (https://ghostscript.com). Example:. ~~~ {.cpp}; canvas->Print(""example.pdf"",""EmbedFonts"");; ~~~; - In TAttAxis::SaveAttributes` take into account the new default value for `TitleOffset`.; - When the histograms' title's font was set in pixel the position of the; `TPaveText` containing the title was not corr",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v616/index.md:16284,guid,guide,16284,README/ReleaseNotes/v616/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v616/index.md,1,['guid'],['guide']
Usability,"ren't associated with a pull-request **will be deleted**. Pull Requests; =============; The LLVM project is using GitHub Pull Requests for Code Reviews. This document; describes the typical workflow of creating a Pull Request and getting it reviewed; and accepted. This is meant as an overview of the GitHub workflow, for complete; documentation refer to `GitHub's documentation <https://docs.github.com/pull-requests>`_. GitHub Tools; ------------; You can interact with GitHub in several ways: via git command line tools,; the web browser, `GitHub Desktop <https://desktop.github.com/>`_, or the; `GitHub CLI <https://cli.github.com>`_. This guide will cover the git command line; tools and the GitHub CLI. The GitHub CLI (`gh`) will be most like the `arc` workflow and; recommended. Creating Pull Requests; ----------------------; Keep in mind that when creating a pull request, it should generally only contain one; self-contained commit initially.; This makes it easier for reviewers to understand the introduced changes and; provide feedback. It also helps maintain a clear and organized commit history; for the project. If you have multiple changes you want to introduce, it's; recommended to create separate pull requests for each change. Create a local branch per commit you want to submit and then push that branch; to your `fork <https://docs.github.com/en/pull-requests/collaborating-with-pull-requests/working-with-forks>`_; of the llvm-project and; `create a pull request from the fork <https://docs.github.com/en/pull-requests/collaborating-with-pull-requests/proposing-changes-to-your-work-with-pull-requests/creating-a-pull-request-from-a-fork>`_.; As GitHub uses the first line of the commit message truncated to 72 characters; as the pull request title, you may have to edit to reword or to undo this; truncation. Creating Pull Requests with GitHub CLI; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^; With the CLI it's enough to create the branch locally and then run:. ::. gh pr create. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GitHub.rst:1869,feedback,feedback,1869,interpreter/llvm-project/llvm/docs/GitHub.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GitHub.rst,1,['feedback'],['feedback']
Usability,"renamed during the; refactoring. Subclasses that choose to implement this rule have to implement; the ``findSymbolOccurrences`` member function. The following set of quick checks might help if you are unsure about the type; of rule you should use:. #. If you would like to transform the source in one translation unit and if; you don't need any cross-TU information, then the; ``SourceChangeRefactoringRule`` should work for you. #. If you would like to implement a rename-like operation with potential; interactive components, then ``FindSymbolOccurrencesRefactoringRule`` might; work for you. How to Create a Rule; ^^^^^^^^^^^^^^^^^^^^. Once you determine which type of rule is suitable for your needs you can; implement the refactoring by subclassing the rule and implementing its; interface. The subclass should have a constructor that takes the inputs that; are needed to perform the refactoring. For example, if you want to implement a; rule that simply deletes a selection, you should create a subclass of; ``SourceChangeRefactoringRule`` with a constructor that accepts the selection; range:. .. code-block:: c++. class DeleteSelectedRange final : public SourceChangeRefactoringRule {; public:; DeleteSelection(SourceRange Selection) : Selection(Selection) {}. Expected<AtomicChanges>; createSourceReplacements(RefactoringRuleContext &Context) override {; AtomicChange Replacement(Context.getSources(), Selection.getBegin());; Replacement.replace(Context.getSource,; CharSourceRange::getCharRange(Selection), """");; return { Replacement };; }; private:; SourceRange Selection;; };. The rule's subclass can then be added to the list of refactoring action's; rules for a particular action using the ``createRefactoringActionRule``; function. For example, the class that's shown above can be added to the; list of action rules using the following code:. .. code-block:: c++. RefactoringActionRules Rules;; Rules.push_back(; createRefactoringActionRule<DeleteSelectedRange>(; SourceRangeSelectionRe",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/RefactoringEngine.rst:5316,simpl,simply,5316,interpreter/llvm-project/clang/docs/RefactoringEngine.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/RefactoringEngine.rst,1,['simpl'],['simply']
Usability,"rence page <http://root.cern.ch/root/html/THtml>. The; following will enumerate some of the highlights. ### Referencing Documentation for other Libraries. When **`THtml`** generates documentation for classes it recognizes all; class names known to ROOT. If **`THtml`** does not have sources for a; class it determines the class's library name. This has to be set by; means of `rootmap` files, see Library AutoLoading of this User's Guide.; Given the library name, **`THtml`** searches for an entry in its map of; libraries to documentation URLs. If it finds it, it will create a link; to the documentation at that URL for all occurrences of a given class; name. One can set the URL `../mylib/` for a library name `MyLib` by; setting `Root.Html.MyLib:` `../mylib/` or by calling; `THtml::SetLibURL(""MyLib"", ""../mylib/"")`. Occurrences of class `MyClass`; of `MyLib` will now be referenced as `../mylib/MyClass.html`. ### Search Engine. **`THtml`** can invoke external search engines. The ROOT reference guide; sets `Root.Html.Search` to <http://www.google.com/search?q=%s+site%3A%u>.; Calling **`THtml::SetSearchStemURL()`** will set the same. If this URL stem is; set, `THtml` will create search fields in the index pages. It will; send the words entered in these search fields as %s in the URL; %u will; be replaced by the current document's path, allowing a site- and; directory-specific search. ### ViewCVS. Most code is managed in a version control system like CVS. ViewCVS is a; WWW reader interface to the versioning control system that allows e.g.; tracking a file's changes. **`THtml`** will reference these pages; automatically if the `.rootrc` variable `Root.Html.ViewCVS` is set to; the URL stem of the ViewCVS. installation. Alternatively, one can call; THtml::SetViewCVS(). ### Wiki Pages. In some contexts it might be desirable to let users comment on classes,; e.g. for suggestions of use or alternatives, details of behavior, and; cross references to other relevant classes. A successf",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/HTMLDoc.md:10538,guid,guide,10538,documentation/users-guide/HTMLDoc.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/HTMLDoc.md,1,['guid'],['guide']
Usability,"replace the null with an appropriate coroutine; handle value. The second argument should be `true` if this coro.end is in the block that is; part of the unwind sequence leaving the coroutine body due to an exception and; `false` otherwise. The third argument if present should specify a function to be called. If the third argument is present, the remaining arguments are the arguments to; the function call. .. code-block:: llvm. call i1 (ptr, i1, ...) @llvm.coro.end.async(; ptr %hdl, i1 0,; ptr @must_tail_call_return,; ptr %ctxt, ptr %task, ptr %actor); unreachable. .. _coro.suspend:; .. _suspend points:. 'llvm.coro.suspend' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^; ::. declare i8 @llvm.coro.suspend(token <save>, i1 <final>). Overview:; """""""""""""""""". The '``llvm.coro.suspend``' marks the point where execution of a; switched-resume coroutine is suspended and control is returned back; to the caller. Conditional branches consuming the result of this; intrinsic lead to basic blocks where coroutine should proceed when; suspended (-1), resumed (0) or destroyed (1). Arguments:; """""""""""""""""""". The first argument refers to a token of `coro.save` intrinsic that marks the; point when coroutine state is prepared for suspension. If `none` token is passed,; the intrinsic behaves as if there were a `coro.save` immediately preceding; the `coro.suspend` intrinsic. The second argument indicates whether this suspension point is `final`_.; The second argument only accepts constants. If more than one suspend point is; designated as final, the resume and destroy branches should lead to the same; basic blocks. Example (normal suspend point):; """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""". .. code-block:: llvm. %0 = call i8 @llvm.coro.suspend(token none, i1 false); switch i8 %0, label %suspend [i8 0, label %resume; i8 1, label %cleanup]. Example (final suspend point):; """""""""""""""""""""""""""""""""""""""""""""""""""""""""""". .. code-block:: llvm. while.end:; %s.final = call i8 @llvm.coro.suspend(token none, i1 true); switch",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst:50076,resume,resumed,50076,interpreter/llvm-project/llvm/docs/Coroutines.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst,1,['resume'],['resumed']
Usability,"resentation from M. Slawinska at a ROOT team meeting. define the functions as template functions instead of having the same re-definition for all the various basic types. This is done for TMath::Mean,TMath::GeomMean, TMath::Median, TMath::KOrdStat; Use STL to implement the following algorithms:; ; TMath::Sort is re-implemented using std::sort.; TMath::BinarySearch is re-implemented using the STL algorithm std::lower_bound. The STL algorithms have been found for these cases to be perform better in term of CPU time. For some other algorithms like TMath::LocMin, TMath::LocMax or TMath::Permute the original implementation is faster than STL and has been maintained.; ; Add a generic iterator interface, similar to the STL algorithm interface, to the following TMath functions:; MinElement, MaxElement, LocMin, LocMax, Mean, GeomMean, RMS,; BinarySearch. The iterator interface for sort is called; TMath::SortItr to avoid a compilation ambiguity. For example,; for finding the mean of a std::vector<double> v, one simply needs to call TMath::Mean(v.begin(), v.end() ) .; ; Various changes have been applied to the mathematical functions to remove duplications in the implementation with the special and statistical functions defined in ROOT::Math. The functions which have been changed and thus they can return a sightly different result than before are:; ; TMath::Erf and TMath::Erfc call ROOT::Math::erf and ROOT::math::erfc which are implemented using the Cephes algorithms, which is accurate at the required double precision level.; TMath::Gamma(z) is implemented with ROOT::Math::tgamma, which again uses Cephes.; The incomplete gamma function, TMath::Gamma(a,x) it is implemented using ROOT::Math::inc_gamma based on a corresponding Cephes function.; TMath::Prob (the upper chi2 probability) is implemented also using ROOT::Math::chisquared_cdf_c which uses ROOT::Math::inc_gamma_c based on a corresponding Cephes function. Now the implementation does not suffer anymore from large numerical ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/doc/v520/index.html:2471,simpl,simply,2471,math/doc/v520/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/doc/v520/index.html,1,['simpl'],['simply']
Usability,"ressions are enclosed with double braces, they are; visually distinct, and you don't need to use escape characters within the double; braces like you would in C. In the rare case that you want to match double; braces explicitly from the input, you can use something ugly like; ``{{[}][}]}}`` as your pattern. Or if you are using the repetition count; syntax, for example ``[[:xdigit:]]{8}`` to match exactly 8 hex digits, you; would need to add parentheses like this ``{{([[:xdigit:]]{8})}}`` to avoid; confusion with FileCheck's closing double-brace. FileCheck String Substitution Blocks; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. It is often useful to match a pattern and then verify that it occurs again; later in the file. For codegen tests, this can be useful to allow any; register, but verify that that register is used consistently later. To do; this, :program:`FileCheck` supports string substitution blocks that allow; string variables to be defined and substituted into patterns. Here is a simple; example:. .. code-block:: llvm. ; CHECK: test5:; ; CHECK: notw	[[REGISTER:%[a-z]+]]; ; CHECK: andw	{{.*}}[[REGISTER]]. The first check line matches a regex ``%[a-z]+`` and captures it into the; string variable ``REGISTER``. The second line verifies that whatever is in; ``REGISTER`` occurs later in the file after an ""``andw``"". :program:`FileCheck`; string substitution blocks are always contained in ``[[ ]]`` pairs, and string; variable names can be formed with the regex ``[a-zA-Z_][a-zA-Z0-9_]*``. If a; colon follows the name, then it is a definition of the variable; otherwise, it; is a substitution. :program:`FileCheck` variables can be defined multiple times, and substitutions; always get the latest value. Variables can also be substituted later on the; same line they were defined on. For example:. .. code-block:: llvm. ; CHECK: op [[REG:r[0-9]+]], [[REG]]. Can be useful if you want the operands of ``op`` to be the same register,; and don't care exactly which register it is. If ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/FileCheck.rst:26473,simpl,simple,26473,interpreter/llvm-project/llvm/docs/CommandGuide/FileCheck.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/FileCheck.rst,1,['simpl'],['simple']
Usability,"returns kNone, as it does; for successful addition, indicating it does not require further; information about this object. Hence you should not try to make any; assumptions about what the viewer did with the object. The viewer may; decide to force the client to rebuild (republish) the scene, obtaining a; different collection of objects, if the internal viewer state changes; .e.g. significant camera move. It does this presently by forcing a; repaint on the attached **`TPad`** object - hence you should attach you; master geometry object to the pad (via `TObject::Draw()`), and perform; the publishing to the viewer in response to **`TObject::Paint()`**. #### Physical IDs. TVirtualViewer3D provides for two methods of object addition:. ``` {.cpp}; virtual Int_t AddObject(const TBuffer3D &buffer,; Bool_t * addChildren = 0); virtual Int_t AddObject(UInt_t physicalID,; const TBuffer3D & buffer,; Bool_t *addChildren = 0); ```. If you use the first (simple) case a viewer using logical/physical pairs; will generate sequential IDs for each physical object internally. Scene; rebuilds will require destruction and recreation of all physical; objects. For the second you can specify an identifier from the client; side, which must be unique and stable - i.e. the IDs of a published; object is consistent, regardless of changes in termination of contained; child geometry branches. In this case the viewer can safely cache the; physical objects across scene rebuilds, discarding those no longer of; interest. #### Child Objects. In many geometries there is a rigid containment hierarchy, and so if the; viewer is not interested in a certain object due to limits/size then it; will also not be interest in any of the contained branch of siblings.; Both `TBuffer3D::AddObject()` methods have an `addChildren` return; parameter. The viewer will complete this (if passed) indicating if; children of the object just sent are worth sending. #### Recycling TBuffer3D. Once add `TBuffer3D::AddObject()` has b",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md:137831,simpl,simple,137831,documentation/users-guide/Graphics.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md,1,['simpl'],['simple']
Usability,"reventing future redefinition. This code does have a bug, though: If the ``FunctionAST::codegen()`` method; finds an existing IR Function, it does not validate its signature against the; definition's own prototype. This means that an earlier 'extern' declaration will; take precedence over the function definition's signature, which can cause; codegen to fail, for instance if the function arguments are named differently.; There are a number of ways to fix this bug, see what you can come up with! Here; is a testcase:. ::. extern foo(a); # ok, defines foo.; def foo(b) b; # Error: Unknown variable name. (decl using 'a' takes precedence). Driver Changes and Closing Thoughts; ===================================. For now, code generation to LLVM doesn't really get us much, except that; we can look at the pretty IR calls. The sample code inserts calls to; codegen into the ""``HandleDefinition``"", ""``HandleExtern``"" etc; functions, and then dumps out the LLVM IR. This gives a nice way to look; at the LLVM IR for simple functions. For example:. ::. ready> 4+5;; Read top-level expression:; define double @0() {; entry:; ret double 9.000000e+00; }. Note how the parser turns the top-level expression into anonymous; functions for us. This will be handy when we add `JIT; support <LangImpl04.html#adding-a-jit-compiler>`_ in the next chapter. Also note that the; code is very literally transcribed, no optimizations are being performed; except simple constant folding done by IRBuilder. We will `add; optimizations <LangImpl04.html#trivial-constant-folding>`_ explicitly in the next; chapter. ::. ready> def foo(a b) a*a + 2*a*b + b*b;; Read function definition:; define double @foo(double %a, double %b) {; entry:; %multmp = fmul double %a, %a; %multmp1 = fmul double 2.000000e+00, %a; %multmp2 = fmul double %multmp1, %b; %addtmp = fadd double %multmp, %multmp2; %multmp3 = fmul double %b, %b; %addtmp4 = fadd double %addtmp, %multmp3; ret double %addtmp4; }. This shows some simple arithmetic. N",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl03.rst:17835,simpl,simple,17835,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl03.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl03.rst,1,['simpl'],['simple']
Usability,"rg));; else; return nullptr;. if (CurTok == ')'); break;. if (CurTok != ','); return LogError(""Expected ')' or ',' in argument list"");; getNextToken();; }; }. // Eat the ')'.; getNextToken();. return std::make_unique<CallExprAST>(IdName, std::move(Args));; }. This routine follows the same style as the other routines. (It expects; to be called if the current token is a ``tok_identifier`` token). It; also has recursion and error handling. One interesting aspect of this is; that it uses *look-ahead* to determine if the current identifier is a; stand alone variable reference or if it is a function call expression.; It handles this by checking to see if the token after the identifier is; a '(' token, constructing either a ``VariableExprAST`` or; ``CallExprAST`` node as appropriate. Now that we have all of our simple expression-parsing logic in place, we; can define a helper function to wrap it together into one entry point.; We call this class of expressions ""primary"" expressions, for reasons; that will become more clear `later in the; tutorial <LangImpl06.html#user-defined-unary-operators>`_. In order to parse an arbitrary; primary expression, we need to determine what sort of expression it is:. .. code-block:: c++. /// primary; /// ::= identifierexpr; /// ::= numberexpr; /// ::= parenexpr; static std::unique_ptr<ExprAST> ParsePrimary() {; switch (CurTok) {; default:; return LogError(""unknown token when expecting an expression"");; case tok_identifier:; return ParseIdentifierExpr();; case tok_number:; return ParseNumberExpr();; case '(':; return ParseParenExpr();; }; }. Now that you see the definition of this function, it is more obvious why; we can assume the state of CurTok in the various functions. This uses; look-ahead to determine which sort of expression is being inspected, and; then parses it with a function call. Now that basic expressions are handled, we need to handle binary; expressions. They are a bit more complex. Binary Expression Parsing; =================",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl02.rst:11120,clear,clear,11120,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl02.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl02.rst,1,['clear'],['clear']
Usability,"riable; number of tracks, and each track has several variables. - `tree4.C:` a tree with a class (`Event`). The class Event is defined; in `$ROOTSYS/test`. In this example we first encounter the impact of; splitting a branch. Each script contains the main function, with the same name as the file; (i.e. `tree1`), the function to write - `tree1w`, and the function to; read - `tree1r`. If the script is not run in batch mode, it displays the; tree in the browser and tree viewer. To study the example scripts, you; can either execute the main script, or load the script and execute a; specific function. For example:. ``` {.cpp}; // execute the function that writes, reads, shows the tree; root[] x tree1.C; // use ACLiC to build shared library, check syntax, execute; root[] x tree1.C++; // Load the script and select a function to execute; root[] L tree1.C; root[] tree1w(); root[] tree1r(); ```. ## Example 1: A Tree with Simple Variables. This example shows how to write, view, and read a tree with several; simple (integers and floating-point) variables. ### Writing the Tree. Below is the function that writes the tree (`tree1w`). First, the; variables are defined (`px, py, pz,` `random` and `ev`). Then we add a; branch for each of the variables to the tree, by calling the; `TTree::Branch` method for each variable. ``` {.cpp}; void tree1w(){. // create a tree file tree1.root - create the file, the Tree and; // a few branches; TFile f(""tree1.root"",""recreate"");; TTree t1(""t1"",""a simple Tree with simple variables"");; Float_t px, py, pz;; Double_t random;; Int_t ev;; t1.Branch(""px"",&px,""px/F"");; t1.Branch(""py"",&py,""py/F"");; t1.Branch(""pz"",&pz,""pz/F"");; t1.Branch(""ev"",&ev,""ev/I"");. // fill the tree; for (Int_t i=0; i<10000; i++) {; gRandom->Rannor(px,py);; pz = px*px + py*py;; random = gRandom->Rndm();; ev = i;; t1.Fill();; }; // save the Tree heade; the file will be automatically closed; // when going out of the function scope; t1.Write();; }; ```. #### Creating Branches with A sing",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:34930,simpl,simple,34930,documentation/users-guide/Trees.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md,1,['simpl'],['simple']
Usability,"riate coroutine; handle value. The second argument should be `true` if this coro.end is in the block that is; part of the unwind sequence leaving the coroutine body due to an exception and; `false` otherwise. Non-trivial (non-none) token argument can only be specified for unique-suspend; returned-continuation coroutines where it must be a token value produced by; '``llvm.coro.end.results``' intrinsic. Only none token is allowed for coro.end calls in unwind sections. Semantics:; """"""""""""""""""""; The purpose of this intrinsic is to allow frontends to mark the cleanup and; other code that is only relevant during the initial invocation of the coroutine; and should not be present in resume and destroy parts. In returned-continuation lowering, ``llvm.coro.end`` fully destroys the; coroutine frame. If the second argument is `false`, it also returns from; the coroutine with a null continuation pointer, and the next instruction; will be unreachable. If the second argument is `true`, it falls through; so that the following logic can resume unwinding. In a yield-once; coroutine, reaching a non-unwind ``llvm.coro.end`` without having first; reached a ``llvm.coro.suspend.retcon`` has undefined behavior. The remainder of this section describes the behavior under switched-resume; lowering. This intrinsic is lowered when a coroutine is split into; the start, resume and destroy parts. In the start part, it is a no-op,; in resume and destroy parts, it is replaced with `ret void` instruction and; the rest of the block containing `coro.end` instruction is discarded.; In landing pads it is replaced with an appropriate instruction to unwind to; caller. The handling of coro.end differs depending on whether the target is; using landingpad or WinEH exception model. For landingpad based exception model, it is expected that frontend uses the; `coro.end`_ intrinsic as follows:. .. code-block:: llvm. ehcleanup:; %InResumePart = call i1 @llvm.coro.end(ptr null, i1 true, token none); br i1 %InResumePa",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst:43907,resume,resume,43907,interpreter/llvm-project/llvm/docs/Coroutines.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst,1,['resume'],['resume']
Usability,"ribe how to *register* a register allocator machine; pass. Implement your register allocator machine pass. In your register allocator; ``.cpp`` file add the following include:. .. code-block:: c++. #include ""llvm/CodeGen/RegAllocRegistry.h"". Also in your register allocator ``.cpp`` file, define a creator function in the; form:. .. code-block:: c++. FunctionPass *createMyRegisterAllocator() {; return new MyRegisterAllocator();; }. Note that the signature of this function should match the type of; ``RegisterRegAlloc::FunctionPassCtor``. In the same file add the ""installing""; declaration, in the form:. .. code-block:: c++. static RegisterRegAlloc myRegAlloc(""myregalloc"",; ""my register allocator help string"",; createMyRegisterAllocator);. Note the two spaces prior to the help string produces a tidy result on the; :option:`-help` query. .. code-block:: console. $ llc -help; ...; -regalloc - Register allocator to use (default=linearscan); =linearscan - linear scan register allocator; =local - local register allocator; =simple - simple register allocator; =myregalloc - my register allocator help string; ... And that's it. The user is now free to use ``-regalloc=myregalloc`` as an; option. Registering instruction schedulers is similar except use the; ``RegisterScheduler`` class. Note that the; ``RegisterScheduler::FunctionPassCtor`` is significantly different from; ``RegisterRegAlloc::FunctionPassCtor``. To force the load/linking of your register allocator into the; :program:`llc`/:program:`lli` tools, add your creator function's global; declaration to ``Passes.h`` and add a ""pseudo"" call line to; ``llvm/Codegen/LinkAllCodegenComponents.h``. Creating new registries; -----------------------. The easiest way to get started is to clone one of the existing registries; we; recommend ``llvm/CodeGen/RegAllocRegistry.h``. The key things to modify are; the class name and the ``FunctionPassCtor`` type. Then you need to declare the registry. Example: if your pass registry is; ``Regist",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/WritingAnLLVMPass.rst:50514,simpl,simple,50514,interpreter/llvm-project/llvm/docs/WritingAnLLVMPass.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/WritingAnLLVMPass.rst,2,['simpl'],['simple']
Usability,"ribute to the computation of; the function's return value. .. _passes-loop-extract:. ``loop-extract``: Extract loops into new functions; --------------------------------------------------. A pass wrapper around the ``ExtractLoop()`` scalar transformation to extract; each top-level loop into its own new function. If the loop is the *only* loop; in a given function, it is not touched. This is a pass most useful for; debugging via bugpoint. ``loop-reduce``: Loop Strength Reduction; ----------------------------------------. This pass performs a strength reduction on array references inside loops that; have as one or more of their components the loop induction variable. This is; accomplished by creating a new value to hold the initial value of the array; access for the first iteration, and then creating a new GEP instruction in the; loop to increment the value by the appropriate amount. .. _passes-loop-rotate:. ``loop-rotate``: Rotate Loops; -----------------------------. A simple loop rotation transformation. A summary of it can be found in; :ref:`Loop Terminology for Rotated Loops <loop-terminology-loop-rotate>`. .. _passes-loop-simplify:. ``loop-simplify``: Canonicalize natural loops; ---------------------------------------------. This pass performs several transformations to transform natural loops into a; simpler form, which makes subsequent analyses and transformations simpler and; more effective. A summary of it can be found in; :ref:`Loop Terminology, Loop Simplify Form <loop-terminology-loop-simplify>`. Loop pre-header insertion guarantees that there is a single, non-critical entry; edge from outside of the loop to the loop header. This simplifies a number of; analyses and transformations, such as :ref:`LICM <passes-licm>`. Loop exit-block insertion guarantees that all exit blocks from the loop (blocks; which are outside of the loop that have predecessors inside of the loop) only; have predecessors from inside of the loop (and are thus dominated by the loop; head",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Passes.rst:26429,simpl,simple,26429,interpreter/llvm-project/llvm/docs/Passes.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Passes.rst,1,['simpl'],['simple']
Usability,"riding the Translate Function*: The `RooAbsArg::translate()` function; needs to be overridden to specify how the class is translating to C++ code; that is using the aforementioned free function. **Sample Steps**: To add Code Generation support to an existing RooFit class,; following is a sample set of steps (using the aforementioned approach of; extracting free functions in a separate file.). **1. Extract logic into a separate file** Implement what your class is; supposed to do as a free function in [MathFuncs].; This implementation must be compatible with the syntax supported by Clad. **2. Refactor evaluate():** Refactor the existing `RooAbsReal::evaluate()`; function to use the `MathFuncs.h` implementation. This is optional, but; can reduce code duplication and potential for bugs. This may require some; effort if an extensive caching infrastructure is used in your model. **3. Add translate():** RooFit classes are extended using a (typically) simple; `translate()` function that extracts the mathematically differentiable; properties out of the RooFit classes that make up the statistical model. The `translate()` function helps implement the Code Squashing logic that is; used to optimize numerical evaluations. It accomplishes this by using a small; subset of helper functions that are available in the; `RooFit::Detail::CodeSquashContext` and `RooFuncWrapper` classes; (see Appendix B). It converts a RooFit expression into a form that can be; efficiently evaluated by Clad. The `translate()` function returns an `std::string` representing the; underlying mathematical notation of the class as code, that can later be; concatenated into a single string representing the entire model. This string; of code is then just-in-time compiled by Cling (a C++ interpreter for Root). **4. analyticalIntegral() Use Case:** If your class includes (or should; include) the `analyticalIntegral()` function, then a simple; `buildCallToAnalyticIntegral()` function needs to be created to help call ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/developers/roofit_ad.md:8182,simpl,simple,8182,roofit/doc/developers/roofit_ad.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/developers/roofit_ad.md,1,['simpl'],['simple']
Usability,"ries during session startup, as they may significantly slowdown; the startup process is the medium is busy. In such a case, admins; are responsible to create the directories in advance; the session; releated part fo the path is created by the session once up.; In XrdProofd, move the check for the username after authentication.; This is because authentication may run some credentials-to-user mapping; which can modify the requested username. This way we really check the; final username and not the one requested by the client, which may even; not exist on the machines. Side modification: when the mapping function; returns more usernames, the username specified by the client is used to; help choosing the effective username among the available choices; if not; match is found the handshake does any longer fail, the first mapped; username is chosen instead.; In XrdProofd, allow 'xpd.allowedgroups' to control also PROOF; groups, not only UNIX ones.In XrdProofd, simplify error; messages in case of login failure because of non-authorization.; Remove hardcoded additions of dirname(COMPILER) and of; '/bin:/usr/bin:/usr/local/bin' in front of PATH. These uncontrolled; additions could hide specific settings in PATH and be the source of; weird problems appearing in PROOF only.; Add more flexibility to the definition of the library path seen by; proofserv. So far to avoid ambiguites in some cases, $ROOTSYS/lib was; removed and the one of the ROOT version chosen was added later on in; front, which proved to be to aggressive in some cases.; All changes (and fixes) needed to build against the version of Xrootd,; now always installed as external.; Fixes. Fix GetSessionLogs in PROOF-Lite; Restore correct parsing of ""workers=N"" in PROOF-Lite; In Proof-Bench, make sure that it can be run from any directory; and no matter how ROOT was installed; Fix issue in TProofPlayer::HandleHistogram preventing proper; histogram cleaning right after merging when using TH1::Add; histogram; were still des",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/doc/v532/index.html:2923,simpl,simplify,2923,proof/doc/v532/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/doc/v532/index.html,1,['simpl'],['simplify']
Usability,"ries, it must derive from; ``std::exception``.; If preserving the exception (or its type) is not possible, generic exceptions; are used to propagate the exception: ``Exception`` in Python or; ``CPyCppyy::PyException`` in C++. In the most common case of an instance of a C++ exception class derived from; ``std::exception`` that is thrown from a compiled library and which is; copyable, the exception can be caught and handled like any other bound C++; object (or with ``Exception`` on the Python and ``std::exception`` on the; C++ side).; If the exception is not copyable, but derived from ``std::exception``, the; result of its ``what()`` reported with an instance of Python's ``Exception``.; In all other cases, including exceptions thrown from interpreted code (due to; limitations of the Clang JIT), the exception will turn into an instance of; ``Exception`` with a generic message. The standard C++ exceptions are explicitly not mapped onto standard Python; exceptions, since other than a few simple cases, the mapping is too crude to; be useful as the typical usage in each standard library is too different.; Thus, for example, a thrown ``std::runtime_error`` instance will become a; ``cppyy.gbl.std.runtime_error`` instance on the Python side (with Python's; ``Exception`` as its base class), not a ``RuntimeError`` instance. The C++ code used for the examples below can be found; :doc:`here <cppyy_features_header>`, and it is assumed that that code is; loaded at the start of any session.; Download it, save it under the name ``features.h``, and load it:. .. code-block:: python. >>> import cppyy; >>> cppyy.include('features.h'); >>>. In addition, the examples require the ``throw`` to be in compiled code.; Save the following and build it into a shared library ``libfeatures.so`` (or; ``libfeatures.dll`` on MS Windows):. .. code-block:: C++. #include ""features.h"". void throw_an_error(int i) {; if (i) throw SomeError{""this is an error""};; throw SomeOtherError{""this is another error""};;",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/exceptions.rst:1369,simpl,simple,1369,bindings/pyroot/cppyy/cppyy/doc/source/exceptions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/exceptions.rst,1,['simpl'],['simple']
Usability,"rip Symbols"")));. This defines a variable that is conceptually of the type; ""``std::vector<enum Opts>``"". Thus, you can access it with standard vector; methods:. .. code-block:: c++. for (unsigned i = 0; i != OptimizationList.size(); ++i); switch (OptimizationList[i]); ... ... to iterate through the list of options specified. Note that the ""``cl::list``"" template is completely general and may be used with; any data types or other arguments that you can use with the ""``cl::opt``""; template. One especially useful way to use a list is to capture all of the; positional arguments together if there may be more than one specified. In the; case of a linker, for example, the linker takes several '``.o``' files, and; needs to capture them into a list. This is naturally specified as:. .. code-block:: c++. ...; cl::list<std::string> InputFilenames(cl::Positional, cl::desc(""<Input files>""), cl::OneOrMore);; ... This variable works just like a ""``vector<string>``"" object. As such, accessing; the list is simple, just like above. In this example, we used the; `cl::OneOrMore`_ modifier to inform the CommandLine library that it is an error; if the user does not specify any ``.o`` files on our command line. Again, this; just reduces the amount of checking we have to do. Collecting options as a set of flags; ------------------------------------. Instead of collecting sets of options in a list, it is also possible to gather; information for enum values in a **bit vector**. The representation used by the; `cl::bits`_ class is an ``unsigned`` integer. An enum value is represented by a; 0/1 in the enum's ordinal value bit position. 1 indicating that the enum was; specified, 0 otherwise. As each specified value is parsed, the resulting enum's; bit is set in the option's bit vector:. .. code-block:: c++. bits |= 1 << (unsigned)enum;. Options that are specified multiple times are redundant. Any instances after; the first are discarded. Reworking the above list example, we could replace `cl::li",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandLine.rst:21120,simpl,simple,21120,interpreter/llvm-project/llvm/docs/CommandLine.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandLine.rst,1,['simpl'],['simple']
Usability,"ription. Others always require a; tessellation description based on **`TBuffer3D`**'s `kRaw` /; `kRawSizes` points/lines/segments sections. - Some need the 3D object positions in the master (world) frame,; others can cope with local frames and a translation matrix to place; the object. - Some require bounding boxes for objects - others do not. Similarly some viewer clients are only capable of providing positions in; master frame, cannot provide bounding boxes etc. Additionally we do not; want to incur the cost of expensive tessellation operations if the; viewer does not require them. To cope with these variations the; **`TBuffer3D`** objects are filled by negotiation with the viewer. ![TBuffer3D class hierarchy](pictures/030000E0.png). **`TBuffer3D`** classes are conceptually divided into enumerated; sections: `kCore`, `kBoundingBox`, `kRaw` - see the class diagram and; the file `TBuffer3D.h` for more details. The **`TBuffer3D`** methods; `SectionsValid()`, `SetSectionsValid()`, `ClearSectionsValid()` are used; to test, set, clear these section validity flags e.g. ``` {.cpp}; buffer.SetSectionsValid(TBuffer3D::kShapeSpecific);; ...; if (buffer.SectionsValid(TBuffer3D:: kShapeSpecific)) {; ...; }; ```. The sections found in the base **`TBuffer3D`**; (`kCore/kBoundingBox/kRawSizes/kRaw`) are sufficient to describe any; tessellated shape in a generic fashion. An additional `kShapeSpecific`; section is added in **`TBuffer3D`** derived classes, allowing a more; abstract shape description (""a sphere of inner radius x, outer radius; y""). This enables a viewer, which knows how to draw (tessellate) the; shape itself to do so, while providing a generic fallback suitable for; all viewers. The rules for client negotiation with the viewer are:. - If suitable specialized **`TBuffer3D`** class exists, use it,; otherwise use **`TBuffer3D`**. - Complete the mandatory `kCore` section. - Complete the `kShapeSpecific` section if applicable. - Complete the `kBoundingBox` if you can. - Pa",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md:127493,clear,clear,127493,documentation/users-guide/Graphics.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md,1,['clear'],['clear']
Usability,"rit from multiple classes. In that case the order that that happens in matches the order you write the class names after the `:`. ```tablegen; class C {; int a = 1;; }; class D {; int a = 2;; }; class E : C, D {}; ```. ------------- Classes -----------------; class C {; int a = 1;; }; class D {; int a = 2;; }; class E {	// C D; int a = 2;; }; ------------- Defs -----------------. Class `E` first inherits from class `C`. This gives `E` a member `a` with value `1`. Then it inherits from class `D` which also has a member `a` but with a value of `2`. Meaning the final value of `E`'s `a` is `2`. When a member has the same name this is handled on a ""last one in wins"" basis. Assuming the types match. ```tablegen; class C {; string a = """";; }; class D {; int a = 2;; }; class E : C, D {}; ```. <stdin>:7:14: error: New definition of 'a' of type 'int' is incompatible with previous definition of type 'string'; class E : C, D {}; ^. When they don't match, we get an error. Luckily for us, we're about to learn all about types. ## Types. TableGen is statically typed with error checking to prevent you from assigning things with mismatched types. ```tablegen; class C {; int a;; bit b = 0;; string s = ""Hello"";; }; ```. ------------- Classes -----------------; class C {; int a = ?;; bit b = 0;; string s = ""Hello"";; }; ------------- Defs -----------------. Here we've created a class C with integer, bit (1 or 0) and string members. See [here](https://llvm.org/docs/TableGen/ProgRef.html#types) for a full list of types. Note that you do not have to give a member a default value, it can be left uninitialised. ```tablegen; %noreset. def X: C {}; ```. ------------- Classes -----------------; class C {; int a = ?;; bit b = 0;; string s = ""Hello"";; }; ------------- Defs -----------------; def X {	// C; int a = ?;; bit b = 0;; string s = ""Hello"";; }. When you make an instance of a class using `def`, that instance gets all the members of the class. Their values will be as set in the class, unless",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/jupyter/tablegen_tutorial_part_1.md:4746,learn,learn,4746,interpreter/llvm-project/llvm/utils/TableGen/jupyter/tablegen_tutorial_part_1.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/jupyter/tablegen_tutorial_part_1.md,1,['learn'],['learn']
Usability,"rk on C++20, C++23, C++2c, and C23 support:; There are still several C++20 features to complete, and work has begun on; supporting the latest language standards. Please see the; C++ status report page to find out what is; missing.; StringRef'ize APIs: A thankless but incredibly useful project is; StringRef'izing (converting to use llvm::StringRef instead of const; char * or std::string) various clang interfaces. This generally; simplifies the code and makes it more efficient.; Configuration Manager: Clang/LLVM works on a large number of; architectures and operating systems and can cross-compile to a similarly large; number of configurations, but the pitfalls of choosing the command-line; options, making sure the right sub-architecture is chosen and that the correct; optional elements of your particular system can be a pain. A tool that would investigate hosts and targets, and store the configuration; in files that can later be used by Clang itself to avoid command-line options,; especially the ones regarding which target options to use, would greatly alleviate; this problem. A simple tool, with little or no dependency on LLVM itself, that; will investigate a target architecture by probing hardware, software, libraries; and compiling and executing code to identify all properties that would be relevant; to command-line options (VFP, SSE, NEON, ARM vs. Thumb etc), triple settings etc.; The first stage is to build a CFLAGS for Clang that would produce code on the; current Host to the identified Target.; The second stage would be to produce a configuration file (that can be used; independently of the Host) so that Clang can read it and not need a gazillion; of command-line options. Such file should be simple JSON / INI or anything that; a text editor could change. If you hit a bug with Clang, it is very useful for us if you reduce the code; that demonstrates the problem down to something small. There are many ways to; do this; ask on Discourse,; Discord,; or for advice. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/OpenProjects.html:5950,simpl,simple,5950,interpreter/llvm-project/clang/www/OpenProjects.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/OpenProjects.html,2,['simpl'],['simple']
Usability,"rlying integer computation implied, there is no; difference. I'm writing a backend for a target which needs custom lowering for GEP. How do I do this?; -----------------------------------------------------------------------------------------. You don't. The integer computation implied by a GEP is target-independent.; Typically what you'll need to do is make your backend pattern-match expressions; trees involving ADD, MUL, etc., which are what GEP is lowered into. This has the; advantage of letting your code work correctly in more cases. GEP does use target-dependent parameters for the size and layout of data types,; which targets can customize. If you require support for addressing units which are not 8 bits, you'll need to; fix a lot of code in the backend, with GEP lowering being only a small piece of; the overall picture. How does VLA addressing work with GEPs?; ---------------------------------------. GEPs don't natively support VLAs. LLVM's type system is entirely static, and GEP; address computations are guided by an LLVM type. VLA indices can be implemented as linearized indices. For example, an expression; like ``X[a][b][c]``, must be effectively lowered into a form like; ``X[a*m+b*n+c]``, so that it appears to the GEP as a single-dimensional array; reference. This means if you want to write an analysis which understands array indices and; you want to support VLAs, your code will have to be prepared to reverse-engineer; the linearization. One way to solve this problem is to use the ScalarEvolution; library, which always presents VLA and non-VLA indexing in the same manner. .. _Rules:. Rules; =====. What happens if an array index is out of bounds?; ------------------------------------------------. There are two senses in which an array index can be out of bounds. First, there's the array type which comes from the (static) type of the first; operand to the GEP. Indices greater than the number of elements in the; corresponding static array type are valid. There ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GetElementPtr.rst:11739,guid,guided,11739,interpreter/llvm-project/llvm/docs/GetElementPtr.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GetElementPtr.rst,1,['guid'],['guided']
Usability,"rm to pass off to a optimizer or backend. Because; validity analysis and code generation can largely be done on the fly, there is; not hard requirement that the front-end actually build up a full AST for all; the expressions and statements in the code. TCC and GCC are examples of; compilers that either build no real AST (in the former case) or build a stripped; down and simplified AST (in the later case) because they focus primarily on; codegen.; On the opposite side of the spectrum, some clients (like refactoring) want; highly detailed information about the original source code and want a complete; AST to describe it with. Refactoring wants to have information about macro; expansions, the location of every paren expression '(((x)))' vs 'x', full; position information, and much more. Further, refactoring wants to look; across the whole program to ensure that it is making transformations; that are safe. Making this efficient and getting this right requires a; significant amount of engineering and algorithmic work that simply are; unnecessary for a simple static compiler.; The beauty of the clang approach is that it does not restrict how you use it.; In particular, it is possible to use the clang preprocessor and parser to build; an extremely quick and light-weight on-the-fly code generator (similar to TCC); that does not build an AST at all. As an intermediate step, clang supports; using the current AST generation and semantic analysis code and having a code; generation client free the AST for each function after code generation. Finally,; clang provides support for building and retaining fully-fledged ASTs, and even; supports writing them out to disk.; Designing the libraries with clean and simple APIs allows these high-level; policy decisions to be determined in the client, instead of forcing ""one true; way"" in the implementation of any of these libraries. Getting this right is; hard, and we don't always get it right the first time, but we fix any problems; when we ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/features.html:8123,simpl,simply,8123,interpreter/llvm-project/clang/www/features.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/features.html,2,['simpl'],"['simple', 'simply']"
Usability,"rmat on`` or; ``/* clang-format on */`` will not be formatted. The comments themselves will be; formatted (aligned) normally. Also, a colon (``:``) and additional text may; follow ``// clang-format off`` or ``// clang-format on`` to explain why; clang-format is turned off or back on. .. code-block:: c++. int formatted_code;; // clang-format off; void unformatted_code ;; // clang-format on; void formatted_code_again;. Configuring Style in Code; =========================. When using ``clang::format::reformat(...)`` functions, the format is specified; by supplying the `clang::format::FormatStyle; <https://clang.llvm.org/doxygen/structclang_1_1format_1_1FormatStyle.html>`_; structure. Configurable Format Style Options; =================================. This section lists the supported style options. Value type is specified for; each option. For enumeration types possible values are specified both as a C++; enumeration member (with a prefix, e.g. ``LS_Auto``), and as a value usable in; the configuration (without a prefix: ``Auto``). .. _BasedOnStyle:. **BasedOnStyle** (``String``) :ref:`¶ <BasedOnStyle>`; The style used for all options not specifically set in the configuration. This option is supported only in the :program:`clang-format` configuration; (both within ``-style='{...}'`` and the ``.clang-format`` file). Possible values:. * ``LLVM``; A style complying with the `LLVM coding standards; <https://llvm.org/docs/CodingStandards.html>`_; * ``Google``; A style complying with `Google's C++ style guide; <https://google.github.io/styleguide/cppguide.html>`_; * ``Chromium``; A style complying with `Chromium's style guide; <https://chromium.googlesource.com/chromium/src/+/refs/heads/main/styleguide/styleguide.md>`_; * ``Mozilla``; A style complying with `Mozilla's style guide; <https://firefox-source-docs.mozilla.org/code-quality/coding-style/index.html>`_; * ``WebKit``; A style complying with `WebKit's style guide; <https://www.webkit.org/coding/coding-style.html>`_; * ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:4998,usab,usable,4998,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,1,['usab'],['usable']
Usability,"rmatStyle &Style, Lexer &Lex,; SourceManager &SourceMgr,; std::vector<CharSourceRange> Ranges);. This reads a token stream out of the lexer ``Lex`` and reformats all the code; ranges in ``Ranges``. The ``FormatStyle`` controls basic decisions made during; formatting. A list of options can be found under :ref:`style-options`. The style options are described in :doc:`ClangFormatStyleOptions`. .. _style-options:. Style Options; -------------. The style options describe specific formatting options that can be used in; order to make `ClangFormat` comply with different style guides. Currently,; several style guides are hard-coded:. .. code-block:: c++. /// Returns a format style complying with the LLVM coding standards:; /// https://llvm.org/docs/CodingStandards.html.; FormatStyle getLLVMStyle();. /// Returns a format style complying with Google's C++ style guide:; /// http://google-styleguide.googlecode.com/svn/trunk/cppguide.xml.; FormatStyle getGoogleStyle();. /// Returns a format style complying with Chromium's style guide:; /// https://chromium.googlesource.com/chromium/src/+/refs/heads/main/styleguide/styleguide.md; FormatStyle getChromiumStyle();. /// Returns a format style complying with the GNU coding standards:; /// https://www.gnu.org/prep/standards/standards.html; FormatStyle getGNUStyle();. /// Returns a format style complying with Mozilla's style guide; /// https://firefox-source-docs.mozilla.org/code-quality/coding-style/index.html; FormatStyle getMozillaStyle();. /// Returns a format style complying with Webkit's style guide:; /// https://webkit.org/code-style-guidelines/; FormatStyle getWebkitStyle();. /// Returns a format style complying with Microsoft's style guide:; /// https://docs.microsoft.com/en-us/visualstudio/ide/editorconfig-code-style-settings-reference; FormatStyle getMicrosoftStyle();. These options are also exposed in the :doc:`standalone tools <ClangFormat>`; through the `-style` option. In the future, we plan on making this configurable.; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibFormat.rst:1536,guid,guide,1536,interpreter/llvm-project/clang/docs/LibFormat.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibFormat.rst,5,['guid'],"['guide', 'guidelines']"
Usability,"rmations within; instcombine are firing by selecting out lines with ""``IC``"" in them. At this point, you have a decision to make. Is the number of transformations; small enough to step through them using a debugger? If so, then try that. If there are too many transformations, then a source modification approach may; be helpful. In this approach, you can modify the source code of instcombine to; disable just those transformations that are being performed on your test input; and perform a binary search over the set of transformations. One set of places; to modify are the ""``visit*``"" methods of ``InstCombiner`` (*e.g.*; ``visitICmpInst``) by adding a ""``return false``"" as the first line of the; method. If that still doesn't remove enough, then change the caller of; ``InstCombiner::DoOneIteration``, ``InstCombiner::runOnFunction`` to limit the; number of iterations. You may also find it useful to use ""``-stats``"" now to see what parts of; instcombine are firing. This can guide where to put additional reporting code. At this point, if the amount of transformations is still too large, then; inserting code to limit whether or not to execute the body of the code in the; visit function can be helpful. Add a static counter which is incremented on; every invocation of the function. Then add code which simply returns false on; desired ranges. For example:. .. code-block:: c++. static int calledCount = 0;; calledCount++;; LLVM_DEBUG(if (calledCount < 212) return false);; LLVM_DEBUG(if (calledCount > 217) return false);; LLVM_DEBUG(if (calledCount == 213) return false);; LLVM_DEBUG(if (calledCount == 214) return false);; LLVM_DEBUG(if (calledCount == 215) return false);; LLVM_DEBUG(if (calledCount == 216) return false);; LLVM_DEBUG(dbgs() << ""visitXOR calledCount: "" << calledCount << ""\n"");; LLVM_DEBUG(dbgs() << ""I: ""; I->dump());. could be added to ``visitXOR`` to limit ``visitXor`` to being applied only to; calls 212 and 217. This is from an actual test case and raises an impor",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Bugpoint.rst:9684,guid,guide,9684,interpreter/llvm-project/llvm/docs/Bugpoint.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Bugpoint.rst,1,['guid'],['guide']
Usability,"rn LogErrorP(""Expected function name in prototype"");; case tok_identifier:; FnName = IdentifierStr;; Kind = 0;; getNextToken();; break;; case tok_unary:; getNextToken();; if (!isascii(CurTok)); return LogErrorP(""Expected unary operator"");; FnName = ""unary"";; FnName += (char)CurTok;; Kind = 1;; getNextToken();; break;; case tok_binary:; ... As with binary operators, we name unary operators with a name that; includes the operator character. This assists us at code generation; time. Speaking of, the final piece we need to add is codegen support for; unary operators. It looks like this:. .. code-block:: c++. Value *UnaryExprAST::codegen() {; Value *OperandV = Operand->codegen();; if (!OperandV); return nullptr;. Function *F = getFunction(std::string(""unary"") + Opcode);; if (!F); return LogErrorV(""Unknown unary operator"");. return Builder->CreateCall(F, OperandV, ""unop"");; }. This code is similar to, but simpler than, the code for binary; operators. It is simpler primarily because it doesn't need to handle any; predefined operators. Kicking the Tires; =================. It is somewhat hard to believe, but with a few simple extensions we've; covered in the last chapters, we have grown a real-ish language. With; this, we can do a lot of interesting things, including I/O, math, and a; bunch of other things. For example, we can now add a nice sequencing; operator (printd is defined to print out the specified value and a; newline):. ::. ready> extern printd(x);; Read extern:; declare double @printd(double). ready> def binary : 1 (x y) 0; # Low-precedence operator that ignores operands.; ...; ready> printd(123) : printd(456) : printd(789);; 123.000000; 456.000000; 789.000000; Evaluated to 0.000000. We can also define a bunch of other ""primitive"" operations, such as:. ::. # Logical unary not.; def unary!(v); if v then; 0; else; 1;. # Unary negate.; def unary-(v); 0-v;. # Define > with the same precedence as <.; def binary> 10 (LHS RHS); RHS < LHS;. # Binary logical or, which doe",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl06.rst:14252,simpl,simpler,14252,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl06.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl06.rst,1,['simpl'],['simpler']
Usability,"rns of frontend; code generation. However, the styles also have a great deal in common. In all cases, an LLVM coroutine is initially represented as an ordinary LLVM; function that has calls to `coroutine intrinsics`_ defining the structure of; the coroutine. The coroutine function is then, in the most general case,; rewritten by the coroutine lowering passes to become the ""ramp function"",; the initial entrypoint of the coroutine, which executes until a suspend point; is first reached. The remainder of the original coroutine function is split; out into some number of ""resume functions"". Any state which must persist; across suspensions is stored in the coroutine frame. The resume functions; must somehow be able to handle either a ""normal"" resumption, which continues; the normal execution of the coroutine, or an ""abnormal"" resumption, which; must unwind the coroutine without attempting to suspend it. Switched-Resume Lowering; ------------------------. In LLVM's standard switched-resume lowering, signaled by the use of; `llvm.coro.id`, the coroutine frame is stored as part of a ""coroutine; object"" which represents a handle to a particular invocation of the; coroutine. All coroutine objects support a common ABI allowing certain; features to be used without knowing anything about the coroutine's; implementation:. - A coroutine object can be queried to see if it has reached completion; with `llvm.coro.done`. - A coroutine object can be resumed normally if it has not already reached; completion with `llvm.coro.resume`. - A coroutine object can be destroyed, invalidating the coroutine object,; with `llvm.coro.destroy`. This must be done separately even if the; coroutine has reached completion normally. - ""Promise"" storage, which is known to have a certain size and alignment,; can be projected out of the coroutine object with `llvm.coro.promise`.; The coroutine implementation must have been compiled to define a promise; of the same size and alignment. In general, interacting ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst:2620,resume,resume,2620,interpreter/llvm-project/llvm/docs/Coroutines.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst,1,['resume'],['resume']
Usability,ro Devices <https://www.amd.com/>`__. .. _amdgpu-dwarf-AMD-ROCgdb:. 2. [AMD-ROCgdb] `AMD ROCm Debugger (ROCgdb) <https://github.com/ROCm-Developer-Tools/ROCgdb>`__. .. _amdgpu-dwarf-AMD-ROCm:. 3. [AMD-ROCm] `AMD ROCm Platform <https://rocm-documentation.readthedocs.io>`__. .. _amdgpu-dwarf-AMDGPU-DWARF-LOC:. 4. [AMDGPU-DWARF-LOC] `Allow Location Descriptions on the DWARF Expression Stack <https://llvm.org/docs/AMDGPUDwarfExtensionAllowLocationDescriptionOnTheDwarfExpressionStack/AMDGPUDwarfExtensionAllowLocationDescriptionOnTheDwarfExpressionStack.html>`__. .. _amdgpu-dwarf-AMDGPU-LLVM:. 5. [AMDGPU-LLVM] `User Guide for AMDGPU LLVM Backend <https://llvm.org/docs/AMDGPUUsage.html>`__. .. _amdgpu-dwarf-CUDA:. 6. [CUDA] `Nvidia CUDA Language <https://docs.nvidia.com/cuda/cuda-c-programming-guide/>`__. .. _amdgpu-dwarf-DWARF:. 7. [DWARF] `DWARF Debugging Information Format <http://dwarfstd.org/>`__. .. _amdgpu-dwarf-ELF:. 8. [ELF] `Executable and Linkable Format (ELF) <http://www.sco.com/developers/gabi/>`__. .. _amdgpu-dwarf-GCC:. 9. [GCC] `GCC: The GNU Compiler Collection <https://www.gnu.org/software/gcc/>`__. .. _amdgpu-dwarf-GDB:. 10. [GDB] `GDB: The GNU Project Debugger <https://www.gnu.org/software/gdb/>`__. .. _amdgpu-dwarf-HIP:. 11. [HIP] `HIP Programming Guide <https://rocm-documentation.readthedocs.io/en/latest/Programming_Guides/Programming-Guides.html#hip-programing-guide>`__. .. _amdgpu-dwarf-HSA:. 12. [HSA] `Heterogeneous System Architecture (HSA) Foundation <http://www.hsafoundation.com/>`__. .. _amdgpu-dwarf-LLVM:. 13. [LLVM] `The LLVM Compiler Infrastructure <https://llvm.org/>`__. .. _amdgpu-dwarf-OpenCL:. 14. [OpenCL] `The OpenCL Specification Version 2.0 <http://www.khronos.org/registry/cl/specs/opencl-2.0.pdf>`__. .. _amdgpu-dwarf-Perforce-TotalView:. 15. [Perforce-TotalView] `Perforce TotalView HPC Debugging Software <https://totalview.io/products/totalview>`__. .. _amdgpu-dwarf-SEMVER:. 16. [SEMVER] `Semantic Versioning <https://semver.org/>`__; ,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst:235854,guid,guide,235854,interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,1,['guid'],['guide']
Usability,"robability.i1(i1 <val>, i1 <expected_val>, double <prob>); declare i32 @llvm.expect.with.probability.i32(i32 <val>, i32 <expected_val>, double <prob>); declare i64 @llvm.expect.with.probability.i64(i64 <val>, i64 <expected_val>, double <prob>). Overview:; """""""""""""""""". The ``llvm.expect.with.probability`` intrinsic provides information about; expected value of ``val`` with probability(or confidence) ``prob``, which can; be used by optimizers. Arguments:; """""""""""""""""""". The ``llvm.expect.with.probability`` intrinsic takes three arguments. The first; argument is a value. The second argument is an expected value. The third; argument is a probability. Semantics:; """""""""""""""""""". This intrinsic is lowered to the ``val``. .. _int_assume:. '``llvm.assume``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare void @llvm.assume(i1 %cond). Overview:; """""""""""""""""". The ``llvm.assume`` allows the optimizer to assume that the provided; condition is true. This information can then be used in simplifying other parts; of the code. More complex assumptions can be encoded as; :ref:`assume operand bundles <assume_opbundles>`. Arguments:; """""""""""""""""""". The argument of the call is the condition which the optimizer may assume is; always true. Semantics:; """""""""""""""""""". The intrinsic allows the optimizer to assume that the provided condition is; always true whenever the control flow reaches the intrinsic call. No code is; generated for this intrinsic, and instructions that contribute only to the; provided condition are not used for code generation. If the condition is; violated during execution, the behavior is undefined. Note that the optimizer might limit the transformations performed on values; used by the ``llvm.assume`` intrinsic in order to preserve the instructions; only used to form the intrinsic's input argument. This might prove undesirable; if the extra information provided by the ``llvm.assume`` intrinsic does not cause; sufficient overall improvement in code quality. For th",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:935304,simpl,simplifying,935304,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['simpl'],['simplifying']
Usability,"rocess get.json request, which returns object in JSON form.; It can be used directly is script without special I/O of Bertrand.; - Use get.json on browser side to simplify logic. No need for extra; requests for streamer infos.; - Process get.xml request, provide full object streaming via TBufferXML.; It is complete object data, but with many custom-streamer data.; - Significant redesign of I/O part of JSRootIO code. Main change -; introduce JSROOTIO.TBuffer class which has similar functionality as; original TBufferFile class. Eliminate many places with duplicated code; - In JSRootIO avoid objects cloning when object referenced several times; - Treat special cases (collection, arrays) in one place.; This is major advantage, while any new classes should be implemented once.; - Object representation, produced by JSRootIO is similar to; objects, produced by TBufferJSON class. By this one can exchange; I/O engine and use same JavaSctript graphic for display.; - More clear functions to display different elements of the file.; In the future functions should be fully separated from I/O part; and organized in similar way as online part.; - Eliminate usage of gFile pointer in the I/O part.; - Provide TBufferJSON::JsonWriteMember method. It allows to stream any; selected data member of the class. Supported are: basic data types,; arrays of basic data types, TString, TArray classes. Also any object; as data member can be streamed.; - TRootSniffer do not creates sublevels for base classes; - When streaming data member, TBufferJSON produces array with all dimensions; only when fCompact==0. By default, THttpServer uses compact=1 for member; - Support both get.json and root.json requests, they have similar meaning. January 2014; - Make THttpServer::CreateEngine as factory method. One could; create http, fastcgi and dabc engines to access data from server.; Syntax allows to provide arbitrary arguments. Examples:; THttpServer* serv = new THttpServer();; serv->CreateEngine(""http:8080"")",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/http/README.txt:3382,clear,clear,3382,net/http/README.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/http/README.txt,1,['clear'],['clear']
Usability,"roject`` build directory where you; configured CMake to use Ninja. You have a file ``repro.c`` in the current; directory that makes clang crash at trunk, but it worked fine at revision; ``f00ba``. .. code-block:: bash. # Build clang. If the build fails, `exit 125` causes this; # revision to be skipped; ninja -C ../llvm-build-project clang || exit 125. ../llvm-build-project/bin/clang repro.c. To make sure your run script works, it's a good idea to run ``./run.sh`` by; hand and tweak the script until it works, then run ``git bisect good`` or; ``git bisect bad`` manually once based on the result of the script; (check ``echo $?`` after your script ran), and only then run ``git bisect run; ./run.sh``. Don't forget to mark your run script as executable -- ``git bisect; run`` doesn't check for that, it just assumes the run script failed each time. Once your run script works, run ``git bisect run ./run.sh`` and a few hours; later you'll know which commit caused the regression. (This is a very simple run script. Often, you want to use just-built clang; to build a different project and then run a built executable of that project; in the run script.). Bisecting across multiple roots; ===============================. Here's how LLVM's history currently looks:. .. code-block:: none. A-o-o-......-o-D-o-o-HEAD; /; B-o-...-o-C-. ``A`` is the first commit in LLVM ever, ``97724f18c79c``. ``B`` is the first commit in MLIR, ``aed0d21a62db``. ``D`` is the merge commit that merged MLIR into the main LLVM repository,; ``0f0d0ed1c78f``. ``C`` is the last commit in MLIR before it got merged, ``0f0d0ed1c78f^2``. (The; ``^n`` modifier selects the n'th parent of a merge commit.). ``git bisect`` goes through all parent revisions. Due to the way MLIR was; merged, at every revision at ``C`` or earlier, *only* the ``mlir/`` directory; exists, and nothing else does. As of early 2020, there is no flag to ``git bisect`` to tell it to not; descend into all reachable commits. Ideally, we'd want to tell ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GitBisecting.rst:2956,simpl,simple,2956,interpreter/llvm-project/llvm/docs/GitBisecting.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GitBisecting.rst,1,['simpl'],['simple']
Usability,"rontend. The suspend point takes a function and its arguments. The function is intended; to model the transfer to the callee function. It will be tail called by; lowering and therefore must have the same signature and calling convention as; the async coroutine. .. code-block:: llvm. call {ptr, ptr, ptr} (ptr, ptr, ...) @llvm.coro.suspend.async(; ptr %resume_func_ptr,; ptr %context_projection_function,; ptr %suspend_function,; ptr %arg1, ptr %arg2, i8 %arg3). Coroutines by Example; =====================. The examples below are all of switched-resume coroutines. Coroutine Representation; ------------------------. Let's look at an example of an LLVM coroutine with the behavior sketched; by the following pseudo-code. .. code-block:: c++. void *f(int n) {; for(;;) {; print(n++);; <suspend> // returns a coroutine handle on first suspend; }; }. This coroutine calls some function `print` with value `n` as an argument and; suspends execution. Every time this coroutine resumes, it calls `print` again with an argument one bigger than the last time. This coroutine never completes by itself and must be destroyed explicitly. If we use this coroutine with; a `main` shown in the previous section. It will call `print` with values 4, 5; and 6 after which the coroutine will be destroyed. The LLVM IR for this coroutine looks like this:. .. code-block:: llvm. define ptr @f(i32 %n) presplitcoroutine {; entry:; %id = call token @llvm.coro.id(i32 0, ptr null, ptr null, ptr null); %size = call i32 @llvm.coro.size.i32(); %alloc = call ptr @malloc(i32 %size); %hdl = call noalias ptr @llvm.coro.begin(token %id, ptr %alloc); br label %loop; loop:; %n.val = phi i32 [ %n, %entry ], [ %inc, %loop ]; %inc = add nsw i32 %n.val, 1; call void @print(i32 %n.val); %0 = call i8 @llvm.coro.suspend(token none, i1 false); switch i8 %0, label %suspend [i8 0, label %loop; i8 1, label %cleanup]; cleanup:; %mem = call ptr @llvm.coro.free(token %id, ptr %hdl); call void @free(ptr %mem); br label %suspend; suspen",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst:11186,resume,resumes,11186,interpreter/llvm-project/llvm/docs/Coroutines.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst,1,['resume'],['resumes']
Usability,"root"";; let file = await openFile(filename);; let obj = await file.readObject(""hpxpy;1"");; await draw(""drawing"", obj, ""colz"");; </script>; ```. Here the default location `https://root.cern/js/latest/` is specified. One always can install JSROOT on private web server.; When JSROOT is used with THttpServer, the address looks like:. ```javascript; <script type='module'>; import { httpRequest, draw } from 'http://your_root_server:8080/jsrootsys/modules/main.mjs';; let obj = await httpRequest('http://your_root_server:8080/Objects/hist/root.json','object');; await draw('drawing', obj, 'hist');; </script>; ```. Loading main module is enough to get public JSROOT functionality - reading files and drawing objects.; One also can load some special components directly like:. ```javascript; <script type='module'>; import { HierarchyPainter } from 'https://root.cern/js/latest/modules/gui.mjs';. let h = new HierarchyPainter(""example"", ""myTreeDiv"");. // configure 'simple' in provided <div> element; // one also can specify ""grid2x2"" or ""flex"" or ""tabs""; h.setDisplay(""simple"", ""myMainDiv"");. // open file and display element; await h.openRootFile('../../files/hsimple.root');; await h.display('hpxpy;1"",""colz');; </script>; ```. After script loading one can configure different parameters in `gStyle` object.; It is instance of the `TStyle` object and behaves like `gStyle` variable in ROOT. For instance,; to change stat format using to display value in stats box:. ```javascript; import { gStyle } from 'https://root.cern/js/latest/modules/main.mjs';; gStyle.fStatFormat = '7.5g';; ```. There is also `settings` object which contains all other JSROOT settings. For instance,; one can configure custom format for different axes:. ```javascript; import { settings } from 'https://root.cern/js/latest/modules/main.mjs';; settings.XValuesFormat = '4.2g';; settings.YValuesFormat = '6.1f';; ```. One also can use `build/jsroot.js` bundle to load all functionality at one and access it via `JSROOT` global h",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/JSROOT/JSROOT.md:35308,simpl,simple,35308,documentation/JSROOT/JSROOT.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/JSROOT/JSROOT.md,1,['simpl'],['simple']
Usability,"root-project/root/issues/14277)] - Cling triggers a huge number of `openat` calls when loading libraries; * [[#14263](https://github.com/root-project/root/issues/14263)] - [tmva] When using DNN_USE_CBLAS, CMakeLists should link publicly to gsl instead of privately; * [[#14256](https://github.com/root-project/root/issues/14256)] - TAxis::GetTicks and TAxis::SetTicks are inconsistent. Significantly so.; * [[#14244](https://github.com/root-project/root/issues/14244)] - String comparison operators defined in TString.h should be defined as constexpr; * [[#14229](https://github.com/root-project/root/issues/14229)] - [6.30] root-config --git-revision broken; * [[#14225](https://github.com/root-project/root/issues/14225)] - [RF] Segmentation fault in ROOT 6.30 workspace creation; * [[#14223](https://github.com/root-project/root/issues/14223)] - Extremely long startup time when loading dictionaries with pyroot; * [[#14219](https://github.com/root-project/root/issues/14219)] - [cling] Use deduction guides for llvm::ArrayRef; * [[#14211](https://github.com/root-project/root/issues/14211)] - Implement value printing for `std::source_location`; * [[#14205](https://github.com/root-project/root/issues/14205)] - [cling] Replace llvm::Optional and llvm::None with std::optional; * [[#14199](https://github.com/root-project/root/issues/14199)] - Memory hoarding triggered by the TPluginManager; * [[#14188](https://github.com/root-project/root/issues/14188)] - cmake find_package ROOT 6.30 broken: it requires nlohmann-json; * [[#14163](https://github.com/root-project/root/issues/14163)] - cmake find_package ROOT broken with 6.30, nlohmann and vdt are builtin but not found; * [[#14162](https://github.com/root-project/root/issues/14162)] - `RooFFTConvPdf` is not working for ROOT 6.30/02; * [[#14157](https://github.com/root-project/root/issues/14157)] - Minuit2 standalone build: StandAlone.cmake looks for the wrong path for VERSION_FILE; * [[#14113](https://github.com/root-project/root/issues",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v632/index.md:34557,guid,guides,34557,README/ReleaseNotes/v632/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v632/index.md,1,['guid'],['guides']
Usability,"root_hist`; in your home directory. ROOT uses this file to allow for navigation in; the command history with the up-arrow and down-arrow keys. It is also; convenient to extract successful ROOT commands with the help of a text; editor for use in your own macros. ### ROOT Global Pointers ###. All global pointers in ROOT begin with a small ""g"". Some of them were; already implicitly introduced (for example in the section; [Configure ROOT at start-up](#configure-root-at-start-up)).; The most important among them are presented in the following:. - **[gROOT](https://root.cern.ch/doc/master/classTROOT.html)**: the `gROOT`; variable is the entry point to the ROOT system. Technically it is an; instance of the `TROOT` class. Using the `gROOT` pointer one has; access to basically every object created in a ROOT based program.; The `TROOT` object is essentially a container of several lists; pointing to the main `ROOT` objects. - **[gStyle](https://root.cern.ch/doc/master/classTStyle.html)**: By default; ROOT creates a default style that can be accessed via the `gStyle`; pointer. This class includes functions to set some of the following; object attributes. - Canvas; - Pad; - Histogram axis; - Lines; - Fill areas; - Text; - Markers; - Functions; - Histogram Statistics and Titles; - etc ... - **[gSystem](https://root.cern.ch/doc/master/classTSystem.html)**: An; instance of a base class defining a generic interface to the; underlying Operating System, in our case `TUnixSystem`. - **[gInterpreter](http://root.cern.ch/htmldoc/html/TInterpreter.html)**: The; entry point for the ROOT interpreter. Technically an abstraction level; over a singleton instance of `TCling`. At this point you have already learnt quite a bit about some basic; features of ROOT. ***Please move on to become an expert!***. [^2]: All ROOT classes' names start with the letter T. A notable exception is; RooFit. In this context all classes' names are of the form Roo*. Starting with; ROOT7, all names start with and R.; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/ROOT_as_calculator.md:21304,learn,learnt,21304,documentation/primer/ROOT_as_calculator.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/ROOT_as_calculator.md,1,['learn'],['learnt']
Usability,"ror. .. _recursiveExpansionLimit:. **recursiveExpansionLimit:**. As described in the previous section, when expanding substitutions in a ``RUN:``; line, lit makes only one pass through the substitution list by default. Thus,; if substitutions are not defined in the proper order, some will remain in the; ``RUN:`` line unexpanded. For example, the following directives refer to; ``%{inner}`` within ``%{outer}`` but do not define ``%{inner}`` until after; ``%{outer}``:. .. code-block:: llvm. ; By default, this definition order does not enable full expansion. ; DEFINE: %{outer} = %{inner}; ; DEFINE: %{inner} = expanded. ; RUN: echo '%{outer}'. ``DEFINE:`` inserts substitutions at the start of the substitution list, so; ``%{inner}`` expands first but has no effect because the original ``RUN:`` line; does not contain ``%{inner}``. Next, ``%{outer}`` expands, and the output of; the ``echo`` command becomes:. .. code-block:: shell. %{inner}. Of course, one way to fix this simple case is to reverse the definitions of; ``%{outer}`` and ``%{inner}``. However, if a test has a complex set of; substitutions that can all reference each other, there might not exist a; sufficient substitution order. To address such use cases, lit configuration files support; ``config.recursiveExpansionLimit``, which can be set to a non-negative integer; to specify the maximum number of passes through the substitution list. Thus, in; the above example, setting the limit to 2 would cause lit to make a second pass; that expands ``%{inner}`` in the ``RUN:`` line, and the output from the ``echo``; command when then be:. .. code-block:: shell. expanded. To improve performance, lit will stop making passes when it notices the ``RUN:``; line has stopped changing. In the above example, setting the limit higher than; 2 is thus harmless. To facilitate debugging, after reaching the limit, lit will make one extra pass; and report an error if the ``RUN:`` line changes again. In the above example,; setting the limit",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TestingGuide.rst:36585,simpl,simple,36585,interpreter/llvm-project/llvm/docs/TestingGuide.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TestingGuide.rst,1,['simpl'],['simple']
Usability,"rors`**, **`TGraphAsymmErrors`**, and; **`TMultiGraph`**. ## TGraph. The **`TGraph`** class supports the general case with non-equidistant; points, and the special case with equidistant points. Graphs are; created with the **`TGraph`** constructor. First, we define the arrays; of coordinates and then create the graph. The coordinates can be; arrays of doubles or floats. ``` {.cpp}; Int_t n = 20;; Double_t x[n], y[n];; for (Int_t i=0; i<n; i++) {; x[i] = i*0.1;; y[i] = 10*sin(x[i]+0.2);; }; TGraph *gr1 = new TGraph (n, x, y);; ```. An alternative constructor takes only the number of points `n`. It is; expected that the coordinates will be set later. ``` {.cpp}; TGraph *gr2 = new TGraph(n);; ```. The default constructor can also be used. Further calls to; `SetPoint()` will extend the internal vectors. ``` {.cpp}; TGraph *gr3 = new TGraph();; ```. ### Graph Draw Options. The various drawing options for a graph are explained in; `TGraph::PaintGraph`. They are:. - ""`L`"" A simple poly-line between every points is drawn. - ""`F`"" A fill area is drawn. - ""`F1`"" Idem as ""`F`"" but fill area is no more repartee around; X=0 or Y=0. - ""`F2`"" draw a fill area poly line connecting the center of bins. - ""`A`"" Axis are drawn around the graph. - ""`C`"" A smooth curve is drawn. - ""`*`"" A star is plotted at each point. - ""`P`"" The current marker of the graph is plotted at each point. - ""`B`"" A bar chart is drawn at each point. - ""`[]` "" Only the end vertical/horizontal lines of the error bars; are drawn. This option only applies to the; **`TGraphAsymmErrors`**. - ""`1`"" `ylow` `=` `rwymin`. The options are not case sensitive and they can be concatenated in; most cases. Let us look at some examples. #### Continuous Line, Axis and Stars (AC\*). ![A graph drawn with axis, \* markers and continuous line (option AC\*)](pictures/0300004B.png). ``` {.cpp}; {; Int_t n = 20;; Double_t x[n], y[n];; for (Int_t i=0;i<n;i++) {; x[i] = i*0.1;; y[i] = 10*sin(x[i]+0.2);; }. // create graph; TGraph *gr = ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphs.md:1161,simpl,simple,1161,documentation/users-guide/Graphs.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphs.md,1,['simpl'],['simple']
Usability,"rrent direction `(nx,ny,nz)`. This; direction is stored as `Double_t fCurrentDirection[3]` by the navigator; and it represents a direction in the global frame. It can be retrieved; with:. ~~~{.cpp}; Const Double_t *cdir = gGeoManager->GetCurrentDirection();; ~~~. The direction can be initialized in a similar manner as the current; point:. ~~~{.cpp}; gGeoManager->SetCurrentDirection(nx,ny,nz);; // or:; gGeoManager->SetCurrentDirection(Double_t *dir);; ~~~. \anchor GP02d; ### Initializing the State. Setting the initial point and direction is not enough for initializing; tracking. The modeller needs to find out where the initial point is; located in the geometrical hierarchy. Due to the containment based; architecture of the model, this is the deepest positioned object; containing the point. For illustrating this, imagine that we have a; simple structure with a top volume `A` and another one `B `positioned; inside. Since `A `is a top volume, its associated node `A_1` will define; `MARS` and our simple hierarchy of nodes (positioned volumes) will be:; `/A_1/B_1`. Suppose now that the initial point is contained by `B_1`.; This implies by default that the point is also contained by `A_1`, since; `B_1` have to be fully contained by this. After searching the point; location, the modeller will consider that the point is located inside; `B_1`, which will be considered as the representative object (node) for; the current state. This is stored as: `TGeoNode *TGeoNavigator::%fCurrentNode`; and can be asked from the manager class; only after the `'Where am I?'` was completed:. ~~~{.cpp}; TGeoNode *current = gGeoManager->GetCurrentNode();; ~~~. In order to find the location of the current point inside the hierarchy; of nodes, after setting this point it is mandatory to call the; `‘Where am I?'` method:. ~~~{.cpp}; gGeoManager->FindNode();; ~~~. In order to have more flexibility, there are in fact several alternative; ways of initializing a modeller state:. ~~~{.cpp}; // Setting th",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md:66034,simpl,simple,66034,geom/geom/doc/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md,1,['simpl'],['simple']
Usability,"rresponding to the lucky first header. Any other headers that have copy-and-pasted versions of this pattern will *not* have a definition of ``size_t``. Importing the submodule corresponding to one of those headers will therefore not yield ``size_t`` as part of the API, because it wasn't there when the header was parsed. The fix for this problem is either to pull the copied declarations into a common header that gets included everywhere ``size_t`` is part of the API, or to eliminate the ``#ifndef`` and redefine the ``size_t`` type. The latter works for C++ headers and C11, but will cause an error for non-modules C90/C99, where redefinition of ``typedefs`` is not permitted. **Conflicting definitions**; Different system headers may provide conflicting definitions for various macros, functions, or types. These conflicting definitions don't tend to cause problems in a pre-modules world unless someone happens to include both headers in one translation unit. Since the fix is often simply ""don't do that"", such problems persist. Modules requires that the conflicting definitions be eliminated or that they be placed in separate modules (the former is generally the better answer). **Missing includes**; Headers are often missing ``#include`` directives for headers that they actually depend on. As with the problem of conflicting definitions, this only affects unlucky users who don't happen to include headers in the right order. With modules, the headers of a particular module will be parsed in isolation, so the module may fail to build if there are missing includes. **Headers that vend multiple APIs at different times**; Some systems have headers that contain a number of different kinds of API definitions, only some of which are made available with a given include. For example, the header may vend ``size_t`` only when the macro ``__need_size_t`` is defined before that header is included, and also vend ``wchar_t`` only when the macro ``__need_wchar_t`` is defined. Such headers are",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst:54391,simpl,simply,54391,interpreter/llvm-project/clang/docs/Modules.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst,1,['simpl'],['simply']
Usability,"rse.llvm.org</td></tr>; <tr><td>Community - Women in Compilers and Tools</td><td>wict@discourse.llvm.org</td></tr>; <tr><td>Community - Job Postings</td><td>community-jobs@discourse.llvm.org</td></tr>; <tr><td>Community - US LLVM Developers' Meeting</td><td>devmtg-US@discourse.llvm.org</td></tr>; <tr><td>Community - EuroLLVM</td><td>devmtg-euro@discourse.llvm.org</td></tr>; <tr><td>Community - GSOC</td><td>gsoc@discourse.llvm.org</td></tr>; <tr><td>Community - Community.o</td><td>community-dot-o@discourse.llvm.org</td></tr>; <tr><td>Community - LLVM Foundation</td><td>foundation@discourse.llvm.org</td></tr>; <tr><td>Community - Newsletters</td><td>newsletters@discourse.llvm.org</td></tr>; <tr><td>Incubator</td><td>incubator@discourse.llvm.org</td></tr>; <tr><td>Incubator - CIRCT</td><td>circt@discourse.llvm.org</td></tr>; <tr><td>Incubator - Torch-MLIR</td><td>torch-mlir@discourse.llvm.org</td></tr>; <tr><td>Incubator - Enzyme</td><td>enzyme@discourse.llvm.org</td></tr>; <tr><td>Feedback</td><td>feedback@discourse.llvm.org</td></tr>; </table>. ## Mapping of mailing lists to categories. This table explains the mapping from mailing lists to categories in Discourse.; The email addresses of these categories will remain the same, after the; migration. Obsolete lists will become read-only as part of the Discourse; migration. <table border=1>; <tr><th>Mailing lists</th><th>Category in Discourse</th></tr>. <tr><td>All-commits</td><td>no migration at the moment</td></tr>; <tr><td>Bugs-admin</td><td>no migration at the moment</td></tr>; <tr><td>cfe-commits</td><td>no migration at the moment</td></tr>; <tr><td>cfe-dev</td><td>Clang Frontend</td></tr>; <tr><td>cfe-users</td><td>Clang Frontend/Using Clang</td></tr>; <tr><td>clangd-dev</td><td>Clang Frontend/clangd</td></tr>; <tr><td>devmtg-organizers</td><td>Obsolete</td></tr>; <tr><td>Docs</td><td>Obsolete</td></tr>; <tr><td>eurollvm-organizers</td><td>Obsolete</td></tr>; <tr><td>flang-commits</td><td>no migration at the moment<",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/DiscourseMigrationGuide.md:7185,feedback,feedback,7185,interpreter/llvm-project/llvm/docs/DiscourseMigrationGuide.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/DiscourseMigrationGuide.md,1,['feedback'],['feedback']
Usability,"rship are deprecated and replaced by a new constructor that takes ownership via `std::unique_ptr<T>`. They will be removed in ROOT 6.36.; - Several RooFit legacy functions are deprecated and will be removed in ROOT 6.36 (see section ""RooFit libraries""); - Multiple overloads of internal Minuit 2 constructors and functions have been removed. If your code fails to compile, you can easily change to another overload that takes a `MnUserParameterState`, which is a change backwards compatible with older ROOT versions. ## Core Libraries. * The `rootcling` invocation corresponding to a `genreflex` invocation can be obtained with the new `genreflex`; command line argument `--print-rootcling-invocation`. This can be useful when migrating from genreflex to; rootcling.; * The `rootcling` utility now fully supports selection xml files and not only LinkDef files. ## I/O Libraries. ## TTree Libraries. ## RDataFrame. * The `GetColumnNames` function to retrieve the number of available column names in the RDataFrame object is now also; usable from a node of a distributed computation graph. This makes the generation of said computation graph slightly; less lazy than before. Notably, it used to be the case that a distributed computation graph could be defined with; code that was not yet available on the user's local application, but that would only become available in the; distributed worker. Now a call such as `df.Define(""mycol"", ""return run_my_fun();"")` needs to be at least declarable; to the interpreter also locally so that the column can be properly tracked. ## Histogram Libraries. ### Upgrade TUnfold to version 17.9. The [TUnfold package](https://www.desy.de/~sschmitt/tunfold.html) inside ROOT is upgraded from version 17.6 to version 17.9. ## Math Libraries. ### Usage of `std::span<const double>` in Minuit 2 interfaces. To avoid forcing the user to do manual memory allocations via `std::vector`, the interfaces of Minuit 2 function adapter classes like `ROOT::Minuit2::FCNBase` or `R",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v634/index.md:3458,usab,usable,3458,README/ReleaseNotes/v634/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v634/index.md,1,['usab'],['usable']
Usability,"rstanding of the interface. In several cases, the misunderstanding of the interface caused invalid memory accesses to the already destructed; temporary `TString` returned by `GetString()`, e.g. `objStr->GetString().Data()`. This will be fixed automatically by the; new return type. In rare cases, the caller expected `GetString()` to return a (non-const) reference to the embedded `TString`, e.g.; `objString->GetString().ReplaceAll(""a"", ""b""); // WRONG!` This will now fail to compile, instead of not doing what the author of the; code expected. Please fix that code by using the `TObjString::String()` interface, which returns a non-const `TString&`:; `objString->String().ReplaceAll(""a"", ""b"");`. In extremely rare cases, this change breaks a valid use where the temporary `TString` was modified and then captured in a new `TString`; object before the destruction of the temporary: `TString str = objStr->GetString().ReplaceAll(""a"", ""b"");`. In these rare cases,; please use the new function `CopyString()` which clearly indicates that it involves a temporary. ## Histogram Libraries. - New class `THnChain` was added to provide a `TChain`-like experience when; working with `THnBase`'ed histograms (currently `THn` and `THnSparse`) from; many files, see [here](https://sft.its.cern.ch/jira/browse/ROOT-4515). This; allows to e.g., interactively adjust axis parameters before performing; projections from high-dimensional histograms,. ```{.cpp}; // Create a chain of histograms called `h`.; THnChain chain(""h"");. // Add files containing histograms `h` to `chain`.; chain->AddFile(""file1.root"");. chain->GetXaxis(1)->SetRangeUser(0.1, 0.2);. TH1* projection = chain->Projection(0); ```. ## Math Libraries. * Improve thread friendliness of the TMinuit class. ## RooFit Libraries. - Remove deprecated `RooComplex` superseded by `std::complex`. ## TTree Libraries. - `TTreeReader` now supports `TEntryList`s, `Double32_t` / `Float16_t`.; - `TTreeReader::SetLastEntry()` has been deprecated. Its name is mi",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v610/index.md:4164,clear,clearly,4164,README/ReleaseNotes/v610/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v610/index.md,1,['clear'],['clearly']
Usability,"rt forward declaration of user functions. These; 'extern's are just prototypes with no body:. .. code-block:: c++. /// external ::= 'extern' prototype; static std::unique_ptr<PrototypeAST> ParseExtern() {; getNextToken(); // eat extern.; return ParsePrototype();; }. Finally, we'll also let the user type in arbitrary top-level expressions; and evaluate them on the fly. We will handle this by defining anonymous; nullary (zero argument) functions for them:. .. code-block:: c++. /// toplevelexpr ::= expression; static std::unique_ptr<FunctionAST> ParseTopLevelExpr() {; if (auto E = ParseExpression()) {; // Make an anonymous proto.; auto Proto = std::make_unique<PrototypeAST>("""", std::vector<std::string>());; return std::make_unique<FunctionAST>(std::move(Proto), std::move(E));; }; return nullptr;; }. Now that we have all the pieces, let's build a little driver that will; let us actually *execute* this code we've built!. The Driver; ==========. The driver for this simply invokes all of the parsing pieces with a; top-level dispatch loop. There isn't much interesting here, so I'll just; include the top-level loop. See `below <#full-code-listing>`_ for full code in the; ""Top-Level Parsing"" section. .. code-block:: c++. /// top ::= definition | external | expression | ';'; static void MainLoop() {; while (true) {; fprintf(stderr, ""ready> "");; switch (CurTok) {; case tok_eof:; return;; case ';': // ignore top-level semicolons.; getNextToken();; break;; case tok_def:; HandleDefinition();; break;; case tok_extern:; HandleExtern();; break;; default:; HandleTopLevelExpression();; break;; }; }; }. The most interesting part of this is that we ignore top-level; semicolons. Why is this, you ask? The basic reason is that if you type; ""4 + 5"" at the command line, the parser doesn't know whether that is the; end of what you will type or not. For example, on the next line you; could type ""def foo..."" in which case 4+5 is the end of a top-level; expression. Alternatively you could type ""\",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl02.rst:23106,simpl,simply,23106,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl02.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl02.rst,1,['simpl'],['simply']
Usability,"rtain size and alignment,; can be projected out of the coroutine object with `llvm.coro.promise`.; The coroutine implementation must have been compiled to define a promise; of the same size and alignment. In general, interacting with a coroutine object in any of these ways while; it is running has undefined behavior. The coroutine function is split into three functions, representing three; different ways that control can enter the coroutine:. 1. the ramp function that is initially invoked, which takes arbitrary; arguments and returns a pointer to the coroutine object;. 2. a coroutine resume function that is invoked when the coroutine is resumed,; which takes a pointer to the coroutine object and returns `void`;. 3. a coroutine destroy function that is invoked when the coroutine is; destroyed, which takes a pointer to the coroutine object and returns; `void`. Because the resume and destroy functions are shared across all suspend; points, suspend points must store the index of the active suspend in; the coroutine object, and the resume/destroy functions must switch over; that index to get back to the correct point. Hence the name of this; lowering. Pointers to the resume and destroy functions are stored in the coroutine; object at known offsets which are fixed for all coroutines. A completed; coroutine is represented with a null resume function. There is a somewhat complex protocol of intrinsics for allocating and; deallocating the coroutine object. It is complex in order to allow the; allocation to be elided due to inlining. This protocol is discussed; in further detail below. The frontend may generate code to call the coroutine function directly;; this will become a call to the ramp function and will return a pointer; to the coroutine object. The frontend should always resume or destroy; the coroutine using the corresponding intrinsics. Returned-Continuation Lowering; ------------------------------. In returned-continuation lowering, signaled by the use of; `llvm.co",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst:4283,resume,resume,4283,interpreter/llvm-project/llvm/docs/Coroutines.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst,2,['resume'],['resume']
Usability,"rticular issue or concern (although no committed patch should leave the; project in a broken state). Moreover, reviewers can accept a patch conditioned on; the author applying some set of minor updates prior to committing, and when; applicable, it is polite for reviewers to do so. Don't Unintentionally Block a Review; ------------------------------------. If you review a patch, but don't intend for the review process to block on your; approval, please state that explicitly. Out of courtesy, we generally wait on; committing a patch until all reviewers are satisfied, and if you don't intend; to look at the patch again in a timely fashion, please communicate that fact in; the review. Who Can/Should Review Code?; ===========================. Non-Experts Should Review Code; ------------------------------. You do not need to be an expert in some area of the code base to review patches;; it's fine to ask questions about what some piece of code is doing. If it's not; clear to you what is going on, you're unlikely to be the only one. Please; remember that it is not in the long-term best interest of the community to have; components that are only understood well by a small number of people. Extra; comments and/or test cases can often help (and asking for comments in the test; cases is fine as well). Moreover, authors are encouraged to interpret questions as a reason to reexamine; the readability of the code in question. Structural changes, or further; comments, may be appropriate. If you're new to the LLVM community, you might also find this presentation helpful:; .. _How to Contribute to LLVM, A 2019 LLVM Developers' Meeting Presentation: https://youtu.be/C5Y977rLqpw. A good way for new contributors to increase their knowledge of the code base is; to review code. It is perfectly acceptable to review code and explicitly; defer to others for approval decisions. Experts Should Review Code; --------------------------. If you are an expert in an area of the compiler affected by a",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodeReview.rst:10058,clear,clear,10058,interpreter/llvm-project/llvm/docs/CodeReview.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodeReview.rst,1,['clear'],['clear']
Usability,"rting this for the driver build. It will require changing; # the perf-helper.py file to understand to call `llvm` as `llvm clang`.; if(APPLE AND DTRACE AND NOT LLVM_TOOL_LLVM_DRIVER_BUILD); configure_lit_site_cfg(; ${CMAKE_CURRENT_SOURCE_DIR}/order-files.lit.site.cfg.in; ${CMAKE_CURRENT_BINARY_DIR}/order-files/lit.site.cfg; ). add_lit_testsuite(generate-dtrace-logs ""Generating clang dtrace data""; ${CMAKE_CURRENT_BINARY_DIR}/order-files/; EXCLUDE_FROM_CHECK_ALL; ARGS -j 1; DEPENDS clang clear-dtrace-logs; ). add_custom_target(clear-dtrace-logs; COMMAND ""${Python3_EXECUTABLE}"" ${CMAKE_CURRENT_SOURCE_DIR}/perf-helper.py clean ${CMAKE_CURRENT_BINARY_DIR} dtrace; COMMENT ""Clearing old dtrace data""). if(NOT CLANG_ORDER_FILE); message(FATAL_ERROR ""Output clang order file is not set""); endif(). add_custom_target(generate-order-file; COMMAND ""${Python3_EXECUTABLE}"" ${CMAKE_CURRENT_SOURCE_DIR}/perf-helper.py gen-order-file --binary $<TARGET_FILE:clang> --output ${CLANG_ORDER_FILE} ${CMAKE_CURRENT_BINARY_DIR}; COMMENT ""Generating order file""; DEPENDS generate-dtrace-logs); endif(). if(CLANG_BOLT_INSTRUMENT AND NOT LLVM_BUILD_INSTRUMENTED); configure_lit_site_cfg(; ${CMAKE_CURRENT_SOURCE_DIR}/bolt.lit.site.cfg.in; ${CMAKE_CURRENT_BINARY_DIR}/bolt-fdata/lit.site.cfg; ). add_lit_testsuite(generate-bolt-fdata ""Generating BOLT profile for Clang""; ${CMAKE_CURRENT_BINARY_DIR}/bolt-fdata/; EXCLUDE_FROM_CHECK_ALL; DEPENDS clang-instrumented clear-bolt-fdata; ). add_custom_target(clear-bolt-fdata; COMMAND ""${Python3_EXECUTABLE}"" ${CMAKE_CURRENT_SOURCE_DIR}/perf-helper.py clean ${CMAKE_CURRENT_BINARY_DIR} fdata; COMMENT ""Clearing old BOLT fdata""). # Merge profiles into one using merge-fdata; add_custom_target(clang-bolt-profile; COMMAND ""${Python3_EXECUTABLE}"" ${CMAKE_CURRENT_SOURCE_DIR}/perf-helper.py merge-fdata $<TARGET_FILE:merge-fdata> ${CMAKE_CURRENT_BINARY_DIR}/prof.fdata ${CMAKE_CURRENT_BINARY_DIR}; COMMENT ""Merging BOLT fdata""; DEPENDS merge-fdata generate-bolt-fdata); endif(); ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/perf-training/CMakeLists.txt:3289,clear,clear-bolt-fdata,3289,interpreter/llvm-project/clang/utils/perf-training/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/perf-training/CMakeLists.txt,2,['clear'],['clear-bolt-fdata']
Usability,"ructions such that they are legal. A legal instruction is defined as:. * **selectable** --- the target will later be able to select it to a; target-specific (non-generic) instruction. This doesn't necessarily mean that; :doc:`InstructionSelect` has to handle it though. It just means that; **something** must handle it. * operating on **vregs that can be loaded and stored** -- if necessary, the; target can select a ``G_LOAD``/``G_STORE`` of each gvreg operand. As opposed to SelectionDAG, there are no legalization phases. In particular,; 'type' and 'operation' legalization are not separate. Legalization is iterative, and all state is contained in GMIR. To maintain the; validity of the intermediate code, instructions are introduced:. * ``G_MERGE_VALUES`` --- concatenate multiple registers of the same; size into a single wider register. * ``G_UNMERGE_VALUES`` --- extract multiple registers of the same size; from a single wider register. * ``G_EXTRACT`` --- extract a simple register (as contiguous sequences of bits); from a single wider register. As they are expected to be temporary byproducts of the legalization process,; they are combined at the end of the :ref:`milegalizer` pass.; If any remain, they are expected to always be selectable, using loads and stores; if necessary. The legality of an instruction may only depend on the instruction itself and; must not depend on any context in which the instruction is used. However, after; deciding that an instruction is not legal, using the context of the instruction; to decide how to legalize the instruction is permitted. As an example, if we; have a ``G_FOO`` instruction of the form::. %1:_(s32) = G_CONSTANT i32 1; %2:_(s32) = G_FOO %0:_(s32), %1:_(s32). it's impossible to say that G_FOO is legal iff %1 is a ``G_CONSTANT`` with; value ``1``. However, the following::. %2:_(s32) = G_FOO %0:_(s32), i32 1. can say that it's legal iff operand 2 is an immediate with value ``1`` because; that information is entirely contained within",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GlobalISel/Legalizer.rst:1061,simpl,simple,1061,interpreter/llvm-project/llvm/docs/GlobalISel/Legalizer.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GlobalISel/Legalizer.rst,1,['simpl'],['simple']
Usability,"ructor. Also, in the case of many; instances of ``ilist``\ s, the memory overhead of the associated sentinels is; wasted. To alleviate the situation with numerous and voluminous; ``T``-sentinels, sometimes a trick is employed, leading to *ghostly sentinels*. Ghostly sentinels are obtained by specially-crafted ``ilist_traits<T>`` which; superpose the sentinel with the ``ilist`` instance in memory. Pointer; arithmetic is used to obtain the sentinel, which is relative to the ``ilist``'s; ``this`` pointer. The ``ilist`` is augmented by an extra pointer, which serves; as the back-link of the sentinel. This is the only field in the ghostly; sentinel which can be legally accessed. .. _dss_other:. Other Sequential Container options; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Other STL containers are available, such as ``std::string``. There are also various STL adapter classes such as ``std::queue``,; ``std::priority_queue``, ``std::stack``, etc. These provide simplified access; to an underlying container but don't affect the cost of the container itself. .. _ds_string:. String-like containers; ----------------------. There are a variety of ways to pass around and use strings in C and C++, and; LLVM adds a few new options to choose from. Pick the first option on this list; that will do what you need, they are ordered according to their relative cost. Note that it is generally preferred to *not* pass strings around as ``const; char*``'s. These have a number of problems, including the fact that they; cannot represent embedded nul (""\0"") characters, and do not have a length; available efficiently. The general replacement for '``const char*``' is; StringRef. For more information on choosing string containers for APIs, please see; :ref:`Passing Strings <string_apis>`. .. _dss_stringref:. llvm/ADT/StringRef.h; ^^^^^^^^^^^^^^^^^^^^. The StringRef class is a simple value class that contains a pointer to a; character and a length, and is quite related to the :ref:`ArrayRef; <dss_arrayref>` ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:70809,simpl,simplified,70809,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,1,['simpl'],['simplified']
Usability,"ructure in HTML, replace dtree.js which is; extremely slow for complex hierarchies. Dramatically improve performance for; structures with large (~1000) number of items.; 19. Deliver to the server title of the objects, display it as hint in the browser.; 20. Better handling of special characters in the hierarchies - allows to display; symbols like ' or "" in the file structure. ### July 2014; 1. Migration to d3.v3.js and jQuery v2.1.1; 2. Fix errors in filling of histogram statbox; 3. Possibility of move and resize of statbox, title, color palete; 4. Remove many (not all) global variables; 5. Example with direct usage of JSRootIO graphics; 6. Example of inserting ROOT graphics from THttpServer into `<iframe></iframe>`. ### May 2014; 1. This JSRootIO code together with THttpServer class included; in ROOT repository. ### March 2014; 1. Introduce TBuffer class, which plays similar role; as TBuffer in native ROOT I/O. Simplifies I/O logic,; reduce duplication of code in many places, fix errors.; Main advantage - one could try to keep code synchronous with C++.; 2. Avoid objects cloning when object referenced several times.; 3. Treat special cases (collection, arrays) in one place.; This is major advantage, while any new classes need to be implemented only once.; 4. Object representation, produced by JSRootIO is similar to; objects, produced by TBufferJSON class. By this one can exchange; I/O engine and use same JavaSctript graphic for display.; 5. More clear functions to display different elements of the file.; In the future functions should be fully separated from I/O part; and organized in similar way as online part.; 6. Eliminate usage of gFile pointer in the I/O part.; 7. Provide TBufferJSON::JsonWriteMember method. It allows to stream any; selected data member of the class. Supported are:; basic data types, arrays of basic data types, TString, TArray classes.; Also any object as data member can be streamed.; 8. TRootSniffer do not creates sublevels for base classes; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/changes.md:77494,clear,clear,77494,js/changes.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/changes.md,1,['clear'],['clear']
Usability,"run through clang -O2 -S -emit-llvm to get; equivalent IR */; int x;; void f(int* a) {; for (int i = 0; i < 100; i++) {; if (a[i]); x += 1;; }; }. The following is equivalent in non-concurrent situations:. .. code-block:: c. int x;; void f(int* a) {; int xtemp = x;; for (int i = 0; i < 100; i++) {; if (a[i]); xtemp += 1;; }; x = xtemp;; }. However, LLVM is not allowed to transform the former to the latter: it could; indirectly introduce undefined behavior if another thread can access ``x`` at; the same time. That thread would read `undef` instead of the value it was; expecting, which can lead to undefined behavior down the line. (This example is; particularly of interest because before the concurrency model was implemented,; LLVM would perform this transformation.). Note that speculative loads are allowed; a load which is part of a race returns; ``undef``, but does not have undefined behavior. Atomic instructions; ===================. For cases where simple loads and stores are not sufficient, LLVM provides; various atomic instructions. The exact guarantees provided depend on the; ordering; see `Atomic orderings`_. ``load atomic`` and ``store atomic`` provide the same basic functionality as; non-atomic loads and stores, but provide additional guarantees in situations; where threads and signals are involved. ``cmpxchg`` and ``atomicrmw`` are essentially like an atomic load followed by an; atomic store (where the store is conditional for ``cmpxchg``), but no other; memory operation can happen on any thread between the load and store. A ``fence`` provides Acquire and/or Release ordering which is not part; of another operation; it is normally used along with Monotonic memory; operations. A Monotonic load followed by an Acquire fence is roughly; equivalent to an Acquire load, and a Monotonic store following a; Release fence is roughly equivalent to a Release; store. SequentiallyConsistent fences behave as both an Acquire and a; Release fence, and additionally provide a t",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Atomics.rst:4203,simpl,simple,4203,interpreter/llvm-project/llvm/docs/Atomics.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Atomics.rst,1,['simpl'],['simple']
Usability,"rwise it is replaced with an indirect call based; on the function pointer for the resume function stored in the coroutine frame.; Resuming a coroutine that is not suspended leads to undefined behavior. .. _coro.done:. 'llvm.coro.done' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. ::. declare i1 @llvm.coro.done(ptr <handle>). Overview:; """""""""""""""""". The '``llvm.coro.done``' intrinsic checks whether a suspended; switched-resume coroutine is at the final suspend point or not. Arguments:; """""""""""""""""""". The argument is a handle to a suspended coroutine. Semantics:; """""""""""""""""""". Using this intrinsic on a coroutine that does not have a `final suspend`_ point; or on a coroutine that is not suspended leads to undefined behavior. .. _coro.promise:. 'llvm.coro.promise' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. ::. declare ptr @llvm.coro.promise(ptr <ptr>, i32 <alignment>, i1 <from>). Overview:; """""""""""""""""". The '``llvm.coro.promise``' intrinsic obtains a pointer to a; `coroutine promise`_ given a switched-resume coroutine handle and vice versa. Arguments:; """""""""""""""""""". The first argument is a handle to a coroutine if `from` is false. Otherwise,; it is a pointer to a coroutine promise. The second argument is an alignment requirements of the promise.; If a frontend designated `%promise = alloca i32` as a promise, the alignment; argument to `coro.promise` should be the alignment of `i32` on the target; platform. If a frontend designated `%promise = alloca i32, align 16` as a; promise, the alignment argument should be 16.; This argument only accepts constants. The third argument is a boolean indicating a direction of the transformation.; If `from` is true, the intrinsic returns a coroutine handle given a pointer; to a promise. If `from` is false, the intrinsics return a pointer to a promise; from a coroutine handle. This argument only accepts constants. Semantics:; """""""""""""""""""". Using this intrinsic on a coroutine that does not have a coroutine promise; leads to undefined",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst:29187,resume,resume,29187,interpreter/llvm-project/llvm/docs/Coroutines.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst,1,['resume'],['resume']
Usability,"ry:; getNextToken();; if (!isascii(CurTok)); return LogErrorP(""Expected unary operator"");; FnName = ""unary"";; FnName += (char)CurTok;; Kind = 1;; getNextToken();; break;; case tok_binary:; ... As with binary operators, we name unary operators with a name that; includes the operator character. This assists us at code generation; time. Speaking of, the final piece we need to add is codegen support for; unary operators. It looks like this:. .. code-block:: c++. Value *UnaryExprAST::codegen() {; Value *OperandV = Operand->codegen();; if (!OperandV); return nullptr;. Function *F = getFunction(std::string(""unary"") + Opcode);; if (!F); return LogErrorV(""Unknown unary operator"");. return Builder->CreateCall(F, OperandV, ""unop"");; }. This code is similar to, but simpler than, the code for binary; operators. It is simpler primarily because it doesn't need to handle any; predefined operators. Kicking the Tires; =================. It is somewhat hard to believe, but with a few simple extensions we've; covered in the last chapters, we have grown a real-ish language. With; this, we can do a lot of interesting things, including I/O, math, and a; bunch of other things. For example, we can now add a nice sequencing; operator (printd is defined to print out the specified value and a; newline):. ::. ready> extern printd(x);; Read extern:; declare double @printd(double). ready> def binary : 1 (x y) 0; # Low-precedence operator that ignores operands.; ...; ready> printd(123) : printd(456) : printd(789);; 123.000000; 456.000000; 789.000000; Evaluated to 0.000000. We can also define a bunch of other ""primitive"" operations, such as:. ::. # Logical unary not.; def unary!(v); if v then; 0; else; 1;. # Unary negate.; def unary-(v); 0-v;. # Define > with the same precedence as <.; def binary> 10 (LHS RHS); RHS < LHS;. # Binary logical or, which does not short circuit.; def binary| 5 (LHS RHS); if LHS then; 1; else if RHS then; 1; else; 0;. # Binary logical and, which does not short circuit.; de",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl06.rst:14416,simpl,simple,14416,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl06.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl06.rst,1,['simpl'],['simple']
Usability,"s HybridResult and HybridPlot work only; with the HybridCalculatorOriginal and remain for maintaining; a backward compatibility. ; Given a ModelConfig, the tool will attempt to form the posterior pdf ; for the nuisance parameters based on the prior and the constraint terms ; in the pdf. However, this is not yet implemented. In order to keep; logical consistency with other tools, the distribution being used; to smear the nuisance parameters should NOT be considered the prior in ; the model config. Instead, one should use HybridCalculator's; ForcePriorNuisanceNull and ForcePriorNuisanceAlt. HybridCalculatorOriginal. Apply a fix for test statistic = 3 (profile likelihood); Apply a fix for using non-extended pdf. TestStatSampler and TestStatistics. Cleanup of the interfaces.; TestStatistics now have a method PValueIsRightTail to specify the sign conventions for the test statistic. This is used when making plots and calculating p-values.; make clear that TestStatistic::Evaluate should take data and values of the parameters that define the null.; Add method TestStatSampler::SetParametersForTestStat that ; allows for greater control of parameters used for generating toy data; and parameters used for evaluating the test statistic.; ProfileLikelihoodTestStatUsing the raw profile likelihood while reviewing the old algorithm used to provide robustness in situations with local minima.; New test statistic classes:; ; SimpleLikelihoodRatioTestStat : log L_1 / L_0; RatioOfProfiledLikelihoodsTestStat: log L(mu_1, hat(nu_1))/L(mu_0,hat(nu_0)); MaxLikelihoodEstimateTestStat: the MLE of a specified parameter. ToyMCSampler. New version of ToyMCSampler which can smear the nuisance; parameters according to their distributions for use with; HybridCalculator; Updated class structure: ToyMCSampler is a particular implementation of a TestStatSampler and runs with any TestStatistic. It returns the result in an instance of SamplingDistribution.; Supports Importance Sampling: Improves sampling t",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v528/index.html:6653,clear,clear,6653,roofit/doc/v528/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v528/index.html,1,['clear'],['clear']
Usability,"s against an installed version of; LLVM regardless of how it was built. Here is a simple example of a CMakeLists.txt file that imports the LLVM libraries; and uses them to build a simple application ``simple-tool``. .. code-block:: cmake. cmake_minimum_required(VERSION 3.20.0); project(SimpleProject). find_package(LLVM REQUIRED CONFIG). message(STATUS ""Found LLVM ${LLVM_PACKAGE_VERSION}""); message(STATUS ""Using LLVMConfig.cmake in: ${LLVM_DIR}""). # Set your project compile flags.; # E.g. if using the C++ header files; # you will need to enable C++11 support; # for your compiler. include_directories(${LLVM_INCLUDE_DIRS}); separate_arguments(LLVM_DEFINITIONS_LIST NATIVE_COMMAND ${LLVM_DEFINITIONS}); add_definitions(${LLVM_DEFINITIONS_LIST}). # Now build our tools; add_executable(simple-tool tool.cpp). # Find the libraries that correspond to the LLVM components; # that we wish to use; llvm_map_components_to_libnames(llvm_libs support core irreader). # Link against LLVM libraries; target_link_libraries(simple-tool ${llvm_libs}). The ``find_package(...)`` directive when used in CONFIG mode (as in the above; example) will look for the ``LLVMConfig.cmake`` file in various locations (see; cmake manual for details). It creates a ``LLVM_DIR`` cache entry to save the; directory where ``LLVMConfig.cmake`` is found or allows the user to specify the; directory (e.g. by passing ``-DLLVM_DIR=/usr/lib/cmake/llvm`` to; the ``cmake`` command or by setting it directly in ``ccmake`` or ``cmake-gui``). This file is available in two different locations. * ``<LLVM_INSTALL_PACKAGE_DIR>/LLVMConfig.cmake`` where; ``<LLVM_INSTALL_PACKAGE_DIR>`` is the location where LLVM CMake modules are; installed as part of an installed version of LLVM. This is typically; ``cmake/llvm/`` within the lib directory. On Linux, this is typically; ``/usr/lib/cmake/llvm/LLVMConfig.cmake``. * ``<LLVM_BUILD_ROOT>/lib/cmake/llvm/LLVMConfig.cmake`` where; ``<LLVM_BUILD_ROOT>`` is the root of the LLVM build tree. **Not",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CMake.rst:42064,simpl,simple-tool,42064,interpreter/llvm-project/llvm/docs/CMake.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CMake.rst,1,['simpl'],['simple-tool']
Usability,"s an instance variable for part of its lifetime, it may; maintain an invariant guaranteeing that the instance variable is always released; before -dealloc. In this case, you can silence a warning about a missing release; by either adding assert(_ivar == nil) or an explicit release; [_ivar release] (which will be a no-op when the variable is nil) in; -dealloc. ; Q: How do I decide whether a method's return type should be _Nullable or _Nonnull?; Depending on the implementation of the method, this puts you in one of five situations:. You actually never return nil.; You do return nil sometimes, and callers are supposed to handle that. This; includes cases where your method is documented to return nil given certain; inputs.; You return nil based on some external condition (such as an out-of-memory; error), but the client can't do anything about it either.; You return nil only when the caller passes input documented to be invalid.; That means it's the client's fault.; You return nil in some totally undocumented case. In (1) you should annotate the method as returning a _Nonnull; object.; In (2) the method should be marked _Nullable.; In (3) you should probably annotate the method _Nonnull. Why?; Because no callers will actually check for nil, given that they can't do; anything about the situation and don't know what went wrong. At this point; things have gone so poorly that there's basically no way to recover.; The least happy case is (4) because the resulting program will almost; certainly either crash or just silently do the wrong thing.; If this is a new method or you control the callers, you can use; NSParameterAssert() (or the equivalent) to check the precondition and; remove the nil return. But if you don't control the callers and they rely on; this behavior, you should return mark the method _Nonnull and return; nil cast to _Nonnull anyway.; (Note that (4) doesn't apply in cases where the caller can't know they passed; bad parameters. For example,; +[NSData dataWith",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/faq.html:5378,undo,undocumented,5378,interpreter/llvm-project/clang/www/analyzer/faq.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/faq.html,1,['undo'],['undocumented']
Usability,"s and assigned a sub-set of workers to merge. Once each; sub-merger has merged its sub-set of workers, it sends its result to; the master, which merges the partial results into the final; set of results.; The determination of the sub-mergers is always done dynamically, based; on the recent performance of workers. An optimal (i.e. giving the; highest speed-up) number can be calculated analytically under simple; assumptions.; Merging via submergers is by default disabled. To enable it, with the; optimal number of sub-mergers, one should set the integer parameter; 'PROOF_UseMergers' to 0, i.e.                     ; proof->SetParameter(""PROOF_UseMergers"", 0). To force S sub-mergers (regardless of the optimal number) do.                     ; proof->SetParameter(""PROOF_UseMergers"", S). The new functionality can be tested in tutorials by adding the argument; 'submergers' to runProof, e.g. .        ;        ;      root [0] .L; tutorials/proof/runProof.C+ ;        ;        ;      root [1]; runProof(""simple(nhist=10000,submergers)"") . (see the top of tutorials/proof/runProof.C for additional options). A test for the submerger functionality has also been added to; test/stressProof.cxx .; In PROOF-Lite, add the possibility for the administrator; to control the number of workers. This is done using; the rootrc variable ProofLite.MaxWorkers, which is read out of; /etc/system.rootrc and cannot be overwritten by users. Setting the; value to 0 disables PROOF-Lite. Improvements. TFileMerger. A few improvements on the way to make TFileMerger and; hadd totally equivalent:. import from hadd an optimization of key hashing; import from hadd a better way to invoke Merge for; generic objects; add option to merge histograms in one go, instead of; one-by-one as for generic objects (this option is not yet supported by; hadd). TProofOutputFile. Add support for the placeholder <file>; the definition of the outputfile. This allows to have complete URL and; to pass options to TFile::Open. XrdProo",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/doc/v526/index.html:3065,simpl,simple,3065,proof/doc/v526/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/doc/v526/index.html,1,['simpl'],['simple']
Usability,"s and programs external to; LLVM, there are many ways to install and configure these dependencies so you; may need to adapt the instructions here to fit your own local situation. Prerequisites; =============. In this use case we'll be using cmake on a Debian-based Linux system,; cross-compiling from an x86_64 host to a hard-float Armv7-A target. We'll be; using as many of the LLVM tools as we can, but it is possible to use GNU; equivalents. * ``A build of LLVM/clang for the llvm-tools and llvm-config``; * ``A clang executable with support for the ARM target``; * ``compiler-rt sources``; * ``The qemu-arm user mode emulator``; * ``An arm-linux-gnueabihf sysroot``. In this example we will be using ninja. See https://compiler-rt.llvm.org/ for more information about the dependencies; on clang and LLVM. See https://llvm.org/docs/GettingStarted.html for information about obtaining; the source for LLVM and compiler-rt. Note that the getting started guide; places compiler-rt in the projects subdirectory, but this is not essential and; if you are using the BaremetalARM.cmake cache for v6-M, v7-M and v7-EM then; compiler-rt must be placed in the runtimes directory. ``qemu-arm`` should be available as a package for your Linux distribution. The most complicated of the prerequisites to satisfy is the arm-linux-gnueabihf; sysroot. In theory it is possible to use the Linux distributions multiarch; support to fulfill the dependencies for building but unfortunately due to; /usr/local/include being added some host includes are selected. The easiest way; to supply a sysroot is to download the arm-linux-gnueabihf toolchain. This can; be found at:; * https://developer.arm.com/open-source/gnu-toolchain/gnu-a/downloads for gcc 8 and above; * https://releases.linaro.org/components/toolchain/binaries/ for gcc 4.9 to 7.3. Building compiler-rt builtins for Arm; =====================================; We will be doing a standalone build of compiler-rt using the following cmake; options. * ``path",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToCrossCompileBuiltinsOnArm.rst:1553,guid,guide,1553,interpreter/llvm-project/llvm/docs/HowToCrossCompileBuiltinsOnArm.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToCrossCompileBuiltinsOnArm.rst,1,['guid'],['guide']
Usability,"s and vendors of potential disruptions when upgrading to; a newer version of a tool. For example, deprecating a feature that is expected; to be removed in the future, removing an already-deprecated feature, upgrading a; diagnostic from a warning to an error, switching important default behavior, or; any other potentially disruptive situation thought to be worth raising; awareness of. For such changes, the following should be done:. .. warning::. Phabricator is deprecated and will be switched to read-only mode in October; 2023, for new code contributions use :ref:`GitHub Pull Requests <github-reviews>`.; This section contains old information that needs to be updated. * When performing the code review for the change, please add any applicable; ""vendors"" group to the review for their awareness. The purpose of these; groups is to give vendors early notice that potentially disruptive changes; are being considered but have not yet been accepted. Vendors can give early; testing feedback on the changes to alert us to unacceptable breakages. The; current list of vendor groups is:. * `Clang vendors <https://reviews.llvm.org/project/members/113/>`_; * `libc++ vendors <https://reviews.llvm.org/project/members/109/>`_. People interested in joining the vendors group can do so by clicking the; ""Join Project"" link on the vendor's ""Members"" page in Phabricator. * When committing the change to the repository, add appropriate information; about the potentially breaking changes to the ``Potentially Breaking Changes``; section of the project's release notes. The release note should have; information about what the change is, what is potentially disruptive about; it, as well as any code examples, links, and motivation that is appropriate; to share with users. This helps users to learn about potential issues with; upgrading to that release. * After the change has been committed to the repository, the potentially; disruptive changes described in the release notes should be posted to the; `A",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/DeveloperPolicy.rst:6035,feedback,feedback,6035,interpreter/llvm-project/llvm/docs/DeveloperPolicy.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/DeveloperPolicy.rst,1,['feedback'],['feedback']
Usability,"s are represented with the; ``ConstantFP`` class, which holds the numeric value in an ``APFloat``; internally (``APFloat`` has the capability of holding floating point; constants of Arbitrary Precision). This code basically just creates; and returns a ``ConstantFP``. Note that in the LLVM IR that constants; are all uniqued together and shared. For this reason, the API uses the; ""foo::get(...)"" idiom instead of ""new foo(..)"" or ""foo::Create(..)"". .. code-block:: c++. Value *VariableExprAST::codegen() {; // Look this variable up in the function.; Value *V = NamedValues[Name];; if (!V); LogErrorV(""Unknown variable name"");; return V;; }. References to variables are also quite simple using LLVM. In the simple; version of Kaleidoscope, we assume that the variable has already been; emitted somewhere and its value is available. In practice, the only; values that can be in the ``NamedValues`` map are function arguments.; This code simply checks to see that the specified name is in the map (if; not, an unknown variable is being referenced) and returns the value for; it. In future chapters, we'll add support for `loop induction; variables <LangImpl05.html#for-loop-expression>`_ in the symbol table, and for `local; variables <LangImpl07.html#user-defined-local-variables>`_. .. code-block:: c++. Value *BinaryExprAST::codegen() {; Value *L = LHS->codegen();; Value *R = RHS->codegen();; if (!L || !R); return nullptr;. switch (Op) {; case '+':; return Builder->CreateFAdd(L, R, ""addtmp"");; case '-':; return Builder->CreateFSub(L, R, ""subtmp"");; case '*':; return Builder->CreateFMul(L, R, ""multmp"");; case '<':; L = Builder->CreateFCmpULT(L, R, ""cmptmp"");; // Convert bool 0/1 to double 0.0 or 1.0; return Builder->CreateUIToFP(L, Type::getDoubleTy(TheContext),; ""booltmp"");; default:; return LogErrorV(""invalid binary operator"");; }; }. Binary operators start to get more interesting. The basic idea here is; that we recursively emit code for the left-hand side of the expression,; then the",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl03.rst:6026,simpl,simply,6026,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl03.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl03.rst,1,['simpl'],['simply']
Usability,"s by calling:. ``` {.cpp}; TH1::LabelsDeflate(axis);; ```. Here `axis` may be X, Y, or Z. This operation is automatic when using; **`TTree`**`::Draw` . Once bin labels have been created, they become; persistent if the histogram is written to a file or when generating; the C++ code via `SavePrimitive` . ## Histogram Stacks. A **`THStack`** is a collection of **`TH1`** (or derived) objects. Use; **`THStack`**`::Add(` **`TH1`** `*h)` to add a histogram to the stack.; The **`THStack`** does not own the objects in the list. ![Stacked histograms](pictures/0300003D.png). By default, **`THStack`**`::Draw` draws the histograms stacked as; shown in the left pad in the picture above. If the option `""nostack""`; is used, the histograms are superimposed as if they were drawn one at; a time using the `""same""` draw option `.` The right pad in this; picture illustrates the **`THStack`** drawn with the `""nostack""`; option. ``` {.cpp}; hs->Draw(""nostack"");; ```. Next is a simple example, for a more complex one see; `$ROOTSYS/tutorials/hist/hstack.C.`. ``` {.cpp}; {; THStack hs(""hs"",""test stacked histograms"");; TH1F *h1 = new TH1F(""h1"",""test hstack"",100,-4,4);; h1->FillRandom(""gaus"",20000);; h1->SetFillColor(kRed);; hs.Add(h1);; TH1F *h2 = new TH1F(""h2"",""test hstack"",100,-4,4);; h2->FillRandom(""gaus"",15000);; h2->SetFillColor(kBlue);; hs.Add(h2);; TH1F *h3 = new TH1F(""h3"",""test hstack"",100,-4,4);; h3->FillRandom(""gaus"",10000);; h3->SetFillColor(kGreen);; hs.Add(h3);; TCanvas c1(""c1"",""stacked hists"",10,10,700,900);; c1.Divide (1,2);; c1.cd(1);; hs.Draw();; c1.cd(2);; hs->Draw(""nostack"");; }; ```. ## TH2Poly. `TH2Poly` is a 2D Histogram class allowing to define polygonal bins of; arbitrary shape. Each bin in the `TH2Poly` histogram is a `TH2PolyBin` object.; `TH2PolyBin` is a very simple class containing the vertices and; contents of the polygonal bin as well as several related functions. Bins are defined using one of the `AddBin()` methods. The bin; definition should be done before filli",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md:59596,simpl,simple,59596,documentation/users-guide/Histograms.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md,1,['simpl'],['simple']
Usability,"s clarity; > and readability. I agree to some extent, but it also comes at the; > cost of verbosity. And when the types are obvious from people's; > experience (e.g., in the br instruction), it doesn't seem to help as; > much. Very true. We should discuss this more, but my reasoning is more of a; consistency argument. There are VERY few instructions that can have all; of the types eliminated, and doing so when available unnecessarily makes; the language more difficult to handle. Especially when you see 'int; %this' and 'bool %that' all over the place, I think it would be; disorienting to see:. br %predicate, %iftrue, %iffalse. for branches. Even just typing that once gives me the creeps. ;) Like I; said, we should probably discuss this further in person... > On reflection, I really like your idea of having the two different; > switch types (even though they encode implementation techniques rather; > than semantics). It should simplify building the CFG and my guess is it; > could enable some significant optimizations, though we should think; > about which. Great. I added a note to the switch section commenting on how the VM; should just use the instruction type as a hint, and that the; implementation may choose altermate representations (such as predicated; branches). > In the lookup-indirect form of the switch, is there a reason not to; > make the val-type uint?. No. This was something I was debating for a while, and didn't really feel; strongly about either way. It is common to switch on other types in HLL's; (for example signed int's are particularly common), but in this case, all; that will be added is an additional 'cast' instruction. I removed that; from the spec. > I agree with your comment that we don't need 'neg'. Removed. > There's a trade-off with the cast instruction:; > + it avoids having to define all the upcasts and downcasts that are; > valid for the operands of each instruction (you probably have; > thought of other benefits also); > - it could make ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HistoricalNotes/2001-02-09-AdveCommentsResponse.txt:1533,simpl,simplify,1533,interpreter/llvm-project/llvm/docs/HistoricalNotes/2001-02-09-AdveCommentsResponse.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HistoricalNotes/2001-02-09-AdveCommentsResponse.txt,1,['simpl'],['simplify']
Usability,"s described in; `Minimising cost of downstream merges`_).; Also update the project list on the policy page.; 2. Apply ``clang-tidy`` to the project's files, with only the; ``readability-identifier-naming`` rules enabled. ``clang-tidy`` will also; reformat the affected lines according to the rules in ``.clang-format``.; It is anticipated that this will be a good dog-fooding opportunity for; clang-tidy, and bugs should be fixed in the process, likely including:. * `readability-identifier-naming incorrectly fixes lambda capture; <https://bugs.llvm.org/show_bug.cgi?id=41119>`_.; * `readability-identifier-naming incorrectly fixes variables which; become keywords <https://bugs.llvm.org/show_bug.cgi?id=41120>`_.; * `readability-identifier-naming misses fixing member variables in; destructor <https://bugs.llvm.org/show_bug.cgi?id=41122>`_. #. Gather feedback and refine the process as appropriate. #. Apply the process to the following projects, with a suitable delay between; each (at least 4 weeks after the first change, at least 2 weeks subsequently); to allow gathering further feedback.; This list should exclude projects that must adhere to an externally defined; standard e.g. libcxx.; The list is roughly in chronological order of renaming.; Some items may not make sense to rename individually - it is expected that; this list will change following experimentation:. * TableGen; * llvm/tools; * clang-tools-extra; * clang; * ARM backend; * AArch64 backend; * AMDGPU backend; * ARC backend; * AVR backend; * BPF backend; * Hexagon backend; * Lanai backend; * MIPS backend; * NVPTX backend; * PowerPC backend; * RISC-V backend; * Sparc backend; * SystemZ backend; * WebAssembly backend; * X86 backend; * XCore backend; * libLTO; * Debug Information; * Remainder of llvm; * compiler-rt; * libunwind; * openmp; * parallel-libs; * polly; * lldb. #. Remove the old variable name rule from the policy page. #. Repeat many of the steps in the sequence, using a script to expand acronyms. Refere",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Proposals/VariableNames.rst:12372,feedback,feedback,12372,interpreter/llvm-project/llvm/docs/Proposals/VariableNames.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Proposals/VariableNames.rst,1,['feedback'],['feedback']
Usability,"s description block, everything until the first; non-commented line is considered as a valid member function description; block. **Data members** are documented by putting a C++ comment behind their; declaration in the header file, e.g. ``` {.cpp}; Int_t fIAmADataMember; // this is a data member; ```. When documenting a class, **`THtml`** creates both a ""beautified""; version of the source file and a web page containing the class; documentation. The documentation also shows the **author** and a; **copyright statement**. This information is extracted from the source; file. The author can be in the format. ``` {.cpp}; // Author: Enrico Fermi; ```. for people that have an entry in CERN's XWho database, and for those who; have not:. ``` {.cpp}; // Author: Enrico Fermi <mailto:enrico@fnal.gov>; ```. The copyright statement is introduced by the string ""`* Copyright`""; inside a comment. You should read the class reference page at; <http://root.cern.ch/root/html/THtml.html> to learn about all of; **`THtml`**'s features. ### Product and Module Documentation. For **`THtml`**, a product like ROOT is a combination of several; modules. It can include user-provided document for both products and; modules. The name of the product can be set by calling; `THtml::SetProductName()`. By default, the documentation is searched for; in the `doc/` subdirectory of the source tree, and in the; `../doc `directory, relative to the directory of first source file of a; module. This can be set by calls to `THtml::SetProductDocDir()` and; `THtml::SetModuleDocPath()`. The documentation is generated as an index page with links to further; files. This index page includes the file `index.txt` converted to HTML; (via `THtml::Convert()`) or the file index.html (without conversion to; HTML, of course), if any of these files exist. The index page will also; contain a list of links to all files in the directory that end on; `.html` or `.txt`. Files ending on `.txt` will be converted to HTML; before they are",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/HTMLDoc.md:2758,learn,learn,2758,documentation/users-guide/HTMLDoc.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/HTMLDoc.md,1,['learn'],['learn']
Usability,"s first reached. The remainder of the original coroutine function is split; out into some number of ""resume functions"". Any state which must persist; across suspensions is stored in the coroutine frame. The resume functions; must somehow be able to handle either a ""normal"" resumption, which continues; the normal execution of the coroutine, or an ""abnormal"" resumption, which; must unwind the coroutine without attempting to suspend it. Switched-Resume Lowering; ------------------------. In LLVM's standard switched-resume lowering, signaled by the use of; `llvm.coro.id`, the coroutine frame is stored as part of a ""coroutine; object"" which represents a handle to a particular invocation of the; coroutine. All coroutine objects support a common ABI allowing certain; features to be used without knowing anything about the coroutine's; implementation:. - A coroutine object can be queried to see if it has reached completion; with `llvm.coro.done`. - A coroutine object can be resumed normally if it has not already reached; completion with `llvm.coro.resume`. - A coroutine object can be destroyed, invalidating the coroutine object,; with `llvm.coro.destroy`. This must be done separately even if the; coroutine has reached completion normally. - ""Promise"" storage, which is known to have a certain size and alignment,; can be projected out of the coroutine object with `llvm.coro.promise`.; The coroutine implementation must have been compiled to define a promise; of the same size and alignment. In general, interacting with a coroutine object in any of these ways while; it is running has undefined behavior. The coroutine function is split into three functions, representing three; different ways that control can enter the coroutine:. 1. the ramp function that is initially invoked, which takes arbitrary; arguments and returns a pointer to the coroutine object;. 2. a coroutine resume function that is invoked when the coroutine is resumed,; which takes a pointer to the coroutine object an",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst:3082,resume,resumed,3082,interpreter/llvm-project/llvm/docs/Coroutines.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst,1,['resume'],['resumed']
Usability,"s if the replacement register is a temporary register from the; ``apply`` pattern. .. code-block:: text. def ReplaceTemp : GICombineRule<; (defs root:$a),; (match (G_BUILD_VECTOR $tmp, $x, $y),; (G_UNMERGE_VALUES $a, $b, $tmp)),; (apply (G_UNMERGE_VALUES $a, i32:$new, $y),; (GIReplaceReg $b, $new))>. Common Pattern #2: Erasing a Def-less Root; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. If we simply want to erase a def-less match root, we can use the; ``GIEraseRoot`` builtin. .. code-block:: text. def Foo : GICombineRule<; (defs root:$mi),; (match (G_STORE $a, $b):$mi),; (apply (GIEraseRoot))>;. Common Pattern #3: Emitting a Constant Value; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. When an immediate operand appears in an 'apply' pattern, the behavior; depends on whether it's typed or not. * If the immediate is typed, ``MachineIRBuilder::buildConstant`` is used; to create a ``G_CONSTANT``. A ``G_BUILD_VECTOR`` will be used for vectors.; * If the immediate is untyped, a simple immediate is added; (``MachineInstrBuilder::addImm``). There is of course a special case for ``G_CONSTANT``. Immediates for; ``G_CONSTANT`` must always be typed, and a CImm is added; (``MachineInstrBuilder::addCImm``). .. code-block:: text; :caption: Constant Emission Examples:. // Example output:; // %0 = G_CONSTANT i32 0; // %dst = COPY %0; def Foo : GICombineRule<; (defs root:$dst),; (match (G_FOO $dst, $src)),; (apply (COPY $dst, (i32 0)))>;. // Example output:; // %dst = COPY 0; // Note that this would be ill-formed because COPY; // expects a register operand!; def Bar : GICombineRule<; (defs root:$dst),; (match (G_FOO $dst, $src)),; (apply (COPY $dst, (i32 0)))>;. // Example output:; // %dst = G_CONSTANT i32 0; def Bux : GICombineRule<; (defs root:$dst),; (match (G_FOO $dst, $src)),; (apply (G_CONSTANT $dst, (i32 0)))>;. GICombinePatFrag; ----------------. ``GICombinePatFrag`` is an equivalent of ``PatFrags`` for MIR patterns.; They have two main usecases:. * Reduce repetition by creat",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GlobalISel/MIRPatterns.rst:9617,simpl,simple,9617,interpreter/llvm-project/llvm/docs/GlobalISel/MIRPatterns.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GlobalISel/MIRPatterns.rst,1,['simpl'],['simple']
Usability,"s in the set"". The; choice of constraint is made independently for each constraint in the; constraint list. 2) Use ""``|``"" between constraint code sets, creating alternatives. Every; constraint in the constraint list must have the same number of alternative; sets. With this syntax, the same alternative in *all* of the items in the; constraint list will be chosen together. Putting those together, you might have a two operand constraint string like; ``""rm|r,ri|rm""``. This indicates that if operand 0 is ``r`` or ``m``, then; operand 1 may be one of ``r`` or ``i``. If operand 0 is ``r``, then operand 1; may be one of ``r`` or ``m``. But, operand 0 and 1 cannot both be of type m. However, the use of either of the alternatives features is *NOT* recommended, as; LLVM is not able to make an intelligent choice about which one to use. (At the; point it currently needs to choose, not enough information is available to do so; in a smart way.) Thus, it simply tries to make a choice that's most likely to; compile, not one that will be optimal performance. (e.g., given ""``rm``"", it'll; always choose to use memory, not registers). And, if given multiple registers,; or multiple register classes, it will simply choose the first one. (In fact, it; doesn't currently even ensure explicitly specified physical registers are; unique, so specifying multiple physical registers as alternatives, like; ``{r11}{r12},{r11}{r12}``, will assign r11 to both operands, not at all what was; intended.). Supported Constraint Code List; """""""""""""""""""""""""""""""""""""""""""""""""""""""""""". The constraint codes are, in general, expected to behave the same way they do in; GCC. LLVM's support is often implemented on an 'as-needed' basis, to support C; inline asm code which was supported by GCC. A mismatch in behavior between LLVM; and GCC likely indicates a bug in LLVM. Some constraint codes are typically supported by all targets:. - ``r``: A register in the target's general purpose register class.; - ``m``: A memory address oper",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:219843,simpl,simply,219843,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['simpl'],['simply']
Usability,"s inclusive on both ends. Example:; ``""%plural{0:none|1:one|[2,5]:some|:many}0""``; * modulo: A modulo operator is followed by a number, and equals sign and; either a number or a range. The tests are the same as for plain numbers; and ranges, but the argument is taken modulo the number first. Example:; ``""%plural{%100=0:even hundred|%100=[1,50]:lower half|:everything else}1""``. The parser is very unforgiving. A syntax error, even whitespace, will abort,; as will a failure to match the argument against any expression. **""ordinal"" format**. Example:; ``""ambiguity in %ordinal0 argument""``; Class:; Integers; Description:; This is a formatter which represents the argument number as an ordinal: the; value ``1`` becomes ``1st``, ``3`` becomes ``3rd``, and so on. Values less; than ``1`` are not supported. This formatter is currently hard-coded to use; English ordinals. **""objcclass"" format**. Example:; ``""method %objcclass0 not found""``; Class:; ``DeclarationName``; Description:; This is a simple formatter that indicates the ``DeclarationName`` corresponds; to an Objective-C class method selector. As such, it prints the selector; with a leading ""``+``"". **""objcinstance"" format**. Example:; ``""method %objcinstance0 not found""``; Class:; ``DeclarationName``; Description:; This is a simple formatter that indicates the ``DeclarationName`` corresponds; to an Objective-C instance method selector. As such, it prints the selector; with a leading ""``-``"". **""q"" format**. Example:; ``""candidate found by name lookup is %q0""``; Class:; ``NamedDecl *``; Description:; This formatter indicates that the fully-qualified name of the declaration; should be printed, e.g., ""``std::vector``"" rather than ""``vector``"". **""diff"" format**. Example:; ``""no known conversion %diff{from $ to $|from argument type to parameter type}1,2""``; Class:; ``QualType``; Description:; This formatter takes two ``QualType``\ s and attempts to print a template; difference between the two. If tree printing is off, the te",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:13831,simpl,simple,13831,interpreter/llvm-project/clang/docs/InternalsManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst,1,['simpl'],['simple']
Usability,"s info using this interface.; For example:. .. code-block:: c++. bool ModuleLevelPass::runOnModule(Module &M) {; //...; DominatorTree &DT = getAnalysis<DominatorTree>(Func);; //...; }. In above example, ``runOnFunction`` for ``DominatorTree`` is called by pass; manager before returning a reference to the desired pass. If your pass is capable of updating analyses if they exist (e.g.,; ``BreakCriticalEdges``, as described above), you can use the; ``getAnalysisIfAvailable`` method, which returns a pointer to the analysis if; it is active. For example:. .. code-block:: c++. if (DominatorSet *DS = getAnalysisIfAvailable<DominatorSet>()) {; // A DominatorSet is active. This code will update it.; }. Implementing Analysis Groups; ----------------------------. Now that we understand the basics of how passes are defined, how they are used,; and how they are required from other passes, it's time to get a little bit; fancier. All of the pass relationships that we have seen so far are very; simple: one pass depends on one other specific pass to be run before it can; run. For many applications, this is great, for others, more flexibility is; required. In particular, some analyses are defined such that there is a single simple; interface to the analysis results, but multiple ways of calculating them.; Consider alias analysis for example. The most trivial alias analysis returns; ""may alias"" for any alias query. The most sophisticated analysis a; flow-sensitive, context-sensitive interprocedural analysis that can take a; significant amount of time to execute (and obviously, there is a lot of room; between these two extremes for other implementations). To cleanly support; situations like this, the LLVM Pass Infrastructure supports the notion of; Analysis Groups. Analysis Group Concepts; ^^^^^^^^^^^^^^^^^^^^^^^. An Analysis Group is a single simple interface that may be implemented by; multiple different passes. Analysis Groups can be given human readable names; just like passes, but u",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/WritingAnLLVMPass.rst:34839,simpl,simple,34839,interpreter/llvm-project/llvm/docs/WritingAnLLVMPass.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/WritingAnLLVMPass.rst,1,['simpl'],['simple']
Usability,"s is a ""binary +"").; Many other examples abound. In the following example, not only do we tell you; that there is a problem with the *; and point to it, we say exactly why and tell you what the type is (in case it is; a complicated subexpression, such as a call to an overloaded function). This; sort of attention to detail makes it much easier to understand and fix problems; quickly. $ gcc-4.9 -fsyntax-only t.c; t.c:5:11: error: invalid type argument of unary '*' (have 'int'); return *SomeA.X;; ^; $ clang -fsyntax-only t.c; t.c:5:11: error: indirection requires pointer operand ('int' invalid); int y = *SomeA.X;; ^~~~~~~~. Typedef Preservation and Selective Unwrapping; Many programmers use high-level user defined types, typedefs, and other; syntactic sugar to refer to types in their program. This is useful because they; can abbreviate otherwise very long types and it is useful to preserve the; typename in diagnostics. However, sometimes very simple typedefs can wrap; trivial types and it is important to strip off the typedef to understand what; is going on. Clang aims to handle both cases well.; The following example shows where it is important to preserve; a typedef in C. $ clang -fsyntax-only t.c; t.c:15:11: error: can't convert between vector values of different size ('__m128' and 'int const *'); myvec[1]/P;; ~~~~~~~~^~. The following example shows where it is useful for the compiler to expose; underlying details of a typedef. If the user was somehow confused about how the; system ""pid_t"" typedef is defined, Clang helpfully displays it with ""aka"". $ clang -fsyntax-only t.c; t.c:13:9: error: member reference base type 'pid_t' (aka 'int') is not a structure or union; myvar = myvar.x;; ~~~~~ ^. In C++, type preservation includes retaining any qualification written into type names. For example, if we take a small snippet of code such as:. namespace services {; struct WebService { };; }; namespace myapp {; namespace servers {; struct Server { };; }; }. using namespace m",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/diagnostics.html:4220,simpl,simple,4220,interpreter/llvm-project/clang/www/diagnostics.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/diagnostics.html,1,['simpl'],['simple']
Usability,"s like:. .. code-block:: c++. for (i = 7; i*i < 1000; ++i). into. .. code-block:: c++. for (i = 0; i != 25; ++i). * Any use outside of the loop of an expression derived from the indvar is; changed to compute the derived value outside of the loop, eliminating the; dependence on the exit value of the induction variable. If the only purpose; of the loop is to compute the exit value of some derived expression, this; transformation will make the loop dead. This transformation should be followed by strength reduction after all of the; desired loop transformations have been performed. Additionally, on targets; where it is profitable, the loop could be transformed to count down to zero; (the ""do loop"" optimization). ``inline``: Function Integration/Inlining; -----------------------------------------. Bottom-up inlining of functions into callees. .. _passes-instcombine:. ``instcombine``: Combine redundant instructions; -----------------------------------------------. Combine instructions to form fewer, simple instructions. This pass does not; modify the CFG. This pass is where algebraic simplification happens. This pass combines things like:. .. code-block:: llvm. %Y = add i32 %X, 1; %Z = add i32 %Y, 1. into:. .. code-block:: llvm. %Z = add i32 %X, 2. This is a simple worklist driven algorithm. This pass guarantees that the following canonicalizations are performed on the; program:. #. If a binary operator has a constant operand, it is moved to the right-hand; side.; #. Bitwise operators with constant operands are always grouped so that shifts; are performed first, then ``or``\ s, then ``and``\ s, then ``xor``\ s.; #. Compare instructions are converted from ``<``, ``>``, ``≤``, or ``≥`` to; ``=`` or ``≠`` if possible.; #. All ``cmp`` instructions on boolean values are replaced with logical; operations.; #. ``add X, X`` is represented as ``mul X, 2`` ⇒ ``shl X, 1``; #. Multiplies with a constant power-of-two argument are transformed into; shifts.; #. … etc. This pass can also ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Passes.rst:19426,simpl,simple,19426,interpreter/llvm-project/llvm/docs/Passes.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Passes.rst,1,['simpl'],['simple']
Usability,"s no explicit interface (see; comments in ``PassManager.h`` for more details). All LLVM passes inherit from; the CRTP mix-in ``PassInfoMixin<PassT>``. The pass should have a ``run()``; method which returns a ``PreservedAnalyses`` and takes in some unit of IR; along with an analysis manager. For example, a function pass would have a; ``PreservedAnalyses run(Function &F, FunctionAnalysisManager &AM);`` method. We start by showing you how to construct a pass, from setting up the build,; creating the pass, to executing and testing it. Looking at existing passes is; always a great way to learn details. .. warning::; This document deals with the new pass manager. LLVM uses the legacy pass; manager for the codegen pipeline. For more details, see; :doc:`WritingAnLLVMPass` and :doc:`NewPassManager`. Quick Start --- Writing hello world; ===================================. Here we describe how to write the ""hello world"" of passes. The ""HelloWorld""; pass is designed to simply print out the name of non-external functions that; exist in the program being compiled. It does not modify the program at all,; it just inspects it. The code below already exists; feel free to create a pass with a different; name alongside the HelloWorld source files. .. _writing-an-llvm-npm-pass-build:. Setting up the build; --------------------. First, configure and build LLVM as described in :doc:`GettingStarted`. Next, we will reuse an existing directory (creating a new directory involves; messing around with more CMake files than we want). For this example, we'll use; ``llvm/lib/Transforms/Utils/HelloWorld.cpp``, which has already been created.; If you'd like to create your own pass, add a new source file into; ``llvm/lib/Transforms/Utils/CMakeLists.txt`` (assuming you want your pass in; the ``Transforms/Utils`` directory. Now that we have the build set up for a new pass, we need to write the code; for the pass itself. .. _writing-an-llvm-npm-pass-basiccode:. Basic code required; -------------------. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/WritingAnLLVMNewPMPass.rst:1705,simpl,simply,1705,interpreter/llvm-project/llvm/docs/WritingAnLLVMNewPMPass.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/WritingAnLLVMNewPMPass.rst,1,['simpl'],['simply']
Usability,"s of classes that don't know anything about each other. They; interact and allow method calls of other object's methods. The idea is; simple: any object can send out (emit) a signal in certain situations; saying that something happened. This is all it does to communicate and; it does not know whether anything is interested in this information. On; the other side there might be an object waiting for that signal and; ready to react to it. This object disposes of special instruments to; listen to the sent out signals. To have a communication we need a; message transmission between the objects. In this simple example we use; signals and slots. The code of the method **`TGButton::Clicked()`** is:. ``` {.cpp}; virtual void Clicked() { Emit(""Clicked()""); } // *SIGNAL*; ```. I.e. any button emits the signal `Clicked()` any time someone clicks on; it. As you can see this method is virtual and could be overridden if you; need to. In our simple example we call the `Connect()` method to connect; the `Clicked()` signal of Draw button with `MyMainFrame::DoDraw():`. ``` {.cpp}; draw->Connect(""Clicked()"",""MyMainFrame"",this,""DoDraw()"");; ```. In the same way we can connect to the signal `Clicked()` of the Exit; button with the system call `gApplication->Terminate(0).` We declare a; new slot `DoExit(),` implement it to invoke the termination call and; associate this slot with the signal `Clicked()` of the Exit button. The code of `example.C` can be changed as follows:. ``` {.cpp}; public:; ...; void DoExit(); // a new slot is added; }; void MyMainFrame::DoExit() {; gApplication->Terminate(0);; }; MyMainFrame::MyMainFrame(const TGWindow *p,UInt_t w,UInt_t h) {; ...; TGTextButton *exit = new TGTextButton(hframe,""&Exit "");; // connects signal Clicked() with slot DoExit(); exit->Connect(""Clicked()"",""MyMainFrame"",this,""DoExit()"");; ...; }; ```. Here is an abstract view of the signal/slots connections in `example.C`:. ![](pictures/0200020C.jpg). To benefit from this mechanism your classes ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md:41907,simpl,simple,41907,documentation/users-guide/WritingGUI.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md,1,['simpl'],['simple']
Usability,"s of constexpr static data members; Not resolved. 2410; C++23; Implicit calls of immediate functions; Unknown. 2411; C++20; Comparison of pointers to members in template non-type arguments; Unknown. 2412; review; SFINAE vs undeduced placeholder type; Not resolved. 2413; CD6; typename in conversion-function-ids; Unknown. 2414; C++20; Unclear results if both member and friend operator<=> are declared; Unknown. 2415; NAD; using-declarations vs copy assignment operators; Unknown. 2416; C++20; Explicit specializations vs constexpr and consteval; Unknown. 2417; open; Explicit instantiation and exception specifications; Not resolved. 2418; CD5; Missing cases in definition of “usable in constant expressions”; Unknown. 2419; C++20; Loss of generality treating pointers to objects as one-element arrays; Unknown. 2420; dup; Exception specifications in explicit instantiation; Unknown. 2421; drafting; Explicit instantiation of constrained member functions; Not resolved. 2422; C++20; Incorrect grammar for deduction-guide; Unknown. 2423; NAD; Typedefs, names, and entities; Unknown. 2424; C++20; constexpr initialization requirements for variant members; Unknown. 2425; open; Confusing wording for deduction from a type; Not resolved. 2426; C++20; Reference to destructor that cannot be invoked; Unknown. 2427; C++20; Deprecation of volatile operands and unevaluated contexts; Unknown. 2428; C++23; Deprecating a concept; Unknown. 2429; C++20; Initialization of thread_local variables referenced by lambdas; Unknown. 2430; C++20; Completeness of return and parameter types of member functions; Unknown. 2431; C++20; Full-expressions and temporaries bound to references; Unknown. 2432; C++20; Return types for defaulted <=>; Unknown. 2433; C++20; Variable templates in the ODR; Unknown. 2434; open; Mandatory copy elision vs non-class objects; Not resolved. 2435; open; Alias template specializations; Not resolved. 2436; C++20; Copy semantics of coroutine parameters; Unknown. 2437; C++20; Conversion ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:165806,guid,guide,165806,interpreter/llvm-project/clang/www/cxx_dr_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html,1,['guid'],['guide']
Usability,"s or the source. The source is quicker to transfer; since it is only \~22 MB, but you will need to compile and link it. The; binaries compiled with no debug information range from \~35 MB to \~45; MB depending on the target platform. The installation and building of ROOT is described in Appendix A:; Install and Build ROOT. You can download the binaries, or the source.; The GNU g++ compiler on most UNIX platforms can compile ROOT. Before downloading a binary version make sure your machine contains the; right run-time environment. In most cases it is not possible to run a; version compiled with, e.g., gcc4.0 on a platform where only gcc 3.2 is; installed. In such cases you'll have to install ROOT from source. ROOT is currently running on the following platforms: supported; platforms. - `GNU/Linux x86-32 (IA32) and x86-64 (AMD64)(GCC,Intel/icc,; Portland/PGCC,KAI/KCC)`. - `Intel Itanium (IA64) GNU/Linux (GCC, Intel/ecc, SGI/CC) `. - `FreeBSD and OpenBSD (GCC)`. - `GNU/Hurd (GCC)`. - `HP HP-UX 10.x (IA32) and 11 (IA64) (HP CC, aCC, GCC)`. - `IBM AIX 4.1 (xlC compiler, GCC)`. - `Sun Solaris for SPARC (SUN C++ compiler, GCC) `. - `Sun Solaris for x86 (SUN C++ compiler, KAI/KCC)`. - `Compaq Alpha (GCC, KAI/KCC, DEC/CXX)`. - `SGI Irix 32 and 64 bits (GCC, KAI/KCC, SGI C++ compiler) `. - `Windows >= 95 (Microsoft Visual C++ compiler, Cygwin/GCC) `. - `MacOS X PPC, x86-32, x86-64 (GCC, Intel/ICC, IBM/xl)`. - `PowerPC with GNU/Linux and GCC, Debian v2`. - `PowerPC64 with GNU/Linux and GCC`. - `ARM with GNU/Linux and GCC`. - `LynxOS`. ## The Organization of the ROOT Framework. Now after we know in abstract terms what the ROOT framework is, let us; look at the physical directories and files that come with the ROOT; installation. You may work on a platform where your system; administrator has already installed ROOT. You will need to follow the; specific development environment for your setup and you may not have; write access to the directories. In any case, you will need an; env",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md:9856,UX,UX,9856,documentation/users-guide/Introduction.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md,1,['UX'],['UX']
Usability,"s or values; also for data or choices that are discrete, small; and fixed in number, not easily remembered. With check boxes all; alternatives are visible: it is easy to access and compare choices; because they can all be seen together. Each option acts as a switch and; can be either ""on"" or ""off"". It is never changed in contents. Checkboxes; differ from radio buttons in that they permit selection of more than one; alternative. Each box can be switched on or off independently. These; buttons can be used alone or grouped in sets. It is good practice to; provide default settings for check boxes whenever it is possible. ![](pictures/03000213.png). This can be done by:. ``` {.cpp}; SetState(EButtonState state); ```. The parameter state can be one of `kButtonUp`, `kButtonDown`,; `kButtonEngaged`, `kButtonDisabled`. Check boxes can be used to affect other controls. The contents of a list; can, for example, be filtered by setting a check box. In any case, use a; check box only when both states of a choice are clearly opposite and; unambiguous. If opposite states are not clear, it is better to use two; radio buttons. Choice description, i.e. check box label, must be clear, meaningful,; fully spelled out, and displayed in mixed-type text. Whenever the use of; a given button is inappropriate, for whatever reason, that button should; be disabled:. ``` {.cpp}; button->SetState(kButtonDisabled);; ```. Never make a button appear and disappear. In general, option buttons should not offer more than eight choices. If; the number of choices exceeds this maximum, it is better to use a; multiple selection list box. The method `IsToggleButton()` gives the information whether a radio; button or a check button is selected. An option button can be set or; unset via its method `PSetState(EButtonState state).`. The method `HandleKey(event)` is called when the defined hotkey is hit; for any button. It sets the selected option button or clicks the; selected text button and invokes its defined a",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md:63138,clear,clearly,63138,documentation/users-guide/WritingGUI.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md,1,['clear'],['clearly']
Usability,"s passed; in `'filename'`. ``` {.cpp}; {; gROOT->Reset();; TFile *f = new TFile(""basic2.root"",""RECREATE"");; TH1F *h1 = new TH1F(""h1"",""x distribution"",100,-4,4);; TTree *T = new TTree(""ntuple"",""data from ascii file"");; Long64_t nlines = T->ReadFile(""basic.dat"",""x:y:z"");; printf("" found %lld pointsn"",nlines);; T->Draw(""x"",""z>2"");; T->Write();; }; ```. If `branchDescriptor` is set to an empty string (the default), it is; assumed that the **`Tree`** descriptor is given in the first line of the; file with a syntax like: `A/D:Table[2]/F:Ntracks/I:astring/C`. Otherwise branchDescriptor must be specified with the above syntax.Lines; in the input file starting with ""\#"" are ignored. A **`TBranch`** object; is created for each variable in the expression. The total number of rows; read from the file is returned. ## Trees in Analysis. The methods `TTree::Draw`, `TTree::MakeClass` and; `TTree::MakeSelector` are available for data analysis using trees. The; **`TTree::Draw`** method is a powerful yet simple way to look and draw the; trees contents. It enables you to plot a variable (a leaf) with just one; line of code. However, the Draw method falls short once you want to look; at each entry and design more sophisticated acceptance criteria for your; analysis. For these cases, you can use `TTree::MakeClass`. It creates a; class that loops over the trees entries one by one. You can then expand; it to do the logic of your analysis. The `TTree::MakeSelector` is the recommended method for ROOT data; analysis. It is especially important for large data set in a parallel; processing configuration where the analysis is distributed over several; processors and you can specify which entries to send to each processor.; With `MakeClass` the user has control over the event loop, with; `MakeSelector `the tree is in control of the event loop. ## Simple Analysis Using TTree::Draw. We will use the tree in `cernstaff.root` that was made by the macro in; `$ROOTSYS/tutorials/tree/staff.C`. First, open",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:67714,simpl,simple,67714,documentation/users-guide/Trees.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md,1,['simpl'],['simple']
Usability,"s reachable objects starting; from the roots, then deallocates unreachable objects in a sweep phase. Copying; As reachability analysis proceeds, the collector copies objects from one heap; area to another, compacting them in the process. Copying collectors enable; highly efficient ""bump pointer"" allocation and can improve locality of; reference. Incremental; (Including generational collectors.) Incremental collectors generally have all; the properties of a copying collector (regardless of whether the mature heap; is compacting), but bring the added complexity of requiring write barriers. Threaded; Denotes a multithreaded mutator; the collector must still stop the mutator; (""stop the world"") before beginning reachability analysis. Stopping a; multithreaded mutator is a complicated problem. It generally requires highly; platform-specific code in the runtime, and the production of carefully; designed machine code at safe points. Concurrent; In this technique, the mutator and the collector run concurrently, with the; goal of eliminating pause times. In a *cooperative* collector, the mutator; further aids with collection should a pause occur, allowing collection to take; advantage of multiprocessor hosts. The ""stop the world"" problem of threaded; collectors is generally still present to a limited extent. Sophisticated; marking algorithms are necessary. Read barriers may be necessary. As the matrix indicates, LLVM's garbage collection infrastructure is already; suitable for a wide variety of collectors, but does not currently extend to; multithreaded programs. This will be added in the future as there is; interest. .. _stack-map:. Computing stack maps; --------------------. LLVM automatically computes a stack map. One of the most important features; of a ``GCStrategy`` is to compile this information into the executable in; the binary representation expected by the runtime library. The stack map consists of the location and identity of each GC root in the; each function in",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GarbageCollection.rst:31368,pause,pause,31368,interpreter/llvm-project/llvm/docs/GarbageCollection.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GarbageCollection.rst,1,['pause'],['pause']
Usability,"s soon as we see it: inside; a template, we're not allowed to make assumptions about ""dependent; types"" like Processor<T>. Suppose that later on in; this file the programmer adds an explicit specialization; of Processor, like so:. template <> class Processor<char*> {; void innit();; };. Now the program will work — as long as the programmer only ever; instantiates process() with T = char*! This is why; it's hard, and sometimes impossible, to diagnose mistakes in a; template definition before it's instantiated. The standard says that a template with no valid instantiations is; ill-formed. Clang tries to do as much checking as possible at; definition-time instead of instantiation-time: not only does this; produce clearer diagnostics, but it also substantially improves; compile times when using pre-compiled headers. The downside to this; philosophy is that Clang sometimes fails to process files because they; contain broken templates that are no longer used. The solution is; simple: since the code is unused, just remove it. Default initialization of const variable of a class type requires user-defined default constructor. If a class or struct has no user-defined default; constructor, C++ doesn't allow you to default construct a const; instance of it like this ([dcl.init], p9):. class Foo {; public:; // The compiler-supplied default constructor works fine, so we; // don't bother with defining one.; ...; };. void Bar() {; const Foo foo; // Error!; ...; }. To fix this, you can define a default constructor for the class:. class Foo {; public:; Foo() {}; ...; };. void Bar() {; const Foo foo; // Now the compiler is happy.; ...; }. An upcoming change to the C++ standard is expected to weaken this rule to only; apply when the compiler-supplied default constructor would leave a member; uninitialized. Clang implements the more relaxed rule in version 3.8 onwards. Parameter name lookup. Some versions of GCC allow the redeclaration of function parameter names within a function protot",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html:19894,simpl,simple,19894,interpreter/llvm-project/clang/www/compatibility.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html,1,['simpl'],['simple']
Usability,"s to the end of Chapter 1 of Building a JIT. You now have a basic; but fully functioning JIT stack that you can use to take LLVM IR and make it; executable within the context of your JIT process. In the next chapter we'll; look at how to extend this JIT to produce better quality code, and in the; process take a deeper look at the ORC layer concept. `Next: Extending the KaleidoscopeJIT <BuildingAJIT2.html>`_. Full Code Listing; =================. Here is the complete code listing for our running example. To build this; example, use:. .. code-block:: bash. # Compile; clang++ -g toy.cpp `llvm-config --cxxflags --ldflags --system-libs --libs core orcjit native` -O3 -o toy; # Run; ./toy. Here is the code:. .. literalinclude:: ../../examples/Kaleidoscope/BuildingAJIT/Chapter1/KaleidoscopeJIT.h; :language: c++. .. [1] Actually we use a cut-down version of KaleidoscopeJIT that makes a; simplifying assumption: symbols cannot be re-defined. This will make it; impossible to re-define symbols in the REPL, but will make our symbol; lookup logic simpler. Re-introducing support for symbol redefinition is; left as an exercise for the reader. (The KaleidoscopeJIT.h used in the; original tutorials will be a helpful reference). .. [2] +-----------------------------+-----------------------------------------------+; | File | Reason for inclusion |; +=============================+===============================================+; | CompileUtils.h | Provides the SimpleCompiler class. |; +-----------------------------+-----------------------------------------------+; | Core.h | Core utilities such as ExecutionSession and |; | | JITDylib. |; +-----------------------------+-----------------------------------------------+; | ExecutionUtils.h | Provides the DynamicLibrarySearchGenerator |; | | class. |; +-----------------------------+-----------------------------------------------+; | IRCompileLayer.h | Provides the IRCompileLayer class. |; +-----------------------------+-----------------------",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/BuildingAJIT1.rst:13490,simpl,simpler,13490,interpreter/llvm-project/llvm/docs/tutorial/BuildingAJIT1.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/BuildingAJIT1.rst,1,['simpl'],['simpler']
Usability,"s to; improve the quality of clang by self-testing. Some examples:. Improve the reliability of AST printing and serialization by; ensuring that the AST produced by clang on an input doesn't change; when it is reparsed or unserialized. Improve parser reliability and error generation by automatically; or randomly changing the input checking that clang doesn't crash and; that it doesn't generate excessive errors for small input; changes. Manipulating the input at both the text and token levels is; likely to produce interesting test cases. Continue work on C++20, C++23, C++2c, and C23 support:; There are still several C++20 features to complete, and work has begun on; supporting the latest language standards. Please see the; C++ status report page to find out what is; missing.; StringRef'ize APIs: A thankless but incredibly useful project is; StringRef'izing (converting to use llvm::StringRef instead of const; char * or std::string) various clang interfaces. This generally; simplifies the code and makes it more efficient.; Configuration Manager: Clang/LLVM works on a large number of; architectures and operating systems and can cross-compile to a similarly large; number of configurations, but the pitfalls of choosing the command-line; options, making sure the right sub-architecture is chosen and that the correct; optional elements of your particular system can be a pain. A tool that would investigate hosts and targets, and store the configuration; in files that can later be used by Clang itself to avoid command-line options,; especially the ones regarding which target options to use, would greatly alleviate; this problem. A simple tool, with little or no dependency on LLVM itself, that; will investigate a target architecture by probing hardware, software, libraries; and compiling and executing code to identify all properties that would be relevant; to command-line options (VFP, SSE, NEON, ARM vs. Thumb etc), triple settings etc.; The first stage is to build a CFLAGS for C",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/OpenProjects.html:5288,simpl,simplifies,5288,interpreter/llvm-project/clang/www/OpenProjects.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/OpenProjects.html,1,['simpl'],['simplifies']
Usability,"s use [GitHub issues](https://github.com/civetweb/civetweb/issues). Source releases can be found on GitHub; [https://github.com/civetweb/civetweb/releases](https://github.com/civetweb/civetweb/releases). A very brief overview can be found on GitHub Pages; [http://civetweb.github.io/civetweb/](http://civetweb.github.io/civetweb/). Getting The Source; ------------------; Download the source code by running the following code in your command prompt:. $ git clone https://github.com/civetweb/civetweb.git; or simply grab a copy of the source code as a ZIP or TGZ file. Quick start documentation; --------------------------. - [docs/Installing.md](https://github.com/civetweb/civetweb/blob/master/docs/Installing.md) - Install Guide (for end users using pre-built binaries); - [docs/UserManual.md](https://github.com/civetweb/civetweb/blob/master/docs/UserManual.md) - End User Guide; - [docs/Building.md](https://github.com/civetweb/civetweb/blob/master/docs/Building.md) - Building the Server (quick start guide); - [docs/Embedding.md](https://github.com/civetweb/civetweb/blob/master/docs/Embedding.md) - Embedding (how to add HTTP support to an existing application); - [docs/OpenSSL.md](https://github.com/civetweb/civetweb/blob/master/docs/OpenSSL.md) - Adding HTTPS (SSL/TLS) support using OpenSSL.; - [API documentation](https://github.com/civetweb/civetweb/tree/master/docs/api) - Additional documentation on the civetweb application programming interface ([civetweb.h](https://github.com/civetweb/civetweb/blob/master/include/civetweb.h)).; - [RELEASE_NOTES.md](https://github.com/civetweb/civetweb/blob/master/RELEASE_NOTES.md) - Release Notes; - [SECURITY.md](https://github.com/civetweb/civetweb/blob/master/SECURITY.md) - Security Policy; - [LICENSE.md](https://github.com/civetweb/civetweb/blob/master/LICENSE.md) - Copyright License. Overview; --------. CivetWeb keeps the balance between functionality and; simplicity by a carefully selected list of features:. - Liberal, commercial-fr",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/http/civetweb/README.md:4306,guid,guide,4306,net/http/civetweb/README.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/http/civetweb/README.md,1,['guid'],['guide']
Usability,"s used in; your code), it should work for AD support efforts. Please view Clad; documentation for more details. ---. ## Appendix A - What could go wrong (FAQs). ### Will my analyticalIntegral() function support AD?. Both scenarios are possible:. 1 - where `analyticalIntegral()` will be able to support AD. 2 - where `analyticalIntegral()` will *not* be able to support AD. This requires further research. ### What if my evaluate() function cannot support AD?. In some cases. the `evaluate()` function is written in a piece-wise format; (multiple evaluations based on multiple chunks of code). You can review the; `MathFuncs.h` file to find AD support for several piece-wise (`if code==1; {...} else if code==2 {...}` ) code snippets. However, there may still be some cases where AD support may not be possible; due to the way that `evaluate()` function works in that instance. ### What if my evaluate() function depends heavily on caching?. For simple caching, the caching logic can be separated from the; mathematical code that is being moved to `MathFuncs.h`, so that it can; retained in the original file. For more complicated scenarios, the `code` variable can be used to identify; use cases (parts of the mathematical code in `evaluate()`) that should be; supported, while other parts that are explicitly not be supported (e.g., using; `if code==1 {...} else if code==2 {...}`). ### Can classes using Numerical Integration support AD?. So far, no. This needs further exploration. Hint: classes using Numerical; Integration can be identified with the absence of the `analyticalIntegral()`; function. ### Why is my code falling back to Numeric Differentiation?. If you call in to an external Math library, and you use a function that has a; customized variant with an already defined custom derivative, then you may see; a warning like ""falling back to Numeric Differentiation"". In most such cases,; your derivative should still work, since Numeric Differentiation is already; well-tested in Clad",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/developers/roofit_ad.md:26762,simpl,simple,26762,roofit/doc/developers/roofit_ad.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/developers/roofit_ad.md,1,['simpl'],['simple']
Usability,"s used to track the state:; * Rather than inserting a `cmovCC` instruction along every conditional edge in; the original program, we track each set of condition flags we need to capture; prior to entering each basic block and reuse a common `cmovCC` sequence for; those.; * We could further reuse suffixes when there are multiple `cmovCC`; instructions required to capture the set of flags. Currently this is; believed to not be worth the cost as paired flags are relatively rare and; suffixes of them are exceedingly rare.; * A common pattern in x86 is to have multiple conditional jump instructions; that use the same flags but handle different conditions. Naively, we could; consider each fallthrough between them an ""edge"" but this causes a much more; complex control flow graph. Instead, we accumulate the set of conditions; necessary for fallthrough and use a sequence of `cmovCC` instructions in a; single fallthrough edge to track it. Second, we trade register pressure for simpler `cmovCC` instructions by; allocating a register for the ""bad"" state. We could read that value from memory; as part of the conditional move instruction, however, this creates more; micro-ops and requires the load-store unit to be involved. Currently, we place; the value into a virtual register and allow the register allocator to decide; when the register pressure is sufficient to make it worth spilling to memory; and reloading. #### Hardening Loads. Once we have the predicate accumulated into a special value for correct vs.; misspeculated, we need to apply this to loads in a way that ensures they do not; leak secret data. There are two primary techniques for this: we can either; harden the loaded value to prevent observation, or we can harden the address; itself to prevent the load from occurring. These have significantly different; performance tradeoffs. ##### Hardening loaded values. The most appealing way to harden loads is to mask out all of the bits loaded.; The key requirement is that for e",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SpeculativeLoadHardening.md:21835,simpl,simpler,21835,interpreter/llvm-project/llvm/docs/SpeculativeLoadHardening.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SpeculativeLoadHardening.md,1,['simpl'],['simpler']
Usability,"s within the vector. This means that the register content is the same as it would have been on a little endian system. It may seem that ``LD1`` should suffice to perform vector loads on a big endian machine. However there are pros and cons to the two approaches that make it less than simple which register format to pick. There are two options:. 1. The content of a vector register is the same *as if* it had been loaded with an ``LDR`` instruction.; 2. The content of a vector register is the same *as if* it had been loaded with an ``LD1`` instruction. Because ``LD1 == LDR + REV`` and similarly ``LDR == LD1 + REV`` (on a big endian system), we can simulate either type of load with the other type of load plus a ``REV`` instruction. So we're not deciding which instructions to use, but which format to use (which will then influence which instruction is best to use). .. The 'clearer' container is required to make the following section header come after the floated; images above.; .. container:: clearer. Note that throughout this section we only mention loads. Stores have exactly the same problems as their associated loads, so have been skipped for brevity. Considerations; ==============. LLVM IR Lane ordering; ---------------------. LLVM IR has first class vector types. In LLVM IR, the zero'th element of a vector resides at the lowest memory address. The optimizer relies on this property in certain areas, for example when concatenating vectors together. The intention is for arrays and vectors to have identical memory layouts - ``[4 x i8]`` and ``<4 x i8>`` should be represented the same in memory. Without this property there would be many special cases that the optimizer would have to cleverly handle. Use of ``LDR`` would break this lane ordering property. This doesn't preclude the use of ``LDR``, but we would have to do one of two things:. 1. Insert a ``REV`` instruction to reverse the lane order after every ``LDR``.; 2. Disable all optimizations that rely on lane layout, ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/BigEndianNEON.rst:4402,clear,clearer,4402,interpreter/llvm-project/llvm/docs/BigEndianNEON.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/BigEndianNEON.rst,1,['clear'],['clearer']
Usability,"s you out by automatically printing instantiation information and; nested range information for diagnostics as they are instantiated through macros; and also shows how some of the other pieces work in a bigger example. $ clang -fsyntax-only t.c; t.c:80:3: error: invalid operands to binary expression ('typeof(P)' (aka 'struct mystruct') and 'typeof(F)' (aka 'float')); X = MYMAX(P, F);; ^~~~~~~~~~~; t.c:76:94: note: expanded from:; #define MYMAX(A,B) __extension__ ({ __typeof__(A) __a = (A); __typeof__(B) __b = (B); __a < __b ? __b : __a; }); ~~~ ^ ~~~. Here's another real world warning that occurs in the ""window"" Unix package (which; implements the ""wwopen"" class of APIs):. $ clang -fsyntax-only t.c; t.c:22:2: warning: type specifier missing, defaults to 'int'; ILPAD();; ^; t.c:17:17: note: expanded from:; #define ILPAD() PAD((NROW - tt.tt_row) * 10) /* 1 ms per char */; ^; t.c:14:2: note: expanded from:; register i; \; ^. In practice, we've found that Clang's treatment of macros is actually more useful in multiply nested; macros than in simple ones.; Quality of Implementation and Attention to Detail; Finally, we have put a lot of work polishing the little things, because; little things add up over time and contribute to a great user experience.; The following example shows that we recover from the simple case of; forgetting a ; after a struct definition much better than GCC. $ cat t.cc; template<class T>; class a {};; struct b {}; a<int> c;; $ gcc-4.9 t.cc; t.cc:4:8: error: invalid declarator before 'c'; a<int> c;; ^; $ clang t.cc; t.cc:3:12: error: expected ';' after struct; struct b {}; ^; ;. The following example shows that we diagnose and recover from a missing; typename keyword well, even in complex circumstances where GCC; cannot cope. $ cat t.cc; template<class T> void f(T::type) { }; struct A { };; void g(); {; A a;; f<A>(a);; }; $ gcc-4.9 t.cc; t.cc:1:33: error: variable or field 'f' declared void; template<class T> void f(T::type) { }; ^; t.cc: In function",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/diagnostics.html:9962,simpl,simple,9962,interpreter/llvm-project/clang/www/diagnostics.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/diagnostics.html,1,['simpl'],['simple']
Usability,"s |; +-----------------------------------------+----------------------------------+; | `SetSparseIndex` `(Int_t nelems new)` | allocate memory for a sparse map |; | | of `nelems_new` elements and |; | | copy (if exists) at most |; | | `nelems_new` matrix elements |; | | over to the new structure |; +-----------------------------------------+----------------------------------+; | `SetSparseIndex` | copy the sparse map from matrix |; | `(const TMatrixDBase &a)` | `a` Note that this can be a |; | | dense matrix! |; +-----------------------------------------+----------------------------------+; | `SetSparseIndexAB` | set the sparse map to the same |; | `(const TMatrixDSparse &a,` ` | of the map of matrix `a` and `b` |; | const TMatrixDSparse &b)` | |; +-----------------------------------------+----------------------------------+. The second half of the table is only relevant for sparse matrices. These; methods define the sparse structure. It should be clear that a call to; any of these methods has to be followed by a **`SetMatrixArray`** (...); which will supply the matrix data, see the next chapter ""Creating and; Filling a Matrix"". ## Creating and Filling a Matrix. The matrix constructors are listed in the next table. In the simplest; ones, only the number of rows and columns is given. In a slightly more; elaborate version, one can define the row and column index range.; Finally, one can also define the matrix data in the constructor. In; Matrix Operators and Methods we will encounter more fancy constructors; that will allow arithmetic operations. +--------------------------------------------------------------------------+; | `TMatrixD(Int_t nrows,Int_t ncols)` |; | |; | `TMatrixD(Int_t row_lwb,Int_t row_upb,Int_t col_lwb,Int_t col_upb)` |; | |; | `TMatrixD(Int_t nrows,Int_t ncols,const Double_t *data, Option_t option= |; | """")` |; | |; | `TMatrixD(Int_t row_lwb,Int_t row_upb,Int_t col_lwb,Int_t col_upb,` |; | |; | ` const Double_t *data,Option_t *option="""")` |; +-----",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/LinearAlgebra.md:9377,clear,clear,9377,documentation/users-guide/LinearAlgebra.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/LinearAlgebra.md,1,['clear'],['clear']
Usability,"s's returned ``PreservedAnalyses``. This can be also done; manually within the pass:. .. code-block:: c++. FooModulePass::run(Module& M, ModuleAnalysisManager& AM) {; auto &FAM = AM.getResult<FunctionAnalysisManagerModuleProxy>(M).getManager();. // Invalidate all analysis results for function F1.; FAM.invalidate(F1, PreservedAnalyses::none());. // Invalidate all analysis results across the entire module.; AM.invalidate(M, PreservedAnalyses::none());. // Clear the entry in the analysis manager for function F2 if we've completely removed it from the module.; FAM.clear(F2);. ...; }. One thing to note when accessing inner level IR analyses is cached results for; deleted IR. If a function is deleted in a module pass, its address is still used; as the key for cached analyses. Take care in the pass to either clear the; results for that function or not use inner analyses at all. ``AM.invalidate(M, PreservedAnalyses::none());`` will invalidate the inner; analysis manager proxy which will clear all cached analyses, conservatively; assuming that there are invalid addresses used as keys for cached analyses.; However, if you'd like to be more selective about which analyses are; cached/invalidated, you can mark the analysis manager proxy as preserved,; essentially saying that all deleted entries have been taken care of manually.; This should only be done with measurable compile time gains as it can be tricky; to make sure all the right analyses are invalidated. Implementing Analysis Invalidation; ==================================. By default, an analysis is invalidated if ``PreservedAnalyses`` says that; analyses on the IR unit it runs on are not preserved (see; ``AnalysisResultModel::invalidate()``). An analysis can implement; ``invalidate()`` to be more conservative when it comes to invalidation. For; example,. .. code-block:: c++. bool FooAnalysisResult::invalidate(Function &F, const PreservedAnalyses &PA,; FunctionAnalysisManager::Invalidator &) {; auto PAC = PA.getChecker<Fo",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/NewPassManager.rst:14428,clear,clear,14428,interpreter/llvm-project/llvm/docs/NewPassManager.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/NewPassManager.rst,1,['clear'],['clear']
Usability,"s, and Cling sometimes calls them fundamental types. When we say, ""writing an object to a file"", we actually mean writing the; current values of the data members. The most common way to do this is to; decompose (also called the serialization of) the object into its data; members and write them to disk. The decomposition is the job of the; `Streamer`. Every class with ambitions to be stored in a file has a; `Streamer `that decomposes it and ""streams"" its members into a buffer. The methods of the class are not written to the file, it contains only; the persistent data members. To decompose the parent classes, the; `Streamer `calls the `Streamer `of the parent classes. It moves up the; inheritance tree until it reaches an ancestor without a parent. To; serialize the object data members it calls their `Streamer`. They in; turn move up their own inheritance tree and so forth. The simple data; members are written to the buffer directly. Eventually the buffer; contains all simple data members of all the classes that make up this; particular object. Data members that are references (as; `MyClass &fObj;`) are never saved, it is always the responsibility of; the object's constructor to set them properly. ### Automatically Generated Streamers. A `Streamer `usually calls other `Streamers`: the `Streamer `of its; parents and data members. This architecture depends on all classes; having `Streamers`, because eventually they will be called. To ensure; that a class has a `Streamer`, `rootcling` automatically creates one in; the `ClassDef` macro that is defined in `$ROOTSYS/include/Rtypes.h`.; `ClassDef` defines several methods for any class, and one of them is the; `Streamer`. The automatically generated `Streamer `is complete and can; be used as long as no customization is needed. The `Event` class is defined in `$ROOTSYS/test/Event.h`. Looking at the; class definition, we find that it inherits from **`TObject`**. It is a; simple example of a class with diverse data members. ``` {.",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md:43289,simpl,simple,43289,documentation/users-guide/InputOutput.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md,1,['simpl'],['simple']
Usability,"s, and framework; stability. The changes with respect to ROOT 5.27 / TMVA 4.0.7 are; in detail:. Framework. Multi-class support. The support of multiple; output classes (i.e., more than a single background and signal; class) has been enabled for these methods: MLP (NN), BDTG,; FDA.; The multiclass; functionality can be enabled with the Factory option; ""AnalysisType=multiclass"". Training data is; specified with an additional classname, e.g. via; factory->AddTree(tree,""classname"");. After the; training a genetic algorithm is invoked to determine the best; cuts for selecting a specific class, based on the figure of; merit: purity*efficiency. TMVA comes with two examples in; $ROOTSYS/tmva/test: TMVAMulticlass.C; and TMVAMulticlassApplication.C. New TMVA event vector building. The code; for splitting the input data into training and test samples for; all classes and the mixing of those samples to one training and; one test sample has been rewritten completely. The new code is; more performant and has a clearer structure. This fixes several; bugs which have been reported by some users of TMVA.; Code and performance test framework: A unit; test framework for daily software and method performance; validation has been implemented.; . Methods. BDT Automatic parameter optimisation for building the; tree architecture: The optimisation procedure uses the; performance of the trained classifier on the ""test sample"" for; finding the set of optimal parameters. Two different methods to; traverse the parameter space are available (scanning, genetic; algorithm). Currently parameter optimization is implemented only; for these three parameters that influence the tree architectur:; the maximum depth of a tree, MaxDepth, the minimum; number of events in each node, NodeMinEvents, and; the number of tress, NTrees. Optimization can; is invoked by calling; factory->OptimizeAllMethods(); prior to the call; factory->TrainAllMethods();. Automated and configurable parameter optimization is soon to",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/doc/v528/index.html:1316,clear,clearer,1316,tmva/doc/v528/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/doc/v528/index.html,1,['clear'],['clearer']
Usability,"s-entropy loss function. In addition we have :. - New `TMVA::Executor` class to control the multi-thread running of TMVA. By default now MT running will be enabled only when `ROOT::EnabledImplicitMT()` is called. But we can take the control of the threads by using `TMVA::gConfig().EnableMT(...)` and `TMVA::gConfig().DisableMT()`. ### PyMVA; - add support when using the Tensorflow backend in Keras to control the number of threads; - add possibility to control options for configuring GPU running. FOr example we can now set the mode to allocate memory only as needed. This is required when using the new RTX gaming cards from NVIDIA. ## 2D Graphics Libraries. - In the statistics painting for 2D histograms, the central cell of; the underflow/overflow grid was not properly rendered for very large contents.; This problem was reported [here](https://root-forum.cern.ch/t/stat-box-for-th2/).; - The automatic placement of legend now ""sees"" TMultiGraph and THStack.; - Improve and simplify the drawing the 2D histogram's option ""ARR"".; - The option ARR can be combined with the option COL or COLZ.; - `TBox::DistancetoPrimitive` and `TBox::ExecuteEvent` now work in log scales (by Jérémie Dudouet).; - Take the line attributes into account when drawing a histogram with option bar or hbar.; They were ignored until now.; - The new draw option MIN0 makes same effect as gStyle->SetHistMinimumZero(1), but can be specified; individually for each histogram.; - Improve the line clipping when a histogram is drawn with option ""L"". The following; example shows the improvement.; ~~~ {.cpp}; auto h = new TH1F(""h"",""h"",5,0.5,5.5);; h->SetBinContent(1,100000);; h->SetBinContent(2,10000);; h->SetBinContent(3,1000);; h->SetBinContent(4,100);; h->SetBinContent(5,10);; h->SetMinimum(50.);; h->SetMaximum(40000);; h->Draw(""L*"");; gPad->SetLogy();; ~~~; - `ChangeLabel` is now available for alphanumeric axis.; - Implement transparency for lines, texts and markers in the TeX output. ## 3D Graphics Libraries. -",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v618/index.md:18808,simpl,simplify,18808,README/ReleaseNotes/v618/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v618/index.md,1,['simpl'],['simplify']
Usability,"s. //===---------------------------------------------------------------------===//. In this code:. long foo(long x) {; return x > 1 ? x : 1;; }. LLVM emits a comparison with 1 instead of 0. 0 would be equivalent; and cheaper on most targets. LLVM prefers comparisons with zero over non-zero in general, but in this; case it choses instead to keep the max operation obvious. //===---------------------------------------------------------------------===//. define void @a(i32 %x) nounwind {; entry:; switch i32 %x, label %if.end [; i32 0, label %if.then; i32 1, label %if.then; i32 2, label %if.then; i32 3, label %if.then; i32 5, label %if.then; ]; if.then:; tail call void @foo() nounwind; ret void; if.end:; ret void; }; declare void @foo(). Generated code on x86-64 (other platforms give similar results):; a:; 	cmpl	$5, %edi; 	ja	LBB2_2; 	cmpl	$4, %edi; 	jne	LBB2_3; .LBB0_2:; 	ret; .LBB0_3:; 	jmp	foo # TAILCALL. If we wanted to be really clever, we could simplify the whole thing to; something like the following, which eliminates a branch:; 	xorl $1, %edi; 	cmpl	$4, %edi; 	ja	.LBB0_2; 	ret; .LBB0_2:; 	jmp	foo # TAILCALL. //===---------------------------------------------------------------------===//. We compile this:. int foo(int a) { return (a & (~15)) / 16; }. Into:. define i32 @foo(i32 %a) nounwind readnone ssp {; entry:; %and = and i32 %a, -16; %div = sdiv i32 %and, 16; ret i32 %div; }. but this code (X & -A)/A is X >> log2(A) when A is a power of 2, so this case; should be instcombined into just ""a >> 4"". We do get this at the codegen level, so something knows about it, but ; instcombine should catch it earlier:. _foo: ## @foo; ## %bb.0: ## %entry; 	movl	%edi, %eax; 	sarl	$4, %eax; 	ret. //===---------------------------------------------------------------------===//. This code (from GCC PR28685):. int test(int a, int b) {; int lt = a < b;; int eq = a == b;; if (lt); return 1;; return eq;; }. Is compiled to:. define i32 @test(i32 %a, i32 %b) nounwind readnone ssp {; entry",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/README.txt:52419,simpl,simplify,52419,interpreter/llvm-project/llvm/lib/Target/README.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/README.txt,1,['simpl'],['simplify']
Usability,"s. ; Runtime binding of C++ functions - You can now trivially bind at run time any C++ functions as a RooFit function or p.d.f. objects, e.g. RooAbsReal* erfx = bindFunction(""erfx"",TMath::erf,x). See rf105_funcbinding.C for details; Runtime binding of TFx functions - You can now trivially bind at run time any ROOT TFx function as a RooFit function or p.d.f. objects, e.g. RooAbsReal* myFunc = bindFunction(myTF1,x). See rf105_funcbinding.C for details; RooAbsReal - The handling of -log(L) evaluation errors in plotting is now explicitly controllable, just like in fitting. See rf606_nllerrorhandling.C for details; RooDataHist - Add new named argument constructor that can collate multiple ROOT THn histgrams into a n+1 dimensional RooDataHist; RooDataSet - Add new named argument constructor that can collate multiple input RooDataSets into a n+1 dimensional RooDataSet.Add createHistogram() method for simplified plotting; RooFitResult - Add new method correlationHist() that returns a labeled TH2 with the contents of the fit correlation matrix; RooFFTConvPdf - Automatically put sampling windows of 'resolution model' p.d.f. centered around zero, even if fit range of convolution observable does not bracket zero. Improve internal efficiency; RooAbsData - Add ability to plot efficiency distribution with correct binomial errors given a RooRealVar and a RooCategory category observable encoding distribution and accept/reject state respectively. See rf701_efficiencyfit.C for details ; RooAbsPdf - Included extended ML term by default in fit if p.d.f is extendable. You can still use Extended() to override default behavior. Do not run MINOS by default anymore if no fit options are provided.; RooProfileLL - Add option to always start minimization from global minimimum (takes more time, but improves reproducibility). Can now profile multi-core paralellized likelihoods as well.; RooRealSumPdf - Enable plotting of component p.d.f.s using same scheme as RooAddPdf, i.e. just use the Component",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v522/index.html:7626,simpl,simplified,7626,roofit/doc/v522/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v522/index.html,1,['simpl'],['simplified']
Usability,"s. The sources are checked out from the; upstream git repository when building the image. The resulting image contains only the requested LLVM components and a few extra; packages to make the image minimally useful for C++ development, e.g. libstdc++; and binutils. The interface to run the build is ``build_docker_image.sh`` script. It accepts a; list of LLVM repositories to checkout and arguments for CMake invocation. If you want to write your own docker image, start with an ``example/`` subfolder.; It provides an incomplete Dockerfile with (very few) FIXMEs explaining the steps; you need to take in order to make your Dockerfiles functional. Usage; =====; The ``llvm/utils/build_docker_image.sh`` script provides a rather high degree of; control on how to run the build. It allows you to specify the projects to; checkout from git and provide a list of CMake arguments to use during when; building LLVM inside docker container. Here's a very simple example of getting a docker image with clang binary,; compiled by the system compiler in the debian10 image:. .. code-block:: bash. ./llvm/utils/docker/build_docker_image.sh \; 	--source debian10 \; 	--docker-repository clang-debian10 --docker-tag ""staging"" \; 	-p clang -i install-clang -i install-clang-resource-headers \; 	-- \; 	-DCMAKE_BUILD_TYPE=Release. Note that a build like that doesn't use a 2-stage build process that; you probably want for clang. Running a 2-stage build is a little more intricate,; this command will do that:. .. code-block:: bash. # Run a 2-stage build.; # LLVM_TARGETS_TO_BUILD=Native is to reduce stage1 compile time.; # Options, starting with BOOTSTRAP_* are passed to stage2 cmake invocation.; ./build_docker_image.sh \; 	--source debian10 \; 	--docker-repository clang-debian10 --docker-tag ""staging"" \; 	-p clang -i stage2-install-clang -i stage2-install-clang-resource-headers \; 	-- \; 	-DLLVM_TARGETS_TO_BUILD=Native -DCMAKE_BUILD_TYPE=Release \; 	-DBOOTSTRAP_CMAKE_BUILD_TYPE=Release \; 	-DCLANG_ENABLE",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Docker.rst:3570,simpl,simple,3570,interpreter/llvm-project/llvm/docs/Docker.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Docker.rst,1,['simpl'],['simple']
Usability,"s.; for ref in $(git -C my-monorepo for-each-ref --format=""%(refname)"" \; refs/remotes/myrepo/release); do; branch=${ref#refs/remotes/myrepo/}; git -C my-monorepo branch --no-track myrepo/${branch} ${ref}; done. # Preserve main.; git -C my-monorepo branch --no-track myrepo/main refs/remotes/myrepo/main. # Merge main.; git -C my-monorepo checkout local/zip/main # Or local/octopus/main; git -C my-monorepo merge myrepo/main. You may want to merge other corresponding branches, for example; ``myrepo`` release branches if they were in lockstep with LLVM project; releases. ``--tag-prefix`` tells ``import-downstream-repo.py`` to rename; annotated tags with the given prefix. Due to limitations with; ``fast_filter_branch.py``, unannotated tags cannot be renamed; (``fast_filter_branch.py`` considers them branches, not tags). Since; the upstream monorepo had its tags rewritten with an ""llvmorg-""; prefix, name conflicts should not be an issue. ``--tag-prefix`` can; be used to more clearly indicate which tags correspond to various; imported repositories. Given this repository history::. R1 - R2 - R3 <- main; ^; |; release/1. The above recipe results in a history like this::. U1 - U2 - U3 <- upstream/main; \ \ \; \ -----\--------------- local/zip--.; \ \ \ |; - Lllvm1 - Llld1 - UM3 - Lclang1 - Lclang2 - Lllvm2 - Llld2 - Lmyproj1 - M1 <-'; /; R1 - R2 - R3 <-.; ^ |; | |; myrepo-release/1 |; |; myrepo/main--'. Commits ``R1``, ``R2`` and ``R3`` have trees that *only* contain blobs; from ``myrepo``. If you require commits from ``myrepo`` to be; interleaved with commits on local project branches (for example,; interleaved with ``llvm1``, ``llvm2``, etc. above) and myrepo doesn't; appear in an umbrella repository, a new tool will need to be; developed. Creating such a tool would involve:. 1. Modifying ``fast_filter_branch.py`` to optionally take a; revlist directly rather than generating it itself. 2. Creating a tool to generate an interleaved ordering of local; commits based on some cri",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Proposals/GitHubMove.rst:36478,clear,clearly,36478,interpreter/llvm-project/llvm/docs/Proposals/GitHubMove.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Proposals/GitHubMove.rst,1,['clear'],['clearly']
Usability,"s.fInt); 42; >>>. * **C-style cast**: This is the simplest option for builtin types.; The syntax is ""template-style"", example:. .. code-block:: python. >>> cppyy.cppdef(""""""; ... void* get_data(int sz) {; ... int* iptr = (int*)malloc(sizeof(int)*sz);; ... for (int i=0; i<sz; ++i) iptr[i] = i;; ... return iptr;; ... }""""""); ...; >>> NDATA = 4; >>> d = cppyy.gbl.get_data(NDATA); >>> print(d); <cppyy.LowLevelView object at 0x1068cba30>; >>> d = cppyy.ll.cast['int*'](d); >>> d.reshape((NDATA,)); >>> print(list(d)); [0, 1, 2, 3]; >>>. * **C++-style casts**: Similar to the C-style cast, there are; ``ll.static_cast`` and ``ll.reinterpret_cast``.; There should never be a reason for a ``dynamic_cast``, since that only; applies to objects, for which auto-casting will work.; The syntax is ""template-style"", just like for the C-style cast above. .. _npcasts:. `NumPy casts`; -------------. The ``cppyy.LowLevelView`` type returned for pointers to basic types,; including for ``void*``, is a simple and light-weight view on memory, given a; pointer, type, and number of elements (or unchecked, if unknown).; It only supports basic operations such as indexing and iterations, but also; the buffer protocol for integration with full-fledged functional arrays such; as NumPy`s ``ndarray``. In addition, specifically when dealing with ``void*`` returns, you can use; NumPy's low-level ``frombuffer`` interface to perform the cast.; Example:. .. code-block:: python. >>> cppyy.cppdef(""""""; ... void* create_float_array(int sz) {; ... float* pf = (float*)malloc(sizeof(float)*sz);; ... for (int i = 0; i < sz; ++i) pf[i] = 2*i;; ... return pf;; ... }""""""); ...; >>> import numpy as np; >>> NDATA = 8; >>> arr = cppyy.gbl.create_float_array(NDATA); >>> print(arr); <cppyy.LowLevelView object at 0x109f15230>; >>> arr.reshape((NDATA,)) # adjust the llv's size; >>> v = np.frombuffer(arr, dtype=np.float32, count=NDATA) # cast to float; >>> print(len(v)); 8; >>> print(v); array([ 0., 2., 4., 6., 8., 10., 12., 14.],",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/lowlevel.rst:4598,simpl,simple,4598,bindings/pyroot/cppyy/cppyy/doc/source/lowlevel.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/lowlevel.rst,1,['simpl'],['simple']
Usability,"s0x8000``' gives -32768. Note that hexadecimal integers are sign extended from the number; of active bits, i.e. the bit width minus the number of leading; zeros. So '``s0x0001``' of type '``i16``' will be -1, not 1.; **Floating-point constants**; Floating-point constants use standard decimal notation (e.g.; 123.421), exponential notation (e.g. 1.23421e+2), or a more precise; hexadecimal notation (see below). The assembler requires the exact; decimal value of a floating-point constant. For example, the; assembler accepts 1.25 but rejects 1.3 because 1.3 is a repeating; decimal in binary. Floating-point constants must have a; :ref:`floating-point <t_floating>` type.; **Null pointer constants**; The identifier '``null``' is recognized as a null pointer constant; and must be of :ref:`pointer type <t_pointer>`.; **Token constants**; The identifier '``none``' is recognized as an empty token constant; and must be of :ref:`token type <t_token>`. The one non-intuitive notation for constants is the hexadecimal form of; floating-point constants. For example, the form; '``double 0x432ff973cafa8000``' is equivalent to (but harder to read; than) '``double 4.5e+15``'. The only time hexadecimal floating-point; constants are required (and the only time that they are generated by the; disassembler) is when a floating-point constant must be emitted but it; cannot be represented as a decimal floating-point number in a reasonable; number of digits. For example, NaN's, infinities, and other special; values are represented in their IEEE hexadecimal format so that assembly; and disassembly do not cause any bits to change in the constants. When using the hexadecimal form, constants of types bfloat, half, float, and; double are represented using the 16-digit form shown above (which matches the; IEEE754 representation for double); bfloat, half and float values must, however,; be exactly representable as bfloat, IEEE 754 half, and IEEE 754 single; precision respectively. Hexadecimal format is a",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:185815,intuit,intuitive,185815,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['intuit'],['intuitive']
Usability,"s5.root Y 1.40 Gb 8.09s +/- 0.08 (700 entries) . In the case of a data member which is a pointer to a STL container, eg:; std::container<Data> *fDataObjects;; and which is stored member-wise, add support for the schema evolution of the class 'Data'. This requires a change in the on file format used to store this type; of data members (i.e. by adding inline the version number of the class; 'Data'). To read file containing this construct and written with this revision; using an older version of ROOT you will need the following patches:; For v5.22/00, you will need the patch r33174; or v5.22/00k; For v5.26/00, you will need patch r33176; or v5.26/00c. Additionally, we no longer allow the member wise streaming of a class which; has a custom streamer nor of any data members marked with //||. Run time performance. We introduced an optimized infrastructure for reading objects using a StreamerInfo. Rather than driving the streaming using a switch statement inside TStreamerInfo::ReadBuffer,; the streaming is now driven using a simple loop over a sequence of configured StreamerInfo actions. This improves run-time performance by allowing a dramatic reduction in function calls and code; branches at the expense of some code duplication. There are 3 versions of this loop implemented in TBufferFile and overloaded in TBufferXML and TBufferSQL:. virtual Int_t ReadSequence(const TStreamerInfoActions::TActionSequence &sequence, void *object);; virtual Int_t ReadSequence(const TStreamerInfoActions::TActionSequence &sequence,; void *start_collection, void *end_collection);; virtual Int_t ReadSequence(const TStreamerInfoActions::TActionSequence &sequence,; void *start_collection, void *end_collection);. The 1st version is optimized to read a single object. The 2nd version is optimized to read the content of TClonesArrays and vectors of pointers to objects. The 3rd version is used to streamed any collections. TBufferXML and TBufferSQL overload the loops to introduce extra code to help the",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/doc/v528/index.html:3052,simpl,simple,3052,io/doc/v528/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/doc/v528/index.html,1,['simpl'],['simple']
Usability,"s; Using ccache materially improves average build times. Incremental builds; can be slightly faster, but introduce the risk of build corruption due to; e.g. state changes, etc... At this point, the recommendation is not to; use incremental builds and instead use ccache as the latter captures the; majority of the benefit with less risk of false positives. One of the non-obvious benefits of using ccache is that it makes the; builder less sensitive to which projects are being monitored vs built.; If a change triggers a build request, but doesn't change the build output; (e.g. doc changes, python utility changes, etc..), the build will entirely; hit in cache and the build request will complete in just the testing time. With multiple workers, it is tempting to try to configure a shared cache; between the workers. Experience to date indicates this is difficult to; well, and that having local per-worker caches gets most of the benefit; anyways. We don't currently recommend shared caches. CCache does depend on the builder hardware having sufficient IO to access; the cache with reasonable access times - i.e. a fast disk, or enough memory; for a RAM cache, etc.. For builders without, incremental may be your best; option, but is likely to require higher ongoing involvement from the; sponsor. Enable batch builds; As a last resort, you can configure your builder to batch build requests.; This makes the build failure notifications markedly less actionable, and; should only be done once all other reasonable measures have been taken. Leave it on the staging buildmaster; While most of this section has been biased towards builders intended for; the main buildmaster, it is worth highlighting that builders can run; indefinitely on the staging buildmaster. Such a builder may still be; useful for the sponsoring organization, without concern of negatively; impacting the broader community. The sponsoring organization simply; has to take on the responsibility of all bisection and triage. ; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToAddABuilder.rst:13009,simpl,simply,13009,interpreter/llvm-project/llvm/docs/HowToAddABuilder.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToAddABuilder.rst,1,['simpl'],['simply']
Usability,"s; bool fix_amp[MAX_NUMBER_OF_PEAKS1]i; // logical vector, which allows to fix appropriate amplitudes (not fit). However they are present in the estimated functional; double area[MAX_NUMBER_OF_PEAKS1]; // calculated areas of peaks; double area_err[MAX_NUMBER_OF_PEAKS1]; // errors of peak areas; double sigma_init; // sigma parameter, see peak shape function; double sigma_calc;; double sigma_err;; bool fix_sigma;; double t_init // t parameter, see peak shape function; double t_calc;; double t_err;; bool fix_t;; double b_init // b parameter, see peak shape function; double b_calc;; double b_err;; bool fix_b;; double s_init; // s parameter, see peak shape function; double s_calc;; double s_err;; bool fix_s;; double a0_init; // background is estimated as a0+a1*x+a2*x*x; double a0_calc;; double a0_err;; bool fix_a0;; double a1_init;; double a1_calc;; double a1_err;; bool fix_a1;; double a2_init;; double a2_calc;; double a2_err;; bool fix_a2;; };; ```. As an example we present a simple 1-dimensional synthetic spectrum with 5; peaks. The fit (obtained using above-given awmi fitting function) is given; in Figure 5.1. The chi-square achieved in this fit was 0.76873. The input; value of the fit (positions of peaks and their amplitudes) were; estimated using peak searching function. ![Fit obtained using above given awmi fitting function](figures/image172.png). Let us go to a more complicated fit with a lot of overlapping peaks as in Figure 5.2.; The initial positions of peaks were determined from original data, using; peak searching function. The fit is not very good, as there are some; peaks missing. ![More complicated fit with lot of overlapping peaks](figures/image174.png). However, in order to analyze the spectrum, we can proceed in a completely different way employing the sophisticated functions of background elimination and deconvolution. First, let us remove background from the original raw; data. We get spectrum given in Figure 5.3. ![Removed background from the origina",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/spectrum/Spectrum.md:44008,simpl,simple,44008,documentation/spectrum/Spectrum.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/spectrum/Spectrum.md,1,['simpl'],['simple']
Usability,"sary; to execute tail iterations of the loop if the loop trip count is unknown or it; does not evenly divide the vectorization and unroll factors. When the; vectorization and unroll factors are large, it's possible for loops with smaller; trip counts to end up spending most of their time in the scalar (rather than; the vector) code. In order to address this issue, the inner loop vectorizer is; enhanced with a feature that allows it to vectorize epilogue loops with a; vectorization and unroll factor combination that makes it more likely for small; trip count loops to still execute in vectorized code. The diagram below shows; the CFG for a typical epilogue vectorized loop with runtime checks. As; illustrated the control flow is structured in a way that avoids duplicating the; runtime pointer checks and optimizes the path length for loops that have very; small trip counts. .. image:: epilogue-vectorization-cfg.png. Performance; -----------. This section shows the execution time of Clang on a simple benchmark:; `gcc-loops <https://github.com/llvm/llvm-test-suite/tree/main/SingleSource/UnitTests/Vectorizer>`_.; This benchmarks is a collection of loops from the GCC autovectorization; `page <http://gcc.gnu.org/projects/tree-ssa/vectorization.html>`_ by Dorit Nuzman. The chart below compares GCC-4.7, ICC-13, and Clang-SVN with and without loop vectorization at -O3, tuned for ""corei7-avx"", running on a Sandybridge iMac.; The Y-axis shows the time in msec. Lower is better. The last column shows the geomean of all the kernels. .. image:: gcc-loops.png. And Linpack-pc with the same configuration. Result is Mflops, higher is better. .. image:: linpack-pc.png. Ongoing Development Directions; ------------------------------. .. toctree::; :hidden:. VectorizationPlan. :doc:`VectorizationPlan`; Modeling the process and upgrading the infrastructure of LLVM's Loop Vectorizer. .. _slp-vectorizer:. The SLP Vectorizer; ==================. Details; -------. The goal of SLP vectorization (a.",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Vectorizers.rst:12336,simpl,simple,12336,interpreter/llvm-project/llvm/docs/Vectorizers.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Vectorizers.rst,1,['simpl'],['simple']
Usability,"scope: Kaleidoscope Introduction and the Lexer; =====================================================. .. contents::; :local:. The Kaleidoscope Language; =========================. This tutorial is illustrated with a toy language called; ""`Kaleidoscope <http://en.wikipedia.org/wiki/Kaleidoscope>`_"" (derived; from ""meaning beautiful, form, and view""). Kaleidoscope is a procedural; language that allows you to define functions, use conditionals, math,; etc. Over the course of the tutorial, we'll extend Kaleidoscope to; support the if/then/else construct, a for loop, user defined operators,; JIT compilation with a simple command line interface, debug info, etc. We want to keep things simple, so the only datatype in Kaleidoscope; is a 64-bit floating point type (aka 'double' in C parlance). As such,; all values are implicitly double precision and the language doesn't; require type declarations. This gives the language a very nice and; simple syntax. For example, the following simple example computes; `Fibonacci numbers: <http://en.wikipedia.org/wiki/Fibonacci_number>`_. ::. # Compute the x'th fibonacci number.; def fib(x); if x < 3 then; 1; else; fib(x-1)+fib(x-2). # This expression will compute the 40th number.; fib(40). We also allow Kaleidoscope to call into standard library functions - the; LLVM JIT makes this really easy. This means that you can use the; 'extern' keyword to define a function before you use it (this is also; useful for mutually recursive functions). For example:. ::. extern sin(arg);; extern cos(arg);; extern atan2(arg1 arg2);. atan2(sin(.4), cos(42)). A more interesting example is included in Chapter 6 where we write a; little Kaleidoscope application that `displays a Mandelbrot; Set <LangImpl06.html#kicking-the-tires>`_ at various levels of magnification. Let's dive into the implementation of this language!. The Lexer; =========. When it comes to implementing a language, the first thing needed is the; ability to process a text file and recognize wh",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl01.rst:1048,simpl,simple,1048,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl01.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl01.rst,1,['simpl'],['simple']
Usability,"se it gives comprehensive information; on every decision made by the analyzer across all analysis paths.; There are more debug checkers available. To see all available debug checkers:. $ clang -cc1 -analyzer-checker-help | grep ""debug"". Debug Prints and Tricks; To view ""half-baked"" ExplodedGraph while debugging, jump to a frame; that has clang::ento::ExprEngine object and execute:. (gdb) p ViewGraph(0). To see the ProgramState while debugging use the following command. (gdb) p State->dump(). To see clang::Expr while debugging use the following command. If you; pass in a SourceManager object, it will also dump the corresponding line in the; source code. (gdb) p E->dump(). To dump AST of a method that the current ExplodedNode belongs; to:. (gdb) p C.getPredecessor()->getCodeDecl().getBody()->dump(). Making Your Checker Better. User facing documentation is important for adoption! Make sure the checker list is updated; at the homepage of the analyzer. Also ensure the description is clear to; non-analyzer-developers in Checkers.td.; Warning and note messages should be clear and easy to understand, even if a bit long. Messages should start with a capital letter (unlike Clang warnings!) and should not; end with ..; Articles are usually omitted, eg. Dereference of a null pointer ->; Dereference of null pointer.; Introduce BugReporterVisitors to emit additional notes that explain the warning; to the user better. There are some existing visitors that might be useful for your check,; e.g. trackNullOrUndefValue. For example, SimpleStreamChecker should highlight; the event of opening the file when reporting a file descriptor leak. If the check tracks anything in the program state, it needs to implement the; checkDeadSymbolscallback to clean the state up.; The check should conservatively assume that the program is correct when a tracked symbol; is passed to a function that is unknown to the analyzer.; checkPointerEscape callback could help you handle that case.; Use safe and conv",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/checker_dev_manual.html:23066,clear,clear,23066,interpreter/llvm-project/clang/www/analyzer/checker_dev_manual.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/checker_dev_manual.html,1,['clear'],['clear']
Usability,"se of the; use of the ``%free`` anchor intrinsic. In practice, they almost certainly have to be non-converged dynamic; instances. Consider that if an implementation strictly follows the order of; instructions given in the program, the executions of the threads can be; ""aligned"" as follows:. .. code-block:: text. Thread 1: A B C D F B D E F G; Thread 2: A B D E F B C D F G. So then ``@op.2(1)`` physically executes later than ``@op.2(2)`` and there; can be no communication between the threads, which means they execute; non-converged dynamic instances. That said, it is conceivable that there aren't actually any data or other; dependencies that would enforce this execution order. In that case, a highly; out-of-order implementation could potentially allow communication. That's; why the rules defined in this document are silent about whether; ``@op.2(1) == @op.2(2)`` or not. This type of convergence control seems relatively unlikely to appear in real; programs. Its possibility is simply a logical consequence of the model. An equivalent issue arises if the convergent operations are replaced by nested; loops with loop heart intrinsics that directly refer to ``%anchor``, hence; the variants of the static rules about cycles that apply to them:. .. code-block:: llvm. ; WARNING: Example of incorrect convergence control!. %anchor = call token @llvm.experimental.convergence.anchor(); for (;;) {; if (condition1) {; for (;;) {; %loop1 = call token @llvm.experimental.convergence.loop() [ ""convergencectrl""(token %anchor) ]; }; }; if (condition2) {; for (;;) {; %loop2 = call token @llvm.experimental.convergence.loop() [ ""convergencectrl""(token %anchor) ]; }; }; }. There is a cycle (closed walk in the CFG) that goes through both loop heart; intrinsics using ``%anchor`` but not through the definition of ``%anchor``,; so this code is invalid. Examples for the Correctness of Program Transforms; ==================================================. (This section is informative.). As implied ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ConvergentOperations.rst:46749,simpl,simply,46749,interpreter/llvm-project/llvm/docs/ConvergentOperations.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ConvergentOperations.rst,1,['simpl'],['simply']
Usability,"se);; ig.SetRelTolerance(0.001);. cout << ig.Integral(0, TMath::PiOver2()) << endl;. return 0;; }; ```; #### ROOT::Math::GaussLegendreIntegrator. This class implementes the Gauss-Legendre quadrature formulas. This sort of numerical methods requieres that the user specifies the number of intermediate function points; used in the calculation of the integral. It will automatically determine the coordinates and weights of such points before performing the integration.; We can use the example above, but replacing the creation of a `ROOT::Math::GaussIntegrator` object with `ROOT::Math::GaussLegendreIntegrator`. #### ROOT::Math::GSLIntegrator. This is a wrapper for the *QUADPACK* integrator implemented in the GSL library. It supports several integration methods that can be chosen in construction time.; The default type is adaptive integration with singularity applying a Gauss-Kronrod 21-point integration rule. For a detail description of the GSL methods visit the GSL user guide; This class implements the best algorithms for numerical integration for one dimensional functions. We encourage the use it as the main option, bearing in mind that it uses code from the; GSL library, wich is provided in the *MathMore* library of ROOT. The interface to use is the same as above. We have now the possibility to specify a different integration algorithm in the constructor of the `ROOT::Math::GSLIntegrator` class.; ```{.cpp}; // create the adaptive integrator with the 51 point rule; ROOT::Math::GSLIntegrator ig(ROOT::Math::Integration::kADAPTIVE, ROOT::Math::Integration::kGAUSS51);; ig.SetRelTolerance(1.E-6); // set relative tolerance; ig.SetAbsTolerance(1.E-6); // set absoulte tolerance; ```. The algorithm is controlled by the given absolute and relative tolerance. The iterations are continued until the following condition is satisfied; $$; absErr <= max ( epsAbs, epsRel * Integral); $$; Where *absErr* is an estimate of the absolute error (it can be retrieved with `GSLIntegrator::Error()",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:54916,guid,guide,54916,documentation/users-guide/MathLibraries.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md,1,['guid'],['guide']
Usability,"se:** If your class includes (or should; include) the `analyticalIntegral()` function, then a simple; `buildCallToAnalyticIntegral()` function needs to be created to help call the; `analyticalIntegral()` function. # Example for adding Code Generation support to RooFit classes. Let us take the `RooPoisson.cxx` class as an example. > [roofit/roofit/src/RooPoisson.cxx](https://github.com/root-project/root/blob/master/roofit/roofit/src/RooPoisson.cxx). First step is to locate the `RooPoisson::evaluate()` function. Most RooFit; classes implement this function. > RooFit internally calls the `evaluate()` function to evaluate a single node; in a compute graph. ## Before Code Generation Support. Following is a code snippet from `RooPoisson` *before* it had AD support. ``` {.cpp}; double RooPoisson::evaluate() const; {; double k = _noRounding ? x : floor(x);; if(_protectNegative && mean<0) {; RooNaNPacker np;; np.setPayload(-mean);; return np._payload;; }; return TMath::Poisson(k,mean);; }; ```; `TMath::Poisson()` is a simple mathematical function. For this example, the; relevant part is `return TMath::Poisson(k,mean);`. This needs to be extracted; into the `MathFuncs.h` file and the fully qualified name of the function; referencing that file should be used here instead. ## After Code Generation Support. Following is a code snippet from `RooPoisson` *after* it has AD support. ### Step 1. Refactor the `RooPoisson::evaluate()` Function. ``` {.cpp}; /// Implementation in terms of the TMath::Poisson() function. double RooPoisson::evaluate() const; {; double k = _noRounding ? x : floor(x);; if(_protectNegative && mean<0) {; RooNaNPacker np;; np.setPayload(-mean);; return np._payload;; }; return RooFit::Detail::MathFuncs::poisson(k, mean);; }; ```. Note that the `evaluate()` function was refactored in such a way that the; mathematical parts were moved to an inline function in a separate header file; named `MathFuncs`, so that Clad could see and differentiate that function.; The rest",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/developers/roofit_ad.md:10073,simpl,simple,10073,roofit/doc/developers/roofit_ad.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/developers/roofit_ad.md,1,['simpl'],['simple']
Usability,"sections. Semantics:; """"""""""""""""""""; The purpose of this intrinsic is to allow frontends to mark the cleanup and; other code that is only relevant during the initial invocation of the coroutine; and should not be present in resume and destroy parts. In returned-continuation lowering, ``llvm.coro.end`` fully destroys the; coroutine frame. If the second argument is `false`, it also returns from; the coroutine with a null continuation pointer, and the next instruction; will be unreachable. If the second argument is `true`, it falls through; so that the following logic can resume unwinding. In a yield-once; coroutine, reaching a non-unwind ``llvm.coro.end`` without having first; reached a ``llvm.coro.suspend.retcon`` has undefined behavior. The remainder of this section describes the behavior under switched-resume; lowering. This intrinsic is lowered when a coroutine is split into; the start, resume and destroy parts. In the start part, it is a no-op,; in resume and destroy parts, it is replaced with `ret void` instruction and; the rest of the block containing `coro.end` instruction is discarded.; In landing pads it is replaced with an appropriate instruction to unwind to; caller. The handling of coro.end differs depending on whether the target is; using landingpad or WinEH exception model. For landingpad based exception model, it is expected that frontend uses the; `coro.end`_ intrinsic as follows:. .. code-block:: llvm. ehcleanup:; %InResumePart = call i1 @llvm.coro.end(ptr null, i1 true, token none); br i1 %InResumePart, label %eh.resume, label %cleanup.cont. cleanup.cont:; ; rest of the cleanup. eh.resume:; %exn = load ptr, ptr %exn.slot, align 8; %sel = load i32, ptr %ehselector.slot, align 4; %lpad.val = insertvalue { ptr, i32 } undef, ptr %exn, 0; %lpad.val29 = insertvalue { ptr, i32 } %lpad.val, i32 %sel, 1; resume { ptr, i32 } %lpad.val29. The `CoroSpit` pass replaces `coro.end` with ``True`` in the resume functions,; thus leading to immediate unwind to the caller",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst:44297,resume,resume,44297,interpreter/llvm-project/llvm/docs/Coroutines.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst,1,['resume'],['resume']
Usability,"sembly into `D,E` and `F` will actually position only `A` and; `B `directly into these volumes, taking into account their combined; transformations `A/B` to `C` and `C` to `D/E/F`. This looks much nicer,; is it? In fact, it is and it is not. Of course, we managed to get rid of; the ‘unnecessary' volume `C` in our geometry, but we end-up with a more; flat structure for `D,E` and `F` (more daughters inside). This can get; much worse when extensively used, as in the case: assemblies of; assemblies. For deciding what to choose between using virtual containers or; assemblies for a specific case, one can use for both cases, after the; geometry was closed:. ``` {.cpp}; gGeoManager->SetTopVolume(ptr_D);; gGeoManager->Test();; gGeoManager->RestoreMasterVolume();; ```. The `ptr_D` is a pointer to volume `D` containing the interesting; structure. The test will provide the timing for classifying 1 million; random points inside `D`. #### Examples of Volume Positioning. Now let us make a simple volume representing a copper wire. We suppose; that a medium is already created (see **`TGeoMedium`** class on how to; create media). We will create a `TUBE` shape for our wire, having `Rmin=0cm`,; `Rmax=0.01cm` and a half-length `dZ=1cm`:. ``` {.cpp}; TGeoTube *tube = new TGeoTube(""wire_tube"",0,0.01,1);; ```. One may omit the name for the shape `wire_tube,` if no retrieving by; name is further needed during geometry building. Different volumes; having different names and materials can share the same shape. Now let's make the volume for our wire:. ``` {.cpp}; TGeoVolume *wire_co = new TGeoVolume(""WIRE_CO"",tube,; ptrCOPPER); //(*); ```. **(\*)** Do not bother to delete the media, shapes or volumes that you; have created since all will be automatically cleaned on exit by the; manager class. If we would have taken a look inside `TGeoManager::MakeTube()` method,; we would have been able to create our wire with a single line:. ``` {.cpp}; TGeoVolume *wire_co = gGeoManager->MakeTube(""WIRE_CO"",pt",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:72978,simpl,simple,72978,documentation/users-guide/Geometry.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md,1,['simpl'],['simple']
Usability,"sequence of convergent; operations where the code does not care about the exact set of threads with; which it is executed, but only that the set of threads is the same for all the; operations within the sequence. (If a subset of the convergent operations in the; sequence have additional, non-uniform control dependencies, then this is not; possible. However, the code may still require that the sets of threads are; logically consistent with the conditions of those control dependencies.) In this; case, :ref:`llvm.experimental.convergence.anchor; <llvm.experimental.convergence.anchor>` can be used to express the desired; semantics. The following example function could be part of a hypothetical ""append buffer""; implementation, where threads conditionally write fixed-sized records; contiguously into a global buffer. The function ``@reserveSpaceInBuffer``; returns the index into the buffer at which the calling thread should store its; data. This could be achieved by using a simple atomic operation in every thread to; bump an allocation counter. However, the following implementation can be more performant on some hardware,; because it uses only a single atomic operation for an entire group of threads.; To do this, it first determines the total size of the group, which will be the; operand to the atomic operation, and then later broadcasts the result of the; atomic operation to all threads of the group, so that each thread can compute; its individual position in the buffer:. .. code-block:: llvm. define i32 @reserveSpaceInBuffer() { ; NOTE: _not_ a convergent function!; entry:; %anchor = call token @llvm.experimental.convergence.anchor(). %ballot = call i64 @subgroupBallot(i1 true) [ ""convergencectrl""(token %anchor) ]; %numThreads.p = call i64 @llvm.ctpop.i64(i64 %ballot); %numThreads = trunc i64 %numThreads.p to i32. %absoluteThreadIdx = call i32 @getSubgroupLocalInvocationId(); %absoluteThreadIdx.ext = zext i32 %absoluteThreadIdx to i64; %mask.p = shl i64 1, %absoluteThrea",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ConvergentOperations.rst:12445,simpl,simple,12445,interpreter/llvm-project/llvm/docs/ConvergentOperations.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ConvergentOperations.rst,1,['simpl'],['simple']
Usability,"sers are the portion of the CommandLine library; that turns string input from the user into a particular parsed data type,; validating the input in the process. There are two ways to use a new parser:. #. Specialize the `cl::parser`_ template for your custom data type. This approach has the advantage that users of your custom data type will; automatically use your custom parser whenever they define an option with a; value type of your data type. The disadvantage of this approach is that it; doesn't work if your fundamental data type is something that is already; supported. #. Write an independent class, using it explicitly from options that need it. This approach works well in situations where you would line to parse an; option using special syntax for a not-very-special data-type. The drawback; of this approach is that users of your parser have to be aware that they are; using your parser instead of the builtin ones. To guide the discussion, we will discuss a custom parser that accepts file; sizes, specified with an optional unit after the numeric size. For example, we; would like to parse ""102kb"", ""41M"", ""1G"" into the appropriate integer value. In; this case, the underlying data type we want to parse into is '``unsigned``'. We; choose approach #2 above because we don't want to make this the default for all; ``unsigned`` options. To start out, we declare our new ``FileSizeParser`` class:. .. code-block:: c++. struct FileSizeParser : public cl::parser<unsigned> {; // parse - Return true on error.; bool parse(cl::Option &O, StringRef ArgName, const std::string &ArgValue,; unsigned &Val);; };. Our new class inherits from the ``cl::parser`` template class to fill in; the default, boiler plate code for us. We give it the data type that we parse; into, the last argument to the ``parse`` method, so that clients of our custom; parser know what object type to pass in to the parse method. (Here we declare; that we parse into '``unsigned``' variables.). For most purposes, the ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandLine.rst:62892,guid,guide,62892,interpreter/llvm-project/llvm/docs/CommandLine.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandLine.rst,1,['guid'],['guide']
Usability,"ses is all that is necessary here.; The reader should be able to understand how to use interfaces without reading; the code itself. Good things to talk about here are what happens when something unexpected; happens, for instance, does the method return null?. Comment Formatting; ^^^^^^^^^^^^^^^^^^. In general, prefer C++-style comments (``//`` for normal comments, ``///`` for; ``doxygen`` documentation comments). There are a few cases when it is; useful to use C-style (``/* */``) comments however:. #. When writing C code to be compatible with C89. #. When writing a header file that may be ``#include``\d by a C source file. #. When writing a source file that is used by a tool that only accepts C-style; comments. #. When documenting the significance of constants used as actual parameters in; a call. This is most helpful for ``bool`` parameters, or passing ``0`` or; ``nullptr``. The comment should contain the parameter name, which ought to be; meaningful. For example, it's not clear what the parameter means in this call:. .. code-block:: c++. Object.emitName(nullptr);. An in-line C-style comment makes the intent obvious:. .. code-block:: c++. Object.emitName(/*Prefix=*/nullptr);. Commenting out large blocks of code is discouraged, but if you really have to do; this (for documentation purposes or as a suggestion for debug printing), use; ``#if 0`` and ``#endif``. These nest properly and are better behaved in general; than C style comments. Doxygen Use in Documentation Comments; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Use the ``\file`` command to turn the standard file header into a file-level; comment. Include descriptive paragraphs for all public interfaces (public classes,; member and non-member functions). Avoid restating the information that can; be inferred from the API name. The first sentence (or a paragraph beginning; with ``\brief``) is used as an abstract. Try to use a single sentence as the; ``\brief`` adds visual clutter. Put detailed discussion into separate",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodingStandards.rst:10761,clear,clear,10761,interpreter/llvm-project/llvm/docs/CodingStandards.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodingStandards.rst,1,['clear'],['clear']
Usability,"ses; ================================. At the high-level, LLVM code is translated to a machine specific representation; formed out of :raw-html:`<tt>` `MachineFunction`_ :raw-html:`</tt>`,; :raw-html:`<tt>` `MachineBasicBlock`_ :raw-html:`</tt>`, and :raw-html:`<tt>`; `MachineInstr`_ :raw-html:`</tt>` instances (defined in; ``include/llvm/CodeGen``). This representation is completely target agnostic,; representing instructions in their most abstract form: an opcode and a series of; operands. This representation is designed to support both an SSA representation; for machine code, as well as a register allocated, non-SSA form. .. _MachineInstr:. The ``MachineInstr`` class; --------------------------. Target machine instructions are represented as instances of the ``MachineInstr``; class. This class is an extremely abstract way of representing machine; instructions. In particular, it only keeps track of an opcode number and a set; of operands. The opcode number is a simple unsigned integer that only has meaning to a; specific backend. All of the instructions for a target should be defined in the; ``*InstrInfo.td`` file for the target. The opcode enum values are auto-generated; from this description. The ``MachineInstr`` class does not have any information; about how to interpret the instruction (i.e., what the semantics of the; instruction are); for that you must refer to the :raw-html:`<tt>`; `TargetInstrInfo`_ :raw-html:`</tt>` class. The operands of a machine instruction can be of several different types: a; register reference, a constant integer, a basic block reference, etc. In; addition, a machine operand should be marked as a def or a use of the value; (though only registers are allowed to be defs). By convention, the LLVM code generator orders instruction operands so that all; register definitions come before the register uses, even on architectures that; are normally printed in other orders. For example, the SPARC add instruction:; ""``add %i1, %i2, %i3``"" adds ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodeGenerator.rst:16203,simpl,simple,16203,interpreter/llvm-project/llvm/docs/CodeGenerator.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodeGenerator.rst,1,['simpl'],['simple']
Usability,"set the format of dashed lines. - `TStyle::SetOptStat`. - `TStyle::SetPalette` to change the colors palette. - `TStyle::SetTitleOffset`. - `TStyle::SetOptDate(Int_t optdate)` to support several date formats.; If `optdate` is non-null, the current date/time will be printed in; the canvas. The position of the date string can be controlled by:; `optdate = 10*format `+` mode`. - `mode = 1` the date is printed in the bottom/left corner. - `mode = 2` date is printed in the bottom/right corner. - `mode = 3` date is printed in the top/right corner. - `format = 0` (default) date format is like: ""Wed Sep 25 17:10:35; 2002"". - `format = 1` date format is: ""2002-09-25"". - `format = 2` date format is: ""2002-09-25 17:10:35"". ## 3D Viewers. ROOT provides several viewers capable of displaying 3D content:. - the Pad - simple line drawing using **`TPad`** and associated; projection class **`TView`**;. - GL Viewer - high quality and performance viewer(See ""The GL; Viewer"");. - X3D viewer - simple legacy viewer (See ""The X3D Viewer"");. - GL-in-pad - combination of basic GL viewer in **`TPad`**, with no; hardware acceleration. The X3D and GL viewers are created as external windows, associated with; a pad, and displaying the same content as it. Only these external; viewers are detailed here - for Pad (**`TPad`**, **`TView`** classes); you should refer to ""Graphical Containers: Canvas and Pad"" and the class; definitions. All viewers use a common architecture to publish 3D objects to the; viewer - described in ""Common 3D Viewer Architecture"" below. In most; cases, you will **not** need to use this, working instead with a; package, such as the ""The Geometry Package"", which provides; comprehensive, high level functionality to create and place objects into; complex 3D scenes, and uses the viewer architecture internally to show; the result in your chosen viewer. ### Invoking a 3D viewer. A 3D viewer can be created in a script by passing the appropriate option; to `Draw() `when attaching the dra",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md:105316,simpl,simple,105316,documentation/users-guide/Graphics.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md,1,['simpl'],['simple']
Usability,"sg = !strconcat(""Hello "", _msg);; }. def HelloWorld: Hello<""world!""> {}; ```; ```; ------------- Classes -----------------; class Hello<string Hello:_msg = ?> {; string msg = !strconcat(""Hello "", Hello:_msg);; }; ------------- Defs -----------------; def HelloWorld { // Hello; string msg = ""Hello world!"";; }; ```; [Try this example on Compiler Explorer.](https://godbolt.org/z/13xo1P5oz). The internalized records are passed on to various backends, which extract; information from a subset of the records and generate one or more output files. These output files are typically .inc files for C++, but may be any type of file; that the backend developer needs. Resources for learning the language:; * [TableGen Overview](https://llvm.org/docs/TableGen/index.html); * [Programmer's reference guide](https://llvm.org/docs/TableGen/ProgRef.html); * [Tutorial](jupyter/tablegen_tutorial_part_1.ipynb); * [Tools for Learning LLVM TableGen](https://blog.llvm.org/posts/2023-12-07-tools-for-learning-llvm-tablegen/); * [Lessons in TableGen](https://www.youtube.com/watch?v=45gmF77JFBY) (video),; [slides](https://archive.fosdem.org/2019/schedule/event/llvm_tablegen/attachments/slides/3304/export/events/attachments/llvm_tablegen/slides/3304/tablegen.pdf); * [Improving Your TableGen Descriptions](https://www.youtube.com/watch?v=dIEVUlsiktQ); (video), [slides](https://llvm.org/devmtg/2019-10/slides/Absar-ImprovingYourTableGenDescription.pdf). Writing TableGen backends:; * [TableGen Backend Developer's Guide](https://llvm.org/docs/TableGen/BackGuide.html); * [How to write a TableGen backend](https://www.youtube.com/watch?v=UP-LBRbvI_U); (video), [slides](https://llvm.org/devmtg/2021-11/slides/2021-how-to-write-a-tablegen-backend.pdf), also available as a; 	[notebook](jupyter/sql_query_backend.ipynb). TableGen in MLIR:; * [Operation Definition Specification](https://mlir.llvm.org/docs/DefiningDialects/Operations/); * [Defining Dialect Attributes and Types](https://mlir.llvm.org/docs/DefiningDial",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/README.md:1382,learn,learning-llvm-tablegen,1382,interpreter/llvm-project/llvm/utils/TableGen/README.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/README.md,1,['learn'],['learning-llvm-tablegen']
Usability,"shContext object, via the virtual; RooAbsArg::translate() function that implements the translation of a; given RooFit class to minimal C++ code. This is an example of the visitor; pattern. 2. The generated code is processed by a RooFuncWrapper object, which takes care; of just-in-time compiling it with the ROOT interpreter, generating the; gradient code with Clad, and compiling that as well. 3. Since the RooFuncWrapper is implementing a RooAbsArg itself, it can now be; used as a drop-in replacement for the RooAbsArg that was the top node of the; original computation graph, with the added benefit that it can be queried for; the gradient. In summary, the important ingredient to enable AD in RooFit is to support the; **C++ code generation** from RooFit classes. # Steps to enable Code Generation in RooFit classes. There are multiple code generation approaches that can be followed to add Code; Generation support in RooFit classes. **Approach 1:** For very simple cases like `RooRatio`, it may be preferable to; write the entire code in a single string. **Approach 2:** Another approach could be to extract free functions in a; separate header file.; Since Clad prefers the code for models to be within a single translation unit,; in many classes, this has been implemented by moving the computational; aspects of the RooFit class; to free functions in a single header file named [MathFuncs] (and/or; [MathFuncs], where relevant). This approach enables easier debugging; (e.g., you can standalone-compile the generated code with just a few header; files copied outside ROOT). *Refactoring* It is important to refactor the code such that:. - the footprint of the generated code is minimized by referring to existing; functions with the definition known by interpreter (i.e., they are in public; header files). - to reuse common code, both in the generated code, and in the existing; RooAbsReal::evaluate() method (meaning that the refactoring of `evaluate()` is; optional, but it is recommende",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/developers/roofit_ad.md:5456,simpl,simple,5456,roofit/doc/developers/roofit_ad.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/developers/roofit_ad.md,1,['simpl'],['simple']
Usability,"shows the assigned keyboard mnemonic for its choice. A button that; prompts more information for users has the label generally followed by; ellipsis (...). ![](pictures/0300020D.png). As we saw the hot strings ""&Draw"" and ""&Exit"" define the text labels; ""Draw"" and ""Exit"" and keyboard mnemonics `Alt+D`, `Alt+E` for their; selection. The letter D and E appear underlined on the screen. All text; buttons should have a unique shortcut key with the exception of OK and; Cancel. These buttons are usually placed within a window to provide fast access; to frequently used or critical commands. They help in situations where a; command is not available through the menu bar. You already know that a; command string can be passed in the text button via the constructor:. ``` {.cpp}; TGTextButton(const TGWindow *p, const char *s, const char *cmd,; Int_t id, GContext_t norm, FontStruct_t font,; UInt_t options);; ```. A button label can be changed by `SetText(new_label).` There are; important guidelines to be followed about a button label. The text has; to provide a meaningful description of the performed action. The; single-word label should be used whenever possible, only two-three words; for clarity, if necessary. Do not number labels. Always follow all; platform presentation and usage guidelines for standard button; functions. Let's remember a few standard names and definitions of well; known buttons:. ***`OK`*** - any changed information in a window is accepted and the; window is closed;. ***`Cancel`*** - closes window without implementing submitted changes;. ***`Reset `***- resets defaults and cancels any changed information that; has not be submitted;. ***`Apply`*** - any changed information is accepted and again displayed; in the window that remains open;. ***`Close`*** - closes the window;. ***`Help`*** - opens online Help. Below are examples of text buttons. Note the two placement methods. The; first example should be used when there are one to three command; buttons; the sec",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md:56379,guid,guidelines,56379,documentation/users-guide/WritingGUI.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md,1,['guid'],['guidelines']
Usability,"sible different states of; the modeller corresponds to the number of different objects/paths in; the geometry. This has nothing to do with the number of nodes, since; the same node can be found on different branches. In other words,; the number of states corresponds to the number of nodes in the; `expanded geometry tree`. Since unfortunately this expansion from; logical to physical hierarchy cannot be stored on regular basis due; to the large size of the latter, one cannot directly assign state; numbers. If the size of the expansion proves however to be small; enough (less than about 50 million objects), a parallel structure; storing these state indices is built and stored in memory. In such; case each state automatically gets an index that can be retrieved; after any state initialization. These indices can prove to be quite; useful for being able to keep track of the navigation history and; force certain states. Let's illustrate how this works with a simple; example:; - Suppose we have a simple geometry with a volume B positioned twice; inside a container A. Then A is positioned twice in a top container; T. The complete list of logical nodes is: `T_1`, `A_1`, `A_2`,; `B_1`, `B_2`. On the other hand we will have more states than; logical nodes:; - `/T_1`- 1 state at level = 0; - `/T_1/A_1,/T_1/A_2`- 2 states at level = 1; - `/T_1/A_1/B_1,/T_1/A_1/B_2,/T_1/A_2/B_1,/T_1/A_2/B_2` - 4 states at; level = 2; - All these states will get automatic numbers, starting with 0; corresponding to the top-level state and ending with an integer; corresponding to Ntotal\_states-1. The mapping from a given logical; node to a state number is generally not possible, as for the node; B\_1 that appears as current node for 2 different states. The; numbering order of states is therefore not important, but it can be; used as in the following lines:. ``` {.cpp}; gGeoManager->InitTrack(pt,dir); // anything to initialize a state; Int_t istate = gGeoManager->GetCurrentNodeId(); // in fact state I",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:110150,simpl,simple,110150,documentation/users-guide/Geometry.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md,2,['simpl'],['simple']
Usability,"sible different states of; the modeller corresponds to the number of different objects/paths in; the geometry. This has nothing to do with the number of nodes, since; the same node can be found on different branches. In other words,; the number of states corresponds to the number of nodes in the; `expanded geometry tree`. Since unfortunately this expansion from; logical to physical hierarchy cannot be stored on regular basis due; to the large size of the latter, one cannot directly assign state; numbers. If the size of the expansion proves however to be small; enough (less than about 50 million objects), a parallel structure; storing these state indices is built and stored in memory. In such; case each state automatically gets an index that can be retrieved; after any state initialization. These indices can prove to be quite; useful for being able to keep track of the navigation history and; force certain states. Let's illustrate how this works with a simple; example:; - Suppose we have a simple geometry with a volume B positioned twice; inside a container A. Then A is positioned twice in a top container; T. The complete list of logical nodes is: `T_1`, `A_1`, `A_2`,; `B_1`, `B_2`. On the other hand we will have more states than; logical nodes:; - `/T_1`- 1 state at level = 0; - `/T_1/A_1,/T_1/A_2`- 2 states at level = 1; - `/T_1/A_1/B_1,/T_1/A_1/B_2,/T_1/A_2/B_1,/T_1/A_2/B_2` - 4 states at; level = 2; - All these states will get automatic numbers, starting with 0; corresponding to the top-level state and ending with an integer; corresponding to Ntotal\_states-1. The mapping from a given logical; node to a state number is generally not possible, as for the node; B\_1 that appears as current node for 2 different states. The; numbering order of states is therefore not important, but it can be; used as in the following lines:. ~~~{.cpp}; gGeoManager->InitTrack(pt,dir); // anything to initialize a state; Int_t istate = gGeoManager->GetCurrentNodeId(); // in fact state Id",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md:70553,simpl,simple,70553,geom/geom/doc/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md,2,['simpl'],['simple']
Usability,"side of a loop, so how can such a phi ""close""; the value inside the loop since it uses it outside of it ? First of all,; for phi nodes, as; `mentioned in the LangRef <https://llvm.org/docs/LangRef.html#id311>`_:; ""the use of each incoming value is deemed to occur on the edge from the; corresponding predecessor block to the current block"". Now, an; edge to an exit block is considered outside of the loop because; if we take that edge, it leads us clearly out of the loop. However, an edge doesn't actually contain any IR, so in source code,; we have to choose a convention of whether the use happens in; the current block or in the respective predecessor. For LCSSA's purpose,; we consider the use happens in the latter (so as to consider the; use inside) [#point-of-use-phis]_. The major benefit of LCSSA is that it makes many other loop optimizations; simpler. First of all, a simple observation is that if one needs to see all; the outside users, they can just iterate over all the (loop closing); PHI nodes in the exit blocks (the alternative would be to; scan the def-use chain [#def-use-chain]_ of all instructions in the loop). Then, consider for example; :ref:`simple-loop-unswitch <passes-simple-loop-unswitch>` ing the loop above.; Because it is in LCSSA form, we know that any value defined inside of; the loop will be used either only inside the loop or in a loop closing; PHI node. In this case, the only loop closing PHI node is X4.; This means that we can just copy the loop and change the X4; accordingly, like so:. .. code-block:: C. c = ...;; if (c) {; for (...) {; if (true); X1 = ...; else; X2 = ...; X3 = phi(X1, X2);; }; } else {; for (...) {; if (false); X1' = ...; else; X2' = ...; X3' = phi(X1', X2');; }; }; X4 = phi(X3, X3'). Now, all uses of X4 will get the updated value (in general,; if a loop is in LCSSA form, in any loop transformation,; we only need to update the loop closing PHI nodes for the changes; to take effect). If we did not have Loop Closed SSA form, it",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LoopTerminology.rst:12962,simpl,simple,12962,interpreter/llvm-project/llvm/docs/LoopTerminology.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LoopTerminology.rst,1,['simpl'],['simple']
Usability,"sing different portions of; LLVM. Even in this situation using *BUILD_SHARED_LIBS* is not supported. If you; want to distribute LLVM as a shared library for use in a tool, the recommended; method is using *LLVM_BUILD_LLVM_DYLIB*, and you can use *LLVM_DYLIB_COMPONENTS*; to configure which LLVM components are part of libLLVM.; Note: *LLVM_BUILD_LLVM_DYLIB* is not available on Windows. Options for Optimizing LLVM; ===========================. There are four main build optimizations that our CMake build system supports.; When performing a bootstrap build it is not beneficial to do anything other than; setting *CMAKE_BUILD_TYPE* to ``Release`` for the stage-1 compiler. This is; because the more intensive optimizations are expensive to perform and the; stage-1 compiler is thrown away. All of the further options described should be; set on the stage-2 compiler either using a CMake cache file, or by prefixing the; option with *BOOTSTRAP_*. The first and simplest to use is the compiler optimization level by setting the; *CMAKE_BUILD_TYPE* option. The main values of interest are ``Release`` or; ``RelWithDebInfo``. By default the ``Release`` option uses the ``-O3``; optimization level, and ``RelWithDebInfo`` uses ``-O2``. If you want to generate; debug information and use ``-O3`` you can override the; *CMAKE_<LANG>_FLAGS_RELWITHDEBINFO* option for C and CXX.; DistributionExample.cmake does this. Another easy to use option is Link-Time-Optimization. You can set the; *LLVM_ENABLE_LTO* option on your stage-2 build to ``Thin`` or ``Full`` to enable; building LLVM with LTO. These options will significantly increase link time of; the binaries in the distribution, but it will create much faster binaries. This; option should not be used if your distribution includes static archives, as the; objects inside the archive will be LLVM bitcode, which is not portable. The :doc:`AdvancedBuilds` documentation describes the built-in tooling for; generating LLVM profiling information to drive P",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/BuildingADistribution.rst:8050,simpl,simplest,8050,interpreter/llvm-project/llvm/docs/BuildingADistribution.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/BuildingADistribution.rst,1,['simpl'],['simplest']
Usability,"sing the newer, much faster,; gold linker. In addition we added the linker option ""-Wl,--no-undefined"",; so you will get an error if symbols are unresolved.; Explicit linking is required by newer distributions, like Ubuntu 11.10,; that require all dependent shared libs to be specified when linking. They; also have default options set to dead strip shared libs that don't resolve; any symbols (equivalent to the MacOS X build changes described above). Core Libraries; TClonesArray. Introduce TClonesArray::ConstructedAt which; always returns an already constructed object. If the slot is being used for the; first time, it calls the default constructor otherwise it returns the object as; is (unless a string is passed as the 2nd argument to the function in which case,; it also calls Clear(second_argument) on the object).; This allows to replace code like:. for (int i = 0; i < ev->Ntracks; i++) {; new(a[i]) TTrack(x,y,z,...);; ...; ...; }; ...; a.Delete(); // or a.Clear(""C""). with the simpler and more efficient:. for (int i = 0; i < ev->Ntracks; i++) {; TTrack *track = (TTrack*)a.ConstructedAt(i);; track->Set(x,y,z,....);; ...; ...; }; ...; a.Clear();. even in case where the TTrack class allocates memory. TClonesArray: update ExpandCreateFast to also reset the non-used slots; so that calling Clear (which does too much) is no longer necessary; when using ExpandCreateFast. New Thread Pool class. A first version of TThreadPool class has been introduced.; This class implements a Thread Pool pattern.; So far it supports only one type of queue - FIFO. Thread library. Reduces risk of internal dead lock by using a private internal lock to protect the internals of TThread, rather than using TThread::Lock. New header TThreadSlots.h to centralize and formalize the use of the TThread local memory slots amongst the ROOT packages. Global Variables. The global values gPad, gVirtualX, gInterpreter, gDirectory and gFile; are now all accessed via a static function of their respective class. T",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/doc/v532/index.html:2039,simpl,simpler,2039,core/doc/v532/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/doc/v532/index.html,1,['simpl'],['simpler']
Usability,"sion being browsed.; A set of scripts for quick interaction with a dataset; manager via PROOF are available under $ROOTSYS/etc/proof/utils/pq2 .; The scripts are prefixed; pq2 (proof; quick query - or; proof-dq2); and allow to {browse, register, remove, verify} datasets on a given; PROOF master. See $ROOTSYS/etc/proof/utils/pq2/README for more; information. Improvements. Enable by default schema evolution in TMessage; can be; disabled setting 'Proof.SchemaEvolution:; 0' .; Extend the functionality of the dataset API to obtaine; information on per-server base; add also two new methods:. TProof::SetDataSetTreeName(<dataset>,<treename>):; set/change the default tree name in the TFileCollection;; TProof::ExistsDataSet(<dataset>):; check; by-name the availability of a given dataset;. In ProofBench, . Load the macro before executing it. This allows to; circumvent a problem recently fixed giving less dependency on the; server version.; In make_dset.C, simplification of the body and of the; signature, eliminating one redundant argument. In TProofOutputFile, improve flexibility in defining the; URL for the local files server. The ""LOCALDATASERVER"" env is tested,; which can defined with placeholders via the xpd.putenv directive in the; xrootd/xproofd config files.; Improving parsing of lines with memory info.; This solves occasional crashes while generating the memory; plots.; In TProofMgr::GetSessionLogs:. add the possibility to postpone the retrieval of the; logs files when the TProofLog object is created. This improved; functionality is exploited in the log window.; add decoding of the session starting time and full; information about the master URL. Enable new xrootd configuration options, including the; possibility to set the compiler and linker; Cleanup of the TProofMgr functions DetachSession and; ShutdownSession, and better handling of the internal list registration,; to fix potential segvs when reopening a PROOF session inside the same; ROOT session.; Optimize the wa",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/doc/v524/index.html:5599,simpl,simplification,5599,proof/doc/v524/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/doc/v524/index.html,1,['simpl'],['simplification']
Usability,"sis to provide high-level dependence; information about memory-using instructions. This will tell you which store; feeds into a load, for example. It uses caching and other techniques to be; efficient, and is used by Dead Store Elimination, GVN, and memcpy optimizations. .. _AliasSetTracker:. Using the ``AliasSetTracker`` class; -----------------------------------. Many transformations need information about alias **sets** that are active in; some scope, rather than information about pairwise aliasing. The; `AliasSetTracker <https://llvm.org/doxygen/classllvm_1_1AliasSetTracker.html>`__; class is used to efficiently build these Alias Sets from the pairwise alias; analysis information provided by the ``AliasAnalysis`` interface. First you initialize the AliasSetTracker by using the ""``add``"" methods to add; information about various potentially aliasing instructions in the scope you are; interested in. Once all of the alias sets are completed, your pass should; simply iterate through the constructed alias sets, using the ``AliasSetTracker``; ``begin()``/``end()`` methods. The ``AliasSet``\s formed by the ``AliasSetTracker`` are guaranteed to be; disjoint, calculate mod/ref information and volatility for the set, and keep; track of whether or not all of the pointers in the set are Must aliases. The; AliasSetTracker also makes sure that sets are properly folded due to call; instructions, and can provide a list of pointers in each set. As an example user of this, the `Loop Invariant Code Motion; <doxygen/structLICM.html>`_ pass uses ``AliasSetTracker``\s to calculate alias; sets for each loop nest. If an ``AliasSet`` in a loop is not modified, then all; load instructions from that set may be hoisted out of the loop. If any alias; sets are stored to **and** are must alias sets, then the stores may be sunk; to outside of the loop, promoting the memory location to a register for the; duration of the loop nest. Both of these transformations only apply if the; pointer argumen",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst:20520,simpl,simply,20520,interpreter/llvm-project/llvm/docs/AliasAnalysis.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst,1,['simpl'],['simply']
Usability,"sive; Not resolved. 294; NAD; Can static_cast drop exception specifications?; No. 295; CD1; cv-qualifiers on function types; Clang 3.7. 296; CD1; Can conversion functions be static?; Yes. 297; NAD; Which template does an explicit specialization specialize?; Unknown. 298; CD1; T::x when T is cv-qualified; Clang 3.1. 299; CD1; Conversion on array bound expression in new; Clang 2.8 (C++11 onwards). 300; CD1; References to functions in template argument deduction; Yes. 301; CD1; Syntax for template-name; Clang 3.5. 302; CD1; Value-initialization and generation of default constructor; Clang 3.0. 303; NAD; Integral promotions on bit-fields; N/A. 304; TC1; Value-initialization of a reference; Clang 2.9. 305; CD1; Name lookup in destructor call; No. 306; CD1; Ambiguity by class name injection; Duplicate of 39. 307; NAD; Initialization of a virtual base class subobject; N/A. 308; NAD; Catching exceptions with ambiguous base classes; Clang 3.7. 309; CD1; Linkage of entities whose names are not simply identifiers, in introduction; Duplicate of 485. 310; open; Can function templates differing only in parameter cv-qualifiers be overloaded?; Not resolved. 311; NAD; Using qualified name to reopen nested namespace; Clang 3.0. 312; CD3; “use” of invalid pointer value not defined; Duplicate of 616. 313; dup; Class with single conversion function to integral as array size in new; Duplicate of 299 (C++11 onwards). 314; C++17; template in base class specifier; No. 315; NAD; Is call of static member function through null pointer undefined?; N/A. 316; NAD; Injected-class-name of template used as template template parameter; Superseded by 1004. 317; CD1; Can a function be declared inline after it has been called?; Clang 3.5. 318; CD1; struct A::A should not name the constructor of A; Superseded by 1310. 319; CD1; Use of names without linkage in declaring entities with linkage; No. 320; CD1; Question on copy constructor elision example; Yes. 321; dup; Associated classes and namespaces for ar",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:20395,simpl,simply,20395,interpreter/llvm-project/clang/www/cxx_dr_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html,1,['simpl'],['simply']
Usability,"so compare them. How to implement cmpValues?; ^^^^^^^^^^^^^^^^^^^^^^^^^^^; *Association* is a case of equality for us. We just treat such values as equal,; but, in general, we need to implement antisymmetric relation. As mentioned; above, to understand what is *less*, we can use order in which we; meet values. If both values have the same order in a function (met at the same; time), we then treat values as *associated*. Otherwise – it depends on who was; first. Every time we run the top-level compare method, we initialize two identical; maps (one for the left side, another one for the right side):. ``map<Value, int> sn_mapL, sn_mapR;``. The key of the map is the *Value* itself, the *value* – is its order (call it; *serial number*). To add value *V* we need to perform the next procedure:. ``sn_map.insert(std::make_pair(V, sn_map.size()));``. For the first *Value*, map will return *0*, for the second *Value* map will; return *1*, and so on. We can then check whether left and right values met at the same time with; a simple comparison:. ``cmpNumbers(sn_mapL[Left], sn_mapR[Right]);``. Of course, we can combine insertion and comparison:. .. code-block:: c++. std::pair<iterator, bool>; LeftRes = sn_mapL.insert(std::make_pair(Left, sn_mapL.size())), RightRes; = sn_mapR.insert(std::make_pair(Right, sn_mapR.size()));; return cmpNumbers(LeftRes.first->second, RightRes.first->second);. Let's look, how whole method could be implemented. 1. We have to start with the bad news. Consider function self and; cross-referencing cases:. .. code-block:: c++. // self-reference unsigned fact0(unsigned n) { return n > 1 ? n; * fact0(n-1) : 1; } unsigned fact1(unsigned n) { return n > 1 ? n *; fact1(n-1) : 1; }. // cross-reference unsigned ping(unsigned n) { return n!= 0 ? pong(n-1) : 0;; } unsigned pong(unsigned n) { return n!= 0 ? ping(n-1) : 0; }. .. This comparison has been implemented in initial *MergeFunctions* pass; version. But, unfortunately, it is not transitive. And this is the onl",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MergeFunctions.rst:19288,simpl,simple,19288,interpreter/llvm-project/llvm/docs/MergeFunctions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MergeFunctions.rst,1,['simpl'],['simple']
Usability,"so do not be concerned if a; commit does not immediately appear in the archives. If you have recently been granted commit access, these policies apply:. #. You are granted *commit-after-approval* to all parts of LLVM. For; information on how to get approval for a patch, please see :doc:`CodeReview`.; When approved, you may commit it yourself. #. You are allowed to commit patches without approval which you think are; obvious. This is clearly a subjective decision --- we simply expect you to; use good judgement. Examples include: fixing build breakage, reverting; obviously broken patches, documentation/comment changes, any other minor; changes. Avoid committing formatting- or whitespace-only changes outside of; code you plan to make subsequent changes to. Also, try to separate; formatting or whitespace changes from functional changes, either by; correcting the format first (ideally) or afterward. Such changes should be; highly localized and the commit message should clearly state that the commit; is not intended to change functionality, usually by stating it is; :ref:`NFC <nfc>`. #. You are allowed to commit patches without approval to those portions of LLVM; that you have contributed or maintain (i.e., have been assigned; responsibility for), with the proviso that such commits must not break the; build. This is a ""trust but verify"" policy, and commits of this nature are; reviewed after they are committed. #. Multiple violations of these policies or a single egregious violation may; cause commit access to be revoked. In any case, your changes are still subject to `code review`_ (either before or; after they are committed, depending on the nature of the change). You are; encouraged to review other peoples' patches as well, but you aren't required; to do so. .. _discuss the change/gather consensus:. Making a Major Change; ---------------------. When a developer begins a major new project with the aim of contributing it back; to LLVM, they should inform the community with",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/DeveloperPolicy.rst:25048,clear,clearly,25048,interpreter/llvm-project/llvm/docs/DeveloperPolicy.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/DeveloperPolicy.rst,1,['clear'],['clearly']
Usability,"software engineering; principles. For example, the code uses global variables; pervasively, doesn't use; `visitors <http://en.wikipedia.org/wiki/Visitor_pattern>`_, etc... but; instead keeps things simple and focuses on the topics at hand. This tutorial is structured into chapters covering individual topics,; allowing you to skip ahead as you wish:. - `Chapter #1: Kaleidoscope language and Lexer <LangImpl01.html>`_ -; This shows where we are; going and the basic functionality that we want to build. A lexer; is also the first part of building a parser for a language, and we; use a simple C++ lexer which is easy to understand.; - `Chapter #2: Implementing a Parser and AST <LangImpl02.html>`_ -; With the lexer in place, we can talk about parsing techniques and; basic AST construction. This tutorial describes recursive descent; parsing and operator precedence parsing.; - `Chapter #3: Code generation to LLVM IR <LangImpl03.html>`_ - with; the AST ready, we show how easy it is to generate LLVM IR, and show; a simple way to incorporate LLVM into your project.; - `Chapter #4: Adding JIT and Optimizer Support <LangImpl04.html>`_ -; One great thing about LLVM is its support for JIT compilation, so; we'll dive right into it and show you the 3 lines it takes to add JIT; support. Later chapters show how to generate .o files.; - `Chapter #5: Extending the Language: Control Flow <LangImpl05.html>`_ - With; the basic language up and running, we show how to extend; it with control flow operations ('if' statement and a 'for' loop). This; gives us a chance to talk about SSA construction and control; flow.; - `Chapter #6: Extending the Language: User-defined Operators; <LangImpl06.html>`_ - This chapter extends the language to let; users define arbitrary unary and binary operators - with assignable; precedence! This allows us to build a significant piece of the; ""language"" as library routines.; - `Chapter #7: Extending the Language: Mutable Variables; <LangImpl07.html>`_ - This chapter",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/index.rst:2278,simpl,simple,2278,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/index.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/index.rst,1,['simpl'],['simple']
Usability,"son.gz&layout=3x3>; 18. Also for online server process url options like 'item', 'items', 'layout'; 19. Possibility to generate URL, which reproduces opened page with layout and drawn items. ### August 2014; 1. All communication between server and browser done with JSON format.; 2. Fix small error in dtree.js - one should always set; last sibling (_ls) property while tree can be dynamically changed.; 3. In JSRootCore.js provide central function, which handles different kinds; of XMLHttpRequest. Use only async requests, also when getting file header.; 4. Fully reorganize data management in file/tree/directory/collection hierarchical; display. Now complete description collected in HPainter class and decoupled from; visualization, performed with dTree.js.; 5. Remove all global variables from the code.; 6. Automatic scripts/style loading handled via JSROOT.loadScript() function.; One can specify arbitrary scripts list, which asynchronously loaded by browser.; 7. Method to build simple GUI changed and more simplified :). The example in index.htm.; While loadScript and AssertPrerequisites functions moved to JSROOT, one; can easily build many different kinds of GUIs, reusing provided JSRootCore.js functions.; 8. In example.htm also use AssertPrerequisites to load necessary scripts.; This helps to keep code up-to-date even by big changes in JavaScript code.; 9. Provide monitoring of online THttpServer with similar interface as for ROOT files.; 10. Fix several errors in TKey Streamer, use member names as in ROOT itself.; 11. Keep the only version identifier JSROOT.version for JS code; 12. One can specify in JSROOT.AssertPrerequisites functionality which is required.; One could specify '2d', 'io' (default) or '3d'.; 13. Use new AssertPrerequisites functionality to load only required functionality.; 14. When displaying single element, one could specify draw options and monitor property like:; <http://localhost:8080/Files/job1.root/hpxpy/draw.htm?opt=col&monitor=2000>; Such link ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/changes.md:74549,simpl,simple,74549,js/changes.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/changes.md,2,['simpl'],"['simple', 'simplified']"
Usability,"specialization A<T,T*,I> but not A<int,int,1>. Matcher<Decl>classTemplateSpecializationDeclMatcher<ClassTemplateSpecializationDecl>...; Matches C++ class template specializations. Given; template<typename T> class A {};; template<> class A<double> {};; A<int> a;; classTemplateSpecializationDecl(); matches the specializations A<int> and A<double>. Matcher<Decl>conceptDeclMatcher<ConceptDecl>...; Matches concept declarations. Example matches integral; template<typename T>; concept integral = std::is_integral_v<T>;. Matcher<Decl>cxxConstructorDeclMatcher<CXXConstructorDecl>...; Matches C++ constructor declarations. Example matches Foo::Foo() and Foo::Foo(int); class Foo {; public:; Foo();; Foo(int);; int DoSomething();; };. Matcher<Decl>cxxConversionDeclMatcher<CXXConversionDecl>...; Matches conversion operator declarations. Example matches the operator.; class X { operator int() const; };. Matcher<Decl>cxxDeductionGuideDeclMatcher<CXXDeductionGuideDecl>...; Matches user-defined and implicitly generated deduction guide. Example matches the deduction guide.; template<typename T>; class X { X(int) };; X(int) -> X<int>;. Matcher<Decl>cxxDestructorDeclMatcher<CXXDestructorDecl>...; Matches explicit C++ destructor declarations. Example matches Foo::~Foo(); class Foo {; public:; virtual ~Foo();; };. Matcher<Decl>cxxMethodDeclMatcher<CXXMethodDecl>...; Matches method declarations. Example matches y; class X { void y(); };. Matcher<Decl>cxxRecordDeclMatcher<CXXRecordDecl>...; Matches C++ class declarations. Example matches X, Z; class X;; template<class T> class Z {};. Matcher<Decl>declMatcher<Decl>...; Matches declarations. Examples matches X, C, and the friend declaration inside C;; void X();; class C {; friend X;; };. Matcher<Decl>declaratorDeclMatcher<DeclaratorDecl>...; Matches declarator declarations (field, variable, function; and non-type template parameter declarations). Given; class X { int y; };; declaratorDecl(); matches int y. Matcher<Decl>decompositionDeclMatcher",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:11578,guid,guide,11578,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,1,['guid'],['guide']
Usability,"spend.retcon`` after resuming in any way. Coroutine Transformation Passes; ===============================; CoroEarly; ---------; The pass CoroEarly lowers coroutine intrinsics that hide the details of the; structure of the coroutine frame, but, otherwise not needed to be preserved to; help later coroutine passes. This pass lowers `coro.frame`_, `coro.done`_,; and `coro.promise`_ intrinsics. .. _CoroSplit:. CoroSplit; ---------; The pass CoroSplit builds coroutine frame and outlines resume and destroy parts; into separate functions. CoroElide; ---------; The pass CoroElide examines if the inlined coroutine is eligible for heap; allocation elision optimization. If so, it replaces; `coro.begin` intrinsic with an address of a coroutine frame placed on its caller; and replaces `coro.alloc` and `coro.free` intrinsics with `false` and `null`; respectively to remove the deallocation code.; This pass also replaces `coro.resume` and `coro.destroy` intrinsics with direct; calls to resume and destroy functions for a particular coroutine where possible. CoroCleanup; -----------; This pass runs late to lower all coroutine related intrinsics not replaced by; earlier passes. Attributes; ==========. coro_only_destroy_when_complete; -------------------------------. When the coroutine are marked with coro_only_destroy_when_complete, it indicates; the coroutine must reach the final suspend point when it get destroyed. This attribute only works for switched-resume coroutines now. Metadata; ========. '``coro.outside.frame``' Metadata; ---------------------------------. ``coro.outside.frame`` metadata may be attached to an alloca instruction to; to signify that it shouldn't be promoted to the coroutine frame, useful for; filtering allocas out by the frontend when emitting internal control mechanisms.; Additionally, this metadata is only used as a flag, so the associated; node must be empty. .. code-block:: text. %__coro_gro = alloca %struct.GroType, align 1, !coro.outside.frame !0. ...; !",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst:57170,resume,resume,57170,interpreter/llvm-project/llvm/docs/Coroutines.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst,1,['resume'],['resume']
Usability,"sponding value. Also,; if the string ends with '`!`', output neurons are set up for; classification, i.e. with a sigmoid (1 neuron) or softmax (more; neurons) activation function. Many questions on the good usage of neural network, including rules of; dumb to determine the best network topology are addressed at; <ftp://ftp.sas.com/pub/neural/FAQ.html>. ``` {.cpp}; // a simple network: 2 inputs, 10 hidden and 1 normalized; // output neuron; TMultiLayerPerceptron network(""r,z:10:@Br"",tree);; ```. Expressions are evaluated as for `TTree::Draw()`. Input and outputs; are taken from the **`TTree`** associated with the network. This; **`TTree`** can be given as argument of the constructor or defined; later with `TMultiLayerPerceptron::SetData()`. Events can also be; weighted. The weight expression can be given in the constructor or set; later with the method `SetWeight()` of the class; **`TMultiLayerPerceptron`**. Two datasets must be defined before; learning the network: a training dataset that is used when minimizing; the error, and a test dataset that will avoid bias. Those two datasets; can be built aside and then given to the network, or can be built from; a standard expression. By default, half of the events are put in both; datasets. ``` {.cpp}; // a more complex 4:8:1 network; // the ptsumf branch is used as weigh;; // default event lists are explicit; TMultiLayerPerceptron network(""m,pt,acol,acopl:8:type"",""pt"",tree,; ""Entry$%2"",""Entry$/2"");; ```. The method `TMultiLayerPerceptron::SetLearningMethod()` defines the; learning method. Learning methods are:. ```; TMultiLayerPerceptron::kStochastic,; TMultiLayerPerceptron::kBatch,; TMultiLayerPerceptron::kSteepestDescent,; TMultiLayerPerceptron::kRibierePolak,; TMultiLayerPerceptron::kFletcherReeves,; TMultiLayerPerceptron::kBFGS // default; ```. The training can start with; `TMultiLayerPerceptron::Train(Int_t nepoch,Option_t* options).` The; first argument is the number of epochs while option is a string that; can cont",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:75668,learn,learning,75668,documentation/users-guide/FittingHistograms.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md,1,['learn'],['learning']
Usability,"ss values and so forth, without the logging code doing any real work to; convert those values to human-readable form. Instead, logging text uses the; markup format defined here to identify pieces of information that should be; converted to human-readable form after the fact. As with other markup formats,; the expectation is that most of the text will be displayed as is, while the; markup elements will be replaced with expanded text, or converted into active UI; elements, that present more details in symbolic form. This means there is no need for symbol tables, DWARF debugging sections, or; similar information to be directly accessible at runtime. There is also no need; at runtime for any logic intended to compute human-readable presentation of; information, such as C++ symbol demangling. Instead, logging must include markup; elements that give the contextual information necessary to make sense of the raw; data, such as memory layout details. This format identifies markup elements with a syntax that is both simple and; distinctive. It's simple enough to be matched and parsed with straightforward; code. It's distinctive enough that character sequences that look like the start; or end of a markup element should rarely if ever appear incidentally in logging; text. It's specifically intended not to require sanitizing plain text, such as; the HTML/XML requirement to replace ``<`` with ``&lt;`` and the like. :doc:`llvm-symbolizer <CommandGuide/llvm-symbolizer>` includes a symbolizing; filter via its ``--filter-markup`` option. Also, LLVM utilites emit stack; traces as markup when the ``LLVM_ENABLE_SYMBOLIZER_MARKUP`` environment; variable is set. Scope and assumptions; =====================. A symbolizing filter implementation will be independent both of the target; operating system and machine architecture where the logs are generated and of; the host operating system and machine architecture where the filter runs. This format assumes that the symbolizing filter processes ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SymbolizerMarkupFormat.rst:1320,simpl,simple,1320,interpreter/llvm-project/llvm/docs/SymbolizerMarkupFormat.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SymbolizerMarkupFormat.rst,1,['simpl'],['simple']
Usability,"ss, it works for all projectable classes. TEveVector, TEveVector4 and TEveVector2 are now typedefs to float; specialization of corresponding templates. Double versions use 'D' as; postfix, 'F' postfix is another alias for float versions, e.g.:; typedef TEveVectorT<Float_t> TEveVector;; typedef TEveVectorT<Float_t> TEveVectorF;; typedef TEveVectorT<Double_t> TEveVectorD;. All projectable classes now take into account their transformation; matrix. The projected versions are still stored in global; coordinates.; TEveShape -- a new abstract base-class for 2D/3D shapes that; require fill / outline color, line-width and various flags; controlling the area / outline drawing.; TEveGeoShape and projected classes: subclass from TEveShape. Add; support for TGeoCompositeShapes. In 2D projected class; (TEvePolygonSetProjected) improve detection of duplicate polygons; and add support for detection of minimal-outline (triggered via; Bool_t TEveShape::fMiniOutline).; TEveBox: New class to draw a simple cuboid with minimal memory; usage. It is projectable.; TEveBoxSet: for box-type kBT_FreeBox assure proper face; orientation at registration time and calculate normals when; rendering. TEveJetCone is now projectable.; Several performance improvements when dealing with large; collections of EVE objects. Profiled with simulated heavy-ion; data. In particular, for destruction of self-contained sub-hierarchies of objects; one can use TEveElement::Annihilate() and; TEveElement::AnnihilateElements(). See class docs for constraints. Minor changes. Add support for projecting a new child (all children) of an; element after the element and its old children have already been; projected. This is provided by the following virtual functions in; TEveElement:; void ProjectChild(TEveElement* el, Bool_t sameDepth=kTRUE);; void ProjectAllChildren(Bool_t same_depth=kTRUE);. Several improvements in drawing of TEveCalo axes and labels.; TEveTrackPropagator. Fix some issues with Runge-Kutta track; propagato",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/doc/v528/index.html:5446,simpl,simple,5446,graf3d/doc/v528/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/doc/v528/index.html,1,['simpl'],['simple']
Usability,"ssible to launch ROOT with some command line options, as shown; below:. ```; % root -?; Usage: root [-l] [-b] [-n] [-q] [dir] [[file:]data.root]; [file1.C ... fileN.C]; Options:; -b : run in batch mode without graphics; -n : do not execute logon and logoff macros as specified in .rootrc; -q : exit after processing command line macro files; -l : do not show splash screen; -x : exit on exception; dir : if dir is a valid directory cd to it before executing. -? : print usage; -h : print usage; --help : print usage; -config : print ./configure options; ```. - -b ROOT session runs in batch mode, without graphics display. This; mode is useful in case one does not want to set the DISPLAY or; cannot do it for some reason. - -n usually, launching a ROOT session will execute a logon script; and quitting will execute a logoff script. This option prevents; the execution of these two scripts. - it is also possible to execute a script without entering a ROOT; session. One simply adds the name of the script(s) after the ROOT; command. Be warned: after finishing the execution of the script,; ROOT will normally enter a new session. - -q process command line script files and exit. For example if you would like to run a script `myMacro.C` in the; background, redirect the output into a file `myMacro.log`, and exit; after the script execution, use the following syntax:. ```; root -b -q myMacro.C > myMacro.log; ```. If you need to pass a parameter to the script use:. ```; root -b -q 'myMacro.C(3)' > myMacro.log; ```. Be mindful of the quotes, i.e. if you need to pass a string as a; parameter, the syntax is:. ```; root -b -q 'myMacro.C(""text"")' > myMacro.log; ```. You can build a shared library with ACLiC and then use this shared; library on the command line for a quicker execution (i.e. the compiled; speed rather than the interpreted speed). See also ""Cling the C++; Interpreter"". ```; root -b -q myMacro.so > myMacro.log; ```. ROOT has a powerful C/C++ interpreter giving you access to all a",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/GettingStarted.md:3780,simpl,simply,3780,documentation/users-guide/GettingStarted.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/GettingStarted.md,1,['simpl'],['simply']
Usability,"st MatchFinder::MatchResult &Result) {; if (const ForStmt *FS = Result.Nodes.getNodeAs<clang::ForStmt>(""forLoop"")); FS->dump();; }; };. And change ``main()`` to:. .. code-block:: c++. int main(int argc, const char **argv) {; auto ExpectedParser = CommonOptionsParser::create(argc, argv, MyToolCategory);; if (!ExpectedParser) {; // Fail gracefully for unsupported options.; llvm::errs() << ExpectedParser.takeError();; return 1;; }; CommonOptionsParser& OptionsParser = ExpectedParser.get();; ClangTool Tool(OptionsParser.getCompilations(),; OptionsParser.getSourcePathList());. LoopPrinter Printer;; MatchFinder Finder;; Finder.addMatcher(LoopMatcher, &Printer);. return Tool.run(newFrontendActionFactory(&Finder).get());; }. Now, you should be able to recompile and run the code to discover for; loops. Create a new file with a few examples, and test out our new; handiwork:. .. code-block:: console. cd ~/clang-llvm/build/; ninja loop-convert; vim ~/test-files/simple-loops.cc; bin/loop-convert ~/test-files/simple-loops.cc. Step 3.5: More Complicated Matchers; ===================================. Our simple matcher is capable of discovering for loops, but we would; still need to filter out many more ourselves. We can do a good portion; of the remaining work with some cleverly chosen matchers, but first we; need to decide exactly which properties we want to allow. How can we characterize for loops over arrays which would be eligible; for translation to range-based syntax? Range based loops over arrays of; size ``N`` that:. - start at index ``0``; - iterate consecutively; - end at index ``N-1``. We already check for (1), so all we need to add is a check to the loop's; condition to ensure that the loop's index variable is compared against; ``N`` and another check to ensure that the increment step just; increments this same variable. The matcher for (2) is straightforward:; require a pre- or post-increment of the same variable declared in the; init portion. Unfortunately, such a mat",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersTutorial.rst:10472,simpl,simple-loops,10472,interpreter/llvm-project/clang/docs/LibASTMatchersTutorial.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersTutorial.rst,1,['simpl'],['simple-loops']
Usability,"st not suffice, and instead would simply; complicate the picture further because it adds an extra variant in; addition to the one each language provides. Instead, providing a default library version of malloc and free; (and perhaps a malloc_gc with garbage collection instead of free); would make a good implementation available to anyone who wants it. I don't recall all your arguments in favor so let's discuss this again,; and soon. o 'alloca' on the other hand sounds like a good idea, and the; implementation seems fairly language-independent so it doesn't have the; problems with malloc listed above. o About indirect call:; Your option #2 sounded good to me. I'm not sure I understand your; concern about an explicit 'icall' instruction?. o A pair of important synchronization instr'ns to think about:; load-linked; store-conditional. o Other classes of instructions that are valuable for pipeline performance:; conditional-move		 ; predicated instructions. o I believe tail calls are relatively easy to identify; do you know why; .NET has a tailcall instruction?. o I agree that we need a static data space. Otherwise, emulating global; data gets unnecessarily complex. o About explicit parallelism:. We once talked about adding a symbolic thread-id field to each; instruction. (It could be optional so single-threaded codes are; not penalized.) This could map well to multi-threaded architectures; while providing easy ILP for single-threaded onces. But it is probably; too radical an idea to include in a base version of LLVM. Instead, it; could a great topic for a separate study. What is the semantics of the IA64 stop bit?. o And finally, another thought about the syntax for arrays :-). Although this syntax:; 	 array <dimension-list> of <type>; is verbose, it will be used only in the human-readable assembly code so; size should not matter. I think we should consider it because I find it; to be the clearest syntax. It could even make arrays of function; pointers somewhat readable. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HistoricalNotes/2001-02-09-AdveComments.txt:4453,clear,clearest,4453,interpreter/llvm-project/llvm/docs/HistoricalNotes/2001-02-09-AdveComments.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HistoricalNotes/2001-02-09-AdveComments.txt,1,['clear'],['clearest']
Usability,"st; argument to have access to class members of the same instance).; `pthreads` are made for simple C functions and do not know about Thread0; being a member function of a class. Thus, you have to pass this; information by hand, if you want to access all members of the `Myclass`; instance from the Thread0 function. Note: Method Thread0 cannot be a virtual member function, since the cast; of `Thread0` to `void(*)` in the **`TThread`** constructor may raise; problems with C++ virtual function table. However, Thread0 may call; another virtual member function virtual void `Myclass::Func0()` which; then can be overridden in a derived class of `Myclass`. (See example; `TMhs3`). Class `Myclass` may also provide a method to stop the running thread:. ``` {.cpp}; Int_t Myclass::Threadstop() {; if (mTh) {; TThread::Delete(mTh);; delete mTh;; mTh=0;; return 0;; }; return 1;; }; ```. Example `TMhs3:` Class **`TThreadframe`**; (`TThreadframe.h, TThreadframe.cxx`) is a simple example of a framework; class managing up to four threaded methods. Class `TMhs3`; (`TMhs3.h, TMhs3.cxx)` inherits from this base class, showing the `mhs3`; example 8.1 `(mhs3.h, mhs3.cxx) `within a class. The `Makefile` of this; example builds the shared libraries `libTThreadframe.so` and; `libTMhs3.so`. These are either loaded or executed by the ROOT script; `TMhs3demo.C,` or are linked against an executable: `TMhs3run.cxx`. ### Known Problems. Parts of the ROOT framework, like the interpreter, are not yet; thread-safe. Therefore, you should use this package with caution. If you; restrict your threads to distinct and \`simple' duties, you will able to; benefit from their use. The **`TThread`** class is available on all; platforms, which provide a POSIX compliant thread implementation. On; Linux, Xavier Leroy's Linux Threads implementation is widely used, but; the **`TThread`** implementation should be usable on all platforms that; provide `pthread`. **Linux Xlib on SMP machines** is not yet thread-safe. This",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Threads.md:16498,simpl,simple,16498,documentation/users-guide/Threads.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Threads.md,1,['simpl'],['simple']
Usability,"stance, running a `migrad` fit:; ``` {.cpp}; m.migrad(); ```. ## Constant term optimization; The `RooAbsTestStatistic` based classes not only combine statistics and calculation, but also constant term optimization routines.; These can be run on PDFs and datasets before starting a fit.; They search the calculation graph for parts that are independent of the fit parameters, precalculates them, and adds them to (a clone of) the dataset so that these values can be used during calculation. In `RooFit::TestStatistics`, we separated this functionality out into the `ConstantTermsOptimizer` class.; In fact, it is not so much a class, as it is a collection of static functions that can be applied to any combination of pdf and dataset.; This class does essentially the same as `constOptimizeTestStatistic` did on a `RooNLLVar`, except that it has been factored out into a separate class. ### Usage example: apply constant term optimization on pdf and dataset inside a likelihood; Applying the default `ConstantTermsOptimizer` optimization routines on the pdf and dataset inside a `RooAbsL` likelihood is as simple as:. ``` {.cpp}; likelihood.constOptimizeTestStatistic();; ```; This applies constant term optimization to the cloned pdf and dataset inside the likelihood object.; It will not modify anything outside of the likelihood. Optimization can also be activated through the minimizer, which may be more familiar to most users.; Given the `RooMinimizer` object `m` as defined in the example above, we can do:; ``` {.cpp}; m.optimizeConst(2);; ```. For the adventurous user, it is also possible to apply constant term optimization to a pdf and dataset directly without needing a likelihood object, e.g. given some `RooArgSet` set of observables `normSet`:; ``` {.cpp}; bool applyTrackingOpt = true;; ConstantTermsOptimizer::enableConstantTermsOptimization(&pdf, &normSet, dataset, applyTrackingOpt);; ```; We refer to RooFit documentation for more about ""tracking optimization"" which can be enabled",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/developers/test_statistics.md:10500,simpl,simple,10500,roofit/doc/developers/test_statistics.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/developers/test_statistics.md,1,['simpl'],['simple']
Usability,"state change that; needs to happen to prepare a coroutine for resumption) happens at the same time as; a suspension of a coroutine. However, in certain cases, it is necessary to control; when coroutine is prepared for resumption and when it is suspended. In the following example, a coroutine represents some activity that is driven; by completions of asynchronous operations `async_op1` and `async_op2` which get; a coroutine handle as a parameter and resume the coroutine once async; operation is finished. .. code-block:: text. void g() {; for (;;); if (cond()) {; async_op1(<coroutine-handle>); // will resume once async_op1 completes; <suspend>; do_one();; }; else {; async_op2(<coroutine-handle>); // will resume once async_op2 completes; <suspend>; do_two();; }; }; }. In this case, coroutine should be ready for resumption prior to a call to; `async_op1` and `async_op2`. The `coro.save`_ intrinsic is used to indicate a; point when coroutine should be ready for resumption (namely, when a resume index; should be stored in the coroutine frame, so that it can be resumed at the; correct resume point):. .. code-block:: llvm. if.true:; %save1 = call token @llvm.coro.save(ptr %hdl); call void @async_op1(ptr %hdl); %suspend1 = call i1 @llvm.coro.suspend(token %save1, i1 false); switch i8 %suspend1, label %suspend [i8 0, label %resume1; i8 1, label %cleanup]; if.false:; %save2 = call token @llvm.coro.save(ptr %hdl); call void @async_op2(ptr %hdl); %suspend2 = call i1 @llvm.coro.suspend(token %save2, i1 false); switch i8 %suspend2, label %suspend [i8 0, label %resume2; i8 1, label %cleanup]. .. _coroutine promise:. Coroutine Promise; -----------------. A coroutine author or a frontend may designate a distinguished `alloca` that can; be used to communicate with the coroutine. This distinguished alloca is called; **coroutine promise** and is provided as the second parameter to the; `coro.id`_ intrinsic. The following coroutine designates a 32 bit integer `promise` and uses it to; st",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst:21604,resume,resume,21604,interpreter/llvm-project/llvm/docs/Coroutines.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst,3,['resume'],"['resume', 'resumed']"
Usability,"stead,e.g.:. RooDataSet wdata(""wdata"",""wdata"",RooArgSet(x,y,wgt),WeightVar(wgt)) ;. The RooHist class that represents data as a histogram in a RooPlot has been modified; so that it can show approximate Poisson errors for non-integer data. These approximate; errors are calculated from interpolation of the error bars of the nearest integers. NB: A weighted dataset; plotted with RooAbsData::plotOn() will be default show sum-of-weights-squared errors. Only; when Poisson error are forced through a DataError(RooAbsData::Poisson) argument these; approximate Poisson error bars are shown. Miscellaneous improvements other. The RooFit messagee service class RooMsgService has been augmented with a stack that; can store its configurate state information. A call to saveState() will save the; present configuration, which can be restored through a subsequent call to restoreState().; In addition to the method RooAbsArg::printCompactTree() which is mostly intende for; debugging, a new method RooAbsArg::printComponentTree() has been added that prints; the tree structure of a pdf in a more user-friendly content oriented way. The printing ; of the leaf nodes (the variables) is omitted in this method to keep the output compact. RooStats. This release contains significant bug fixes and it is strongly; recommended to update to this version if using older ones. . Major Changes in LimitCalculator and HypoTestCalculator classes: usage of ModelConfig class. The RooStats calculator interfaces have been changed to use the ModelConfig class.; All the setter methods with the parameter lists, pdf instances and name have been removed from the interfaces.; The SetWorkspace(RooWorkspace & ) has also been removed, while a SetModel(const ModelConfig &); function is introduced. Users are supposed to pass all the model information using the; ModelConfig class rather than via the; RooWorkspace or specifying directly the pdf and parameter; objects in the constructors. ; Setter methods using pdf instances an",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v526/index.html:11143,user-friendly,user-friendly,11143,roofit/doc/v526/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v526/index.html,1,['user-friendly'],['user-friendly']
Usability,"stered object can be requested and displayed in the web browser. There are many benefits of such approach:. * standard http interface to ROOT application; * no any temporary ROOT files to access data; * user interface running in all browsers. ## Starting the HTTP server. To start the http server, at any time, create an instance of the [THttpServer](https://root.cern/doc/master/classTHttpServer.html) class like:. ```cpp; auto serv = new THttpServer(""http:8080"");; ```. This will start a [civetweb](https://github.com/civetweb/civetweb)-based http server on the port 8080. Then one should be able to open the address `http://localhost:8080` in any modern browser (Firefox, Chrome, Opera, Safari, IE11) and browse objects created in application. By default, the server can access files, canvases, and histograms via the gROOT pointer. All those objects can be displayed with JSROOT graphics. There is a [server snapshot](https://root.cern/js/latest/httpserver.C/?layout=simple&item=Canvases/c1) of running macro [tutorials/http/httpserver.C](https://github.com/root-project/root/blob/master/tutorials/http/httpserver.C) from ROOT tutorials. One could specify several options when creating http server. They could be add as additional URL parameters to the constructor arguments like:. ```cpp; auto serv = new THttpServer(""http:8080?loopback&thrds=2"");; ```. Following URL parameters are supported:. | Name | Description |; | :-------------------- | :---------------- |; | thrds=N | number of threads used by the civetweb (default is 10) |; | top=name | configure top name, visible in the web browser |; | auth_file=filename | authentication file name, created with htdigets utility |; | auth_domain=domain | authentication domain |; | loopback | bind specified port to loopback 127.0.0.1 address |; | debug | enable debug mode, server returns html page with request info |; | websocket_timeout=tm | set web sockets timeout in seconds (default 300) |; | websocket_disable | disable web sockets handlin",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/HttpServer/HttpServer.md:1130,simpl,simple,1130,documentation/HttpServer/HttpServer.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/HttpServer/HttpServer.md,1,['simpl'],['simple']
Usability,"stroy_fn = 0x402000 <coro_task(int)>, __promise = {...}, ...}. The above is possible because:. (1) The name of the debug type of the coroutine frame is the `linkage_name`,; plus the `.coro_frame_ty` suffix because each coroutine function shares the; same coroutine type. (2) The coroutine function name is accessible from the address of the coroutine; frame. The above commands can be simplified by placing them in debug scripts. Examples to print coroutine frames; ----------------------------------. The print examples below use the following definition:. .. code-block:: c++. #include <coroutine>; #include <iostream>. struct task{; struct promise_type {; task get_return_object() { return std::coroutine_handle<promise_type>::from_promise(*this); }; std::suspend_always initial_suspend() { return {}; }; std::suspend_always final_suspend() noexcept { return {}; }; void return_void() noexcept {}; void unhandled_exception() noexcept {}. int count = 0;; };. void resume() noexcept {; handle.resume();; }. task(std::coroutine_handle<promise_type> hdl) : handle(hdl) {}; ~task() {; if (handle); handle.destroy();; }. std::coroutine_handle<> handle;; };. class await_counter : public std::suspend_always {; public:; template<class PromiseType>; void await_suspend(std::coroutine_handle<PromiseType> handle) noexcept {; handle.promise().count++;; }; };. static task coro_task(int v) {; int a = v;; co_await await_counter{};; a++;; std::cout << a << ""\n"";; a++;; std::cout << a << ""\n"";; a++;; std::cout << a << ""\n"";; co_await await_counter{};; a++;; std::cout << a << ""\n"";; a++;; std::cout << a << ""\n"";; }. int main() {; task t = coro_task(43);; t.resume();; t.resume();; t.resume();; return 0;; }. In debug mode (`O0` + `g`), the printing result would be:. .. parsed-literal::. {__resume_fn = 0x4019e0 <coro_task(int)>, __destroy_fn = 0x402000 <coro_task(int)>, __promise = {count = 1}, v = 43, a = 45, __coro_index = 1 '\001', struct_std__suspend_always_0 = {__int_8 = 0 '\000'},; class_await_coun",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DebuggingCoroutines.rst:6478,resume,resume,6478,interpreter/llvm-project/clang/docs/DebuggingCoroutines.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DebuggingCoroutines.rst,1,['resume'],['resume']
Usability,"subdivisions, called pads; c1.cd(1); //change to pad 1 of canvas c1; ```. These parts of a well-written macro are pretty standard, and you should; remember to include pieces of code like in the examples above to make; sure your plots always look as you had intended. Below, in section [Interpretation and Compilation](#interpretation-and-compilation), some more code fragments; will be shown, allowing you to use the system compiler to compile macros for; more efficient execution, or turn macros into stand-alone applications linked; against the ROOT libraries. ## A more complete example ##. Let us now look at a rather complete example of a typical task in data; analysis, a macro that constructs a graph with errors, fits a (linear); model to it and saves it as an image. To run this macro, simply type in; the shell:. ``` {.cpp}; > root macro1.C; ```. The code is built around the ROOT class `TGraphErrors`, which was; already introduced previously. Have a look at it in the class reference; guide, where you will also find further examples. The macro shown below; uses additional classes, `TF1` to define a function, `TCanvas` to define; size and properties of the window used for our plot, and `TLegend` to; add a nice legend. For the moment, ignore the commented include; statements for header files, they will only become important at the end; in section [Interpretation and Compilation](#interpretation-and-compilation). ``` {.cpp .numberLines}; @ROOT_INCLUDE_FILE macros/macro1.C; ```. Let's comment it in detail:. - Line *13*: the name of the principal function (it plays the role of; the ""main"" function in compiled programs) in the macro file. It has; to be the same as the file name without extension. - Line *24-25*: instance of the `TGraphErrors` class. The constructor; takes the number of points and the pointers to the arrays of; x values, y values, x errors (in this case none,; represented by the NULL pointer) and y errors. The second line; defines in one shot the title of the",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/your_first_ROOT_macro.md:2961,guid,guide,2961,documentation/primer/your_first_ROOT_macro.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/your_first_ROOT_macro.md,1,['guid'],['guide']
Usability,"supported style options. Value type is specified for; each option. For enumeration types possible values are specified both as a C++; enumeration member (with a prefix, e.g. ``LS_Auto``), and as a value usable in; the configuration (without a prefix: ``Auto``). .. _BasedOnStyle:. **BasedOnStyle** (``String``) :ref:`¶ <BasedOnStyle>`; The style used for all options not specifically set in the configuration. This option is supported only in the :program:`clang-format` configuration; (both within ``-style='{...}'`` and the ``.clang-format`` file). Possible values:. * ``LLVM``; A style complying with the `LLVM coding standards; <https://llvm.org/docs/CodingStandards.html>`_; * ``Google``; A style complying with `Google's C++ style guide; <https://google.github.io/styleguide/cppguide.html>`_; * ``Chromium``; A style complying with `Chromium's style guide; <https://chromium.googlesource.com/chromium/src/+/refs/heads/main/styleguide/styleguide.md>`_; * ``Mozilla``; A style complying with `Mozilla's style guide; <https://firefox-source-docs.mozilla.org/code-quality/coding-style/index.html>`_; * ``WebKit``; A style complying with `WebKit's style guide; <https://www.webkit.org/coding/coding-style.html>`_; * ``Microsoft``; A style complying with `Microsoft's style guide; <https://docs.microsoft.com/en-us/visualstudio/ide/editorconfig-code-style-settings-reference>`_; * ``GNU``; A style complying with the `GNU coding standards; <https://www.gnu.org/prep/standards/standards.html>`_; * ``InheritParentConfig``; Not a real style, but allows to use the ``.clang-format`` file from the; parent directory (or its parent if there is none). If there is no parent; file found it falls back to the ``fallback`` style, and applies the changes; to that. With this option you can overwrite some parts of your main style for your; subdirectories. This is also possible through the command line, e.g.:; ``--style={BasedOnStyle: InheritParentConfig, ColumnLimit: 20}``. .. START_FORMAT_STYLE_OPTIONS. ..",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:5808,guid,guide,5808,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,1,['guid'],['guide']
Usability,"system. :doc:`BugLifeCycle`; Describes how bugs are reported, triaged and closed. :doc:`CodingStandards`; Details the LLVM coding standards and provides useful information on writing; efficient C++ code. :doc:`GitHub`; Describes how to use the llvm-project repository and code reviews on GitHub. :doc:`GitBisecting`; Describes how to use ``git bisect`` on LLVM's repository. :doc:`GitRepositoryPolicy`; Collection of policies around the git repositories. .. _development-process:. Development Process; -------------------. Information about LLVM's development process. .. toctree::; :hidden:. Projects; HowToReleaseLLVM; Packaging; ReleaseProcess; HowToAddABuilder; ReleaseNotes. :doc:`Projects`; How-to guide and templates for new projects that *use* the LLVM; infrastructure. The templates (directory organization, Makefiles, and test; tree) allow the project code to be located outside (or inside) the ``llvm/``; tree, while using LLVM header files and libraries. :doc:`HowToReleaseLLVM`; This is a guide to preparing LLVM releases. Most developers can ignore it. :doc:`ReleaseProcess`; This is a guide to validate a new release, during the release process. Most developers can ignore it. :doc:`HowToAddABuilder`; Instructions for adding new builder to LLVM buildbot master. :doc:`Packaging`; Advice on packaging LLVM into a distribution. :doc:`Release notes for the current release <ReleaseNotes>`; This describes new features, known bugs, and other limitations. .. _lists-forums:. Forums & Mailing Lists; ----------------------. If you can't find what you need in these docs, try consulting the; Discourse forums. There are also commit mailing lists for all commits to the LLVM Project.; The :doc:`CodeOfConduct` applies to all these forums and mailing lists. `LLVM Discourse`__; The forums for all things LLVM and related sub-projects. There are categories and subcategories for a wide variety of areas within LLVM. You can also view tags or search for a specific topic. .. __: https://discourse",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GettingInvolved.rst:1899,guid,guide,1899,interpreter/llvm-project/llvm/docs/GettingInvolved.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GettingInvolved.rst,1,['guid'],['guide']
Usability,"t LLVM; supports, even emitting C code and compiling that on targets that LLVM; doesn't support natively. You can trivially tell that the Kaleidoscope; compiler generates target-independent code because it never queries for; any target-specific information when generating code. The fact that LLVM provides a compact, target-independent,; representation for code gets a lot of people excited. Unfortunately,; these people are usually thinking about C or a language from the C; family when they are asking questions about language portability. I say; ""unfortunately"", because there is really no way to make (fully general); C code portable, other than shipping the source code around (and of; course, C source code is not actually portable in general either - ever; port a really old application from 32- to 64-bits?). The problem with C (again, in its full generality) is that it is heavily; laden with target specific assumptions. As one simple example, the; preprocessor often destructively removes target-independence from the; code when it processes the input text:. .. code-block:: c. #ifdef __i386__; int X = 1;; #else; int X = 42;; #endif. While it is possible to engineer more and more complex solutions to; problems like this, it cannot be solved in full generality in a way that; is better than shipping the actual source code. That said, there are interesting subsets of C that can be made portable.; If you are willing to fix primitive types to a fixed size (say int =; 32-bits, and long = 64-bits), don't care about ABI compatibility with; existing binaries, and are willing to give up some other minor features,; you can have portable code. This can make sense for specialized domains; such as an in-kernel language. Safety Guarantees; -----------------. Many of the languages above are also ""safe"" languages: it is impossible; for a program written in Java to corrupt its address space and crash the; process (assuming the JVM has no bugs). Safety is an interesting; property that requi",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl10.rst:7056,simpl,simple,7056,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl10.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl10.rst,1,['simpl'],['simple']
Usability,"t either using; the standard EBP register or as the first parameter register, depending on the; architecture. The funclet implements the EH action by accessing local variables; in memory through the frame pointer, and returning some appropriate value,; continuing the EH process. No variables live in to or out of the funclet can be; allocated in registers. The C++ personality also uses funclets to contain the code for catch blocks; (i.e. all user code between the braces in ``catch (Type obj) { ... }``). The; runtime must use funclets for catch bodies because the C++ exception object is; allocated in a child stack frame of the function handling the exception. If the; runtime rewound the stack back to frame of the catch, the memory holding the; exception would be overwritten quickly by subsequent function calls. The use of; funclets also allows ``__CxxFrameHandler3`` to implement rethrow without; resorting to TLS. Instead, the runtime throws a special exception, and then uses; SEH (``__try / __except``) to resume execution with new information in the child; frame. In other words, the successive unwinding approach is incompatible with Visual; C++ exceptions and general purpose Windows exception handling. Because the C++; exception object lives in stack memory, LLVM cannot provide a custom personality; function that uses landingpads. Similarly, SEH does not provide any mechanism; to rethrow an exception or continue unwinding. Therefore, LLVM must use the IR; constructs described later in this document to implement compatible exception; handling. SEH filter expressions; -----------------------. The SEH personality functions also use funclets to implement filter expressions,; which allow executing arbitrary user code to decide which exceptions to catch.; Filter expressions should not be confused with the ``filter`` clause of the LLVM; ``landingpad`` instruction. Typically filter expressions are used to determine; if the exception came from a particular DLL or code region, o",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ExceptionHandling.rst:23291,resume,resume,23291,interpreter/llvm-project/llvm/docs/ExceptionHandling.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ExceptionHandling.rst,1,['resume'],['resume']
Usability,"t in many different ways. In addition; to adding new features (LLVM did not always support exceptions or debug; info), we also extend the IR to capture important information for; optimization (e.g. whether an argument is sign or zero extended,; information about pointers aliasing, etc). Many of the enhancements are; user-driven: people want LLVM to include some specific feature, so they; go ahead and extend it. Third, it is *possible and easy* to add language-specific optimizations,; and you have a number of choices in how to do it. As one trivial; example, it is easy to add language-specific optimization passes that; ""know"" things about code compiled for a language. In the case of the C; family, there is an optimization pass that ""knows"" about the standard C; library functions. If you call ""exit(0)"" in main(), it knows that it is; safe to optimize that into ""return 0;"" because C specifies what the; 'exit' function does. In addition to simple library knowledge, it is possible to embed a; variety of other language-specific information into the LLVM IR. If you; have a specific need and run into a wall, please bring the topic up on; the llvm-dev list. At the very worst, you can always treat LLVM as if it; were a ""dumb code generator"" and implement the high-level optimizations; you desire in your front-end, on the language-specific AST. Tips and Tricks; ===============. There is a variety of useful tips and tricks that you come to know after; working on/with LLVM that aren't obvious at first glance. Instead of; letting everyone rediscover them, this section talks about some of these; issues. Implementing portable offsetof/sizeof; -------------------------------------. One interesting thing that comes up, if you are trying to keep the code; generated by your compiler ""target independent"", is that you often need; to know the size of some LLVM type or the offset of some field in an; llvm structure. For example, you might need to pass the size of a type; into a function that",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl10.rst:10827,simpl,simple,10827,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl10.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl10.rst,1,['simpl'],['simple']
Usability,"t is only optional when parsing textual IR; for in-memory IR,; it is always present. If not specified, the target can choose to align the; allocation on any convenient boundary compatible with the type. '``type``' may be any sized type. Structs containing scalable vectors cannot be used in allocas unless all; fields are the same scalable vector type (e.g. ``{<vscale x 2 x i32>,; <vscale x 2 x i32>}`` contains the same type while ``{<vscale x 2 x i32>,; <vscale x 2 x i64>}`` doesn't). Semantics:; """""""""""""""""""". Memory is allocated; a pointer is returned. The allocated memory is; uninitialized, and loading from uninitialized memory produces an undefined; value. The operation itself is undefined if there is insufficient stack; space for the allocation.'``alloca``'d memory is automatically released; when the function returns. The '``alloca``' instruction is commonly used; to represent automatic variables that must have an address available. When; the function returns (either with the ``ret`` or ``resume`` instructions),; the memory is reclaimed. Allocating zero bytes is legal, but the returned; pointer may not be unique. The order in which memory is allocated (ie.,; which way the stack grows) is not specified. Note that '``alloca``' outside of the alloca address space from the; :ref:`datalayout string<langref_datalayout>` is meaningful only if the; target has assigned it a semantics. If the returned pointer is used by :ref:`llvm.lifetime.start <int_lifestart>`,; the returned object is initially dead.; See :ref:`llvm.lifetime.start <int_lifestart>` and; :ref:`llvm.lifetime.end <int_lifeend>` for the precise semantics of; lifetime-manipulating intrinsics. Example:; """""""""""""""". .. code-block:: llvm. %ptr = alloca i32 ; yields ptr; %ptr = alloca i32, i32 4 ; yields ptr; %ptr = alloca i32, i32 4, align 1024 ; yields ptr; %ptr = alloca i32, align 1024 ; yields ptr. .. _i_load:. '``load``' Instruction; ^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. <result> = load [volatile] <ty>, pt",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:410932,resume,resume,410932,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['resume'],['resume']
Usability,"t native support for a given type, the specified type; may be promoted to a larger type that is supported. For example, SPARC does; not support a sign-extending load for Boolean values (``i1`` type), so in; ``SparcISelLowering.cpp`` the third parameter below, ``Promote``, changes; ``i1`` type values to a large type before loading. .. code-block:: c++. setLoadExtAction(ISD::SEXTLOAD, MVT::i1, Promote);. Expand; ^^^^^^. For a type without native support, a value may need to be broken down further,; rather than promoted. For an operation without native support, a combination; of other operations may be used to similar effect. In SPARC, the; floating-point sine and cosine trig operations are supported by expansion to; other operations, as indicated by the third parameter, ``Expand``, to; ``setOperationAction``:. .. code-block:: c++. setOperationAction(ISD::FSIN, MVT::f32, Expand);; setOperationAction(ISD::FCOS, MVT::f32, Expand);. Custom; ^^^^^^. For some operations, simple type promotion or operation expansion may be; insufficient. In some cases, a special intrinsic function must be implemented. For example, a constant value may require special treatment, or an operation; may require spilling and restoring registers in the stack and working with; register allocators. As seen in ``SparcISelLowering.cpp`` code below, to perform a type conversion; from a floating point value to a signed integer, first the; ``setOperationAction`` should be called with ``Custom`` as the third parameter:. .. code-block:: c++. setOperationAction(ISD::FP_TO_SINT, MVT::i32, Custom);. In the ``LowerOperation`` method, for each ``Custom`` operation, a case; statement should be added to indicate what function to call. In the following; code, an ``FP_TO_SINT`` opcode will call the ``LowerFP_TO_SINT`` method:. .. code-block:: c++. SDValue SparcTargetLowering::LowerOperation(SDValue Op, SelectionDAG &DAG) {; switch (Op.getOpcode()) {; case ISD::FP_TO_SINT: return LowerFP_TO_SINT(Op, DAG);; ...; }; }.",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/WritingAnLLVMBackend.rst:59603,simpl,simple,59603,interpreter/llvm-project/llvm/docs/WritingAnLLVMBackend.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/WritingAnLLVMBackend.rst,1,['simpl'],['simple']
Usability,"t of objects. For; now, we assume that the types we want to cast *to* all provide ``classof``. So; we can use some provided cast traits like so:. .. code-block:: c++. template <typename T>; struct CastInfo<T, SomeValue>; : CastIsPossible<T, SomeValue>, NullableValueCastFailed<T>,; DefaultDoCastIfPossible<T, SomeValue, CastInfo<T, SomeValue>> {; static T doCast(SomeValue v) {; return T(v.getPointer());; }; };. Pointer to value casting; ------------------------; Now given the value above ``SomeValue``, maybe we'd like to be able to cast to; that type from a char pointer type. So what we would do in that case is:. .. code-block:: c++. template <typename T>; struct CastInfo<SomeValue, T *>; : NullableValueCastFailed<SomeValue>,; DefaultDoCastIfPossible<SomeValue, T *, CastInfo<SomeValue, T *>> {; static bool isPossible(const T *t) {; return std::is_same<T, char>::value;; }; static SomeValue doCast(const T *t) {; return SomeValue((void *)t);; }; };. This would enable us to cast from a ``char *`` to a SomeValue, if we wanted to. Optional value casting; ----------------------; When your types are not constructible from ``nullptr`` or there isn't a simple; way to tell when an object is invalid, you may want to use ``std::optional``.; In those cases, you probably want something like this:. .. code-block:: c++. template <typename T>; struct CastInfo<T, SomeValue> : OptionalValueCast<T, SomeValue> {};. That cast trait requires that ``T`` is constructible from ``const SomeValue &``; but it enables casting like so:. .. code-block:: c++. SomeValue someVal = ...;; std::optional<AnotherValue> valOr = dyn_cast<AnotherValue>(someVal);. With the ``_if_present`` variants, you can even do optional chaining like this:. .. code-block:: c++. std::optional<SomeValue> someVal = ...;; std::optional<AnotherValue> valOr = dyn_cast_if_present<AnotherValue>(someVal);. and ``valOr`` will be ``std::nullopt`` if either ``someVal`` cannot be converted *or*; if ``someVal`` was also ``std::nullopt``.; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToSetUpLLVMStyleRTTI.rst:17255,simpl,simple,17255,interpreter/llvm-project/llvm/docs/HowToSetUpLLVMStyleRTTI.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToSetUpLLVMStyleRTTI.rst,1,['simpl'],['simple']
Usability,"t off); - no_screen - let ignore kVisOnScreen bits for nodes visibility; - dray - calculate rendering order using raytracing (extensive calculations); - dbox - use distance to nearest point from bounding box for rendering order (default); - dpnt - use distance to shape center as rendering order; - dsize - use volume size as rendering order; - ddflt - let three.js to calculate rendering order; - comp - show left and right components of TGeoCompositeShape; - compx - show all sub-components of TGeoCompositeShape. In the URL string several global settings can be changed:. - geosegm - grads per segment is cylindrical shapes, default is 6; - geocomp - compress results of composite shape production, default is true. It is possible to display only part of geometry model. For instance, one could select sub-item like:. - [file=rootgeom.root&item=simple1/TOP/REPLICA_1](https://root.cern/js/latest/?file=../files/geom/rootgeom.root&item=simple1/TOP/REPLICA_1). Or one can use simple selection syntax (work only with first-level volumes):. - [item=simple1&opt=-bar1-bar2](https://root.cern/js/latest/?file=../files/geom/rootgeom.root&item=simple1;1&opt=-bar1-bar2). Syntax uses '+' sign to enable visibility flag of specified volume and '-' sign to disable visibility.; One could use wildcard symbol like '+TUBE1*'. Another way to configure visibility flags is usage of ROOT macros, which typically looks like:. ```cpp; {; TGeoManager::Import(""http://root.cern/files/alice2.root"");; gGeoManager->DefaultColors();; // gGeoManager->SetVisLevel(4);; gGeoManager->GetVolume(""HALL"")->InvisibleAll();; gGeoManager->GetVolume(""ZDCC"")->InvisibleAll();; gGeoManager->GetVolume(""ZDCA"")->InvisibleAll();; // ...; gGeoManager->GetVolume(""ALIC"")->Draw(""ogl"");; new TBrowser;; }; ```. Example of such macro can be found in root tutorials. From provided macro only following calls will be executed in JSROOT:. * `gGeoManager->DefaultColors()`; * `gGeoManager->GetVolume(""HALL"")->InvisibleAll()`; * `gGeoManager->Get",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/JSROOT/JSROOT.md:22737,simpl,simple,22737,documentation/JSROOT/JSROOT.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/JSROOT/JSROOT.md,1,['simpl'],['simple']
Usability,"t search for module map files named ``module.modulemap`` and similar. This option is implied by ``-fmodules``. If this is disabled with ``-fno-implicit-module-maps``, module map files will only be loaded if they are explicitly specified via ``-fmodule-map-file`` or transitively used by another module map file. ``-fmodules-cache-path=<directory>``; Specify the path to the modules cache. If not provided, Clang will select a system-appropriate default. ``-fno-autolink``; Disable automatic linking against the libraries associated with imported modules. ``-fmodules-ignore-macro=macroname``; Instruct modules to ignore the named macro when selecting an appropriate module variant. Use this for macros defined on the command line that don't affect how modules are built, to improve sharing of compiled module files. ``-fmodules-prune-interval=seconds``; Specify the minimum delay (in seconds) between attempts to prune the module cache. Module cache pruning attempts to clear out old, unused module files so that the module cache itself does not grow without bound. The default delay is large (604,800 seconds, or 7 days) because this is an expensive operation. Set this value to 0 to turn off pruning. ``-fmodules-prune-after=seconds``; Specify the minimum time (in seconds) for which a file in the module cache must be unused (according to access time) before module pruning will remove it. The default delay is large (2,678,400 seconds, or 31 days) to avoid excessive module rebuilding. ``-module-file-info <module file name>``; Debugging aid that prints information about a given module file (with a ``.pcm`` extension), including the language and preprocessor options that particular module variant was built with. ``-fmodules-decluse``; Enable checking of module ``use`` declarations. ``-fmodule-name=module-id``; Consider a source file as a part of the given module. ``-fmodule-map-file=<file>``; Load the given module map file if a header from its directory or one of its subdirectories is loa",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst:15577,clear,clear,15577,interpreter/llvm-project/clang/docs/Modules.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst,1,['clear'],['clear']
Usability,"t suitable for; embedding in datastructures in most cases (instead, use an std::string or; something like that). #. For the same reason, StringRef cannot be used as the return value of a; method if the method ""computes"" the result string. Instead, use std::string. #. StringRef's do not allow you to mutate the pointed-to string bytes and it; doesn't allow you to insert or remove bytes from the range. For editing; operations like this, it interoperates with the :ref:`Twine <dss_twine>`; class. Because of its strengths and limitations, it is very common for a function to; take a StringRef and for a method on an object to return a StringRef that points; into some string that it owns. .. _dss_twine:. llvm/ADT/Twine.h; ^^^^^^^^^^^^^^^^. The Twine class is used as an intermediary datatype for APIs that want to take a; string that can be constructed inline with a series of concatenations. Twine; works by forming recursive instances of the Twine datatype (a simple value; object) on the stack as temporary objects, linking them together into a tree; which is then linearized when the Twine is consumed. Twine is only safe to use; as the argument to a function, and should always be a const reference, e.g.:. .. code-block:: c++. void foo(const Twine &T);; ...; StringRef X = ...; unsigned i = ...; foo(X + ""."" + Twine(i));. This example forms a string like ""blarg.42"" by concatenating the values; together, and does not form intermediate strings containing ""blarg"" or ""blarg."". Because Twine is constructed with temporary objects on the stack, and because; these instances are destroyed at the end of the current statement, it is an; inherently dangerous API. For example, this simple variant contains undefined; behavior and will probably crash:. .. code-block:: c++. void foo(const Twine &T);; ...; StringRef X = ...; unsigned i = ...; const Twine &Tmp = X + ""."" + Twine(i);; foo(Tmp);. ... because the temporaries are destroyed before the call. That said, Twine's; are much more efficient tha",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:73806,simpl,simple,73806,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,1,['simpl'],['simple']
Usability,"t the drawn objects. The; ""memory leak"" is intentional, to make the object existing also out; of the macro1 scope. - Line *36*: the method *DrawClone* draws a clone of the object on the; canvas. It *has to be* a clone, to survive after the scope of; `macro1`, and be displayed on screen after the end of the macro; execution. The string option ""APE"" stands for:. - *A* imposes the drawing of the Axes. - *P* imposes the drawing of the graph's markers. - *E* imposes the drawing of the graph's error bars. - Line *39*: define a mathematical function. There are several ways to; accomplish this, but in this case the constructor accepts the name; of the function, the formula, and the function range. - Line *41*: maquillage. Try to give a look to the line styles at your; disposal visiting the documentation of the `TLine` class. - Line *43*: fits the *f* function to the graph, observe that the; pointer is passed. It is more interesting to look at the output on; the screen to see the parameters values and other crucial; information that we will learn to read at the end of this guide. - Line *44*: again draws the clone of the object on the canvas. The; ""Same"" option avoids the cancellation of the already drawn objects,; in our case, the graph. The function *f* will be drawn using the *same* axis; system defined by the previously drawn graph. - Line *47-52*: completes the plot with a legend, represented by a; `TLegend` instance. The constructor takes as parameters the lower; left and upper right corners coordinates with respect to the total; size of the canvas, assumed to be 1, and the legend header string.; You can add to the legend the objects, previously drawn or not; drawn, through the `addEntry` method. Observe how the legend is; drawn at the end: looks familiar now, right ?. - Line *55-57*: defines an arrow with a triangle on the right hand; side, a thickness of 2 and draws it. - Line *60-61*: interpret a Latex string which hast its lower left; corner located in the specified",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/your_first_ROOT_macro.md:5299,learn,learn,5299,documentation/primer/your_first_ROOT_macro.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/your_first_ROOT_macro.md,2,"['guid', 'learn']","['guide', 'learn']"
Usability,"t the; interactions between various memory operations. Its goal is to replace; ``MemoryDependenceAnalysis`` for most (if not all) use-cases. This is because,; unless you're very careful, use of ``MemoryDependenceAnalysis`` can easily; result in quadratic-time algorithms in LLVM. Additionally, ``MemorySSA`` doesn't; have as many arbitrary limits as ``MemoryDependenceAnalysis``, so you should get; better results, too. One common use of ``MemorySSA`` is to quickly find out; that something definitely cannot happen (for example, reason that a hoist; out of a loop can't happen). At a high level, one of the goals of ``MemorySSA`` is to provide an SSA based; form for memory, complete with def-use and use-def chains, which; enables users to quickly find may-def and may-uses of memory operations.; It can also be thought of as a way to cheaply give versions to the complete; state of memory, and associate memory operations with those versions. This document goes over how ``MemorySSA`` is structured, and some basic; intuition on how ``MemorySSA`` works. A paper on MemorySSA (with notes about how it's implemented in GCC) `can be; found here <http://www.airs.com/dnovillo/Papers/mem-ssa.pdf>`_. Though, it's; relatively out-of-date; the paper references multiple memory partitions, but GCC; eventually swapped to just using one, like we now have in LLVM. Like; GCC's, LLVM's MemorySSA is intraprocedural. MemorySSA Structure; ===================. MemorySSA is a virtual IR. After it's built, ``MemorySSA`` will contain a; structure that maps ``Instruction``\ s to ``MemoryAccess``\ es, which are; ``MemorySSA``'s parallel to LLVM ``Instruction``\ s. Each ``MemoryAccess`` can be one of three types:. - ``MemoryDef``; - ``MemoryPhi``; - ``MemoryUse``. ``MemoryDef``\ s are operations which may either modify memory, or which; introduce some kind of ordering constraints. Examples of ``MemoryDef``\ s; include ``store``\ s, function calls, ``load``\ s with ``acquire`` (or higher); ordering, volatile",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MemorySSA.rst:1170,intuit,intuition,1170,interpreter/llvm-project/llvm/docs/MemorySSA.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MemorySSA.rst,1,['intuit'],['intuition']
Usability,"t to emphasize; > portability and safety like the Java VM? Or shall we focus on the; > architecture interface first (i.e., consider the code generation and; > processor issues), since the architecture interface question is also; > important for portable Java-type VMs?. I forsee the architecture looking kinda like this: (which is completely; subject to change). 1. The VM code is NOT guaranteed safe in a java sense. Doing so makes it; basically impossible to support C like languages. Besides that,; certifying a register based language as safe at run time would be a; pretty expensive operation to have to do. Additionally, we would like; to be able to statically eliminate many bounds checks in Java; programs... for example. 2. Instead, we can do the following (eventually): ; * Java bytecode is used as our ""safe"" representation (to avoid; reinventing something that we don't add much value to). When the; user chooses to execute Java bytecodes directly (ie, not; precompiled) the runtime compiler can do some very simple; transformations (JIT style) to convert it into valid input for our; VM. Performance is not wonderful, but it works right.; * The file is scheduled to be compiled (rigorously) at a later; time. This could be done by some background process or by a second; processor in the system during idle time or something...; * To keep things ""safe"" ie to enforce a sandbox on Java/foreign code,; we could sign the generated VM code with a host specific private; key. Then before the code is executed/loaded, we can check to see if; the trusted compiler generated the code. This would be much quicker; than having to validate consistency (especially if bounds checks have; been removed, for example). > This is important because the audiences for these two goals are very; > different. Architects and many compiler people care much more about; > the second question. The Java compiler and OS community care much more; > about the first one. 3. By focusing on a more low level virtual m",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HistoricalNotes/2000-11-18-EarlyDesignIdeasResp.txt:1324,simpl,simple,1324,interpreter/llvm-project/llvm/docs/HistoricalNotes/2000-11-18-EarlyDesignIdeasResp.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HistoricalNotes/2000-11-18-EarlyDesignIdeasResp.txt,1,['simpl'],['simple']
Usability,"t type; Int_t type = 111; //portrait ps; // Int_t type = 112; //landscape ps; // Int_t type = 113; //eps. //create a PostScript file and set the paper size; TPostScript ps(""test.ps"",type);; ps.Range(16,24); //set x,y of printed page. //draw 3 histograms from file hsimple.root on separate pages; hpx->Draw();; c1.Update(); //force drawing in a script; hprof->Draw();; c1.Update();; hpx->Draw(""lego1"");; c1.Update();; ps.Close();; }; ```. The next example does the same:. ``` {.cpp}; {; TFile f(""hsimple.root"");; TCanvas c1(""c1"",""canvas"",800,600);. //set x,y of printed page; gStyle->SetPaperSize(16,24);. //draw 3 histograms from file hsimple.root on separate pages; hpx->Draw();; c1->Print(""test1.ps("", ""Portrait"");; hprof->Draw();; c1->Print(""test1.ps"");; hpx->Draw(""lego1"");; c1->Print(""test1.ps)"");; }; ```. This following example shows two pages. The canvas is divided.; `TPostScript::NewPage` must be called before starting a new picture.; `object->Draw` does not clear the canvas in this case because we clear; only the pads and not the main canvas. Note that `c1->Update` must be; called at the end of the first picture. ``` {.cpp}; {; TFile *f1 = new TFile(""hsimple.root"");; TCanvas *c1 = new TCanvas(""c1"");; TPostScript *ps = new TPostScript(""file.ps"",112);. // picture 1; c1->Divide(2,1);; ps->NewPage();; c1->cd(1);; hpx->Draw();; c1->cd(2);; hprof->Draw();. // picture 2; c1->Update();; ps->NewPage();; c1->cd(1);; hpxpy->Draw();; c1->cd(2);; ntuple->Draw(""px"");; c1->Update();; ps->Close();. // invoke PostScript viewer; gSystem->Exec(""gs file.ps"");; }; ```. The next one does the same:. ``` {.cpp}; {; TFile *f1 = new TFile(""hsimple.root"");; TCanvas *c1 = new TCanvas(""c1"");; c1->Divide(2,1);. // picture 1; c1->cd(1);; hpx->Draw();; c1->cd(2);; hprof->Draw();; c1->Print(""test2.ps("", ""Landscape"");. // picture 2; c1->cd(1);; hpxpy->Draw();; c1->cd(2);; ntuple->Draw(""px"");; c1->Print(""test2.ps)"");; gSystem->Exec(""gs file.ps""); // invoke PostScript viewer; }; ```; ### The Color Model",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md:98199,clear,clear,98199,documentation/users-guide/Graphics.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md,2,['clear'],['clear']
Usability,"t visible.; TEveRGBAPalette - implement additional flag fFixColorRange specifying; how the palette color range gets mapped onto signal values:; true - LowLimit -> HighLimit; false - MinValue -> MaxValue.; Add signal emitting TEveRGBAPalette::MinMaxValChanged(). Ged; editor calls this after setting the min/max range. OpenGL; Major changes. Add support for stereo rendering. This requires quad buffer; support from OpenGL driver and hardware as well as shutter; glasses. See tutorial eve/geom_cms_stereo.C.; Support for rendering into frame-buffer objects (FBO).; Using FBOs, it is now possible to save bitmap image formats at; any resolution and even when the GL window is not on screen.; Add support for global scaling of point-sizes, line-widths and font-sizes.; Generalize secondary-selection handling so that it is possible to; implement various handling schemes. For example see individual; calorimeter tower selection in TEveCalo-classes.; Generalize handling of highlight feedback -- this is now done via; a virtual TGLLogicalShape::DrawHighlight(...) so that it can be; changed by sub-classes.; The stand-alone GL viewer now supports hiding of menu-bar. It; collapses into a narrow band on top of the viewer that expands when; mouse pointer enters its area. This allows for better utilization of; the screen while still providing the controls available from the menu.; Editor for ""gl5d"" option was improved.; TGLTH3Composition class to combine several TH3s in one plot. Minor changes. Use Diagonal() instead of Volume() to determine if a bounding-box; is empty and also for sorting of the scene-elements by size. The; previous implementation caused problems with 2D and 1D objects.; Several improvements in camera configuration and handling.; Improve mouse-button handling. After a button goes down, other; buttons do not interfere with user interaction until the first button; is released.; When initializing TGLClipPlane for the first time, place it in; the center of the scene's bounding-b",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/doc/v526/index.html:5539,feedback,feedback,5539,graf3d/doc/v526/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/doc/v526/index.html,1,['feedback'],['feedback']
Usability,"t, then ``or``\ s, then ``and``\ s, then ``xor``\ s.; #. Compare instructions are converted from ``<``, ``>``, ``≤``, or ``≥`` to; ``=`` or ``≠`` if possible.; #. All ``cmp`` instructions on boolean values are replaced with logical; operations.; #. ``add X, X`` is represented as ``mul X, 2`` ⇒ ``shl X, 1``; #. Multiplies with a constant power-of-two argument are transformed into; shifts.; #. … etc. This pass can also simplify calls to specific well-known function calls (e.g.; runtime library functions). For example, a call ``exit(3)`` that occurs within; the ``main()`` function can be transformed into simply ``return 3``. Whether or; not library calls are simplified is controlled by the; :ref:`-function-attrs <passes-function-attrs>` pass and LLVM's knowledge of; library calls on different targets. .. _passes-aggressive-instcombine:. ``aggressive-instcombine``: Combine expression patterns; --------------------------------------------------------. Combine expression patterns to form expressions with fewer, simple instructions. For example, this pass reduce width of expressions post-dominated by TruncInst; into smaller width when applicable. It differs from instcombine pass in that it can modify CFG and contains pattern; optimization that requires higher complexity than the O(1), thus, it should run fewer; times than instcombine pass. ``internalize``: Internalize Global Symbols; -------------------------------------------. This pass loops over all of the functions in the input module, looking for a; main function. If a main function is found, all other functions and all global; variables with initializers are marked as internal. ``ipsccp``: Interprocedural Sparse Conditional Constant Propagation; -------------------------------------------------------------------. An interprocedural variant of :ref:`Sparse Conditional Constant Propagation; <passes-sccp>`. ``jump-threading``: Jump Threading; ----------------------------------. Jump threading tries to find distinct threa",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Passes.rst:21018,simpl,simple,21018,interpreter/llvm-project/llvm/docs/Passes.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Passes.rst,1,['simpl'],['simple']
Usability,"t.c:28:8: warning: extra tokens at end of #endif directive [-Wextra-tokens]; #endif bad; ^. These extra tokens are not strictly conforming, and are usually best; handled by commenting them out. .. option:: -Wambiguous-member-template. Warn about unqualified uses of a member template whose name resolves to; another template at the location of the use. This option, which defaults to on, enables a warning in the; following code:. ::. template<typename T> struct set{};; template<typename T> struct trait { typedef const T& type; };; struct Value {; template<typename T> void set(typename trait<T>::type value) {}; };; void foo() {; Value v;; v.set<double>(3.2);; }. C++ [basic.lookup.classref] requires this to be an error, but,; because it's hard to work around, Clang downgrades it to a warning; as an extension. .. option:: -Wbind-to-temporary-copy. Warn about an unusable copy constructor when binding a reference to a; temporary. This option enables warnings about binding a; reference to a temporary when the temporary doesn't have a usable; copy constructor. For example:. ::. struct NonCopyable {; NonCopyable();; private:; NonCopyable(const NonCopyable&);; };; void foo(const NonCopyable&);; void bar() {; foo(NonCopyable()); // Disallowed in C++98; allowed in C++11.; }. ::. struct NonCopyable2 {; NonCopyable2();; NonCopyable2(NonCopyable2&);; };; void foo(const NonCopyable2&);; void bar() {; foo(NonCopyable2()); // Disallowed in C++98; allowed in C++11.; }. Note that if ``NonCopyable2::NonCopyable2()`` has a default argument; whose instantiation produces a compile error, that error will still; be a hard error in C++98 mode even if this warning is turned off. Options to Control Clang Crash Diagnostics; ------------------------------------------. As unbelievable as it may sound, Clang does crash from time to time.; Generally, this only occurs to those living on the `bleeding; edge <https://llvm.org/releases/download.html#svn>`_. Clang goes to great; lengths to assist you in fil",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:20986,usab,usable,20986,interpreter/llvm-project/clang/docs/UsersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst,1,['usab'],['usable']
Usability,"tHub's; built-in tool. See the section about landing your fix below. When pushing to your branch, make sure you push to the correct fork. Check your; remotes with:. ::. git remote -v. And make sure you push to the remote that's pointing to your fork. Rebasing Pull Requests and Force Pushes; ---------------------------------------; In general, you should avoid rebasing a Pull Request and force pushing to the; branch that's the root of the Pull Request during the review. This action will; make the context of the old changes and comments harder to find and read. Sometimes, a rebase might be needed to update your branch with a fix for a test; or in some dependent code. After your PR is reviewed and accepted, you want to rebase your branch to ensure; you won't encounter merge conflicts when landing the PR. Landing your change; -------------------; When your PR has been accepted you can use the web interface to land your change.; If you have created multiple commits to address feedback at this point you need; to consolidate those commits into one commit. There are two different ways to; do this:. `Interactive rebase <https://git-scm.com/docs/git-rebase#_interactive_mode>`_; with fixup's. This is the recommended method since you can control the final; commit message and inspect that the final commit looks as you expect. When; your local state is correct, remember to force-push to your branch and press; the merge button afterwards. Use the button `Squash and merge` in GitHub's web interface, if you do this; remember to review the commit message when prompted. Afterwards you can select the option `Delete branch` to delete the branch; from your fork. You can also merge via the CLI by switching to your branch locally and run:. ::. gh pr merge --squash --delete-branch. If you observe an error message from the above informing you that your pull; request is not mergeable, then that is likely because upstream has been; modified since your pull request was authored in a way that no",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GitHub.rst:4933,feedback,feedback,4933,interpreter/llvm-project/llvm/docs/GitHub.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GitHub.rst,1,['feedback'],['feedback']
Usability,"tMemOperand`` method; should be implemented to generate the proper output. Similarly,; ``printCCOperand`` should be used to print a conditional operand. ``doFinalization`` should be overridden in ``XXXAsmPrinter``, and it should be; called to shut down the assembly printer. During ``doFinalization``, global; variables and constants are printed to output. Subtarget Support; =================. Subtarget support is used to inform the code generation process of instruction; set variations for a given chip set. For example, the LLVM SPARC; implementation provided covers three major versions of the SPARC microprocessor; architecture: Version 8 (V8, which is a 32-bit architecture), Version 9 (V9, a; 64-bit architecture), and the UltraSPARC architecture. V8 has 16; double-precision floating-point registers that are also usable as either 32; single-precision or 8 quad-precision registers. V8 is also purely big-endian.; V9 has 32 double-precision floating-point registers that are also usable as 16; quad-precision registers, but cannot be used as single-precision registers.; The UltraSPARC architecture combines V9 with UltraSPARC Visual Instruction Set; extensions. If subtarget support is needed, you should implement a target-specific; ``XXXSubtarget`` class for your architecture. This class should process the; command-line options ``-mcpu=`` and ``-mattr=``. TableGen uses definitions in the ``Target.td`` and ``Sparc.td`` files to; generate code in ``SparcGenSubtarget.inc``. In ``Target.td``, shown below, the; ``SubtargetFeature`` interface is defined. The first 4 string parameters of; the ``SubtargetFeature`` interface are a feature name, a XXXSubtarget field set; by the feature, the value of the XXXSubtarget field, and a description of the; feature. (The fifth parameter is a list of features whose presence is implied,; and its default value is an empty array.). If the value for the field is the string ""true"" or ""false"", the field; is assumed to be a bool and only one Subtarge",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/WritingAnLLVMBackend.rst:71855,usab,usable,71855,interpreter/llvm-project/llvm/docs/WritingAnLLVMBackend.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/WritingAnLLVMBackend.rst,1,['usab'],['usable']
Usability,"t[] gPad->SetLogx(); root[] MyCanvas->cd(3); root[] gPad->SetLogx(); ```. ### WaitPrimitive method. When the `TPad::WaitPrimitive()` method is called with no arguments, it; will wait until a double click or any key pressed is executed in the; canvas. A call to `gSystem->Sleep(10)` has been added in the loop to; avoid consuming at all the CPU. This new option is convenient when; executing a macro. By adding statements like:. ``` {.cpp}; canvas->WaitPrimitive();; ```. You can monitor the progress of a running macro, stop it at convenient; places with the possibility to interact with the canvas and resume the; execution with a double click or a key press. ### Locking the Pad. You can make the **`TPad`** non-editable. Then no new objects can be; added, and the existing objects and the pad can not be changed with the; mouse or programmatically. By default the **`TPad`** is editable. ``` {.cpp}; TPad::SetEditable(kFALSE); ```. ## Graphical Objects. In this paragraph, we describe the various simple 2D graphical objects; defined in ROOT. Usually, one defines these objects with their; constructor and draws them with their `Draw()` method. Therefore, the; examples will be very brief. Most graphical objects have line and fill; attributes (color, width) that will be described in ""Graphical objects; attributes"". If the user wants more information, the class names are; given and they may refer to the online developer documentation. This is; especially true for functions and methods that set and get internal; values of the objects described here. By default 2D graphical objects; are created in User Coordinates with (0, 0) in the lower left corner. ### Lines, Arrows and Polylines. The simplest graphical object is a line. It is implemented in the; **`TLine`** class. The line constructor is:. ``` {.cpp}; TLine(Double_t x1,Double_t y1,Double_t x2,Double_t y2); ```. The arguments `x1`, `y1`, `x2`, `y2` are the coordinates of the first; and second point. It can be used:. ``` {.cpp}; root",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md:31633,simpl,simple,31633,documentation/users-guide/Graphics.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md,1,['simpl'],['simple']
Usability,"tab. * ``UT_ForIndentation`` (in configuration: ``ForIndentation``); Use tabs only for indentation. * ``UT_ForContinuationAndIndentation`` (in configuration: ``ForContinuationAndIndentation``); Fill all leading whitespace with tabs, and use spaces for alignment that; appears within a line (e.g. consecutive assignments and declarations). * ``UT_AlignWithSpaces`` (in configuration: ``AlignWithSpaces``); Use tabs for line continuation and indentation, and spaces for; alignment. * ``UT_Always`` (in configuration: ``Always``); Use tabs whenever we need to fill whitespace that spans at least from; one tab stop to the next one. .. _VerilogBreakBetweenInstancePorts:. **VerilogBreakBetweenInstancePorts** (``Boolean``) :versionbadge:`clang-format 17` :ref:`¶ <VerilogBreakBetweenInstancePorts>`; For Verilog, put each port on its own line in module instantiations. .. code-block:: c++. true:; ffnand ff1(.q(),; .qbar(out1),; .clear(in1),; .preset(in2));. false:; ffnand ff1(.q(), .qbar(out1), .clear(in1), .preset(in2));. .. _WhitespaceSensitiveMacros:. **WhitespaceSensitiveMacros** (``List of Strings``) :versionbadge:`clang-format 11` :ref:`¶ <WhitespaceSensitiveMacros>`; A vector of macros which are whitespace-sensitive and should not; be touched. These are expected to be macros of the form:. .. code-block:: c++. STRINGIZE(...). In the .clang-format configuration file, this can be configured like:. .. code-block:: yaml. WhitespaceSensitiveMacros: ['STRINGIZE', 'PP_STRINGIZE']. For example: BOOST_PP_STRINGIZE. .. END_FORMAT_STYLE_OPTIONS. Adding additional style options; ===============================. Each additional style option adds costs to the clang-format project. Some of; these costs affect the clang-format development itself, as we need to make; sure that any given combination of options work and that new features don't; break any of the existing options in any way. There are also costs for end users; as options become less discoverable and people have to think about and m",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:133142,clear,clear,133142,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,1,['clear'],['clear']
Usability,"table entries, so that addresses taken outside the module will pass; any verification done inside the module. In more concrete terms, suppose we have three functions ``f``, ``g``,; ``h`` which are all of the same type, and a function foo that returns their; addresses:. .. code-block:: none. f:; mov 0, %eax; ret. g:; mov 1, %eax; ret. h:; mov 2, %eax; ret. foo:; mov f, %eax; mov g, %edx; mov h, %ecx; ret. Our jump table will (conceptually) look like this:. .. code-block:: none. f:; jmp .Ltmp0 ; 5 bytes; int3 ; 1 byte; int3 ; 1 byte; int3 ; 1 byte. g:; jmp .Ltmp1 ; 5 bytes; int3 ; 1 byte; int3 ; 1 byte; int3 ; 1 byte. h:; jmp .Ltmp2 ; 5 bytes; int3 ; 1 byte; int3 ; 1 byte; int3 ; 1 byte. .Ltmp0:; mov 0, %eax; ret. .Ltmp1:; mov 1, %eax; ret. .Ltmp2:; mov 2, %eax; ret. foo:; mov f, %eax; mov g, %edx; mov h, %ecx; ret. Because the addresses of ``f``, ``g``, ``h`` are evenly spaced at a power of; 2, and function types do not overlap (unlike class types with base classes),; we can normally apply the `Alignment`_ and `Eliminating Bit Vector Checks; for All-Ones Bit Vectors`_ optimizations thus simplifying the check at each; call site to a range and alignment check. Shared library support; ======================. **EXPERIMENTAL**. The basic CFI mode described above assumes that the application is a; monolithic binary; at least that all possible virtual/indirect call; targets and the entire class hierarchy are known at link time. The; cross-DSO mode, enabled with **-f[no-]sanitize-cfi-cross-dso** relaxes; this requirement by allowing virtual and indirect calls to cross the; DSO boundary. Assuming the following setup: the binary consists of several; instrumented and several uninstrumented DSOs. Some of them may be; dlopen-ed/dlclose-d periodically, even frequently. - Calls made from uninstrumented DSOs are not checked and just work.; - Calls inside any instrumented DSO are fully protected.; - Calls between different instrumented DSOs are also protected, with; a performance pen",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ControlFlowIntegrityDesign.rst:18538,simpl,simplifying,18538,interpreter/llvm-project/clang/docs/ControlFlowIntegrityDesign.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ControlFlowIntegrityDesign.rst,1,['simpl'],['simplifying']
Usability,"tainer limits. Suppose we want to position the; same box inside 2 different volumes and we want the Z size to match the; one of each container:. ``` {.cpp}; TGeoVolume *container1 = gGeoManager->MakeBox(""C1"",imed,10,10,30);; TGeoVolume *container2 = gGeoManager->MakeBox(""C2"",imed,10,10,20);; TGeoVolume *pvol = gGeoManager->MakeBox(""PVOL"",jmed,3,3,-1);; container1->AddNode(pvol,1);; container2->AddNode(pvol,1);; ```. Note that the third parameter of `PVOL` is negative, which does not make; sense as half-length on Z. This is interpreted as: when positioned,; create a box replacing all invalid parameters with the corresponding; dimensions of the container. This is also internally handled by the; **`TGeoVolumeMulti`** class, which does not need to be instantiated by; users. #### Dividing Volumes. Volumes can be divided according a pattern. The simplest division can be; done along one axis that can be: `X,Y,Z,Phi,Rxy or Rxyz`. Let's take a; simple case: we would like to divide a box in N equal slices along X; coordinate, representing a new volume family. Supposing we already have; created the initial box, this can be done like:. ``` {.cpp}; TGeoVolume *slicex = box->Divide(""SLICEX"",1,N);; ```. Here `SLICEX` is the name of the new family representing all slices and; 1 is the slicing axis. The meaning of the axis index is the following:; for all volumes having shapes like `box`, `trd1`, `trd2`, `trap`,; `gtra `or` para - `1, 2, 3 mean X, Y, Z; for `tube`, `tubs`, `cone`,; `cons - `1 means `Rxy`, 2 means `phi` and 3 means Z; for `pcon` and; `pgon` - 2 means `phi` and 3 means Z; for spheres 1 means `R `and 2; means `phi.`. In fact, the division operation has the same effect as positioning; volumes in a given order inside the divided container - the advantage; being that the navigation in such a structure is much faster. When a; volume is divided, a volume family corresponding to the slices is; created. In case all slices can be represented by a single shape, only; one volume",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:83956,simpl,simple,83956,documentation/users-guide/Geometry.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md,1,['simpl'],['simple']
Usability,"tall standard binary operators.; // 1 is lowest precedence.; BinopPrecedence['<'] = 10;; BinopPrecedence['+'] = 20;; BinopPrecedence['-'] = 20;; BinopPrecedence['*'] = 40; // highest. // Prime the first token.; fprintf(stderr, ""ready> "");; getNextToken();. TheJIT = std::make_unique<KaleidoscopeJIT>();. // Run the main ""interpreter loop"" now.; MainLoop();. return 0;; }. We also need to setup the data layout for the JIT:. .. code-block:: c++. void InitializeModuleAndPassManager(void) {; // Open a new context and module.; TheContext = std::make_unique<LLVMContext>();; TheModule = std::make_unique<Module>(""my cool jit"", TheContext);; TheModule->setDataLayout(TheJIT->getDataLayout());. // Create a new builder for the module.; Builder = std::make_unique<IRBuilder<>>(*TheContext);. // Create a new pass manager attached to it.; TheFPM = std::make_unique<legacy::FunctionPassManager>(TheModule.get());; ... The KaleidoscopeJIT class is a simple JIT built specifically for these; tutorials, available inside the LLVM source code; at `llvm-src/examples/Kaleidoscope/include/KaleidoscopeJIT.h; <https://github.com/llvm/llvm-project/blob/main/llvm/examples/Kaleidoscope/include/KaleidoscopeJIT.h>`_.; In later chapters we will look at how it works and extend it with; new features, but for now we will take it as given. Its API is very simple:; ``addModule`` adds an LLVM IR module to the JIT, making its functions; available for execution (with its memory managed by a ``ResourceTracker``); and; ``lookup`` allows us to look up pointers to the compiled code. We can take this simple API and change our code that parses top-level expressions to; look like this:. .. code-block:: c++. static ExitOnError ExitOnErr;; ...; static void HandleTopLevelExpression() {; // Evaluate a top-level expression into an anonymous function.; if (auto FnAST = ParseTopLevelExpr()) {; if (FnAST->codegen()) {; // Create a ResourceTracker to track JIT'd memory allocated to our; // anonymous expression -- that way we ca",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl04.rst:11841,simpl,simple,11841,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl04.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl04.rst,1,['simpl'],['simple']
Usability,"tasets are no cloned for fit operations to save time and memory.; This change in procedure should save some time and memory, especially in toy MC; studies where the overhead in setting up the likelihood can dominate the total; time spent in fitting. The data cloning behavior of RooAbsPdf::fitTo(); and RooAbsPdf::createNLL() can be explicitly set through the CloneData(); named argument; It is now possible to construct a RooSimultaneous p.d.f. from other; RooSimultaneous p.d.f.s, provided the constructor form is used that takes; all input p.d.f.s. In this constructor simultaneous-of-simultaneous p.d.f.s are automatically; recast to an equivalent top-level simultaneous p.d.f; Sim of sim now possible; Several improvements were made in the internal handling of datasets that; will speedup certain data intensive operations. RooStats; New Tutorials. Several new tutorials were added for RooStats. rs101_limitexample.C Demonstrates use of Frequentist,; Bayesian, and Likelihood intervals for a simple number counting experiment; with uncertainty on signal and background rates.; rs301_splot.C Demonstrates use of RooStats sPlot; implementation; rs401c_FeldmanCousins.C Demonstrates use of; FeldmanCousins interval calculator with a Poisson problem, reproduces; results from table IV and V of the original; paper�Phys.Rev.D57:3873-3889,1998.; rs401d_FeldmanCousins.C Demonstrates use of; FeldmanCousins interval calculator with the neutrino oscillation toy; example described in the original paper�Phys.Rev.D57:3873-3889,1998.; Reproduces figure 12.; rs_bernsteinCorrection.C Demonstrates use of; BernsteinCorrection class, which corrects a nominal PDF with a polynomial; to agree with observed or simulated data. TestStatistic interface and implementations; We added a new interface class called TestStatistic. It defines the; method Evaluate(data, parameterPoint), which returns a double. �This; class can be used in�conjunction�with the ToyMCSampler class to generate; sampling distributions for",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v524/index.html:25078,simpl,simple,25078,roofit/doc/v524/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v524/index.html,1,['simpl'],['simple']
Usability,"te <typename T> Expected<T> errorOrToExpected(ErrorOr<T> TOrEC);. Using these APIs it is easy to make surgical patches that update individual; functions from ``std::error_code`` to ``Error``, and from ``ErrorOr<T>`` to; ``Expected<T>``. Returning Errors from error handlers; """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""". Error recovery attempts may themselves fail. For that reason, ``handleErrors``; actually recognises three different forms of handler signature:. .. code-block:: c++. // Error must be handled, no new errors produced:; void(UserDefinedError &E);. // Error must be handled, new errors can be produced:; Error(UserDefinedError &E);. // Original error can be inspected, then re-wrapped and returned (or a new; // error can be produced):; Error(std::unique_ptr<UserDefinedError> E);. Any error returned from a handler will be returned from the ``handleErrors``; function so that it can be handled itself, or propagated up the stack. .. _err_exitonerr:. Using ExitOnError to simplify tool code; """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""". Library code should never call ``exit`` for a recoverable error, however in tool; code (especially command line tools) this can be a reasonable approach. Calling; ``exit`` upon encountering an error dramatically simplifies control flow as the; error no longer needs to be propagated up the stack. This allows code to be; written in straight-line style, as long as each fallible call is wrapped in a; check and call to exit. The ``ExitOnError`` class supports this pattern by; providing call operators that inspect ``Error`` values, stripping the error away; in the success case and logging to ``stderr`` then exiting in the failure case. To use this class, declare a global ``ExitOnError`` variable in your program:. .. code-block:: c++. ExitOnError ExitOnErr;. Calls to fallible functions can then be wrapped with a call to ``ExitOnErr``,; turning them into non-failing calls:. .. code-block:: c++. Error mayFail();; Expected<int> mayFail2();. void foo() {;",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:30345,simpl,simplify,30345,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,1,['simpl'],['simplify']
Usability,"te `presplitcoroutine` for the coroutine. 'llvm.coro.id.retcon.once' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^; ::. declare token @llvm.coro.id.retcon.once(i32 <size>, i32 <align>, ptr <buffer>,; ptr <prototype>,; ptr <alloc>, ptr <dealloc>). Overview:; """""""""""""""""". The '``llvm.coro.id.retcon.once``' intrinsic returns a token identifying a; unique-suspend returned-continuation coroutine. Arguments:; """""""""""""""""""". As for ``llvm.core.id.retcon``, except that the return type of the; continuation prototype must represent the normal return type of the continuation; (instead of matching the coroutine's return type). Semantics:; """""""""""""""""""". A frontend should emit function attribute `presplitcoroutine` for the coroutine. .. _coro.end:. 'llvm.coro.end' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^; ::. declare i1 @llvm.coro.end(ptr <handle>, i1 <unwind>, token <result.token>). Overview:; """""""""""""""""". The '``llvm.coro.end``' marks the point where execution of the resume part of; the coroutine should end and control should return to the caller. Arguments:; """""""""""""""""""". The first argument should refer to the coroutine handle of the enclosing; coroutine. A frontend is allowed to supply null as the first parameter, in this; case `coro-early` pass will replace the null with an appropriate coroutine; handle value. The second argument should be `true` if this coro.end is in the block that is; part of the unwind sequence leaving the coroutine body due to an exception and; `false` otherwise. Non-trivial (non-none) token argument can only be specified for unique-suspend; returned-continuation coroutines where it must be a token value produced by; '``llvm.coro.end.results``' intrinsic. Only none token is allowed for coro.end calls in unwind sections. Semantics:; """"""""""""""""""""; The purpose of this intrinsic is to allow frontends to mark the cleanup and; other code that is only relevant during the initial invocation of the coroutine; and should not be present in resume and destr",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst:42553,resume,resume,42553,interpreter/llvm-project/llvm/docs/Coroutines.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst,1,['resume'],['resume']
Usability,"te information and is retaining the types as written by the user (e.g., ""servers::Server"", ""::services::WebService""):. $ clang -fsyntax-only t.cpp; t.cpp:9:10: error: invalid operands to binary expression ('servers::Server const' and '::services::WebService const *'); server += http;; ~~~~~~ ^ ~~~~. Naturally, type preservation extends to uses of templates, and Clang retains information about how a particular template specialization (like std::vector<Real>) was spelled within the source code. For example:. $ clang -fsyntax-only t.cpp; t.cpp:12:7: error: incompatible type assigning 'vector<Real>', expected 'std::string' (aka 'class std::basic_string<char>'); str = vec;; ^ ~~~. Fix-it Hints; ""Fix-it"" hints provide advice for fixing small, localized problems; in source code. When Clang produces a diagnostic about a particular; problem that it can work around (e.g., non-standard or redundant; syntax, missing keywords, common mistakes, etc.), it may also provide; specific guidance in the form of a code transformation to correct the; problem. In the following example, Clang warns about the use of a GCC; extension that has been considered obsolete since 1993. The underlined; code should be removed, then replaced with the code below the; point line ("".x ="" or "".y ="", respectively). $ clang t.c; t.c:5:28: warning: use of GNU old-style field designator extension; struct point origin = { x: 0.0, y: 0.0 };; ~~ ^; .x = ; t.c:5:36: warning: use of GNU old-style field designator extension; struct point origin = { x: 0.0, y: 0.0 };; ~~ ^; .y = . ""Fix-it"" hints are most useful for; working around common user errors and misconceptions. For example, C++ users; commonly forget the syntax for explicit specialization of class templates,; as in the error in the following example. Again, after describing the problem,; Clang provides the fix--add template<>--as part of the; diagnostic. $ clang t.cpp; t.cpp:9:3: error: template specialization requires 'template<>'; struct iterator_traits<file",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/diagnostics.html:6428,guid,guidance,6428,interpreter/llvm-project/clang/www/diagnostics.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/diagnostics.html,1,['guid'],['guidance']
Usability,"tecture or designing a; :program:`lit` testing implementation should see :ref:`lit-infrastructure`. GENERAL OPTIONS; ---------------. .. option:: -h, --help. Show the :program:`lit` help message. .. option:: -j N, --workers=N. Run ``N`` tests in parallel. By default, this is automatically chosen to; match the number of detected available CPUs. .. option:: --config-prefix=NAME. Search for :file:`{NAME}.cfg` and :file:`{NAME}.site.cfg` when searching for; test suites, instead of :file:`lit.cfg` and :file:`lit.site.cfg`. .. option:: -D NAME[=VALUE], --param NAME[=VALUE]. Add a user defined parameter ``NAME`` with the given ``VALUE`` (or the empty; string if not given). The meaning and use of these parameters is test suite; dependent. .. _output-options:. OUTPUT OPTIONS; --------------. .. option:: -q, --quiet. Suppress any output except for test failures. .. option:: -s, --succinct. Show less output, for example don't show information on tests that pass.; Also show a progress bar, unless ``--no-progress-bar`` is specified. .. option:: -v, --verbose. Show more information on test failures, for example the entire test output; instead of just the test result. Each command is printed before it is executed. This can be valuable for; debugging test failures, as the last printed command is the one that failed.; Moreover, :program:`lit` inserts ``'RUN: at line N'`` before each; command pipeline in the output to help you locate the source line of; the failed command. .. option:: -vv, --echo-all-commands. Deprecated alias for -v. .. option:: -a, --show-all. Enable -v, but for all tests not just failed tests. .. option:: --no-progress-bar. Do not use curses based progress bar. .. option:: --show-unsupported. Show the names of unsupported tests. .. option:: --show-xfail. Show the names of tests that were expected to fail. .. _execution-options:. EXECUTION OPTIONS; -----------------. .. option:: --path=PATH. Specify an additional ``PATH`` to use when searching for executables in te",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/lit.rst:3199,progress bar,progress bar,3199,interpreter/llvm-project/llvm/docs/CommandGuide/lit.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/lit.rst,1,['progress bar'],['progress bar']
Usability,"ted from memory, the corresponding CINT namespace; is removed as well. Note that this feature is strictly available in interpreted C++ only; A new tutorial macro has been added to illustrate this functionality in more detail: rf509_wsinteractive.C.; writeToFile -- A new utility method RooWorkspace::writeToFile() has been added; to simplify the process of saving a workspace to file; Named sets and parameter snapshots -- It is now possible to define and retrieve; named RooArgSets of objects that live in the workspace through methods; defineSet() and set(). While named sets merely group objects logically, methods loadSnapshot and; saveSnapshot allow to make copies of the values, errors and 'constant' status of; sets of variable objects that live in the workspace. A newly added tutorial macro rf510_namedsets.C illustrates the functionality of both; of these features.; Improved printing of contents -- Many operator p.d.f. and function components now show; a more intuitive natural representation of their contents (these changes are mostly in the; respective p.d.f.s, but are most relevant in the context of a workspace). New object factory interface to workspace to facilitate script driven model definition; A object factory has been added to RooFit to simplify the process of creating p.d.f.; and function expressions consisting of multiple objects. The factory has two goals:; the first is to provide a back-end for higher level factories and tools to process; the creation of objects. The second is to provide a simple end-user language to; populate a RooWorkspace with function and p.d.f. objects. For the latter purpose the object creation language is executed through the factory() method; of a workspace object. RooWorkspace w(""w"") ;; RooAbsArg* arg = w.factory(""expression_goes_here"") ;. Basic Syntax; The rules at its simplest level are as follows. Expressions with square brackets create variables (discrete and continuous). ""m[-10,10]"" - Creates a RooRealVar named 'm' with rang",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v524/index.html:17902,intuit,intuitive,17902,roofit/doc/v524/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v524/index.html,1,['intuit'],['intuitive']
Usability,"ted. To prevent this, make sure that the code is actually needed. For example, if; you are computing some expression, return the value from the function instead; of leaving it in a local variable. If you really want to constrain the; optimizer, you can read from and assign to ``volatile`` global variables. What is this ""``undef``"" thing that shows up in my code?; --------------------------------------------------------; ``undef`` is the LLVM way of representing a value that is not defined. You; can get these if you do not initialize a variable before you use it. For; example, the C function:. .. code-block:: c. int X() { int i; return i; }. Is compiled to ""``ret i32 undef``"" because ""``i``"" never has a value specified; for it. Why does instcombine + simplifycfg turn a call to a function with a mismatched calling convention into ""unreachable""? Why not make the verifier reject it?; ----------------------------------------------------------------------------------------------------------------------------------------------------------; This is a common problem run into by authors of front-ends that are using; custom calling conventions: you need to make sure to set the right calling; convention on both the function and on each call to the function. For; example, this code:. .. code-block:: llvm. define fastcc void @foo() {; ret void; }; define void @bar() {; call void @foo(); ret void; }. Is optimized to:. .. code-block:: llvm. define fastcc void @foo() {; ret void; }; define void @bar() {; unreachable; }. ... with ""``opt -instcombine -simplifycfg``"". This often bites people because; ""all their code disappears"". Setting the calling convention on the caller and; callee is required for indirect calls to work, so people often ask why not; make the verifier reject this sort of thing. The answer is that this code has undefined behavior, but it is not illegal.; If we made it illegal, then every transformation that could potentially create; this would have to ensure that it do",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/FAQ.rst:9046,simpl,simplifycfg,9046,interpreter/llvm-project/llvm/docs/FAQ.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/FAQ.rst,1,['simpl'],['simplifycfg']
Usability,"template pattern parameterized over the load upper immediate; instruction, add operation, the zero register, and register class.; Here the instantiation of MipsHiLoRelocs in MipsInstrInfo.td is used; to MIPS32 to compute addresses for the static relocation model. // lib/Target/Mips/MipsInstrInfo.td; multiclass MipsHiLoRelocs<Instruction Lui, Instruction Addiu,; Register ZeroReg, RegisterOperand GPROpnd> {; def : MipsPat<(MipsHi tglobaladdr:$in), (Lui tglobaladdr:$in)>;; ...; def : MipsPat<(MipsLo tglobaladdr:$in), (Addiu ZeroReg, tglobaladdr:$in)>;; ...; def : MipsPat<(add GPROpnd:$hi, (MipsLo tglobaladdr:$lo)),; (Addiu GPROpnd:$hi, tglobaladdr:$lo)>;; ...; }; defm : MipsHiLoRelocs<LUi, ADDiu, ZERO, GPR32Opnd>;. // lib/Target/Mips/Mips64InstrInfo.td; defm : MipsHiLoRelocs<LUi64, DADDiu, ZERO_64, GPR64Opnd>, SYM_32;. The instantiation in Mips64InstrInfo.td is used for MIPS64 in ILP32; mode, as guarded by the predicate ""SYM_32"" and also for a submode of; LP64 where symbols are assumed to be 32 bits wide. More details on how multiclasses in TableGen work can be found in the; section ""Multiclass definitions and instances"" in the document; ""TableGen Language Introduction"". 4. Instruction definitions are multiply defined to cover the different; register classes. In some cases, such as LW/LW64, this also accounts; for the difference in the results of instruction execution. On MIPS32,; ""lw"" loads a 32 bit value from memory. On MIPS64, ""lw"" loads a 32 bit; value from memory and sign extends the value to 64 bits. // lib/Target/Mips/MipsInstrInfo.td; def LUi : MMRel, LoadUpper<""lui"", GPR32Opnd, uimm16_relaxed>, LUI_FM;; // lib/Target/Mips/Mips64InstrInfo.td; def LUi64 : LoadUpper<""lui"", GPR64Opnd, uimm16_64_relaxed>, LUI_FM;. defines two names ""LUi"" and ""LUi64"" with two different register; classes, but with the same encoding---""LUI_FM"". These instructions load a; 16-bit immediate into bits 31-16 and clear the lower 15 bits. On MIPS64,; the result is sign-extended to 64 bits.; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/Relocation.txt:3809,clear,clear,3809,interpreter/llvm-project/llvm/lib/Target/Mips/Relocation.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/Relocation.txt,1,['clear'],['clear']
Usability,"tentially relocated pointer is observably-after a; safepoint which could relocate it. 'observably-after' is this usage; means that an outside observer could observe this sequence of events; in a way which precludes the operation being performed before the; safepoint. To understand why this 'observable-after' property is required,; consider a null comparison performed on the original copy of a; relocated pointer. Assuming that control flow follows the safepoint,; there is no way to observe externally whether the null comparison is; performed before or after the safepoint. (Remember, the original; Value is unmodified by the safepoint.) The compiler is free to make; either scheduling choice. The actual correctness property implemented is slightly stronger than; this. We require that there be no *static path* on which a; potentially relocated pointer is 'observably-after' it may have been; relocated. This is slightly stronger than is strictly necessary (and; thus may disallow some otherwise valid programs), but greatly; simplifies reasoning about correctness of the compiled code. By construction, this property will be upheld by the optimizer if; correctly established in the source IR. This is a key invariant of; the design. The existing IR Verifier pass has been extended to check most of the; local restrictions on the intrinsics mentioned in their respective; documentation. The current implementation in LLVM does not check the; key relocation invariant, but this is ongoing work on developing such; a verifier. Please ask on llvm-dev if you're interested in; experimenting with the current version. .. _statepoint-utilities:. Utility Passes for Safepoint Insertion; ======================================. .. _RewriteStatepointsForGC:. RewriteStatepointsForGC; ^^^^^^^^^^^^^^^^^^^^^^^^. The pass RewriteStatepointsForGC transforms a function's IR to lower from the; abstract machine model described above to the explicit statepoint model of; relocations. To do this, it replaces al",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Statepoints.rst:24578,simpl,simplifies,24578,interpreter/llvm-project/llvm/docs/Statepoints.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Statepoints.rst,1,['simpl'],['simplifies']
Usability,"termine the loop depth of; various nodes of the CFG. Note that the loops identified may actually be; several natural loops that share the same header node... not just a single; natural loop. ``memdep``: Memory Dependence Analysis; --------------------------------------. An analysis that determines, for a given memory operation, what preceding; memory operations it depends on. It builds on alias analysis information, and; tries to provide a lazy, caching interface to a common kind of alias; information query. ``module-debuginfo``: Decodes module-level debug info; -----------------------------------------------------. This pass decodes the debug info metadata in a module and prints in a; (sufficiently-prepared-) human-readable form. For example, run this pass from ``opt`` along with the ``-analyze`` option, and; it'll print to standard output. ``postdomtree``: Post-Dominator Tree Construction; -------------------------------------------------. This pass is a simple post-dominator construction algorithm for finding; post-dominators. ``print-alias-sets``: Alias Set Printer; ---------------------------------------. Yet to be written. ``print-callgraph``: Print a call graph; ---------------------------------------. This pass, only available in ``opt``, prints the call graph to standard error; in a human-readable form. ``print-callgraph-sccs``: Print SCCs of the Call Graph; ------------------------------------------------------. This pass, only available in ``opt``, prints the SCCs of the call graph to; standard error in a human-readable form. ``print-cfg-sccs``: Print SCCs of each function CFG; ---------------------------------------------------. This pass, only available in ``opt``, printsthe SCCs of each function CFG to; standard error in a human-readable fom. ``print-function``: Print function to stderr; --------------------------------------------. The ``PrintFunctionPass`` class is designed to be pipelined with other; ``FunctionPasses``, and prints out the functions ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Passes.rst:8781,simpl,simple,8781,interpreter/llvm-project/llvm/docs/Passes.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Passes.rst,1,['simpl'],['simple']
Usability,"tes. In previous versions, it could sometime return `kEntryNotFound` even for well-behaved event loops.; - Add `TEntryList::AddSubList` to specifically add a sub-list to the main list of entries. Consequently, add also a new option `""sync""` in `TChain::SetEntryList` to connect the sub-trees of the chain to the sub-lists of the entry list in lockstep (PR [#8660](https://github.com/root-project/root/pull/8660)).; - Add `TEntryList::EnterRange` to add all entries in a certain range `[start, end)` to the entry list (PR [#8740](https://github.com/root-project/root/pull/8740)). ## RNTuple. ROOT's experimental successor of TTree has been upgraded to the version 1 of the binary format specification. Compared to the v0 format, the header is ~40% smaller and the footer ~100% smaller (after zstd compression). More details in PR [#8897](https://github.com/root-project/root/pull/8897).; RNTuple is still experimental and is scheduled to become production grade in 2024. Thus, we appreciate feedback and suggestions for improvement. If you have been trying RNTuple for a while, these are the other important changes that you will notice:. - Support for aligned friends (PR [#6979](https://github.com/root-project/root/pull/6979)). Refer to the `RNTupleReader::OpenFriends()` function.; - Cluster and page sizes in `RNTupleWriteOptions` now refer to their target size in bytes (as opposed to the number of entries). Defaults are 64 kB for the page size and 50 MB for the cluster size (PR [#8703](https://github.com/root-project/root/pull/8703)).; - Storing objects of user-defined classes via `TClass` now also includes members inherited from all the base classes (PR [#8552](https://github.com/root-project/root/pull/8552)).; - Support for RFields whose type is a typedef to some other type. ## RDataFrame. ### New features. - Add [`Redefine`](https://root.cern/doc/master/classROOT_1_1RDF_1_1RInterface.html#a4e882a949c8a1022a38ec6936c2ff29c) to the `RDataFrame` interface, which allows to overwrite ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v626/index.md:6338,feedback,feedback,6338,README/ReleaseNotes/v626/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v626/index.md,1,['feedback'],['feedback']
Usability,"text. (inst operand0, operand1, ...). ``inst`` must be a def which inherits from ``Instruction`` (e.g. ``G_FADD``); or ``GICombinePatFrag``. Operands essentially fall into one of two categories:. * immediates. * untyped, unnamed: ``0``; * untyped, named: ``0:$y``; * typed, unnamed: ``(i32 0)``; * typed, named: ``(i32 0):$y``. * machine operands. * untyped: ``$x``; * typed: ``i32:$x``. Semantics:. * A typed operand always adds an operand type check to the matcher.; * There is a trivial type inference system to propagate types. * e.g. You only need to use ``i32:$x`` once in any pattern of a; ``GICombinePatFrag`` alternative or ``GICombineRule``, then all; other patterns in that rule/alternative can simply use ``$x``; (``i32:$x`` is redundant). * A named operand's behavior depends on whether the name has been seen before. * For match patterns, reusing an operand name checks that the operands; are identical (see example 2 below).; * For apply patterns, reusing an operand name simply copies that operand into; the new instruction (see example 2 below). Operands are ordered just like they would be in a MachineInstr: the defs (outs); come first, then the uses (ins). Patterns are generally grouped into another DAG datatype with a dummy operator; such as ``match``, ``apply`` or ``pattern``. Finally, any DAG datatype in TableGen can be named. This also holds for; patterns. e.g. the following is valid: ``(G_FOO $root, (i32 0):$cst):$mypat``.; This may also be helpful to debug issues. Patterns are *always* named, and if; they don't have a name, an ""anonymous"" one is given to them. If you're trying; to debug an error related to a MIR pattern, but the error mentions an anonymous; pattern, you can try naming your patterns to see exactly where the issue is. .. code-block:: text; :caption: Pattern Example 1. // Match; // %imp = G_IMPLICIT_DEF; // %root = G_MUL %x, %imp; (match (G_IMPLICIT_DEF $imp),; (G_MUL $root, $x, $imp)). .. code-block:: text; :caption: Pattern Example 2. // using",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GlobalISel/MIRPatterns.rst:1615,simpl,simply,1615,interpreter/llvm-project/llvm/docs/GlobalISel/MIRPatterns.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GlobalISel/MIRPatterns.rst,1,['simpl'],['simply']
Usability,"text;. // Initialize the driver API; cuInit(0);; // Get a handle to the first compute device; cuDeviceGet(&device, 0);; // Create a compute device context; cuCtxCreate(&context, 0, device);. JIT compiling a PTX string to a device binary:. .. code-block:: c++. CUmodule module;; CUfunction function;. // JIT compile a null-terminated PTX string; cuModuleLoadData(&module, (void*)PTXString);. // Get a handle to the ""myfunction"" kernel function; cuModuleGetFunction(&function, module, ""myfunction"");. For full examples of executing PTX assembly, please see the `CUDA Samples; <https://developer.nvidia.com/cuda-downloads>`_ distribution. Common Issues; =============. ptxas complains of undefined function: __nvvm_reflect; -----------------------------------------------------. When linking with libdevice, the ``NVVMReflect`` pass must be used. See; :ref:`libdevice` for more information. Tutorial: A Simple Compute Kernel; =================================. To start, let us take a look at a simple compute kernel written directly in; LLVM IR. The kernel implements vector addition, where each thread computes one; element of the output vector C from the input vectors A and B. To make this; easier, we also assume that only a single CTA (thread block) will be launched,; and that it will be one dimensional. The Kernel; ----------. .. code-block:: llvm. target datalayout = ""e-p:64:64:64-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64-f32:32:32-f64:64:64-v16:16:16-v32:32:32-v64:64:64-v128:128:128-n16:32:64""; target triple = ""nvptx64-nvidia-cuda"". ; Intrinsic to read X component of thread ID; declare i32 @llvm.nvvm.read.ptx.sreg.tid.x() readnone nounwind. define void @kernel(float addrspace(1)* %A,; float addrspace(1)* %B,; float addrspace(1)* %C) {; entry:; ; What is my ID?; %id = tail call i32 @llvm.nvvm.read.ptx.sreg.tid.x() readnone nounwind. ; Compute pointers into A, B, and C; %ptrA = getelementptr float, float addrspace(1)* %A, i32 %id; %ptrB = getelementptr float, float addrspace(1)* ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/NVPTXUsage.rst:12522,simpl,simple,12522,interpreter/llvm-project/llvm/docs/NVPTXUsage.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/NVPTXUsage.rst,1,['simpl'],['simple']
Usability,"text;; ...; }. char *context_projection_function(struct async_context *callee_ctxt) {; return callee_ctxt->caller_context;; }. .. code-block:: llvm. %resume_func_ptr = call ptr @llvm.coro.async.resume(); call {ptr, ptr, ptr} (ptr, ptr, ...) @llvm.coro.suspend.async(; ptr %resume_func_ptr,; ptr %context_projection_function. The frontend should provide a `async function pointer` struct associated with; each async coroutine by `llvm.coro.id.async`'s argument. The initial size and; alignment of the `async context` must be provided as arguments to the; `llvm.coro.id.async` intrinsic. Lowering will update the size entry with the; coroutine frame requirements. The frontend is responsible for allocating the; memory for the `async context` but can use the `async function pointer` struct; to obtain the required size. .. code-block:: c. struct async_function_pointer {; uint32_t relative_function_pointer_to_async_impl;; uint32_t context_size;; }. Lowering will split an async coroutine into a ramp function and one resume; function per suspend point. How control-flow is passed between caller, suspension point, and back to; resume function is left up to the frontend. The suspend point takes a function and its arguments. The function is intended; to model the transfer to the callee function. It will be tail called by; lowering and therefore must have the same signature and calling convention as; the async coroutine. .. code-block:: llvm. call {ptr, ptr, ptr} (ptr, ptr, ...) @llvm.coro.suspend.async(; ptr %resume_func_ptr,; ptr %context_projection_function,; ptr %suspend_function,; ptr %arg1, ptr %arg2, i8 %arg3). Coroutines by Example; =====================. The examples below are all of switched-resume coroutines. Coroutine Representation; ------------------------. Let's look at an example of an LLVM coroutine with the behavior sketched; by the following pseudo-code. .. code-block:: c++. void *f(int n) {; for(;;) {; print(n++);; <suspend> // returns a coroutine handle on first sus",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst:10067,resume,resume,10067,interpreter/llvm-project/llvm/docs/Coroutines.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst,1,['resume'],['resume']
Usability,"th a coroutine object in any of these ways while; it is running has undefined behavior. The coroutine function is split into three functions, representing three; different ways that control can enter the coroutine:. 1. the ramp function that is initially invoked, which takes arbitrary; arguments and returns a pointer to the coroutine object;. 2. a coroutine resume function that is invoked when the coroutine is resumed,; which takes a pointer to the coroutine object and returns `void`;. 3. a coroutine destroy function that is invoked when the coroutine is; destroyed, which takes a pointer to the coroutine object and returns; `void`. Because the resume and destroy functions are shared across all suspend; points, suspend points must store the index of the active suspend in; the coroutine object, and the resume/destroy functions must switch over; that index to get back to the correct point. Hence the name of this; lowering. Pointers to the resume and destroy functions are stored in the coroutine; object at known offsets which are fixed for all coroutines. A completed; coroutine is represented with a null resume function. There is a somewhat complex protocol of intrinsics for allocating and; deallocating the coroutine object. It is complex in order to allow the; allocation to be elided due to inlining. This protocol is discussed; in further detail below. The frontend may generate code to call the coroutine function directly;; this will become a call to the ramp function and will return a pointer; to the coroutine object. The frontend should always resume or destroy; the coroutine using the corresponding intrinsics. Returned-Continuation Lowering; ------------------------------. In returned-continuation lowering, signaled by the use of; `llvm.coro.id.retcon` or `llvm.coro.id.retcon.once`, some aspects of; the ABI must be handled more explicitly by the frontend. In this lowering, every suspend point takes a list of ""yielded values""; which are returned back to the caller al",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst:4581,resume,resume,4581,interpreter/llvm-project/llvm/docs/Coroutines.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst,1,['resume'],['resume']
Usability,"th=""560"" height=""315"" src=""https://www.youtube.com/embed/VqCkCDFLSsc?vq=hd720"" frameborder=""0"" allowfullscreen></iframe></center>. `Slides <https://llvm.org/devmtg/2013-04/klimek-slides.pdf>`_. Introduction; ============. Clang's AST is different from ASTs produced by some other compilers in; that it closely resembles both the written C++ code and the C++; standard. For example, parenthesis expressions and compile time; constants are available in an unreduced form in the AST. This makes; Clang's AST a good fit for refactoring tools. Documentation for all Clang AST nodes is available via the generated; `Doxygen <https://clang.llvm.org/doxygen>`_. The doxygen online; documentation is also indexed by your favorite search engine, which will; make a search for clang and the AST node's class name usually turn up; the doxygen of the class you're looking for (for example, search for:; clang ParenExpr). Examining the AST; =================. A good way to familiarize yourself with the Clang AST is to actually look; at it on some simple example code. Clang has a builtin AST-dump mode,; which can be enabled with the flag ``-ast-dump``. Let's look at a simple example AST:. ::. $ cat test.cc; int f(int x) {; int result = (x / 42);; return result;; }. # Clang by default is a frontend for many tools; -Xclang is used to pass; # options directly to the C++ frontend.; $ clang -Xclang -ast-dump -fsyntax-only test.cc; TranslationUnitDecl 0x5aea0d0 <<invalid sloc>>; ... cutting out internal declarations of clang ...; `-FunctionDecl 0x5aeab50 <test.cc:1:1, line:4:1> f 'int (int)'; |-ParmVarDecl 0x5aeaa90 <line:1:7, col:11> x 'int'; `-CompoundStmt 0x5aead88 <col:14, line:4:1>; |-DeclStmt 0x5aead10 <line:2:3, col:24>; | `-VarDecl 0x5aeac10 <col:3, col:23> result 'int'; | `-ParenExpr 0x5aeacf0 <col:16, col:23> 'int'; | `-BinaryOperator 0x5aeacc8 <col:17, col:21> 'int' '/'; | |-ImplicitCastExpr 0x5aeacb0 <col:17> 'int' <LValueToRValue>; | | `-DeclRefExpr 0x5aeac68 <col:17> 'int' lvalue ParmVa",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/IntroductionToTheClangAST.rst:1379,simpl,simple,1379,interpreter/llvm-project/clang/docs/IntroductionToTheClangAST.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/IntroductionToTheClangAST.rst,1,['simpl'],['simple']
Usability,"the ""t.c"" input into an object file, two to assemble the; ""t.s"" input, and one to link them together. A rather different compilation pipeline is shown here; in this; example there are two top level actions to compile the input files; into two separate object files, where each object file is built using; ``lipo`` to merge results built for two separate architectures. .. code-block:: console. $ clang -ccc-print-phases -c -arch i386 -arch x86_64 t0.c t1.c; 0: input, ""t0.c"", c; 1: preprocessor, {0}, cpp-output; 2: compiler, {1}, assembler; 3: assembler, {2}, object; 4: bind-arch, ""i386"", {3}, object; 5: bind-arch, ""x86_64"", {3}, object; 6: lipo, {4, 5}, object; 7: input, ""t1.c"", c; 8: preprocessor, {7}, cpp-output; 9: compiler, {8}, assembler; 10: assembler, {9}, object; 11: bind-arch, ""i386"", {10}, object; 12: bind-arch, ""x86_64"", {10}, object; 13: lipo, {11, 12}, object. After this stage is complete the compilation process is divided into; a simple set of actions which need to be performed to produce; intermediate or final outputs (in some cases, like ``-fsyntax-only``,; there is no ""real"" final output). Phases are well known compilation; steps, such as ""preprocess"", ""compile"", ""assemble"", ""link"", etc. #. **Bind: Tool & Filename Selection**. This stage (in conjunction with the Translate stage) turns the tree; of Actions into a list of actual subprocess to run. Conceptually, the; driver performs a top down matching to assign Action(s) to Tools. The; ToolChain is responsible for selecting the tool to perform a; particular action; once selected the driver interacts with the tool; to see if it can match additional actions (for example, by having an; integrated preprocessor). Once Tools have been selected for all actions, the driver determines; how the tools should be connected (for example, using an inprocess; module, pipes, temporary files, or user provided filenames). If an; output file is required, the driver also computes the appropriate; file name (the suffix and fil",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DriverInternals.rst:8219,simpl,simple,8219,interpreter/llvm-project/clang/docs/DriverInternals.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DriverInternals.rst,1,['simpl'],['simple']
Usability,"the RooFit::makeOwningPtr<T>() helper to translate the; // std::unique_ptr to the actual return type (either std::unique_ptr<T> or T*).; return RooFit::makeOwningPtr<RooAbsReal>(std::move(integral));; }; ```. The biggest application of the memory-safe interfaces is to spot memory leaks; in RooFit-based frameworks. If you make sure that your framework compiles both; with and without `ROOFIT_MEMORY_SAFE_INTERFACES`, you can get rid of all memory; leaks related to RooFit user error! After making the necessary changes, you can; remove the marco definition again to keep backwards compatibility. Note that the memory-safe interfaces might become the default at some point, so; doing this **backwards-compatible migration early** is strongly encouraged and; appreciated. ### Removal of some memory-unsafe interfaces. * The final `bool takeOwnership` parameter of the **RooAddition** and; **RooStats::HistFactory::PiecewiseInterpolation** constructors was removed.; This is to avoid situations where ownership is not clear to the compiler.; Now, ownership of the input RooAbsArgs is never passed in the constructor. If; you want the pass input ownership to the created object, please use; `addOwnedComponents`. If you want to be extra safe, make sure the inputs are; in an owning collection and then `std::move` the collection, so that the; ownership is always clear. Example:; ```c++; RooArgList sumSet;; sumSet.add(*(new RooRealVar(""var1"", ""var1"", 1.0)));; sumSet.add(*(new RooRealVar(""var2"", ""var2"", 3.0)));; RooAddition addition{""addition"", ""addition"", sumSet, /*takeOwnership=*/true};; ```; should become:; ```c++; RooArgList sumSet;; sumSet.addOwned(std::make_unique<RooRealVar>(""var1"", ""var1"", 1.0));; sumSet.addOwned(std::make_unique<RooRealVar>(""var2"", ""var2"", 3.0));; RooAddition addition{""addition"", ""addition"", sumSet};; addition.addOwnedComponents(std::move(sumSet));; ```. ### Deprecation of legacy iterators. The following methods related to the RooFit legacy iterators are deprecated an",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v632/index.md:10851,clear,clear,10851,README/ReleaseNotes/v632/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v632/index.md,1,['clear'],['clear']
Usability,"the bookkeeping and to facilitate *O(1)* addition and; removal. .. _Use2User:. Interaction and relationship between ``User`` and ``Use`` objects; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. A subclass of ``User`` can choose between incorporating its ``Use`` objects or; refer to them out-of-line by means of a pointer. A mixed variant (some ``Use``; s inline others hung off) is impractical and breaks the invariant that the; ``Use`` objects belonging to the same ``User`` form a contiguous array. We have 2 different layouts in the ``User`` (sub)classes:. * Layout a). The ``Use`` object(s) are inside (resp. at fixed offset) of the ``User``; object and there are a fixed number of them. * Layout b). The ``Use`` object(s) are referenced by a pointer to an array from the; ``User`` object and there may be a variable number of them. As of v2.4 each layout still possesses a direct pointer to the start of the; array of ``Use``\ s. Though not mandatory for layout a), we stick to this; redundancy for the sake of simplicity. The ``User`` object also stores the; number of ``Use`` objects it has. (Theoretically this information can also be; calculated given the scheme presented below.). Special forms of allocation operators (``operator new``) enforce the following; memory layouts:. * Layout a) is modelled by prepending the ``User`` object by the ``Use[]``; array. .. code-block:: none. ...---.---.---.---.-------...; | P | P | P | P | User; '''---'---'---'---'-------'''. * Layout b) is modelled by pointing at the ``Use[]`` array. .. code-block:: none. .-------...; | User; '-------'''; |; v; .---.---.---.---...; | P | P | P | P |; '---'---'---'---'''. *(In the above figures* '``P``' *stands for the* ``Use**`` *that is stored in; each* ``Use`` *object in the member* ``Use::Prev`` *)*. .. _polymorphism:. Designing Type Hierarchies and Polymorphic Interfaces; -----------------------------------------------------. There are two different design patterns that tend to re",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:128076,simpl,simplicity,128076,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,1,['simpl'],['simplicity']
Usability,"the coroutine handle of the enclosing; coroutine. A frontend is allowed to supply null as the first parameter, in this; case `coro-early` pass will replace the null with an appropriate coroutine; handle value. The second argument should be `true` if this coro.end is in the block that is; part of the unwind sequence leaving the coroutine body due to an exception and; `false` otherwise. The third argument if present should specify a function to be called. If the third argument is present, the remaining arguments are the arguments to; the function call. .. code-block:: llvm. call i1 (ptr, i1, ...) @llvm.coro.end.async(; ptr %hdl, i1 0,; ptr @must_tail_call_return,; ptr %ctxt, ptr %task, ptr %actor); unreachable. .. _coro.suspend:; .. _suspend points:. 'llvm.coro.suspend' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^; ::. declare i8 @llvm.coro.suspend(token <save>, i1 <final>). Overview:; """""""""""""""""". The '``llvm.coro.suspend``' marks the point where execution of a; switched-resume coroutine is suspended and control is returned back; to the caller. Conditional branches consuming the result of this; intrinsic lead to basic blocks where coroutine should proceed when; suspended (-1), resumed (0) or destroyed (1). Arguments:; """""""""""""""""""". The first argument refers to a token of `coro.save` intrinsic that marks the; point when coroutine state is prepared for suspension. If `none` token is passed,; the intrinsic behaves as if there were a `coro.save` immediately preceding; the `coro.suspend` intrinsic. The second argument indicates whether this suspension point is `final`_.; The second argument only accepts constants. If more than one suspend point is; designated as final, the resume and destroy branches should lead to the same; basic blocks. Example (normal suspend point):; """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""". .. code-block:: llvm. %0 = call i8 @llvm.coro.suspend(token none, i1 false); switch i8 %0, label %suspend [i8 0, label %resume; i8 1, label %cleanup]. Example (final ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst:49866,resume,resume,49866,interpreter/llvm-project/llvm/docs/Coroutines.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst,1,['resume'],['resume']
Usability,"the current users of the code. All LLVM releases may be downloaded; from the `LLVM releases web site <https://llvm.org/releases/>`_. For more information about LLVM, including information about the latest; release, please check out the `main LLVM web site <https://llvm.org/>`_. If you; have questions or comments, the `Discourse forums; <https://discourse.llvm.org>`_ is a good place to ask; them. Note that if you are reading this file from a Git checkout or the main; LLVM web page, this document applies to the *next* release, not the current; one. To see the release notes for a specific release, please see the `releases; page <https://llvm.org/releases/>`_. Non-comprehensive list of changes in this release; =================================================; .. NOTE; For small 1-3 sentence descriptions, just add an entry at the end of; this list. If your description won't fit comfortably in one bullet; point (e.g. maybe you would like to give an example of the; functionality, or simply have a lot to talk about), see the `NOTE` below; for adding a new subsection. * ... Update on required toolchains to build LLVM; -------------------------------------------. Changes to the LLVM IR; ----------------------. * The `llvm.stacksave` and `llvm.stackrestore` intrinsics now use; an overloaded pointer type to support non-0 address spaces.; * The constant expression variants of the following instructions have been; removed:. * ``and``; * ``or``; * ``lshr``; * ``ashr``; * ``zext``; * ``sext``; * ``fptrunc``; * ``fpext``; * ``fptoui``; * ``fptosi``; * ``uitofp``; * ``sitofp``. * Added `llvm.exp10` intrinsic. * Added a ``code_model`` attribute for the `global variable <LangRef.html#global-variables>`_. Changes to LLVM infrastructure; ------------------------------. * Minimum Clang version to build LLVM in C++20 configuration has been updated to clang-17.0.6. Changes to building LLVM; ------------------------. Changes to TableGen; -------------------. * Added constructs for debugging ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseNotes.rst:1608,simpl,simply,1608,interpreter/llvm-project/llvm/docs/ReleaseNotes.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseNotes.rst,1,['simpl'],['simply']
Usability,"the function declaration ``f(int x)``. In C++, declaration names can also name; class constructors (""``Class``"" in ``struct Class { Class(); }``), class; destructors (""``~Class``""), overloaded operator names (""``operator+``""), and; conversion functions (""``operator void const *``""). In Objective-C,; declaration names can refer to the names of Objective-C methods, which involve; the method name and the parameters, collectively called a *selector*, e.g.,; ""``setWidth:height:``"". Since all of these kinds of entities --- variables,; functions, Objective-C methods, C++ constructors, destructors, and operators; --- are represented as subclasses of Clang's common ``NamedDecl`` class,; ``DeclarationName`` is designed to efficiently represent any kind of name. Given a ``DeclarationName`` ``N``, ``N.getNameKind()`` will produce a value; that describes what kind of name ``N`` stores. There are 10 options (all of; the names are inside the ``DeclarationName`` class). ``Identifier``. The name is a simple identifier. Use ``N.getAsIdentifierInfo()`` to retrieve; the corresponding ``IdentifierInfo*`` pointing to the actual identifier. ``ObjCZeroArgSelector``, ``ObjCOneArgSelector``, ``ObjCMultiArgSelector``. The name is an Objective-C selector, which can be retrieved as a ``Selector``; instance via ``N.getObjCSelector()``. The three possible name kinds for; Objective-C reflect an optimization within the ``DeclarationName`` class:; both zero- and one-argument selectors are stored as a masked; ``IdentifierInfo`` pointer, and therefore require very little space, since; zero- and one-argument selectors are far more common than multi-argument; selectors (which use a different structure). ``CXXConstructorName``. The name is a C++ constructor name. Use ``N.getCXXNameType()`` to retrieve; the :ref:`type <QualType>` that this constructor is meant to construct. The; type is always the canonical type, since all constructors for a given type; have the same name. ``CXXDestructorName``. The name i",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:69392,simpl,simple,69392,interpreter/llvm-project/clang/docs/InternalsManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst,1,['simpl'],['simple']
Usability,"the header files being bound. This is used to; generate the generic C++ binding code (and some ancillary files) using; a modified C++ compiler. The needed options must be compatible with the; normal build environment of the header files.; - One to compile the generated, generic C++ binding code using a standard; C++ compiler. The resulting library code is ""universal"" in that it is; compatible with both Python2 and Python3.; - One to package the library and ancillary files into standard Python2/3; wheel format. The packaging is done using native Python tooling. +----------------------+---------------------------------------------------------------------------------------------+; |Arguments and options | Description |; +======================+=============================================================================================+; |pkg | The name of the package to generate. This can be either |; | | of the form ""simplename"" (e.g. ""Akonadi""), or of the |; | | form ""namespace.simplename"" (e.g. ""KF5.Akonadi""). |; +----------------------+---------------------------------------------------------------------------------------------+; |pkg_version | The version of the package. |; +----------------------+---------------------------------------------------------------------------------------------+; |author | The name of the library author. |; +----------------------+---------------------------------------------------------------------------------------------+; |author_email | The email address of the library author. |; +----------------------+---------------------------------------------------------------------------------------------+; |URL url | The home page for the library. Default is |; | | ""https://pypi.python.org/pypi/<pkg>"". |; +----------------------+---------------------------------------------------------------------------------------------+; |LICENSE license | The license, default is ""LGPL 2.0"". |; +----------------------+-------------------------------------",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/cmake_interface.rst:5869,simpl,simplename,5869,bindings/pyroot/cppyy/cppyy/doc/source/cmake_interface.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/cmake_interface.rst,1,['simpl'],['simplename']
Usability,"the need to track data associated with a; symbolic expression; a map type is the most logical way to implement this. The; key for this map will be a pointer to a symbolic expression; (SymbolRef). If the data type to be associated with the symbolic; expression is an integer, then the custom category of state information would be; declared as. REGISTER_MAP_WITH_PROGRAMSTATE(ExampleDataType, SymbolRef, int). The data would be accessed with the function. ProgramStateRef state;; SymbolRef Sym;; ...; int currentlValue = state->get<ExampleDataType>(Sym);. and set with the function. ProgramStateRef state;; SymbolRef Sym;; int newValue;; ...; ProgramStateRef newState = state->set<ExampleDataType>(Sym, newValue);. In addition, the macros define a data type used for storing the data of the; new data category; the name of this type is the name of the data category with; ""Ty"" appended. For REGISTER_TRAIT_WITH_PROGRAMSTATE, this will simply; be passed data type; for the other three macros, this will be a specialized; version of the llvm::ImmutableList,; llvm::ImmutableSet,; or llvm::ImmutableMap; templated class. For the ExampleDataType example above, the type; created would be equivalent to writing the declaration:. using ExampleDataTypeTy = llvm::ImmutableMap<SymbolRef, int>;. These macros will cover a majority of use cases; however, they still have a; few limitations. They cannot be used inside namespaces (since they expand to; contain top-level namespace references), and the data types that they define; cannot be referenced from more than one file. Note that ProgramStates are immutable; instead of modifying an existing; one, functions that modify the state will return a copy of the previous state; with the change applied. This updated state must be then provided to the; analyzer core by calling the CheckerContext::addTransition function.; Bug Reports; When a checker detects a mistake in the analyzed code, it needs a way to; report it to the analyzer core so that it can be disp",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/checker_dev_manual.html:14660,simpl,simply,14660,interpreter/llvm-project/clang/www/analyzer/checker_dev_manual.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/checker_dev_manual.html,1,['simpl'],['simply']
Usability,"the old manglings if ``-fclang-abi-compat=17`` or lower is; specified.; (`#48216 <https://github.com/llvm/llvm-project/issues/48216>`_),; (`#49884 <https://github.com/llvm/llvm-project/issues/49884>`_), and; (`#61273 <https://github.com/llvm/llvm-project/issues/61273>`_). - The `ClassScopeFunctionSpecializationDecl` AST node has been removed.; Dependent class scope explicit function template specializations now use; `DependentFunctionTemplateSpecializationInfo` to store candidate primary; templates and explicit template arguments. This should not impact users of; Clang as a compiler, but it may break assumptions in Clang-based tools; iterating over the AST. - The warning `-Wenum-constexpr-conversion` is now also enabled by default on; system headers and macros. It will be turned into a hard (non-downgradable); error in the next Clang release. - The flag `-fdelayed-template-parsing` won't be enabled by default with C++20; when targetting MSVC to match the behavior of MSVC.; (`MSVC Docs <https://learn.microsoft.com/en-us/cpp/build/reference/permissive-standards-conformance?view=msvc-170>`_). - Remove the hardcoded path to the imported modules for C++20 named modules. Now we; require all the dependent modules to specified from the command line.; See (`#62707 <https://github.com/llvm/llvm-project/issues/62707>`_). - Forbid `import XXX;` in C++ to find module `XXX` comes from explicit clang modules.; See (`#64755 <https://github.com/llvm/llvm-project/issues/64755>`_). ABI Changes in This Version; ---------------------------; - Following the SystemV ABI for x86-64, ``__int128`` arguments will no longer; be split between a register and a stack slot. - Fixed Microsoft calling convention for returning certain classes with a; templated constructor. If a class has a templated constructor, it should; be returned indirectly even if it meets all the other requirements for; returning a class in a register. This affects some uses of std::pair.; (#GH86384). AST Dumping Potentially Br",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst:6104,learn,learn,6104,interpreter/llvm-project/clang/docs/ReleaseNotes.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst,1,['learn'],['learn']
Usability,"the results one can simply use; operator[] returning a TString. New tutorial regexp_pme.C. Meta. Add a new TClass interface to be able to trigger the ""auto addition of object; to a TDirectory object"". If a class has a member function:; DirectoryAutoAdd(TDirectory*); it will now be accessible (when the dictionary is generated via rootcint; for now) via TClass::GetDirectoryAutoAdd which return a wrapper with the; signature:; void (*)(void *this_obj,TDirectory *where_to_add). Extend #pragma create TClass; to namespaces.; Enable autoloading of the cintdlls.; rlibmap now handles #pragma create TClass; statements. Cont. Support for std algorithms and iterators for ROOT collection classes by Anar.; The background is the following. While working on the PROOF code I found; that enumerating TList is an inconvenient and a long operation, I had to; write the same code all over the place and make duplications. I tried; to use STD algorithms with it, namely std::for_each, and failed.; I therefore decided to enable std::for_each algorithm for ROOT; Containers/Iterators by making as few as possible changes, without rewriting; iterators at all. Now with only two simple lines of code one is able to; iterate through a container:. TIter iter(&list);; for_each(iter.Begin(), TIter::End(), SEnumFunctor());. or. for_each(iter.Begin(), inter_end, SEnumFunctor());. where iter_end could be an iterator to a middle of the container. After I had changed Iterators so that they could be used with std::for_each,; I decided to go further and did some more changes. As a result,. I have updated CINT implementation of some algorithms (they look now; more or less better in terms of the standard),. All collections can be now used with std::for_each, std::find_if,; std::count_if (probably with some more algorithms. I've listed here; only what has been *checked* by me). A test program has been added: $ROOTSYS/test/stressIterators.cxx. A tutorial macro has been added: $ROOTSYS/tutorials/cont/TListAndSTL.C. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/doc/v520/index.html:4093,simpl,simple,4093,core/doc/v520/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/doc/v520/index.html,1,['simpl'],['simple']
Usability,"the set of declaration contexts that are; semantically connected to this declaration context, in source order, including; this context (which will be the only result, for non-namespace contexts) via; ``DeclContext::collectAllContexts``. Note that these functions are used; internally within the lookup and insertion methods of the ``DeclContext``, so; the vast majority of clients can ignore them. Because the same entity can be defined multiple times in different modules,; it is also possible for there to be multiple definitions of (for instance); a ``CXXRecordDecl``, all of which describe a definition of the same class.; In such a case, only one of those ""definitions"" is considered by Clang to be; the definition of the class, and the others are treated as non-defining; declarations that happen to also contain member declarations. Corresponding; members in each definition of such multiply-defined classes are identified; either by redeclaration chains (if the members are ``Redeclarable``); or by simply a pointer to the canonical declaration (if the declarations; are not ``Redeclarable`` -- in that case, a ``Mergeable`` base class is used; instead). Error Handling; --------------. Clang produces an AST even when the code contains errors. Clang won't generate; and optimize code for it, but it's used as parsing continues to detect further; errors in the input. Clang-based tools also depend on such ASTs, and IDEs in; particular benefit from a high-quality AST for broken code. In presence of errors, clang uses a few error-recovery strategies to present the; broken code in the AST:. - correcting errors: in cases where clang is confident about the fix, it; provides a FixIt attaching to the error diagnostic and emits a corrected AST; (reflecting the written code with FixIts applied). The advantage of that is to; provide more accurate subsequent diagnostics. Typo correction is a typical; example.; - representing invalid node: the invalid node is preserved in the AST in some; form",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:84143,simpl,simply,84143,interpreter/llvm-project/clang/docs/InternalsManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst,1,['simpl'],['simply']
Usability,"the steps of coroutine lowering is building the coroutine frame. The; def-use chains are analyzed to determine which objects need be kept alive across; suspend points. In the coroutine shown in the previous section, use of virtual register; `%inc` is separated from the definition by a suspend point, therefore, it; cannot reside on the stack frame since the latter goes away once the coroutine; is suspended and control is returned back to the caller. An i32 slot is; allocated in the coroutine frame and `%inc` is spilled and reloaded from that; slot as needed. We also store addresses of the resume and destroy functions so that the; `coro.resume` and `coro.destroy` intrinsics can resume and destroy the coroutine; when its identity cannot be determined statically at compile time. For our; example, the coroutine frame will be:. .. code-block:: llvm. %f.frame = type { ptr, ptr, i32 }. After resume and destroy parts are outlined, function `f` will contain only the; code responsible for creation and initialization of the coroutine frame and; execution of the coroutine until a suspend point is reached:. .. code-block:: llvm. define ptr @f(i32 %n) {; entry:; %id = call token @llvm.coro.id(i32 0, ptr null, ptr null, ptr null); %alloc = call noalias ptr @malloc(i32 24); %frame = call noalias ptr @llvm.coro.begin(token %id, ptr %alloc); %1 = getelementptr %f.frame, ptr %frame, i32 0, i32 0; store ptr @f.resume, ptr %1; %2 = getelementptr %f.frame, ptr %frame, i32 0, i32 1; store ptr @f.destroy, ptr %2. %inc = add nsw i32 %n, 1; %inc.spill.addr = getelementptr inbounds %f.Frame, ptr %FramePtr, i32 0, i32 2; store i32 %inc, ptr %inc.spill.addr; call void @print(i32 %n). ret ptr %frame; }. Outlined resume part of the coroutine will reside in function `f.resume`:. .. code-block:: llvm. define internal fastcc void @f.resume(ptr %frame.ptr.resume) {; entry:; %inc.spill.addr = getelementptr %f.frame, ptr %frame.ptr.resume, i64 0, i32 2; %inc.spill = load i32, ptr %inc.spill.addr, align ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst:14679,resume,resume,14679,interpreter/llvm-project/llvm/docs/Coroutines.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst,1,['resume'],['resume']
Usability,"the type itself, we do not need; to create duplicates of types with different sets of qualifiers (i.e. there is; only a single heap allocated ""``int``"" type: ""``const int``"" and ""``volatile; const int``"" both point to the same heap allocated ""``int``"" type). This; reduces the heap size used to represent bits and also means we do not have to; consider qualifiers when uniquing types (:ref:`Type <Type>` does not even; contain qualifiers). In practice, the two most common type qualifiers (``const`` and ``restrict``); are stored in the low bits of the pointer to the ``Type`` object, together with; a flag indicating whether extended qualifiers are present (which must be; heap-allocated). This means that ``QualType`` is exactly the same size as a; pointer. .. _DeclarationName:. Declaration names; -----------------. The ``DeclarationName`` class represents the name of a declaration in Clang.; Declarations in the C family of languages can take several different forms.; Most declarations are named by simple identifiers, e.g., ""``f``"" and ""``x``"" in; the function declaration ``f(int x)``. In C++, declaration names can also name; class constructors (""``Class``"" in ``struct Class { Class(); }``), class; destructors (""``~Class``""), overloaded operator names (""``operator+``""), and; conversion functions (""``operator void const *``""). In Objective-C,; declaration names can refer to the names of Objective-C methods, which involve; the method name and the parameters, collectively called a *selector*, e.g.,; ""``setWidth:height:``"". Since all of these kinds of entities --- variables,; functions, Objective-C methods, C++ constructors, destructors, and operators; --- are represented as subclasses of Clang's common ``NamedDecl`` class,; ``DeclarationName`` is designed to efficiently represent any kind of name. Given a ``DeclarationName`` ``N``, ``N.getNameKind()`` will produce a value; that describes what kind of name ``N`` stores. There are 10 options (all of; the names are inside the ``De",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:68343,simpl,simple,68343,interpreter/llvm-project/clang/docs/InternalsManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst,1,['simpl'],['simple']
Usability,"the user function by varying parameter number; $\mbox{par}$, leaving all other parameters fixed at the current; value. If $\mbox{par}$ is not specified, all variable parameters are; scanned in sequence. The number of points $\mbox{npoints}$ in the; scan is 40 by default, and cannot exceed 100. The range of the scan is; by default 2 standard deviations on each side of the current best value,; but can be specified as from $\mbox{low}$ to $\mbox{high}$.; After each scan, if a new minimum is found, the best parameter values; are retained as start values for future scans or minimizations. The; curve resulting from each scan can be plotted on the output terminal; using MnPlot [api:plot] in order to show the approximate behaviour of; the function. ### ScanMinimizer ###. Although the $\mbox{SCAN}$ method is not intended for minimization; it can be used as a minimizer in its most primitive form. ## MnSimplex and SimplexMinimizer ##. [api:simplex]. $\mbox{SIMPLEX}$ is a function minimization method using the simplex; method of Nelder and Mead. MnSimplex provides minimization of the; function by the method of $\mbox{SIMPLEX}$ and the functionality for; parameters interaction. It also retains the result from the last; minimization in case the user may want to do subsequent minimization; steps with parameter interactions in between the minimization requests.; The minimization is done by the SimplexMinimizer. Minimization of the; function can be done by directly using the SimplexMinimizer if no; parameters interaction is required. As $\mbox{SIMPLEX}$ is a; stepping method it does not produce a covariance matrix. ### MnSimplex(const FCNBase&, const std::vector$<$double$>$&,\; const std::vector$<$double$>$&, unsigned int) ###. Constructor for the minimal required interface: $\mbox{FCN}$ and; starting values for parameters and uncertainties. Optional the strategy; level in MnStrategy can be specified. ### MnSimplex(const FCNBase&, const MnUserParameters&,\; unsigned int) ###. Constru",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md:48477,simpl,simplex,48477,documentation/minuit2/Minuit2.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md,1,['simpl'],['simplex']
Usability,"the values visited by the; iterators are not visited in sorted order. .. _dss_stringset:. llvm/ADT/StringSet.h; ^^^^^^^^^^^^^^^^^^^^. ``StringSet`` is a thin wrapper around :ref:`StringMap\<char\> <dss_stringmap>`,; and it allows efficient storage and retrieval of unique strings. Functionally analogous to ``SmallSet<StringRef>``, ``StringSet`` also supports; iteration. (The iterator dereferences to a ``StringMapEntry<char>``, so you; need to call ``i->getKey()`` to access the item of the StringSet.) On the; other hand, ``StringSet`` doesn't support range-insertion and; copy-construction, which :ref:`SmallSet <dss_smallset>` and :ref:`SmallPtrSet; <dss_smallptrset>` do support. .. _dss_denseset:. llvm/ADT/DenseSet.h; ^^^^^^^^^^^^^^^^^^^. DenseSet is a simple quadratically probed hash table. It excels at supporting; small values: it uses a single allocation to hold all of the pairs that are; currently inserted in the set. DenseSet is a great way to unique small values; that are not simple pointers (use :ref:`SmallPtrSet <dss_smallptrset>` for; pointers). Note that DenseSet has the same requirements for the value type that; :ref:`DenseMap <dss_densemap>` has. .. _dss_sparseset:. llvm/ADT/SparseSet.h; ^^^^^^^^^^^^^^^^^^^^. SparseSet holds a small number of objects identified by unsigned keys of; moderate size. It uses a lot of memory, but provides operations that are almost; as fast as a vector. Typical keys are physical registers, virtual registers, or; numbered basic blocks. SparseSet is useful for algorithms that need very fast clear/find/insert/erase; and fast iteration over small sets. It is not intended for building composite; data structures. .. _dss_sparsemultiset:. llvm/ADT/SparseMultiSet.h; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^. SparseMultiSet adds multiset behavior to SparseSet, while retaining SparseSet's; desirable attributes. Like SparseSet, it typically uses a lot of memory, but; provides operations that are almost as fast as a vector. Typical keys are; physical re",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:80272,simpl,simple,80272,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,1,['simpl'],['simple']
Usability,"the variables; `x,y,z` the correlation between these two sets of variables is clear also. ![Axis order is very important to show clusters.](pictures/para6.png). To pursue further data sets exploration we have implemented the possibility; to define selections interactively. A selection is a set of ranges combined; together. Within a selection, ranges along the same axis are combined with; logical OR, and ranges on different axes with logical AND. A selection is; displayed on top of the complete data set using its own color. Only the; events fulfilling the selection criteria (ranges) are displayed. Ranges; are defined interactively using cursors, like on the first axis on the; figure. Several selections can be defined at the same time,; each selection having its own color. ![Selections are set of ranges which can be defined interactively.](pictures/para7.png). Several selections can been defined. Each cluster is now clearly visible; and the zone with crossing clusters is now understandable whereas,; without any selection or with only a single one, it was not easy to; understand. ![Several selections can be defined each of them having its own color.](pictures/para8.png). Interactive selections on Parallel Coordinates are a powerful tool because; they can be defined graphically on many variables (graphical cuts in ROOT can; be defined on two variables only) which allow a very accurate events; filtering. Selections allow making precise events choices: a single outlying; event is clearly visible when the lines are displayed as “solid” therefore; it is easy to make cuts in order to eliminate one single event from a; selection. Such selection (to filter one single event) on a scatter plot; would be much more difficult. ![Selections allow to easily filter one single event.](pictures/para9.png). Once a selection has been defined, it is possible to use it to generate a; `TEntryList` which is applied on the tree and used at drawing time. In our; example the selection we defined",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:101029,clear,clearly,101029,documentation/users-guide/Trees.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md,1,['clear'],['clearly']
Usability,"the; events fulfilling the selection criteria (ranges) are displayed. Ranges; are defined interactively using cursors, like on the first axis on the; figure. Several selections can be defined at the same time,; each selection having its own color. ![Selections are set of ranges which can be defined interactively.](pictures/para7.png). Several selections can been defined. Each cluster is now clearly visible; and the zone with crossing clusters is now understandable whereas,; without any selection or with only a single one, it was not easy to; understand. ![Several selections can be defined each of them having its own color.](pictures/para8.png). Interactive selections on Parallel Coordinates are a powerful tool because; they can be defined graphically on many variables (graphical cuts in ROOT can; be defined on two variables only) which allow a very accurate events; filtering. Selections allow making precise events choices: a single outlying; event is clearly visible when the lines are displayed as “solid” therefore; it is easy to make cuts in order to eliminate one single event from a; selection. Such selection (to filter one single event) on a scatter plot; would be much more difficult. ![Selections allow to easily filter one single event.](pictures/para9.png). Once a selection has been defined, it is possible to use it to generate a; `TEntryList` which is applied on the tree and used at drawing time. In our; example the selection we defined allows to select exactly the two; correlated “random spheres”. ![Output of `nt->Draw(“x:y:z”)` and `nt->Draw(“u:v:w”)` after applying the selection.](pictures/para10.png). Another technique has been implemented in order to show clusters when; the picture is cluttered. A weight is assigned to each event. The weight; value is computed as:; $$; weight = \sum_{i=1}^{n} b_i; $$. Where:. - bi is the content of bin crossed by the event on the i-th axis.; - n is the number of axis. The events having the bigger weights are those belongin",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:101600,clear,clearly,101600,documentation/users-guide/Trees.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md,1,['clear'],['clearly']
Usability,"ther passes, it's time to get a little bit; fancier. All of the pass relationships that we have seen so far are very; simple: one pass depends on one other specific pass to be run before it can; run. For many applications, this is great, for others, more flexibility is; required. In particular, some analyses are defined such that there is a single simple; interface to the analysis results, but multiple ways of calculating them.; Consider alias analysis for example. The most trivial alias analysis returns; ""may alias"" for any alias query. The most sophisticated analysis a; flow-sensitive, context-sensitive interprocedural analysis that can take a; significant amount of time to execute (and obviously, there is a lot of room; between these two extremes for other implementations). To cleanly support; situations like this, the LLVM Pass Infrastructure supports the notion of; Analysis Groups. Analysis Group Concepts; ^^^^^^^^^^^^^^^^^^^^^^^. An Analysis Group is a single simple interface that may be implemented by; multiple different passes. Analysis Groups can be given human readable names; just like passes, but unlike passes, they need not derive from the ``Pass``; class. An analysis group may have one or more implementations, one of which is; the ""default"" implementation. Analysis groups are used by client passes just like other passes are: the; ``AnalysisUsage::addRequired()`` and ``Pass::getAnalysis()`` methods. In order; to resolve this requirement, the :ref:`PassManager; <writing-an-llvm-pass-passmanager>` scans the available passes to see if any; implementations of the analysis group are available. If none is available, the; default implementation is created for the pass to use. All standard rules for; :ref:`interaction between passes <writing-an-llvm-pass-interaction>` still; apply. Although :ref:`Pass Registration <writing-an-llvm-pass-registration>` is; optional for normal passes, all analysis group implementations must be; registered, and must use the :ref:`IN",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/WritingAnLLVMPass.rst:35701,simpl,simple,35701,interpreter/llvm-project/llvm/docs/WritingAnLLVMPass.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/WritingAnLLVMPass.rst,1,['simpl'],['simple']
Usability,"this article, click **Show Source** on the right sidebar. Authoring Guidelines; ====================. Focus on *content*. It is easy to fix the Sphinx (reStructuredText) syntax; later if necessary, although reStructuredText tries to imitate common; plain-text conventions so it should be quite natural. A basic knowledge of; reStructuredText syntax is useful when writing the document, so the last; ~half of this document (starting with `Example Section`_) gives examples; which should cover 99% of use cases. Let me say that again: focus on *content*. But if you really need to verify; Sphinx's output, see ``docs/README.txt`` for information. Once you have finished with the content, please send the ``.rst`` file to; llvm-commits for review. Creating New Articles; ---------------------. Before creating a new article, consider the following questions:. #. Why would I want to read this document?. #. What should I know to be able to follow along with this document?. #. What will I have learned by the end of this document?. A standard best practice is to make your articles task-oriented. You generally should not be writing documentation that isn't based around ""how to"" do something; unless there's already an existing ""how to"" article for the topic you're documenting. The reason for this is that without a ""how to"" article to read first, it might be difficult for; someone unfamiliar with the topic to understand a more advanced, conceptual article. When creating a task-oriented article, follow existing LLVM articles by giving it a filename that starts with ``HowTo*.rst``. This format is usually the easiest for another person to understand and also the most useful. Focus on content (yes, I had to say it again). The rest of this document shows example reStructuredText markup constructs; that are meant to be read by you in your text editor after you have copied; this file into a new file for the documentation you are about to write. Example Section; ===============. An article can co",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SphinxQuickstartTemplate.rst:2036,learn,learned,2036,interpreter/llvm-project/llvm/docs/SphinxQuickstartTemplate.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SphinxQuickstartTemplate.rst,1,['learn'],['learned']
Usability,"this is not always possible or entirely; accurate. If in doubt, refer to the numerical value. * On Windows, LLDB can now read the thread names. Changes to Sanitizers; ---------------------; * HWASan now defaults to detecting use-after-scope bugs. * `SpecialCaseList <https://clang.llvm.org/docs/SanitizerSpecialCaseList.html#format>`_; used by sanitizer ignore lists (e.g. ``*_ignorelist.txt`` in the Clang; resource directory) now uses glob patterns instead of a variant of POSIX; Extended Regular Expression (where ``*`` is translated to ``.*``) by default.; Search for ``|`` to find patterns that may have different meanings now, and; replace ``a|b`` with ``{a,b}``. Changes to the Profile Runtime; ------------------------------. * Public header ``profile/instr_prof_interface.h`` is added to declare four; API functions to fine tune profile collection. Other Changes; -------------. * The ``Flags`` field of ``llvm::opt::Option`` has been split into ``Flags``; and ``Visibility`` to simplify option sharing between various drivers (such; as ``clang``, ``clang-cl``, or ``flang``) that rely on Clang's Options.td.; Overloads of ``llvm::opt::OptTable`` that use ``FlagsToInclude`` have been; deprecated. There is a script and instructions on how to resolve conflicts -; see https://reviews.llvm.org/D157150 and https://reviews.llvm.org/D157151 for; details. * On Linux, FreeBSD, and NetBSD, setting the environment variable; ``LLVM_ENABLE_SYMBOLIZER_MARKUP`` causes tools to print stacktraces using; :doc:`Symbolizer Markup <SymbolizerMarkupFormat>`.; This works even if the tools have no embedded symbol information (i.e. are; fully stripped); :doc:`llvm-symbolizer <CommandGuide/llvm-symbolizer>` can; symbolize the markup afterwards using ``debuginfod``. External Open Source Projects Using LLVM 15; ===========================================. * A project... Additional Information; ======================. A wide variety of additional information is available on the `LLVM web page; <https://l",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseNotes.rst:18328,simpl,simplify,18328,interpreter/llvm-project/llvm/docs/ReleaseNotes.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseNotes.rst,1,['simpl'],['simplify']
Usability,"thod is named ""size"":. .. code-block:: c++. llvm::StringRef s = ""str"";; makeRule(; cxxMemberCallExpr(; on(expr().bind(s)),; callee(cxxMethodDecl(hasName(""size"")))),; changeTo(cat(""Size("", node(s), "")"")),; cat(""Method ``size`` is deprecated in favor of free function ``Size``""));. We express the pattern with the given AST matcher, which binds the method call's; target to ``s`` [#f1]_. For the edit, we again use ``changeTo``, but this; time we construct the term from multiple parts, which we compose with ``cat``. The; second part of our term is ``node(s)``, which selects the source code; corresponding to the AST node ``s`` that was bound when a match was found in the; AST for our rule's pattern. ``node(s)`` constructs a ``RangeSelector``, which, when; used in ``cat``, indicates that the selected source should be inserted in the; output at that point. Now, we probably don't want to rewrite *all* invocations of ""size"" methods, just; those on ``std::string``\ s. We can achieve this change simply by refining our; matcher. The rest of the rule remains unchanged:. .. code-block:: c++. llvm::StringRef s = ""str"";; makeRule(; cxxMemberCallExpr(; on(expr(hasType(namedDecl(hasName(""std::string"")))); 	 .bind(s)),; callee(cxxMethodDecl(hasName(""size"")))),; changeTo(cat(""Size("", node(s), "")"")),; cat(""Method ``size`` is deprecated in favor of free function ``Size``""));. Example: rewriting method calls; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. In this example, we delete an ""intermediary"" method call in a string of; invocations. This scenario can arise, for example, if you want to collapse a; substructure into its parent. .. code-block:: c++. llvm::StringRef e = ""expr"", m = ""member"";; auto child_call = cxxMemberCallExpr(on(expr().bind(e)),; 				 callee(cxxMethodDecl(hasName(""child""))));; makeRule(cxxMemberCallExpr(on(child_call), callee(memberExpr().bind(m)),; 	 changeTo(cat(e, ""."", member(m), ""()""))),; 	 cat(""``child`` accessor is being removed; call "",; 		member(m), "" directly on parent""));.",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangTransformerTutorial.rst:6923,simpl,simply,6923,interpreter/llvm-project/clang/docs/ClangTransformerTutorial.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangTransformerTutorial.rst,1,['simpl'],['simply']
Usability,"thods may well read or write to those instance; variables. Making such message sends from dealloc is generally discouraged,; since the subclass may well rely on other invariants that were broken during; ``dealloc``, but it's not so inescapably dangerous that we felt comfortable; calling it undefined behavior. Therefore we chose to delay destroying the; instance variables to a point at which message sends are clearly disallowed:; the point at which the root class's deallocation routines take over. In most code, the difference is not observable. It can, however, be observed; if an instance variable holds a strong reference to an object whose; deallocation will trigger a side-effect which must be carefully ordered with; respect to the destruction of the super class. Such code violates the design; principle that semantically important behavior should be explicit. A simple; fix is to clear the instance variable manually during ``dealloc``; a more; holistic solution is to move semantically important side-effects out of; ``dealloc`` and into a separate teardown phase which can rely on working with; well-formed objects. .. _arc.misc.autoreleasepool:. ``@autoreleasepool``; --------------------. To simplify the use of autorelease pools, and to bring them under the control; of the compiler, a new kind of statement is available in Objective-C. It is; written ``@autoreleasepool`` followed by a *compound-statement*, i.e. by a new; scope delimited by curly braces. Upon entry to this block, the current state; of the autorelease pool is captured. When the block is exited normally,; whether by fallthrough or directed control flow (such as ``return`` or; ``break``), the autorelease pool is restored to the saved state, releasing all; the objects in it. When the block is exited with an exception, the pool is not; drained. ``@autoreleasepool`` may be used in non-ARC translation units, with equivalent; semantics. A program is ill-formed if it refers to the ``NSAutoreleasePool`` class. .. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst:90175,simpl,simple,90175,interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,2,"['clear', 'simpl']","['clear', 'simple']"
Usability,"ties provided by git for Windows have been known to work.; Cygwin has worked in the past, but is not well tested.; If you don't already have the core utilies from some other source, get; gnuwin32 from ; http://getgnuwin32.sourceforge.net/. Check out LLVM and Clang:; ; git clone https://github.com/llvm/llvm-project.git. Note: Some Clang tests are sensitive to the line endings. Ensure; that checking out the files does not convert LF line endings to CR+LF. If; you're using git on Windows, make sure your core.autocrlf setting; is false. Run CMake to generate the Visual Studio solution and project files:; ; cd llvm-project; mkdir build (for building without polluting the source dir); cd build. If you are using Visual Studio 2019:; cmake -DLLVM_ENABLE_PROJECTS=clang -G ""Visual Studio 16 2019"" -A x64 -Thost=x64 ..\llvm; -Thost=x64 is required, since the 32-bit linker will run out of memory.; ; To generate x86 binaries instead of x64, pass -A Win32.; See the LLVM CMake guide for; more information on other configuration options for CMake.; The above, if successful, will have created an LLVM.sln file in the; build directory.; . Build Clang:; ; Open LLVM.sln in Visual Studio.; Build the ""clang"" project for just the compiler driver and front end, or; the ""ALL_BUILD"" project to build everything, including tools. Try it out (assuming you added llvm/debug/bin to your path). (See the; running examples from above.); See ; Hacking on clang - Testing using Visual Studio on Windows for information; on running regression tests on Windows. Using Ninja alongside Visual Studio; We recommend that developers who want the fastest incremental builds use the; Ninja build system. You can use the; generated Visual Studio project files to edit Clang source code and generate a; second build directory next to it for running the tests with these steps:. Check out clang and LLVM as described above; Open a developer command prompt with the appropriate environment.; ; If you open the start menu and sear",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/get_started.html:4968,guid,guide,4968,interpreter/llvm-project/clang/www/get_started.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/get_started.html,1,['guid'],['guide']
Usability,"time.; Such new versions will be similar in spirit to the present version,; but may differ in detail to address new problems or concerns. Each version is given a distinguishing version number. If the Library; specifies a version number of this License which applies to it and; ""any later version"", you have the option of following the terms and; conditions either of that version or of any later version published by; the Free Software Foundation. If the Library does not specify a; license version number, you may choose any version ever published by; the Free Software Foundation. 14. If you wish to incorporate parts of the Library into other free; programs whose distribution conditions are incompatible with these,; write to the author to ask for permission. For software which is; copyrighted by the Free Software Foundation, write to the Free; Software Foundation; we sometimes make exceptions for this. Our; decision will be guided by the two goals of preserving the free status; of all derivatives of our free software and of promoting the sharing; and reuse of software generally. NO WARRANTY. 15. BECAUSE THE LIBRARY IS LICENSED FREE OF CHARGE, THERE IS NO; WARRANTY FOR THE LIBRARY, TO THE EXTENT PERMITTED BY APPLICABLE LAW.; EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR; OTHER PARTIES PROVIDE THE LIBRARY ""AS IS"" WITHOUT WARRANTY OF ANY; KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE; IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR; PURPOSE. THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE; LIBRARY IS WITH YOU. SHOULD THE LIBRARY PROVE DEFECTIVE, YOU ASSUME; THE COST OF ALL NECESSARY SERVICING, REPAIR OR CORRECTION. 16. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN; WRITING WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY; AND/OR REDISTRIBUTE THE LIBRARY AS PERMITTED ABOVE, BE LIABLE TO YOU; FOR DAMAGES, INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR; CONSEQUENTIAL DAMAGES A",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/LICENSE.TXT:25075,guid,guided,25075,interpreter/cling/LICENSE.TXT,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/LICENSE.TXT,1,['guid'],['guided']
Usability,"tin_va_arg_pack``/``__builtin_va_arg_pack_len``. This is; used rarely, but in some potentially interesting places, like the; glibc headers, so it may be implemented pending user demand. Note; that because clang pretends to be like GCC 4.2, and this extension; was introduced in 4.3, the glibc headers will not try to use this; extension with clang at the moment.; - clang does not support the gcc extension for forward-declaring; function parameters; this has not shown up in any real-world code; yet, though, so it might never be implemented. This is not a complete list; if you find an unsupported extension; missing from this list, please send an e-mail to cfe-dev. This list; currently excludes C++; see :ref:`C++ Language Features <cxx>`. Also, this; list does not include bugs in mostly-implemented features; please see; the `bug; tracker <https://bugs.llvm.org/buglist.cgi?quicksearch=product%3Aclang+component%3A-New%2BBugs%2CAST%2CBasic%2CDriver%2CHeaders%2CLLVM%2BCodeGen%2Cparser%2Cpreprocessor%2CSemantic%2BAnalyzer>`_; for known existing bugs (FIXME: Is there a section for bug-reporting; guidelines somewhere?). Intentionally unsupported GCC extensions; ----------------------------------------. - clang does not support the gcc extension that allows variable-length; arrays in structures. This is for a few reasons: one, it is tricky to; implement, two, the extension is completely undocumented, and three,; the extension appears to be rarely used. Note that clang *does*; support flexible array members (arrays with a zero or unspecified; size at the end of a structure).; - GCC accepts many expression forms that are not valid integer constant; expressions in bit-field widths, enumerator constants, case labels,; and in array bounds at global scope. Clang also accepts additional; expression forms in these contexts, but constructs that GCC accepts due to; simplifications GCC performs while parsing, such as ``x - x`` (where ``x`` is a; variable) will likely never be accepted by Cl",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:135442,guid,guidelines,135442,interpreter/llvm-project/clang/docs/UsersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst,1,['guid'],['guidelines']
Usability,"ting with exceptions on Windows is significantly more complicated than; on Itanium C++ ABI platforms. The fundamental difference between the two models; is that Itanium EH is designed around the idea of ""successive unwinding,"" while; Windows EH is not. Under Itanium, throwing an exception typically involves allocating thread local; memory to hold the exception, and calling into the EH runtime. The runtime; identifies frames with appropriate exception handling actions, and successively; resets the register context of the current thread to the most recently active; frame with actions to run. In LLVM, execution resumes at a ``landingpad``; instruction, which produces register values provided by the runtime. If a; function is only cleaning up allocated resources, the function is responsible; for calling ``_Unwind_Resume`` to transition to the next most recently active; frame after it is finished cleaning up. Eventually, the frame responsible for; handling the exception calls ``__cxa_end_catch`` to destroy the exception,; release its memory, and resume normal control flow. The Windows EH model does not use these successive register context resets.; Instead, the active exception is typically described by a frame on the stack.; In the case of C++ exceptions, the exception object is allocated in stack memory; and its address is passed to ``__CxxThrowException``. General purpose structured; exceptions (SEH) are more analogous to Linux signals, and they are dispatched by; userspace DLLs provided with Windows. Each frame on the stack has an assigned EH; personality routine, which decides what actions to take to handle the exception.; There are a few major personalities for C and C++ code: the C++ personality; (``__CxxFrameHandler3``) and the SEH personalities (``_except_handler3``,; ``_except_handler4``, and ``__C_specific_handler``). All of them implement; cleanups by calling back into a ""funclet"" contained in the parent function. Funclets, in this context, are regions of the ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ExceptionHandling.rst:21149,resume,resume,21149,interpreter/llvm-project/llvm/docs/ExceptionHandling.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ExceptionHandling.rst,1,['resume'],['resume']
Usability,"tio of two histograms.\label{f53}][f53]. Some lines now need a bit of clarification:. - line *3*: Cling, as we know, is also able to interpret more than one; function per file. In this case the function simply sets up some; parameters to conveniently set the line of histograms. - line *19* to *21*: Some `C++` syntax for conditional; statements is used to fill the histograms with different numbers of; entries inside the loop. - line *30*: The sum of two histograms. A weight, which can be negative, can; be assigned to the added histogram. - line *41*: The division of two histograms is rather straightforward. - line *44* to *62*: When you draw two quantities and their ratios, it; is much better if all the information is condensed in one single; plot. These lines provide a skeleton to perform this operation. ## Two-dimensional Histograms ##. Two-dimensional histograms are a very useful tool, for example to; inspect correlations between variables. You can exploit the; bi-dimensional histogram classes provided by ROOT in a simple way.; Let's see how in this macro:. ``` {.cpp}; @ROOT_INCLUDE_FILE macros/macro7.C; ```. Two kinds of plots are provided within the code, the first one; containing three-dimensional representations (Figure [5.4](#f54)) and the second one; projections and profiles (Figure [5.5](#f55)) of the bi-dimensional histogram. [f54]: figures/th2f.png ""f54""; <a name=""f54""></a>. ![Different ways of representing bi-dimensional; histograms.\label{f54}][f54]. [f55]: figures/proj_and_prof.png ""f55""; <a name=""f55""></a>. ![The projections and profiles of bi-dimensional; histograms.\label{f55}][f55]. When a projection is performed along the x (y) direction, for every bin; along the x (y) axis, all bin contents along the y (x) axis are summed; up (upper the plots of Figure [5.5](#f55)). When a profile is performed along the x (y); direction, for every bin along the x (y) axis, the average of all the; bin contents along the y (x) is calculated together with their RMS ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/histograms.md:3367,simpl,simple,3367,documentation/primer/histograms.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/histograms.md,1,['simpl'],['simple']
Usability,"tion codeid=8 abbrevid=7 op0=4 op1=5 op2=6 op3=11 op4=66/>; </Remark>. ``Standalone``. .. code-block:: none. <BLOCKINFO_BLOCK/>; <Meta BlockID=8 NumWords=15 BlockCodeSize=3>; <Container info codeid=1 abbrevid=4 op0=5 op1=2/>; <Remark version codeid=2 abbrevid=5 op0=30/>; <String table codeid=3 abbrevid=6/> blob data = 'pass\\x00remark\\x00function\\x00path\\x00key\\x00value\\x00argpath\\x00'; </Meta>; <Remark BlockID=9 NumWords=8 BlockCodeSize=4>; <Remark header codeid=5 abbrevid=4 op0=2 op1=1 op2=0 op3=2/>; <Remark debug location codeid=6 abbrevid=5 op0=3 op1=99 op2=55/>; <Remark hotness codeid=7 abbrevid=6 op0=999999999/>; <Argument with debug location codeid=8 abbrevid=7 op0=4 op1=5 op2=6 op3=11 op4=66/>; </Remark>. opt-viewer; ==========. The ``opt-viewer`` directory contains a collection of tools that visualize and; summarize serialized remarks. The tools only support the ``yaml`` format. .. _optviewerpy:. opt-viewer.py; -------------. Output a HTML page which gives visual feedback on compiler interactions with; your program. :Examples:. ::. $ opt-viewer.py my_yaml_file.opt.yaml. ::. $ opt-viewer.py my_build_dir/. opt-stats.py; ------------. Output statistics about the optimization remarks in the input set. :Example:. ::. $ opt-stats.py my_yaml_file.opt.yaml. Total number of remarks 3. Top 10 remarks by pass:; inline 33%; asm-printer 33%; prologepilog 33%. Top 10 remarks:; asm-printer/InstructionCount 33%; inline/NoDefinition 33%; prologepilog/StackSize 33%. opt-diff.py; -----------. Produce a new YAML file which contains all of the changes in optimizations; between two YAML files. Typically, this tool should be used to do diffs between:. * new compiler + fixed source vs old compiler + fixed source; * fixed compiler + new source vs fixed compiler + old source. This diff file can be displayed using :ref:`opt-viewer.py <optviewerpy>`. :Example:. ::. $ opt-diff.py my_opt_yaml1.opt.yaml my_opt_yaml2.opt.yaml -o my_opt_diff.opt.yaml; $ opt-viewer.py my_opt_diff.opt.",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Remarks.rst:15015,feedback,feedback,15015,interpreter/llvm-project/llvm/docs/Remarks.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Remarks.rst,1,['feedback'],['feedback']
Usability,"tion comments. ClangCommentHTMLTagsProperties; ------------------------------. Generate efficient matchers for HTML tag properties. ClangCommentHTMLNamedCharacterReferences; ----------------------------------------. Generate function to translate named character references to UTF-8 sequences. ClangCommentCommandInfo; -----------------------. Generate command properties for commands that are used in documentation comments. ClangCommentCommandList; -----------------------. Generate list of commands that are used in documentation comments. ArmNeon; -------. Generate arm_neon.h for clang. ArmNeonSema; -----------. Generate ARM NEON sema support for clang. ArmNeonTest; -----------. Generate ARM NEON tests for clang. AttrDocs; --------. **Purpose**: Creates ``AttributeReference.rst`` from ``AttrDocs.td``, and is; used for documenting user-facing attributes. General BackEnds; ================. Print Records; -------------. The TableGen command option ``--print-records`` invokes a simple backend; that prints all the classes and records defined in the source files. This is; the default backend option. See the :doc:`TableGen Backend Developer's Guide; <./BackGuide>` for more information. Print Detailed Records; ----------------------. The TableGen command option ``--print-detailed-records`` invokes a backend; that prints all the global variables, classes, and records defined in the; source files, with more detail than the default record printer. See the; :doc:`TableGen Backend Developer's Guide <./BackGuide>` for more; information. JSON Reference; --------------. **Purpose**: Output all the values in every ``def``, as a JSON data; structure that can be easily parsed by a variety of languages. Useful; for writing custom backends without having to modify TableGen itself,; or for performing auxiliary analysis on the same TableGen data passed; to a built-in backend. **Output**:. The root of the output file is a JSON object (i.e. dictionary),; containing the following fixed keys:. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TableGen/BackEnds.rst:14259,simpl,simple,14259,interpreter/llvm-project/llvm/docs/TableGen/BackEnds.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TableGen/BackEnds.rst,1,['simpl'],['simple']
Usability,"tion of the; API. This implementation change is logically separate from the API; change. If you are interested in making a large change, and this scares you, please make; sure to first `discuss the change/gather consensus`_ then ask about the best way; to go about making the change. Attribution of Changes; ----------------------. When contributors submit a patch to an LLVM project, other developers with; commit access may commit it for the author once appropriate (based on the; progression of code review, etc.). When doing so, it is important to retain; correct attribution of contributions to their contributors. However, we do not; want the source code to be littered with random attributions ""this code written; by J. Random Hacker"" (this is noisy and distracting). In practice, the revision; control system keeps a perfect history of who changed what, and the CREDITS.txt; file describes higher-level contributions. If you commit a patch for someone; else, please follow the attribution of changes in the simple manner as outlined; by the `commit messages`_ section. Overall, please do not add contributor names; to the source code. Also, don't commit patches authored by others unless they have submitted the; patch to the project or you have been authorized to submit them on their behalf; (you work together and your company authorized you to contribute the patches,; etc.). The author should first submit them to the relevant project's commit; list, development list, or LLVM bug tracker component. If someone sends you; a patch privately, encourage them to submit it to the appropriate list first. Our previous version control system (subversion) did not distinguish between the; author and the committer like git does. As such, older commits used a different; attribution mechanism. The previous method was to include ""Patch by John Doe.""; in a separate line of the commit message and there are automated processes that; rely on this format. .. _IR backwards compatibility:. IR Backwar",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/DeveloperPolicy.rst:30323,simpl,simple,30323,interpreter/llvm-project/llvm/docs/DeveloperPolicy.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/DeveloperPolicy.rst,1,['simpl'],['simple']
Usability,"tion of the; code path ([mitigation G-2 +; V1-1](https://developer.amd.com/wp-content/resources/Managing-Speculation-on-AMD-Processors.pdf)). However, this relies on finding and enumerating all possible points in code; which could be attacked to leak information. While in some cases static; analysis is effective at doing this at scale, in many cases it still relies on; human judgement to evaluate whether code might be vulnerable. Especially for; software systems which receive less detailed scrutiny but remain sensitive to; these attacks, this seems like an impractical security model. We need an; automatic and systematic mitigation strategy. ### Automatic `lfence` on Conditional Edges. A natural way to scale up the existing hand-coded mitigations is simply to; inject an `lfence` instruction into both the target and fallthrough; destinations of every conditional branch. This ensures that no predicate or; bounds check can be bypassed speculatively. However, the performance overhead; of this approach is, simply put, catastrophic. Yet it remains the only truly; ""secure by default"" approach known prior to this effort and serves as the; baseline for performance. One attempt to address the performance overhead of this and make it more; realistic to deploy is [MSVC's /Qspectre; switch](https://blogs.msdn.microsoft.com/vcblog/2018/01/15/spectre-mitigations-in-msvc/).; Their technique is to use static analysis within the compiler to only insert; `lfence` instructions into conditional edges at risk of attack. However,; [initial](https://arstechnica.com/gadgets/2018/02/microsofts-compiler-level-spectre-fix-shows-how-hard-this-problem-will-be-to-solve/); [analysis](https://www.paulkocher.com/doc/MicrosoftCompilerSpectreMitigation.html); has shown that this approach is incomplete and only catches a small and limited; subset of attackable patterns which happen to resemble very closely the initial; proofs of concept. As such, while its performance is acceptable, it does not; appear ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SpeculativeLoadHardening.md:45427,simpl,simply,45427,interpreter/llvm-project/llvm/docs/SpeculativeLoadHardening.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SpeculativeLoadHardening.md,1,['simpl'],['simply']
Usability,"tion unit is likely to cause a problem. For example, two modules may provide similar-but-incompatible functionality. .. parsed-literal::. *conflict-declaration*:; ``conflict`` *module-id* ',' *string-literal*. The *module-id* of the *conflict-declaration* specifies the module with which the enclosing module conflicts. The specified module shall not have been imported in the translation unit when the enclosing module is imported. The *string-literal* provides a message to be provided as part of the compiler diagnostic when two modules conflict. .. note::. Clang emits a warning (under the control of ``-Wmodule-conflict``); when a module conflict is discovered. **Example:**. .. parsed-literal::. module Conflicts {; explicit module A {; header ""conflict_a.h""; conflict B, ""we just don't like B""; }. module B {; header ""conflict_b.h""; }; }. Attributes; ----------; Attributes are used in a number of places in the grammar to describe specific behavior of other declarations. The format of attributes is fairly simple. .. parsed-literal::. *attributes*:; *attribute* *attributes*:sub:`opt`. *attribute*:; '[' *identifier* ']'. Any *identifier* can be used as an attribute, and each declaration specifies what attributes can be applied to it. Private Module Map Files; ------------------------; Module map files are typically named ``module.modulemap`` and live; either alongside the headers they describe or in a parent directory of; the headers they describe. These module maps typically describe all of; the API for the library. However, in some cases, the presence or absence of particular headers; is used to distinguish between the ""public"" and ""private"" APIs of a; particular library. For example, a library may contain the headers; ``Foo.h`` and ``Foo_Private.h``, providing public and private APIs,; respectively. Additionally, ``Foo_Private.h`` may only be available on; some versions of library, and absent in others. One cannot easily; express this with a single module map file in the ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst:49368,simpl,simple,49368,interpreter/llvm-project/clang/docs/Modules.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst,1,['simpl'],['simple']
Usability,"tion-defined format <ccxx_frontend>` (the C/C++ front-end; currently uses working draft 7 of the `DWARF 3 standard; <http://www.eagercon.com/dwarf/dwarf3std.htm>`_). When a program is being debugged, a debugger interacts with the user and turns; the stored debug information into source-language specific information. As; such, a debugger must be aware of the source-language, and is thus tied to a; specific language or family of languages. Debug information consumers; ---------------------------. The role of debug information is to provide meta information normally stripped; away during the compilation process. This meta information provides an LLVM; user a relationship between generated code and the original program source; code. Currently, there are two backend consumers of debug info: DwarfDebug and; CodeViewDebug. DwarfDebug produces DWARF suitable for use with GDB, LLDB, and; other DWARF-based debuggers. :ref:`CodeViewDebug <codeview>` produces CodeView,; the Microsoft debug info format, which is usable with Microsoft debuggers such; as Visual Studio and WinDBG. LLVM's debug information format is mostly derived; from and inspired by DWARF, but it is feasible to translate into other target; debug info formats such as STABS. It would also be reasonable to use debug information to feed profiling tools; for analysis of generated code, or, tools for reconstructing the original; source from generated code. .. _intro_debugopt:. Debug information and optimizations; -----------------------------------. An extremely high priority of LLVM debugging information is to make it interact; well with optimizations and analysis. In particular, the LLVM debug; information provides the following guarantees:. * LLVM debug information **always provides information to accurately read; the source-level state of the program**, regardless of which LLVM; optimizations have been run. :doc:`HowToUpdateDebugInfo` specifies how debug; info should be updated in various kinds of code transformatio",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst:3164,usab,usable,3164,interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,1,['usab'],['usable']
Usability,"tion. In the example above, the LLVM builder class is starting to show its; value. IRBuilder knows where to insert the newly created instruction,; all you have to do is specify what instruction to create (e.g. with; ``CreateFAdd``), which operands to use (``L`` and ``R`` here) and; optionally provide a name for the generated instruction. One nice thing about LLVM is that the name is just a hint. For instance,; if the code above emits multiple ""addtmp"" variables, LLVM will; automatically provide each one with an increasing, unique numeric; suffix. Local value names for instructions are purely optional, but it; makes it much easier to read the IR dumps. `LLVM instructions <../../LangRef.html#instruction-reference>`_ are constrained by strict; rules: for example, the Left and Right operands of an `add; instruction <../../LangRef.html#add-instruction>`_ must have the same type, and the; result type of the add must match the operand types. Because all values; in Kaleidoscope are doubles, this makes for very simple code for add,; sub and mul. On the other hand, LLVM specifies that the `fcmp; instruction <../../LangRef.html#fcmp-instruction>`_ always returns an 'i1' value (a; one bit integer). The problem with this is that Kaleidoscope wants the; value to be a 0.0 or 1.0 value. In order to get these semantics, we; combine the fcmp instruction with a `uitofp; instruction <../../LangRef.html#uitofp-to-instruction>`_. This instruction converts its; input integer into a floating point value by treating the input as an; unsigned value. In contrast, if we used the `sitofp; instruction <../../LangRef.html#sitofp-to-instruction>`_, the Kaleidoscope '<' operator; would return 0.0 and -1.0, depending on the input value. .. code-block:: c++. Value *CallExprAST::codegen() {; // Look up the name in the global module table.; Function *CalleeF = TheModule->getFunction(Callee);; if (!CalleeF); return LogErrorV(""Unknown function referenced"");. // If argument mismatch error.; if (CalleeF->a",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl03.rst:8263,simpl,simple,8263,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl03.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl03.rst,1,['simpl'],['simple']
Usability,"tion; equivalent to a call or invoke to 'target'. The 'target' operand is the function actually being called. The operand; must have an :ref:`elementtype <attr_elementtype>` attribute specifying; the function type of the target. The target can be specified as either; a symbolic LLVM function, or as an arbitrary Value of pointer type. Note; that the function type must match the signature of the callee and the; types of the 'call parameters' arguments. The '#call args' operand is the number of arguments to the actual; call. It must exactly match the number of arguments passed in the; 'call parameters' variable length section. The 'flags' operand is used to specify extra information about the; statepoint. This is currently only used to mark certain statepoints; as GC transitions. This operand is a 64-bit integer with the following; layout, where bit 0 is the least significant bit:. +-------+---------------------------------------------------+; | Bit # | Usage |; +=======+===================================================+; | 0 | Set if the statepoint is a GC transition, cleared |; | | otherwise. |; +-------+---------------------------------------------------+; | 1-63 | Reserved for future use; must be cleared. |; +-------+---------------------------------------------------+. The 'call parameters' arguments are simply the arguments which need to; be passed to the call target. They will be lowered according to the; specified calling convention and otherwise handled like a normal call; instruction. The number of arguments must exactly match what is; specified in '# call args'. The types must match the signature of; 'target'. The 'call parameter' attributes must be followed by two 'i64 0' constants.; These were originally the length prefixes for 'gc transition parameter' and; 'deopt parameter' arguments, but the role of these parameter sets have been; entirely replaced with the corresponding operand bundles. In a future; revision, these now redundant arguments will be remo",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:502300,clear,cleared,502300,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['clear'],['cleared']
Usability,"tionAction`` should be called with ``Custom`` as the third parameter:. .. code-block:: c++. setOperationAction(ISD::FP_TO_SINT, MVT::i32, Custom);. In the ``LowerOperation`` method, for each ``Custom`` operation, a case; statement should be added to indicate what function to call. In the following; code, an ``FP_TO_SINT`` opcode will call the ``LowerFP_TO_SINT`` method:. .. code-block:: c++. SDValue SparcTargetLowering::LowerOperation(SDValue Op, SelectionDAG &DAG) {; switch (Op.getOpcode()) {; case ISD::FP_TO_SINT: return LowerFP_TO_SINT(Op, DAG);; ...; }; }. Finally, the ``LowerFP_TO_SINT`` method is implemented, using an FP register to; convert the floating-point value to an integer. .. code-block:: c++. static SDValue LowerFP_TO_SINT(SDValue Op, SelectionDAG &DAG) {; assert(Op.getValueType() == MVT::i32);; Op = DAG.getNode(SPISD::FTOI, MVT::f32, Op.getOperand(0));; return DAG.getNode(ISD::BITCAST, MVT::i32, Op);; }. Legal; ^^^^^. The ``Legal`` ``LegalizeAction`` enum value simply indicates that an operation; **is** natively supported. ``Legal`` represents the default condition, so it; is rarely used. In ``SparcISelLowering.cpp``, the action for ``CTPOP`` (an; operation to count the bits set in an integer) is natively supported only for; SPARC v9. The following code enables the ``Expand`` conversion technique for; non-v9 SPARC implementations. .. code-block:: c++. setOperationAction(ISD::CTPOP, MVT::i32, Expand);; ...; if (TM.getSubtarget<SparcSubtarget>().isV9()); setOperationAction(ISD::CTPOP, MVT::i32, Legal);. Calling Conventions; -------------------. To support target-specific calling conventions, ``XXXGenCallingConv.td`` uses; interfaces (such as ``CCIfType`` and ``CCAssignToReg``) that are defined in; ``lib/Target/TargetCallingConv.td``. TableGen can take the target descriptor; file ``XXXGenCallingConv.td`` and generate the header file; ``XXXGenCallingConv.inc``, which is typically included in; ``XXXISelLowering.cpp``. You can use the interfaces in; ``Targe",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/WritingAnLLVMBackend.rst:61051,simpl,simply,61051,interpreter/llvm-project/llvm/docs/WritingAnLLVMBackend.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/WritingAnLLVMBackend.rst,1,['simpl'],['simply']
Usability,"tions must already name the class and new overloads; cannot be introduced out of line, so this recommendation does not apply to them. .. _early exits:. Use Early Exits and ``continue`` to Simplify Code; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. When reading code, keep in mind how much state and how many previous decisions; have to be remembered by the reader to understand a block of code. Aim to; reduce indentation where possible when it doesn't make it more difficult to; understand the code. One great way to do this is by making use of early exits; and the ``continue`` keyword in long loops. Consider this code that does not; use an early exit:. .. code-block:: c++. Value *doSomething(Instruction *I) {; if (!I->isTerminator() &&; I->hasOneUse() && doOtherThing(I)) {; ... some long code ....; }. return 0;; }. This code has several problems if the body of the ``'if'`` is large. When; you're looking at the top of the function, it isn't immediately clear that this; *only* does interesting things with non-terminator instructions, and only; applies to things with the other predicates. Second, it is relatively difficult; to describe (in comments) why these predicates are important because the ``if``; statement makes it difficult to lay out the comments. Third, when you're deep; within the body of the code, it is indented an extra level. Finally, when; reading the top of the function, it isn't clear what the result is if the; predicate isn't true; you have to read to the end of the function to know that; it returns null. It is much preferred to format the code like this:. .. code-block:: c++. Value *doSomething(Instruction *I) {; // Terminators never need 'something' done to them because ...; if (I->isTerminator()); return 0;. // We conservatively avoid transforming instructions with multiple uses; // because goats like cheese.; if (!I->hasOneUse()); return 0;. // This is really just here for example.; if (!doOtherThing(I)); return 0;. ... some long code ....; }. Th",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodingStandards.rst:36012,clear,clear,36012,interpreter/llvm-project/llvm/docs/CodingStandards.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodingStandards.rst,1,['clear'],['clear']
Usability,"tisfy both it and this License would be to; refrain entirely from distribution of the Library. If any portion of this section is held invalid or unenforceable under any; particular circumstance, the balance of the section is intended to apply,; and the section as a whole is intended to apply in other circumstances. It is not the purpose of this section to induce you to infringe any; patents or other property right claims or to contest validity of any; such claims; this section has the sole purpose of protecting the; integrity of the free software distribution system which is; implemented by public license practices. Many people have made; generous contributions to the wide range of software distributed; through that system in reliance on consistent application of that; system; it is up to the author/donor to decide if he or she is willing; to distribute software through any other system and a licensee cannot; impose that choice. This section is intended to make thoroughly clear what is believed to; be a consequence of the rest of this License. 12. If the distribution and/or use of the Library is restricted in; certain countries either by patents or by copyrighted interfaces, the; original copyright holder who places the Library under this License may add; an explicit geographical distribution limitation excluding those countries,; so that distribution is permitted only in or among countries not thus; excluded. In such case, this License incorporates the limitation as if; written in the body of this License. 13. The Free Software Foundation may publish revised and/or new; versions of the Lesser General Public License from time to time.; Such new versions will be similar in spirit to the present version,; but may differ in detail to address new problems or concerns. Each version is given a distinguishing version number. If the Library; specifies a version number of this License which applies to it and; ""any later version"", you have the option of following the terms and",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/LGPL2_1.txt:21216,clear,clear,21216,LGPL2_1.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/LGPL2_1.txt,2,['clear'],['clear']
Usability,"tizer reads instruction classes from a target's itineraries and creates; a deterministic finite automaton (DFA) to represent the state of a packet. A DFA; consists of three major elements: inputs, states, and transitions. The set of; inputs for the generated DFA represents the instruction being added to a; packet. The states represent the possible consumption of functional units by; instructions in a packet. In the DFA, transitions from one state to another; occur on the addition of an instruction to an existing packet. If there is a; legal mapping of functional units to instructions, then the DFA contains a; corresponding transition. The absence of a transition indicates that a legal; mapping does not exist and that the instruction cannot be added to the packet. To generate tables for a VLIW target, add *Target*\ GenDFAPacketizer.inc as a; target to the Makefile in the target directory. The exported API provides three; functions: ``DFAPacketizer::clearResources()``,; ``DFAPacketizer::reserveResources(MachineInstr *MI)``, and; ``DFAPacketizer::canReserveResources(MachineInstr *MI)``. These functions allow; a target packetizer to add an instruction to an existing packet and to check; whether an instruction can be added to a packet. See; ``llvm/CodeGen/DFAPacketizer.h`` for more information. Implementing a Native Assembler; ===============================. Though you're probably reading this because you want to write or maintain a; compiler backend, LLVM also fully supports building a native assembler.; We've tried hard to automate the generation of the assembler from the .td files; (in particular the instruction syntax and encodings), which means that a large; part of the manual and repetitive data entry can be factored and shared with the; compiler. Instruction Parsing; -------------------. .. note::. To Be Written. Instruction Alias Processing; ----------------------------. Once the instruction is parsed, it enters the MatchInstructionImpl function.; The MatchInstr",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodeGenerator.rst:80517,clear,clearResources,80517,interpreter/llvm-project/llvm/docs/CodeGenerator.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodeGenerator.rst,1,['clear'],['clearResources']
Usability,"tly if they want to. Now we just need to be able to set; the ``DebugFlag`` boolean when the option is set. To do this, we pass an; additional argument to our command line argument processor, and we specify where; to fill in with the `cl::location`_ attribute:. .. code-block:: c++. bool DebugFlag; // the actual value; static cl::opt<bool, true> // The parser; Debug(""debug"", cl::desc(""Enable debug output""), cl::Hidden, cl::location(DebugFlag));. In the above example, we specify ""``true``"" as the second argument to the; `cl::opt`_ template, indicating that the template should not maintain a copy of; the value itself. In addition to this, we specify the `cl::location`_; attribute, so that ``DebugFlag`` is automatically set. Option Attributes; -----------------. This section describes the basic attributes that you can specify on options. * The option name attribute (which is required for all options, except; `positional options`_) specifies what the option name is. This option is; specified in simple double quotes:. .. code-block:: c++. cl::opt<bool> Quiet(""quiet"");. .. _cl::desc(...):. * The **cl::desc** attribute specifies a description for the option to be; shown in the ``-help`` output for the program. This attribute supports; multi-line descriptions with lines separated by '\n'. .. _cl::value_desc:. * The **cl::value_desc** attribute specifies a string that can be used to; fine tune the ``-help`` output for a command line option. Look `here`_ for an; example. .. _cl::init:. * The **cl::init** attribute specifies an initial value for a `scalar`_; option. If this attribute is not specified then the command line option value; defaults to the value created by the default constructor for the; type. .. warning::. If you specify both **cl::init** and **cl::location** for an option, you; must specify **cl::location** first, so that when the command-line parser; sees **cl::init**, it knows where to put the initial value. (You will get an; error at runtime if you don't put th",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandLine.rst:35744,simpl,simple,35744,interpreter/llvm-project/llvm/docs/CommandLine.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandLine.rst,1,['simpl'],['simple']
Usability,"tly. When control; flow :ref:`diverges <convergence-and-uniformity>`, i.e. threads of the same; group follow different; paths through the CFG, not all threads of the group may be available to; participate in this communication. This is the defining characteristic that; distinguishes convergent operations from other inter-thread communication:. A convergent operation involves inter-thread communication or synchronization; that occurs outside of the memory model, where the set of threads which; participate in communication is implicitly affected by control flow. For example, in the following GPU compute kernel, communication during the; convergent operation is expected to occur precisely among those threads of an; implementation-defined execution scope (such as workgroup or subgroup) for; which ``condition`` is true:. .. code-block:: c++. void example_kernel() {; ...; if (condition); convergent_operation();; ...; }. In structured programming languages, there is often an intuitive and; unambiguous way of determining the threads that are expected to communicate.; However, this is not always the case even in structured programming languages,; and the intuition breaks down entirely in unstructured control flow. This; document describes the formal semantics in LLVM, i.e. how to determine the set; of communicating threads for convergent operations. The definitions in this document leave many details open, such as how groups of; threads are formed in the first place. It focuses on the questions that are; relevant for deciding the correctness of generic program transforms and; convergence-related analyses such as :ref:`uniformity analysis; <convergence-and-uniformity>`. .. _convergent_operations:. Convergent Operations; =====================. In LLVM IR, the only way to communicate between threads as described; above is by calling target-defined convergent intrinsics. Hence, only; a call-site in LLVM IR (a :ref:`call <i_call>`, :ref:`invoke; <i_invoke>`, or :ref:`callbr <i_cal",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ConvergentOperations.rst:1426,intuit,intuitive,1426,interpreter/llvm-project/llvm/docs/ConvergentOperations.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ConvergentOperations.rst,1,['intuit'],['intuitive']
Usability,"to *not* pass strings around as ``const; char*``'s. These have a number of problems, including the fact that they; cannot represent embedded nul (""\0"") characters, and do not have a length; available efficiently. The general replacement for '``const char*``' is; StringRef. For more information on choosing string containers for APIs, please see; :ref:`Passing Strings <string_apis>`. .. _dss_stringref:. llvm/ADT/StringRef.h; ^^^^^^^^^^^^^^^^^^^^. The StringRef class is a simple value class that contains a pointer to a; character and a length, and is quite related to the :ref:`ArrayRef; <dss_arrayref>` class (but specialized for arrays of characters). Because; StringRef carries a length with it, it safely handles strings with embedded nul; characters in it, getting the length does not require a strlen call, and it even; has very convenient APIs for slicing and dicing the character range that it; represents. StringRef is ideal for passing simple strings around that are known to be live,; either because they are C string literals, std::string, a C array, or a; SmallVector. Each of these cases has an efficient implicit conversion to; StringRef, which doesn't result in a dynamic strlen being executed. StringRef has a few major limitations which make more powerful string containers; useful:. #. You cannot directly convert a StringRef to a 'const char*' because there is; no way to add a trailing nul (unlike the .c_str() method on various stronger; classes). #. StringRef doesn't own or keep alive the underlying string bytes.; As such it can easily lead to dangling pointers, and is not suitable for; embedding in datastructures in most cases (instead, use an std::string or; something like that). #. For the same reason, StringRef cannot be used as the return value of a; method if the method ""computes"" the result string. Instead, use std::string. #. StringRef's do not allow you to mutate the pointed-to string bytes and it; doesn't allow you to insert or remove bytes from the range",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:72192,simpl,simple,72192,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,1,['simpl'],['simple']
Usability,"to be writable even without this attribute. The ``writable`` attribute cannot be combined with ``readnone``,; ``readonly`` or a ``memory`` attribute that does not contain; ``argmem: write``. ``dead_on_unwind``; At a high level, this attribute indicates that the pointer argument is dead; if the call unwinds, in the sense that the caller will not depend on the; contents of the memory. Stores that would only be visible on the unwind; path can be elided. More precisely, the behavior is as-if any memory written through the; pointer during the execution of the function is overwritten with a poison; value on unwind. This includes memory written by the implicit write implied; by the ``writable`` attribute. The caller is allowed to access the affected; memory, but all loads that are not preceded by a store will return poison. This attribute cannot be applied to return values. .. _gc:. Garbage Collector Strategy Names; --------------------------------. Each function may specify a garbage collector strategy name, which is simply a; string:. .. code-block:: llvm. define void @f() gc ""name"" { ... }. The supported values of *name* includes those :ref:`built in to LLVM; <builtin-gc-strategies>` and any provided by loaded plugins. Specifying a GC; strategy will cause the compiler to alter its output in order to support the; named garbage collection algorithm. Note that LLVM itself does not contain a; garbage collector, this functionality is restricted to generating machine code; which can interoperate with a collector provided externally. .. _prefixdata:. Prefix Data; -----------. Prefix data is data associated with a function which the code; generator will emit immediately before the function's entrypoint.; The purpose of this feature is to allow frontends to associate; language-specific runtime metadata with specific functions and make it; available through the function pointer while still allowing the; function pointer to be called. To access the data for a given function, a prog",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:71879,simpl,simply,71879,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['simpl'],['simply']
Usability,"to call/access.; For now we will ignore this argument and use a standard optimization; pipeline. To do this we set up a FunctionPassManager, add some passes to it, run; it over every function in the module, and then return the mutated module. The; specific optimizations are the same ones used in `Chapter 4 <LangImpl04.html>`_; of the ""Implementing a language with LLVM"" tutorial series. Readers may visit; that chapter for a more in-depth discussion of these, and of IR optimization in; general. And that's it in terms of changes to KaleidoscopeJIT: When a module is added via; addModule the OptimizeLayer will call our optimizeModule function before passing; the transformed module on to the CompileLayer below. Of course, we could have; called optimizeModule directly in our addModule function and not gone to the; bother of using the IRTransformLayer, but doing so gives us another opportunity; to see how layers compose. It also provides a neat entry point to the *layer*; concept itself, because IRTransformLayer is one of the simplest layers that; can be implemented. .. code-block:: c++. // From IRTransformLayer.h:; class IRTransformLayer : public IRLayer {; public:; using TransformFunction = std::function<Expected<ThreadSafeModule>(; ThreadSafeModule, const MaterializationResponsibility &R)>;. IRTransformLayer(ExecutionSession &ES, IRLayer &BaseLayer,; TransformFunction Transform = identityTransform);. void setTransform(TransformFunction Transform) {; this->Transform = std::move(Transform);; }. static ThreadSafeModule; identityTransform(ThreadSafeModule TSM,; const MaterializationResponsibility &R) {; return TSM;; }. void emit(MaterializationResponsibility R, ThreadSafeModule TSM) override;. private:; IRLayer &BaseLayer;; TransformFunction Transform;; };. // From IRTransformLayer.cpp:. IRTransformLayer::IRTransformLayer(ExecutionSession &ES,; IRLayer &BaseLayer,; TransformFunction Transform); : IRLayer(ES), BaseLayer(BaseLayer), Transform(std::move(Transform)) {}. void IRTr",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/BuildingAJIT2.rst:6412,simpl,simplest,6412,interpreter/llvm-project/llvm/docs/tutorial/BuildingAJIT2.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/BuildingAJIT2.rst,1,['simpl'],['simplest']
Usability,"to emit IR for that AST node along with all; the things it depends on, and they all return an LLVM Value object.; ""Value"" is the class used to represent a ""`Static Single Assignment; (SSA) <http://en.wikipedia.org/wiki/Static_single_assignment_form>`_; register"" or ""SSA value"" in LLVM. The most distinct aspect of SSA values; is that their value is computed as the related instruction executes, and; it does not get a new value until (and if) the instruction re-executes.; In other words, there is no way to ""change"" an SSA value. For more; information, please read up on `Static Single; Assignment <http://en.wikipedia.org/wiki/Static_single_assignment_form>`_; - the concepts are really quite natural once you grok them. Note that instead of adding virtual methods to the ExprAST class; hierarchy, it could also make sense to use a `visitor; pattern <http://en.wikipedia.org/wiki/Visitor_pattern>`_ or some other; way to model this. Again, this tutorial won't dwell on good software; engineering practices: for our purposes, adding a virtual method is; simplest. The second thing we want is a ""LogError"" method like we used for the; parser, which will be used to report errors found during code generation; (for example, use of an undeclared parameter):. .. code-block:: c++. static std::unique_ptr<LLVMContext> TheContext;; static std::unique_ptr<IRBuilder<>> Builder(TheContext);; static std::unique_ptr<Module> TheModule;; static std::map<std::string, Value *> NamedValues;. Value *LogErrorV(const char *Str) {; LogError(Str);; return nullptr;; }. The static variables will be used during code generation. ``TheContext``; is an opaque object that owns a lot of core LLVM data structures, such as; the type and constant value tables. We don't need to understand it in; detail, we just need a single instance to pass into APIs that require it. The ``Builder`` object is a helper object that makes it easy to generate; LLVM instructions. Instances of the; `IRBuilder <https://llvm.org/doxygen/IRBu",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl03.rst:2655,simpl,simplest,2655,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl03.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl03.rst,1,['simpl'],['simplest']
Usability,"to gcc 4.3.1. This version of gcc is much stricker with respect to; implicit header files so in many source files <stdlib.h> and <string.h>; had to be added. TPRegexp. Modularized Match() and Substitute() functions so that the low-level work; is done by MatchInternal() and SubstituteInternal(). Added function TString GetModifiers() that translates from bit-flag; options back to perl-style option characters. For all functions that do actual matching replaced the default value; of 'Int_t nMatchMax' argument from 30 to 10. PCRE internals require; the index buffer to be 3-times the number of allowed matches. This; multiplication is now performed in individual functions and nMatchMax; is really the number of allowed matches. Two function calls in; TString passing this number explicitly have been updated. TPMERegexp. New sub-class of TPRegexp with API closer to PERL.; Supports main Perl operations using regular expressions (Match,; Substitute and Split). To retrieve the results one can simply use; operator[] returning a TString. New tutorial regexp_pme.C. Meta. Add a new TClass interface to be able to trigger the ""auto addition of object; to a TDirectory object"". If a class has a member function:; DirectoryAutoAdd(TDirectory*); it will now be accessible (when the dictionary is generated via rootcint; for now) via TClass::GetDirectoryAutoAdd which return a wrapper with the; signature:; void (*)(void *this_obj,TDirectory *where_to_add). Extend #pragma create TClass; to namespaces.; Enable autoloading of the cintdlls.; rlibmap now handles #pragma create TClass; statements. Cont. Support for std algorithms and iterators for ROOT collection classes by Anar.; The background is the following. While working on the PROOF code I found; that enumerating TList is an inconvenient and a long operation, I had to; write the same code all over the place and make duplications. I tried; to use STD algorithms with it, namely std::for_each, and failed.; I therefore decided to enable std::for_",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/doc/v520/index.html:2949,simpl,simply,2949,core/doc/v520/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/doc/v520/index.html,1,['simpl'],['simply']
Usability,"to the current process. Starting with ROOT version 4.00/06,; this happens automatically for all classes that are declared to the; auto-loading mechanism through so-called `rootmap` files. Effectively,; this means that all classes in the ROOT distributions are directly; available for import. For example:. ``` {.cpp}; from ROOT import TCanvas # available at startup; c = TCanvas(). from ROOT import TLorentzVector # triggers auto-load of libPhysics; l = TLorentzVector(); ```. Although it is not recommended, a simple way of working with `PyROOT` is; doing a global import:. ``` {.cpp}; from ROOT import *. c = TCanvas(); l = TLorentzVector(); ```. Keeping the ROOT namespace (""`import ROOT`""), or only importing from; ROOT those classes that you will actually use (see above), however, will; always be cleaner and clearer:. ``` {.cpp}; import ROOT. c = ROOT.TCanvas(); l = ROOT.TLorentzVector(); ```. Since it is foreseen that most people will use the simple approach; anyway, the request to copy all from module ROOT will not actually; result in copying all ROOT classes into the current namespace. Instead,; classes will still be bound (and possibly loaded) on an as-needed basis.; Note carefully how this is different from other Python (extension); modules, and what to expect if you use the normal inspection tools (such; as e.g. '`dir()`'). This feature prevents the inspection tools from; being swamped by an enormous amount of classes, but they can no longer; be used to explore unknown parts of the system (e.g. to find out which; classes are available). Furthermore, because of this approach,; \<`tab`\>-completion will usually not be available until after the first; use (and hence creation) of a class. Access to class static functions, public data members, enums, etc. is as; expected. Many more example uses of ROOT classes from Python can be; found in the tutorials directory in the ROOT distribution. The recipes; section contains a description on working with your own classes (see; """,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PythonRuby.md:10426,simpl,simple,10426,documentation/users-guide/PythonRuby.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PythonRuby.md,1,['simpl'],['simple']
Usability,"tok_else); return LogError(""expected else"");. getNextToken();. auto Else = ParseExpression();; if (!Else); return nullptr;. return std::make_unique<IfExprAST>(std::move(Cond), std::move(Then),; std::move(Else));; }. Next we hook it up as a primary expression:. .. code-block:: c++. static std::unique_ptr<ExprAST> ParsePrimary() {; switch (CurTok) {; default:; return LogError(""unknown token when expecting an expression"");; case tok_identifier:; return ParseIdentifierExpr();; case tok_number:; return ParseNumberExpr();; case '(':; return ParseParenExpr();; case tok_if:; return ParseIfExpr();; }; }. LLVM IR for If/Then/Else; ------------------------. Now that we have it parsing and building the AST, the final piece is; adding LLVM code generation support. This is the most interesting part; of the if/then/else example, because this is where it starts to; introduce new concepts. All of the code above has been thoroughly; described in previous chapters. To motivate the code we want to produce, let's take a look at a simple; example. Consider:. ::. extern foo();; extern bar();; def baz(x) if x then foo() else bar();. If you disable optimizations, the code you'll (soon) get from; Kaleidoscope looks like this:. .. code-block:: llvm. declare double @foo(). declare double @bar(). define double @baz(double %x) {; entry:; %ifcond = fcmp one double %x, 0.000000e+00; br i1 %ifcond, label %then, label %else. then: ; preds = %entry; %calltmp = call double @foo(); br label %ifcont. else: ; preds = %entry; %calltmp1 = call double @bar(); br label %ifcont. ifcont: ; preds = %else, %then; %iftmp = phi double [ %calltmp, %then ], [ %calltmp1, %else ]; ret double %iftmp; }. To visualize the control flow graph, you can use a nifty feature of the; LLVM '`opt <https://llvm.org/cmds/opt.html>`_' tool. If you put this LLVM; IR into ""t.ll"" and run ""``llvm-as < t.ll | opt -passes=view-cfg``"", `a; window will pop up <../../ProgrammersManual.html#viewing-graphs-while-debugging-code>`_ and you'll; se",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl05.rst:5179,simpl,simple,5179,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl05.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl05.rst,1,['simpl'],['simple']
Usability,"topics that need more documentation.; Please send your comments, corrections, questions, and suggestions to; the `rootdoc` list: <rootdoc@cern.ch>. We attempt to give the user insight into the many capabilities of; ROOT. The book begins with the elementary functionality and progresses; in complexity reaching the specialized topics at the end. The; experienced user looking for special topics may find these chapters; useful: see ""Networking"", ""Writing a Graphical User Interface"",; ""Threads"", and ""PROOF: Parallel Processing"". ## Conventions Used in This Book. We tried to follow a style convention for the sake of clarity. The; styles in used are described below. To show source code in scripts or source files:. ``` {.cpp}; {; cout << "" Hello"" << endl;; float x = 3.;; float y = 5.;; int i = 101;; cout <<"" x = ""<<x<<"" y = ""<<y<<"" i = ""<<i<< endl;; }; ```. To show the ROOT command line, we show the ROOT prompt without numbers.; In the interactive system, the ROOT prompt has a line number; (`root[12]`); for the sake of simplicity, the line numbers are left; off. ``` {.cpp}; root[] TLine l; root[] l.Print(); TLine X1=0.000000 Y1=0.000000 X2=0.000000 Y2=0.000000; ```. Italic bold monotype font indicates a global variable, for example; ***`gDirectory`***. When a variable term is used, it is shown between angled brackets. In; the example below the variable term \<library\> can be replaced with; any library in the `$ROOTSYS` directory: `$ROOTSYS/<library>/inc.`. ## The Framework. ROOT is an object-oriented framework aimed at solving the data; analysis challenges of high-energy physics. There are two key words in; this definition, object oriented and framework. First, we explain what; we mean by a framework and then why it is an object-oriented; framework. ### What Is a Framework?. Programming inside a framework is a little like living in a city.; Plumbing, electricity, telephone, and transportation are services; provided by the city. In your house, you have interfaces to the; serv",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md:4086,simpl,simplicity,4086,documentation/users-guide/Introduction.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md,1,['simpl'],['simplicity']
Usability,"tor operates in C++ mode, utilizing C++ reference types, while; ``-fbounds-safety`` does not currently support C++. This means LLDB’s expression; evaluator can only evaluate a subset of the ``-fbounds-safety`` language model.; Specifically, it’s capable of evaluating the wide pointers that already exist in; the source code. All other expressions are evaluated according to C/C++; semantics. C++ support; ===========. C++ has multiple options to write code in a bounds-safe manner, such as; following the bounds-safety core guidelines and/or using hardened libc++ along; with the `C++ Safe Buffer model; <https://discourse.llvm.org/t/rfc-c-buffer-hardening/65734>`_. However, these; techniques may require ABI changes and may not be applicable to code; interoperating with C. When the ABI of an existing program needs to be preserved; and for headers shared between C and C++, ``-fbounds-safety`` offers a potential; solution. ``-fbounds-safety`` is not currently supported in C++, but we believe the; general approach would be applicable for future efforts. Upstreaming plan; ================. Gradual updates with experimental flag; --------------------------------------. The upstreaming will take place as a series of smaller PRs and we will guard our; implementation with an experimental flag ``-fexperimental-bounds-safety`` until; the usable model is fully upstreamed. Once the model is ready for use, we will; expose the flag ``-fbounds-safety``. Possible patch sets; -------------------. * External bounds annotations and the (late) parsing logic.; * Internal bounds annotations (wide pointers) and their parsing logic.; * Clang code generation for wide pointers with debug information.; * Pointer cast semantics involving bounds annotations (this could be divided; into multiple sub-PRs).; * CFG analysis for pairs of related pointer and count assignments and the likes.; * Bounds check expressions in AST and the Clang code generation (this could also; be divided into multiple sub-PRs). ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafetyImplPlans.rst:11359,usab,usable,11359,interpreter/llvm-project/clang/docs/BoundsSafetyImplPlans.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafetyImplPlans.rst,1,['usab'],['usable']
Usability,"tors on objects; locally if one is thrown by the function. Most functions don't throw; exceptions, so this code is dead [with all the bad effects of dead; code, including icache pollution].; 2. Declaring a function nothrow causes catch blocks to be added to every; call that isnot provably nothrow. This makes them very slow.; 3. Extra extraneous exception edges reduce the opportunity for code; motion.; 4. EH is typically implemented with large lookup tables. Ours is going to; be much smaller (than the ""standard"" way of doing it) to start with,; but eliminating it entirely would be nice. :); 5. It is physically impossible to correctly put (accurate, correct); exception specifications on generic, templated code. But it is trivial; to analyze instantiations of said code.; 6. Most large C++ programs throw few exceptions. Most well designed; programs only throw exceptions in specific planned portions of the; code. Given our _planned_ model of handling exceptions, all of this would be; pretty trivial to eliminate through some pretty simplistic interprocedural; analysis. The DCE factor alone could probably be pretty significant. The; extra code motion opportunities could also be exploited though... Additionally, this optimization can be implemented in a straight forward; conservative manner, allowing libraries to be optimized or individual; files even (if there are leaf functions visible in the translation unit; that are called). I think it's a reasonable optimization that hasn't really been addressed; (because assembly is way too low level for this), and could have decent; payoffs... without being a overly complex optimization. After I wrote all of that, I found this page that is talking about; basically the same thing I just wrote, except that it is translation unit; at a time, tree based approach:; http://www.ocston.org/~jls/ehopt.html. but is very useful from ""expected gain"" and references perspective. Note; that their compiler is apparently unable to inline functions t",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HistoricalNotes/2001-09-18-OptimizeExceptions.txt:1469,simpl,simplistic,1469,interpreter/llvm-project/llvm/docs/HistoricalNotes/2001-09-18-OptimizeExceptions.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HistoricalNotes/2001-09-18-OptimizeExceptions.txt,1,['simpl'],['simplistic']
Usability,"towards native vector predication in LLVM,; specifically for vector instructions with a mask and/or an explicit vector; length. LLVM currently has no target-independent means to model predicated; vector instructions for modern SIMD ISAs such as AVX512, ARM SVE, the RISC-V V; extension and NEC SX-Aurora. Only some predicated vector operations, such as; masked loads and stores, are available through intrinsics [MaskedIR]_. The Vector Predication (VP) extensions is a concrete RFC and prototype; implementation to achieve native vector predication in LLVM. The VP prototype; and all related discussions can be found in the VP patch on Phabricator; [VPRFC]_. Roadmap; =======. 1. IR-level VP intrinsics; -------------------------. - There is a consensus on the semantics/instruction set of VP.; - VP intrinsics and attributes are available on IR level.; - TTI has capability flags for VP (``supportsVP()``?,; ``haveActiveVectorLength()``?). Result: VP usable for IR-level vectorizers (LV, VPlan, RegionVectorizer),; potential integration in Clang with builtins. 2. CodeGen support; ------------------. - VP intrinsics translate to first-class SDNodes; (eg ``llvm.vp.fdiv.* -> vp_fdiv``).; - VP legalization (legalize explicit vector length to mask (AVX512), legalize VP; SDNodes to pre-existing ones (SSE, NEON)). Result: Backend development based on VP SDNodes. 3. Lift InstSimplify/InstCombine/DAGCombiner to VP; --------------------------------------------------. - Introduce PredicatedInstruction, PredicatedBinaryOperator, .. helper classes; that match standard vector IR and VP intrinsics.; - Add a matcher context to PatternMatch and context-aware IR Builder APIs.; - Incrementally lift DAGCombiner to work on VP SDNodes as well as on regular; vector instructions.; - Incrementally lift InstCombine/InstSimplify to operate on VP as well as; regular IR instructions. Result: Optimization of VP intrinsics on par with standard vector instructions. 4. Deprecate llvm.masked.* / llvm.experimental.r",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Proposals/VectorPredication.rst:1145,usab,usable,1145,interpreter/llvm-project/llvm/docs/Proposals/VectorPredication.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Proposals/VectorPredication.rst,1,['usab'],['usable']
Usability,tps://github.com/llvm/llvm-project/issues/57812>`_). - Diagnose use of a variable-length array in a coroutine. The design of; coroutines is such that it is not possible to support VLA use. Fixes:; (`#65858 <https://github.com/llvm/llvm-project/issues/65858>`_). - Fix bug where we were overriding zero-initialization of class members when; default initializing a base class in a constant expression context. Fixes:; (`#69890 <https://github.com/llvm/llvm-project/issues/69890>`_). - Fix crash when template class static member imported to other translation unit.; Fixes:; (`#68769 <https://github.com/llvm/llvm-project/issues/68769>`_). - Clang now rejects incomplete types for ``__builtin_dump_struct``. Fixes:; (`#63506 <https://github.com/llvm/llvm-project/issues/63506>`_). - Fixed a crash for C++98/03 while checking an ill-formed ``_Static_assert`` expression.; Fixes: (`#72025 <https://github.com/llvm/llvm-project/issues/72025>`_). - Clang now defers the instantiation of explicit specifier until constraint checking; completes (except deduction guides). Fixes:; (`#59827 <https://github.com/llvm/llvm-project/issues/59827>`_). - Fix crash when parsing nested requirement. Fixes:; (`#73112 <https://github.com/llvm/llvm-project/issues/73112>`_). - Fixed a crash caused by using return type requirement in a lambda. Fixes:; (`#63808 <https://github.com/llvm/llvm-project/issues/63808>`_); (`#64607 <https://github.com/llvm/llvm-project/issues/64607>`_); (`#64086 <https://github.com/llvm/llvm-project/issues/64086>`_). - Fixed a crash where we lost uninstantiated constraints on placeholder NTTP packs. Fixes:; (`#63837 <https://github.com/llvm/llvm-project/issues/63837>`_). - Fixed a regression where clang forgets how to substitute into constraints on template-template; parameters. Fixes:; (`#57410 <https://github.com/llvm/llvm-project/issues/57410>`_) and; (`#76604 <https://github.com/llvm/llvm-project/issues/57410>`_). - Fix a bug where clang would produce inconsistent values when; ``,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst:53213,guid,guides,53213,interpreter/llvm-project/clang/docs/ReleaseNotes.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst,1,['guid'],['guides']
Usability,"tr, ptr, ptr)`.; Lowering will replace this intrinsic with its coroutine function argument. .. _coro.suspend.retcon:. 'llvm.coro.suspend.retcon' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^; ::. declare i1 @llvm.coro.suspend.retcon(...). Overview:; """""""""""""""""". The '``llvm.coro.suspend.retcon``' intrinsic marks the point where; execution of a returned-continuation coroutine is suspended and control; is returned back to the caller. `llvm.coro.suspend.retcon`` does not support separate save points;; they are not useful when the continuation function is not locally; accessible. That would be a more appropriate feature for a ``passcon``; lowering that is not yet implemented. Arguments:; """""""""""""""""""". The types of the arguments must exactly match the yielded-types sequence; of the coroutine. They will be turned into return values from the ramp; and continuation functions, along with the next continuation function. Semantics:; """""""""""""""""""". The result of the intrinsic indicates whether the coroutine should resume; abnormally (non-zero). In a normal coroutine, it is undefined behavior if the coroutine executes; a call to ``llvm.coro.suspend.retcon`` after resuming abnormally. In a yield-once coroutine, it is undefined behavior if the coroutine; executes a call to ``llvm.coro.suspend.retcon`` after resuming in any way. Coroutine Transformation Passes; ===============================; CoroEarly; ---------; The pass CoroEarly lowers coroutine intrinsics that hide the details of the; structure of the coroutine frame, but, otherwise not needed to be preserved to; help later coroutine passes. This pass lowers `coro.frame`_, `coro.done`_,; and `coro.promise`_ intrinsics. .. _CoroSplit:. CoroSplit; ---------; The pass CoroSplit builds coroutine frame and outlines resume and destroy parts; into separate functions. CoroElide; ---------; The pass CoroElide examines if the inlined coroutine is eligible for heap; allocation elision optimization. If so, it replaces; `coro.begin` intr",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst:55909,resume,resume,55909,interpreter/llvm-project/llvm/docs/Coroutines.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst,1,['resume'],['resume']
Usability,"trace_LIBFILE}); set(system_libs ${system_libs} ${Backtrace_LIBFILE}); endif(); if( LLVM_ENABLE_TERMINFO ); set(imported_libs ${imported_libs} Terminfo::terminfo); endif(); set(system_libs ${system_libs} ${LLVM_ATOMIC_LIB}); set(system_libs ${system_libs} ${LLVM_PTHREAD_LIB}); if( UNIX AND NOT (BEOS OR HAIKU) ); set(system_libs ${system_libs} m); endif(); if( UNIX AND ${CMAKE_SYSTEM_NAME} MATCHES ""SunOS"" ); set(system_libs ${system_libs} kstat socket); endif(); if( FUCHSIA ); set(system_libs ${system_libs} zircon); endif(); if ( HAIKU ); add_compile_definitions(_BSD_SOURCE); set(system_libs ${system_libs} bsd network); endif(); endif( MSVC OR MINGW ). # Delay load shell32.dll if possible to speed up process startup.; set (delayload_flags); if (MSVC); # When linking with Swift, `swiftc.exe` is used as the linker drive rather; # than invoking `link.exe` directly. In such a case, the flags should be; # marked as `-Xlinker` to pass them directly to the linker. As a temporary; # workaround simply elide the delay loading.; set (delayload_flags $<$<NOT:$<LINK_LANGUAGE:Swift>>:delayimp -delayload:shell32.dll -delayload:ole32.dll>); endif(). # Link Z3 if the user wants to build it.; if(LLVM_WITH_Z3); set(system_libs ${system_libs} ${Z3_LIBRARIES}); endif(). # Override the C runtime allocator on Windows and embed it into LLVM tools & libraries; if(LLVM_INTEGRATED_CRT_ALLOC); if (NOT CMAKE_MSVC_RUNTIME_LIBRARY OR CMAKE_MSVC_RUNTIME_LIBRARY MATCHES ""DLL$""); message(FATAL_ERROR ""LLVM_INTEGRATED_CRT_ALLOC only works with CMAKE_MSVC_RUNTIME_LIBRARY set to MultiThreaded or MultiThreadedDebug.""); endif(). string(REGEX REPLACE ""(/|\\\\)$"" """" LLVM_INTEGRATED_CRT_ALLOC ""${LLVM_INTEGRATED_CRT_ALLOC}""). if(NOT EXISTS ""${LLVM_INTEGRATED_CRT_ALLOC}""); message(FATAL_ERROR ""Cannot find the path to `git clone` for the CRT allocator! (${LLVM_INTEGRATED_CRT_ALLOC}). Currently, rpmalloc, snmalloc and mimalloc are supported.""); endif(). if(LLVM_INTEGRATED_CRT_ALLOC MATCHES ""rpmalloc$""); add_compil",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/CMakeLists.txt:3246,simpl,simply,3246,interpreter/llvm-project/llvm/lib/Support/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/CMakeLists.txt,1,['simpl'],['simply']
Usability,"truct') and 'typeof(F)' (aka 'float')); X = MYMAX(P, F);; ^~~~~~~~~~~; t.c:76:94: note: expanded from:; #define MYMAX(A,B) __extension__ ({ __typeof__(A) __a = (A); __typeof__(B) __b = (B); __a < __b ? __b : __a; }); ~~~ ^ ~~~. Here's another real world warning that occurs in the ""window"" Unix package (which; implements the ""wwopen"" class of APIs):. $ clang -fsyntax-only t.c; t.c:22:2: warning: type specifier missing, defaults to 'int'; ILPAD();; ^; t.c:17:17: note: expanded from:; #define ILPAD() PAD((NROW - tt.tt_row) * 10) /* 1 ms per char */; ^; t.c:14:2: note: expanded from:; register i; \; ^. In practice, we've found that Clang's treatment of macros is actually more useful in multiply nested; macros than in simple ones.; Quality of Implementation and Attention to Detail; Finally, we have put a lot of work polishing the little things, because; little things add up over time and contribute to a great user experience.; The following example shows that we recover from the simple case of; forgetting a ; after a struct definition much better than GCC. $ cat t.cc; template<class T>; class a {};; struct b {}; a<int> c;; $ gcc-4.9 t.cc; t.cc:4:8: error: invalid declarator before 'c'; a<int> c;; ^; $ clang t.cc; t.cc:3:12: error: expected ';' after struct; struct b {}; ^; ;. The following example shows that we diagnose and recover from a missing; typename keyword well, even in complex circumstances where GCC; cannot cope. $ cat t.cc; template<class T> void f(T::type) { }; struct A { };; void g(); {; A a;; f<A>(a);; }; $ gcc-4.9 t.cc; t.cc:1:33: error: variable or field 'f' declared void; template<class T> void f(T::type) { }; ^; t.cc: In function 'void g()':; t.cc:6:5: error: 'f' was not declared in this scope; f<A>(a);; ^; t.cc:6:8: error: expected primary-expression before '>' token; f<A>(a);; ^; $ clang t.cc; t.cc:1:26: error: missing 'typename' prior to dependent type name 'T::type'; template<class T> void f(T::type) { }; ^~~~~~~; typename ; t.cc:6:5: error: no match",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/diagnostics.html:10228,simpl,simple,10228,interpreter/llvm-project/clang/www/diagnostics.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/diagnostics.html,1,['simpl'],['simple']
Usability,"truction is designed to operate as a standard '``call``'; instruction in most regards. The primary difference is that it; establishes an association with additional labels to define where control; flow goes after the call. The output values of a '``callbr``' instruction are available only to; the '``fallthrough``' block, not to any '``indirect``' blocks(s). The only use of this today is to implement the ""goto"" feature of gcc inline; assembly where additional labels can be provided as locations for the inline; assembly to jump to. Example:; """""""""""""""". .. code-block:: llvm. ; ""asm goto"" without output constraints.; callbr void asm """", ""r,!i""(i32 %x); to label %fallthrough [label %indirect]. ; ""asm goto"" with output constraints.; <result> = callbr i32 asm """", ""=r,r,!i""(i32 %x); to label %fallthrough [label %indirect]. .. _i_resume:. '``resume``' Instruction; ^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. resume <type> <value>. Overview:; """""""""""""""""". The '``resume``' instruction is a terminator instruction that has no; successors. Arguments:; """""""""""""""""""". The '``resume``' instruction requires one argument, which must have the; same type as the result of any '``landingpad``' instruction in the same; function. Semantics:; """""""""""""""""""". The '``resume``' instruction resumes propagation of an existing; (in-flight) exception whose unwinding was interrupted with a; :ref:`landingpad <i_landingpad>` instruction. Example:; """""""""""""""". .. code-block:: llvm. resume { ptr, i32 } %exn. .. _i_catchswitch:. '``catchswitch``' Instruction; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. <resultval> = catchswitch within <parent> [ label <handler1>, label <handler2>, ... ] unwind to caller; <resultval> = catchswitch within <parent> [ label <handler1>, label <handler2>, ... ] unwind label <default>. Overview:; """""""""""""""""". The '``catchswitch``' instruction is used by `LLVM's exception handling system; <ExceptionHandling.html#overview>`_ to describe the set of possible catch handlers; that may ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:369831,resume,resume,369831,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['resume'],['resume']
Usability,"tructions may have the same `DIAssignID`; instruction. In this case, the assignment is considered to take place in; multiple positions in the program. **Moving** a non-debug instruction: nothing new to do. Instructions linked to an; `llvm.dbg.assign` have their initial IR position marked by the position of the; `llvm.dbg.assign`. **Deleting** a non-debug instruction: nothing new to do. Simple DSE does not; require any change; it’s safe to delete an instruction with a `DIAssignID`; attachment. An `llvm.dbg.assign` that uses a `DIAssignID` that is not attached; to any instruction indicates that the memory location isn’t valid. **Merging** stores: In many cases no change is required as `DIAssignID`; attachments are automatically merged if `combineMetadata` is called. One way or; another, the `DIAssignID` attachments must be merged such that new store; becomes linked to all the `llvm.dbg.assign` intrinsics that the merged stores; were linked to. This can be achieved simply by calling a helper function; `Instruction::mergeDIAssignID`. **Inlining** stores: As stores are inlined we generate `llvm.dbg.assign`; intrinsics and `DIAssignID` attachments as if the stores represent source; assignments, just like the in frontend. This isn’t perfect, as stores may have; been moved, modified or deleted before inlining, but it does at least keep the; information about the variable correct within the non-inlined scope. **Splitting** stores: SROA and passes that split stores treat `llvm.dbg.assign`; intrinsics similarly to `llvm.dbg.declare` intrinsics. Clone the; `llvm.dbg.assign` intrinsics linked to the store, update the FragmentInfo in; the `ValueExpression`, and give the split stores (and cloned intrinsics) new; `DIAssignID` attachments each. In other words, treat the split stores as; separate assignments. For partial DSE (e.g. shortening a memset), we do the; same except that `llvm.dbg.assign` for the dead fragment gets an `Undef`; `Address`. **Promoting** allocas and store/loads",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AssignmentTracking.md:6837,simpl,simply,6837,interpreter/llvm-project/llvm/docs/AssignmentTracking.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AssignmentTracking.md,1,['simpl'],['simply']
Usability,"tructions. This pass does not; modify the CFG. This pass is where algebraic simplification happens. This pass combines things like:. .. code-block:: llvm. %Y = add i32 %X, 1; %Z = add i32 %Y, 1. into:. .. code-block:: llvm. %Z = add i32 %X, 2. This is a simple worklist driven algorithm. This pass guarantees that the following canonicalizations are performed on the; program:. #. If a binary operator has a constant operand, it is moved to the right-hand; side.; #. Bitwise operators with constant operands are always grouped so that shifts; are performed first, then ``or``\ s, then ``and``\ s, then ``xor``\ s.; #. Compare instructions are converted from ``<``, ``>``, ``≤``, or ``≥`` to; ``=`` or ``≠`` if possible.; #. All ``cmp`` instructions on boolean values are replaced with logical; operations.; #. ``add X, X`` is represented as ``mul X, 2`` ⇒ ``shl X, 1``; #. Multiplies with a constant power-of-two argument are transformed into; shifts.; #. … etc. This pass can also simplify calls to specific well-known function calls (e.g.; runtime library functions). For example, a call ``exit(3)`` that occurs within; the ``main()`` function can be transformed into simply ``return 3``. Whether or; not library calls are simplified is controlled by the; :ref:`-function-attrs <passes-function-attrs>` pass and LLVM's knowledge of; library calls on different targets. .. _passes-aggressive-instcombine:. ``aggressive-instcombine``: Combine expression patterns; --------------------------------------------------------. Combine expression patterns to form expressions with fewer, simple instructions. For example, this pass reduce width of expressions post-dominated by TruncInst; into smaller width when applicable. It differs from instcombine pass in that it can modify CFG and contains pattern; optimization that requires higher complexity than the O(1), thus, it should run fewer; times than instcombine pass. ``internalize``: Internalize Global Symbols; ---------------------------------------",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Passes.rst:20418,simpl,simplify,20418,interpreter/llvm-project/llvm/docs/Passes.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Passes.rst,1,['simpl'],['simplify']
Usability,"tructure is slower than using a stack map; compiled into the executable as constant data, but has a significant portability; advantage because it requires no special support from the target code generator,; and does not require tricky platform-specific code to crawl the machine stack. The tradeoff for this simplicity and portability is:. * High overhead per function call. * Not thread-safe. Still, it's an easy way to get started. After your compiler and runtime are up; and running, writing a :ref:`plugin <plugin>` will allow you to take advantage; of :ref:`more advanced GC features <collector-algos>` of LLVM in order to; improve performance. The shadow stack doesn't imply a memory allocation algorithm. A semispace; collector or building atop ``malloc`` are great places to start, and can be; implemented with very little code. When it comes time to collect, however, your runtime needs to traverse the stack; roots, and for this it needs to integrate with the shadow stack. Luckily, doing; so is very simple. (This code is heavily commented to help you understand the; data structure, but there are only 20 lines of meaningful code.). .. code-block:: c++. /// The map for a single function's stack frame. One of these is; /// compiled as constant data into the executable for each function.; ///; /// Storage of metadata values is elided if the %metadata parameter to; /// @llvm.gcroot is null.; struct FrameMap {; int32_t NumRoots; //< Number of roots in stack frame.; int32_t NumMeta; //< Number of metadata entries. May be < NumRoots.; const void *Meta[0]; //< Metadata for each root.; };. /// A link in the dynamic shadow stack. One of these is embedded in; /// the stack frame of each function on the call stack.; struct StackEntry {; StackEntry *Next; //< Link to next stack entry (the caller's).; const FrameMap *Map; //< Pointer to constant FrameMap.; void *Roots[0]; //< Stack roots (in-place array).; };. /// The head of the singly-linked list of StackEntries. Functions push; /// ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GarbageCollection.rst:17411,simpl,simple,17411,interpreter/llvm-project/llvm/docs/GarbageCollection.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GarbageCollection.rst,1,['simpl'],['simple']
Usability,"true.i.i.i.i; call void @_ZSt17__throw_bad_allocv() noreturn nounwind; unreachable. _ZNSt12_Vector_baseIiSaIiEEC2EmRKS0_.exit.i.i: ; preds = %cond.true.i.i.i.i; %mul.i.i.i.i.i = shl i64 %conv, 2; %call3.i.i.i.i.i = call noalias i8* @_Znwm(i64 %mul.i.i.i.i.i) nounwind; %0 = bitcast i8* %call3.i.i.i.i.i to i32*; store i32* %0, i32** %v2.sub, align 8, !tbaa !0; store i32* %0, i32** %tmp3.i.i.i.i.i, align 8, !tbaa !0; %add.ptr.i.i.i = getelementptr inbounds i32* %0, i64 %conv; store i32* %add.ptr.i.i.i, i32** %tmp4.i.i.i.i.i, align 8, !tbaa !0; call void @llvm.memset.p0i8.i64(i8* %call3.i.i.i.i.i, i8 0, i64 %mul.i.i.i.i.i, i32 4, i1 false); br label %_ZNSt6vectorIiSaIiEEC1EmRKiRKS0_.exit. This is just the handling the construction of the vector. Most surprising here; is the fact that all three null stores in %entry are dead (because we do no; cross-block DSE). Also surprising is that %conv isn't simplified to 0 in %....exit.thread.i.i.; This is a because the client of LazyValueInfo doesn't simplify all instruction; operands, just selected ones. //===---------------------------------------------------------------------===//. clang -O3 -fno-exceptions currently compiles this code:. void f(char* a, int n) {; __builtin_memset(a, 0, n);; for (int i = 0; i < n; ++i); a[i] = 0;; }. into:. define void @_Z1fPci(i8* nocapture %a, i32 %n) nounwind {; entry:; %conv = sext i32 %n to i64; tail call void @llvm.memset.p0i8.i64(i8* %a, i8 0, i64 %conv, i32 1, i1 false); %cmp8 = icmp sgt i32 %n, 0; br i1 %cmp8, label %for.body.lr.ph, label %for.end. for.body.lr.ph: ; preds = %entry; %tmp10 = add i32 %n, -1; %tmp11 = zext i32 %tmp10 to i64; %tmp12 = add i64 %tmp11, 1; call void @llvm.memset.p0i8.i64(i8* %a, i8 0, i64 %tmp12, i32 1, i1 false); ret void. for.end: ; preds = %entry; ret void; }. This shouldn't need the ((zext (%n - 1)) + 1) game, and it should ideally fold; the two memset's together. The issue with the addition only occurs in 64-bit mode, and appears to be at; least partially ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/README.txt:58323,simpl,simplify,58323,interpreter/llvm-project/llvm/lib/Target/README.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/README.txt,1,['simpl'],['simplify']
Usability,"try_2E_ce:; mov r2, #1; lsl r2, r0; cmp r0, #9; bhi LBB1_4 @bb12.exitStub; LBB1_1: @newFuncRoot; mov r1, #13; tst r2, r1; bne LBB1_5 @bb4.exitStub; LBB1_2: @newFuncRoot; ldr r1, LCPI1_0; tst r2, r1; bne LBB1_6 @bb9.exitStub; LBB1_3: @newFuncRoot; mov r1, #1; lsl r1, r1, #8; tst r2, r1; bne LBB1_7 @bb.exitStub; LBB1_4: @bb12.exitStub; mov r0, #0; bx lr; LBB1_5: @bb4.exitStub; mov r0, #1; bx lr; LBB1_6: @bb9.exitStub; mov r0, #2; bx lr; LBB1_7: @bb.exitStub; mov r0, #3; bx lr; LBB1_8:; .align 2; LCPI1_0:; .long 642. gcc compiles to:. 	cmp	r0, #9; 	@ lr needed for prologue; 	bhi	L2; 	ldr	r3, L11; 	mov	r2, #1; 	mov	r1, r2, asl r0; 	ands	r0, r3, r2, asl r0; 	movne	r0, #2; 	bxne	lr; 	tst	r1, #13; 	beq	L9; L3:; 	mov	r0, r2; 	bx	lr; L9:; 	tst	r1, #256; 	movne	r0, #3; 	bxne	lr; L2:; 	mov	r0, #0; 	bx	lr; L12:; 	.align 2; L11:; 	.long	642; . GCC is doing a couple of clever things here:; 1. It is predicating one of the returns. This isn't a clear win though: in; cases where that return isn't taken, it is replacing one condbranch with; two 'ne' predicated instructions.; 2. It is sinking the shift of ""1 << i"" into the tst, and using ands instead of; tst. This will probably require whole function isel.; 3. GCC emits:; 	tst	r1, #256; we emit:; mov r1, #1; lsl r1, r1, #8; tst r2, r1. //===---------------------------------------------------------------------===//. When spilling in thumb mode and the sp offset is too large to fit in the ldr /; str offset field, we load the offset from a constpool entry and add it to sp:. ldr r2, LCPI; add r2, sp; ldr r2, [r2]. These instructions preserve the condition code which is important if the spill; is between a cmp and a bcc instruction. However, we can use the (potentially); cheaper sequence if we know it's ok to clobber the condition register. add r2, sp, #255 * 4; add r2, #132; ldr r2, [r2, #7 * 4]. This is especially bad when dynamic alloca is used. The all fixed size stack; objects are referenced off the frame pointer with negative offsets.",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/README-Thumb.txt:3573,clear,clear,3573,interpreter/llvm-project/llvm/lib/Target/ARM/README-Thumb.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/README-Thumb.txt,1,['clear'],['clear']
Usability,"ts *must* adhere to the guidelines specified below to ensure; proper operation in multithreaded mode. Note that, on Unix-like platforms, LLVM requires the presence of GCC's atomic; intrinsics in order to support threaded operation. If you need a; multithreading-capable LLVM on a platform without a suitably modern system; compiler, consider compiling LLVM and LLVM-GCC in single-threaded mode, and; using the resultant compiler to build a copy of LLVM with multithreading; support. .. _shutdown:. Ending Execution with ``llvm_shutdown()``; -----------------------------------------. When you are done using the LLVM APIs, you should call ``llvm_shutdown()`` to; deallocate memory used for internal structures. .. _managedstatic:. Lazy Initialization with ``ManagedStatic``; ------------------------------------------. ``ManagedStatic`` is a utility class in LLVM used to implement static; initialization of static resources, such as the global type tables. In a; single-threaded environment, it implements a simple lazy initialization scheme.; When LLVM is compiled with support for multi-threading, however, it uses; double-checked locking to implement thread-safe lazy initialization. .. _llvmcontext:. Achieving Isolation with ``LLVMContext``; ----------------------------------------. ``LLVMContext`` is an opaque class in the LLVM API which clients can use to; operate multiple, isolated instances of LLVM concurrently within the same; address space. For instance, in a hypothetical compile-server, the compilation; of an individual translation unit is conceptually independent from all the; others, and it would be desirable to be able to compile incoming translation; units concurrently on independent server threads. Fortunately, ``LLVMContext``; exists to enable just this kind of scenario!. Conceptually, ``LLVMContext`` provides isolation. Every LLVM entity; (``Module``\ s, ``Value``\ s, ``Type``\ s, ``Constant``\ s, etc.) in LLVM's; in-memory IR belongs to an ``LLVMContext``. Entities",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:122305,simpl,simple,122305,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,1,['simpl'],['simple']
Usability,"ts an error message if it is not. .. productionlist::; Assert: ""assert"" `condition` "","" `message` "";"". If the boolean condition is true, the statement does nothing. If the; condition is false, it prints a nonfatal error message. The **message**, which; can be an arbitrary string expression, is included in the error message as a; note. The exact behavior of the ``assert`` statement depends on its; placement. * At top level, the assertion is checked immediately. * In a record definition, the statement is saved and all assertions are; checked after the record is completely built. * In a class definition, the assertions are saved and inherited by all; the subclasses and records that inherit from the class. The assertions are; then checked when the records are completely built. * In a multiclass definition, the assertions are saved with the other; components of the multiclass and then checked each time the multiclass; is instantiated with ``defm``. Using assertions in TableGen files can simplify record checking in TableGen; backends. Here is an example of an ``assert`` in two class definitions. .. code-block:: text. class PersonName<string name> {; assert !le(!size(name), 32), ""person name is too long: "" # name;; string Name = name;; }. class Person<string name, int age> : PersonName<name> {; assert !and(!ge(age, 1), !le(age, 120)), ""person age is invalid: "" # age;; int Age = age;; }. def Rec20 : Person<""Donald Knuth"", 60> {; ...; }. Additional Details; ==================. Directed acyclic graphs (DAGs); ------------------------------. A directed acyclic graph can be represented directly in TableGen using the; ``dag`` datatype. A DAG node consists of an operator and zero or more; arguments (or operands). Each argument can be of any desired type. By using; another DAG node as an argument, an arbitrary graph of DAG nodes can be; built. The syntax of a ``dag`` instance is:. ``(`` *operator* *argument1*\ ``,`` *argument2*\ ``,`` ... ``)``. The operator must be present and mus",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TableGen/ProgRef.rst:50021,simpl,simplify,50021,interpreter/llvm-project/llvm/docs/TableGen/ProgRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TableGen/ProgRef.rst,1,['simpl'],['simplify']
Usability,"ts should be accurate and very close to those you would have got; without limits. In other cases (which should be more common, since; otherwise you wouldn't need limits), the very meaning of parameter; errors becomes problematic. Mathematically, since the limit is an; absolute constraint on the parameter, a parameter at its limit has no; error, at least in one direction. The error matrix, which can assign; only symmetric errors, then becomes essentially meaningless. On the; other hand, the $\mbox{MINOS}$ analysis is still meaningful, at; least in principle, as long as $\mbox{MIGRAD}$ (which is called; internally by $\mbox{MINOS}$) does not get blocked at a limit.; Unfortunately, the user has no control over this aspect of the; $\mbox{MINOS}$ calculation, although it is possible to get enough; printout from the $\mbox{MINOS}$ result to be able to determine; whether the results are reliable or not. ## Fixing and releasing parameters ##. When M needs to be guided to the ""right"" minimum, often the best way to; do this is with the methods e.g. MnMigrad::fix(...) and; MnMigrad::release(...). That is, suppose you have a problem with ten; free parameters, and when you minimize with respect to all at once, M; goes to an unphysical solution characterized by an unphysical or; unwanted value of parameter number four. One way to avoid this is to fix; parameter four at a ""good"" value (not necessarily the best, since you; presumably don't know that yet), and minimize with respect to the; others. Then release parameter four and minimize again. If the problem; admits a ""good"" physical solution, you will normally find it this way.; If it doesn't work, you may see what is wrong by the following sequence; (where $\mbox{xxx}$ is the expected physical value for parameter; four):. MnMigrad migrad(...);; migrad.setValue(4, xxx);; migrad.fix(4);; FunctionMinimum min = migrad();; migrad.release(4);; MnScan scan(...);; std::vector<std::pair<double, double> > points = scan(4);. where $\mbox{SC",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md:66534,guid,guided,66534,documentation/minuit2/Minuit2.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md,1,['guid'],['guided']
Usability,"ts the optimizer; from performing unsound optimizations.; #. recording a mapping of live pointers (and the allocation they're; associated with) for each statepoint. At the most abstract level, inserting a safepoint can be thought of as; replacing a call instruction with a call to a multiple return value; function which both calls the original target of the call, returns; its result, and returns updated values for any live pointers to; garbage collected objects. Note that the task of identifying all live pointers to garbage; collected values, transforming the IR to expose a pointer giving the; base object for every such live pointer, and inserting all the; intrinsics correctly is explicitly out of scope for this document.; The recommended approach is to use the :ref:`utility passes; <statepoint-utilities>` described below. This abstract function call is concretely represented by a sequence of; intrinsic calls known collectively as a ""statepoint relocation sequence"". Let's consider a simple call in LLVM IR:. .. code-block:: llvm. define i8 addrspace(1)* @test1(i8 addrspace(1)* %obj); gc ""statepoint-example"" {; call void ()* @foo(); ret i8 addrspace(1)* %obj; }. Depending on our language we may need to allow a safepoint during the execution; of ``foo``. If so, we need to let the collector update local values in the; current frame. If we don't, we'll be accessing a potential invalid reference; once we eventually return from the call. In this example, we need to relocate the SSA value ``%obj``. Since we can't; actually change the value in the SSA value ``%obj``, we need to introduce a new; SSA value ``%obj.relocated`` which represents the potentially changed value of; ``%obj`` after the safepoint and update any following uses appropriately. The; resulting relocation sequence is:. .. code-block:: llvm. define i8 addrspace(1)* @test1(i8 addrspace(1)* %obj); gc ""statepoint-example"" {; %0 = call token (i64, i32, void ()*, i32, i32, ...)* @llvm.experimental.gc.statepoint.p0f_",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Statepoints.rst:7983,simpl,simple,7983,interpreter/llvm-project/llvm/docs/Statepoints.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Statepoints.rst,1,['simpl'],['simple']
Usability,"ts) can be produced from a TTree using the; “candle” option in TTree::Draw(). ``` {.cpp}; tree->Draw(“px:cos(py):sin(pz)”,””,”candle”);; ```. ### Using TTree::Scan; \index{tree!scan}. `TTree::Scan` can be used to print the content of the tree's entries; optional passing a selection. ``` {.cpp}; root[] MyTree->Scan();; ```. will print the first 8 variables of the tree. ``` {.cpp}; root[] MyTree->Scan(""*"");; ```. will print all the variable of the tree. Specific variables of the tree can be explicit selected by list them in; column separated list:. ``` {.cpp}; root[] MyTree->Scan(""var1:var2:var3"");; ```. will print the values of `var1`, `var2` and `var3`. A selection can be; applied in the second argument:. ``` {.cpp}; root[] MyTree->Scan(""var1:var2:var3"",""var1==0"");; ```. will print the values of `var1`, `var2` and `var3` for the entries where; var1 is exactly 0. `TTree::Scan` returns the number of entries passing the selection. By; default 50 rows are shown before `TTree::Scan` pauses and ask you to; press the Enter key to see the next 50 rows. You can change the default; number of rows to be shown before \<CR\> via; `mytree->SetScanfield(maxrows)` where maxrows is 50 by default. If; maxrows is set to 0 all rows of the **`Tree`** are shown. This option is; interesting when dumping the contents of a Tree to an ascii file, eg; from the command line:. ``` {.cpp}; root[] tree->SetScanField(0);; root[] tree->Scan(""*""); >tree.log; ```. will create a file `tree.log`. Arrays (within an entry) are printed in their linear forms. If several; arrays with multiple dimensions are printed together, they will NOT be; synchronized. For example, with a tree containing `arr1[4][2] `and; `arr2[2][3]`,. ``` {.cpp}; root[] MyTree(""arr1:arr2"");; ```. will results in a printing similar to:. ``` {.cpp}; ************************************************; * Row * Instance * arr1 * arr2 *; ***********************************************; * x * 0 * arr1[0][0]* arr2[0][0]*; * x * 1 * arr1[0][1]* a",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:105498,pause,pauses,105498,documentation/users-guide/Trees.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md,1,['pause'],['pauses']
Usability,"ts<8> Opcode = { 0, 0, 0, 0, 0, 0, 0, 1 };; Format Form = MRMDestReg;; bits<7> FormBits = { 0, 1, 0, 1, 0, 0, 0 };; ImmType ImmT = NoImm;; bit ForceDisassemble = 0;; OperandSize OpSize = OpSize32;; bits<2> OpSizeBits = { 1, 0 };; AddressSize AdSize = AdSizeX;; bits<2> AdSizeBits = { 0, 0 };; Prefix OpPrefix = NoPrfx;; bits<3> OpPrefixBits = { 0, 0, 0 };; Map OpMap = OB;; bits<3> OpMapBits = { 0, 0, 0 };; bit hasREX_WPrefix = 0;; FPFormat FPForm = NotFP;; bit hasLockPrefix = 0;; Domain ExeDomain = GenericDomain;; bit hasREPPrefix = 0;; Encoding OpEnc = EncNormal;; bits<2> OpEncBits = { 0, 0 };; bit HasVEX_W = 0;; bit IgnoresVEX_W = 0;; bit EVEX_W1_VEX_W0 = 0;; bit hasVEX_4V = 0;; bit hasVEX_L = 0;; bit ignoresVEX_L = 0;; bit hasEVEX_K = 0;; bit hasEVEX_Z = 0;; bit hasEVEX_L2 = 0;; bit hasEVEX_B = 0;; bits<3> CD8_Form = { 0, 0, 0 };; int CD8_EltSize = 0;; bit hasEVEX_RC = 0;; bit hasNoTrackPrefix = 0;; bits<7> VectSize = { 0, 0, 1, 0, 0, 0, 0 };; bits<7> CD8_Scale = { 0, 0, 0, 0, 0, 0, 0 };; string FoldGenRegForm = ?;; string EVEX2VEXOverride = ?;; bit isMemoryFoldable = 1;; bit notEVEX2VEXConvertible = 0;; }. On the first line of the record, you can see that the ``ADD32rr`` record; inherited from eight classes. Although the inheritance hierarchy is complex,; using parent classes is much simpler than specifying the 109 individual; fields for each instruction. Here is the code fragment used to define ``ADD32rr`` and multiple other; ``ADD`` instructions:. .. code-block:: text. defm ADD : ArithBinOp_RF<0x00, 0x02, 0x04, ""add"", MRM0r, MRM0m,; X86add_flag, add, 1, 1, 1>;. The ``defm`` statement tells TableGen that ``ArithBinOp_RF`` is a; multiclass, which contains multiple concrete record definitions that inherit; from ``BinOpRR_RF``. That class, in turn, inherits from ``BinOpRR``, which; inherits from ``ITy`` and ``Sched``, and so forth. The fields are inherited; from all the parent classes; for example, ``IsIndirectBranch`` is inherited; from the ``Instruction`` class.; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TableGen/ProgRef.rst:78831,simpl,simpler,78831,interpreter/llvm-project/llvm/docs/TableGen/ProgRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TableGen/ProgRef.rst,1,['simpl'],['simpler']
Usability,"tself - what we need; to do is to take it out and to ignore all the rest since it is a; self-contained object. In fact, the modeller can act like this,; considering a given volume as temporary MARS, but we will describe this; feature later on. Let us focus on the biggest pack - it is mandatory to; define one. Consider the simplest geometry that is made of a single box.; Here is an example on how to build it:. ### Example 1: Creating the World. We first need to load the geometry library. This is not needed if one; does `make map` in root folder. ``` {.cpp}; root[] gSystem->Load(""libGeom"");; ```. Second, we have to create an instance of the geometry manager class.; This takes care of all the modeller components, performing several tasks; to insure geometry validity and containing the user interface for; building and interacting with the geometry. After its creation, the; geometry manager class can be accessed with the global; ***`gGeoManager`***:. ``` {.cpp}; root[] new TGeoManager(""world"", ""the simplest geometry"");; ```. We want to create a single volume in our geometry, but since any volume; needs to have an associated medium, we will create a dummy one. You can; safely ignore the following lines for the time being, since materials; and media will be explained in detail later on. ``` {.cpp}; root[] TGeoMaterial *mat = new TGeoMaterial(""Vacuum"",0,0,0);; root[] TGeoMedium *med = new TGeoMedium(""Vacuum"",1,mat);; ```. We can finally make our volume having a box shape. Note that the world; volume does not need to be a box - it can be any other shape. Generally,; boxes and tubes are the most recommendable shapes for this purpose due; to their fast navigation algorithms. ``` {.cpp}; root[] TGeoVolume *top=gGeoManager->MakeBox(""Top"",med,10.,10.,10.);; ```. The default units are in centimeters. Now we want to make this volume; our world. We have to do this operation **before** closing the geometry. ``` {.cpp}; root[] gGeoManager->SetTopVolume(top);; ```. This should be enough",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:2673,simpl,simplest,2673,documentation/users-guide/Geometry.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md,1,['simpl'],['simplest']
Usability,"ttern matches,; and ``CHECK-NOT:`` patterns that do not have matches. Implies ``-v``.; However, if ``-dump-input=fail`` or ``-dump-input=always``, just add that; information as input annotations instead. .. option:: --allow-deprecated-dag-overlap. Enable overlapping among matches in a group of consecutive ``CHECK-DAG:``; directives. This option is deprecated and is only provided for convenience; as old tests are migrated to the new non-overlapping ``CHECK-DAG:``; implementation. .. option:: --allow-empty. Allow checking empty input. By default, empty input is rejected. .. option:: --color. Use colors in output (autodetected by default). EXIT STATUS; -----------. If :program:`FileCheck` verifies that the file matches the expected contents,; it exits with 0. Otherwise, if not, or if an error occurs, it will exit with a; non-zero value. TUTORIAL; --------. FileCheck is typically used from LLVM regression tests, being invoked on the RUN; line of the test. A simple example of using FileCheck from a RUN line looks; like this:. .. code-block:: llvm. ; RUN: llvm-as < %s | llc -march=x86-64 | FileCheck %s. This syntax says to pipe the current file (""``%s``"") into ``llvm-as``, pipe; that into ``llc``, then pipe the output of ``llc`` into ``FileCheck``. This; means that FileCheck will be verifying its standard input (the llc output); against the filename argument specified (the original ``.ll`` file specified by; ""``%s``""). To see how this works, let's look at the rest of the ``.ll`` file; (after the RUN line):. .. code-block:: llvm. define void @sub1(i32* %p, i32 %v) {; entry:; ; CHECK: sub1:; ; CHECK: subl; %0 = tail call i32 @llvm.atomic.load.sub.i32.p0i32(i32* %p, i32 %v); ret void; }. define void @inc4(i64* %p) {; entry:; ; CHECK: inc4:; ; CHECK: incq; %0 = tail call i64 @llvm.atomic.load.add.i64.p0i64(i64* %p, i64 1); ret void; }. Here you can see some ""``CHECK:``"" lines specified in comments. Now you can; see how the file is piped into ``llvm-as``, then ``llc``, and the ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/FileCheck.rst:7907,simpl,simple,7907,interpreter/llvm-project/llvm/docs/CommandGuide/FileCheck.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/FileCheck.rst,1,['simpl'],['simple']
Usability,"tting it into another is not necessarily easier than re-doing it.; > Optimization code is usually heavily tied in to the specific IR they use. Understood. The only reason that I brought this up is because SGI's IR is; more similar to LLVM than it is different in many respects (SSA based,; relatively low level, etc), and could be easily adapted. Also their; optimizations are written in C++ and are actually somewhat; structured... of course it would be no walk in the park, but it would be; much less time consuming to adapt, say, SSA-PRE than to rewrite it. > But your larger point is valid that adding SSA based optimizations is; > feasible and should be fun. (Again, link time cost is the issue.). Assuming linktime cost wasn't an issue, the question is: ; Does using GCC's backend buy us anything?. > It also occurs to me that GCC is probably doing quite a bit of back-end; > optimization (step 16 in your list). Do you have a breakdown of that?. Not really. The irritating part of GCC is that it mixes it all up and; doesn't have a clean separation of concerns. A lot of the ""back end; optimization"" happens right along with other data optimizations (ie, CSE; of machine specific things). As far as REAL back end optimizations go, it looks something like this:. 1. Instruction combination: try to make CISCy instructions, if available; 2. Register movement: try to get registers in the right places for the; architecture to avoid register to register moves. For example, try to get; the first argument of a function to naturally land in %o0 for sparc.; 3. Instruction scheduling: 'nuff said :); 4. Register class preferencing: ??; 5. Local register allocation; 6. global register allocation; 7. Spilling; 8. Local regalloc; 9. Jump optimization; 10. Delay slot scheduling; 11. Branch shorting for CISC machines; 12. Instruction selection & peephole optimization; 13. Debug info output. But none of this would be usable for LLVM anyways, unless we were using; GCC as a static compiler. -Chris. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HistoricalNotes/2001-06-01-GCCOptimizations2.txt:2914,usab,usable,2914,interpreter/llvm-project/llvm/docs/HistoricalNotes/2001-06-01-GCCOptimizations2.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HistoricalNotes/2001-06-01-GCCOptimizations2.txt,1,['usab'],['usable']
Usability,"ture were; required:; TEveProjectable::ProjectedClass() takes an argument:; virtual TClass* ProjectedClass(const TEveProjection* p) const = 0;; thus allowing different projected classes for different projections.; All TEveProjection::ProjectPoint/Vector(...) functions have an; additional ""depth"" argument thus allowing the projected classes to; skip explicit setting of depth after the point has been projected; -- this could damage the 3rd component. Pre-scaling now supports 3 dimensions.; Abstract TEveProjected::SetDepth() has been split into two parts:; ; It has been implemented in the base class where it checks for; the projection type (2d) before calling the local function;; Abstract SetDepthLocal() has been added to provide the same; functionality. This allows for the 2d/3d check to be done in place only.; New projection class has been introduced: TEve3DProjection.; It performs pre-scaling and offsets the center.; To simplify the projection of lists TEveElementList has been made; projectable and corresponding TEveElementListProjected class; introduced. This also fixed the problem with render-state not being; propagated to projected classes. The check whether to project a sub-tree of elements is still performed.; TEveGeoShapeProjected has been introduced to represent the 3D; projection of a TEveGeoShape (2D projection is handled by; TEvePolygonSetProjected). Points, lines and tracks use the same projected class for both 2D; and 3D projections. An example showing this functionality has been added as a new tab in; projection_prescale.C.; TEveManager now allows simultaneous usage of several objects; editors. Simply click on the top name-button in object editor to; create a standalone editor for this object in a separate window. This; facilitates operation when several objects need to be modifed in; parallel.; New tutorial alice_vsd.C has been added. It shows; how to read Visualization Summary Data files (VSD).; Code for operating three view configuration (3D / RPhi /",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/doc/v526/index.html:2578,simpl,simplify,2578,graf3d/doc/v526/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/doc/v526/index.html,1,['simpl'],['simplify']
Usability,"turn std::coroutine_handle<promise_type>::from_promise(*this); }; std::suspend_always initial_suspend() { return {}; }; std::suspend_always final_suspend() noexcept { return {}; }; void return_void() noexcept {}; void unhandled_exception() noexcept {}. int count = 0;; };. void resume() noexcept {; handle.resume();; }. task(std::coroutine_handle<promise_type> hdl) : handle(hdl) {}; ~task() {; if (handle); handle.destroy();; }. std::coroutine_handle<> handle;; };. class await_counter : public std::suspend_always {; public:; template<class PromiseType>; void await_suspend(std::coroutine_handle<PromiseType> handle) noexcept {; handle.promise().count++;; }; };. static task coro_task(int v) {; int a = v;; co_await await_counter{};; a++;; std::cout << a << ""\n"";; a++;; std::cout << a << ""\n"";; a++;; std::cout << a << ""\n"";; co_await await_counter{};; a++;; std::cout << a << ""\n"";; a++;; std::cout << a << ""\n"";; }. int main() {; task t = coro_task(43);; t.resume();; t.resume();; t.resume();; return 0;; }. In debug mode (`O0` + `g`), the printing result would be:. .. parsed-literal::. {__resume_fn = 0x4019e0 <coro_task(int)>, __destroy_fn = 0x402000 <coro_task(int)>, __promise = {count = 1}, v = 43, a = 45, __coro_index = 1 '\001', struct_std__suspend_always_0 = {__int_8 = 0 '\000'},; class_await_counter_1 = {__int_8 = 0 '\000'}, class_await_counter_2 = {__int_8 = 0 '\000'}, struct_std__suspend_always_3 = {__int_8 = 0 '\000'}}. In the above, the values of `v` and `a` are clearly expressed, as are the; temporary values for `await_counter` (`class_await_counter_1` and; `class_await_counter_2`) and `std::suspend_always` (; `struct_std__suspend_always_0` and `struct_std__suspend_always_3`). The index; of the current suspension point of the coroutine is emitted as `__coro_index`.; In the above example, the `__coro_index` value of `1` means the coroutine; stopped at the second suspend point (Note that `__coro_index` is zero indexed); which is the first `co_await await_counter{};` ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DebuggingCoroutines.rst:7160,resume,resume,7160,interpreter/llvm-project/clang/docs/DebuggingCoroutines.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DebuggingCoroutines.rst,1,['resume'],['resume']
Usability,"ty cannot be determined statically at compile time. For our; example, the coroutine frame will be:. .. code-block:: llvm. %f.frame = type { ptr, ptr, i32 }. After resume and destroy parts are outlined, function `f` will contain only the; code responsible for creation and initialization of the coroutine frame and; execution of the coroutine until a suspend point is reached:. .. code-block:: llvm. define ptr @f(i32 %n) {; entry:; %id = call token @llvm.coro.id(i32 0, ptr null, ptr null, ptr null); %alloc = call noalias ptr @malloc(i32 24); %frame = call noalias ptr @llvm.coro.begin(token %id, ptr %alloc); %1 = getelementptr %f.frame, ptr %frame, i32 0, i32 0; store ptr @f.resume, ptr %1; %2 = getelementptr %f.frame, ptr %frame, i32 0, i32 1; store ptr @f.destroy, ptr %2. %inc = add nsw i32 %n, 1; %inc.spill.addr = getelementptr inbounds %f.Frame, ptr %FramePtr, i32 0, i32 2; store i32 %inc, ptr %inc.spill.addr; call void @print(i32 %n). ret ptr %frame; }. Outlined resume part of the coroutine will reside in function `f.resume`:. .. code-block:: llvm. define internal fastcc void @f.resume(ptr %frame.ptr.resume) {; entry:; %inc.spill.addr = getelementptr %f.frame, ptr %frame.ptr.resume, i64 0, i32 2; %inc.spill = load i32, ptr %inc.spill.addr, align 4; %inc = add i32 %inc.spill, 1; store i32 %inc, ptr %inc.spill.addr, align 4; tail call void @print(i32 %inc); ret void; }. Whereas function `f.destroy` will contain the cleanup code for the coroutine:. .. code-block:: llvm. define internal fastcc void @f.destroy(ptr %frame.ptr.destroy) {; entry:; tail call void @free(ptr %frame.ptr.destroy); ret void; }. Avoiding Heap Allocations; -------------------------. A particular coroutine usage pattern, which is illustrated by the `main`; function in the overview section, where a coroutine is created, manipulated and; destroyed by the same calling function, is common for coroutines implementing; RAII idiom and is suitable for allocation elision optimization which avoid; dynamic all",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst:15493,resume,resume,15493,interpreter/llvm-project/llvm/docs/Coroutines.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst,1,['resume'],['resume']
Usability,"types of stack walking that may be used by various; language runtime libraries. We imagine that it would be typical to ; represent a frame with a PC and frame pointer pair, although that is not ; required. %frame getStackCurrentFrame();; Get a frame object for the current function. Note that if the current; function was inlined into its caller, the ""current"" frame will belong to; the ""caller"". bool isFirstFrame(%frame f);; Returns true if the specified frame is the top level (first activated) frame; for this thread. For the main thread, this corresponds to the main() ; function, for a spawned thread, it corresponds to the thread function. %frame getNextFrame(%frame f);; Return the previous frame on the stack. This function is undefined if f; satisfies the predicate isFirstFrame(f). Label *getFrameLabel(%frame f);; If a label was associated with f (as discussed below), this function returns; it. Otherwise, it returns a null pointer. doNonLocalBranch(Label *L);; At this point, it is not clear whether this should be a function or ; intrinsic. It should probably be an intrinsic in LLVM, but we'll deal with; this issue later. Here is a motivating example that illustrates how these facilities could be; used to implement the C++ exception model:. void TestFunction(...) {; A a; B b;; foo(); // Any function call may throw; bar();; C c;. try {; D d;; baz();; } catch (int) {; ...int Stuff...; // execution continues after the try block: the exception is consumed; } catch (double) {; ...double stuff...; throw; // Exception is propogated; }; }. This function would compile to approximately the following code (heavy ; pseudo code follows):. Func:; %a = alloca A; A::A(%a) // These ctors & dtors could throw, but we ignore this ; %b = alloca B // minor detail for this example; B::B(%b). call foo() with fooCleanup // An exception in foo is propogated to fooCleanup; call bar() with barCleanup // An exception in bar is propogated to barCleanup. %c = alloca C; C::C(c); %d = alloca D; D::D",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HistoricalNotes/2001-05-18-ExceptionHandling.txt:2145,clear,clear,2145,interpreter/llvm-project/llvm/docs/HistoricalNotes/2001-05-18-ExceptionHandling.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HistoricalNotes/2001-05-18-ExceptionHandling.txt,1,['clear'],['clear']
Usability,"typo: the programmer; meant init() but wrote innit() instead. template <class T> class Processor {; ...; void init();; ...; };; ...; template <class T> void process() {; Processor<T> processor;; processor.innit(); // <-- should be 'init()'; ...; }. Unfortunately, we can't flag this mistake as soon as we see it: inside; a template, we're not allowed to make assumptions about ""dependent; types"" like Processor<T>. Suppose that later on in; this file the programmer adds an explicit specialization; of Processor, like so:. template <> class Processor<char*> {; void innit();; };. Now the program will work — as long as the programmer only ever; instantiates process() with T = char*! This is why; it's hard, and sometimes impossible, to diagnose mistakes in a; template definition before it's instantiated. The standard says that a template with no valid instantiations is; ill-formed. Clang tries to do as much checking as possible at; definition-time instead of instantiation-time: not only does this; produce clearer diagnostics, but it also substantially improves; compile times when using pre-compiled headers. The downside to this; philosophy is that Clang sometimes fails to process files because they; contain broken templates that are no longer used. The solution is; simple: since the code is unused, just remove it. Default initialization of const variable of a class type requires user-defined default constructor. If a class or struct has no user-defined default; constructor, C++ doesn't allow you to default construct a const; instance of it like this ([dcl.init], p9):. class Foo {; public:; // The compiler-supplied default constructor works fine, so we; // don't bother with defining one.; ...; };. void Bar() {; const Foo foo; // Error!; ...; }. To fix this, you can define a default constructor for the class:. class Foo {; public:; Foo() {}; ...; };. void Bar() {; const Foo foo; // Now the compiler is happy.; ...; }. An upcoming change to the C++ standard is expected to weaken",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html:19629,clear,clearer,19629,interpreter/llvm-project/clang/www/compatibility.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html,1,['clear'],['clearer']
Usability,"u need for ARM are: ``libtinfo``, ``zlib1g``,; ``libxml2`` and ``liblzma``. In the Debian repository you'll; find downloads for all architectures. After you download and unpack all ``.deb`` packages, copy all; ``.so`` and ``.a`` to a directory, make the appropriate; symbolic links (if necessary), and add the relevant ``-L``; and ``-I`` paths to ``-DCMAKE_CXX_FLAGS`` above. Running CMake and Building; --------------------------. Finally, if you're using your platform compiler, run:. .. code-block:: bash. $ cmake -G Ninja <source-dir> -DCMAKE_BUILD_TYPE=<type> <options above>. If you're using Clang as the cross-compiler, run:. .. code-block:: bash. $ CC='clang' CXX='clang++' cmake -G Ninja <source-dir> -DCMAKE_BUILD_TYPE=<type> <options above>. If you have ``clang``/``clang++`` on the path, it should just work, and special; Ninja files will be created in the build directory. I strongly suggest; you to run ``cmake`` on a separate build directory, *not* inside the; source tree. To build, simply type:. .. code-block:: bash. $ ninja. It should automatically find out how many cores you have, what are; the rules that needs building and will build the whole thing. You can't run ``ninja check-all`` on this tree because the created; binaries are targeted to ARM, not x86_64. Installing and Using; --------------------. After the LLVM/Clang has built successfully, you should install it; via:. .. code-block:: bash. $ ninja install. which will create a sysroot on the install-dir. You can then tar; that directory into a binary with the full triple name (for easy; identification), like:. .. code-block:: bash. $ ln -sf <install-dir> arm-linux-gnueabihf-clang; $ tar zchf arm-linux-gnueabihf-clang.tar.gz arm-linux-gnueabihf-clang. If you copy that tarball to your target board, you'll be able to use; it for running the test-suite, for example. Follow the guidelines at; https://llvm.org/docs/lnt/quickstart.html, unpack the tarball in the; test directory, and use options:. .. code-block:: ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToCrossCompileLLVM.rst:6733,simpl,simply,6733,interpreter/llvm-project/llvm/docs/HowToCrossCompileLLVM.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToCrossCompileLLVM.rst,1,['simpl'],['simply']
Usability,"u the `C++` compiler behind the scenes and to produce machine; code starting from your macro. One could decide to compile a macro; in order to obtain better performance or to get nearer to the; production environment. ## Plotting Measurements ##. To display measurements in ROOT, including errors, there exists a; powerful class `TGraphErrors` with different types of constructors. In; the example here, we use data from the file `ExampleData.txt` in text; format:. ``` {.cpp}; root [0] TGraphErrors gr(""ExampleData.txt"");; root [1] gr.Draw(""AP"");; ```. You should see the output shown in Figure [2.2](#f22). [f22]: figures/TGraphErrors_Example.png ""f22""; <a name=""f22""></a>. ![Visualisation of data points with errors using the class TGraphErrors. \label{f22}][f22]. Make sure the file `ExampleData.txt` is available in the directory from; which you started ROOT. Inspect this file now with your favourite; editor, or use the command `less ExampleData.txt` to inspect the file,; you will see that the format is very simple and easy to understand.; Lines beginning with `#` are ignored. It is very convenient to add some; comments about the type of data. The data itself consist of lines with; four real numbers each, representing the x- and y- coordinates and their; errors of each data point. The argument of the method `Draw(""AP"")` is important here. Behind the scenes,; it tells the `TGraphPainter` class to show the axes and to plot markers at the; *x* and *y* positions of the specified data points. Note that this simple; example relies on the default settings of ROOT, concerning the size of; the canvas holding the plot, the marker type and the line colours and; thickness used and so on. In a well-written, complete example, all this; would need to be specified explicitly in order to obtain nice and well; readable results. A full chapter on graphs will explain many; more of the features of the class `TGraphErrors` and its relation to; other ROOT classes in much more detail. ## Histogra",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/ROOT_as_calculator.md:9591,simpl,simple,9591,documentation/primer/ROOT_as_calculator.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/ROOT_as_calculator.md,1,['simpl'],['simple']
Usability,"uage features supported by LLVM; worked under MCJIT, and objects to be loaded under the JIT had to be compiled to; target it (precluding the use of precompiled code from other sources under the; JIT). RuntimeDyld also provided very limited visibility into the linking process; itself: Clients could access conservative estimates of section size; (RuntimeDyld bundled stub size and padding estimates into the section size; value) and the final relocated bytes, but could not access RuntimeDyld's; internal object representations. Eliminating these restrictions and limitations was one of the primary motivations; for the development of JITLink. The llvm-jitlink tool; =====================. The ``llvm-jitlink`` tool is a command line wrapper for the JITLink library.; It loads some set of relocatable object files and then links them using; JITLink. Depending on the options used it will then execute them, or validate; the linked memory. The ``llvm-jitlink`` tool was originally designed to aid JITLink development by; providing a simple environment for testing. Basic usage; -----------. By default, ``llvm-jitlink`` will link the set of objects passed on the command; line, then search for a ""main"" function and execute it:. .. code-block:: sh. % cat hello-world.c; #include <stdio.h>. int main(int argc, char *argv[]) {; printf(""hello, world!\n"");; return 0;; }. % clang -c -o hello-world.o hello-world.c; % llvm-jitlink hello-world.o; Hello, World!. Multiple objects may be specified, and arguments may be provided to the JIT'd; main function using the -args option:. .. code-block:: sh. % cat print-args.c; #include <stdio.h>. void print_args(int argc, char *argv[]) {; for (int i = 0; i != argc; ++i); printf(""arg %i is \""%s\""\n"", i, argv[i]);; }. % cat print-args-main.c; void print_args(int argc, char *argv[]);. int main(int argc, char *argv[]) {; print_args(argc, argv);; return 0;; }. % clang -c -o print-args.o print-args.c; % clang -c -o print-args-main.o print-args-main.c; % llvm-jitli",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/JITLink.rst:37323,simpl,simple,37323,interpreter/llvm-project/llvm/docs/JITLink.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/JITLink.rst,1,['simpl'],['simple']
Usability,"uations -- noise. The algorithm is based on smoothed; second differences that are compared to its standard deviations.; Therefore it is necessary to pass a parameter of sigma to the peak; searching function. The algorithm is selective to the peaks with a; given sigma. The form of the basic peak searching function is. ```{.cpp}; Int_t Search1(const float *spectrum,; int size,; double sigma);; ```. This function searches for peaks in the source spectrum. The number of found; peaks and their positions are written into structure pointed by; `one_dim_peak` structure pointer. Function parameters:. - **`source`**: pointer to the vector of the source spectrum; - **`p`**: pointer to the `one_dim_peak` structure pointer; - **`size`**: length of the source spectrum; - **`sigma`**: sigma of searched peaks. The `one_dim_peak` structure has the form of. ```{.cpp}; struct one_dim_peak{; int number_of_peaks;; double position[MAX_NUMBER_OF_PEAKS1];; };; ```. An example of simple one-dimensional spectrum with identified peaks is; given in Figure 3.1. ![Simple one-dimensional spectrum with identified peaks](figures/image058.png). An example of 1-dimensional experimental spectrum with many identified; peaks is given in Figure 3.2. ![1-dimensional experimental spectrum with many identified peaks](figures/image060.png). However, when we have noisy data, the number of peaks can be enormous. One; such an example is given in Figure 3.3. ![With noisy data the number of peaks can be enormous](figures/image062.png). Therefore it can be useful to have a possibility to set a threshold value and to consider only the peaks higher than this threshold (see Figure 3.4, only three peaks were identified, threshold=50). The value in the center of the peak (`value[i]`) minus the average value in two symmetrically positioned channels (channels `i-3*sigma`, `i+3*sigma`) must be greater than threshold.; Otherwise the peak is ignored. ![Iwth threshold=50, only three peaks were identified](figures/image064.png",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/spectrum/Spectrum.md:17647,simpl,simple,17647,documentation/spectrum/Spectrum.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/spectrum/Spectrum.md,1,['simpl'],['simple']
Usability,"uch as; Intel's Sandylake), we do so now. To see which features and CPUs that LLVM knows about, we can use; ``llc``. For example, let's look at x86:. ::. $ llvm-as < /dev/null | llc -march=x86 -mattr=help; Available CPUs for this target:. amdfam10 - Select the amdfam10 processor.; athlon - Select the athlon processor.; athlon-4 - Select the athlon-4 processor.; ... Available features for this target:. 16bit-mode - 16-bit mode (i8086).; 32bit-mode - 32-bit mode (80386).; 3dnow - Enable 3DNow! instructions.; 3dnowa - Enable 3DNow! Athlon instructions.; ... For our example, we'll use the generic CPU without any additional feature or; target option. .. code-block:: c++. auto CPU = ""generic"";; auto Features = """";. TargetOptions opt;; auto TargetMachine = Target->createTargetMachine(TargetTriple, CPU, Features, opt, Reloc::PIC_);. Configuring the Module; ======================. We're now ready to configure our module, to specify the target and; data layout. This isn't strictly necessary, but the `frontend; performance guide <../../Frontend/PerformanceTips.html>`_ recommends; this. Optimizations benefit from knowing about the target and data; layout. .. code-block:: c++. TheModule->setDataLayout(TargetMachine->createDataLayout());; TheModule->setTargetTriple(TargetTriple);. Emit Object Code; ================. We're ready to emit object code! Let's define where we want to write; our file to:. .. code-block:: c++. auto Filename = ""output.o"";; std::error_code EC;; raw_fd_ostream dest(Filename, EC, sys::fs::OF_None);. if (EC) {; errs() << ""Could not open file: "" << EC.message();; return 1;; }. Finally, we define a pass that emits object code, then we run that; pass:. .. code-block:: c++. legacy::PassManager pass;; auto FileType = CodeGenFileType::ObjectFile;. if (TargetMachine->addPassesToEmitFile(pass, dest, nullptr, FileType)) {; errs() << ""TargetMachine can't emit a file of this type"";; return 1;; }. pass.run(*TheModule);; dest.flush();. Putting It All Together; ============",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl08.rst:3584,guid,guide,3584,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl08.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl08.rst,1,['guid'],['guide']
Usability,"uction; ----------------------------------------. This pass performs a strength reduction on array references inside loops that; have as one or more of their components the loop induction variable. This is; accomplished by creating a new value to hold the initial value of the array; access for the first iteration, and then creating a new GEP instruction in the; loop to increment the value by the appropriate amount. .. _passes-loop-rotate:. ``loop-rotate``: Rotate Loops; -----------------------------. A simple loop rotation transformation. A summary of it can be found in; :ref:`Loop Terminology for Rotated Loops <loop-terminology-loop-rotate>`. .. _passes-loop-simplify:. ``loop-simplify``: Canonicalize natural loops; ---------------------------------------------. This pass performs several transformations to transform natural loops into a; simpler form, which makes subsequent analyses and transformations simpler and; more effective. A summary of it can be found in; :ref:`Loop Terminology, Loop Simplify Form <loop-terminology-loop-simplify>`. Loop pre-header insertion guarantees that there is a single, non-critical entry; edge from outside of the loop to the loop header. This simplifies a number of; analyses and transformations, such as :ref:`LICM <passes-licm>`. Loop exit-block insertion guarantees that all exit blocks from the loop (blocks; which are outside of the loop that have predecessors inside of the loop) only; have predecessors from inside of the loop (and are thus dominated by the loop; header). This simplifies transformations such as store-sinking that are built; into LICM. This pass also guarantees that loops will have exactly one backedge. Note that the :ref:`simplifycfg <passes-simplifycfg>` pass will clean up blocks; which are split out but end up being unnecessary, so usage of this pass should; not pessimize generated code. This pass obviously modifies the CFG, but updates loop information and; dominator information. ``loop-unroll``: Unroll loops; ----",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Passes.rst:26966,simpl,simplify,26966,interpreter/llvm-project/llvm/docs/Passes.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Passes.rst,1,['simpl'],['simplify']
Usability,"ude <stdio.h>; #include <sanitizer/coverage_interface.h>. // This callback is inserted by the compiler as a module constructor; // into every DSO. 'start' and 'stop' correspond to the; // beginning and end of the section with the guards for the entire; // binary (executable or DSO). The callback will be called at least; // once per DSO and may be called multiple times with the same parameters.; extern ""C"" void __sanitizer_cov_trace_pc_guard_init(uint32_t *start,; uint32_t *stop) {; static uint64_t N; // Counter for the guards.; if (start == stop || *start) return; // Initialize only once.; printf(""INIT: %p %p\n"", start, stop);; for (uint32_t *x = start; x < stop; x++); *x = ++N; // Guards should start from 1.; }. // This callback is inserted by the compiler on every edge in the; // control flow (some optimizations apply).; // Typically, the compiler will emit the code like this:; // if(*guard); // __sanitizer_cov_trace_pc_guard(guard);; // But for large functions it will emit a simple call:; // __sanitizer_cov_trace_pc_guard(guard);; extern ""C"" void __sanitizer_cov_trace_pc_guard(uint32_t *guard) {; if (!*guard) return; // Duplicate the guard check.; // If you set *guard to 0 this code will not be called again for this edge.; // Now you can get the PC and do whatever you want:; // store it somewhere or symbolize it and print right away.; // The values of `*guard` are as you set them in; // __sanitizer_cov_trace_pc_guard_init and so you can make them consecutive; // and use them to dereference an array or a bit vector.; void *PC = __builtin_return_address(0);; char PcDescr[1024];; // This function is a part of the sanitizer run-time.; // To use it, link with AddressSanitizer or other sanitizer.; __sanitizer_symbolize_pc(PC, ""%p %F %L"", PcDescr, sizeof(PcDescr));; printf(""guard: %p %x PC %s\n"", guard, *guard, PcDescr);; }. .. code-block:: c++. // trace-pc-guard-example.cc; void foo() { }; int main(int argc, char **argv) {; if (argc > 1) foo();; }. .. code-block:: cons",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SanitizerCoverage.rst:2431,simpl,simple,2431,interpreter/llvm-project/clang/docs/SanitizerCoverage.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SanitizerCoverage.rst,1,['simpl'],['simple']
Usability,"ude talks, organizers should end talks early if the; violations include harassment or violent threats. There may be talks where; other types of code of conduct violations occur and organizers should do ; their best to determine if a talk should be ended early or not. . When undertaking an immediate response, document the action and notify the; committee within 24 hours. . Response Procedure; ==================. The following is a summary of the steps the committee takes when responding to; a reported incident. . 1. Determine if there is a need for an :ref:`immediate response<Immediate; Response Checklist>`. 2. :ref:`Acknowledge the report<Receiving a report>` within 24 hours. 3. :ref:`Discuss the incident report<Incident Response Assessment>`, gather; more information, and determine a :ref:`resolution<Resolutions>`. 4. During this process, the :ref:`reporter will be informed of the; resolution<Following Up With the Reportee>` and feedback is requested. This; feedback may or may not be used to re-evaluate the resolution. 5. Inform the reportee of the resolution. The reportee is provided options to; :ref:`appeal<Appeal Process>`. . 6. The :ref:`resolution<Resolutions>` is implemented. 7. All reports, data, notes, and resolutions are logged in a private location; (e.g., Google Drive or other database). The committee will never make public statements about a resolution and will; only publish :ref:`transparency reports<Transparency Reports>`. If a public; statement is necessary and requested by the committee, it will be given by the; LLVM Foundation Board of Directors. Report Acknowledgement; ======================. When a report is received, the committee will reply to the reporter to confirm; receipt within 24 hours of the incident being reported. . This acknowledgement will contain:. * Acknowledgement of the incident report; * Next steps of the committee for responding to the incident; * Reminder of confidentiality policy regarding the report and parties involved. All ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ResponseGuide.rst:3666,feedback,feedback,3666,interpreter/llvm-project/llvm/docs/ResponseGuide.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ResponseGuide.rst,1,['feedback'],['feedback']
Usability,"uding the input ll/bc file), they are; given via the following flag:; `--test_args=<test_arguments>`; If unspecified, the test is run as given. It’s worth noting that the input file; would be passed as a parameter to the test, similar how `-compile-custom`; currently operates. ### Implementation; The tool would behave similar to CReduce’s functionality in that it would have a; list of passes that try to minimize the given test-case. We should be able to; modularize the tool’s behavior, as well as making it easier to maintain and; expand. The first version of this redesign would try to:. * Discard functions, instructions and metadata that don’t influence the; interesting-ness test; * Remove unused parameters from functions; * Eliminate unvisited conditional paths; * Rename variables to more regular ones (such as “a”, “b”, “c”, etc.). Once these passes are implemented, more meaningful reductions (such as type; reduction) would be added to the tool, to even further reduce IR. ## Background on historical bugpoint issues. ### Root Cause Analysis; Presently, bugpoint takes a long time to find the source problem in a given IR; file, mainly due to the fact that it tries to debug the input by running; various strategies to classify the bug, which in turn run multiple optimizer; and compilation passes over the input, taking up a lot of time. Furthermore,; when the IR crashes, it tries to reduce it by performing some sub-optimal; passes (e.g. a lot of unreachable blocks), and sometimes even fails to minimize; at all. ### ""Quirky"" Interface; Bugpoint’s current interface overwhelms and confuses the user, the help screen; alone ends up confusing rather providing guidance. And, not only are there; numerous features and options, but some of them also work in unexpected ways; and most of the time the user ends up using a custom script. Pruning and; simplifying the interface will be worth considering in order to make the tool; more useful in the general case and easier to maintain.; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/BugpointRedesign.md:3674,guid,guidance,3674,interpreter/llvm-project/llvm/docs/BugpointRedesign.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/BugpointRedesign.md,2,"['guid', 'simpl']","['guidance', 'simplifying']"
Usability,"ue of the; pointer is set equal to. ``` {.cpp}; new Quad(1.,2.,-3.);; ```. `new`, despite its looks, is an operator and creates an object or; variable of the type that comes next, `Quad` in this case, on the; heap. Just as with stack objects it has to be initialized by calling; its constructor. The syntax requires that the argument list follows the; type. This one statement has brought two items into existence, one on; the heap and one on the stack. The heap object will live until the; delete operator is applied to it. There is no FORTRAN parallel to a heap object; variables either come; or go as control passes in and out of a function or subroutine, or,; like a COMMON block variables, live for the lifetime of the program.; However, most people in HEP who use FORTRAN will have experience of a; memory manager and the act of creating a bank is a good equivalent of; a heap object. For those who know systems like ZEBRA, it will come as; a relief to learn that objects do not move, C++ does not garbage; collect, so there is never a danger that a pointer to an object; becomes invalid for that reason. However, having created an object,; it is the user's responsibility to ensure that it is deleted when no; longer needed, or to pass that responsibility onto to some other; object. Failing to do that will result in a memory leak, one of the; most common and most hard-to-find C++ bugs. To send a message to an object via a pointer to it, you need to use; the ""`->`"" operator e.g.:. ``` {.cpp}; root[] my_objptr->Solve();; ```. Although we chose to call our pointer `my_objptr`, to emphasize that; it is a pointer, heap objects are so common in an object-oriented; program that pointer names rarely reflect the fact - you have to be; careful that you know if you are dealing with an object or its; pointer! Fortunately, the compiler won't tolerate an attempt to do; something like:. ``` {.cpp}; root[] my_objptr.Solve();; ```. As we have seen, heap objects; have to be accessed via pointers,",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/ALittleC++.md:10560,learn,learn,10560,documentation/users-guide/ALittleC++.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/ALittleC++.md,1,['learn'],['learn']
Usability,"ue.html>`_ and `User Class; <https://llvm.org/doxygen/classllvm_1_1User.html>`_, respectively, for more; information. .. _schanges_deletingGV:. Deleting GlobalVariables; ^^^^^^^^^^^^^^^^^^^^^^^^. Deleting a global variable from a module is just as easy as deleting an; Instruction. First, you must have a pointer to the global variable that you; wish to delete. You use this pointer to erase it from its parent, the module.; For example:. .. code-block:: c++. GlobalVariable *GV = .. ;. GV->eraseFromParent();. .. _threading:. Threads and LLVM; ================. This section describes the interaction of the LLVM APIs with multithreading,; both on the part of client applications, and in the JIT, in the hosted; application. Note that LLVM's support for multithreading is still relatively young. Up; through version 2.5, the execution of threaded hosted applications was; supported, but not threaded client access to the APIs. While this use case is; now supported, clients *must* adhere to the guidelines specified below to ensure; proper operation in multithreaded mode. Note that, on Unix-like platforms, LLVM requires the presence of GCC's atomic; intrinsics in order to support threaded operation. If you need a; multithreading-capable LLVM on a platform without a suitably modern system; compiler, consider compiling LLVM and LLVM-GCC in single-threaded mode, and; using the resultant compiler to build a copy of LLVM with multithreading; support. .. _shutdown:. Ending Execution with ``llvm_shutdown()``; -----------------------------------------. When you are done using the LLVM APIs, you should call ``llvm_shutdown()`` to; deallocate memory used for internal structures. .. _managedstatic:. Lazy Initialization with ``ManagedStatic``; ------------------------------------------. ``ManagedStatic`` is a utility class in LLVM used to implement static; initialization of static resources, such as the global type tables. In a; single-threaded environment, it implements a simple lazy initial",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:121320,guid,guidelines,121320,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,1,['guid'],['guidelines']
Usability,"uffer into a string very easily with as_string():; print(""struct.char_buffer.as_string(): "", char_buffer.as_string()); ```; The output of this script with ROOT 6.32:; ```; struct.char_buffer : <cppyy.LowLevelView object at 0x74c7a2682fb0>; struct.char_buffer.as_string(): foo; ```. ### Deprecate the attribute pythonization of `TDirectory` in favor of item-getting syntax. The new recommended way to get objects from a `TFile` or any `TDirectory` in general is now via `__getitem__`:. ```python; tree = my_file[""my_tree""] # instead of my_file.my_tree; ```. This is more consistent with other Python collections (like dictionaries), makes sure that member functions can't be confused with branch names, and easily allows you to use string variables as keys. With the new dictionary-like syntax, you can also get objects with names that don't qualify as a Python variable. Here is a short demo:; ```python; import ROOT. with ROOT.TFile.Open(""my_file.root"", ""RECREATE"") as my_file:. # Populate the TFile with simple objects.; my_file.WriteObject(ROOT.std.string(""hello world""), ""my_string""); my_file.WriteObject(ROOT.vector[""int""]([1, 2, 3]), ""my vector""). print(my_file[""my_string""]) # new syntax; print(my_file.my_string) # old deprecated syntax. # With the dictionary syntax, you can also use names that don't qualify as; # a Python variable:; print(my_file[""my vector""]); # print(my_file.my vector) # the old syntax would not work here!; ```. The old pythonization with the `__getattr__` syntax still works, but emits a deprecation warning and will be removed from ROOT 6.34. ### Removal of Python 2 support. ROOT does no longer support Python 2. The minimum Python version necessary to use ROOT in a Python application is 3.8.; As a consequence, any reference to Python 2 in ROOT code was removed and certain configuration options are no longer; usable, e.g. * `root-config --python2-version`; * cmake -Dpyroot-python2. The cmake build system now looks for the standard `Python3` package and previo",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v632/index.md:21840,simpl,simple,21840,README/ReleaseNotes/v632/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v632/index.md,1,['simpl'],['simple']
Usability,"ughter. Of course, the gas has some container also, but let; us keeps it like that for the sake of simplicity. Since we did not; supply the third argument, the wire will be positioned with an identity; transformation inside the chamber. #### Overlapping Volumes. Positioning volumes that does not overlap their neighbors nor extrude; their container is sometimes quite strong constraint. Having a limited; set of geometric shapes might force sometimes overlaps. Since; overlapping is contradictory to containment, a point belonging to an; overlapping region will naturally belong to all overlapping partners.; The answer provided by the modeller to ""Where am I?"" is no longer; deterministic if there is no priority assigned. There are two ways out provided by the modeller in such cases and we; will illustrate them by examples. - Suppose we have 2 crossing tubes that we have to describe. Such a; structure cannot be decomposed in a containment schema. This is a; typical example of simple structure that can be handled by using; composite shapes. What we have to do is to define as shapes the; inner and outer parts of the tubes (tubes having; `Rmin=0`,` Rmax=`inner/outer radius), then to make a composite:; - `C = (Tub1out+Tub2out)-(Tub1in+Tub2in)`; - On the other hand, if we have an EM calorimeter having a honeycomb; structure, Boolean combinations do not help anymore. Here the; problem is that we usually have a very large number of cells that; are naturally belonging to the same container. This result in a very; flat and slow structure for that particular container, which we; would very much want to avoid by introducing additional levels in; depth. We can describe the basic cell as a hexahedron that we can; represent by using a polygon primitive shape. Instead of putting one; by one all cells in the same container, we can define rows of such; elements, fitting in box-shaped containers. Then we can put; row-beside-row inside the container, making life much easier for its; navigatio",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:75804,simpl,simple,75804,documentation/users-guide/Geometry.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md,1,['simpl'],['simple']
Usability,"uilds coroutine frame and outlines resume and destroy parts; into separate functions. CoroElide; ---------; The pass CoroElide examines if the inlined coroutine is eligible for heap; allocation elision optimization. If so, it replaces; `coro.begin` intrinsic with an address of a coroutine frame placed on its caller; and replaces `coro.alloc` and `coro.free` intrinsics with `false` and `null`; respectively to remove the deallocation code.; This pass also replaces `coro.resume` and `coro.destroy` intrinsics with direct; calls to resume and destroy functions for a particular coroutine where possible. CoroCleanup; -----------; This pass runs late to lower all coroutine related intrinsics not replaced by; earlier passes. Attributes; ==========. coro_only_destroy_when_complete; -------------------------------. When the coroutine are marked with coro_only_destroy_when_complete, it indicates; the coroutine must reach the final suspend point when it get destroyed. This attribute only works for switched-resume coroutines now. Metadata; ========. '``coro.outside.frame``' Metadata; ---------------------------------. ``coro.outside.frame`` metadata may be attached to an alloca instruction to; to signify that it shouldn't be promoted to the coroutine frame, useful for; filtering allocas out by the frontend when emitting internal control mechanisms.; Additionally, this metadata is only used as a flag, so the associated; node must be empty. .. code-block:: text. %__coro_gro = alloca %struct.GroType, align 1, !coro.outside.frame !0. ...; !0 = !{}. Areas Requiring Attention; =========================; #. When coro.suspend returns -1, the coroutine is suspended, and it's possible; that the coroutine has already been destroyed (hence the frame has been freed).; We cannot access anything on the frame on the suspend path.; However there is nothing that prevents the compiler from moving instructions; along that path (e.g. LICM), which can lead to use-after-free. At the moment; we disabled",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst:57646,resume,resume,57646,interpreter/llvm-project/llvm/docs/Coroutines.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst,1,['resume'],['resume']
Usability,"uired by EVE).; Switched the icon and checkbox position in TGListTreeItem.; Added custom user control flags, with their getters and setters and three new signal methods (required by EVE). All these were implemented for better control of the TGListTree behavior.; ; fUserControlled is a flag to take over the control; fEventHandled is a flag to tell TGListTree that the current event has been processed by user.; ; MouseOver(TGListTreeItem *entry); MouseOver(TGListTreeItem *entry, UInt_t mask); Clicked(TGListTreeItem *entry, Int_t btn, UInt_t mask, Int_t x, Int_t y). The new DrawOutline() method draws a colored outline around a list tree item following the mouse position.; Implemented correct keyboard navigation.; Improvements for list trees containing a large number of items (i.e. one million). TGTab. Added a new signal method Removed(Int_t id) to notify when a tab was removed. TGListBox. Fixed flickering problem on Windows. TGDockableFrame. Introduced the fFixedSize option, to let user choose if the undocked frame may; be resized or not. Keep the (fixed) original docked frame size when undocked; (i.e. for menus and toolbars). TGShutter. Two helper methods added:; ; SetSelectedItem(const char *name) - switch to the shutter section 'name'.; EnableItem(const char *name, Bool_t on) - enable/disable the shutter section 'name' according to the value of the second parameter 'on'.; . TGFileDialog; The File Open/Close dialogs show the list of all available (mounted) drives on Windows. Modal Dialogs; On Windows, any modal dialog now stays on top of its parent (true modal mode). Context Menus; The context menu of ROOT classes can be created with hierarchical sub-menus, which are more convenient and offer better organization. This makes possible to access more class methods from the context menu (without having the menu becoming larger than the screen). The next is an example of the hierarchihal submenu structure shown below. void SetLevelOne(EPaletteType palette = pal3); // *MENU=",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/doc/v520/index.html:1856,undo,undocked,1856,gui/doc/v520/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/doc/v520/index.html,1,['undo'],['undocked']
Usability,"ular, this means that the code used for read rules (\#pragma read); can no longer access private member unless they have been mentioned as a; target of the rule.; - rootcling no longer considers a friend declaration to be a; declaration for the friended function. In particular this means that; rootcling may now issue:. ``` {.cpp}; Error: in this version of ROOT, the option '!' used in a linkdef file; implies the actual existence of customized operators.; The following declaration is now required:; TBuffer &operator<<(TBuffer &,const THit *);; ```. if the operator `<<` declaration is missing. To steer the parsing done during the execution of rootcling, a new; macro: *\_\_ROOTCLING\_\_* is now defined during the parsing. The macros; *\_\_CINT\_\_* and *\_\_MAKECINT\_\_* are defined only when looking for; `#pragma` statement. The genreflex executable is still available, it preserves the same command; line options as in version 5 and provides new ones. Old selection XML files; are transparently usable by the new implementation. On the other hand some; of the new functionalities can be hardly backported to version 5. See; genreflex help for all the details about commandline switches and selection; files. It is important to note that it is not anymore a python script; interfaced to GCCXML but rather a wrapper around rootcling. In order to specify the classes selection, three methods are available:. 1) Selection XML file. This file can be read by both genreflex and rootcling.; 2) LinkDef file. This file can be read by rootcling.; 3) Selection namespace (also called *dictselection*). Available both for; rootcling and genreflex. See the documentation of the; `ROOT::Meta::Selection` namespace for all the details. *Warning*. It is important to note that during the parsing of the header files,; rootcint no longer defines *\_\_CINT\_\_* and genreflex no longer defines; *\_\_GCCXML\_\_*. This means in particular that data members that were; made transient by hiding them from rootc",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/doc/v600/index.md:7526,usab,usable,7526,core/doc/v600/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/doc/v600/index.md,1,['usab'],['usable']
Usability,"uld be able to express facts like ""when this region escapes, that metadata; symbol attached to it should also escape"". This sounds like an ultimate freedom,; with maximum stress on the checkers - still not too much stress when we have; smart data maps. I'm personally liking the approach (2) - it should be possible to avoid; performance overhead, and clarity seems nice. **Gabor:**. At this point, I am a bit wondering about two questions. * When should something belong to a checker and when should something belong to the engine?; Sometimes we model library aspects in the engine and model language constructs in checkers. * What is the checker programming model that we are aiming for? Maximum freedom or more easy checker development?. I think if we aim for maximum freedom, we do not need to worry about the; potential stress on checkers, and we can introduce abstractions to mitigate that; later on.; If we want to simplify the API, then maybe it makes more sense to move language; construct modeling to the engine when the checker API is not sufficient instead; of complicating the API. Right now I have no preference or objections between the alternatives but there; are some random thoughts:. * Maybe it would be great to have a guideline how to evolve the analyzer and; follow it, so it can help us to decide in similar situations. * I do care about performance in this case. The reason is that we have a; limited performance budget. And I think we should not expect most of the checker; writers to add modeling of language constructs. So, in my opinion, it is ok to; have less nice/more verbose API for language modeling if we can have better; performance this way, since it only needs to be done once, and is done by the; framework developers. **Artem:** These are some great questions, i guess it'd be better to discuss; them more openly. As a quick dump of my current mood:. * To me it seems obvious that we need to aim for a checker API that is both; simple and powerful. This can pro",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/InitializerLists.rst:5182,simpl,simplify,5182,interpreter/llvm-project/clang/docs/analyzer/developer-docs/InitializerLists.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/InitializerLists.rst,1,['simpl'],['simplify']
Usability,"uld be the same as the one passed to; ``--sysroot`` in the ""build-c-flags"". The ""test-c-flags"" need to include the target, architecture, gcc-toolchain,; sysroot and arm/thumb state. The additional cmake defines such as; ``CMAKE_C_COMPILER_EXTERNAL_TOOLCHAIN`` do not apply when building the tests. If; you have put all of these in ""build-c-flags"" then these can be repeated. If you; wish to use lld to link the tests then add ``""-fuse-ld=lld``. Once cmake has completed the tests can be built and run using; ``ninja check-builtins``. Troubleshooting; ===============. The cmake try compile stage fails; ---------------------------------; At an early stage cmake will attempt to compile and link a simple C program to; test if the toolchain is working. This stage can often fail at link time if the ``--sysroot=`` and; ``--gcc-toolchain=`` options are not passed to the compiler. Check the; ``CMAKE_C_FLAGS`` and ``CMAKE_C_COMPILER_TARGET`` flags. It can be useful to build a simple example outside of cmake with your toolchain; to make sure it is working. For example: ``clang --target=arm-linux-gnueabi -march=armv7a --gcc-toolchain=/path/to/gcc-toolchain --sysroot=/path/to/gcc-toolchain/arm-linux-gnueabihf/libc helloworld.c``. Clang uses the host header files; --------------------------------; On debian based systems it is possible to install multiarch support for; arm-linux-gnueabi and arm-linux-gnueabihf. In many cases clang can successfully; use this multiarch support when ``--gcc-toolchain=`` and ``--sysroot=`` are not supplied.; Unfortunately clang adds ``/usr/local/include`` before; ``/usr/include/arm-linux-gnueabihf`` leading to errors when compiling the hosts; header files. The multiarch support is not sufficient to build the builtins you will need to; use a separate arm-linux-gnueabihf toolchain. No target passed to clang; -------------------------; If clang is not given a target it will typically use the host target, this will; not understand the Arm assembly language file",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToCrossCompileBuiltinsOnArm.rst:6177,simpl,simple,6177,interpreter/llvm-project/llvm/docs/HowToCrossCompileBuiltinsOnArm.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToCrossCompileBuiltinsOnArm.rst,1,['simpl'],['simple']
Usability,"ults. `std::map`; ----------. C++'s ``map`` is an associative container similar to Python's ``dict``,; albeit one that has stronger type constraints.; A ``map`` can be instantiated from a ``dict`` (and types can be inferred) or; from a collection of ``pair`` mappings. .. code-block:: python. >>> from cppyy.gbl.std import map; >>> m = map[str, int](*(""one"", 1), (""two"", 2))) # type explicit, from pairs; >>> print(m); { ""one"" => 1, ""two"" => 2 }; >>> m = map({1: ""one"", 2: ""two""}) # type implicit, from dict; >>> type(m); <class cppyy.gbl.std.map<int,std::string> at 0x12d068d60>; >>> print(m); { 1 => ""one"", 2 => ""two"" }; >>>. `std::string`; -------------. Python's `str` is a unicode type since Python3, whereas ``std::string`` is; single-byte char-based.; Having the two correctly interact therefore deserves it's own; :doc:`chapter <strings>`. `std::tuple`; ------------. C++ ``tuple`` is supported but it should be noted that its use, and in; particular instantiating (heavily overloaded) ``get<>`` functions for member; access is inefficient.; They are really only meant for use when you have to pass a ``tuple`` to C++; code; and if returned from a C++ function, it is easier to simply unpack them.; In all other cases, prefer Python's builtin ``tuple``.; Example usage:. .. code-block:: python. >>> from cppyy.gbl.std import make_tuple, get; >>> t = make_tuple(1, '2', 5.); >>> print(t); <cppyy.gbl.std.tuple<int,std::string,double> object at 0x12033ee70>; >>> len(t); 3; >>> get[0](t) # access with templated std::get<>; 1; >>> get[1](t); b'2'; >>> get[2](t); 5.0; >>> a, b, c = t # unpack through iteration; >>> print(a, b, c); 1 2 5.0; >>>. .. rubric:: Footnotes. .. [#f1] The meaning of ""temporary"" differs between Python and C++: in a statement such as ``func(std.vector[int]((1, 2, 3)))``, there is no temporary as far as Python is concerned, even as there clearly is in the case of a similar statement in C++. Thus that call will succeed even if ``func`` takes a non-const reference.; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/stl.rst:8710,simpl,simply,8710,bindings/pyroot/cppyy/cppyy/doc/source/stl.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/stl.rst,2,"['clear', 'simpl']","['clearly', 'simply']"
Usability,"ume families are; used is when we want that a volume positioned inside a container to; match one ore more container limits. Suppose we want to position the; same box inside 2 different volumes and we want the Z size to match the; one of each container:. ``` {.cpp}; TGeoVolume *container1 = gGeoManager->MakeBox(""C1"",imed,10,10,30);; TGeoVolume *container2 = gGeoManager->MakeBox(""C2"",imed,10,10,20);; TGeoVolume *pvol = gGeoManager->MakeBox(""PVOL"",jmed,3,3,-1);; container1->AddNode(pvol,1);; container2->AddNode(pvol,1);; ```. Note that the third parameter of `PVOL` is negative, which does not make; sense as half-length on Z. This is interpreted as: when positioned,; create a box replacing all invalid parameters with the corresponding; dimensions of the container. This is also internally handled by the; **`TGeoVolumeMulti`** class, which does not need to be instantiated by; users. #### Dividing Volumes. Volumes can be divided according a pattern. The simplest division can be; done along one axis that can be: `X,Y,Z,Phi,Rxy or Rxyz`. Let's take a; simple case: we would like to divide a box in N equal slices along X; coordinate, representing a new volume family. Supposing we already have; created the initial box, this can be done like:. ``` {.cpp}; TGeoVolume *slicex = box->Divide(""SLICEX"",1,N);; ```. Here `SLICEX` is the name of the new family representing all slices and; 1 is the slicing axis. The meaning of the axis index is the following:; for all volumes having shapes like `box`, `trd1`, `trd2`, `trap`,; `gtra `or` para - `1, 2, 3 mean X, Y, Z; for `tube`, `tubs`, `cone`,; `cons - `1 means `Rxy`, 2 means `phi` and 3 means Z; for `pcon` and; `pgon` - 2 means `phi` and 3 means Z; for spheres 1 means `R `and 2; means `phi.`. In fact, the division operation has the same effect as positioning; volumes in a given order inside the divided container - the advantage; being that the navigation in such a structure is much faster. When a; volume is divided, a volume family corre",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:83858,simpl,simplest,83858,documentation/users-guide/Geometry.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md,1,['simpl'],['simplest']
Usability,"ume:; %inc = add nsw i32 %n.addr, 1; %sub = xor i32 %n.addr, -1; call void @print(i32 %sub); %3 = call i8 @llvm.coro.suspend(token none, i1 false); switch i8 %3, label %suspend [i8 0, label %loop; i8 1, label %cleanup]. In this case, the coroutine frame would include a suspend index that will; indicate at which suspend point the coroutine needs to resume. .. code-block:: llvm. %f.frame = type { ptr, ptr, i32, i32 }. The resume function will use an index to jump to an appropriate basic block and will look; as follows:. .. code-block:: llvm. define internal fastcc void @f.Resume(ptr %FramePtr) {; entry.Resume:; %index.addr = getelementptr inbounds %f.Frame, ptr %FramePtr, i64 0, i32 2; %index = load i8, ptr %index.addr, align 1; %switch = icmp eq i8 %index, 0; %n.addr = getelementptr inbounds %f.Frame, ptr %FramePtr, i64 0, i32 3; %n = load i32, ptr %n.addr, align 4. br i1 %switch, label %loop.resume, label %loop. loop.resume:; %sub = sub nsw i32 0, %n; call void @print(i32 %sub); br label %suspend; loop:; %inc = add nsw i32 %n, 1; store i32 %inc, ptr %n.addr, align 4; tail call void @print(i32 %inc); br label %suspend. suspend:; %storemerge = phi i8 [ 0, %loop ], [ 1, %loop.resume ]; store i8 %storemerge, ptr %index.addr, align 1; ret void; }. If different cleanup code needs to get executed for different suspend points,; a similar switch will be in the `f.destroy` function. .. note ::. Using suspend index in a coroutine state and having a switch in `f.resume` and; `f.destroy` is one of the possible implementation strategies. We explored; another option where a distinct `f.resume1`, `f.resume2`, etc. are created for; every suspend point, and instead of storing an index, the resume and destroy; function pointers are updated at every suspend. Early testing showed that the; current approach is easier on the optimizer than the latter so it is a; lowering strategy implemented at the moment. Distinct Save and Suspend; -------------------------. In the previous example, sett",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst:19503,resume,resume,19503,interpreter/llvm-project/llvm/docs/Coroutines.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst,1,['resume'],['resume']
Usability,"un through the implementation of a simple language, showing; how fun and easy it can be. This tutorial will get you up and running; fast and show a concrete example of something that uses LLVM to generate; code. This tutorial introduces the simple ""Kaleidoscope"" language, building it; iteratively over the course of several chapters, showing how it is built; over time. This lets us cover a range of language design and LLVM-specific; ideas, showing and explaining the code for it all along the way,; and reduces the overwhelming amount of details up front. We strongly; encourage that you *work with this code* - make a copy and hack it up and; experiment. **Warning**: In order to focus on teaching compiler techniques and LLVM; specifically,; this tutorial does *not* show best practices in software engineering; principles. For example, the code uses global variables; pervasively, doesn't use; `visitors <http://en.wikipedia.org/wiki/Visitor_pattern>`_, etc... but; instead keeps things simple and focuses on the topics at hand. This tutorial is structured into chapters covering individual topics,; allowing you to skip ahead as you wish:. - `Chapter #1: Kaleidoscope language and Lexer <LangImpl01.html>`_ -; This shows where we are; going and the basic functionality that we want to build. A lexer; is also the first part of building a parser for a language, and we; use a simple C++ lexer which is easy to understand.; - `Chapter #2: Implementing a Parser and AST <LangImpl02.html>`_ -; With the lexer in place, we can talk about parsing techniques and; basic AST construction. This tutorial describes recursive descent; parsing and operator precedence parsing.; - `Chapter #3: Code generation to LLVM IR <LangImpl03.html>`_ - with; the AST ready, we show how easy it is to generate LLVM IR, and show; a simple way to incorporate LLVM into your project.; - `Chapter #4: Adding JIT and Optimizer Support <LangImpl04.html>`_ -; One great thing about LLVM is its support for JIT compilation, s",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/index.rst:1457,simpl,simple,1457,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/index.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/index.rst,1,['simpl'],['simple']
Usability,"un-mangled name, we just re-produce this mangling ourselves using our; ``Mangle`` member function object. This brings us to the end of Chapter 1 of Building a JIT. You now have a basic; but fully functioning JIT stack that you can use to take LLVM IR and make it; executable within the context of your JIT process. In the next chapter we'll; look at how to extend this JIT to produce better quality code, and in the; process take a deeper look at the ORC layer concept. `Next: Extending the KaleidoscopeJIT <BuildingAJIT2.html>`_. Full Code Listing; =================. Here is the complete code listing for our running example. To build this; example, use:. .. code-block:: bash. # Compile; clang++ -g toy.cpp `llvm-config --cxxflags --ldflags --system-libs --libs core orcjit native` -O3 -o toy; # Run; ./toy. Here is the code:. .. literalinclude:: ../../examples/Kaleidoscope/BuildingAJIT/Chapter1/KaleidoscopeJIT.h; :language: c++. .. [1] Actually we use a cut-down version of KaleidoscopeJIT that makes a; simplifying assumption: symbols cannot be re-defined. This will make it; impossible to re-define symbols in the REPL, but will make our symbol; lookup logic simpler. Re-introducing support for symbol redefinition is; left as an exercise for the reader. (The KaleidoscopeJIT.h used in the; original tutorials will be a helpful reference). .. [2] +-----------------------------+-----------------------------------------------+; | File | Reason for inclusion |; +=============================+===============================================+; | CompileUtils.h | Provides the SimpleCompiler class. |; +-----------------------------+-----------------------------------------------+; | Core.h | Core utilities such as ExecutionSession and |; | | JITDylib. |; +-----------------------------+-----------------------------------------------+; | ExecutionUtils.h | Provides the DynamicLibrarySearchGenerator |; | | class. |; +-----------------------------+--------------------------------------------",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/BuildingAJIT1.rst:13333,simpl,simplifying,13333,interpreter/llvm-project/llvm/docs/tutorial/BuildingAJIT1.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/BuildingAJIT1.rst,1,['simpl'],['simplifying']
Usability,"unction that maps a ``MatchResult`` to a set; of edits, or fails. This signature supports a very general form of computation; over match results. Transformer provides a number of functions for working with; ``EditGenerator``\ s, most notably; `flatten <https://github.com/llvm/llvm-project/blob/1fabe6e51917bcd7a1242294069c682fe6dffa45/clang/include/clang/Tooling/Transformer/RewriteRule.h#L165-L167>`_; ``EditGenerator``\ s, like list flattening. For the full list, see the header file; `clang/Tooling/Transformer/RewriteRule.h <https://github.com/llvm/llvm-project/blob/main/clang/include/clang/Tooling/Transformer/RewriteRule.h>`_. Rules; ^^^^^. We can also compose multiple *rules*, rather than just edits within a rule,; using ``applyFirst``: it composes a list of rules as an ordered choice, where; Transformer applies the first rule whose pattern matches, ignoring others in the; list that follow. If the matchers are independent then order doesn't matter. In; that case, ``applyFirst`` is simply joining the set of rules into one. The benefit of ``applyFirst`` is that, for some problems, it allows the user to; more concisely formulate later rules in the list, since their patterns need not; explicitly exclude the earlier patterns of the list. For example, consider a set; of rules that rewrite compound statements, where one rule handles the case of an; empty compound statement and the other handles non-empty compound statements.; With ``applyFirst``, these rules can be expressed compactly as:. .. code-block:: c++. applyFirst({; makeRule(compoundStmt(statementCountIs(0)).bind(""empty""), ...),; makeRule(compoundStmt().bind(""non-empty""),...); }). The second rule does not need to explicitly specify that the compound statement; is non-empty -- it follows from the rules position in ``applyFirst``. For more; complicated examples, this can lead to substantially more readable code. Sometimes, a modification to the code might require the inclusion of a; particular header file. To this en",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangTransformerTutorial.rst:15000,simpl,simply,15000,interpreter/llvm-project/clang/docs/ClangTransformerTutorial.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangTransformerTutorial.rst,1,['simpl'],['simply']
Usability,"unction writes to a readonly pointer argument, the behavior is; undefined. ``writeonly``; This attribute indicates that the function may write to, but does not read; through this pointer argument (even though it may read from the memory that; the pointer points to). If a function reads from a writeonly pointer argument, the behavior is; undefined. ``writable``; This attribute is only meaningful in conjunction with ``dereferenceable(N)``; or another attribute that implies the first ``N`` bytes of the pointer; argument are dereferenceable. In that case, the attribute indicates that the first ``N`` bytes will be; (non-atomically) loaded and stored back on entry to the function. This implies that it's possible to introduce spurious stores on entry to; the function without introducing traps or data races. This does not; necessarily hold throughout the whole function, as the pointer may escape; to a different thread during the execution of the function. See also the; :ref:`atomic optimization guide <Optimization outside atomic>`. The ""other attributes"" that imply dereferenceability are; ``dereferenceable_or_null`` (if the pointer is non-null) and the; ``sret``, ``byval``, ``byref``, ``inalloca``, ``preallocated`` family of; attributes. Note that not all of these combinations are useful, e.g.; ``byval`` arguments are known to be writable even without this attribute. The ``writable`` attribute cannot be combined with ``readnone``,; ``readonly`` or a ``memory`` attribute that does not contain; ``argmem: write``. ``dead_on_unwind``; At a high level, this attribute indicates that the pointer argument is dead; if the call unwinds, in the sense that the caller will not depend on the; contents of the memory. Stores that would only be visible on the unwind; path can be elided. More precisely, the behavior is as-if any memory written through the; pointer during the execution of the function is overwritten with a poison; value on unwind. This includes memory written by the implicit ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:70516,guid,guide,70516,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['guid'],['guide']
Usability,"unction);. return TheFunction;; }. Once the insertion point has been set up and the NamedValues map populated,; we call the ``codegen()`` method for the root expression of the function. If no; error happens, this emits code to compute the expression into the entry block; and returns the value that was computed. Assuming no error, we then create an; LLVM `ret instruction <../../LangRef.html#ret-instruction>`_, which completes the function.; Once the function is built, we call ``verifyFunction``, which is; provided by LLVM. This function does a variety of consistency checks on; the generated code, to determine if our compiler is doing everything; right. Using this is important: it can catch a lot of bugs. Once the; function is finished and validated, we return it. .. code-block:: c++. // Error reading body, remove function.; TheFunction->eraseFromParent();; return nullptr;; }. The only piece left here is handling of the error case. For simplicity,; we handle this by merely deleting the function we produced with the; ``eraseFromParent`` method. This allows the user to redefine a function; that they incorrectly typed in before: if we didn't delete it, it would; live in the symbol table, with a body, preventing future redefinition. This code does have a bug, though: If the ``FunctionAST::codegen()`` method; finds an existing IR Function, it does not validate its signature against the; definition's own prototype. This means that an earlier 'extern' declaration will; take precedence over the function definition's signature, which can cause; codegen to fail, for instance if the function arguments are named differently.; There are a number of ways to fix this bug, see what you can come up with! Here; is a testcase:. ::. extern foo(a); # ok, defines foo.; def foo(b) b; # Error: Unknown variable name. (decl using 'a' takes precedence). Driver Changes and Closing Thoughts; ===================================. For now, code generation to LLVM doesn't really get us much, except t",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl03.rst:16550,simpl,simplicity,16550,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl03.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl03.rst,1,['simpl'],['simplicity']
Usability,"unctions()->FindObject(""palette"");; Int_t ci = palette->GetBinColor(20,15);; ; Then it is possible to retrieve the RGB components in the following way:; ; TColor *c = gROOT->GetColor(ci);; float x,y,z;; c->GetRGB(x,y,z);; . TFormula. Fixed a bug in TFormula::GetExprFormula. Now the correct formula is returned for expressions based on CINT type functions. TF1. Fixed a bug in the calculation of the integral of multi-dimensional interpreted functions. The method TF1::operator() (const double *x, const double *p) calls now TF1::InitArgs in the case of CINT functions.; Fixed a bug in using the TF1::GetMinimum(), TF1::GetMaximum(), TF1::GetMinimumX, TF1::GetMaximumX, TF1::GetX with default arguments. ; Fixed a bug when copying functions obtained from member functions of interpreted classes; . THStack. In THStack::Paint() replace; fHistogram->Paint(""axissame""); by; gPad->RedrawAxis(); in order to fix the bug described here:; https://savannah.cern.ch/bugs/?41423 .; The simple following macro was enough to show the problem:. {; TH1D h(""h"", ""h"", 10., 0., 1.); h.Fill(.5);; THStack s(""s"", ""s""); s.Add(&h);; TCanvas canvas(""canvas"");; frame = canvas.DrawFrame(-1., 0., 2., 2.);; frame.SetLabelSize(0.05, ""XY"");; frame.Draw(); s.Draw(""same"");; }. Make the data member fHistogram persistent in order to save the; axis attributes which may have been changed during a root session (like,; for instance, the axis titles).; When a THStack is drawn with the option ""pads"", the number of lines is; now optimized to make sure there is no empty line. . TUnfold. Introduces this new class for solving inverse problems:. data histograms with Gaussian errors are decomposed into; several template distributions (""generator level"" bins). The result are new normalisation constants for the template; distributions (the unfolded ""generator level"" distribution). The solution can be tuned by properly adjusting the; regularisation parameter tau. A standard method, the L-curve scan is; implemented to help finding ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/doc/v522/index.html:6778,simpl,simple,6778,hist/doc/v522/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/doc/v522/index.html,1,['simpl'],['simple']
Usability,"unds in the same scope; Not resolved. 2702; open; Constant destruction of reference members; Not resolved. 2703; review; Three-way comparison requiring strong ordering for floating-point types, take 2; Not resolved. 2704; open; Clarify meaning of ""bind directly""; Not resolved. 2705; open; Accessing ambiguous subobjects; Not resolved. 2706; open; Repeated structured binding declarations; Not resolved. 2707; tentatively ready; Deduction guides cannot have a trailing requires-clause; Unknown. 2708; DRWP; Parenthesized initialization of arrays; Unknown. 2709; NAD; Parenthesized initialization of reference-to-aggregate; Unknown. 2710; DRWP; Loops in constant expressions; Unknown. 2711; DRWP; Source for copy-initializing the exception object; Unknown. 2712; DRWP; Simplify restrictions on built-in assignment operator candidates; Unknown. 2713; DRWP; Initialization of reference-to-aggregate from designated initializer list; Unknown. 2714; open; Implicit deduction guides omit properties from the parameter-declaration-clause of a constructor; Not resolved. 2715; DRWP; ""calling function"" for parameter initialization may not exist; Unknown. 2716; DRWP; Rule about self-or-base conversion is normatively redundant; Unknown. 2717; DRWP; Pack expansion for alignment-specifier; Unknown. 2718; DRWP; Type completeness for derived-to-base conversions; Unknown. 2719; DRWP; Creating objects in misaligned storage; Unknown. 2720; DRWP; Template validity rules for templated entities and alias templates; Unknown. 2721; DRWP; When exactly is storage reused?; Unknown. 2722; DRWP; Temporary materialization conversion for noexcept operator; Unknown. 2723; DRWP; Range of representable values for floating-point types; Unknown. 2724; DRWP; Clarify rounding for arithmetic right shift; Unknown. 2725; DR; Overload resolution for non-call of class member access; Unknown. 2726; review; Alternative tokens appearing as attribute-tokens; Not resolved. 2727; open; Importing header units synthesized from sour",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:187548,guid,guides,187548,interpreter/llvm-project/clang/www/cxx_dr_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html,1,['guid'],['guides']
Usability,"unger_struct`` type, for; either the ``f1`` or ``f2`` field. So, in LLVM assembly the ``munge`` function; looks like:. .. code-block:: llvm. define void @munge(ptr %P) {; entry:; %tmp = getelementptr %struct.munger_struct, ptr %P, i32 1, i32 0; %tmp1 = load i32, ptr %tmp; %tmp2 = getelementptr %struct.munger_struct, ptr %P, i32 2, i32 1; %tmp3 = load i32, ptr %tmp2; %tmp4 = add i32 %tmp3, %tmp1; %tmp5 = getelementptr %struct.munger_struct, ptr %P, i32 0, i32 0; store i32 %tmp4, ptr %tmp5; ret void; }. In each case the second operand is the pointer through which the GEP instruction; starts. The same is true whether the second operand is an argument, allocated; memory, or a global variable. To make this clear, let's consider a more obtuse example:. .. code-block:: text. @MyVar = external global i32; ...; %idx1 = getelementptr i32, ptr @MyVar, i64 0; %idx2 = getelementptr i32, ptr @MyVar, i64 1; %idx3 = getelementptr i32, ptr @MyVar, i64 2. These GEP instructions are simply making address computations from the base; address of ``MyVar``. They compute, as follows (using C syntax):. .. code-block:: c++. idx1 = (char*) &MyVar + 0; idx2 = (char*) &MyVar + 4; idx3 = (char*) &MyVar + 8. Since the type ``i32`` is known to be four bytes long, the indices 0, 1 and 2; translate into memory offsets of 0, 4, and 8, respectively. No memory is; accessed to make these computations because the address of ``@MyVar`` is passed; directly to the GEP instructions. The obtuse part of this example is in the cases of ``%idx2`` and ``%idx3``. They; result in the computation of addresses that point to memory past the end of the; ``@MyVar`` global, which is only one ``i32`` long, not three ``i32``\s long.; While this is legal in LLVM, it is inadvisable because any load or store with; the pointer that results from these GEP instructions would trigger undefined; behavior (UB). Why is the extra 0 index required?; ----------------------------------. Quick answer: there are no superfluous indices. Thi",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GetElementPtr.rst:3974,simpl,simply,3974,interpreter/llvm-project/llvm/docs/GetElementPtr.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GetElementPtr.rst,1,['simpl'],['simply']
Usability,"unsafe, or (2) are; thread-safe, but too complicated for the analysis to understand. Reasons for; (2) will be described in the :ref:`limitations`, below. .. code-block:: c++. class Counter {; Mutex mu;; int a GUARDED_BY(mu);. void unsafeIncrement() NO_THREAD_SAFETY_ANALYSIS { a++; }; };. Unlike the other attributes, NO_THREAD_SAFETY_ANALYSIS is not part of the; interface of a function, and should thus be placed on the function definition; (in the ``.cc`` or ``.cpp`` file) rather than on the function declaration; (in the header). RETURN_CAPABILITY(c); --------------------. *Previously*: ``LOCK_RETURNED``. ``RETURN_CAPABILITY`` is an attribute on functions or methods, which declares; that the function returns a reference to the given capability. It is used to; annotate getter methods that return mutexes. .. code-block:: c++. class MyClass {; private:; Mutex mu;; int a GUARDED_BY(mu);. public:; Mutex* getMu() RETURN_CAPABILITY(mu) { return &mu; }. // analysis knows that getMu() == mu; void clear() REQUIRES(getMu()) { a = 0; }; };. ACQUIRED_BEFORE(...), ACQUIRED_AFTER(...); -----------------------------------------. ``ACQUIRED_BEFORE`` and ``ACQUIRED_AFTER`` are attributes on member; declarations, specifically declarations of mutexes or other capabilities.; These declarations enforce a particular order in which the mutexes must be; acquired, in order to prevent deadlock. .. code-block:: c++. Mutex m1;; Mutex m2 ACQUIRED_AFTER(m1);. // Alternative declaration; // Mutex m2;; // Mutex m1 ACQUIRED_BEFORE(m2);. void foo() {; m2.Lock();; m1.Lock(); // Warning! m2 must be acquired after m1.; m1.Unlock();; m2.Unlock();; }. CAPABILITY(<string>); --------------------. *Previously*: ``LOCKABLE``. ``CAPABILITY`` is an attribute on classes, which specifies that objects of the; class can be used as a capability. The string argument specifies the kind of; capability in error messages, e.g. ``""mutex""``. See the ``Container`` example; given above, or the ``Mutex`` class in :ref:`mutexhea",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst:12131,clear,clear,12131,interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst,1,['clear'],['clear']
Usability,"unter_1` and; `class_await_counter_2`) and `std::suspend_always` (; `struct_std__suspend_always_0` and `struct_std__suspend_always_3`). The index; of the current suspension point of the coroutine is emitted as `__coro_index`.; In the above example, the `__coro_index` value of `1` means the coroutine; stopped at the second suspend point (Note that `__coro_index` is zero indexed); which is the first `co_await await_counter{};` in `coro_task`. Note that the; first initial suspend point is the compiler generated; `co_await promise_type::initial_suspend()`. However, when optimizations are enabled, the printed result changes drastically:. .. parsed-literal::. {__resume_fn = 0x401280 <coro_task(int)>, __destroy_fn = 0x401390 <coro_task(int)>, __promise = {count = 1}, __int_32_0 = 43, __coro_index = 1 '\001'}. Unused values are optimized out, as well as the name of the local variable `a`.; The only information remained is the value of a 32 bit integer. In this simple; case, it seems to be pretty clear that `__int_32_0` represents `a`. However, it; is not true. An important note with optimization is that the value of a variable may not; properly express the intended value in the source code. For example:. .. code-block:: c++. static task coro_task(int v) {; int a = v;; co_await await_counter{};; a++; // __int_32_0 is 43 here; std::cout << a << ""\n"";; a++; // __int_32_0 is still 43 here; std::cout << a << ""\n"";; a++; // __int_32_0 is still 43 here!; std::cout << a << ""\n"";; co_await await_counter{};; a++; // __int_32_0 is still 43 here!!; std::cout << a << ""\n"";; a++; // Why is __int_32_0 still 43 here?; std::cout << a << ""\n"";; }. When debugging step-by-step, the value of `__int_32_0` seemingly does not; change, despite being frequently incremented, and instead is always `43`.; While this might be surprising, this is a result of the optimizer recognizing; that it can eliminate most of the load/store operations. The above code gets; optimized to the equivalent of:. .. code-bl",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DebuggingCoroutines.rst:8710,simpl,simple,8710,interpreter/llvm-project/clang/docs/DebuggingCoroutines.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DebuggingCoroutines.rst,2,"['clear', 'simpl']","['clear', 'simple']"
Usability,"untime by the compiler, and they're easy to integrate into your build; environment. Canonical examples of when to use Clang Plugins:. * special lint-style warnings or errors for your project; * creating additional build artifacts from a single compile step. Use Clang Plugins when you...:. * need your tool to rerun if any of the dependencies change; * want your tool to make or break a build; * need full control over the Clang AST. Do not use Clang Plugins when you...:. * want to run tools outside of your build environment; * want full control on how Clang is set up, including mapping of in-memory; virtual files; * need to run over a specific subset of files in your project which is not; necessarily related to any changes which would trigger rebuilds. LibTooling; ----------. :doc:`LibTooling <LibTooling>` is a C++ interface aimed at writing standalone; tools, as well as integrating into services that run clang tools. Canonical; examples of when to use LibTooling:. * a simple syntax checker; * refactoring tools. Use LibTooling when you...:. * want to run tools over a single file, or a specific subset of files,; independently of the build system; * want full control over the Clang AST; * want to share code with Clang Plugins. Do not use LibTooling when you...:. * want to run as part of the build triggered by dependency changes; * want a stable interface so you don't need to change your code when the AST API; changes; * want high level abstractions like cursors and code completion out of the box; * do not want to write your tools in C++. :doc:`Clang tools <ClangTools>` are a collection of specific developer tools; built on top of the LibTooling infrastructure as part of the Clang project.; They are targeted at automating and improving core development activities of; C/C++ developers. Examples of tools we are building or planning as part of the Clang project:. * Syntax checking (:program:`clang-check`); * Automatic fixing of compile errors (:program:`clang-fixit`); * Auto",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Tooling.rst:2298,simpl,simple,2298,interpreter/llvm-project/clang/docs/Tooling.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Tooling.rst,1,['simpl'],['simple']
Usability,"uperclasses were visited while copying their fields into the; record. Each pair consists of a pointer to the ``Record`` instance for a; superclass record and an instance of the ``SMRange`` class. The range; indicates the source file locations of the beginning and end of the class; definition. This example obtains the superclasses of the ``Prototype`` record and then; iterates over the pairs in the returned array. .. code-block:: text. ArrayRef<std::pair<Record *, SMRange>>; Superclasses = Prototype->getSuperClasses();; for (const auto &SuperPair : Superclasses) {; ...; }. The ``Record`` class also provides a function, ``getDirectSuperClasses``, to; append the *direct* superclasses of a record to a given vector of type; ``SmallVectorImpl<Record *>``. Emitting Text to the Output Stream; ==================================. The ``run`` function is passed a ``raw_ostream`` to which it prints the; output file. By convention, this stream is saved in the emitter class member; named ``OS``, although some ``run`` functions are simple and just use the; stream without saving it. The output can be produced by writing values; directly to the output stream, or by using the ``std::format()`` or; ``llvm::formatv()`` functions. .. code-block:: text. OS << ""#ifndef "" << NodeName << ""\n"";. OS << format(""0x%0*x, "", Digits, Value);. Instances of the following classes can be printed using the ``<<`` operator:; ``RecordKeeper``,; ``Record``,; ``RecTy``,; ``RecordVal``, and; ``Init``. The helper function ``emitSourceFileHeader()`` prints the header comment; that should be included at the top of every output file. A call to it is; included in the skeleton backend file ``TableGenBackendSkeleton.cpp``. Printing Error Messages; =======================. TableGen records are often derived from multiple classes and also often; defined through a sequence of multiclasses. Because of this, it can be; difficult for backends to report clear error messages with accurate source; file locations. To make e",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TableGen/BackGuide.rst:22839,simpl,simple,22839,interpreter/llvm-project/llvm/docs/TableGen/BackGuide.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TableGen/BackGuide.rst,1,['simpl'],['simple']
Usability,"ur tension about; inserting such blatant inefficiencies :). After the rest of the optimizers run, we get:. .. code-block:: llvm. define double @fib(double %x) {; entry:; %cmptmp = fcmp ult double %x, 3.000000e+00; %booltmp = uitofp i1 %cmptmp to double; %ifcond = fcmp ueq double %booltmp, 0.000000e+00; br i1 %ifcond, label %else, label %ifcont. else:; %subtmp = fsub double %x, 1.000000e+00; %calltmp = call double @fib(double %subtmp); %subtmp5 = fsub double %x, 2.000000e+00; %calltmp6 = call double @fib(double %subtmp5); %addtmp = fadd double %calltmp, %calltmp6; ret double %addtmp. ifcont:; ret double 1.000000e+00; }. Here we see that the simplifycfg pass decided to clone the return; instruction into the end of the 'else' block. This allowed it to; eliminate some branches and the PHI node. Now that all symbol table references are updated to use stack variables,; we'll add the assignment operator. New Assignment Operator; =======================. With our current framework, adding a new assignment operator is really; simple. We will parse it just like any other binary operator, but handle; it internally (instead of allowing the user to define it). The first; step is to set a precedence:. .. code-block:: c++. int main() {; // Install standard binary operators.; // 1 is lowest precedence.; BinopPrecedence['='] = 2;; BinopPrecedence['<'] = 10;; BinopPrecedence['+'] = 20;; BinopPrecedence['-'] = 20;. Now that the parser knows the precedence of the binary operator, it; takes care of all the parsing and AST generation. We just need to; implement codegen for the assignment operator. This looks like:. .. code-block:: c++. Value *BinaryExprAST::codegen() {; // Special case '=' because we don't want to emit the LHS as an expression.; if (Op == '=') {; // This assume we're building without RTTI because LLVM builds that way by; // default. If you build LLVM with RTTI this can be changed to a; // dynamic_cast for automatic error checking.; VariableExprAST *LHSE = static_cast<Var",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl07.rst:20194,simpl,simple,20194,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl07.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl07.rst,1,['simpl'],['simple']
Usability,"urce file that ``#include``\s the header, creating; maintenance issues. In implementation files (e.g. ``.cpp`` files), the rule is more of a stylistic; rule, but is still important. Basically, using explicit namespace prefixes; makes the code **clearer**, because it is immediately obvious what facilities; are being used and where they are coming from. And **more portable**, because; namespace clashes cannot occur between LLVM code and other namespaces. The; portability rule is important because different standard library implementations; expose different symbols (potentially ones they shouldn't), and future revisions; to the C++ standard will add more symbols to the ``std`` namespace. As such, we; never use ``'using namespace std;'`` in LLVM. The exception to the general rule (i.e. it's not an exception for the ``std``; namespace) is for implementation files. For example, all of the code in the; LLVM project implements code that lives in the 'llvm' namespace. As such, it is; ok, and actually clearer, for the ``.cpp`` files to have a ``'using namespace; llvm;'`` directive at the top, after the ``#include``\s. This reduces; indentation in the body of the file for source editors that indent based on; braces, and keeps the conceptual context cleaner. The general form of this rule; is that any ``.cpp`` file that implements code in any namespace may use that; namespace (and its parents'), but should not use any others. Provide a Virtual Method Anchor for Classes in Headers; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. If a class is defined in a header file and has a vtable (either it has virtual; methods or it derives from classes with virtual methods), it must always have at; least one out-of-line virtual method in the class. Without this, the compiler; will copy the vtable and RTTI into every ``.o`` file that ``#include``\s the; header, bloating ``.o`` file sizes and increasing link times. Don't use default labels in fully covered switches over enumerations; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodingStandards.rst:50094,clear,clearer,50094,interpreter/llvm-project/llvm/docs/CodingStandards.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodingStandards.rst,1,['clear'],['clearer']
Usability,"urce ranges, and the caret.; However, this behavior isn't required. Another implementation of the ``DiagnosticConsumer`` interface is the; ``TextDiagnosticBuffer`` class, which is used when Clang is in ``-verify``; mode. Instead of formatting and printing out the diagnostics, this; implementation just captures and remembers the diagnostics as they fly by.; Then ``-verify`` compares the list of produced diagnostics to the list of; expected ones. If they disagree, it prints out its own output. Full; documentation for the ``-verify`` mode can be found at; :ref:`verifying-diagnostics`. There are many other possible implementations of this interface, and this is; why we prefer diagnostics to pass down rich structured information in; arguments. For example, an HTML output might want declaration names be; linkified to where they come from in the source. Another example is that a GUI; might let you click on typedefs to expand them. This application would want to; pass significantly more information about types through to the GUI than a; simple flat string. The interface allows this to happen. .. _internals-diag-translation:. Adding Translations to Clang; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Not possible yet! Diagnostic strings should be written in UTF-8, the client can; translate to the relevant code page if needed. Each translation completely; replaces the format string for the diagnostic. .. _SourceLocation:; .. _SourceManager:. The ``SourceLocation`` and ``SourceManager`` classes; ----------------------------------------------------. Strangely enough, the ``SourceLocation`` class represents a location within the; source code of the program. Important design points include:. #. ``sizeof(SourceLocation)`` must be extremely small, as these are embedded; into many AST nodes and are passed around often. Currently it is 32 bits.; #. ``SourceLocation`` must be a simple value object that can be efficiently; copied.; #. We should be able to represent a source location for any byte of any",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:22675,simpl,simple,22675,interpreter/llvm-project/clang/docs/InternalsManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst,1,['simpl'],['simple']
Usability,"ure tests are standardized, like ``__has_cpp_attribute`` or; ``__cpp_lambdas``, while others are Clang extensions, like ``__has_builtin``.; The common theme among all the various feature tests is that they are a utility; to tell users that we think a particular feature is complete. However,; completeness is a difficult property to define because features may still have; lingering bugs, may only work on some targets, etc. We use the following; criteria when deciding whether to expose a feature test macro (or particular; result value for the feature test):. * Are there known issues where we reject valid code that should be accepted?; * Are there known issues where we accept invalid code that should be rejected?; * Are there known crashes, failed assertions, or miscompilations?; * Are there known issues on a particular relevant target?. If the answer to any of these is ""yes"", the feature test macro should either; not be defined or there should be very strong rationale for why the issues; should not prevent defining it. Note, it is acceptable to define the feature; test macro on a per-target basis if needed. When in doubt, being conservative is better than being aggressive. If we don't; claim support for the feature but it does useful things, users can still use it; and provide us with useful feedback on what is missing. But if we claim support; for a feature that has significant bugs, we've eliminated most of the utility; of having a feature testing macro at all because users are then forced to test; what compiler version is in use to get a more accurate answer. The status reported by the feature test macro should always be reflected in the; language support page for the corresponding feature (`C++; <https://clang.llvm.org/cxx_status.html>`_, `C; <https://clang.llvm.org/c_status.html>`_) if applicable. This page can give; more nuanced information to the user as well, such as claiming partial support; for a feature and specifying details as to what remains to be done.; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:164088,feedback,feedback,164088,interpreter/llvm-project/clang/docs/InternalsManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst,1,['feedback'],['feedback']
Usability,"urn 1;; else return 0; }; ULong_t Hash() const { return num; }; };; ```. ## The TIter Generic Iterator. As stated above, the **`TIterator`** class is abstract; it is not; possible to create **`TIterator`** objects. However, it should be; possible to write generic code to process all members of a collection so; there is a need for a generic iterator object. A **`TIter`** object acts; as generic iterator. It provides the same `Next()` and `Reset()` methods; as **`TIterator`** although it has no idea how to support them! It works; as follows:. - To create a **`TIter`** object its constructor must be passed an; object that inherits from **`TCollection`**. The **`TIter`**; constructor calls the `MakeIterator()` method of this collection to; get the appropriate iterator object that inherits from; **`TIterator`**. - The `Next()` and `Reset()` methods of **`TIter`** simply call the; `Next()` and `Reset()` methods of the iterator object. Therefore, **`TIter`** simply acts as a wrapper for an object of a; concrete class inheriting from **`TIterator`**. To see this working in practice, consider the **`TObjArray`**; collection. Its associated iterator is **`TObjArrayIter`**. Suppose; `myarray` is a pointer to a **`TObjArray`** that contains `MyClass`; objects, i.e. ``` {.cpp}; TObjArray *myarray;; ```. To create a **`TIter`** object called `myiter`:. ``` {.cpp}; TIter myiter(myarray);; ```. ![](pictures/020001A4.jpg). As shown in the diagram, this results in several methods being called:. - The **`TIter`** constructor is passed a **`TObjArray`**. - **`TIter`** asks embedded **`TCollection`** to make an iterator. - **`TCollection`** asks **`TObjArray`** to make an iterator. - **`TObjArray`** returns a **`TObjArrayIter`**. Now define a pointer for `MyClass` objects and set it to each member of; the **`TObjArray`**:. ``` {.cpp}; MyClass *myobject;; while ((myobject = (MyClass *)myiter.Next())) {; // process myobject; }; ```. The heart of this is the `myiter.Next()` expression whic",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/CollectionClasses.md:11210,simpl,simply,11210,documentation/users-guide/CollectionClasses.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/CollectionClasses.md,1,['simpl'],['simply']
Usability,"urpose of these; groups is to give vendors early notice that potentially disruptive changes; are being considered but have not yet been accepted. Vendors can give early; testing feedback on the changes to alert us to unacceptable breakages. The; current list of vendor groups is:. * `Clang vendors <https://reviews.llvm.org/project/members/113/>`_; * `libc++ vendors <https://reviews.llvm.org/project/members/109/>`_. People interested in joining the vendors group can do so by clicking the; ""Join Project"" link on the vendor's ""Members"" page in Phabricator. * When committing the change to the repository, add appropriate information; about the potentially breaking changes to the ``Potentially Breaking Changes``; section of the project's release notes. The release note should have; information about what the change is, what is potentially disruptive about; it, as well as any code examples, links, and motivation that is appropriate; to share with users. This helps users to learn about potential issues with; upgrading to that release. * After the change has been committed to the repository, the potentially; disruptive changes described in the release notes should be posted to the; `Announcements <https://discourse.llvm.org/c/announce/>`_ channel on; Discourse. The post should be tagged with the ``potentially-breaking`` label; and a label specific to the project (such as ``clang``, ``llvm``, etc). This; is another mechanism by which we can give pre-release notice to users about; potentially disruptive changes. It is a lower-traffic alternative to the; joining ""vendors"" group. To automatically be notified of new announcements; with the ``potentially-breaking`` label, go to your user preferences page in; Discourse, and add the label to one of the watch categories under; ``Notifications->Tags``. .. _code owners:. Code Owners; -----------. The LLVM Project relies on two features of its process to maintain rapid; development in addition to the high quality of its source base: the ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/DeveloperPolicy.rst:6837,learn,learn,6837,interpreter/llvm-project/llvm/docs/DeveloperPolicy.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/DeveloperPolicy.rst,1,['learn'],['learn']
Usability,"use ICM, STCM, or CLM. --. We don't use ADD (LOGICAL) HIGH, SUBTRACT (LOGICAL) HIGH,; or COMPARE (LOGICAL) HIGH yet. --. DAGCombiner doesn't yet fold truncations of extended loads. Functions like:. unsigned long f (unsigned long x, unsigned short *y); {; return (x << 32) | *y;; }. therefore end up as:. sllg %r2, %r2, 32; llgh %r0, 0(%r3); lr %r2, %r0; br %r14. but truncating the load would give:. sllg %r2, %r2, 32; lh %r2, 0(%r3); br %r14. --. Functions like:. define i64 @f1(i64 %a) {; %and = and i64 %a, 1; ret i64 %and; }. ought to be implemented as:. lhi %r0, 1; ngr %r2, %r0; br %r14. but two-address optimizations reverse the order of the AND and force:. lhi %r0, 1; ngr %r0, %r2; lgr %r2, %r0; br %r14. CodeGen/SystemZ/and-04.ll has several examples of this. --. Out-of-range displacements are usually handled by loading the full; address into a register. In many cases it would be better to create; an anchor point instead. E.g. for:. define void @f4a(i128 *%aptr, i64 %base) {; %addr = add i64 %base, 524288; %bptr = inttoptr i64 %addr to i128 *; %a = load volatile i128 *%aptr; %b = load i128 *%bptr; %add = add i128 %a, %b; store i128 %add, i128 *%aptr; ret void; }. (from CodeGen/SystemZ/int-add-08.ll) we load %base+524288 and %base+524296; into separate registers, rather than using %base+524288 as a base for both. --. Dynamic stack allocations round the size to 8 bytes and then allocate; that rounded amount. It would be simpler to subtract the unrounded; size from the copy of the stack pointer and then align the result.; See CodeGen/SystemZ/alloca-01.ll for an example. --. If needed, we can support 16-byte atomics using LPQ, STPQ and CSDG. --. We might want to model all access registers and use them to spill; 32-bit values. --. We might want to use the 'overflow' condition of eg. AR to support; llvm.sadd.with.overflow.i32 and related instructions - the generated code; for signed overflow check is currently quite bad. This would improve; the results of using -ftrapv.; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/README.txt:3297,simpl,simpler,3297,interpreter/llvm-project/llvm/lib/Target/SystemZ/README.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/README.txt,1,['simpl'],['simpler']
Usability,"use button near to the; left/right (top/bottom) edges of the slider. To change both values; simultaneously press the mouse button near to the slider center. To; change pointer value press the mouse on the pointer and drag it to the; desired position. ``` {.cpp}; fSlider = new TGTripleHSlider(parent,100,kDoubleScaleBoth,kSLD_ID,; kHorizontalFrame);; parent->AddFrame(fSlider,new TGLayoutHints(kLHintsExpandX,5,5,5,5));; fSlider->SetConstrained(kTRUE);; fSlider->SetRange(rmin, rmax);; fSlider->SetPosition(pmin, pmax);; fSlider ->SetPointerPosition(pvalue);; ```. ### Progress Bars. A progress bar is a widget that shows that an operation is in progress; and how much time is left. It is a long rectangular bar, initially; empty, that fills with a color as a process is being performed. The; filled-in area indicates the percentage of the process that has been; completed. You should use this widget for waits exceeding `one minute`.; For a very time consuming operation it is better to break the operation; into subtasks and provide a progress bar for each of them. ![](pictures/0200021E.jpg). A progress bar may be oriented horizontally or vertically. The; horizontally oriented progress bar fills with a color from left to; right; the vertically oriented - from bottom to top. A percent complete; message provides an indication of the completed part of the process. It; is a good practice to include some descriptive text of the process to; keep users informed and entertained while they are waiting for process; completion. The picture below shows the progress bars you can create using the; classes **`TGProgressBar`**, **`TGHProgressBar`**, and; **`TGHProgressBar`**. ``` {.cpp}; // vertical frame with three horizontal progressive bars; TGVerticalFrame *vframe = new TGVerticalFrame(fMain, 10, 10);; fHProg1 = new TGHProgressBar(vframe,TGProgressBar::kStandard,300);; fHProg1->ShowPosition();; fHProg1->SetBarColor(""yellow"");; fHProg2 = new TGHProgressBar(vframe,TGProgressBar::kFancy,300);; f",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md:88206,progress bar,progress bar,88206,documentation/users-guide/WritingGUI.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md,1,['progress bar'],['progress bar']
Usability,"using ``fork-exec``, not just ``fork``). The top libFuzzer process will not do any fuzzing itself, but will; spawn up to ``N`` concurrent child processes providing them; small random subsets of the corpus. After a child exits, the top process; merges the corpus generated by the child back to the main corpus. Related flags:. ``-ignore_ooms``; True by default. If an OOM happens during fuzzing in one of the child processes,; the reproducer is saved on disk, and fuzzing continues.; ``-ignore_timeouts``; True by default, same as ``-ignore_ooms``, but for timeouts.; ``-ignore_crashes``; False by default, same as ``-ignore_ooms``, but for all other crashes. The plan is to eventually replace ``-jobs=N`` and ``-workers=N`` with ``-fork=N``. Resuming merge; --------------. Merging large corpora may be time consuming, and it is often desirable to do it; on preemptable VMs, where the process may be killed at any time.; In order to seamlessly resume the merge, use the ``-merge_control_file`` flag; and use ``killall -SIGUSR1 /path/to/fuzzer/binary`` to stop the merge gracefully. Example:. .. code-block:: console. % rm -f SomeLocalPath; % ./my_fuzzer CORPUS1 CORPUS2 -merge=1 -merge_control_file=SomeLocalPath; ...; MERGE-INNER: using the control file 'SomeLocalPath'; ...; # While this is running, do `killall -SIGUSR1 my_fuzzer` in another console; ==9015== INFO: libFuzzer: exiting as requested. # This will leave the file SomeLocalPath with the partial state of the merge.; # Now, you can continue the merge by executing the same command. The merge; # will continue from where it has been interrupted.; % ./my_fuzzer CORPUS1 CORPUS2 -merge=1 -merge_control_file=SomeLocalPath; ...; MERGE-OUTER: non-empty control file provided: 'SomeLocalPath'; MERGE-OUTER: control file ok, 32 files total, first not processed file 20; ... Options; =======. To run the fuzzer, pass zero or more corpus directories as command line; arguments. The fuzzer will read test inputs from each of these corpus; directo",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LibFuzzer.rst:8496,resume,resume,8496,interpreter/llvm-project/llvm/docs/LibFuzzer.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LibFuzzer.rst,1,['resume'],['resume']
Usability,"using a different coordinate; system, or even an object from a different package as long as it implements the required signatures.; One such vector type is CLHEP's `Hep3Vector`:. ~~~{.cpp}; XYZVector v1(1,2,3);; RhoEtaPhiVector r2(v1);; CLHEP::Hep3Vector q(1,2,3);; XYZVector v3(q); ~~~. ### Arithmetic Operations. The following operations are possible between vector classes, even of different; coordinate system types:. ~~~{.cpp}; v1 += v2;; v1 -= v2;; v1 = - v2;; v1 *= a;; v1 /= a;; v2 = a * v1;; v2 = v1 / a;; v2 = v1 * a;; v3 = v1 + v2;; v3 = v1 - v2;; ~~~. Note that the multiplication between two vectors using the `operator *` is not supported; because it is ambiguous. ### Other Methods. The vector classes support methods for:. - computation of the dot product via Dot(),; - computation of the cross product via Cross(),; - construction of a unit vector via Unit(). \anchor GenVectorTransformations; ## Transformations. The transformations are modeled using simple (non-template) classes, using `double` as; the scalar type to avoid too large numerical errors. The transformations are grouped; in Rotations (in 3 dimensions), Lorentz transformations. Each group has several members which may; model physically equivalent transformations but with different internal representations.; Transformation classes can operate on all type of vectors using the `operator()`; or the `operator *` and the transformations can also be combined via the `operator *`.; In more detail the transformations available are:. ### 3D Rotations. * ROOT::Math::Rotation3D, rotation described by a 3x3 matrix of doubles; * ROOT::Math::EulerAngles rotation described by the three Euler angles (phi, theta and psi) following the GoldStein [definition](http://mathworld.wolfram.com/EulerAngles.html).; * ROOT::Math::RotationZYX rotation described by three angles defining a rotation first along the Z axis, then along the rotated Y' axis and then along the rotated X'' axis.; * ROOT::Math::AxisAngle, rotation described",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/genvector/doc/index.md:7471,simpl,simple,7471,math/genvector/doc/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/genvector/doc/index.md,1,['simpl'],['simple']
Usability,"usion with the first index usually arises from thinking about the; GetElementPtr instruction as if it was a C index operator. They aren't the; same. For example, when we write, in ""C"":. .. code-block:: c++. AType *Foo;; ...; X = &Foo->F;. it is natural to think that there is only one index, the selection of the field; ``F``. However, in this example, ``Foo`` is a pointer. That pointer; must be indexed explicitly in LLVM. C, on the other hand, indices through it; transparently. To arrive at the same address location as the C code, you would; provide the GEP instruction with two index operands. The first operand indexes; through the pointer; the second operand indexes the field ``F`` of the; structure, just as if you wrote:. .. code-block:: c++. X = &Foo[0].F;. Sometimes this question gets rephrased as:. .. _GEP index through first pointer:. *Why is it okay to index through the first pointer, but subsequent pointers; won't be dereferenced?*. The answer is simply because memory does not have to be accessed to perform the; computation. The second operand to the GEP instruction must be a value of a; pointer type. The value of the pointer is provided directly to the GEP; instruction as an operand without any need for accessing memory. It must,; therefore be indexed and requires an index operand. Consider this example:. .. code-block:: c++. struct munger_struct {; int f1;; int f2;; };; void munge(struct munger_struct *P) {; P[0].f1 = P[1].f1 + P[2].f2;; }; ...; struct munger_struct Array[3];; ...; munge(Array);. In this ""C"" example, the front end compiler (Clang) will generate three GEP; instructions for the three indices through ""P"" in the assignment statement. The; function argument ``P`` will be the second operand of each of these GEP; instructions. The third operand indexes through that pointer. The fourth; operand will be the field offset into the ``struct munger_struct`` type, for; either the ``f1`` or ``f2`` field. So, in LLVM assembly the ``munge`` function; looks ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GetElementPtr.rst:2075,simpl,simply,2075,interpreter/llvm-project/llvm/docs/GetElementPtr.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GetElementPtr.rst,1,['simpl'],['simply']
Usability,"uspend index in a coroutine state and having a switch in `f.resume` and; `f.destroy` is one of the possible implementation strategies. We explored; another option where a distinct `f.resume1`, `f.resume2`, etc. are created for; every suspend point, and instead of storing an index, the resume and destroy; function pointers are updated at every suspend. Early testing showed that the; current approach is easier on the optimizer than the latter so it is a; lowering strategy implemented at the moment. Distinct Save and Suspend; -------------------------. In the previous example, setting a resume index (or some other state change that; needs to happen to prepare a coroutine for resumption) happens at the same time as; a suspension of a coroutine. However, in certain cases, it is necessary to control; when coroutine is prepared for resumption and when it is suspended. In the following example, a coroutine represents some activity that is driven; by completions of asynchronous operations `async_op1` and `async_op2` which get; a coroutine handle as a parameter and resume the coroutine once async; operation is finished. .. code-block:: text. void g() {; for (;;); if (cond()) {; async_op1(<coroutine-handle>); // will resume once async_op1 completes; <suspend>; do_one();; }; else {; async_op2(<coroutine-handle>); // will resume once async_op2 completes; <suspend>; do_two();; }; }; }. In this case, coroutine should be ready for resumption prior to a call to; `async_op1` and `async_op2`. The `coro.save`_ intrinsic is used to indicate a; point when coroutine should be ready for resumption (namely, when a resume index; should be stored in the coroutine frame, so that it can be resumed at the; correct resume point):. .. code-block:: llvm. if.true:; %save1 = call token @llvm.coro.save(ptr %hdl); call void @async_op1(ptr %hdl); %suspend1 = call i1 @llvm.coro.suspend(token %save1, i1 false); switch i8 %suspend1, label %suspend [i8 0, label %resume1; i8 1, label %cleanup]; if.false:; %s",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst:21059,resume,resume,21059,interpreter/llvm-project/llvm/docs/Coroutines.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst,1,['resume'],['resume']
Usability,"uspended. LLVM currently supports two styles of coroutine lowering. These styles; support substantially different sets of features, have substantially; different ABIs, and expect substantially different patterns of frontend; code generation. However, the styles also have a great deal in common. In all cases, an LLVM coroutine is initially represented as an ordinary LLVM; function that has calls to `coroutine intrinsics`_ defining the structure of; the coroutine. The coroutine function is then, in the most general case,; rewritten by the coroutine lowering passes to become the ""ramp function"",; the initial entrypoint of the coroutine, which executes until a suspend point; is first reached. The remainder of the original coroutine function is split; out into some number of ""resume functions"". Any state which must persist; across suspensions is stored in the coroutine frame. The resume functions; must somehow be able to handle either a ""normal"" resumption, which continues; the normal execution of the coroutine, or an ""abnormal"" resumption, which; must unwind the coroutine without attempting to suspend it. Switched-Resume Lowering; ------------------------. In LLVM's standard switched-resume lowering, signaled by the use of; `llvm.coro.id`, the coroutine frame is stored as part of a ""coroutine; object"" which represents a handle to a particular invocation of the; coroutine. All coroutine objects support a common ABI allowing certain; features to be used without knowing anything about the coroutine's; implementation:. - A coroutine object can be queried to see if it has reached completion; with `llvm.coro.done`. - A coroutine object can be resumed normally if it has not already reached; completion with `llvm.coro.resume`. - A coroutine object can be destroyed, invalidating the coroutine object,; with `llvm.coro.destroy`. This must be done separately even if the; coroutine has reached completion normally. - ""Promise"" storage, which is known to have a certain size and alignme",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst:2309,resume,resume,2309,interpreter/llvm-project/llvm/docs/Coroutines.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst,1,['resume'],['resume']
Usability,"ut function type. V No False − Verbose output (short form of VerbosityLevel below - overrides the latter one). VerbosityLevel No Default Default, Debug, Verbose, Info, Warning, Error, Fatal Verbosity level. VarTransform No None − List of variable transformations performed before training, e.g., D_Background,P_Signal,G,N_AllClasses for: Decorrelation, PCA-transformation, Gaussianisation, Normalisation, each for the given class of events ('AllClasses' denotes all events of all classes, if no class indication is given, 'All' is assumed). H No False − Print method-specific help message. CreateMVAPdfs No False − Create PDFs for classifier outputs (signal and background). IgnoreNegWeightsInTraining No False − Events with negative weights are ignored in the training (but are included for testing and performance evaluation). TrainingMethod No BP BP, GA, BFGS Train with Back-Propagation (BP), BFGS Algorithm (BFGS), or Genetic Algorithm (GA - slower and worse). LearningRate No 0.02 − ANN learning rate parameter. DecayRate No 0.01 − Decay rate for learning parameter. TestRate No 10 − Test for overtraining performed at each #th epochs. EpochMonitoring No False − Provide epoch-wise monitoring plots according to TestRate (caution: causes big ROOT output file!). Sampling No 1 − Only 'Sampling' (randomly selected) events are trained each epoch. SamplingEpoch No 1 − Sampling is used for the first 'SamplingEpoch' epochs, afterwards, all events are taken for training. SamplingImportance No 1 − The sampling weights of events in epochs which successful (worse estimator than before) are multiplied with SamplingImportance, else they are divided. SamplingTraining No True − The training sample is sampled. SamplingTesting No False − The testing sample is sampled. ResetStep No 50 − How often BFGS should reset history. Tau No 3 − LineSearch size step. BPMode No sequential sequential, batch Back-propagation learning mode: sequential or batch. BatchSize No -1 − Batch size: number of events/batch,",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/tmva/UsersGuide/optionRef.html:22420,learn,learning,22420,documentation/tmva/UsersGuide/optionRef.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/tmva/UsersGuide/optionRef.html,1,['learn'],['learning']
Usability,"ut), then the ""``&``""; modifier must be used (e.g. ""``=&r``"") to specify that the output is an; ""early-clobber"" output. Marking an output as ""early-clobber"" ensures that LLVM; will not use the same register for any inputs (other than an input tied to this; output). Input constraints; """""""""""""""""""""""""""""""""". Input constraints do not have a prefix -- just the constraint codes. Each input; constraint will consume one argument from the call instruction. It is not; permitted for the asm to write to any input register or memory location (unless; that input is tied to an output). Note also that multiple inputs may all be; assigned to the same register, if LLVM can determine that they necessarily all; contain the same value. Instead of providing a Constraint Code, input constraints may also ""tie""; themselves to an output constraint, by providing an integer as the constraint; string. Tied inputs still consume an argument from the call instruction, and; take up a position in the asm template numbering as is usual -- they will simply; be constrained to always use the same register as the output they've been tied; to. For example, a constraint string of ""``=r,0``"" says to assign a register for; output, and use that register as an input as well (it being the 0'th; constraint). It is permitted to tie an input to an ""early-clobber"" output. In that case, no; *other* input may share the same register as the input tied to the early-clobber; (even when the other input has the same value). You may only tie an input to an output which has a register constraint, not a; memory constraint. Only a single input may be tied to an output. There is also an ""interesting"" feature which deserves a bit of explanation: if a; register class constraint allocates a register which is too small for the value; type operand provided as input, the input value will be split into multiple; registers, and all of them passed to the inline asm. However, this feature is often not as useful as you might think. Firstly,",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:213556,simpl,simply,213556,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['simpl'],['simply']
Usability,"ut; some strictures on the Python side, requiring careful use of types.; However, an easily fixable error is preferable over an implicitly wrong; result.; Note the type of the init argument in the call resulting in an (attempted); implicit instantiation in the following example:. .. code-block:: python. >>> cppyy.cppdef(""""""; ... template<class T>; ... T sumit_T(const std::vector<T>& data, T init) {; ... return std::accumulate(data.begin(), data.end(), init);; ... }""""""); ...; True; >>> cppyy.gbl.sumit_T(vector['double'](range(7)), 0); Traceback (most recent call last):; File ""<stdin>"", line 1, in <module>; TypeError: Template method resolution failed:; Failed to instantiate ""sumit_T(std::vector<double>&,int)""; Failed to instantiate ""sumit_T(std::vector<double>*,int)""; Failed to instantiate ""sumit_T(std::vector<double>,int)""; >>> cppyy.gbl.sumit_T(vector['double'](range(7)), 0.); 21.0; >>>. To be sure, the code is `too` strict in the simplistic example above, and; with a future version of Cling it should be possible to lift some of these; restrictions without causing incorrect results. `std::map`; ----------. C++'s ``map`` is an associative container similar to Python's ``dict``,; albeit one that has stronger type constraints.; A ``map`` can be instantiated from a ``dict`` (and types can be inferred) or; from a collection of ``pair`` mappings. .. code-block:: python. >>> from cppyy.gbl.std import map; >>> m = map[str, int](*(""one"", 1), (""two"", 2))) # type explicit, from pairs; >>> print(m); { ""one"" => 1, ""two"" => 2 }; >>> m = map({1: ""one"", 2: ""two""}) # type implicit, from dict; >>> type(m); <class cppyy.gbl.std.map<int,std::string> at 0x12d068d60>; >>> print(m); { 1 => ""one"", 2 => ""two"" }; >>>. `std::string`; -------------. Python's `str` is a unicode type since Python3, whereas ``std::string`` is; single-byte char-based.; Having the two correctly interact therefore deserves it's own; :doc:`chapter <strings>`. `std::tuple`; ------------. C++ ``tuple`` is supported but",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/stl.rst:7375,simpl,simplistic,7375,bindings/pyroot/cppyy/cppyy/doc/source/stl.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/stl.rst,1,['simpl'],['simplistic']
Usability,"ution results of an expression are stored in the object 'V' of; type Value. This value is then printed, effectively helping the interpreter; use a value from the compiled code. .. code-block:: console. int Global = 42;; void setGlobal(int val) { Global = val; }; int getGlobal() { return Global; }; Interp.ParseAndExecute(“void setGlobal(int val);”);; Interp.ParseAndExecute(“int getGlobal();”);; Value V;; Interp.ParseAndExecute(“getGlobal()”, &V);; std::cout << V.getAs<int>() << “\n”; // Prints 42. **Note:** Above is an example of interoperability between the compiled code and; the interpreted code. Interoperability between languages (e.g., C++ and Python); works similarly. 2. Dump Captured Execution Results; ==================================. This feature helps create a temporary dump to display the value and type; (pretty print) of the desired data. This is a good way to interact with the; interpreter during interactive programming. How value printing is simplified (Automatic Printf); ---------------------------------------------------. The ``Automatic Printf`` feature makes it easy to display variable values during; program execution. Using the ``printf`` function repeatedly is not required.; This is achieved using an extension in the ``libclangInterpreter`` library. To automatically print the value of an expression, simply write the expression; in the global scope **without a semicolon**. .. graphviz::; :name: automaticprintf; :caption: Automatic PrintF; :alt: Shows how Automatic PrintF can be used; :align: center. digraph ""AutomaticPrintF"" {; size=""6,4"";; rankdir=""LR"";; graph [fontname=""Verdana"", fontsize=""12""];; node [fontname=""Verdana"", fontsize=""12""];; edge [fontname=""Sans"", fontsize=""9""];. manual [label="" Manual PrintF "", shape=""box""];; int1 [label="" int ( &) 42 "", shape=""box""]; auto [label="" Automatic PrintF "", shape=""box""];; int2 [label="" int ( &) 42 "", shape=""box""]. auto -> int2 [label=""int x = 42; \n x""];; manual -> int1 [label=""int x = 42; \n printf(&qu",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangRepl.rst:13941,simpl,simplified,13941,interpreter/llvm-project/clang/docs/ClangRepl.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangRepl.rst,1,['simpl'],['simplified']
Usability,"utputFile. Fix a problem with the determination of the fDir member; affecting mostly PROOF-Lite; Fix a serious issue whose net effect was to delete the; outputfile just after having open it. XrdProofd plugin. Make sure that the limit on the number of old; sessions is applied whenever a new session is started and not only when; the daemon is started.; Fix the behaviour of the xpd.allowedusers directive: if; at least one of these directives is present, users in the password file; are not allowed by default but must be explicitly appear in one; xpd.allowedusers directive  ; Fix a source for memory leak in; XrdProofdProtocol::SendMsg; Optimize the usage of strings in a few places. DataSet manager. Correctly classify as TTree all TTree derived classes; (e.g. TNtuple's); Fix a problem in saving the end-point URL for local; files; Improve realtime notification during 'verify'. TProofDraw. Fix a problem with the axis ranges of the underlying; histogram in PolyMarker3D; Allow to use the default pad instead of forcing; creation of one pad per object; Add wrapper to handle the feedback default canvas. TEventIter. Fix a problem with changing the tree cache size: the; size was reset to the default value after the first file. TDataSetManagerFile. Solve a consistency problem in checking URLs for; duplication when adding them to the relevant TFileInfo; During dataset validation, do not fail on duplications; but notify and add them to the bad file list. TPacketizerAdaptive, TPacketizer. Improve data node / worker matching by always using the; host FQDN. TPacketizerUnit, TEventIter. Make sure that the entry; number passed to TSelector::Process is unique and in increasing order; for non-data driven processing (packetizer TPacketizerUnit). This; allows to give a meaning to this variable, for example to related it to; one dimension of an integration. Fixes in PROOF-Lite:. Make sure that with envs settings via TProof::AddEnvVar; are effective; this enables, for example, the automatic valg",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/doc/v526/index.html:8328,feedback,feedback,8328,proof/doc/v526/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/doc/v526/index.html,1,['feedback'],['feedback']
Usability,"utton near to the slider center. To; change pointer value press the mouse on the pointer and drag it to the; desired position. ``` {.cpp}; fSlider = new TGTripleHSlider(parent,100,kDoubleScaleBoth,kSLD_ID,; kHorizontalFrame);; parent->AddFrame(fSlider,new TGLayoutHints(kLHintsExpandX,5,5,5,5));; fSlider->SetConstrained(kTRUE);; fSlider->SetRange(rmin, rmax);; fSlider->SetPosition(pmin, pmax);; fSlider ->SetPointerPosition(pvalue);; ```. ### Progress Bars. A progress bar is a widget that shows that an operation is in progress; and how much time is left. It is a long rectangular bar, initially; empty, that fills with a color as a process is being performed. The; filled-in area indicates the percentage of the process that has been; completed. You should use this widget for waits exceeding `one minute`.; For a very time consuming operation it is better to break the operation; into subtasks and provide a progress bar for each of them. ![](pictures/0200021E.jpg). A progress bar may be oriented horizontally or vertically. The; horizontally oriented progress bar fills with a color from left to; right; the vertically oriented - from bottom to top. A percent complete; message provides an indication of the completed part of the process. It; is a good practice to include some descriptive text of the process to; keep users informed and entertained while they are waiting for process; completion. The picture below shows the progress bars you can create using the; classes **`TGProgressBar`**, **`TGHProgressBar`**, and; **`TGHProgressBar`**. ``` {.cpp}; // vertical frame with three horizontal progressive bars; TGVerticalFrame *vframe = new TGVerticalFrame(fMain, 10, 10);; fHProg1 = new TGHProgressBar(vframe,TGProgressBar::kStandard,300);; fHProg1->ShowPosition();; fHProg1->SetBarColor(""yellow"");; fHProg2 = new TGHProgressBar(vframe,TGProgressBar::kFancy,300);; fHProg2->SetBarColor(""lightblue"");; fHProg2->ShowPosition(kTRUE,kFALSE,""%.0f events"");; fHProg3 = new TGHProgressBar(vframe,T",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md:88267,progress bar,progress bar,88267,documentation/users-guide/WritingGUI.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md,1,['progress bar'],['progress bar']
Usability,"uture version may integrate Cling-generated IR directly into Numba IR (or; vice versa), e.g. if the C++ code is exposed from (precompiled) headers.; This would allow inlining of C++ code into Numba traces, for further; expected speedups. Why Numba?; ----------. The advertised premise of Numba is that it ""makes Python code fast.""; However, there is a much more compelling reason: Numba allows developers to; stay in their chosen ecosystem, be it Python or C++, in mixed environments,; without paying for their choice in lost performance.; For example, a Python developer using Numba does not need to rewrite a kernel; into C++ just to run performantly in a C++ framework.; Similarly, a C++ developer can use Numba to compile and create function; pointers to Python code for easy, performant, access.; This becomes even more compelling if the deployment target is a GPU, which; would otherwise certainly require a rewrite of the Python code.; Add that Numba, as a JIT-compiler, is fully run-time just like ``cppyy``,; and the use case for integration is clear.; (Numba does not currently provide support for C++.). Usage; -------. ``cppyy`` does not use Numba extension hooks to minimize accidental; dependencies.; Instead, it requires that the extensions are loaded explicitly by any code; that uses it::. import cppyy.numba_ext. After that, Numba is able to trace ``cppyy`` bound code when applying the; usual ``numba.njit`` decorator. Numba type declarations are done lazily, with the ``numba_ext`` module only; initially registering hooks on proxy base classes, to keep overheads in; Numba's type-resolution to a minimum.; On use in a JITed trace, each C++ type or function call is refined to the; actual, concrete types and type-specific overloads, with templates; instantiated as-needed.; Where possible, lowering is kept generic to reduce the number of callbacks; in Numba's compilation chain. Examples; --------. The following, non-exhaustive, set of examples gives an idea of the; current lev",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/numba.rst:2173,clear,clear,2173,bindings/pyroot/cppyy/cppyy/doc/source/numba.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/numba.rst,1,['clear'],['clear']
Usability,"v/null | llc -march=xyz -mattr=help. .. option:: --frame-pointer. Specify effect of frame pointer elimination optimization (all,non-leaf,none). .. option:: --disable-excess-fp-precision. Disable optimizations that may produce excess precision for floating point.; Note that this option can dramatically slow down code on some systems; (e.g. X86). .. option:: --enable-no-infs-fp-math. Enable optimizations that assume no Inf values. .. option:: --enable-no-nans-fp-math. Enable optimizations that assume no NAN values. .. option:: --enable-no-signed-zeros-fp-math. Enable FP math optimizations that assume the sign of 0 is insignificant. .. option:: --enable-no-trapping-fp-math. Enable setting the FP exceptions build attribute not to use exceptions. .. option:: --enable-unsafe-fp-math. Enable optimizations that make unsafe assumptions about IEEE math (e.g. that; addition is associative) or may not work for all input ranges. These; optimizations allow the code generator to make use of some instructions which; would otherwise not be usable (such as ``fsin`` on X86). .. option:: --stats. Print statistics recorded by code-generation passes. .. option:: --time-passes. Record the amount of time needed for each pass and print a report to standard; error. .. option:: --load=<dso_path>. Dynamically load ``dso_path`` (a path to a dynamically shared object) that; implements an LLVM target. This will permit the target name to be used with; the :option:`-march` option so that code can be generated for that target. .. option:: -meabi=[default|gnu|4|5]. Specify which EABI version should conform to. Valid EABI versions are *gnu*,; *4* and *5*. Default value (*default*) depends on the triple. .. option:: -stack-size-section. Emit the .stack_sizes section which contains stack size metadata. The section; contains an array of pairs of function symbol values (pointer size) and stack; sizes (unsigned LEB128). The stack size values only include the space allocated; in the function prologue. Functi",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llc.rst:4083,usab,usable,4083,interpreter/llvm-project/llvm/docs/CommandGuide/llc.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llc.rst,1,['usab'],['usable']
Usability,"valid orderings of dependencies; - since linking resolution is linear, it's possible that some implicit; dependencies can sneak through: A depends on B and C, so valid orderings are; ""C B A"" or ""B C A"", in both cases the explicit dependencies come before their; use. But in the first case, B could still link successfully if it implicitly; depended on C, or the opposite in the second case). .. _minimal list of #includes:. ``#include`` as Little as Possible; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. ``#include`` hurts compile time performance. Don't do it unless you have to,; especially in header files. But wait! Sometimes you need to have the definition of a class to use it, or to; inherit from it. In these cases go ahead and ``#include`` that header file. Be; aware however that there are many cases where you don't need to have the full; definition of a class. If you are using a pointer or reference to a class, you; don't need the header file. If you are simply returning a class instance from a; prototyped function or method, you don't need it. In fact, for most cases, you; simply don't need the definition of a class. And not ``#include``\ing speeds up; compilation. It is easy to try to go too overboard on this recommendation, however. You; **must** include all of the header files that you are using --- you can include; them either directly or indirectly through another header file. To make sure; that you don't accidentally forget to include a header file in your module; header, make sure to include your module header **first** in the implementation; file (as mentioned above). This way there won't be any hidden dependencies that; you'll find out about later. Keep ""Internal"" Headers Private; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Many modules have a complex implementation that causes them to use more than one; implementation (``.cpp``) file. It is often tempting to put the internal; communication interface (helper classes, extra functions, etc) in the public; module header file. Do",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodingStandards.rst:32328,simpl,simply,32328,interpreter/llvm-project/llvm/docs/CodingStandards.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodingStandards.rst,1,['simpl'],['simply']
Usability,"value.; - Due to some planned major improvements to `RVec`, the layout of `RVec` objects will change in a backward-incompatible way between v6.24 and v6.26.; Because of this, we now print a warning if an application is reading or writing a `ROOT::RVec` object from/to a ROOT file. We assume this is an; exceedingly rare case, as the ROOT interface typically used to manipulate `RVec`s is `RDataFrame`, and `RDataFrame` performs an on-the-fly; `RVec <-> std::vector` conversion rather than writing `RVec`s to disk. Note that, currently, `RVecs` written e.g. in a `TTree` cannot be read back; using certain ROOT interfaces (e.g. `TTreeReaderArray`, `RDataFrame` and the experimental `RNTuple`). All these limitations will be lifted in v6.26.; - Portable implementation of the RANLUX++ generator, see [RanluxppEngine](https://root.cern/doc/master/classROOT_1_1Math_1_1RanluxppEngine.html) and [our blog post](https://root.cern/blog/ranluxpp/). ## TMVA. - Introducing TMVA PyTorch Interface, a method to use PyTorch internally with TMVA for deep learning. This can be used as an alternative to PyKeras Interface for complex models providing more flexibility and power. ## RooFit Libraries. - Extension / updates of the doxygen reference guide.; - Allow for removing RooPlot from global directory management, see [RooPlot::AddDirectory](https://root.cern/doc/v624/classRooPlot.html#a47f7ba71dcaca30ad9ee295dee89c9b8); and [RooPlot::SetDirectory](https://root.cern/doc/v624/classRooPlot.html#a5938bc6d5c47d94c2f04fdcc10c1c026); - Hash-assisted finding of elements in RooWorkspace. Large RooWorkspace objects were slow in finding elements.; This was improved using a hash map.; - Stabilise RooStats::HypoTestInverter. It can now tolerate a few failed fits when conducting hypothesis tests.; This is relevant when a few points in a parameter scan don't converge due to numerical or model instabilities.; These points will be skipped, and HypoTestInverter can continue.; - Tweak pull / residual plots. ROOT au",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v624/index.md:13718,learn,learning,13718,README/ReleaseNotes/v624/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v624/index.md,1,['learn'],['learning']
Usability,"vas,; when whole canvas cannot be drawn.; 13. Correct usage of colors map, provided with TCanvas.; 14. Introduce JSROOT.redraw() function which is capable to create or update object drawing.; 15. In main index.htm page browser can be disabled (nobrowser parameter) and; page can be used to display only specified items from the file; 16. Add support of TPolyMarker3D in binary I/O. ### September 2014; 1. First try to handle resize of the browser,; for the moment works only with collapsible layout; 2. Also first try to interactively move separation line between; browser and drawing field.; 3. Small fix of minor ticks drawing on the axis; 4. Introduce display class for MDI drawing. Provide two implementations -; 'collapsible' for old kind and 'tabs' for new kinds.; 5. Adjust size of color palette drawing when labels would take more place as provided.; 6. Add correct filling of statistic for TProfile,; fix small problem with underflow/overflow bins.; 7. Provide way to select display kind ('collapsible', 'tabs') in the simple GUI.; 8. Implement 'grid' display, one could specify any number of division like; 'grid 3x3' or 'grid 4x2'.; 9. MDI display object created at the moment when first draw is performed.; 10. Introduce painter class for TCanvas, support resize and update of canvas drawing; 11. Resize almost works for all layouts and all objects kinds.; 12. Implement JSROOT.GetUrlOption to extract options from document URL.; 13. Provide example fileitem.htm how read and display item from ROOT file.; 14. In default index.htm page one could specify 'file', 'layout',; 'item' and 'items' parameters like:; <http://root.cern.ch/js/3.0/index.htm?file=../files/hsimple.root&layout=grid3x2&item=hpx;1>; 15. Support direct reading of objects from sub-sub-directories.; 16. Introduce demo.htm, which demonstrates online usage of JSROOT.; 17. One could use demo.htm directly with THttpServer providing address like:; <http://localhost:8080/jsrootsys/demo/demo.htm?addr=../../Files/job1.root/",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/changes.md:72579,simpl,simple,72579,js/changes.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/changes.md,1,['simpl'],['simple']
Usability,"vative.; The resulting fit parameters will be identical to those obtained with the non-parallelized gradients minimizer in most cases (see the usage notes linked below for exceptions). In upcoming releases, further developments are planned:. - Benchmark/profile and optimize performance further; - Add a `RooAbsPdf::fitTo` interface around these new classes; - Achieve feature parity with existing `RooNLLVar` functionality, e.g. ranges are not yet supported. For more details, consult the usage notes in the [TestStatistics README.md](https://github.com/root-project/root/tree/master/roofit/roofitcore/src/TestStatistics/README.md).; For benchmarking results on the prototype version of the parallelized gradient calculator, see the corresponding [CHEP19 proceedings paper](https://doi.org/10.1051/epjconf/202024506027). ### New pythonizations. Various new pythonizations are introduced to streamline your RooFit code in Python. For a complete list of all pythonized classes and functions, please see the [RooFit pythonizations page in the reference guide](https://root.cern/doc/v626/group__RoofitPythonizations.html).; All RooFit Python tutorials have been updated to profit from all available pythonizations. Some notable highlights are listed in the following. #### Keyword argument pythonizations. All functions that take RooFit command arguments as parameters now accept equivalent Python keyword arguments, for example simplifying calls to [RooAbsPdf::fitTo()](https://root.cern/doc/v626/classRooAbsPdf.html#a5f79f16f4a26a19c9e66fb5c080f59c5) such as:; ```Python; model.fitTo(data, ROOT.RooFit.Range(""left,right""), ROOT.RooFit.Save()); ```; which becomes:; ```Python; model.fitTo(data, Range=""left,right"", Save=True); ```. #### String to enum pythonizations. Many functions that take an enum as a parameter now accept also a string with the enum label. Take for example this expression:; ```Python; data.plotOn(frame, ROOT.RooFit.DataError(ROOT.RooAbsData.SumW2); ```; Combining the enum pytho",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v626/index.md:19011,guid,guide,19011,README/ReleaseNotes/v626/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v626/index.md,1,['guid'],['guide']
Usability,"ved to the ""bottom"" of the loop, i.e.; the latch. This is something that LoopRotate does by copying the header; of the loop to the latch.; * The compiler in this case can't deduce that the loop will; definitely execute at least once so the above transformation; is not valid. As mentioned above, a guard has to be inserted,; which is something that LoopRotate will do. This is how LoopRotate transforms this loop:. .. code-block:: none. define void @test(i32 %n) {; entry:; %guard_cond = icmp slt i32 0, %n; br i1 %guard_cond, label %loop.preheader, label %exit. loop.preheader:; br label %body. body:; %i2 = phi i32 [ 0, %loop.preheader ], [ %i.next, %latch ]; br label %latch. latch:; %i.next = add nsw i32 %i2, 1; %cond = icmp slt i32 %i.next, %n; br i1 %cond, label %body, label %loop.exit. loop.exit:; br label %exit. exit:; ret void; }. .. image:: ./loop-terminology-guarded-loop.png; :width: 500 px. The result is a little bit more complicated than we may expect; because LoopRotate ensures that the loop is in; :ref:`Loop Simplify Form <loop-terminology-loop-simplify>`; after rotation.; In this case, it inserted the %loop.preheader basic block so; that the loop has a preheader and it introduced the %loop.exit; basic block so that the loop has dedicated exits; (otherwise, %exit would be jumped from both %latch and %entry,; but %entry is not contained in the loop).; Note that a loop has to be in Loop Simplify Form beforehand; too for LoopRotate to be applied successfully. The main advantage of this form is that it allows hoisting; invariant instructions, especially loads, into the preheader.; That could be done in non-rotated loops as well but with; some disadvantages. Let's illustrate them with an example:. .. code-block:: C. for (int i = 0; i < n; ++i) {; auto v = *p;; use(v);; }. We assume that loading from p is invariant and use(v) is some; statement that uses v.; If we wanted to execute the load only once we could move it; ""out"" of the loop body, resulting in this:. .. c",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LoopTerminology.rst:21742,simpl,simplify,21742,interpreter/llvm-project/llvm/docs/LoopTerminology.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LoopTerminology.rst,1,['simpl'],['simplify']
Usability,"vents, magenta bar) or a; session freeze.; Fix problem with packet re-assignment in case of a worker death (some packets were processed twice or more times).; Fix problem with the transmission of non-default file; attributes (e.g. the number of entries) from TChainElement to; TDSetElement during TChain processing in PROOF; Fix problem in the default packetizer with validating the; exact number of needed files when the information about the entries is; already available.; Fix problem with 'xpd.putenv' and 'xpd.putrc' occuring when the variables themselves contain commas.; Avoid resolving the workers FQDN when running in PROOF-Lite,; creating unnecessary delays when running PROOF-Lite within virtual; machines.; Fix problem with the permissions of the user data directory.; Add files to the list of files to process only when finally validated.; Fix; problem with canvases when the feedback canvas and the final canvas are; the same (do not delete the feedback canvas at the end of processing); Make sure that TProof::Load, TProofPlayer::SendSelector and; TSelector::GetSelector treat consistently the extensions of the; implementation files.; Unlock the cache after failure to load a selector; prevents session freezing; Correctly update the number of submergers when workers die; Add missing protection causing a crash in submergers when the output list contained TProofOutputFile objects.; Move the creation and start of the idle timeout from the end; of SetupCommon to the end of CreateServer, so that the timeout is not; active during worker setup.; Make sure that the TProof instance on the client is invalidated after an idle timeout.; Fix an old issue with DeactivateWorker(""*"") (the session is; was terminated because no worker was active; this call coudl not be; used as intermediate step to select a small number of workers).; Consistently check both Proof.Sandbox and ProofLite.Sandbox for sandbox non-default location as done in TProofLite; Fix a problem with the registration of ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/doc/v528/index.html:12218,feedback,feedback,12218,proof/doc/v528/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/doc/v528/index.html,2,['feedback'],['feedback']
Usability,"ver.org/data/file.root"",""new""); root[] TFile *f3 = TFile::Open(""http://root.cern.ch/files/hsimple.root""); root[] f3.ls(); TDavixFile** http://root.cern.ch/files/hsimple.root; TDavixFile* http://root.cern.ch/files/hsimple.root; KEY: TH1F hpx;1 This is the px distribution; KEY: TH2F hpxpy;1 py vs px; KEY: TProfile hprof;1 Profile of pz versus px; KEY: TNtuple ntuple;1 Demo ntuple; root[] hpx.Draw(); ```. ## XML Interface. A new module `xml` as implemented by Sergey Linev (GSI). It is an; optional package that can be used to save a canvas into `file.xml` file; format instead of `file.root`. XML files do not have any advantages; compared to the normal ROOT files, except that the information in these; files can be edited via a normal editor. The main motivation for this; new format is to facilitate the communication with other non ROOT; applications. Currently writing and reading XML files is limited to ROOT; applications. It is our intention to develop a simple reader independent; of the ROOT libraries that could be used as an example for real; applications. The XML format should be used only for small data volumes, typically; histogram files, pictures, geometries, calibrations. The XML file is; built in memory before being dumped to disk. Like for normal ROOT files,; XML files use the same I/O mechanism exploiting the ROOT/Cling; dictionary. Any class having a dictionary can be saved in XML format.; This first implementation does not support subdirectories or trees. The shared library `libRXML.so` may be loaded dynamically via; `gSystem->Load(""libRXML"")`. This library is also automatically loaded by; the plug-in manager as soon a XML file is created. To create an XTM; file, simply specify a filename with an .xml extension when calling; **`TFile`**`::Open`. **`TFile`**`::Open` will recognize that you are trying to; open an XML file and return a **`TXMLFile`** object. When a XML file is; open in write mode, one can use the normal `TObject::Write` to write an; object in th",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md:97532,simpl,simple,97532,documentation/users-guide/InputOutput.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md,1,['simpl'],['simple']
Usability,"ver; binding using `root --notebook --ip=<hostaddr>` arguments; - Now Jupyter Notebooks will use JSROOT provided with ROOT installation. This allows to use notebooks; without internet connection (offline). ## JavaScript ROOT; - Provide monitoring capabilities for TGeoManager object. Now geomtry with some tracks can be displayed and; updated in web browser, using THttpServer monitoring capability like histogram objects. ## Tutorials; - Add the ""Legacy"" category collecting the old tutorials which do not represent any more best practices. ## Class Reference Guide; - Images in tutorials can now be displayed à JavaScript thanks to the (js) option; added next to the directive `\macro_image`; - As the tutorial `palettes.C` is often hit when searching the keyword `palette`; in the reference guide, a direct link from this example to the full list of; predefined palettes given in `TColor` has been added.; - Revisited the TSpectrum2 documentation. All the static images have been replaced; by macros generating images at reference guide build time. These macros have; been added in the tutorial section of the reference guide.; - The Reference Guide can now be accessed directly from the ROOT prompt thanks to; a great extension (implemented by Desislava Kalaydjieva) of the `.help` command.; For example to access the Reference Guide for `TTree` it is enough to type:; ~~~ {.cpp}; root[0] .help TTree; ~~~; To open the reference guide for a function/member:; ~~~ {.cpp}; root[0] .help TTree::Draw; ~~~. ## Build, Configuration and Testing Infrastructure. - Make MLP optional via the `-Dmlp={OFF,ON}` switch for CMake; - Make Spectrum optional via the `-Dspectrum={OFF,ON}` switch for CMake; - ROOT now fails to configure when any package is missing; when `-Dfail-on-missing=ON` is passed to CMake; - The `-Dall=ON` now switches the default value of all optional packages to `ON`; - The options `astiff`, `cling`, `pch`, `thread`, and `explicitlink` have been; removed and are now ignored. They eit",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v620/index.md:7333,guid,guide,7333,README/ReleaseNotes/v620/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v620/index.md,1,['guid'],['guide']
Usability,"verflow problems; N/A. 438; C11; ungetc / ungetwc and file position after discarding push back problems; N/A. 439; C11; Issues with the definition of ""full expression""; Unknown. 440; NAD; Floating-point issues in C11 from PDTS 18661-1 UK review, Issue 1; Unknown. 441; C11; Floating-point issues in C11 from PDTS 18661-1 UK review, Issue 2; N/A. 442; NAD; Floating-point issues in C11 from PDTS 18661-1 UK review, Issue 3; Unknown. 443; NAD; Floating-point issues in C11 from PDTS 18661-1 UK review, Issue 4; Unknown. 444; C11; Issues with alignment in C11, part 1. Partial; Clang rejects use of an alignment specifier in a compound literal expression.; . 445; C11; Issues with alignment in C11, part 2; Unknown. 446; NAD; Use byte instead of character for memcmp, memcpy; N/A. 447; C11; Boolean from complex; Yes. 448; C11; What are the semantics of a # non-directive?; Yes. 449; NAD; What is the value of TSS_DTOR_ITERATIONS for implementations with no maximum?; N/A. 450; C11; tmpnam_s clears s[0] when maxsize > RSIZE_MAX; N/A. 451; NAD; Instability of uninitialized automatic variables; Unknown. 452; C11; Effective Type in Loop Invariant; Unknown. 453; C11; Atomic flag type and operations; N/A. 454; NAD; ATOMIC_VAR_INIT (issues 3 and 4); Yes. 455; NAD; ATOMIC_VAR_INIT issue 5; Yes. 456; Dup; Compile time definition of UINTN_C(value); Duplicate of 209. 457; C11; The ctime_s function in Annex K defined incorrectly; N/A. 458; C11; ATOMIC_XXX_LOCK_FREE macros not constant expressions; N/A. 459; C11; atomic_load missing const qualifier; Yes. 460; C11; aligned_alloc underspecified; N/A. 461; NAD; Problems with references to objects in signal handlers; N/A. 462; C11; Clarifying objects accessed in signal handlers; N/A. 463; NAD; Left-shifting into the sign bit; Yes. 464; C11; Clarifying the Behavior of the #line Directive; Yes. 465; C11; Fixing an inconsistency in atomic_is_lock_free; Unknown. 466; NAD; Scope of a for loop control declaration; Yes. 467; C11; Maximum representable fini",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/c_dr_status.html:24618,clear,clears,24618,interpreter/llvm-project/clang/www/c_dr_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/c_dr_status.html,1,['clear'],['clears']
Usability,"verflow; 	ud2. it would be nice to produce ""into"" someday. //===---------------------------------------------------------------------===//. Test instructions can be eliminated by using EFLAGS values from arithmetic; instructions. This is currently not done for mul, and, or, xor, neg, shl,; sra, srl, shld, shrd, atomic ops, and others. It is also currently not done; for read-modify-write instructions. It is also current not done if the; OF or CF flags are needed. The shift operators have the complication that when the shift count is; zero, EFLAGS is not set, so they can only subsume a test instruction if; the shift count is known to be non-zero. Also, using the EFLAGS value; from a shift is apparently very slow on some x86 implementations. In read-modify-write instructions, the root node in the isel match is; the store, and isel has no way for the use of the EFLAGS result of the; arithmetic to be remapped to the new node. Add and subtract instructions set OF on signed overflow and CF on unsiged; overflow, while test instructions always clear OF and CF. In order to; replace a test with an add or subtract in a situation where OF or CF is; needed, codegen must be able to prove that the operation cannot see; signed or unsigned overflow, respectively. //===---------------------------------------------------------------------===//. memcpy/memmove do not lower to SSE copies when possible. A silly example is:; define <16 x float> @foo(<16 x float> %A) nounwind {; 	%tmp = alloca <16 x float>, align 16; 	%tmp2 = alloca <16 x float>, align 16; 	store <16 x float> %A, <16 x float>* %tmp; 	%s = bitcast <16 x float>* %tmp to i8*; 	%s2 = bitcast <16 x float>* %tmp2 to i8*; 	call void @llvm.memcpy.i64(i8* %s, i8* %s2, i64 64, i32 16); 	%R = load <16 x float>* %tmp2; 	ret <16 x float> %R; }. declare void @llvm.memcpy.i64(i8* nocapture, i8* nocapture, i64, i32) nounwind. which compiles to:. _foo:; 	subl	$140, %esp; 	movaps	%xmm3, 112(%esp); 	movaps	%xmm2, 96(%esp); 	movaps	%xmm1, 80(%e",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/README.txt:31289,clear,clear,31289,interpreter/llvm-project/llvm/lib/Target/X86/README.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/README.txt,1,['clear'],['clear']
Usability,"very simple command, well known by now: fit the; function to the histogram. - Lines *42-46*: Retrieve the output from the fit. Here, we simply; print the fit result and access and print the covariance matrix of; the parameters. - Lines *54-end*: Plot the pseudo-data, the fitted function and the; signal and background components at the best-fit values. [f61]: figures/functions.png ""f61""; <a name=""f61""></a>. ![Fit of pseudo data: a signal shape over a background trend. This plot; is another example of how making a plot ""self-explanatory"" can help you; better displaying your results. \label{f61}][f61]. ## Toy Monte Carlo Experiments ##. Let us look at a simple example of a toy experiment comparing two; methods to fit a function to a histogram, the $\chi^{2}$. method and a method called ""binned log-likelihood fit"", both available in ROOT. As a very simple yet powerful quantity to check the quality of the fit; results, we construct for each pseudo-data set the so-called ""pull"", the; difference of the estimated and the true value of a parameter,; normalised to the estimated error on the parameter,; $\frac{(p_{estim} - p_{true})}{\sigma_{p}}$. If everything is OK, the; distribution of the pull values is a standard normal distribution, i.e.; a Gaussian distribution centred around zero with a standard deviation of one. The macro performs a rather big number of toy experiments, where a; histogram is repeatedly filled with Gaussian distributed numbers,; representing the pseudo-data in this example. Each time, a fit is; performed according to the selected method, and the pull is calculated; and filled into a histogram. Here is the code:. ``` {.cpp .numberLines}; @ROOT_INCLUDE_FILE macros/macro9.C; ```. Your present knowledge of ROOT should be enough to understand all the; technicalities behind the macro. Note that the variable `pull` in line; *61* is different from the definition above: instead of the parameter; error on `mean`, the fitted standard deviation of the distribution",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/functions_and_parameter_estimation.md:4263,simpl,simple,4263,documentation/primer/functions_and_parameter_estimation.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/functions_and_parameter_estimation.md,1,['simpl'],['simple']
Usability,"vided as a note.; ``fn_ret_thunk_extern``; This attribute tells the code generator that returns from functions should; be replaced with jumps to externally-defined architecture-specific symbols.; For X86, this symbol's identifier is ``__x86_return_thunk``.; ``""frame-pointer""``; This attribute tells the code generator whether the function; should keep the frame pointer. The code generator may emit the frame pointer; even if this attribute says the frame pointer can be eliminated.; The allowed string values are:. * ``""none""`` (default) - the frame pointer can be eliminated.; * ``""non-leaf""`` - the frame pointer should be kept if the function calls; other functions.; * ``""all""`` - the frame pointer should be kept.; ``hot``; This attribute indicates that this function is a hot spot of the program; execution. The function will be optimized more aggressively and will be; placed into special subsection of the text section to improving locality. When profile feedback is enabled, this attribute has the precedence over; the profile information. By marking a function ``hot``, users can work; around the cases where the training input does not have good coverage; on all the hot functions.; ``inlinehint``; This attribute indicates that the source code contained a hint that; inlining this function is desirable (such as the ""inline"" keyword in; C/C++). It is just a hint; it imposes no requirements on the; inliner.; ``jumptable``; This attribute indicates that the function should be added to a; jump-instruction table at code-generation time, and that all address-taken; references to this function should be replaced with a reference to the; appropriate jump-instruction-table function pointer. Note that this creates; a new pointer for the original function, which means that code that depends; on function-pointer identity can break. So, any function annotated with; ``jumptable`` must also be ``unnamed_addr``.; ``memory(...)``; This attribute specifies the possible memory effects of the ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:83708,feedback,feedback,83708,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['feedback'],['feedback']
Usability,"vironment or other; installation location.; Adjust other options (esp. ``CMAKE_CXX_STANDARD``) as needed.; For the build command, adjust the ``cmake`` command as appropriate for your; favorite, or platform-specific, build system and/or use ``cmake --build``; instead of ``make`` directly.; See the `cmake documentation`_ for details. Next up is ``cppyy-backend`` (cppyy-backend, subdirectory ""clingwrapper""; omit; the first step if you already cloned the repo for ``cppyy-cling``)::. $ git clone https://github.com/wlav/cppyy-backend.git; $ cd cppyy-backend/clingwrapper; $ python -m pip install . --upgrade --no-use-pep517 --no-deps. Note the use of ``--no-use-pep517``, which prevents ``pip`` from needlessly; going out to pypi.org and creating a local ""clean"" build environment from the; cached or remote wheels.; Instead, by skipping PEP 517, the local installation will be used.; This is imperative if there was a change in public headers or if the version; of ``cppyy-cling`` was locally updated and is thus not available on PyPI. Upgrading ``CPyCppyy`` (if on CPython; it's not needed for PyPy) and ``cppyy``; is very similar::. $ git clone https://github.com/wlav/CPyCppyy.git; $ cd CPyCppyy; $ python -m pip install . --upgrade --no-use-pep517 --no-deps. Just like ``cppyy-cling``, ``CPyCppyy`` has ``cmake`` scripts which are the; recommended way for development, as incremental builds are faster::. $ mkdir build; $ cmake ../CPyCppyy; $ make -j <N>. then simply point the ``PYTHONPATH`` envar to the `build` directory above to; pick up the local `cppyy.so` module. Finally, the top-level package ``cppyy``::. $ git clone https://github.com/wlav/cppyy.git; $ cd cppyy; $ python -m pip install . --upgrade --no-deps. Please see the `pip documentation`_ for more options, such as developer mode. .. _`setuptools`: https://setuptools.readthedocs.io/; .. _`upstream`: https://root.cern.ch/download/; .. _`cmake documentation`: https://cmake.org/; .. _`pip documentation`: https://pip.pypa.io/; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/repositories.rst:6399,simpl,simply,6399,bindings/pyroot/cppyy/cppyy/doc/source/repositories.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/repositories.rst,1,['simpl'],['simply']
Usability,"vm.nvvm.barrier0``'; ^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". .. code-block:: llvm. declare void @llvm.nvvm.barrier0(). Overview:; """""""""""""""""". The '``@llvm.nvvm.barrier0()``' intrinsic emits a PTX ``bar.sync 0``; instruction, equivalent to the ``__syncthreads()`` call in CUDA. Other Intrinsics; ----------------. For the full set of NVPTX intrinsics, please see the; ``include/llvm/IR/IntrinsicsNVVM.td`` file in the LLVM source tree. .. _libdevice:. Linking with Libdevice; ======================. The CUDA Toolkit comes with an LLVM bitcode library called ``libdevice`` that; implements many common mathematical functions. This library can be used as a; high-performance math library for any compilers using the LLVM NVPTX target.; The library can be found under ``nvvm/libdevice/`` in the CUDA Toolkit and; there is a separate version for each compute architecture. For a list of all math functions implemented in libdevice, see; `libdevice Users Guide <http://docs.nvidia.com/cuda/libdevice-users-guide/index.html>`_. To accommodate various math-related compiler flags that can affect code; generation of libdevice code, the library code depends on a special LLVM IR; pass (``NVVMReflect``) to handle conditional compilation within LLVM IR. This; pass looks for calls to the ``@__nvvm_reflect`` function and replaces them; with constants based on the defined reflection parameters. Such conditional; code often follows a pattern:. .. code-block:: c++. float my_function(float a) {; if (__nvvm_reflect(""FASTMATH"")); return my_function_fast(a);; else; return my_function_precise(a);; }. The default value for all unspecified reflection parameters is zero. The ``NVVMReflect`` pass should be executed early in the optimization; pipeline, immediately after the link stage. The ``internalize`` pass is also; recommended to remove unused math functions from the resulting PTX. For an; input IR module ``module.bc``, the following compilation flow is recommended:. 1. Save list of external function",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/NVPTXUsage.rst:8080,guid,guide,8080,interpreter/llvm-project/llvm/docs/NVPTXUsage.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/NVPTXUsage.rst,1,['guid'],['guide']
Usability,"vm.org/doxygen/structclang_1_1format_1_1FormatStyle.html>`_; structure. Configurable Format Style Options; =================================. This section lists the supported style options. Value type is specified for; each option. For enumeration types possible values are specified both as a C++; enumeration member (with a prefix, e.g. ``LS_Auto``), and as a value usable in; the configuration (without a prefix: ``Auto``). .. _BasedOnStyle:. **BasedOnStyle** (``String``) :ref:`¶ <BasedOnStyle>`; The style used for all options not specifically set in the configuration. This option is supported only in the :program:`clang-format` configuration; (both within ``-style='{...}'`` and the ``.clang-format`` file). Possible values:. * ``LLVM``; A style complying with the `LLVM coding standards; <https://llvm.org/docs/CodingStandards.html>`_; * ``Google``; A style complying with `Google's C++ style guide; <https://google.github.io/styleguide/cppguide.html>`_; * ``Chromium``; A style complying with `Chromium's style guide; <https://chromium.googlesource.com/chromium/src/+/refs/heads/main/styleguide/styleguide.md>`_; * ``Mozilla``; A style complying with `Mozilla's style guide; <https://firefox-source-docs.mozilla.org/code-quality/coding-style/index.html>`_; * ``WebKit``; A style complying with `WebKit's style guide; <https://www.webkit.org/coding/coding-style.html>`_; * ``Microsoft``; A style complying with `Microsoft's style guide; <https://docs.microsoft.com/en-us/visualstudio/ide/editorconfig-code-style-settings-reference>`_; * ``GNU``; A style complying with the `GNU coding standards; <https://www.gnu.org/prep/standards/standards.html>`_; * ``InheritParentConfig``; Not a real style, but allows to use the ``.clang-format`` file from the; parent directory (or its parent if there is none). If there is no parent; file found it falls back to the ``fallback`` style, and applies the changes; to that. With this option you can overwrite some parts of your main style for your; subdir",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:5651,guid,guide,5651,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,1,['guid'],['guide']
Usability,"vmtg/2013-04/klimek-slides.pdf>`_. Introduction; ============. Clang's AST is different from ASTs produced by some other compilers in; that it closely resembles both the written C++ code and the C++; standard. For example, parenthesis expressions and compile time; constants are available in an unreduced form in the AST. This makes; Clang's AST a good fit for refactoring tools. Documentation for all Clang AST nodes is available via the generated; `Doxygen <https://clang.llvm.org/doxygen>`_. The doxygen online; documentation is also indexed by your favorite search engine, which will; make a search for clang and the AST node's class name usually turn up; the doxygen of the class you're looking for (for example, search for:; clang ParenExpr). Examining the AST; =================. A good way to familiarize yourself with the Clang AST is to actually look; at it on some simple example code. Clang has a builtin AST-dump mode,; which can be enabled with the flag ``-ast-dump``. Let's look at a simple example AST:. ::. $ cat test.cc; int f(int x) {; int result = (x / 42);; return result;; }. # Clang by default is a frontend for many tools; -Xclang is used to pass; # options directly to the C++ frontend.; $ clang -Xclang -ast-dump -fsyntax-only test.cc; TranslationUnitDecl 0x5aea0d0 <<invalid sloc>>; ... cutting out internal declarations of clang ...; `-FunctionDecl 0x5aeab50 <test.cc:1:1, line:4:1> f 'int (int)'; |-ParmVarDecl 0x5aeaa90 <line:1:7, col:11> x 'int'; `-CompoundStmt 0x5aead88 <col:14, line:4:1>; |-DeclStmt 0x5aead10 <line:2:3, col:24>; | `-VarDecl 0x5aeac10 <col:3, col:23> result 'int'; | `-ParenExpr 0x5aeacf0 <col:16, col:23> 'int'; | `-BinaryOperator 0x5aeacc8 <col:17, col:21> 'int' '/'; | |-ImplicitCastExpr 0x5aeacb0 <col:17> 'int' <LValueToRValue>; | | `-DeclRefExpr 0x5aeac68 <col:17> 'int' lvalue ParmVar 0x5aeaa90 'x' 'int'; | `-IntegerLiteral 0x5aeac90 <col:21> 'int' 42; `-ReturnStmt 0x5aead68 <line:3:3, col:10>; `-ImplicitCastExpr 0x5aead50 <col:10> 'int' <L",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/IntroductionToTheClangAST.rst:1502,simpl,simple,1502,interpreter/llvm-project/clang/docs/IntroductionToTheClangAST.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/IntroductionToTheClangAST.rst,1,['simpl'],['simple']
Usability,"void test() {; pthread_mutex_lock(&mtx);; pthread_mutex_lock(&mtx);; // warn: this lock has already been acquired; }. lck_mtx_t lck1, lck2;. void test() {; lck_mtx_lock(&lck1);; lck_mtx_lock(&lck2);; lck_mtx_unlock(&lck1);; // warn: this was not the most recently acquired lock; }. lck_mtx_t lck1, lck2;. void test() {; if (lck_mtx_try_lock(&lck1) == 0); return;. lck_mtx_lock(&lck2);; lck_mtx_unlock(&lck1);; // warn: this was not the most recently acquired lock; }. alpha.unix.SimpleStream; (C); Check for misuses of stream APIs:; fopen; fclose(demo checker, the subject of the demo; (Slides; ,Video); by Anna Zaks and Jordan Rose presented at the ; 2012 LLVM Developers' Meeting). void test() {; FILE *F = fopen(""myfile.txt"", ""w"");; } // warn: opened file is never closed. void test() {; FILE *F = fopen(""myfile.txt"", ""w"");. if (F); fclose(F);. fclose(F); // warn: closing a previously closed file stream; }. alpha.unix.Stream; (C); Check stream handling functions:fopen; tmpfile; fclose; fread; fwrite; fseek; ftell; rewind; fgetpos; fsetpos; clearerr; feof; ferror; fileno. void test() {; FILE *p = fopen(""foo"", ""r"");; } // warn: opened file is never closed. void test() {; FILE *p = fopen(""foo"", ""r"");; fseek(p, 1, SEEK_SET); // warn: stream pointer might be NULL; fclose(p);; }. void test() {; FILE *p = fopen(""foo"", ""r"");. if (p); fseek(p, 1, 3);; // warn: third arg should be SEEK_SET, SEEK_END, or SEEK_CUR. fclose(p);; }. void test() {; FILE *p = fopen(""foo"", ""r"");; fclose(p);; fclose(p); // warn: already closed; }. void test() {; FILE *p = tmpfile();; ftell(p); // warn: stream pointer might be NULL; fclose(p);; }. alpha.unix.cstring.BufferOverlap; (C); Checks for overlap in two buffer arguments; applies to:; memcpy; mempcpy. void test() {; int a[4] = {0};; memcpy(a + 2, a + 1, 8); // warn; }. alpha.unix.cstring.NotNullTerminated; (C); Check for arguments which are not null-terminated strings; applies; to:; strlen; strnlen; strcpy; strncpy; strcat; strncat. void test() {; int y =",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/alpha_checks.html:14447,clear,clearerr,14447,interpreter/llvm-project/clang/www/analyzer/alpha_checks.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/alpha_checks.html,1,['clear'],['clearerr']
Usability,"w; <ConditionalControlFlow>` is represented using edges between basic blocks. The; statements within a given ``CFGBlock`` can be traversed using the; ``CFGBlock::*iterator`` interface. A ``CFG`` object owns the instances of ``CFGBlock`` within the control-flow; graph it represents. Each ``CFGBlock`` within a CFG is also uniquely numbered; (accessible via ``CFGBlock::getBlockID()``). Currently the number is based on; the ordering the blocks were created, but no assumptions should be made on how; ``CFGBlocks`` are numbered other than their numbers are unique and that they; are numbered from 0..N-1 (where N is the number of basic blocks in the CFG). Entry and Exit Blocks; ^^^^^^^^^^^^^^^^^^^^^. Each instance of ``CFG`` contains two special blocks: an *entry* block; (accessible via ``CFG::getEntry()``), which has no incoming edges, and an; *exit* block (accessible via ``CFG::getExit()``), which has no outgoing edges.; Neither block contains any statements, and they serve the role of providing a; clear entrance and exit for a body of code such as a function body. The; presence of these empty blocks greatly simplifies the implementation of many; analyses built on top of CFGs. .. _ConditionalControlFlow:. Conditional Control-Flow; ^^^^^^^^^^^^^^^^^^^^^^^^. Conditional control-flow (such as those induced by if-statements and loops) is; represented as edges between ``CFGBlocks``. Because different C language; constructs can induce control-flow, each ``CFGBlock`` also records an extra; ``Stmt*`` that represents the *terminator* of the block. A terminator is; simply the statement that caused the control-flow, and is used to identify the; nature of the conditional control-flow between blocks. For example, in the; case of an if-statement, the terminator refers to the ``IfStmt`` object in the; AST that represented the given branch. To illustrate, consider the following code example:. .. code-block:: c++. int foo(int x) {; x = x + 1;; if (x > 2); x++;; else {; x += 2;; x *= 2;; }.",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:113822,clear,clear,113822,interpreter/llvm-project/clang/docs/InternalsManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst,1,['clear'],['clear']
Usability,"w_ostream`` instances. Avoid ``std::endl``; ^^^^^^^^^^^^^^^^^^^. The ``std::endl`` modifier, when used with ``iostreams`` outputs a newline to; the output stream specified. In addition to doing this, however, it also; flushes the output stream. In other words, these are equivalent:. .. code-block:: c++. std::cout << std::endl;; std::cout << '\n' << std::flush;. Most of the time, you probably have no reason to flush the output stream, so; it's better to use a literal ``'\n'``. Don't use ``inline`` when defining a function in a class definition; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. A member function defined in a class definition is implicitly inline, so don't; put the ``inline`` keyword in this case. Don't:. .. code-block:: c++. class Foo {; public:; inline void bar() {; // ...; }; };. Do:. .. code-block:: c++. class Foo {; public:; void bar() {; // ...; }; };. Microscopic Details; -------------------. This section describes preferred low-level formatting guidelines along with; reasoning on why we prefer them. Spaces Before Parentheses; ^^^^^^^^^^^^^^^^^^^^^^^^^. Put a space before an open parenthesis only in control flow statements, but not; in normal function call expressions and function-like macros. For example:. .. code-block:: c++. if (X) ...; for (I = 0; I != 100; ++I) ...; while (LLVMRocks) ... somefunc(42);; assert(3 != 4 && ""laws of math are failing me"");. A = foo(42, 92) + bar(X);. The reason for doing this is not completely arbitrary. This style makes control; flow operators stand out more, and makes expressions flow better. Prefer Preincrement; ^^^^^^^^^^^^^^^^^^^. Hard fast rule: Preincrement (``++X``) may be no slower than postincrement; (``X++``) and could very well be a lot faster than it. Use preincrementation; whenever possible. The semantics of postincrement include making a copy of the value being; incremented, returning it, and then preincrementing the ""work value"". For; primitive types, this isn't a big deal. But ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodingStandards.rst:57167,guid,guidelines,57167,interpreter/llvm-project/llvm/docs/CodingStandards.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodingStandards.rst,1,['guid'],['guidelines']
Usability,"wed very; thin white lines between the bins as well as in the color palette.; This made very ugly the final output.; This problem is due to bad implementation of anti-aliasing in these previewers.; A way to bypass this issue was to turn off the anti-aliasing in the previewer; but then the rest of the document does not look nice. This problem is now bypassed; with a fix in both PDF and PostScript output.; - Offer 0 as line width option. Useful to make a line invisible. ### TSVG. - Use float numbers instead of integer to describe graphics paths to avoid; rounding problems.; - Implement missing math symbols.; - Offer 0 as line width option. Useful to make a line invisible. ### TASImage. - In the animated gif it is now possible to specify the delay between the last; image and the fist image in case of infinite loop. (Fernando Hueso González; <f.gonzalez@hzdr.de>). ### TPadPainter; - Offer 0 as line width option. Useful to make a line invisible. ### TPad. - In `TPad::ShowGuidelines` the number of guide lines is limited to 15. Above; that they become useless.; - Print a warning if one of the pad limit is a NaN.; - Fix https://sft.its.cern.ch/jira/browse/ROOT-6703. ### TCanvas. - Make sure that ""/"" and ""."" are not part of the method name when a canvas is; saved as a .C file. ### TLatex. - With the Cocoa backend the PDF and PS output produced miss-aligned exponents; because the `GetTextExtend` method behaved differently in batch mode and ""screen""; mode. This is now fixed. See http://root.cern.ch/phpBB3/viewtopic.php?f=3&t=18883; - Improve the square-root drawing in case it is small.; - Better adjustment of the tilde accent position in case of Cocoa backend. ### TMathText. - `\mu` is now working for Postscript output.; - `\splitline` is now implemented. ### Cocoa backend. - Line width and line style were not applied on boxes. ## 3D Graphics Libraries. ### GL Viewer; - New option ""Rotate scene"" in the ""Extras"" tab of the GL Viewer. It allows to; do a real rotation instead of ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v604/index.md:23372,guid,guide,23372,README/ReleaseNotes/v604/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v604/index.md,1,['guid'],['guide']
Usability,"will not conflict; during assembly. This is used to implement `GCC's %= special format; string <https://gcc.gnu.org/onlinedocs/gcc/Extended-Asm.html>`_.; - ``${:comment}``: Expands to the comment character of the current target's; assembly dialect. This is usually ``#``, but many targets use other strings,; such as ``;``, ``//``, or ``!``.; - ``${:private}``: Expands to the assembler private label prefix. Labels with; this prefix will not appear in the symbol table of the assembled object.; Typically the prefix is ``L``, but targets may use other strings. ``.L`` is; relatively popular. LLVM's support for inline asm is modeled closely on the requirements of Clang's; GCC-compatible inline-asm support. Thus, the feature-set and the constraint and; modifier codes listed here are similar or identical to those in GCC's inline asm; support. However, to be clear, the syntax of the template and constraint strings; described here is *not* the same as the syntax accepted by GCC and Clang, and,; while most constraint letters are passed through as-is by Clang, some get; translated to other codes when converting from the C source to the LLVM; assembly. An example inline assembler expression is:. .. code-block:: llvm. i32 (i32) asm ""bswap $0"", ""=r,r"". Inline assembler expressions may **only** be used as the callee operand; of a :ref:`call <i_call>` or an :ref:`invoke <i_invoke>` instruction.; Thus, typically we have:. .. code-block:: llvm. %X = call i32 asm ""bswap $0"", ""=r,r""(i32 %Y). Inline asms with side effects not visible in the constraint list must be; marked as having side effects. This is done through the use of the; '``sideeffect``' keyword, like so:. .. code-block:: llvm. call void asm sideeffect ""eieio"", """"(). In some cases inline asms will contain code that will not work unless; the stack is aligned in some way, such as calls or SSE instructions on; x86, yet will not contain code that does that alignment within the asm.; The compiler should make conservative assumptions ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:208159,clear,clear,208159,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['clear'],['clear']
Usability,"wing z axis in lego plot; 6. Fix - error in TGeoCtub shape creation; 7. Fix - error in pcon/pgon shapes when Rmin===0. ## Changes in 4.5.1; 1. Fix - correctly handle ^2..^9 in TFormula equations; 2. Fix - support TMath::Gaus in TFormula; 3. Fix - correctly display ^2 and ^3 in SVG text output; 4. Fix - do not show tooltips for empty TProfile bins; 5. Fix - statbox toggling was not working on subpads; 6. Fix - positioning of 3D objects in Webkit browsers in complex layouts; 7. Fix - difference in TF1 between ROOT5/6 (#54). ## Changes in 4.5.0; 1. Zooming with mouse wheel; 2. Context menus for many different objects attributes are provided; 3. Context menu for every drawn object can be activated via toolbar button; 4. Support browsing of TTask and derived classes (#40); 5. Apply user range for drawing TH1/TH2 histograms, also when superimposed (#44); 6. Implement scaling factor like x10^3 on the vertical axes; 7. Provide shortcut buttons for each subpad; 8. Implement simple drawing for TBox, TWbox, TSliderBox classes. ## Changes in 4.4.4; 1. Fix - toggling of statbox was not working in all situations; 2. Fix - for mouse rect zooming use only left mouse button; 3. Fix - correctly draw TH2 with lego option, when histogram has negative bin content; 4. Fix - log axis drawing with no visible ticks. ## Changes in 4.4.3; 1. Fix - wrong selection of TH1 Y axis range when errors are displayed (#44); 2. Fix - apply user range for TH1 X-axis zooming (#44); 3. Fix - protect against pathological case of 1-bin histogram; 4. Fix - use error plot by default in TH1 only when positive sumw2 entry exists; 5. Fix - for TH2 box draw option draw at least 1px rect for non-empty bin; 6. Fix - support transparency (alpha) in TColor (#45); 7. Fix - correct tooltip handling for graphs with lines and markers; 8. Fix - interactive zooming in TH2 when doing histogram update. ## Changes in 4.4.2; 1. Fix - statistic collection for TH2; 2. Fix - correct handling of empty TList in browser/inspector; 3",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/changes.md:54928,simpl,simple,54928,js/changes.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/changes.md,1,['simpl'],['simple']
Usability,"with state ""A"",""B"",""C"",""D"" the specification. SplitParamConstrained(""m"",""c"",""D""). will result in parameters m_A,m_B,m_C and a formula expression m_D; that evaluates to (1-(m_A+m_B+m_C)). Constrained split can also be; specified in product of categories. In that case the name of the; remainder state follows the syntax {State1;State2} where State1; and State2 are the state names of the two spitting categories. Additional; functionality exists to work with multiple prototype p.d.f.s simultaneously. ; Improved infrastructure for caching p.d.f and functions. The infrastructure that exists for caching p.d.f.s, i.e. p.d.f that precalculate their value; for all observable values at one and cache those in a histogram that is returned as p.d.f shape; (with optional interpolation), has been expanded. This infrastructure comprises RooAbsCached; the base class for all caching p.d.fs, RooAbsSelfCachedPdf a base class for end-user; caching p.d.f implementations that simply cache the result of evaluate() and RooCachedPdf; that can wrap and cache any input p.d.f specified in its constructor. . By default a p.d.f is sampled and cached in all observables in any; given use context, with no need to specify what those are in advance.; The internal code has also been changed such that all cache; histograms now store pre-normalized p.d.f, which is more efficient; than 'raw' p.d.f histograms that are explicitly post-normalized; through integration. Multiple different use cases (e.g. definitions; of what are observables vs parameters) can be cached; simultaneously. Now it is also possible to specify that p.d.f.s; should be sampled and cached in one or more parameter dimensions; in addition to the automatically determined set of observables.; as well. Also a complete new line of classes with similar functionality has been added inheriting from RooAbsReal.; These are RooAbsCachedReal,RooAbsSelfCachedReal and RooCachedReal. A newly; added class RooHistFunc presents these shapes and is capable of",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v520/index.html:13917,simpl,simply,13917,roofit/doc/v520/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v520/index.html,1,['simpl'],['simply']
Usability,"wn change?. * Any time you learn of a serious problem with a change, you should revert it.; We strongly encourage ""revert to green"" as opposed to ""fixing forward"". We; encourage reverting first, investigating offline, and then reapplying the; fixed patch - possibly after another round of review if warranted.; * If you break a buildbot in a way which can't be quickly fixed, please revert.; * If a test case that demonstrates a problem is reported in the commit thread,; please revert and investigate offline.; * If you receive substantial :ref:`post-commit review <post_commit_review>`; feedback, please revert and address said feedback before recommitting.; (Possibly after another round of review.); * If you are asked to revert by another contributor, please revert and discuss; the merits of the request offline (unless doing so would further destabilize; tip of tree). When should you revert someone else's change?. * In general, if the author themselves would revert the change per these; guidelines, we encourage other contributors to do so as a courtesy to the; author. This is one of the major cases where our norms differ from others;; we generally consider reverting a normal part of development. We don't; expect contributors to be always available, and the assurance that a; problematic patch will be reverted and we can return to it at our next; opportunity enables this. What are the expectations around a revert?. * Use your best judgment. If you're uncertain, please start an email on; the commit thread asking for assistance. We aren't trying to enumerate; every case, but rather give a set of guidelines.; * You should be sure that reverting the change improves the stability of tip; of tree. Sometimes reverting one change in a series can worsen things; instead of improving them. We expect reasonable judgment to ensure that; the proper patch or set of patches is being reverted.; * The commit message for the reverting commit should explain why patch; is being reverted.; * It ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/DeveloperPolicy.rst:20250,guid,guidelines,20250,interpreter/llvm-project/llvm/docs/DeveloperPolicy.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/DeveloperPolicy.rst,1,['guid'],['guidelines']
Usability,"workers at startup.;  E.g.;        1. To; start max 5 workers;             ; TProof::Open(""<master>"",""workers=5"");        2. To; start max 2 workers per physical machine;             ; TProof::Open(""<master>"",""workers=2x"");      This is useful in general when; running tests (equivalent but quicker then full startup;      followed by; TProof::SetParallel(n) or TProof::DeactivateWorker(...)).; Add support for the worker SysInfo_t in TSlaveInfo; (obtained via TProof::GetListOfSlaveInfos()); Add new submerger functionality to speed up the merging; phase. At the end of the query, a set of workers are promoted; submergers and assigned a sub-set of workers to merge. Once each; sub-merger has merged its sub-set of workers, it sends its result to; the master, which merges the partial results into the final; set of results.; The determination of the sub-mergers is always done dynamically, based; on the recent performance of workers. An optimal (i.e. giving the; highest speed-up) number can be calculated analytically under simple; assumptions.; Merging via submergers is by default disabled. To enable it, with the; optimal number of sub-mergers, one should set the integer parameter; 'PROOF_UseMergers' to 0, i.e.                     ; proof->SetParameter(""PROOF_UseMergers"", 0). To force S sub-mergers (regardless of the optimal number) do.                     ; proof->SetParameter(""PROOF_UseMergers"", S). The new functionality can be tested in tutorials by adding the argument; 'submergers' to runProof, e.g. .        ;        ;      root [0] .L; tutorials/proof/runProof.C+ ;        ;        ;      root [1]; runProof(""simple(nhist=10000,submergers)"") . (see the top of tutorials/proof/runProof.C for additional options). A test for the submerger functionality has also been added to; test/stressProof.cxx .; In PROOF-Lite, add the possibility for the administrator; to control the number of workers. This is done using; the rootrc variable ProofLite.MaxWorkers, which is read out of; /etc/s",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/doc/v526/index.html:2464,simpl,simple,2464,proof/doc/v526/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/doc/v526/index.html,1,['simpl'],['simple']
Usability,"works amazingly well in many cases; and falls down in others. Please consult the information on this page on making; the best use of scan-build, which includes getting it to work when the; aforementioned hack fails to work. Viewing static analyzer results in a web browser. Contents. Getting Started. Basic Usage; For Windows Users; Other Options; Output of scan-build. Recommended Usage Guidelines. Always Analyze a Project in its ""Debug"" Configuration; Use Verbose Output when Debugging scan-build; Run './configure' through scan-build. Analyzing iPhone Projects. Getting Started; The scan-build command can be used to analyze an entire project by; essentially interposing on a project's build process. This means that to run the; analyzer using scan-build, you will use scan-build to analyze; the source files compiled by gcc/clang during a project build.; This means that any files that are not compiled will also not be analyzed.; Basic Usage; Basic usage of scan-build is designed to be simple: just place the; word ""scan-build"" in front of your build command:. $ scan-build make; $ scan-build xcodebuild. In the first case scan-build analyzes the code of a project built; with make and in the second case scan-build analyzes a project; built using xcodebuild.; Here is the general format for invoking scan-build:. $ scan-build [scan-build options] <command> [command options]. Operationally, scan-build literally runs <command> with all of the; subsequent options passed to it. For example, one can pass -j4 to; make get a parallel build over 4 cores:. $ scan-build make -j4. In almost all cases, scan-build makes no effort to interpret the; options after the build command; it simply passes them through. In general,; scan-build should support parallel builds, but not distributed; builds.; It is also possible to use scan-build to analyze specific; files:. $ scan-build gcc -c t1.c t2.c. This example causes the files t1.c and t2.c to be analyzed. For Windows Users; Windows users must have P",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/scan-build.html:1992,simpl,simple,1992,interpreter/llvm-project/clang/www/analyzer/scan-build.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/scan-build.html,1,['simpl'],['simple']
Usability,"ws how we use the LogError routines. When called, this function; expects that the current token is a '(' token, but after parsing the; subexpression, it is possible that there is no ')' waiting. For example,; if the user types in ""(4 x"" instead of ""(4)"", the parser should emit an; error. Because errors can occur, the parser needs a way to indicate that; they happened: in our parser, we return null on an error. 2) Another interesting aspect of this function is that it uses recursion; by calling ``ParseExpression`` (we will soon see that; ``ParseExpression`` can call ``ParseParenExpr``). This is powerful; because it allows us to handle recursive grammars, and keeps each; production very simple. Note that parentheses do not cause construction; of AST nodes themselves. While we could do it this way, the most; important role of parentheses are to guide the parser and provide; grouping. Once the parser constructs the AST, parentheses are not; needed. The next simple production is for handling variable references and; function calls:. .. code-block:: c++. /// identifierexpr; /// ::= identifier; /// ::= identifier '(' expression* ')'; static std::unique_ptr<ExprAST> ParseIdentifierExpr() {; std::string IdName = IdentifierStr;. getNextToken(); // eat identifier. if (CurTok != '(') // Simple variable ref.; return std::make_unique<VariableExprAST>(IdName);. // Call.; getNextToken(); // eat (; std::vector<std::unique_ptr<ExprAST>> Args;; if (CurTok != ')') {; while (true) {; if (auto Arg = ParseExpression()); Args.push_back(std::move(Arg));; else; return nullptr;. if (CurTok == ')'); break;. if (CurTok != ','); return LogError(""Expected ')' or ',' in argument list"");; getNextToken();; }; }. // Eat the ')'.; getNextToken();. return std::make_unique<CallExprAST>(IdName, std::move(Args));; }. This routine follows the same style as the other routines. (It expects; to be called if the current token is a ``tok_identifier`` token). It; also has recursion and error handling. One interes",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl02.rst:9513,simpl,simple,9513,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl02.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl02.rst,1,['simpl'],['simple']
Usability,"x::InvertChol() and SMatrix & SMatrix::InverseChol(ifail) for the inversion of a symmetric positive defined matrix. New specialized implementation exists up to matrices with sizes 6x6. The speed is comparable to the Cramer method (SMatrix::InvertFast), but with much better accuracy. The new InvertChol method is in any case faster than the general inverter method for all symmetric matrices (SMatrix::Invert), which uses the Bunch-Kaufman decomposition.; Add also a new free function, ROOT::Math::SolveChol for solving a symmetric linear system. For users who need the solution, using this functions avoid for them performing the inversion and then a matrix multiplication. Add support in the SMatrix class for operator m[i][j]; Add in the dictionary the typedefs for some square and symmetrix matrices based on double and floats (up to size 7) defined in the file Math/SMatrixDfwd and Math/SMatrixFfwd; . Minuit. Apply various improvements in the TMInuitMInimizer class thanks to the feedback of Alfio Lazzaro:; ; implement Hess() and CovMatrixStatus();; add new method based on SEEK. The Tolerance() value can be used to specify the volume (in unit of sigma) for searching for the global minimum; fix some of the methods, like NCalls() and GlobalCC(); . Minuit2. Apply some fixes in MnHesse and MnPosDef classes to check correctly variables to not be zero.; (use same checks as in F77Minuit); ; Fix a bug introduced in DavidonErrorCalculator when checking for delgam. Negative values are allowed. This fixes a test problem given privately by A. Suter.; ; Uses also a tighter condition on edm when exiting the iterations (factor of 5 smaller). This is more consistent with conditions used by F77Minuit.; ; Fix a bug in MnCross in the standalone version of Minuit (when WARNINGMSG was not defined).; ; Fix a bug in the sign of the derivative for sine transformation which are used with double bound parameters. The bug could affect the minimization of function with user provided gradient and bound ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/doc/v524/index.html:5065,feedback,feedback,5065,math/doc/v524/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/doc/v524/index.html,1,['feedback'],['feedback']
Usability,"xTrack-1);; ntrack = nt;; sumstat = 0;; // set the values in each track; for (Int_t n=0;n<nt;n++) {; stat[n] = n%3;; sign[n] = i%2;; px[n] = gRandom->Gaus(0,1);; py[n] = gRandom->Gaus(0,2);; pz[n] = gRandom->Gaus(10,5);; zv[n] = gRandom->Gaus(100,2);; chi2[n] = gRandom->Gaus(0,.01);; sumstat += chi2[n];; pt[n] = TMath::Sqrt(px[n]*px[n] + py[n]*py[n]);; }; t3->Fill();; t3f->Fill();; }; // Write the two files; t3->Print();; f.cd();; t3->Write();; fr.cd();; t3f->Write();; }. // Function to read the two files and add the friend; void tree3r() {; TFile *f = new TFile(""tree3.root"");; TTree *t3 = (TTree*)f->Get(""t3"");; // Add the second tree to the first tree as a friend; t3->AddFriend(""t3f"",""tree3f.root"");; // Draw pz which is in the first tree and use pt; // in the condition. pt is in the friend tree.; t3->Draw(""pz"",""pt>3"");; }. // This is executed when typing .x tree3.C; void tree3() {; tree3w();; tree3r();; }; ```. ## Example 4: A Tree with an Event Class. This example is a simplified version of `$ROOTSYS/test/MainEvent.cxx`; and where Event objects are saved in a tree. The full definition of; `Event` is in `$ROOTSYS/test`/`Event.h`. To execute this macro, you will; need the library `$ROOTSYS/test/libEvent.so`. If it does not exist you; can build the test directory applications by following the instruction; in the `$ROOTSYS/test/README` file. In this example we will show. - the difference in splitting or not splitting a branch; - how to read selected branches of the tree,; - how to print a selected entry. ### The Event Class. `Event` is a descendent of **`TObject`**. As such it inherits the data; members of **`TObject`** and its methods such as `Dump()` and; `Inspect() `and` Write()`. In addition, because it inherits from; **`TObject`** it can be a member of a collection. To summarize, the; advantages of inheriting from a **`TObject`** are:. - Inherit the `Write`, `Inspect`, and `Dump` methods; - Enables a class to be a member of a ROOT collection; - Enables RTTI. Belo",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:58014,simpl,simplified,58014,documentation/users-guide/Trees.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md,1,['simpl'],['simplified']
Usability,"xample of TSelector implementation to do generic; processing with the test 'Event' structure.; See tutorials/proof/runProof.C, option ""event"", for an; example of how to run this selector. \defgroup tutorial_ProofEventProc ProofEventProc; \ingroup tutorial_proof; \brief Selector to process trees containing Event structures. Example of TSelector implementation to process trees; containing 'Event' structures, e.g. the files under; http://root.cern/files/data .; See tutorials/proof/runProof.C, option ""eventproc"", for; an example of how to run this selector. \defgroup tutorial_ProofFriends ProofFriends; \ingroup tutorial_proof; \brief Selector to process tree friends. Example of TSelector implementation to process tree friends in PROOF.; See tutorials/proof/runProof.C, option ""eventproc"", for; an example of how to run this selector. \defgroup tutorial_ProofNtuple ProofNtuple; \ingroup tutorial_proof; \brief Selector to fill a simple ntuple. Example of TSelector implementation to do generic processing; (filling a simple ntuple, in this case).; See tutorials/proof/runProof.C, option ""ntuple"", for an; example of how to run this selector. \defgroup tutorial_ProofPythia ProofPythia; \ingroup tutorial_proof; \brief Selector to generate Monte Carlo events with Pythia8. Example of TSelector implementation to do a Monte Carlo; generation using Pythia8.; See tutorials/proof/runProof.C, option ""pythia8"", for an; example of how to run this selector. \defgroup tutorial_ProofSimple ProofSimple; \ingroup tutorial_proof; \brief Selector to fill a set of histograms. Example of TSelector implementation to do generic processing (filling a; set of histograms in this case).; See tutorials/proof/runProof.C, option ""simple"", for an; example of how to run this selector. \defgroup tutorial_ProofSimpleFile ProofSimpleFile; \ingroup tutorial_proof; \brief Selector to fill a set of histograms and merging via file. Example of TSelector implementation to do generic processing; (filling a set of histog",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tutorials/proof/index.md:1442,simpl,simple,1442,tutorials/proof/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tutorials/proof/index.md,1,['simpl'],['simple']
Usability,"xplain to reviewers and future readers of the code why; the change was made. .. code:: console. $ git checkout -b myfirstpatch; $ git commit -am ""[Diagnostic] Clarify -Winfinite-recursion message"". Now we're ready to send this change out into the world! By the way,; There is an unwritten convention of using tag for your commit. Tags; usually represent modules that you intend to modify. If you don't know; the tags for your modules, you can look at the commit history :; https://github.com/llvm/llvm-project/commits/main. Code review; ===========. Finding a reviewer; ------------------. Changes can be reviewed by anyone in the LLVM community who has commit; access.For larger and more complicated changes, it's important that the; reviewer has experience with the area of LLVM and knows the design goals; well. The author of a change will often assign a specific reviewer (git; blame and git log can be useful to find one). As our change is fairly simple, we'll add the cfe-commits mailing list; as a subscriber; anyone who works on clang can likely pick up the; review. (For changes outside clang, llvm-commits is the usual list. See; `http://lists.llvm.org/ <http://lists.llvm.org/mailman/listinfo>`__ for; all the \*-commits mailing lists). Uploading a change for review; -----------------------------. LLVM code reviews happen through pull-request on GitHub, see; :ref:`GitHub <github-reviews>` documentation for how to open; a pull-request on GitHub. Review process; --------------. When you open a pull-request, some automation will add a comment and; notify different member of the projects depending on the component you; changed.; Within a few days, someone should start the review. They may add; themselves as a reviewer, or simply start leaving comments. You'll get; another email any time the review is updated. The details are in the; `https://llvm.org/docs/CodeReview/ <https://llvm.org/docs/CodeReview.html>`__. Comments; ~~~~~~~~. The reviewer can leave comments on the change, and",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MyFirstTypoFix.rst:9311,simpl,simple,9311,interpreter/llvm-project/llvm/docs/MyFirstTypoFix.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MyFirstTypoFix.rst,1,['simpl'],['simple']
Usability,"xpression. Because we don't have anything better; to return, we'll just define the loop as always returning 0.0. In the; future when we have mutable variables, it will get more useful. As before, let's talk about the changes that we need to Kaleidoscope to; support this. Lexer Extensions for the 'for' Loop; -----------------------------------. The lexer extensions are the same sort of thing as for if/then/else:. .. code-block:: c++. ... in enum Token ...; // control; tok_if = -6, tok_then = -7, tok_else = -8,; tok_for = -9, tok_in = -10. ... in gettok ...; if (IdentifierStr == ""def""); return tok_def;; if (IdentifierStr == ""extern""); return tok_extern;; if (IdentifierStr == ""if""); return tok_if;; if (IdentifierStr == ""then""); return tok_then;; if (IdentifierStr == ""else""); return tok_else;; if (IdentifierStr == ""for""); return tok_for;; if (IdentifierStr == ""in""); return tok_in;; return tok_identifier;. AST Extensions for the 'for' Loop; ---------------------------------. The AST node is just as simple. It basically boils down to capturing the; variable name and the constituent expressions in the node. .. code-block:: c++. /// ForExprAST - Expression class for for/in.; class ForExprAST : public ExprAST {; std::string VarName;; std::unique_ptr<ExprAST> Start, End, Step, Body;. public:; ForExprAST(const std::string &VarName, std::unique_ptr<ExprAST> Start,; std::unique_ptr<ExprAST> End, std::unique_ptr<ExprAST> Step,; std::unique_ptr<ExprAST> Body); : VarName(VarName), Start(std::move(Start)), End(std::move(End)),; Step(std::move(Step)), Body(std::move(Body)) {}. Value *codegen() override;; };. Parser Extensions for the 'for' Loop; ------------------------------------. The parser code is also fairly standard. The only interesting thing here; is handling of the optional step value. The parser code handles it by; checking to see if the second comma is present. If not, it sets the step; value to null in the AST node:. .. code-block:: c++. /// forexpr ::= 'for' identifier '",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl05.rst:16825,simpl,simple,16825,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl05.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl05.rst,1,['simpl'],['simple']
Usability,"xpressions to retain their same meaning,; while enabling the ability to explicitly create memory location descriptions in; non-default address spaces and generalizing the power of composite location; descriptions to any kind of location description. For those familiar with the definition of location descriptions in DWARF Version; 5, the definitions in these extensions are presented differently, but does in; fact define the same concept with the same fundamental semantics. However, it; does so in a way that allows the concept to extend to support address spaces,; bit addressing, the ability for composite location descriptions to be composed; of any kind of location description, and the ability to support objects located; at multiple places. Collectively these changes expand the set of architectures; that can be supported and improves support for optimized code. Several approaches were considered, and the one presented, together with the; extensions it enables, appears to be the simplest and cleanest one that offers; the greatest improvement of DWARF's ability to support debugging optimized GPU; and non-GPU code. Examining the GDB debugger and LLVM compiler, it appears only; to require modest changes as they both already have to support general use of; location descriptions. It is anticipated that will also be the case for other; debuggers and compilers. GDB has been modified to evaluate DWARF Version 5 expressions with location; descriptions as stack entries and with implicit conversions. All GDB tests have; passed, except one that turned out to be an invalid test case by DWARF Version 5; rules. The code in GDB actually became simpler as all evaluation is done on a; single stack and there was no longer a need to maintain a separate structure for; the location description results. This gives confidence in backwards; compatibility. See :ref:`amdgpu-dwarf-expressions` and nested sections. This extension is separately described at *Allow Location Descriptions on the; DWA",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst:7046,simpl,simplest,7046,interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,1,['simpl'],['simplest']
Usability,"xtract) # now empty (or invalid); 0; >>> extract = boost.any_cast[std.vector[int]](val); >>> list(extract); [0, 1, 2, 3, 4, 5, 6, ..., 97, 98, 99]; >>>. Of course, there is no reason to use Boost from Python (in fact, this example; calls out for :doc:`pythonizations <pythonizations>`), but it shows that; cppyy seamlessly supports many advanced C++ features. cppyy is available for both `CPython`_ (v2 and v3) and `PyPy`_, reaching; C++-like performance with the latter.; It makes judicious use of precompiled headers, dynamic loading, and lazy; instantiation, to support C++ programs consisting of millions of lines of; code and many thousands of classes.; cppyy minimizes dependencies to allow its use in distributed, heterogeneous,; development environments. .. _Cling: https://github.com/vgvassilev/cling; .. _tutorial: https://github.com/wlav/cppyy/blob/master/doc/tutorial/CppyyTutorial.ipynb; .. _`PyHPC'16 paper`: http://wlav.web.cern.ch/wlav/Cppyy_LavrijsenDutta_PyHPC16.pdf; .. _`CAAS presentation`: https://www.youtube.com/watch?v=stMD7VDWlVU; .. _`Jason Turner's`: https://www.youtube.com/watch?v=TL83P77vZ1k; .. _`Boost`: http://www.boost.org/; .. _`CPython`: http://python.org; .. _`PyPy`: http://pypy.org. .. only: not latex. Contents:. .. toctree::; :maxdepth: 1. changelog; license. .. toctree::; :caption: Getting Started; :maxdepth: 1. installation; starting; examples; bugs. .. toctree::; :caption: Features; :maxdepth: 1. toplevel; basic_types; strings; classes; functions; type_conversions; stl; exceptions; python; numba; cuda; lowlevel; misc; debugging. .. toctree::; :caption: Redistribution; :maxdepth: 1. pythonizations; utilities; cmake_interface. .. toctree::; :caption: Developers; :maxdepth: 1. packages; repositories; testing. .. toctree::; :caption: Background; :maxdepth: 1. history; philosophy. Bugs and feedback; -----------------. Please report bugs or requests for improvement on the `issue tracker`_. .. _`issue tracker`: https://github.com/wlav/cppyy/issues; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/index.rst:5728,feedback,feedback,5728,bindings/pyroot/cppyy/cppyy/doc/source/index.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/index.rst,1,['feedback'],['feedback']
Usability,"y be specified; ---------------------------------. All of the `AliasAnalysis; <https://llvm.org/doxygen/classllvm_1_1AliasAnalysis.html>`__ virtual methods; default to providing :ref:`chaining <aliasanalysis-chaining>` to another alias; analysis implementation, which ends up returning conservatively correct; information (returning ""May"" Alias and ""Mod/Ref"" for alias and mod/ref queries; respectively). Depending on the capabilities of the analysis you are; implementing, you just override the interfaces you can improve. .. _aliasanalysis-chaining:. ``AliasAnalysis`` chaining behavior; -----------------------------------. Every alias analysis pass chains to another alias analysis implementation (for; example, the user can specify ""``-basic-aa -ds-aa -licm``"" to get the maximum; benefit from both alias analyses). The alias analysis class automatically; takes care of most of this for methods that you don't override. For methods; that you do override, in code paths that return a conservative MayAlias or; Mod/Ref result, simply return whatever the superclass computes. For example:. .. code-block:: c++. AliasResult alias(const Value *V1, unsigned V1Size,; const Value *V2, unsigned V2Size) {; if (...); return NoAlias;; ... // Couldn't determine a must or no-alias result.; return AliasAnalysis::alias(V1, V1Size, V2, V2Size);; }. In addition to analysis queries, you must make sure to unconditionally pass LLVM; `update notification`_ methods to the superclass as well if you override them,; which allows all alias analyses in a change to be updated. .. _update notification:. Updating analysis results for transformations; ---------------------------------------------. Alias analysis information is initially computed for a static snapshot of the; program, but clients will use this information to make transformations to the; code. All but the most trivial forms of alias analysis will need to have their; analysis results updated to reflect the changes made by these transformations. Th",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst:13092,simpl,simply,13092,interpreter/llvm-project/llvm/docs/AliasAnalysis.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst,1,['simpl'],['simply']
Usability,"y building the project ""check-all"".; For more information about testing, see the :doc:`TestingGuide`. Cross compiling; ===============. See `this wiki page <https://gitlab.kitware.com/cmake/community/wikis/doc/cmake/CrossCompiling>`_ for; generic instructions on how to cross-compile with CMake. It goes into detailed; explanations and may seem daunting, but it is not. On the wiki page there are; several examples including toolchain files. Go directly to the; ``Information how to set up various cross compiling toolchains`` section; for a quick solution. Also see the `LLVM-related variables`_ section for variables used when; cross-compiling. Embedding LLVM in your project; ==============================. From LLVM 3.5 onwards the CMake build system exports LLVM libraries as; importable CMake targets. This means that clients of LLVM can now reliably use; CMake to develop their own LLVM-based projects against an installed version of; LLVM regardless of how it was built. Here is a simple example of a CMakeLists.txt file that imports the LLVM libraries; and uses them to build a simple application ``simple-tool``. .. code-block:: cmake. cmake_minimum_required(VERSION 3.20.0); project(SimpleProject). find_package(LLVM REQUIRED CONFIG). message(STATUS ""Found LLVM ${LLVM_PACKAGE_VERSION}""); message(STATUS ""Using LLVMConfig.cmake in: ${LLVM_DIR}""). # Set your project compile flags.; # E.g. if using the C++ header files; # you will need to enable C++11 support; # for your compiler. include_directories(${LLVM_INCLUDE_DIRS}); separate_arguments(LLVM_DEFINITIONS_LIST NATIVE_COMMAND ${LLVM_DEFINITIONS}); add_definitions(${LLVM_DEFINITIONS_LIST}). # Now build our tools; add_executable(simple-tool tool.cpp). # Find the libraries that correspond to the LLVM components; # that we wish to use; llvm_map_components_to_libnames(llvm_libs support core irreader). # Link against LLVM libraries; target_link_libraries(simple-tool ${llvm_libs}). The ``find_package(...)`` directive when used in CO",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CMake.rst:41132,simpl,simple,41132,interpreter/llvm-project/llvm/docs/CMake.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CMake.rst,1,['simpl'],['simple']
Usability,"y directives like the following to redefine the parameter substitutions as; desired before each use of ``%{check}`` in a ``RUN:`` line:. .. code-block:: llvm. ; REDEFINE: %{cflags} = -triple x86_64-apple-darwin10.6.0 -fopenmp-simd; ; REDEFINE: %{fcflags} = -check-prefix=SIMD; ; RUN: %{check}. ; REDEFINE: %{cflags} = -triple x86_64-unknown-linux-gnu -fopenmp-simd; ; REDEFINE: %{fcflags} = -check-prefix=SIMD; ; RUN: %{check}. ; REDEFINE: %{cflags} = -triple x86_64-apple-darwin10.6.0; ; REDEFINE: %{fcflags} = -check-prefix=NO-SIMD; ; RUN: %{check}. ; REDEFINE: %{cflags} = -triple x86_64-unknown-linux-gnu; ; REDEFINE: %{fcflags} = -check-prefix=NO-SIMD; ; RUN: %{check}. Besides providing initial values, the initial ``DEFINE:`` directives for the; parameter substitutions in the above example serve a second purpose: they; establish the substitution order so that both ``%{check}`` and its parameters; expand as desired. There's a simple way to remember the required definition; order in a test file: define a substitution before any substitution that might; refer to it. In general, substitution expansion behaves as follows:. - Upon arriving at each ``RUN:`` line, lit expands all substitutions in that; ``RUN:`` line using their current values from the substitution list. No; substitution expansion is performed immediately at ``DEFINE:`` and; ``REDEFINE:`` directives except ``%(line)``, ``%(line+<number>)``, and; ``%(line-<number>)``.; - When expanding substitutions in a ``RUN:`` line, lit makes only one pass; through the substitution list by default. In this case, a substitution must; have been inserted earlier in the substitution list than any substitution; appearing in its value in order for the latter to expand. (For greater; flexibility, you can enable multiple passes through the substitution list by; setting `recursiveExpansionLimit`_ in a lit configuration file.); - While lit configuration files can insert anywhere in the substitution list,; the insertion behavior of the `",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TestingGuide.rst:30833,simpl,simple,30833,interpreter/llvm-project/llvm/docs/TestingGuide.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TestingGuide.rst,1,['simpl'],['simple']
Usability,"y for; // simple display modes algorithm group; float rainbow1_step; // determines the first component step for neighboring color; // levels, applies only for rainbowed display modes, it does not apply; // for simple display modes algorithm group; float rainbow2_step; // determines the second component step for neighboring; // color levels, applies only for rainbowed display modes, it does not; // apply for simple display modes algorithm group; float rainbow3_step; // determines the third component step for neighboring; // color levels, applies only for rainbowed display modes, it does not; // apply for simple display modes algorithm group; int color_alg; // applies only for rainbowed display modes (rgb smooth algorithm,; // rgb modulo color component, cmy smooth algorithm, cmy modulo; // color component, cie smooth algorithm, cie modulo color component,; // yiq smooth algorithm, yiq modulo color component, hsv smooth; // algorithm, hsv modulo color component, it does not apply for simple; // display modes algorithm group [15]; float l_h_weight; // weight between shading according to fictive light source and; // according to channels counts, applies only for; // PICTURE2_MODE_GROUP_LIGHT_HEIGHT modes group; int xlight; // x position of fictive light source, applies only for rainbowed display; // modes with shading according to light; int ylight; // y position of fictive light source, applies only for rainbowed display; // modes with shading according to light; int zlight; // z position of fictive light source, applies only for rainbowed display; // modes with shading according to light; int shadow; // determines whether shadow will be drawn (no shadow, shadow),; // for rainbowed display modes with shading according to light; int shading; // determines whether the picture will shaded, smoothed (no shading,; // shading), for rainbowed display modes only; int bezier; // determines Bezier interpolation (applies only for simple display; // modes group for grid, x_lines, y",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/spectrum/Spectrum.md:78374,simpl,simple,78374,documentation/spectrum/Spectrum.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/spectrum/Spectrum.md,1,['simpl'],['simple']
Usability,"y showing you how to use ROOT interactively. There are two; examples to click through and learn how to use the GUI. We continue by; using the command line, and explaining the coding conventions, global; variables and the environment setup. If you have not installed ROOT,; you can do so by following the instructions in the appendix, or on the; ROOT web site: <http://root.cern.ch/root/Availability.html>. ## Setting the Environment Variables. Before you can run ROOT you need to set the environment variable; `ROOTSYS` and change your path to include `root/bin` and library path; variables to include `root/lib`. Please note: the syntax is for; `bash`, if you are running `tcsh` you will have to use `setenv`; instead of `export`. 1. Define the variable \$ROOTSYS to the directory where you unpacked; the ROOT:. ```; $ export ROOTSYS=$HOME/root; ```. 2. Add ROOTSYS/bin to your PATH:. ```; $ export PATH=$PATH:$ROOTSYS/bin; ```. 3. Setting the Library Path. On HP-UX, before executing the interactive module, you must set the; library path:. ```; $ export SHLIB_PATH=$SHLIB_PATH:$ROOTSYS/lib; ```. On AIX, before executing the interactive module, you must set the; library path:. ```; $ [ -z ""$LIBPATH"" ] && export LIBPATH=/lib:/usr/lib; $ export LIBPATH=$LIBPATH:$ROOTSYS/lib; ```. On Linux, Solaris, Alpha OSF and SGI, before executing the interactive; module, you must set the library path:. ```; $ export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:$ROOTSYS/lib; ```. On Solaris, in case your LD\_LIBRARY\_PATH is empty, you should set; it:. ```; $ export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:$ROOTSYS/lib:/usr/dt/lib; ```. If you use the `afs` version you should set (*vers* = version number,; *arch* = architecture):. ```; $ export ROOTSYS=/afs/cern.ch/sw/lcg/external/root/vers/arch/root; ```. If ROOT was installed in `$HOME/myroot` directory on a local machine,; one can do:. ```; cd $HOME/myroot; . bin/thisroot.sh // or source bin/thisroot.sh; ```. The new `$ROOTSYS/bin/thisroot.[c]sh` scripts will set",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/GettingStarted.md:994,UX,UX,994,documentation/users-guide/GettingStarted.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/GettingStarted.md,1,['UX'],['UX']
Usability,"y those; of Clang itself. They are entirely within the Clang *project*,; regardless of the version control scheme. Core Clang Tools; ================. The core set of Clang tools that are within the main repository are; tools that very specifically complement, and allow use and testing of; *Clang* specific functionality. ``clang-check``; ---------------. :doc:`ClangCheck` combines the LibTooling framework for running a; Clang tool with the basic Clang diagnostics by syntax checking specific files; in a fast, command line interface. It can also accept flags to re-display the; diagnostics in different formats with different flags, suitable for use driving; an IDE or editor. Furthermore, it can be used in fixit-mode to directly apply; fixit-hints offered by clang. See :doc:`HowToSetupToolingForLLVM` for; instructions on how to setup and used `clang-check`. ``clang-format``; ----------------. Clang-format is both a :doc:`library <LibFormat>` and a :doc:`stand-alone tool; <ClangFormat>` with the goal of automatically reformatting C++ sources files; according to configurable style guides. To do so, clang-format uses Clang's; ``Lexer`` to transform an input file into a token stream and then changes all; the whitespace around those tokens. The goal is for clang-format to serve both; as a user tool (ideally with powerful IDE integrations) and as part of other; refactoring tools, e.g. to do a reformatting of all the lines changed during a; renaming. Extra Clang Tools; =================. As various categories of Clang Tools are added to the extra repository,; they'll be tracked here. The focus of this documentation is on the scope; and features of the tools for other tool developers; each tool should; provide its own user-focused documentation. ``clang-tidy``; --------------. `clang-tidy <https://clang.llvm.org/extra/clang-tidy/>`_ is a clang-based C++; linter tool. It provides an extensible framework for building compiler-based; static analyses detecting and fixing bug-prone ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangTools.rst:3440,guid,guides,3440,interpreter/llvm-project/clang/docs/ClangTools.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangTools.rst,1,['guid'],['guides']
Usability,"y to:. - have a system-wide, sysadmin-provided experiment configuration. - execute user actions either *before* or *after* the execution of the; system-wide script (for instance, choosing the preferred version of; the experiment's software). - transfer a custom user **payload** on each PROOF worker (for instance,; user's client-generated Grid credentials to make PROOF workers; capable of accessing a remote authenticated storage). Configuration files are searched for in two different locations:. - a system-wide directory: `<client_install_dir>/etc`. - user's home directory: `~/.vaf`. > A system-wide configuration file always has precedence over user's; > configuration. It is thus possible for the sysadmin to enforce a; > policy where some scripts cannot ever be overridden. Thanks to this separation, users can maintain an uncluttered directory; with very simple configuration files that contain only what really needs; or is allowed to be customized: for instance, user might specify a single line; containing the needed ROOT version, while all the technicalities to set; up the environment are taken care of inside system-installed scripts,; leaving the user's configuration directory clean and uncluttered. ### Local environment configuration. All the local environment files are loaded at the time of the; client's startup following a certain order. - `common.before`. - `local.before`. - `local.conf`. - `$VafConf_LocalPodLocation/PoD_env.sh`. - `common.after`. - `local.after`. The `common.*` files are sourced both for the local and the remote; environment. This might be convenient to avoid repeating the same; configuration in different places. Each file is looked for first in the system-wide directory and then in; the user's directory. If a configuration file does not exist, it is; silently skipped. The `$VafConf_LocalPodLocation/PoD_env.sh` environment script, provided; with each PROOF on Demand installation, *must exist*: without this file,; the VAF client won't start. ###",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/doc/confman/UsingVirtualAnalysisFacility.md:2150,simpl,simple,2150,proof/doc/confman/UsingVirtualAnalysisFacility.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/doc/confman/UsingVirtualAnalysisFacility.md,1,['simpl'],['simple']
Usability,"y will stop to perform cleanups. For example, the GNU C++ unwinder; doesn't do so unless the exception is actually caught somewhere further up the; stack. In order for inlining to behave correctly, landing pads must be prepared to; handle selector results that they did not originally advertise. Suppose that a; function catches exceptions of type ``A``, and it's inlined into a function that; catches exceptions of type ``B``. The inliner will update the ``landingpad``; instruction for the inlined landing pad to include the fact that ``B`` is also; caught. If that landing pad assumes that it will only be entered to catch an; ``A``, it's in for a rude awakening. Consequently, landing pads must test for; the selector results they understand and then resume exception propagation with; the `resume instruction <LangRef.html#i_resume>`_ if none of the conditions; match. Exception Handling Intrinsics; =============================. In addition to the ``landingpad`` and ``resume`` instructions, LLVM uses several; intrinsic functions (name prefixed with ``llvm.eh``) to provide exception; handling information at various points in generated code. .. _llvm.eh.typeid.for:. ``llvm.eh.typeid.for``; ----------------------. .. code-block:: llvm. i32 @llvm.eh.typeid.for(i8* %type_info). This intrinsic returns the type info index in the exception table of the current; function. This value can be used to compare against the result of; ``landingpad`` instruction. The single argument is a reference to a type info. Uses of this intrinsic are generated by the C++ front-end. .. _llvm.eh.exceptionpointer:. ``llvm.eh.exceptionpointer``; ----------------------------. .. code-block:: text. i8 addrspace(N)* @llvm.eh.padparam.pNi8(token %catchpad). This intrinsic retrieves a pointer to the exception caught by the given; ``catchpad``. SJLJ Intrinsics; ---------------. The ``llvm.eh.sjlj`` intrinsics are used internally within LLVM's; backend. Uses of them are generated by the backend's; ``SjLjEHPrepa",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ExceptionHandling.rst:15180,resume,resume,15180,interpreter/llvm-project/llvm/docs/ExceptionHandling.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ExceptionHandling.rst,1,['resume'],['resume']
Usability,"ybe you just want to follow; the development of the project to see it progress. Contribute. See the hacking document for information on how; to author patches. Follow what's going on; Clang is a subproject of the LLVM Project; and has a Discourse forum and mailing list:. Clang Frontend Discourse forum -; This forum is for discussions related to Clang (questions and answers, design; discussions, RFCs, etc).; Discord chat - Real-time chat for; discussions related to Clang (primarily for questions and answers).; Regular meetings are held on the. first and third Wednesday of each month to discuss C and C++; standards-related activities happening within the Clang community. These; meetings are a way to coordinate efforts between implementers and provide; updates on how standards activities are going. Meeting agendas and minutes are; available. here. Clang office hours -; People within the community hold dedicated office hours at different points; during the month, which is a great way opportunity for getting questions; answered, having more in-depth design discussions, or learning about what's; going on in the community in general.; cfe-commits; - Historical record of commits to Clang and contains early community patch; review commentary. The most common way to talk with other developers on the project is through; the Clang Frontend Discourse forum; . The clang forum is a very friendly place and we welcome newcomers. The; forum is archived so you can browse through previous discussions or follow; development on the web if you prefer.; If you're looking for something to work on, check out our Open Projects page or look through the LLVM bug tracker.; Contributing Extensions to Clang; Clang is designed to support experimentation,; allowing programmers to easily extend the compiler to support great; new language features and tools. At some point, the authors of these; extensions may propose that the extensions become a part of Clang; itself, to benefit the whole Clang commun",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/get_involved.html:1329,learn,learning,1329,interpreter/llvm-project/clang/www/get_involved.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/get_involved.html,1,['learn'],['learning']
Usability,"ylibs and set up linkage relationships; --------------------------------------------------------. In ORC, all symbol definitions reside in JITDylibs. JITDylibs are created by; calling the ``ExecutionSession::createJITDylib`` method with a unique name:. .. code-block:: c++. ExecutionSession ES;; auto &JD = ES.createJITDylib(""libFoo.dylib"");. The JITDylib is owned by the ``ExecutionEngine`` instance and will be freed; when it is destroyed. How to remove code; ------------------. To remove an individual module from a JITDylib it must first be added using an; explicit ``ResourceTracker``. The module can then be removed by calling; ``ResourceTracker::remove``:. .. code-block:: c++. auto &JD = ... ;; auto M = ... ;. auto RT = JD.createResourceTracker();; Layer.add(RT, std::move(M)); // Add M to JD, tracking resources with RT. RT.remove(); // Remove M from JD. Modules added directly to a JITDylib will be tracked by that JITDylib's default; resource tracker. All code can be removed from a JITDylib by calling ``JITDylib::clear``. This; leaves the cleared JITDylib in an empty but usable state. JITDylibs can be removed by calling ``ExecutionSession::removeJITDylib``. This; clears the JITDylib and then puts it into a defunct state. No further operations; can be performed on the JITDylib, and it will be destroyed as soon as the last; handle to it is released. An example of how to use the resource management APIs can be found at; ``llvm/examples/OrcV2Examples/LLJITRemovableCode``. How to add the support for custom program representation; --------------------------------------------------------; In order to add the support for a custom program representation, a custom ``MaterializationUnit``; for the program representation, and a custom ``Layer`` are needed. The Layer will have two; operations: ``add`` and ``emit``. The ``add`` operation takes an instance of your program; representation, builds one of your custom ``MaterializationUnits`` to hold it, then adds it; to a ``JITDylib``",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ORCv2.rst:24105,clear,clear,24105,interpreter/llvm-project/llvm/docs/ORCv2.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ORCv2.rst,1,['clear'],['clear']
Usability,"yline); - TGaxis : [dflt](https://root.cern/js/latest/examples.htm#misc_axis); - TEllipse : [dflt](https://root.cern/js/latest/examples.htm#misc_ellipse); - TArrow : [dflt](https://root.cern/js/latest/examples.htm#misc_arrow); - TPolyMarker3D: [dflt](https://root.cern/js/latest/examples.htm#misc_3dmark). More examples of supported classes can be found on: <https://root.cern/js/latest/examples.htm>. There are special JSROOT draw options which only can be used with for `TCanvas` or `TPad` objects:. - logx - enable log10 scale for X axis; - logy - enable log10 scale for Y axis; - logz - enable log10 scale for Z axis; - log - enable log10 scale for X,Y,Z axes; - log2x - enable log2 scale for X axis; - log2y - enable log2 scale for Y axis; - log2z - enable log2 scale for Z axis; - log2 - enable log2 scale for X,Y,Z axes; - gridx - enable grid for X axis; - gridy - enable grid for X axis; - grid - enable grid for X and Y axes; - tickx - enable ticks for X axis; - ticky - enable ticks for X axis; - tick - enable ticks for X and Y axes; - rx - reverse X axis; - ry - reverse Y axis; - rotate - rotate frame; - fixframe - disable interactive moving of the frame; - nozoomx - disable zooming on X axis; - nozoomy - disable zooming on Y axis; - cpXY - create palette XY for the canvas like cp50; - nopalette - ignore palette stored with TCanvas; - nocolors - ignore colors list stored with TCanvas; - lcolors - use only locally colors list stored with TCanvas; - nomargins - clear frame margins. ## Superimposing draw objects. In the URL string one could use ""+"" sign to specify objects superposition:. - [item=hpx+hprof](https://root.cern/js/latest/?file=../files/hsimple.root&item=hpx+hprof). With similar syntax one could specify individual draw options for superimposed objects. - [item=hpx+hprof&opt=logy+hist](https://root.cern/js/latest/?file=../files/hsimple.root&item=hpx+hprof&opt=logy+hist). Here ""logy"" option will be used for ""hpx1"" item and ""hist"" option for ""hprof;1"" item. While d",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/JSROOT/JSROOT.md:13811,clear,clear,13811,documentation/JSROOT/JSROOT.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/JSROOT/JSROOT.md,1,['clear'],['clear']
Usability,"yms are; valuable [ParzyszekAcronym]_ [LattnerAcronym]_. The most commonly cited acronym; is ``TLI`` however that is used to refer to both ``TargetLowering`` and; ``TargetLibraryInfo`` [GreeneDistinguish]_. The following is a list of acronyms considered sufficiently useful that the; benefit of using them outweighs the cost of learning them. Acronyms that are; either not on the list or are used to refer to a different type should be; expanded. ============================ =============; Class name Variable name; ============================ =============; DeterministicFiniteAutomaton dfa; DominatorTree dt; LoopInfo li; MachineFunction mf; MachineInstr mi; MachineRegisterInfo mri; ScalarEvolution se; TargetInstrInfo tii; TargetLibraryInfo tli; TargetRegisterInfo tri; ============================ =============. In some cases renaming acronyms to the full type name will result in overly; verbose code. Unlike most classes, a variable's scope is limited and therefore; some of its purpose can implied from that scope, meaning that fewer words are; necessary to give it a clear name. For example, in an optimization pass the reader; can assume that a variable's purpose relates to optimization and therefore an; ``OptimizationRemarkEmitter`` variable could be given the name ``remarkEmitter``; or even ``remarker``. The following is a list of longer class names and the associated shorter; variable name. ========================= =============; Class name Variable name; ========================= =============; BasicBlock block; ConstantExpr expr; ExecutionEngine engine; MachineOperand operand; OptimizationRemarkEmitter remarker; PreservedAnalyses analyses; PreservedAnalysesChecker checker; TargetLowering lowering; TargetMachine machine; ========================= =============. Transition Options; ==================. There are three main options for transitioning:. 1. Keep the current coding standard; 2. Laissez faire; 3. Big bang. Keep the current coding standard; -----------------",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Proposals/VariableNames.rst:6595,clear,clear,6595,interpreter/llvm-project/llvm/docs/Proposals/VariableNames.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Proposals/VariableNames.rst,1,['clear'],['clear']
Usability,"ynamic allocation of the coroutine frame; when possible. Example:; """""""""""""""". .. code-block:: llvm. entry:; %id = call token @llvm.coro.id(i32 0, ptr null, ptr null, ptr null); %dyn.alloc.required = call i1 @llvm.coro.alloc(token %id); br i1 %dyn.alloc.required, label %coro.alloc, label %coro.begin. coro.alloc:; %frame.size = call i32 @llvm.coro.size(); %alloc = call ptr @MyAlloc(i32 %frame.size); br label %coro.begin. coro.begin:; %phi = phi ptr [ null, %entry ], [ %alloc, %coro.alloc ]; %frame = call ptr @llvm.coro.begin(token %id, ptr %phi). .. _coro.noop:. 'llvm.coro.noop' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^; ::. declare ptr @llvm.coro.noop(). Overview:; """""""""""""""""". The '``llvm.coro.noop``' intrinsic returns an address of the coroutine frame of; a coroutine that does nothing when resumed or destroyed. Arguments:; """""""""""""""""""". None. Semantics:; """""""""""""""""""". This intrinsic is lowered to refer to a private constant coroutine frame. The; resume and destroy handlers for this frame are empty functions that do nothing.; Note that in different translation units llvm.coro.noop may return different pointers. .. _coro.frame:. 'llvm.coro.frame' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^; ::. declare ptr @llvm.coro.frame(). Overview:; """""""""""""""""". The '``llvm.coro.frame``' intrinsic returns an address of the coroutine frame of; the enclosing coroutine. Arguments:; """""""""""""""""""". None. Semantics:; """""""""""""""""""". This intrinsic is lowered to refer to the `coro.begin`_ instruction. This is; a frontend convenience intrinsic that makes it easier to refer to the; coroutine frame. .. _coro.id:. 'llvm.coro.id' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^; ::. declare token @llvm.coro.id(i32 <align>, ptr <promise>, ptr <coroaddr>,; ptr <fnaddrs>). Overview:; """""""""""""""""". The '``llvm.coro.id``' intrinsic returns a token identifying a; switched-resume coroutine. Arguments:; """""""""""""""""""". The first argument provides information on the alignment of the memory returned; by ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst:36176,resume,resume,36176,interpreter/llvm-project/llvm/docs/Coroutines.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst,1,['resume'],['resume']
Usability,"ynamicValueRelocTableSection: {type: int}; GuardRFVerifyStackPointerFunctionPointer: {type: int}; HotPatchTableOffset: {type: int}; EnclaveConfigurationPointer: {type: int}; VolatileMetadataPointer: {type: int}; GuardEHContinuationTable: {type: int}; GuardEHContinuationCount: {type: int}; GuardXFGCheckFunctionPointer: {type: int}; GuardXFGDispatchFunctionPointer: {type: int}; GuardXFGTableDispatchFunctionPointer: {type: int}; CastGuardOsDeterminedFailureMode: {type: int}. symbols:; - Name: .text; Value: 0; SectionNumber: 1; SimpleType: IMAGE_SYM_TYPE_NULL # (0); ComplexType: IMAGE_SYM_DTYPE_NULL # (0); StorageClass: IMAGE_SYM_CLASS_STATIC # (3); NumberOfAuxSymbols: 1; AuxiliaryData:; ""\x24\x00\x00\x00\x03\x00\x00\x00\x00\x00\x00\x00\x01\x00\x00\x00\x00\x00"" # |$.................|. - Name: _main; Value: 0; SectionNumber: 1; SimpleType: IMAGE_SYM_TYPE_NULL # (0); ComplexType: IMAGE_SYM_DTYPE_NULL # (0); StorageClass: IMAGE_SYM_CLASS_EXTERNAL # (2). Here's a simplified Kwalify_ schema with an extension to allow alternate types. .. _Kwalify: http://www.kuwata-lab.com/kwalify/ruby/users-guide.html. .. code-block:: yaml. type: map; mapping:; header:; type: map; mapping:; Machine: [ {type: str, enum:; [ IMAGE_FILE_MACHINE_UNKNOWN; , IMAGE_FILE_MACHINE_AM33; , IMAGE_FILE_MACHINE_AMD64; , IMAGE_FILE_MACHINE_ARM; , IMAGE_FILE_MACHINE_ARMNT; , IMAGE_FILE_MACHINE_ARM64; , IMAGE_FILE_MACHINE_EBC; , IMAGE_FILE_MACHINE_I386; , IMAGE_FILE_MACHINE_IA64; , IMAGE_FILE_MACHINE_M32R; , IMAGE_FILE_MACHINE_MIPS16; , IMAGE_FILE_MACHINE_MIPSFPU; , IMAGE_FILE_MACHINE_MIPSFPU16; , IMAGE_FILE_MACHINE_POWERPC; , IMAGE_FILE_MACHINE_POWERPCFP; , IMAGE_FILE_MACHINE_R4000; , IMAGE_FILE_MACHINE_SH3; , IMAGE_FILE_MACHINE_SH3DSP; , IMAGE_FILE_MACHINE_SH4; , IMAGE_FILE_MACHINE_SH5; , IMAGE_FILE_MACHINE_THUMB; , IMAGE_FILE_MACHINE_WCEMIPSV2; ]}; , {type: int}; ]; Characteristics:; - type: seq; sequence:; - type: str; enum: [ IMAGE_FILE_RELOCS_STRIPPED; , IMAGE_FILE_EXECUTABLE_IMAGE; , IMAGE_FILE_LINE_NU",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/yaml2obj.rst:3050,simpl,simplified,3050,interpreter/llvm-project/llvm/docs/yaml2obj.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/yaml2obj.rst,1,['simpl'],['simplified']
Usability,"yntax above allows each specification to match exactly one; diagnostic. You can use the extended syntax to customize this. The extended; syntax is ``expected-<type> <n> {{diag text}}``, where ``<type>`` is one of; ``error``, ``warning``, ``remark``, or ``note``, and ``<n>`` is a positive; integer. This allows the diagnostic to appear as many times as specified. For; example:. .. code-block:: c++. void f(); // expected-note 2 {{previous declaration is here}}. Where the diagnostic is expected to occur a minimum number of times, this can; be specified by appending a ``+`` to the number. For example:. .. code-block:: c++. void f(); // expected-note 0+ {{previous declaration is here}}; void g(); // expected-note 1+ {{previous declaration is here}}. In the first example, the diagnostic becomes optional, i.e. it will be; swallowed if it occurs, but will not generate an error if it does not occur. In; the second example, the diagnostic must occur at least once. As a short-hand,; ""one or more"" can be specified simply by ``+``. For example:. .. code-block:: c++. void g(); // expected-note + {{previous declaration is here}}. A range can also be specified by ``<n>-<m>``. For example:. .. code-block:: c++. void f(); // expected-note 0-1 {{previous declaration is here}}. In this example, the diagnostic may appear only once, if at all. .. _DiagnosticMatching:. Matching Modes; ~~~~~~~~~~~~~~. The default matching mode is simple string, which looks for the expected text; that appears between the first `{{` and `}}` pair of the comment. The string is; interpreted just as-is, with one exception: the sequence `\n` is converted to a; single newline character. This mode matches the emitted diagnostic when the; text appears as a substring at any position of the emitted message. To enable matching against desired strings that contain `}}` or `{{`, the; string-mode parser accepts opening delimiters of more than two curly braces,; like `{{{`. It then looks for a closing delimiter of equal ""w",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:160469,simpl,simply,160469,interpreter/llvm-project/clang/docs/InternalsManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst,1,['simpl'],['simply']
Usability,"you will have to link against the; libraries that contain the classes you use. The ROOT reference guide; states the library a class is reference guide defined in. Almost all; relevant classes can be found in libraries returned by; `root-config -glibs`; the graphics libraries are retuned by; `root-config --libs`. These commands are commonly used in `Makefiles`.; Using `root-config` instead of enumerating the libraries by hand; allows you to link them in a platform independent way. Also, if ROOT; library names change you will not need to change your Makefile. A batch program that does not have a graphic display, which creates,; fills, and saves histograms and trees, only needs to link the core; libraries (`libCore`, `libRIO`), `libHist` and `libTree`.; If ROOT needs access to other libraries, it loads them dynamically.; For example, if the **`TreeViewer`** is used, `libTreePlayer` and all; libraries `libTreePlayer` depends on are loaded also. The dependent; libraries are shown in the ROOT reference guide's library dependency; graph. The difference between reference guide `libHist` and; `libHistPainter` is that the former needs to be explicitly linked and; the latter will be loaded automatically at runtime when ROOT needs it,; by means of the Plugin Manager. plugin manager. In the Figure 1-2, the libraries represented by green boxes outside of; the core are loaded via the plugin manager plugin manager or; equivalent techniques, while the white ones are not. Of course, if one; wants to access a plugin library directly, it has to be explicitly; linked. An example of a plugin library is `libMinuit`. To create and; fill histograms you need to link `libHist.so`. If the code has a call; to fit the histogram, the ""fitter"" will dynamically load libMinuit if; it is not yet loaded. #### Plugins: Runtime Library Dependencies for Linking. plugin manager The Plugin Manager **`TPluginManager`** allows; postponing library dependencies to runtime: a plugin library will only; be loaded",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md:18130,guid,guide,18130,documentation/users-guide/Introduction.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md,1,['guid'],['guide']
Usability,"ype of the continuation function is ``void`` there must be no; arguments. - if the return type of the continuation function is a ``struct``, the arguments; will be of element types of that ``struct`` in order;. - otherwise, it is just the return value of the continuation function. .. code-block:: llvm. define {ptr, ptr} @g(ptr %buffer, ptr %ptr, i8 %val) presplitcoroutine {; entry:; %id = call token @llvm.coro.id.retcon.once(i32 8, i32 8, ptr %buffer,; ptr @prototype,; ptr @allocate, ptr @deallocate); %hdl = call ptr @llvm.coro.begin(token %id, ptr null). ... cleanup:; %tok = call token (...) @llvm.coro.end.results(i8 %val); call i1 @llvm.coro.end(ptr %hdl, i1 0, token %tok); unreachable. ... declare i8 @prototype(ptr, i1 zeroext); . 'llvm.coro.end.async' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^; ::. declare i1 @llvm.coro.end.async(ptr <handle>, i1 <unwind>, ...). Overview:; """""""""""""""""". The '``llvm.coro.end.async``' marks the point where execution of the resume part; of the coroutine should end and control should return to the caller. As part of; its variable tail arguments this instruction allows to specify a function and; the function's arguments that are to be tail called as the last action before; returning. Arguments:; """""""""""""""""""". The first argument should refer to the coroutine handle of the enclosing; coroutine. A frontend is allowed to supply null as the first parameter, in this; case `coro-early` pass will replace the null with an appropriate coroutine; handle value. The second argument should be `true` if this coro.end is in the block that is; part of the unwind sequence leaving the coroutine body due to an exception and; `false` otherwise. The third argument if present should specify a function to be called. If the third argument is present, the remaining arguments are the arguments to; the function call. .. code-block:: llvm. call i1 (ptr, i1, ...) @llvm.coro.end.async(; ptr %hdl, i1 0,; ptr @must_tail_call_return,; ptr %ctxt, ptr %task, pt",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst:48552,resume,resume,48552,interpreter/llvm-project/llvm/docs/Coroutines.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst,1,['resume'],['resume']
Usability,"ype>` attribute specifying; the function type of the target. The target can be specified as either; a symbolic LLVM function, or as an arbitrary Value of pointer type. Note; that the function type must match the signature of the callee and the; types of the 'call parameters' arguments. The '#call args' operand is the number of arguments to the actual; call. It must exactly match the number of arguments passed in the; 'call parameters' variable length section. The 'flags' operand is used to specify extra information about the; statepoint. This is currently only used to mark certain statepoints; as GC transitions. This operand is a 64-bit integer with the following; layout, where bit 0 is the least significant bit:. +-------+---------------------------------------------------+; | Bit # | Usage |; +=======+===================================================+; | 0 | Set if the statepoint is a GC transition, cleared |; | | otherwise. |; +-------+---------------------------------------------------+; | 1-63 | Reserved for future use; must be cleared. |; +-------+---------------------------------------------------+. The 'call parameters' arguments are simply the arguments which need to; be passed to the call target. They will be lowered according to the; specified calling convention and otherwise handled like a normal call; instruction. The number of arguments must exactly match what is; specified in '# call args'. The types must match the signature of; 'target'. The 'call parameter' attributes must be followed by two 'i64 0' constants.; These were originally the length prefixes for 'gc transition parameter' and; 'deopt parameter' arguments, but the role of these parameter sets have been; entirely replaced with the corresponding operand bundles. In a future; revision, these now redundant arguments will be removed. Semantics:; """""""""""""""""""". A statepoint is assumed to read and write all memory. As a result,; memory operations can not be reordered past a statepoint. It is; illega",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:502434,clear,cleared,502434,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['clear'],['cleared']
Usability,"ys appears to be; ``V70``, and it is not clear what the other values are for. - **Age** - The number of times the PDB has been written. Equal to the same; field from the :ref:`PDB Stream header <pdb_stream_header>`. - **GlobalStreamIndex** - The index of the :doc:`Global Symbol Stream <GlobalStream>`,; which contains CodeView symbol records for all global symbols. Actual records; are stored in the symbol record stream, and are referenced from this stream. - **BuildNumber** - A bitfield containing values representing the major and minor; version number of the toolchain (e.g. 12.0 for MSVC 2013) used to build the; program, with the following layout:. .. code-block:: c++. uint16_t MinorVersion : 8;; uint16_t MajorVersion : 7;; uint16_t NewVersionFormat : 1;. For the purposes of LLVM, we assume ``NewVersionFormat`` to be always ``true``.; If it is ``false``, the layout above does not apply and the reader should consult; the `Microsoft Source Code <https://github.com/Microsoft/microsoft-pdb>`__ for; further guidance. - **PublicStreamIndex** - The index of the :doc:`Public Symbol Stream <PublicStream>`,; which contains CodeView symbol records for all public symbols. Actual records; are stored in the symbol record stream, and are referenced from this stream. - **PdbDllVersion** - The version number of ``mspdbXXXX.dll`` used to produce this; PDB. Note this obviously does not apply for LLVM as LLVM does not use ``mspdb.dll``. - **SymRecordStream** - The stream containing all CodeView symbol records used; by the program. This is used for deduplication, so that many different; compilands can refer to the same symbols without having to include the full record; content inside of each module stream. - **PdbDllRbld** - Unknown. - **MFCTypeServerIndex** - The index of the MFC type server in the; :ref:`dbi_type_server_map_substream`. - **Flags** - A bitfield with the following layout, containing various; information about how the program was built:. .. code-block:: c++. uint16_t Was",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/PDB/DbiStream.rst:2787,guid,guidance,2787,interpreter/llvm-project/llvm/docs/PDB/DbiStream.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/PDB/DbiStream.rst,1,['guid'],['guidance']
Usability,"ysed in; the same manner as intended for the real data, analysis procedures can; be validated or compared. In many cases, the distribution of the; measurement errors is not precisely known, and simulation offers the; possibility to test the effects of different assumptions. A powerful software framework addressing all of the above requirements; is ROOT, an open source project coordinated by the European Organisation for; Nuclear Research, CERN in Geneva. ROOT is very flexible and provides both a programming interface to use in own; applications and a graphical user interface for interactive data analysis. The; purpose of this document is to serve as a beginners guide and provides extendable; examples for your own use cases, based on typical problems addressed in; student labs. This guide will hopefully lay the ground for more complex; applications in your future scientific work building on a modern,; state-of the art tool for data analysis. This guide in form of a tutorial is intended to introduce you quickly to the; ROOT package. This goal will be accomplished using concrete examples, according; to the ""learning by doing"" principle. Also because of this reason, this guide; cannot cover all the complexity of the ROOT package. Nevertheless, once you feel; confident with the concepts presented in the following chapters, you will be; able to appreciate the ROOT Users Guide [@ROOT_Users_Guide] and navigate through; the Class Reference [@ROOT_Class_Reference] to find all the details you might be; interested in. You can even look at the code itself, since ROOT is a; free, open-source product. Use these documents in parallel to this; tutorial!. The ROOT Data Analysis Framework itself is written in and heavily relies; on the `C++` programming language: some knowledge about `C++` is required.; Jus take advantage from the immense available literature about `C++` if you do; not have any idea of what this language is about. ROOT is available for many platforms (Linux, Mac OS X,",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/Introduction.md:3651,guid,guide,3651,documentation/primer/Introduction.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/Introduction.md,1,['guid'],['guide']
Usability,"ze one-dimensional function.; An interval containing the function minimum must be provided.; Here is an example where we define the function to minimize as a *lambda* function; (requires C++11). The function to minimize must be given to the class implementing the algorithm as a; `ROOT::Math::IBaseFunctionOneDim` object. ```{.cpp}; ROOT::Math::Functor1D func( [](double x){ return 1 + -4*x + 1*x*x; } );. ROOT::Math::BrentMinimizer1D bm;; bm.SetFunction(func, -10,10);; bm.Minimize(10,0,0);; cout << ""Minimum: f("" << bm.XMinimum() << "") = "" <<bm.FValMinimum() << endl;; ```. Note that when setting the function to minimize, one needs to provide the interval range to find the minimum.; In the `Minimize` call, the maximum number of function calls, the relative and absolute tolerance must be provided. #### `ROOT::Math::GSLMInimizer1D`. This class wraps two different methods from the GSL.; The algorithms which can be chosen at construction time are *GOLDENSECTION*, which is the simplest method; but the slowest and *BRENT* (the default one) which combines the golden section with a parabolic interpolation.; The algorithm can be chosen as a different enumeration in the constructor:; * `ROOT::Math::Minim1D::kBRENT` for the Brent algorithm (default); * `ROOT::Math::Minim1D::kGOLDENSECTION` for the golden section algorithm. ```{.cpp}; // this makes class with the default Brent algorithm; ROOT::Math::GSLMinimizer1D minBrent;; // this make the class with the Golden Section algorithm; ROOT::Math::GSLMinimizer1D minGold(ROOT::Math::Minim1D::kGOLDENSECTION);; ```. The interface to set the function and to minimize is the same as in the case of the `BrentMinimizer1D`. #### Using the TF1 class. It is possible to perform the one-dimensional minimization/maximization of a function by using directly the function class in ROOT, `TF1` of the *Hist* library.; The minmization is implemented in `TF1` using the BrentMInimizer1D and available with the class member functions; * `TF1::GetMinimum`/`TF1:",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:65111,simpl,simplest,65111,documentation/users-guide/MathLibraries.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md,1,['simpl'],['simplest']
Usability,"{; public:; OurFunctionPass(): callCounter(0) { }. virtual runOnFunction(Function& F) {; for (BasicBlock &B : F) {; for (Instruction &I: B) {; if (auto *CB = dyn_cast<CallBase>(&I)) {; // We know we've encountered some kind of call instruction (call,; // invoke, or callbr), so we need to determine if it's a call to; // the function pointed to by m_func or not.; if (CB->getCalledFunction() == targetFunc); ++callCounter;; }; }; }; }. private:; unsigned callCounter;; };. .. _iterate_chains:. Iterating over def-use & use-def chains; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Frequently, we might have an instance of the ``Value`` class (`doxygen; <https://llvm.org/doxygen/classllvm_1_1Value.html>`__) and we want to determine; which ``User``\ s use the ``Value``. The list of all ``User``\ s of a particular; ``Value`` is called a *def-use* chain. For example, let's say we have a; ``Function*`` named ``F`` to a particular function ``foo``. Finding all of the; instructions that *use* ``foo`` is as simple as iterating over the *def-use*; chain of ``F``:. .. code-block:: c++. Function *F = ...;. for (User *U : F->users()) {; if (Instruction *Inst = dyn_cast<Instruction>(U)) {; errs() << ""F is used in instruction:\n"";; errs() << *Inst << ""\n"";; }. Alternatively, it's common to have an instance of the ``User`` Class (`doxygen; <https://llvm.org/doxygen/classllvm_1_1User.html>`__) and need to know what; ``Value``\ s are used by it. The list of all ``Value``\ s used by a ``User`` is; known as a *use-def* chain. Instances of class ``Instruction`` are common; ``User`` s, so we might want to iterate over all of the values that a particular; instruction uses (that is, the operands of the particular ``Instruction``):. .. code-block:: c++. Instruction *pi = ...;. for (Use &U : pi->operands()) {; Value *v = U.get();; // ...; }. Declaring objects as ``const`` is an important tool of enforcing mutation free; algorithms (such as analyses, etc.). For this purpose above iterators come in; consta",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:111375,simpl,simple,111375,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,1,['simpl'],['simple']
Usability,"{; task get_return_object() { return std::coroutine_handle<promise_type>::from_promise(*this); }; std::suspend_always initial_suspend() { return {}; }; std::suspend_always final_suspend() noexcept { return {}; }; void return_void() noexcept {}; void unhandled_exception() noexcept {}. int count = 0;; };. void resume() noexcept {; handle.resume();; }. task(std::coroutine_handle<promise_type> hdl) : handle(hdl) {}; ~task() {; if (handle); handle.destroy();; }. std::coroutine_handle<> handle;; };. class await_counter : public std::suspend_always {; public:; template<class PromiseType>; void await_suspend(std::coroutine_handle<PromiseType> handle) noexcept {; handle.promise().count++;; }; };. static task coro_task(int v) {; int a = v;; co_await await_counter{};; a++;; std::cout << a << ""\n"";; a++;; std::cout << a << ""\n"";; a++;; std::cout << a << ""\n"";; co_await await_counter{};; a++;; std::cout << a << ""\n"";; a++;; std::cout << a << ""\n"";; }. int main() {; task t = coro_task(43);; t.resume();; t.resume();; t.resume();; return 0;; }. In debug mode (`O0` + `g`), the printing result would be:. .. parsed-literal::. {__resume_fn = 0x4019e0 <coro_task(int)>, __destroy_fn = 0x402000 <coro_task(int)>, __promise = {count = 1}, v = 43, a = 45, __coro_index = 1 '\001', struct_std__suspend_always_0 = {__int_8 = 0 '\000'},; class_await_counter_1 = {__int_8 = 0 '\000'}, class_await_counter_2 = {__int_8 = 0 '\000'}, struct_std__suspend_always_3 = {__int_8 = 0 '\000'}}. In the above, the values of `v` and `a` are clearly expressed, as are the; temporary values for `await_counter` (`class_await_counter_1` and; `class_await_counter_2`) and `std::suspend_always` (; `struct_std__suspend_always_0` and `struct_std__suspend_always_3`). The index; of the current suspension point of the coroutine is emitted as `__coro_index`.; In the above example, the `__coro_index` value of `1` means the coroutine; stopped at the second suspend point (Note that `__coro_index` is zero indexed); which is the fir",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DebuggingCoroutines.rst:7134,resume,resume,7134,interpreter/llvm-project/clang/docs/DebuggingCoroutines.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DebuggingCoroutines.rst,1,['resume'],['resume']
Usability,"| Load Hardening | Mitigated Speedup |; | -------------------------------------- | -------: | -------------: | ----------------: |; | Google microbenchmark suite | -74.8% | -36.4% | **2.5x** |; | Large server QPS (using ThinLTO & PGO) | -62% | -29% | **1.8x** |. Below is a visualization of the microbenchmark suite results which helps show; the distribution of results that is somewhat lost in the summary. The y-axis is; a log-scale speedup ratio of load hardening relative to `lfence` (up -> faster; -> better). Each box-and-whiskers represents one microbenchmark which may have; many different metrics measured. The red line marks the median, the box marks; the first and third quartiles, and the whiskers mark the min and max. ![Microbenchmark result visualization](speculative_load_hardening_microbenchmarks.png). We don't yet have benchmark data on SPEC or the LLVM test suite, but we can; work on getting that. Still, the above should give a pretty clear; characterization of the performance, and specific benchmarks are unlikely to; reveal especially interesting properties. ### Future Work: Fine Grained Control and API-Integration. The performance overhead of this technique is likely to be very significant and; something users wish to control or reduce. There are interesting options here; that impact the implementation strategy used. One particularly appealing option is to allow both opt-in and opt-out of this; mitigation at reasonably fine granularity such as on a per-function basis,; including intelligent handling of inlining decisions -- protected code can be; prevented from inlining into unprotected code, and unprotected code will become; protected when inlined into protected code. For systems where only a limited; set of code is reachable by externally controlled inputs, it may be possible to; limit the scope of mitigation through such mechanisms without compromising the; application's overall security. The performance impact may also be focused in a; few key functions",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SpeculativeLoadHardening.md:48689,clear,clear,48689,interpreter/llvm-project/llvm/docs/SpeculativeLoadHardening.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SpeculativeLoadHardening.md,1,['clear'],['clear']
Usability,"|; +---------------------------------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------+; | ``{i32, i32} (i32)`` | A function taking an ``i32``, returning a :ref:`structure <t_struct>` containing two ``i32`` values |; +---------------------------------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------+. .. _t_firstclass:. First Class Types; -----------------. The :ref:`first class <t_firstclass>` types are perhaps the most important.; Values of these types are the only ones which can be produced by; instructions. .. _t_single_value:. Single Value Types; ^^^^^^^^^^^^^^^^^^. These are the types that are valid in registers from CodeGen's perspective. .. _t_integer:. Integer Type; """""""""""""""""""""""". :Overview:. The integer type is a very simple type that simply specifies an; arbitrary bit width for the integer type desired. Any bit width from 1; bit to 2\ :sup:`23`\ (about 8 million) can be specified. :Syntax:. ::. iN. The number of bits the integer will occupy is specified by the ``N``; value. Examples:; *********. +----------------+------------------------------------------------+; | ``i1`` | a single-bit integer. |; +----------------+------------------------------------------------+; | ``i32`` | a 32-bit integer. |; +----------------+------------------------------------------------+; | ``i1942652`` | a really big integer of over 1 million bits. |; +----------------+------------------------------------------------+. .. _t_floating:. Floating-Point Types; """""""""""""""""""""""""""""""""""""""". .. list-table::; :header-rows: 1. * - Type; - Description. * - ``half``; - 16-bit floating-point value. * - ``bfloat``; - 16-bit ""brain"" floating-point value (7-bit significand). Provides the; same number of exponent bits as ``float``, so that it matches its dynamic; range, ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:168276,simpl,simple,168276,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,2,['simpl'],"['simple', 'simply']"
Usability,"}; {; TCanvas *c1 = new TCanvas(""c1"", ""c1"",0,0,1200,700);; int n = 100;; Float_t d = 0.5;; TH1F *h1 = new TH1F(""h1"", ""x_min = - d"", n, -d, 100-d);; h1->Fill(1, 1); h1->Fill(3, 3); h1->Fill(5, 5); h1->Fill(7, 7);. TH1F *h2 = new TH1F(""h2"", ""x_min = +d"", n, d, 100+d);; h2->Fill(1, 1); h2->Fill(3, 3); h2->Fill(5, 5); h2->Fill(7, 7);. c1->Divide(1, 2);; c1->cd(1); gPad->SetLogx(); h1->Draw(); // upper picture; c1->cd(2); gPad->SetLogx(); h2->Draw(); // lower picture; h1->GetXaxis()->SetMoreLogLabels();; h2->GetXaxis()->SetMoreLogLabels();; c1_1->SetGridx();; c1_2->SetGridx();; }; ```; - In `PaintStat2` the temporary string used to paint the fit parameters; was too small and in some cases the errors where truncated. The size; of the string is now the same as in `PaintStat`.; - Display the bin error for 2D histograms in the status bar.; - New option `CANDLE` to draw 2D histograms as Candle-PLot (Box-PLot).; A Candle plot (also known as a ""box-and whisker plot"" or simply ""box plot""); is a convenient way to describe graphically a data distribution (D) with; only the five numbers. It was invented in 1977 by John Tukey. With the option CANDLEX five numbers are:. 1. The minimum value of the distribution D (bottom dashed line).; 2. The lower quartile (Q1): 25% of the data points in D are less than; Q1 (bottom of the box).; 3. The median (M): 50% of the data points in D are less than M; (thick line segment inside the box).; 4. The upper quartile (Q3): 75% of the data points in D are less; than Q3 (top of the box).; 5. The maximum value of the distribution D (top dashed line). The mean value of the distribution D is also represented as a circle. In this implementation a TH2 is considered as a collection of TH1 along; X (option `CANDLE` or `CANDLEX`) or Y (option `CANDLEY`).; Each TH1 is represented as a candle plot. Example:. ``` {.cpp}; {; TH2F *hcandle = new TH2F(""hcandle"",""Option CANDLE example "",40,-4,4,40,-20,20);; Float_t px, py;; for (Int_t i = 0; i < 25000; i++) {; gRandom",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/doc/v600/index.md:3877,simpl,simply,3877,hist/doc/v600/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/doc/v600/index.md,1,['simpl'],['simply']
Usability,"}][f61]. ## Toy Monte Carlo Experiments ##. Let us look at a simple example of a toy experiment comparing two; methods to fit a function to a histogram, the $\chi^{2}$. method and a method called ""binned log-likelihood fit"", both available in ROOT. As a very simple yet powerful quantity to check the quality of the fit; results, we construct for each pseudo-data set the so-called ""pull"", the; difference of the estimated and the true value of a parameter,; normalised to the estimated error on the parameter,; $\frac{(p_{estim} - p_{true})}{\sigma_{p}}$. If everything is OK, the; distribution of the pull values is a standard normal distribution, i.e.; a Gaussian distribution centred around zero with a standard deviation of one. The macro performs a rather big number of toy experiments, where a; histogram is repeatedly filled with Gaussian distributed numbers,; representing the pseudo-data in this example. Each time, a fit is; performed according to the selected method, and the pull is calculated; and filled into a histogram. Here is the code:. ``` {.cpp .numberLines}; @ROOT_INCLUDE_FILE macros/macro9.C; ```. Your present knowledge of ROOT should be enough to understand all the; technicalities behind the macro. Note that the variable `pull` in line; *61* is different from the definition above: instead of the parameter; error on `mean`, the fitted standard deviation of the distribution; divided by the square root of the number of entries,; `sig/sqrt(n_tot_entries)`, is used. - What method exhibits the better performance with the default; parameters ?. - What happens if you increase the number of entries per histogram by; a factor of ten ? Why ?. The answers to these questions are well beyond the scope of this guide.; Basically all books about statistical methods provide a complete; treatment of the aforementioned topics. [^5]: ""Monte Carlo"" simulation means that random numbers play a role here; which is as crucial as in games of pure chance in the Casino of Monte Carlo.; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/functions_and_parameter_estimation.md:5737,guid,guide,5737,documentation/primer/functions_and_parameter_estimation.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/functions_and_parameter_estimation.md,1,['guid'],['guide']
Usability,"~~~~~~~~~~~~~~~~~~. Of course, this alignment scheme works best if the address points are; in fact aligned correctly. To make this more likely to happen, we insert; padding between virtual tables that in many cases aligns address points to; a power of 2. Specifically, our padding aligns virtual tables to the next; highest power of 2 bytes; because address points for specific base classes; normally appear at fixed offsets within the virtual table, this normally; has the effect of aligning the address points as well. This scheme introduces tradeoffs between decreased space overhead for; instructions and bit vectors and increased overhead in the form of padding. We; therefore limit the amount of padding so that we align to no more than 128; bytes. This number was found experimentally to provide a good tradeoff. Eliminating Bit Vector Checks for All-Ones Bit Vectors; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. If the bit vector is all ones, the bit vector check is redundant; we simply; need to check that the address is in range and well aligned. This is more; likely to occur if the virtual tables are padded. Forward-Edge CFI for Virtual Calls by Interleaving Virtual Tables; -----------------------------------------------------------------. Dimitar et. al. proposed a novel approach that interleaves virtual tables in [1]_.; This approach is more efficient in terms of space because padding and bit vectors are no longer needed.; At the same time, it is also more efficient in terms of performance because in the interleaved layout; address points of the virtual tables are consecutive, thus the validity check of a virtual; vtable pointer is always a range check. At a high level, the interleaving scheme consists of three steps: 1) split virtual table groups into; separate virtual tables, 2) order virtual tables by a pre-order traversal of the class hierarchy; and 3) interleave virtual tables. The interleaving scheme implemented in LLVM is inspired by [1]_ but has it",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ControlFlowIntegrityDesign.rst:9404,simpl,simply,9404,interpreter/llvm-project/clang/docs/ControlFlowIntegrityDesign.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ControlFlowIntegrityDesign.rst,1,['simpl'],['simply']
Usability,"﻿=====================================; CodeView Type Records; =====================================. .. contents::; :local:. .. _types_intro:. Introduction; ============. This document describes the usage and serialization format of the various; CodeView type records that LLVM understands. This document does not describe; every single CodeView type record that is defined. In some cases, this is; because the records are clearly deprecated and can only appear in very old; software (e.g. the 16-bit types). On other cases, it is because the records; have never been observed in practice. This could be because they are only; generated for non-C++ code (e.g. Visual Basic, C#), or because they have been; made obsolete by newer records, or any number of other reasons. However, the; records we describe here should cover 99% of type records that one can expect; to encounter when dealing with modern C++ toolchains. Record Categories; =================. We can think of a sequence of CodeView type records as an array of variable length; `leaf records`. Each such record describes its own length as part of a fixed-size; header, as well as the kind of record it is. Leaf records are either padded to 4; bytes (if this type stream appears in a TPI/IPI stream of a PDB) or not padded at; all (if this type stream appears in the ``.debug$T`` section of an object file).; Padding is implemented by inserting a decreasing sequence of `<_padding_records>`; that terminates with ``LF_PAD0``. The final category of record is a ``member record``. One particular leaf type --; ``LF_FIELDLIST`` -- contains a series of embedded records. While the outer; ``LF_FIELDLIST`` describes its length (like any other leaf record), the embedded; records -- called ``member records`` do not. .. _leaf_types:. Leaf Records; ------------. All leaf records begin with the following 4 byte prefix:. .. code-block:: c++. struct RecordHeader {; uint16_t RecordLen; // Record length, not including this 2 byte field.; uint16_t R",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/PDB/CodeViewTypes.rst:424,clear,clearly,424,interpreter/llvm-project/llvm/docs/PDB/CodeViewTypes.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/PDB/CodeViewTypes.rst,1,['clear'],['clearly']
