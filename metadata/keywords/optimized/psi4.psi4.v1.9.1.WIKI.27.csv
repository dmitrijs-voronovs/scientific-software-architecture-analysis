quality_attribute,sentence,source,author,repo,version,id,keyword,matched_word,match_idx,filename,wiki,url,total_similar,target_keywords,target_matched_words
Energy Efficiency,"OLCCD). “Orbital-optimized linearized coupled-cluster doubles with density-fitting; and Cholesky decomposition approximations: an efficient implementation,”; U. Bozkaya, Phys. Chem. Chem. Phys. 18, 11362 (2016).; (doi: 10.1039/c6cp00164e). Algebraic-Diagrammatic Construction methods (ADC)¶; General ADC theory. “Intermediate state representation approach to physical properties of; electronically excited molecules,”; J. Schirmer, and A. B. Trofimov, J. Chem. Phys. 120,; 11449-11464 (2004).; (doi: 10.1063/1.1752875). Implementation inside adcc,; the ADC backend used for most ADC methods available in PSI4. “adcc: A versatile toolkit for rapid development of; algebraic-diagrammatic construction methods,”; M. F. Herbst, M. Scheurer, T. Fransson, D. R. Rehn, and A. Dreuw.; WIREs Comput. Mol. Sci., (2020).; (DOI: 10.1002/wcms.1462, Preprint https://adc-connect.org/q/publications. Density Matrix Renormalization Group (DMRG)¶. “CheMPS2: a free open-source spin-adapted implementation of the density; matrix renormalization group for ab initio quantum chemistry,”; S. Wouters, W. Poelmans, P. W. Ayers and D. Van Neck,; Comput. Phys. Commun. 185 (6), 1501-1514 (2014).; (doi: 10.1016/j.cpc.2014.01.019).; “The density matrix renormalization group for ab initio quantum chemistry,”; S. Wouters and D. Van Neck, Eur. Phys. J. D 68 (9), 272 (2014).; (doi: 10.1140/epjd/e2014-50500-1). Scalar Relativistic Corrections¶; General theory for the exact two-component approach (X2C). “Analytic energy gradients for the spin-free exact two-component theory; using an exact block diagonalization for the one-electron Dirac; Hamiltonian,”; L. Cheng and J. Gauss, J. Chem. Phys. 135, 084114 (2011).; (doi: 10.1063/1.3624397). Implementation within Psi4. “Predicting Near Edge X-ray Absorption Spectra with the Spin-Free; Exact-Two-Component Hamiltonian and Orthogonality Constrained Density; Functional Theory,”; P. Verma, W. D. Derricotte and F. A. Evangelista,; J. Chem. Theory Comput. (2015).; (doi: 10.1021",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/introduction.html:20449,adapt,adapted,20449,psi4manual/1.7.x/introduction.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/introduction.html,4,['adapt'],['adapted']
Energy Efficiency,"OLE GRADIENT¶; The derivative of the requested DFT method dipole [E_h a0/u] = [(e a0/a0)^2/u] with respect to nuclear perturbations; as a degree-of-freedom by dipole component array, (3 * {nat}, 3). DFT TOTAL HESSIAN¶; The total electronic second derivative [Eh/a0/a0] for the requested DFT method, (3 * {nat}, 3 * {nat}). DFT XC ENERGY¶; The functional energy contribution [Eh] to the total SCF energy (DFT only).; Quantity \(E_{xc}\) in Eqs. (4) and (1). DFT VV10 ENERGY¶; The VV10 nonlocal contribution [Eh] to the total SCF energy (DFT only).; Included in DFT FUNCTIONAL TOTAL ENERGY. DISPERSION CORRECTION ENERGY¶. fctl DISPERSION CORRECTION ENERGY¶; The dispersion correction [Eh] appended to an underlying functional; when a DFT-D method is requested. Quantity \(E_{\text{-D}}\); in Eqs. (4) and (1).; When dispersion parameters are untweaked for a functional and dispersion; level, labeled QCVariable also defined. DOUBLE-HYBRID CORRECTION ENERGY¶; The scaled MP2 correlation energy correction [Eh] appended to an; underlying functional when a DH-DFT method is requested.; Quantity \(E_{\text{DH}}\) in Eq. (1). DMA DISTRIBUTED MULTIPOLES¶; Distributed multipoles in units given by GDMA_MULTIPOLE_UNITS; with the row index corresponding to the site and the column index; referencing the multipole component. Both indices are zero based,; and the Qlm components of the multipoles are ordered as Q00, Q10,; Q11c, Q11s, Q20, Q21c, Q21s, Q22c, Q22s, etc. DMA TOTAL MULTIPOLES¶; Distributed multipoles as a single row, whose columns are the total; multipoles, translated to GDMA_ORIGIN, and summed. DMRG-SCF TOTAL ENERGY¶; The total DMRG total electonic energy [Eh]. Not unique because oribital spaces vary. DMRG-CASPT2 TOTAL ENERGY¶; The total DMRG plus CASPT2 total electonic energy [Eh] . Not unique because orbital spaces vary. EFP DISP ENERGY¶. EFP ELST ENERGY¶. EFP EXCH ENERGY¶. EFP IND ENERGY¶; Respectively, the dispersion, electrostatics, exchange, and induction; components of the total ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/glossary_psivariables-1.html:21066,energy,energy,21066,psi4manual/1.4.0/glossary_psivariables-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/glossary_psivariables-1.html,5,['energy'],['energy']
Energy Efficiency,"OM). (CCLAMBDA). (CCRESPONSE). (DCFT). (FISAPT). (FNOCC). (MCSCF). (PSIMRCC). (SAPT). (SCF). mcs Database attribute. MCSCF_ALGORITHM (DETCI). MCSCF_DIIS_FREQ (DETCI). MCSCF_DIIS_MAX_VECS (DETCI). MCSCF_DIIS_START (DETCI). MCSCF_E_CONVERGENCE (DETCI). MCSCF_MAX_ROT (DETCI). MCSCF_MAXITER (DETCI). MCSCF_R_CONVERGENCE (DETCI). MCSCF_SO (DETCI). MCSCF_SO_START_E (DETCI). MCSCF_SO_START_GRAD (DETCI). memory. MEMORY (ADC). Method class in qcdb.modelchems. method alias; . adding new. MIN_CCD_DIISVECS (SAPT). MINAO_BASIS (FISAPT). missing_bonds() in module qcdb.parker. missing_neighbors() in module qcdb.parker. MIXED (DETCI). MIXED4 (DETCI). Mk-MRCC. MKL_NUM_THREADS, [1]. MO_DIIS_NUM_VECS (DFOCC). (OCC). MO_MAXITER (DFOCC). (OCC). MO_READ (MCSCF). (OCC). MO_RELAX (DCFT). MO_STEP_MAX (DFOCC). (OCC). MO_WRITE (OCC). MODULE (CPHF). MOGRAD_DAMPING (OCC). Molden. molden() in module driver. MOLDEN_WRITE (DCFT). (DFOCC). (SCF). molecular_charge() LibmintsMolecule method. molecule; . EFP. PubChem. charge. ghost. isotope. multiple fragments. multiple in input file. multiplicity. no_reorient. setting keywords. specification. symmetry. units. Molecule class in qcdb.molecule. molecule() BasisSet method. MolproIn class in qcdb.molpro. molutil module. MOM_OCC (SCF). MOM_START (SCF). MOM_VIR (SCF). MONTAGE. move_to_coc() Molecule method. move_to_com() LibmintsMolecule method. MP2; . density-fitting. MP2.5CORRELATIONENERGY. MP2.5TOTALENERGY. MP2_AMP_TYPE (DFOCC). MP2_AMPS_PRINT (CCENERGY). MP2_CCSD_METHOD (PSIMRCC). MP2_GUESS (PSIMRCC). MP2_OS_SCALE (CCENERGY). (DFMP2). (DFOCC). (OCC). MP2_SCALE_OS (FNOCC). MP2_SCALE_SS (FNOCC). MP2_SOS_SCALE (DFOCC). (OCC). MP2_SOS_SCALE2 (DFOCC). (OCC). MP2_SS_SCALE (CCENERGY). (DFMP2). (DFOCC). (OCC). MP2_TYPE (GLOBALS). MP2CORRELATIONENERGY. MP2TOTALENERGY. MP3CORRELATIONENERGY. MP3TOTALENERGY. MP4. MP4(SDQ)CORRELATIONENERGY. MP4(SDQ)TOTALENERGY. MP4(SDTQ)CORRELATIONENERGY. MP4(SDTQ)TOTALENERGY. MP4(T)CORRECTIONENERGY. MP4CORRELATIONENERGY. MP4TOTALENE",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/genindex.html:49691,charge,charge,49691,psi4manual/1.0.0/genindex.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/genindex.html,1,['charge'],['charge']
Energy Efficiency,"OM); CCEOM — Number of threads. Type: integer; Default: 1. CC_NUM_THREADS (CCTRIPLES); CCTRIPLES — Number of threads. Type: integer; Default: 1. CC_NUM_THREADS (PSIMRCC); PSIMRCC — Number of threads. Type: integer; Default: 1. CC_OS_SCALE (CCENERGY); CCENERGY —. Type: double; Default: 1.27. CC_RAS34_MAX (DETCI); DETCI — maximum number of electrons in RAS III + IV, for CC. Type: integer; Default: -1. CC_RAS3_MAX (DETCI); DETCI — maximum number of electrons in RAS III, for CC. Type: integer; Default: -1. CC_RAS4_MAX (DETCI); DETCI — maximum number of electrons in RAS IV, for CC. Type: integer; Default: -1. CC_SS_SCALE (CCENERGY); CCENERGY —. Type: double; Default: 1.13. CC_UPDATE_EPS (DETCI); DETCI (Expert) — Do update T amplitudes with orbital eigenvalues? (Usually would do this). Not doing this is experimental. Type: boolean; Default: true. CC_VAL_EX_LEVEL (DETCI); DETCI — The CC valence excitation level. Type: integer; Default: 0. CC_VARIATIONAL (DETCI); DETCI (Expert) — Do use variational energy expression in CC computation? Experimental. Type: boolean; Default: false. CC_VECS_READ (DETCI); DETCI — Do import a CC vector from disk?. Type: boolean; Default: false. CC_VECS_WRITE (DETCI); DETCI — Do export a CC vector to disk?. Type: boolean; Default: false. CHECK_C_ORTHONORM (TRANSQT); TRANSQT — Do ?. Type: boolean; Default: false. CI_DIIS (MCSCF); MCSCF — Do use DIIS extrapolation to accelerate convergence of the CI coefficients?. Type: boolean; Default: false. CI_NUM_THREADS (DETCI); DETCI — Number of threads for DETCI. Type: integer; Default: 1. CIBLKS_PRINT (DETCI); DETCI — Do print a summary of the CI blocks?. Type: boolean; Default: false. CIS_AD_STATES (CPHF); CPHF — Which states to save AD Matrices for? * Positive - Singlets * Negative - Triplets *. Type: array; Default: No Default. CIS_AMPLITUDE_CUTOFF (CPHF); CPHF — Minimum singles amplitude to print in CIS analysis. Type: double; Default: 0.15. CIS_DOPDM_STATES (CPHF); CPHF — Which states to save AO differe",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/autodoc_glossary_options_c-1.html:11100,energy,energy,11100,psi4manual/4.0b2/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/autodoc_glossary_options_c-1.html,2,['energy'],['energy']
Energy Efficiency,"OMO = -Nb. stats.append("""""" %6d %6d %6d %6d %6d %6d\n"""""" % (Nintegral-1, Na, Nb, charge, mult, HOMO)). if HOMO > 0:; Na -= 1; else:; Nb -= 1; charge += 1; mult = Na - Nb + 1. core.set_local_option(""SCF"", ""DF_INTS_IO"", ""NONE""). # => Print the results out <= #; E = {}; core.print_out(""""""\n ==> Fractional Occupation Nuke Results <==\n\n""""""); core.print_out("""""" %-11s %-24s %-24s %11s\n"""""" % ('N', 'Energy', 'HOMO Energy', 'Converged')); for k in range(len(Ns)):; core.print_out("""""" %11.3E %24.16E %24.16E %11d\n"""""" % (Ns[k], energies[k], potentials[k], convs[k])); E[Ns[k]] = energies[k]. core.print_out('\n'); core.print_out("""""" %6s %6s %6s %6s %6s %6s\n"""""" % ('N', 'Na', 'Nb', 'Charge', 'Mult', 'HOMO')); for line in stats:; core.print_out(line). core.print_out('\n ""You shoot a nuke down a bug hole, you got a lot of dead bugs""\n'); core.print_out(' -Starship Troopers\n'). # Drop the files out; with open(traverse_filename, 'w') as fh:; fh.write("""""" %-11s %-24s %-24s %11s\n"""""" % ('N', 'Energy', 'HOMO Energy', 'Converged')); for k in range(len(Ns)):; fh.write("""""" %11.3E %24.16E %24.16E %11d\n"""""" % (Ns[k], energies[k], potentials[k], convs[k])). with open(stats_filename, 'w') as fh:; fh.write("""""" %6s %6s %6s %6s %6s %6s\n"""""" % ('N', 'Na', 'Nb', 'Charge', 'Mult', 'HOMO')); for line in stats:; fh.write(line). optstash.restore(); return E. [docs]; def ip_fitting(name: Union[str, Callable], omega_l: float = 0.05, omega_r: float = 2.5, omega_convergence: float = 1.0e-3, maxiter: int = 20, **kwargs) -> float:; """"""Optimize DFT omega parameter for molecular system. Parameters; ----------; name; DFT functional string name or function defining functional; whose omega is to be optimized.; omega_l; Minimum omega to be considered during fitting.; omega_r; Maximum omega to be considered during fitting.; molecule : :ref:`molecule <op_py_molecule>`, optional; Target molecule (neutral) for which omega is to be tuned, if not last defined.; omega_convergence; Threshold below which to consider omega",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/frac.html:14063,Energy,Energy,14063,psi4manual/1.8.x/_modules/psi4/driver/frac.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/frac.html,6,['Energy'],['Energy']
Energy Efficiency,"OMO = -Nb. stats.append("""""" %6d %6d %6d %6d %6d %6d\n"""""" % (Nintegral-1, Na, Nb, charge, mult, HOMO)). if HOMO > 0:; Na -= 1; else:; Nb -= 1; charge += 1; mult = Na - Nb + 1. core.set_local_option(""SCF"", ""DF_INTS_IO"", ""NONE""). # => Print the results out <= #; E = {}; core.print_out(""""""\n ==> Fractional Occupation Nuke Results <==\n\n""""""); core.print_out("""""" %-11s %-24s %-24s %11s\n"""""" % ('N', 'Energy', 'HOMO Energy', 'Converged')); for k in range(len(Ns)):; core.print_out("""""" %11.3E %24.16E %24.16E %11d\n"""""" % (Ns[k], energies[k], potentials[k], convs[k])); E[Ns[k]] = energies[k]. core.print_out('\n'); core.print_out("""""" %6s %6s %6s %6s %6s %6s\n"""""" % ('N', 'Na', 'Nb', 'Charge', 'Mult', 'HOMO')); for line in stats:; core.print_out(line). core.print_out('\n ""You shoot a nuke down a bug hole, you got a lot of dead bugs""\n'); core.print_out(' -Starship Troopers\n'). # Drop the files out; with open(traverse_filename, 'w') as fh:; fh.write("""""" %-11s %-24s %-24s %11s\n"""""" % ('N', 'Energy', 'HOMO Energy', 'Converged')); for k in range(len(Ns)):; fh.write("""""" %11.3E %24.16E %24.16E %11d\n"""""" % (Ns[k], energies[k], potentials[k], convs[k])). with open(stats_filename, 'w') as fh:; fh.write("""""" %6s %6s %6s %6s %6s %6s\n"""""" % ('N', 'Na', 'Nb', 'Charge', 'Mult', 'HOMO')); for line in stats:; fh.write(line). optstash.restore(); return E. [docs]def ip_fitting(name: Union[str, Callable], omega_l: float = 0.05, omega_r: float = 2.5, omega_convergence: float = 1.0e-3, maxiter: int = 20, **kwargs) -> float:; """"""Optimize DFT omega parameter for molecular system. Parameters; ----------; name; DFT functional string name or function defining functional; whose omega is to be optimized.; omega_l; Minimum omega to be considered during fitting.; omega_r; Maximum omega to be considered during fitting.; molecule : :ref:`molecule <op_py_molecule>`, optional; Target molecule (neutral) for which omega is to be tuned, if not last defined.; omega_convergence; Threshold below which to consider omega c",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/frac.html:14057,Energy,Energy,14057,psi4manual/1.7.x/_modules/psi4/driver/frac.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/frac.html,2,['Energy'],['Energy']
Energy Efficiency,"ON ENERGY"": (""NOCP-CORRECTED INTERACTION ENERGY THROUGH 2-BODY"", 1.7),; ""NOCP-CORRECTED 3-BODY INTERACTION ENERGY"": (""NOCP-CORRECTED INTERACTION ENERGY THROUGH 3-BODY"", 1.7),; ""NOCP-CORRECTED 4-BODY INTERACTION ENERGY"": (""NOCP-CORRECTED INTERACTION ENERGY THROUGH 4-BODY"", 1.7),; ""NOCP-CORRECTED 5-BODY INTERACTION ENERGY"": (""NOCP-CORRECTED INTERACTION ENERGY THROUGH 5-BODY"", 1.7),; ""VMFC-CORRECTED 2-BODY INTERACTION ENERGY"": (""VMFC-CORRECTED INTERACTION ENERGY THROUGH 2-BODY"", 1.7),; ""VMFC-CORRECTED 3-BODY INTERACTION ENERGY"": (""VMFC-CORRECTED INTERACTION ENERGY THROUGH 3-BODY"", 1.7),; ""VMFC-CORRECTED 4-BODY INTERACTION ENERGY"": (""VMFC-CORRECTED INTERACTION ENERGY THROUGH 4-BODY"", 1.7),; ""VMFC-CORRECTED 5-BODY INTERACTION ENERGY"": (""VMFC-CORRECTED INTERACTION ENERGY THROUGH 5-BODY"", 1.7),; ""COUNTERPOISE CORRECTED TOTAL ENERGY"": (""CP-CORRECTED TOTAL ENERGY"", 1.7),; ""COUNTERPOISE CORRECTED INTERACTION ENERGY"": (""CP-CORRECTED INTERACTION ENERGY"", 1.7),; ""NON-COUNTERPOISE CORRECTED TOTAL ENERGY"": (""NOCP-CORRECTED TOTAL ENERGY"", 1.7),; ""NON-COUNTERPOISE CORRECTED INTERACTION ENERGY"": (""NOCP-CORRECTED INTERACTION ENERGY"", 1.7),; ""VALIRON-MAYER FUNCTION COUTERPOISE TOTAL ENERGY"": (""VALIRON-MAYER FUNCTION COUNTERPOISE TOTAL ENERGY"", 1.7), # note misspelling; ""VALIRON-MAYER FUNCTION COUTERPOISE INTERACTION ENERGY"": (""VMFC-CORRECTED INTERACTION ENERGY"", 1.7), # note misspelling; }. _qcvar_cancellations = {; ""SCSN-MP2 SAME-SPIN CORRELATION ENERGY"": [""MP2 SAME-SPIN CORRELATION ENERGY""],; ""SCSN-MP2 OPPOSITE-SPIN CORRELATION ENERGY"": [""MP2 OPPOSITE-SPIN CORRELATION ENERGY""],; ""SCS-CCSD SAME-SPIN CORRELATION ENERGY"": [""CCSD SAME-SPIN CORRELATION ENERGY""],; ""SCS-CCSD OPPOSITE-SPIN CORRELATION ENERGY"": [""CCSD OPPOSITE-SPIN CORRELATION ENERGY""],; ""SCS-MP2 SAME-SPIN CORRELATION ENERGY"": [""MP2 SAME-SPIN CORRELATION ENERGY""],; ""SCS-MP2 OPPOSITE-SPIN CORRELATION ENERGY"": [""MP2 OPPOSITE-SPIN CORRELATION ENERGY""],; ""SCS(N)-OMP2 CORRELATION ENERGY"": [""OMP2 SAME-SPIN CORRELATION ENERGY"", ""OMP",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/p4util/python_helpers.html:20544,ENERGY,ENERGY,20544,psi4manual/1.6.x/_modules/psi4/driver/p4util/python_helpers.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/p4util/python_helpers.html,10,['ENERGY'],['ENERGY']
Energy Efficiency,"ON ENERGY'); ce_mp3 = PsiMod.get_variable('MP3 CORRELATION ENERGY'); e_mp2 = e_scf + ce_mp2 # reform mp2 and mp3 total energies for printing; e_mp3 = e_scf + ce_mp3. # Compute quantities particular to MP2.5; ce_mp25 = 0.5 * (ce_mp2 + ce_mp3); e_mp25 = e_scf + ce_mp25; PsiMod.set_variable('MP2.5 CORRELATION ENERGY', ce_mp25) # add new method's important results; PsiMod.set_variable('MP2.5 TOTAL ENERGY', e_mp25) # to PSI variable repository; PsiMod.set_variable('CURRENT CORRELATION ENERGY', ce_mp25); PsiMod.set_variable('CURRENT ENERGY', e_mp25) # geometry optimizer tracks this variable, permits; # MP2.5 finite difference optimizations; # build string of title banner and print results; banners = ''; banners += """"""PsiMod.print_out('\\n')\n""""""; banners += """"""banner(' MP2.5 ')\n""""""; banners += """"""PsiMod.print_out('\\n')\n\n""""""; exec banners. tables = ''; tables += """""" SCF total energy: %16.8f\n"""""" % (e_scf); tables += """""" MP2 total energy: %16.8f\n"""""" % (e_mp2); tables += """""" MP2.5 total energy: %16.8f\n"""""" % (e_mp25); tables += """""" MP3 total energy: %16.8f\n\n"""""" % (e_mp3); tables += """""" MP2 correlation energy: %16.8f\n"""""" % (ce_mp2); tables += """""" MP2.5 correlation energy: %16.8f\n"""""" % (ce_mp25); tables += """""" MP3 correlation energy: %16.8f\n"""""" % (ce_mp3); PsiMod.print_out(tables) # prints nice header and table of all involved quantities to output file. return e_mp25. One final step is necessary. At the end of the aliases.py file, add; the following line.; procedures['energy']['mp2.5'] = run_mp2_5. This permits the newly defined MP2.5 method to be called in the input file; with the following command.; energy('mp2.5'). Previous topic; User-Defined Basis Sets; Next topic; Creating a Database; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules |. next |. previous |; PSI4 [beta2] » ; Customization: Adding Simple Extensions ». © Copyright 2012, Psi4 Project.; Last updated on Sep 30, 2012.; Created us",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/quickaddalias-1.html:2842,energy,energy,2842,psi4manual/4.0b2/quickaddalias-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/quickaddalias-1.html,2,['energy'],['energy']
Energy Efficiency,"ON ENERGY'); ce_mp3 = PsiMod.get_variable('MP3 CORRELATION ENERGY'); e_mp2 = e_scf + ce_mp2 # reform mp2 and mp3 total energies for printing; e_mp3 = e_scf + ce_mp3. # Compute quantities particular to MP2.5; ce_mp25 = 0.5 * (ce_mp2 + ce_mp3); e_mp25 = e_scf + ce_mp25; PsiMod.set_variable('MP2.5 CORRELATION ENERGY', ce_mp25) # add new method's important results; PsiMod.set_variable('MP2.5 TOTAL ENERGY', e_mp25) # to PSI variable repository; PsiMod.set_variable('CURRENT CORRELATION ENERGY', ce_mp25); PsiMod.set_variable('CURRENT ENERGY', e_mp25) # geometry optimizer tracks this variable, permits; # MP2.5 finite difference optimizations; # build string of title banner and print results; banners = ''; banners += """"""PsiMod.print_out('\\n')\n""""""; banners += """"""banner(' MP2.5 ')\n""""""; banners += """"""PsiMod.print_out('\\n')\n\n""""""; exec banners. tables = ''; tables += """""" SCF total energy: %16.8f\n"""""" % (e_scf); tables += """""" MP2 total energy: %16.8f\n"""""" % (e_mp2); tables += """""" MP2.5 total energy: %16.8f\n"""""" % (e_mp25); tables += """""" MP3 total energy: %16.8f\n\n"""""" % (e_mp3); tables += """""" MP2 correlation energy: %16.8f\n"""""" % (ce_mp2); tables += """""" MP2.5 correlation energy: %16.8f\n"""""" % (ce_mp25); tables += """""" MP3 correlation energy: %16.8f\n"""""" % (ce_mp3); PsiMod.print_out(tables) # prints nice header and table of all involved quantities to output file. return e_mp25. One final step is necessary. At the end of the aliases.py file, add; the following line.; procedures['energy']['mp2.5'] = run_mp2_5. This permits the newly defined MP2.5 method to be called in the input file; with the following command.; energy('mp2.5'). Previous topic; User-Defined Basis Sets; Next topic; Creating a Database; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta3] » ; Customization: Adding Simple Extensions ». © Copyright 2012, The Psi4 Project.; Last updated on Oct 16",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/quickaddalias-1.html:2857,energy,energy,2857,psi4manual/4.0b3/quickaddalias-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/quickaddalias-1.html,2,['energy'],['energy']
Energy Efficiency,"ON ENERGY'); ce_mp3 = PsiMod.get_variable('MP3 CORRELATION ENERGY'); e_mp2 = e_scf + ce_mp2 # reform mp2 and mp3 total energies for printing; e_mp3 = e_scf + ce_mp3. # Compute quantities particular to MP2.5; ce_mp25 = 0.5 * (ce_mp2 + ce_mp3); e_mp25 = e_scf + ce_mp25; PsiMod.set_variable('MP2.5 CORRELATION ENERGY', ce_mp25) # add new method's important results; PsiMod.set_variable('MP2.5 TOTAL ENERGY', e_mp25) # to PSI variable repository; PsiMod.set_variable('CURRENT CORRELATION ENERGY', ce_mp25); PsiMod.set_variable('CURRENT ENERGY', e_mp25) # geometry optimizer tracks this variable, permits; # MP2.5 finite difference optimizations; # build string of title banner and print results; banners = ''; banners += """"""PsiMod.print_out('\\n')\n""""""; banners += """"""banner(' MP2.5 ')\n""""""; banners += """"""PsiMod.print_out('\\n')\n\n""""""; exec banners. tables = ''; tables += """""" SCF total energy: %16.8f\n"""""" % (e_scf); tables += """""" MP2 total energy: %16.8f\n"""""" % (e_mp2); tables += """""" MP2.5 total energy: %16.8f\n"""""" % (e_mp25); tables += """""" MP3 total energy: %16.8f\n\n"""""" % (e_mp3); tables += """""" MP2 correlation energy: %16.8f\n"""""" % (ce_mp2); tables += """""" MP2.5 correlation energy: %16.8f\n"""""" % (ce_mp25); tables += """""" MP3 correlation energy: %16.8f\n"""""" % (ce_mp3); PsiMod.print_out(tables) # prints nice header and table of all involved quantities to output file. return e_mp25. One final step is necessary. At the end of the aliases.py file, add; the following line.; procedures['energy']['mp2.5'] = run_mp2_5. This permits the newly defined MP2.5 method to be called in the input file; with the following command.; energy('mp2.5'). Previous topic; User-Defined Basis Sets; Next topic; Creating a Database; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » ; Customization: Adding Simple Extensions ». © Copyright 2013, The Psi4 Project.; Last updated on Apr 25",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/quickaddalias-1.html:2857,energy,energy,2857,psi4manual/4.0b4/quickaddalias-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/quickaddalias-1.html,2,['energy'],['energy']
Energy Efficiency,"ONV (CFOUR); CFOUR — Specifies the threshold used in converging CC-LR/EOM-CC calculations. The iterative diagonalization is continued until the RMS residual falls below with as the value specified with this keyword. Type: integer; Default: 5. CFOUR_ESTATE_MAXCYC (CFOUR); CFOUR — The maximum number of expansion vectors used in the solution of EOMCC equations (Default: 20, hard-coded to 4 in triples calculations). Type: integer; Default: 20. CFOUR_ESTATE_PROP (CFOUR); CFOUR — This keyword applies only to EOM-CC calculations and specifies whether any excited or ionized state one-electron properties are to be calculated. Proper use of this keyword requires a relatively advanced knowledge of quantum chemistry and the available options are discussed here. The options are: OFF (=0) [no properties or transition moments are calculated]; EXPECTATION (=1) [transition moments and dipole strengths are calculated along with selected one-electron properties which are evaluated as expectation values]; UNRELAXED (=2) [selected one-electron properties are calculated in an approximation that neglects relaxation of molecular orbitals]; RESPONSE (=3) [selected one-electron properties are calculated as analytic first derivatives of the energy]. Except for EOMCC calculations on two-electron systems (which are exact), properties obtained by the three approaches will not be equivalent. The default value for this keyword is slightly complicated. For TDA calculations, the default is EXPECTATION since the evaluation of transition moments involves only a negligible amount of additional computation relative to the evaluation of the excitation energies. For EOMCC, the default is OFF since evaluation of any transition moments or properties requires approximately twice the computational time. Transition moments and dipole strengths are evaluated by default for all values of ESTATE_PROP other than OFF. Type: string; Possible Values: OFF, EXPECTATION, UNRELAXED, RESPONSE; Default: No Default. CFOUR_ES",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_glossary_options_c-1.html:36142,energy,energy,36142,psi4manual/1.0.0/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_glossary_options_c-1.html,2,['energy'],['energy']
Energy Efficiency,"ONVERGENCE (DCFT); DCFT — Convergence criterion for energy. See Table Post-SCF Convergence for default convergence criteria for different calculation types. Type: conv double; Default: 1e-10. E_CONVERGENCE (DETCI); DETCI — Convergence criterion for energy. See Table Post-SCF Convergence for default convergence criteria for different calculation types. Type: conv double; Default: 1e-6. E_CONVERGENCE (DFOCC); DFOCC — Convergence criterion for energy. See Table Post-SCF Convergence for default convergence criteria for different calculation types. Type: conv double; Default: 1e-6. E_CONVERGENCE (FNOCC); FNOCC — Convergence criterion for CC energy. See Table Post-SCF Convergence for default convergence criteria for different calculation types. Note that convergence is met only when E_CONVERGENCE and R_CONVERGENCE are satisfied. Type: conv double; Default: 1.0e-6. E_CONVERGENCE (MCSCF); MCSCF — Convergence criterion for energy. Type: conv double; Default: 1e-6. E_CONVERGENCE (MRCC); MRCC — Convergence criterion for energy. See Table Post-SCF Convergence for default convergence criteria for different calculation types. This becomes tol (option #16) in fort.56. Type: conv double; Default: 1e-6. E_CONVERGENCE (OCC); OCC — Convergence criterion for energy. See Table Post-SCF Convergence for default convergence criteria for different calculation types. Type: conv double; Default: 1e-6. E_CONVERGENCE (PSIMRCC); PSIMRCC — Convergence criterion for energy. See Table Post-SCF Convergence for default convergence criteria for different calculation types. Type: conv double; Default: 1e-6. E_CONVERGENCE (SAPT); SAPT — Convergence criterion for energy (change) in the SAPT \(E_{ind,resp}^{(20)}\) term during solution of the CPHF equations. Type: conv double; Default: 1e-10. E_CONVERGENCE (SCF); SCF — Convergence criterion for SCF energy. See Table SCF Convergence & Algorithm for default convergence criteria for different calculation types. Type: conv double; Default: 1e-6. EA_POLES (OCC)",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/autodoc_glossary_options_c-1.html:116825,energy,energy,116825,psi4manual/1.2.1/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/autodoc_glossary_options_c-1.html,6,['energy'],['energy']
Energy Efficiency,ONVERGENCE (DCFT); DCFT — Convergence criterion for energy. See Table Post-SCF Convergence for default convergence criteria for different calculation types. Type: conv double; Default: 1e-10. E_CONVERGENCE (DETCI); DETCI — Convergence criterion for energy. See Table Post-SCF Convergence for default convergence criteria for different calculation types. Type: conv double; Default: 1e-6. E_CONVERGENCE (DFOCC); DFOCC — Convergence criterion for energy. See Table Post-SCF Convergence for default convergence criteria for different calculation types. Type: conv double; Default: 1e-6. E_CONVERGENCE (FNOCC); FNOCC — Convergence criterion for CC energy. See Table Post-SCF Convergence for default convergence criteria for different calculation types. Note that convergence is met only when E_CONVERGENCE and R_CONVERGENCE are satisfied. Type: conv double; Default: 1.0e-6. E_CONVERGENCE (MCSCF); MCSCF — Convergence criterion for energy. Type: conv double; Default: 1e-6. E_CONVERGENCE (MRCC); MRCC — Convergence criterion for energy. See Table Post-SCF Convergence for default convergence criteria for different calculation types. This becomes tol (option #16) in fort.56. Type: conv double; Default: 1e-6. E_CONVERGENCE (OCC); OCC — Convergence criterion for energy. See Table Post-SCF Convergence for default convergence criteria for different calculation types. Type: conv double; Default: 1e-6. E_CONVERGENCE (PSIMRCC); PSIMRCC — Convergence criterion for energy. See Table Post-SCF Convergence for default convergence criteria for different calculation types. Type: conv double; Default: 1e-6. E_CONVERGENCE (SAPT); SAPT — Convergence criterion for energy (change) in the SAPT term during solution of the CPHF equations. Type: conv double; Default: 1e-10. E_CONVERGENCE (SCF); SCF — Convergence criterion for SCF energy. See Table SCF Convergence & Algorithm for default convergence criteria for different calculation types. Type: conv double; Default: 1e-6. EA_POLES (OCC); OCC — Do compute OCC p,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_glossary_options_c-1.html:114411,energy,energy,114411,psi4manual/1.0.0/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_glossary_options_c-1.html,2,['energy'],['energy']
Energy Efficiency,"ONVERGENCE and R_CONVERGENCE are satisfied. Type: conv double; Default: 1.0e-6. E_CONVERGENCE (MCSCF); MCSCF — Convergence criterion for energy. Type: conv double; Default: 1e-6. E_CONVERGENCE (MRCC); MRCC — Convergence criterion for energy. See Table Post-SCF Convergence for default convergence criteria for different calculation types. This becomes tol (option #16) in fort.56. Type: conv double; Default: 1e-6. E_CONVERGENCE (OCC); OCC — Convergence criterion for energy. See Table Post-SCF Convergence for default convergence criteria for different calculation types. Type: conv double; Default: 1e-6. E_CONVERGENCE (PSIMRCC); PSIMRCC — Convergence criterion for energy. See Table Post-SCF Convergence for default convergence criteria for different calculation types. Type: conv double; Default: 1e-6. E_CONVERGENCE (SAPT); SAPT — Convergence criterion for energy (change) in the SAPT term during solution of the CPHF equations. Type: conv double; Default: 1e-10. E_CONVERGENCE (SCF); SCF — Convergence criterion for SCF energy. See Table SCF Convergence & Algorithm for default convergence criteria for different calculation types. Type: conv double; Default: 1e-6. EA_POLES (OCC); OCC — Do compute OCC poles for electron affinities? Only valid for OMP2. Type: boolean; Default: false. EFP_DISP (EFP); EFP — Do include dispersion energy term in EFP computation?. Type: boolean; Default: true. EFP_DISP_DAMPING (EFP); EFP — Fragment-fragment dispersion damping type. TT is a damping formula by Tang and Toennies. OVERLAP is overlap-based dispersion damping. Type: string; Possible Values: TT, OVERLAP, OFF; Default: OVERLAP. EFP_ELST (EFP); EFP — Do include electrostatics energy term in EFP computation?. Type: boolean; Default: true. EFP_ELST_DAMPING (EFP); EFP — Fragment-fragment electrostatic damping type. SCREEN is a damping formula based on screen group in the EFP potential. OVERLAP is damping that computes charge penetration energy. Type: string; Possible Values: SCREEN, OVERLAP, OFF;",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_glossary_options_c-1.html:115203,energy,energy,115203,psi4manual/1.0.0/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_glossary_options_c-1.html,2,['energy'],['energy']
Energy Efficiency,"ONVERGENCE and R_CONVERGENCE are satisfied. Type: conv double; Default: 1.0e-6. E_CONVERGENCE (MCSCF); MCSCF — Convergence criterion for energy. Type: conv double; Default: 1e-6. E_CONVERGENCE (MRCC); MRCC — Convergence criterion for energy. See Table Post-SCF Convergence for default convergence criteria for different calculation types. This becomes tol (option #16) in fort.56. Type: conv double; Default: 1e-6. E_CONVERGENCE (OCC); OCC — Convergence criterion for energy. See Table Post-SCF Convergence for default convergence criteria for different calculation types. Type: conv double; Default: 1e-6. E_CONVERGENCE (PSIMRCC); PSIMRCC — Convergence criterion for energy. See Table Post-SCF Convergence for default convergence criteria for different calculation types. Type: conv double; Default: 1e-6. E_CONVERGENCE (SAPT); SAPT — Convergence criterion for energy (change) in the SAPT term during solution of the CPHF equations. Type: conv double; Default: 1e-10. E_CONVERGENCE (SCF); SCF — Convergence criterion for SCF energy. See Table SCF Convergence & Algorithm for default convergence criteria for different calculation types. Type: conv double; Default: 1e-6. EA_POLES (OCC); OCC — Do compute OCC poles for electron affinities? Only valid for OMP2. Type: boolean; Default: false. EKT_EA (OCC); OCC — Do compute virtual orbital energies based on extended Koopmans’ theorem?. Type: boolean; Default: false. EKT_IP (OCC); OCC — Do compute occupied orbital energies based on extended Koopmans’ theorem?. Type: boolean; Default: false. EOM_GUESS (CCEOM); CCEOM — Specifies a set of single-excitation guess vectors for the EOM-CC procedure. If EOM_GUESS = SINGLES, the guess will be taken from the singles-singles block of the similarity-transformed Hamiltonian, Hbar. If EOM_GUESS = DISK, guess vectors from a previous computation will be read from disk. If EOM_GUESS = INPUT, guess vectors will be specified in user input. The latter method is not currently available. Type: string; Possible V",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/autodoc_glossary_options_c-1.html:39021,energy,energy,39021,psi4manual/4.0b5/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodoc_glossary_options_c-1.html,2,['energy'],['energy']
Energy Efficiency,"ONVERGENCE', 10); if not psi4.has_option_changed('SCF', 'D_CONVERGENCE'):; if procedures['energy'][lowername] == run_scf or procedures['energy'][lowername] == run_dft:; psi4.set_local_option('SCF', 'D_CONVERGENCE', 8); else:; psi4.set_local_option('SCF', 'D_CONVERGENCE', 10). # Set post-scf convergence criteria (global will cover all correlated modules); if not psi4.has_global_option_changed('E_CONVERGENCE'):; if not procedures['energy'][lowername] == run_scf and not procedures['energy'][lowername] == run_dft:; psi4.set_global_option('E_CONVERGENCE', 8). # Does dertype indicate an analytic procedure both exists and is wanted?; if (dertype == 1):; # Nothing to it but to do it. Gradient information is saved; # into the current reference wavefunction; procedures['gradient'][lowername](lowername, **kwargs). if 'mode' in kwargs and kwargs['mode'].lower() == 'sow':; raise ValidationError('Optimize execution mode \'sow\' not valid for analytic gradient calculation.'); psi4.wavefunction().energy(). optstash.restore(); return psi4.get_variable('CURRENT ENERGY'). else:; # If not, perform finite difference of energies. opt_iter = 1; if ('opt_iter' in kwargs):; opt_iter = kwargs['opt_iter']. if opt_iter == 1:; print('Performing finite difference calculations'). # Obtain list of displacements; displacements = psi4.fd_geoms_1_0(); ndisp = len(displacements). # This version is pretty dependent on the reference geometry being last (as it is now); print(' %d displacements needed ...' % (ndisp), end=""""); energies = []. # S/R: Write instructions for sow/reap procedure to output file and reap input file; if (opt_mode.lower() == 'sow'):; instructionsO = """"""\n The optimization sow/reap procedure has been selected through mode='sow'. In addition\n""""""; instructionsO += """""" to this output file (which contains no quantum chemical calculations), this job\n""""""; instructionsO += """""" has produced a number of input files (OPT-%s-*.in) for individual components\n"""""" % (str(opt_iter)); instructionsO",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/driver.html:35351,energy,energy,35351,psi4manual/4.0b5/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/driver.html,2,['energy'],['energy']
Energy Efficiency,"ONVERGENCE']). # Make sure the molecule the user provided is the active one; if ('molecule' in kwargs):; activate(kwargs['molecule']); del kwargs['molecule']; molecule = psi4.get_active_molecule(); molecule.update_geometry(); #psi4.set_global_option('BASIS', psi4.get_global_option('BASIS')). # Allow specification of methods to arbitrary order; lowername, level = parse_arbitrary_order(lowername); if level:; kwargs['level'] = level. try:; # Set method-dependent scf convergence criteria (test on procedures['energy'] since that's guaranteed); # SCF properties have been set as 6/5 so as to match those; # run normally through OEProp so subject to change; if not psi4.has_option_changed('SCF', 'E_CONVERGENCE'):; if procedures['energy'][lowername] == run_scf or procedures['energy'][lowername] == run_dft:; psi4.set_local_option('SCF', 'E_CONVERGENCE', 6); else:; psi4.set_local_option('SCF', 'E_CONVERGENCE', 10); if not psi4.has_option_changed('SCF', 'D_CONVERGENCE'):; if procedures['energy'][lowername] == run_scf or procedures['energy'][lowername] == run_dft:; psi4.set_local_option('SCF', 'D_CONVERGENCE', 6); else:; psi4.set_local_option('SCF', 'D_CONVERGENCE', 10). # Set post-scf convergence criteria (global will cover all correlated modules); if not psi4.has_global_option_changed('E_CONVERGENCE'):; if not procedures['energy'][lowername] == run_scf and not procedures['energy'][lowername] == run_dft:; psi4.set_global_option('E_CONVERGENCE', 8). returnvalue = procedures['property'][lowername](lowername, **kwargs). except KeyError:; raise ValidationError('Property method %s not available.' % (lowername)). optstash.restore(); return returnvalue. ## Aliases ##; prop = property. [docs]def optimize(name, **kwargs):; r""""""Function to perform a geometry optimization. :aliases: opt(). :returns: (*float*) Total electronic energy of optimized structure in Hartrees. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`CURRENT ENERGY <CURRENTENERGY>`. .. note:: Analytic gradients area avai",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/driver.html:44517,energy,energy,44517,psi4manual/4.0b5/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/driver.html,4,['energy'],['energy']
Energy Efficiency,"ONVERGENCE. Type: conv double; Default: 1e-4. TDSCF_STATES¶. Number of roots (excited states) we should seek to converge. This can be either an integer (total number of states to seek) or a list (number of states per irrep). The latter is only valid if the system has symmetry. Furthermore, the total number of states will be redistributed among irreps when symmetry is used. Type: array; Default: No Default. TDSCF_TDA¶. Run with Tamm-Dancoff approximation (TDA), uses random-phase approximation (RPA) when false. Type: boolean; Default: false. TDSCF_TDM_PRINT¶. Which transition dipole moments to print out: - E_TDM_LEN : electric transition dipole moments, length representation - E_TDM_VEL : electric transition dipole moments, velocity representation - M_TDM : magnetic transition dipole moments. Type: array; Default: No Default. TDSCF_TRIPLETS¶. Controls inclusion of triplet states, which is only valid for restricted references. Valid options: - none : No triplets computed (default) - also : lowest-energy triplets and singlets included, in 50-50 ratio. Note that singlets are privileged, i.e. if seeking to converge 5 states in total, 3 will be singlets and 2 will be triplets. - only : Only triplet states computed. Type: string; Possible Values: NONE, ALSO, ONLY; Default: NONE. WCOMBINE¶. combine omega exchange and Hartree–Fock exchange into one matrix for efficiency? Default is True for MemDFJK (itself the default for SCF_TYPE DF), False otherwise as not yet implemented. Type: boolean; Default: false. Expert General Wavefunction Info¶. PK_ALGO¶. Select the PK algorithm to use. For debug purposes, selection will be automated later. Type: string; Possible Values: REORDER, YOSHIMINE; Default: REORDER. PK_ALL_NONSYM¶. All densities are considered non symmetric, debug only. Type: boolean; Default: false. PK_MAX_BUCKETS¶. Maximum numbers of batches to read PK supermatrix. Type: integer; Default: 500. PK_NO_INCORE¶. Deactivate in core algorithm. For debug purposes. Type: boolean",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/autodir_options_c/module__scf-1.html:15095,energy,energy,15095,psi4manual/1.4.0/autodir_options_c/module__scf-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/module__scf-1.html,4,['energy'],['energy']
Energy Efficiency,"ONVERGENCE. Type: conv double; Default: 1e-4. TDSCF_STATES¶. Number of roots (excited states) we should seek to converge. This can be either an integer (total number of states to seek) or a list (number of states per irrep). The latter is only valid if the system has symmetry. Furthermore, the total number of states will be redistributed among irreps when symmetry is used. Type: array; Default: No Default. TDSCF_TDA¶. Run with Tamm-Dancoff approximation (TDA), uses random-phase approximation (RPA) when false. Type: boolean; Default: false. TDSCF_TDM_PRINT¶. Which transition dipole moments to print out: - E_TDM_LEN : electric transition dipole moments, length representation - E_TDM_VEL : electric transition dipole moments, velocity representation - M_TDM : magnetic transition dipole moments. Type: array; Default: No Default. TDSCF_TRIPLETS¶. Controls inclusion of triplet states, which is only valid for restricted references. Valid options: - none : No triplets computed (default) - also : lowest-energy triplets and singlets included, in 50-50 ratio. Note that singlets are privileged, i.e. if seeking to converge 5 states in total, 3 will be singlets and 2 will be triplets. - only : Only triplet states computed. Type: string; Possible Values: NONE, ALSO, ONLY; Default: NONE. WCOMBINE¶. combine omega exchange and Hartree–Fock exchange into one matrix for efficiency? Disabled until fixed. Type: boolean; Default: false. Expert General Wavefunction Info¶. PK_ALGO¶. Select the PK algorithm to use. For debug purposes, selection will be automated later. Type: string; Possible Values: REORDER, YOSHIMINE; Default: REORDER. PK_ALL_NONSYM¶. All densities are considered non symmetric, debug only. Type: boolean; Default: false. PK_MAX_BUCKETS¶. Maximum numbers of batches to read PK supermatrix. Type: integer; Default: 500. PK_NO_INCORE¶. Deactivate in core algorithm. For debug purposes. Type: boolean; Default: false. WFN¶. Wavefunction type. Type: string; Possible Values: SCF; Defau",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/autodir_options_c/module__scf-1.html:15436,energy,energy,15436,psi4manual/1.5.0/autodir_options_c/module__scf-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/autodir_options_c/module__scf-1.html,8,['energy'],['energy']
Energy Efficiency,"ONVERGENCE. Type: conv double; Default: 1e-4. TDSCF_STATES¶. Number of roots (excited states) we should seek to converge. This can be either an integer (total number of states to seek) or a list (number of states per irrep). The latter is only valid if the system has symmetry. Furthermore, the total number of states will be redistributed among irreps when symmetry is used. Type: array; Default: No Default. TDSCF_TDA¶. Run with Tamm-Dancoff approximation (TDA), uses random-phase approximation (RPA) when false. Type: boolean; Default: false. TDSCF_TDM_PRINT¶. Which transition dipole moments to print out: - E_TDM_LEN : electric transition dipole moments, length representation - E_TDM_VEL : electric transition dipole moments, velocity representation - M_TDM : magnetic transition dipole moments. Type: array; Default: No Default. TDSCF_TRIPLETS¶. Controls inclusion of triplet states, which is only valid for restricted references. Valid options: - none : No triplets computed (default) - also : lowest-energy triplets and singlets included, in 50-50 ratio. Note that singlets are privileged, i.e. if seeking to converge 5 states in total, 3 will be singlets and 2 will be triplets. - only : Only triplet states computed. Type: string; Possible Values: NONE, ALSO, ONLY; Default: NONE. WCOMBINE¶. combine omega exchange and Hartree–Fock exchange into one matrix for efficiency? Disabled until fixed. Type: boolean; Default: false. Expert General Wavefunction Info¶. PK_ALL_NONSYM¶. All densities are considered non symmetric, debug only. Type: boolean; Default: false. PK_MAX_BUCKETS¶. Maximum numbers of batches to read PK supermatrix. Type: integer; Default: 500. SCF_SUBTYPE¶. For certain SCF_TYPE algorithms that have internal sub-algorithms depending on available memory or other hardware constraints, allow the best sub-algorithm for the molecule and conditions (AUTO ; usual mode) or forcibly select a sub-algorithm (usually only for debugging or profiling). Presently, SCF_SUBTYPE=DF, S",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/autodir_options_c/module__scf.html:17800,energy,energy,17800,psi4manual/1.8.x/autodir_options_c/module__scf.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/autodir_options_c/module__scf.html,6,['energy'],['energy']
Energy Efficiency,"OPTKING). INTRAFRAG_STEP_LIMIT_MIN (OPTKING). INTS_TOLERANCE (CCDENSITY). (CCSORT). (DCFT). (DFMP2). (LMP2). (MRCC). (SAPT). (SCF). (TRANSQT). (TRANSQT2). invalidate() CartesianEntry method. CoordValue method. ZMatrixEntry method. ip_fitting() in module frac. IP_POLES (OCC). IRC; . geometry optimization. IRC_DIRECTION (OPTKING). IRC_STEP_SIZE (OPTKING). IRC_STOP (OPTKING). irrep_labels() LibmintsMolecule method. is_axis() LibmintsMolecule method. is_computed() CoordEntry method. is_equivalent_to() CoordEntry method. is_ghosted() CoordEntry method. is_linear_planar() LibmintsMolecule method. is_plane() LibmintsMolecule method. is_variable() LibmintsMolecule method. ISTOP (DETCI). IVO (TRANSQT). J. J_FILE (TRANSQT). JOBTYPE (CCLAMBDA). JSCH module, [1]. K. KEEP_INTCOS (OPTKING). KEEP_J (TRANSQT). KEEP_OEIFILE (CCSORT). KEEP_PRESORT (TRANSQT). KEEP_TEIFILE (CCSORT). keywords; . C-side, setting. cbs(), setting. cp(), setting. database(), setting. diatomic_anharmonicity(), setting. energy(), setting. molecule, setting. optimize(), setting. property(), setting. kwargs_lower() in module procutil. L. label() CoordEntry method. LibmintsMolecule method. LAG_IN_FILE (TRANSQT). LAGRAN_DOUBLE (TRANSQT). LAGRAN_HALVE (TRANSQT). LAMBDA_MAXITER (DCFT). LCC2(+LMP2)TOTALENERGY. LCCSD(+LMP2)TOTALENERGY. LEVEL_SHIFT (MCSCF). (OCC). LibmintsMolecule class in qcdb.libmintsmolecule. like_world_axis() LibmintsMolecule static method. LINEAR (CCRESPONSE). LINEQ_SOLVER (OCC). LINESEARCH_STATIC_MAX (OPTKING). LINESEARCH_STATIC_MIN (OPTKING). LINESEARCH_STATIC_N (OPTKING). load_basfam_dunning() in module basislistdunning. load_basfam_other() in module basislistother. load_basis_families() in module basislist. LOCAL (CCENERGY). (CCEOM). (CCLAMBDA). (CCRESPONSE). (CCSORT). (CIS). LOCAL_AMPS_PRINT_CUTOFF (CIS). LOCAL_CORE_CUTOFF (CCSORT). LOCAL_CPHF_CUTOFF (CCENERGY). (CCLAMBDA). (CCRESPONSE). (CCSORT). LOCAL_CUTOFF (CCENERGY). (CCEOM). (CCLAMBDA). (CCRESPONSE). (CCSORT). (CIS). (LMP2). LOCAL_DO_SI",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/genindex.html:25039,energy,energy,25039,psi4manual/4.0b4/genindex.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/genindex.html,1,['energy'],['energy']
Energy Efficiency,"OR A PARTICULAR PURPOSE. See the; # GNU Lesser General Public License for more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #; """"""Module with utility functions for use in input files."""""". import os; import re; import sys; import warnings; from typing import Union. from psi4 import core; from psi4.driver.procrouting import *; from .exceptions import ValidationError; from .prop_util import *. [docs]def oeprop(wfn: core.Wavefunction, *args, **kwargs):; """"""Evaluate one-electron properties. :returns: None. :param wfn: set of molecule, basis, orbitals from which to compute properties. How to specify args, which are actually the most important. :type title: str; :param title: label prepended to all psivars computed. :examples:. >>> # [1] Moments with specific label; >>> E, wfn = energy('hf', return_wfn=True); >>> oeprop(wfn, 'DIPOLE', 'QUADRUPOLE', title='H3O+ SCF'). """"""; oe = core.OEProp(wfn); if 'title' in kwargs:; oe.set_title(kwargs['title']); for prop in args:; oe.add(prop); ; # If we're doing MBIS, we want the free-atom volumes; # in order to compute volume ratios,; # but only if we're calling oeprop as the whole molecule; free_atom = kwargs.get('free_atom',False); if ""MBIS"" in prop.upper() and not free_atom:; core.print_out("" Computing free-atom volumes\n""); free_atom_volumes(wfn) . oe.compute(). [docs]def cubeprop(wfn, **kwargs):; """"""Evaluate properties on a grid and generate cube files. .. versionadded:: 0.5; *wfn* parameter passed explicitly. :returns: None. :type wfn: :py:class:`~psi4.core.Wavefunction`; :param wfn: set of molecule, basis, orbitals from which to generate cube files. :examples:. >>> # [1] Cube files for all orbitals; >>> E, wfn = energy('b3lyp', return_wfn=True); >>> cubeprop(wfn). >>> # [2] Cube files for density (alpha, beta, total, spin) and four o",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/util.html:1760,energy,energy,1760,psi4manual/1.4.0/_modules/psi4/driver/p4util/util.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/util.html,4,['energy'],['energy']
Energy Efficiency,"OR A PARTICULAR PURPOSE. See the; # GNU Lesser General Public License for more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #; """"""Module with utility functions for use in input files."""""". import os; import re; import sys; import warnings; from typing import Union. from psi4 import core; from psi4.driver.procrouting import *; from .exceptions import ValidationError; from .prop_util import *. [docs]def oeprop(wfn: core.Wavefunction, *args, **kwargs):; """"""Evaluate one-electron properties. :returns: None. :param wfn: set of molecule, basis, orbitals from which to compute properties. How to specify args, which are actually the most important. :type title: str; :param title: label prepended to all psivars computed. :examples:. >>> # [1] Moments with specific label; >>> E, wfn = energy('hf', return_wfn=True); >>> oeprop(wfn, 'DIPOLE', 'QUADRUPOLE', title='H3O+ SCF'). """"""; oe = core.OEProp(wfn); if 'title' in kwargs:; oe.set_title(kwargs['title']); for prop in args:; oe.add(prop); ; # If we're doing MBIS, we want the free-atom volumes; # in order to compute volume ratios,; # but only if we're calling oeprop as the whole molecule; free_atom = kwargs.get('free_atom',False); if ""MBIS_VOLUME_RATIOS"" in prop.upper() and not free_atom:; core.print_out("" Computing free-atom volumes\n""); free_atom_volumes(wfn) . oe.compute(). [docs]def cubeprop(wfn, **kwargs):; """"""Evaluate properties on a grid and generate cube files. .. versionadded:: 0.5; *wfn* parameter passed explicitly. :returns: None. :type wfn: :py:class:`~psi4.core.Wavefunction`; :param wfn: set of molecule, basis, orbitals from which to generate cube files. :examples:. >>> # [1] Cube files for all orbitals; >>> E, wfn = energy('b3lyp', return_wfn=True); >>> cubeprop(wfn). >>> # [2] Cube files for density (alpha, beta, total, sp",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/p4util/util.html:1760,energy,energy,1760,psi4manual/1.6.x/_modules/psi4/driver/p4util/util.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/p4util/util.html,2,['energy'],['energy']
Energy Efficiency,"ORBS_V4¶. Do use MP2 natural orbital approximations for the \(v^4\) block of two-electron integrals in the evaluation of CCD T2 amplitudes? Recommended true for all SAPT computations. Type: boolean; Default: true. OCC_TOLERANCE¶. Minimum occupation (eigenvalues of the MP2 OPDM) below which virtual natural orbitals are discarded for in each of the above three truncations. Type: conv double; Default: 1.0e-6. Charge-Transfer in SAPT¶; It is possible to obtain the stabilization energy of a complex due to; charge-transfer effects from a SAPT computation. The charge-transfer energy; can be computed with the SAPT module as described by Stone; and Misquitta [Misquitta:2009:201].; Charge-transfer energies can be obtained from the following calls to the; energy function.; energy('sapt0-ct'); energy('sapt2-ct'); energy('sapt2+-ct'); energy('sapt2+(3)-ct'); energy('sapt2+3-ct'); energy('sapt2+(ccd)-ct'); energy('sapt2+(3)(ccd)-ct'); energy('sapt2+3(ccd)-ct'). For now, charge transfer computations are not available with open-shell SAPT0.; A SAPT charge-transfer analysis will perform 5 HF computations: the dimer; in the dimer basis, monomer A in the dimer basis, monomer B in the dimer; basis, monomer A in the monomer A basis, and monomer B in the monomer B; basis. Next, it performs two SAPT computations, one in the dimer basis and; one in the monomer basis. Finally, it will print a summary of the; charge-transfer results:; SAPT Charge Transfer Analysis; ------------------------------------------------------------------------------------------------; SAPT Induction (Dimer Basis) -2.0970 [mEh] -1.3159 [kcal/mol] -5.5057 [kJ/mol]; SAPT Induction (Monomer Basis) -1.1396 [mEh] -0.7151 [kcal/mol] -2.9920 [kJ/mol]; SAPT Charge Transfer -0.9574 [mEh] -0.6008 [kcal/mol] -2.5137 [kJ/mol]. These results are for the water dimer geometry shown above computed with; SAPT0/aug-cc-pVDZ. Monomer-Centered Basis Computations¶; The charge-transfer analysis above is carried out by taking the; differenc",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/sapt-1.html:30816,charge,charge,30816,psi4manual/1.4.0/sapt-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/sapt-1.html,9,['charge'],['charge']
Energy Efficiency,"ORDER_SAVE', 1); elif (name.lower() == 'mp'):; PsiMod.set_global_option('WFN', 'DETCI'); PsiMod.set_global_option('MPN', 'TRUE'). level = kwargs['level']; maxnvect = (level + 1) / 2 + (level + 1) % 2; PsiMod.set_global_option('MAX_NUM_VECS', maxnvect); if ((level + 1) % 2):; PsiMod.set_global_option('MPN_ORDER_SAVE', 2); else:; PsiMod.set_global_option('MPN_ORDER_SAVE', 1); elif (name.lower() == 'fci'):; PsiMod.set_global_option('WFN', 'DETCI'); PsiMod.set_global_option('FCI', 'TRUE'); elif (name.lower() == 'cisd'):; PsiMod.set_global_option('WFN', 'DETCI'); PsiMod.set_global_option('EX_LEVEL', 2); elif (name.lower() == 'cisdt'):; PsiMod.set_global_option('WFN', 'DETCI'); PsiMod.set_global_option('EX_LEVEL', 3); elif (name.lower() == 'cisdtq'):; PsiMod.set_global_option('WFN', 'DETCI'); PsiMod.set_global_option('EX_LEVEL', 4); elif (name.lower() == 'ci'):; PsiMod.set_global_option('WFN', 'DETCI'); level = kwargs['level']; PsiMod.set_global_option('EX_LEVEL', level); # Call a plain energy('detci') and have full control over options; elif(name.lower() == 'detci'):; pass. # Bypass routine scf if user did something special to get it to converge; if not (('bypass_scf' in kwargs) and input.yes.match(str(kwargs['bypass_scf']))):; run_scf('scf', **kwargs). # If the scf type is DF, then the AO integrals were never generated; if PsiMod.get_local_option('scf', 'scf_type') == 'DF':; mints = PsiMod.MintsHelper(); mints.integrals(). PsiMod.transqt2(); returnvalue = PsiMod.detci(). if (name.lower() != 'detci'):; PsiMod.set_global_option('WFN', 'SCF'); PsiMod.revoke_global_option_changed('WFN'); PsiMod.set_global_option('MPN', 'FALSE'); PsiMod.revoke_global_option_changed('MPN'); PsiMod.set_global_option('MAX_NUM_VECS', 12); PsiMod.revoke_global_option_changed('MAX_NUM_VECS'); PsiMod.set_global_option('MPN_ORDER_SAVE', 0); PsiMod.revoke_global_option_changed('MPN_ORDER_SAVE'); PsiMod.set_global_option('FCI', 'FALSE'); PsiMod.revoke_global_option_changed('FCI'); PsiMod.set_global_opt",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/_modules/proc.html:20051,energy,energy,20051,psi4manual/4.0b2/_modules/proc.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/proc.html,2,['energy'],['energy']
Energy Efficiency,ORRECTED INTERACTION ENERGY THROUGH 2-BODY | |em| 1 | when nocp in bsse_type & max_nbody>=2 | 2-body total data less 1-body total data for cumulative IE; inputs are total energies w/o cp treatment |; +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+; | |em| NOCP-CORRECTED INTERACTION ENERGY THROUGH {nb}-BODY | |em| 1 | when nocp in bsse_type | {max_nbody}-body total data less 1-body total data for cumulative IE; inputs are total energies w/o cp treatment |; +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+; | |em| NOCP-CORRECTED INTERACTION ENERGY | |em| 1 | when nocp in bsse_type | best available interaction energy without cp treatment: NOCP-CORRECTED INTERACTION ENERGY THROUGH {max_nbody}-BODY |; +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+; | |em| NOCP-CORRECTED 2-BODY CONTRIBUTION TO ENERGY | |em| 1 | when nocp in bsse_type & max_nbody>=2 | 2-body total data less (2-1)-body total data for partial IE; inputs are total energies w/o cp treatment |; +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+; | |em| NOCP-CORRECTED {nb}-BODY CONTRIBUTION TO ENERGY | |em| 1 | when nocp in bs,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver_nbody.html:50932,ENERGY,ENERGY,50932,psi4manual/1.6.x/_modules/psi4/driver/driver_nbody.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver_nbody.html,5,['ENERGY'],['ENERGY']
Energy Efficiency,"ORRECTION ENERGY¶; The dispersion correction [E_h] appended to an underlying functional; when a DFT-D method is requested. Quantity \(E_{\text{-D}}\); in Eqs. (4) and (1).; When dispersion parameters are untweaked for a functional and dispersion; level, labeled QCVariable also defined. DOUBLE-HYBRID CORRECTION ENERGY¶; The scaled MP2 correlation energy correction [E_h] appended to an; underlying functional when a DH-DFT method is requested.; Quantity \(E_{\text{DH}}\) in Eq. (1). DMA DISTRIBUTED MULTIPOLES¶; Distributed multipoles in units given by GDMA_MULTIPOLE_UNITS; with the row index corresponding to the site and the column index; referencing the multipole component. Both indices are zero based,; and the Qlm components of the multipoles are ordered as Q00, Q10,; Q11c, Q11s, Q20, Q21c, Q21s, Q22c, Q22s, etc. DMA TOTAL MULTIPOLES¶; Distributed multipoles as a single row, whose columns are the total; multipoles, translated to GDMA_ORIGIN, and summed. DMRG-SCF TOTAL ENERGY¶; The total DMRG total electonic energy [E_h]. Not unique because oribital spaces vary. DMRG-CASPT2 TOTAL ENERGY¶; The total DMRG plus CASPT2 total electonic energy [E_h] . Not unique because orbital spaces vary. EFP DISP ENERGY¶. EFP ELST ENERGY¶. EFP EXCH ENERGY¶. EFP IND ENERGY¶; Respectively, the dispersion, electrostatics, exchange, and induction; components of the total electronic interaction energy [E_h] for EFP/EFP; computations. The sum of these four components yields; EFP TOTAL ENERGY. EFP TOTAL ENERGY¶; The total electronic interaction energy [E_h] for EFP/EFP computations. EFP TORQUE¶; The torque, not gradient for EFP/EFP computations. ENTHALPY¶; Total enthalpy H [E_h] at given temperature. ENTHALPY CORRECTION¶; Sum of electronic, translational, rotational, and vibrational corrections [E_h] to the enthalpy at given temperature. ESP AT CENTER n¶; Property of electrostatic potential [E_h / e] at location, usually atom center, n. FCI TOTAL ENERGY¶. FCI CORRELATION ENERGY¶; The total elect",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/glossary_psivariables.html:30662,energy,energy,30662,psi4manual/1.7.x/glossary_psivariables.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/glossary_psivariables.html,4,['energy'],['energy']
Energy Efficiency,"ORRELATION ENERGY"",cemp3); elif ( lowername == 'fno-mp3' ):; emp3 = psi4.get_variable(""MP3 TOTAL ENERGY""); cemp3 = psi4.get_variable(""MP3 CORRELATION ENERGY""); psi4.set_variable(""CURRENT ENERGY"",emp3); psi4.set_variable(""CURRENT CORRELATION ENERGY"",cemp3); elif ( lowername == 'mp4(sdq)'):; emp4sdq = psi4.get_variable(""MP4(SDQ) TOTAL ENERGY""); cemp4sdq = psi4.get_variable(""MP4(SDQ) CORRELATION ENERGY""); psi4.set_variable(""CURRENT ENERGY"",emp4sdq); psi4.set_variable(""CURRENT CORRELATION ENERGY"",cemp4sdq); elif ( lowername == 'fno-mp4(sdq)'):; emp4sdq = psi4.get_variable(""MP4(SDQ) TOTAL ENERGY""); cemp4sdq = psi4.get_variable(""MP4(SDQ) CORRELATION ENERGY""); psi4.set_variable(""CURRENT ENERGY"",emp4sdq); psi4.set_variable(""CURRENT CORRELATION ENERGY"",cemp4sdq); elif ( lowername == 'fno-mp4'):; emp4 = psi4.get_variable(""MP4 TOTAL ENERGY""); cemp4 = psi4.get_variable(""MP4 CORRELATION ENERGY""); psi4.set_variable(""CURRENT ENERGY"",emp4); psi4.set_variable(""CURRENT CORRELATION ENERGY"",cemp4); elif (lowername == 'fnocc-mp') and (level == 4):; emp4 = psi4.get_variable(""MP4 TOTAL ENERGY""); cemp4 = psi4.get_variable(""MP4 CORRELATION ENERGY""); psi4.set_variable(""CURRENT ENERGY"",emp4); psi4.set_variable(""CURRENT CORRELATION ENERGY"",cemp4). # restore options; optstash.restore(). return psi4.get_variable(""CURRENT ENERGY""). [docs]def run_cepa(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a cepa-like calculation. >>> energy('cepa(1)'). """"""; lowername = name.lower(); uppername = name.upper(); kwargs = p4util.kwargs_lower(kwargs). # save user options; optstash = p4util.OptionsState(; ['TRANSQT2', 'WFN'],; ['FNOCC', 'NAT_ORBS'],; ['FNOCC', 'RUN_CEPA'],; ['FNOCC', 'USE_DF_INTS'],; ['FNOCC', 'CEPA_NO_SINGLES']). psi4.set_local_option('FNOCC','RUN_CEPA', True); psi4.set_local_option('FNOCC','USE_DF_INTS', False). # what type of cepa?; cepa_level = uppername; if (lowername == 'cepa(2)'):; raise ValidationError(""Error: %s not implemented\n"" % lowername); if (lowername ==",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/proc.html:71799,ENERGY,ENERGY,71799,psi4manual/4.0b5/_modules/proc.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/proc.html,1,['ENERGY'],['ENERGY']
Energy Efficiency,ORRELATION ENERGY; AQCC OPPOSITE-SPIN CORRELATION ENERGY; AQCC SAME-SPIN CORRELATION ENERGY; AQCC TOTAL ENERGY; CC ALPHA-ALPHA PAIR ENERGIES (array); CC ALPHA-BETA PAIR ENERGIES (array); CC D1 DIAGNOSTIC; CC SINGLET PAIR ENERGIES (array); CC T1 DIAGNOSTIC; CC TRIPLET PAIR ENERGIES (array); CCSD ALPHA-ALPHA PAIR ENERGIES (array); CCSD ALPHA-BETA PAIR ENERGIES (array); CCSD CORRELATION ENERGY; CCSD DOUBLES ENERGY; CCSD ITERATIONS; CCSD OPPOSITE-SPIN CORRELATION ENERGY; CCSD SAME-SPIN CORRELATION ENERGY; CCSD SINGLES ENERGY; CCSD SINGLET PAIR ENERGIES (array); CCSD TOTAL ENERGY; CCSD TRIPLET PAIR ENERGIES (array); CCSD(T) CORRELATION ENERGY; CCSD(T) TOTAL ENERGY; CEPA(0) CORRELATION ENERGY; CEPA(0) DOUBLES ENERGY; CEPA(0) OPPOSITE-SPIN CORRELATION ENERGY; CEPA(0) SAME-SPIN CORRELATION ENERGY; CEPA(0) SINGLES ENERGY; CEPA(0) TOTAL ENERGY; CEPA(1) CORRELATION ENERGY; CEPA(1) OPPOSITE-SPIN CORRELATION ENERGY; CEPA(1) SAME-SPIN CORRELATION ENERGY; CEPA(1) TOTAL ENERGY; CEPA(2) CORRELATION ENERGY; CEPA(2) OPPOSITE-SPIN CORRELATION ENERGY; CEPA(2) SAME-SPIN CORRELATION ENERGY; CEPA(2) TOTAL ENERGY; CEPA(3) CORRELATION ENERGY; CEPA(3) OPPOSITE-SPIN CORRELATION ENERGY; CEPA(3) SAME-SPIN CORRELATION ENERGY; CEPA(3) TOTAL ENERGY; CISD CORRELATION ENERGY; CISD OPPOSITE-SPIN CORRELATION ENERGY; CISD SAME-SPIN CORRELATION ENERGY; CISD TOTAL ENERGY; CURRENT CORRELATION ENERGY; CURRENT ENERGY; LCCD CORRELATION ENERGY; LCCD DOUBLES ENERGY; LCCD OPPOSITE-SPIN CORRELATION ENERGY; LCCD SAME-SPIN CORRELATION ENERGY; LCCD SINGLES ENERGY; LCCD TOTAL ENERGY; LCCSD CORRELATION ENERGY; LCCSD DOUBLES ENERGY; LCCSD OPPOSITE-SPIN CORRELATION ENERGY; LCCSD SAME-SPIN CORRELATION ENERGY; LCCSD SINGLES ENERGY; LCCSD TOTAL ENERGY; MP2 ALPHA-ALPHA PAIR ENERGIES (array); MP2 ALPHA-BETA PAIR ENERGIES (array); MP2 CORRELATION ENERGY; MP2 DOUBLES ENERGY; MP2 OPPOSITE-SPIN CORRELATION ENERGY; MP2 SAME-SPIN CORRELATION ENERGY; MP2 SINGLES ENERGY; MP2 SINGLET PAIR ENERGIES (array); MP2 TOTAL ENERGY; MP2 TRIPLE,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/autodir_psivariables/module__fnocc.html:1274,ENERGY,ENERGY,1274,psi4manual/1.6.x/autodir_psivariables/module__fnocc.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/autodir_psivariables/module__fnocc.html,1,['ENERGY'],['ENERGY']
Energy Efficiency,"ORRELATION ENERGY¶. CC(n-1)(n)_L TOTAL ENERGY¶. CC(n-1)(n)_L CORRELATION ENERGY¶; The total electronic energy [Eh] and correlation energy component [Eh]; for the approximate coupled-cluster (CCSD(T)_L, CCSDT(Q)_L,; up to CC(n-1)(n)L level of theory. CCSDT(Q)/A TOTAL ENERGY¶. CCSDT(Q)/A CORRELATION ENERGY¶. CCSDT(Q)/B TOTAL ENERGY¶. CCSDT(Q)/B CORRELATION ENERGY¶; The total electronic energy [Eh] and correlation energy component [Eh]; for the modified CCSDT(Q) level of theory. CEPA(0) DIPOLE¶; Dipole array [e a0] for the coupled electron pair approximation variant 0 level of theory, (3,). CEPA(0) QUADRUPOLE¶; Redundant quadrupole array [e a0^2] for the coupled electron pair approximation variant 0 level of theory, (3, 3). CEPA(0) TOTAL ENERGY¶. CEPA(0) CORRELATION ENERGY¶. CEPA(1) TOTAL ENERGY¶. CEPA(1) CORRELATION ENERGY¶. CEPA(2) TOTAL ENERGY¶. CEPA(2) CORRELATION ENERGY¶. CEPA(3) TOTAL ENERGY¶. CEPA(3) CORRELATION ENERGY¶; The total electronic energy [Eh] and correlation energy component [Eh]; for the requested variant of coupled electron pair approximation level of theory. CFOUR ERROR CODE¶; The non-zero return value from a Cfour execution. CI DIPOLE¶; Dipole array [e a0] for the requested configuration interaction level of theory, (3,). CI QUADRUPOLE¶; Redundant quadrupole array [e a0^2] for the requested configuration interaction level of theory, (3, 3). CI ROOT n -> ROOT m DIPOLE¶; Transition dipole array [e a0] between roots n and m for the requested configuration interaction level of theory, (3,). CI ROOT n -> ROOT m QUADRUPOLE¶; Redundant transition quadrupole array [e a0^2] between roots n and m for the requested configuration interaction level of theory, (3, 3). CI ROOT n DIPOLE¶; Dipole array [e a0] for the requested configuration interaction level of theory and root n, (3,). CI ROOT n QUADRUPOLE¶; Redundant quadrupole array [e a0^2] for the requested configuration interaction level of theory and root n, (3, 3). CI ROOT n TOTAL ENERGY¶. CI ROOT n CORRELAT",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/glossary_psivariables.html:20803,energy,energy,20803,psi4manual/1.6.x/glossary_psivariables.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/glossary_psivariables.html,2,['energy'],['energy']
Energy Efficiency,"ORRELATIONENERGY>` . >>> energy('mp2.5'). """"""; lowername = name.lower(); kwargs = kwargs_lower(kwargs). # Run detci calculation and collect conventional quantities; energy('mp3', **kwargs); e_scf = PsiMod.get_variable('SCF TOTAL ENERGY'); ce_mp2 = PsiMod.get_variable('MP2 CORRELATION ENERGY'); ce_mp3 = PsiMod.get_variable('MP3 CORRELATION ENERGY'); e_mp2 = e_scf + ce_mp2; e_mp3 = e_scf + ce_mp3. # Compute quantities particular to MP2.5; ce_mp25 = 0.5 * (ce_mp2 + ce_mp3); e_mp25 = e_scf + ce_mp25; PsiMod.set_variable('MP2.5 CORRELATION ENERGY', ce_mp25); PsiMod.set_variable('MP2.5 TOTAL ENERGY', e_mp25); PsiMod.set_variable('CURRENT CORRELATION ENERGY', ce_mp25); PsiMod.set_variable('CURRENT ENERGY', e_mp25). # build string of title banner and print results; banners = ''; banners += """"""PsiMod.print_out('\\n')\n""""""; banners += """"""banner(' MP2.5 ')\n""""""; banners += """"""PsiMod.print_out('\\n')\n\n""""""; exec banners. tables = ''; tables += """""" SCF total energy: %16.8f\n"""""" % (e_scf); tables += """""" MP2 total energy: %16.8f\n"""""" % (e_mp2); tables += """""" MP2.5 total energy: %16.8f\n"""""" % (e_mp25); tables += """""" MP3 total energy: %16.8f\n\n"""""" % (e_mp3); tables += """""" MP2 correlation energy: %16.8f\n"""""" % (ce_mp2); tables += """""" MP2.5 correlation energy: %16.8f\n"""""" % (ce_mp25); tables += """""" MP3 correlation energy: %16.8f\n"""""" % (ce_mp3); PsiMod.print_out(tables). return e_mp25. # A direct translation of a plugin input file into a function call. Function calls are the only; # way to call plugins in sow/reap mode for db(), opt(), etc. This isn't best practices; # but is an example of what to do for a more complicated procedure where different options ; # are set for different qc steps.; [docs]def run_plugin_omega(name, **kwargs):; r""""""Function encoding sequence of PSI module and plugin calls, as well; as typical options, to access Rob Parrish's omega plugin. >>> energy('plugin_omega'). """"""; lowername = name.lower(); kwargs = kwargs_lower(kwargs). plugfile = PsiMod.Process.envir",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/_modules/aliases.html:3549,energy,energy,3549,psi4manual/4.0b2/_modules/aliases.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/aliases.html,2,['energy'],['energy']
Energy Efficiency,"ORT); CCSORT — Convert ROHF MOs to semicanonical MOs. Type: boolean; Default: true. SEMICANONICAL (CCTRIPLES); CCTRIPLES — Convert ROHF MOs to semicanonical MOs. Type: boolean; Default: true. SEMICANONICAL (TRANSQT2); TRANSQT2 — Convert ROHF MOs to semicanonical MOs. Type: boolean; Default: true. SF_RESTRICT (DETCI); DETCI (Expert) — Do eliminate determinants not valid for spin-complete spin-flip CI’s? [see J. S. Sears et al, J. Chem. Phys. 118, 9084-9094 (2003)]. Type: boolean; Default: false. SIGMA_OVERLAP (DETCI); DETCI (Expert) — Do print the sigma overlap matrix? Not generally useful. Type: boolean; Default: false. SINGLES_PRINT (CCEOM); CCEOM — Do print information on the iterative solution to the single-excitation EOM-CC problem used as a guess to full EOM-CC?. Type: boolean; Default: false. SMALL_CUTOFF (PSIMRCC); PSIMRCC —. Type: integer; Default: 0. SO_S_FILE (TRANSQT); TRANSQT — SO basis overlap matrix file. Type: integer; Default: PSIF_OEI. SO_T_FILE (TRANSQT); TRANSQT — SO basis kinetic energy matrix file. Type: integer; Default: PSIF_OEI. SO_TEI_FILE (TRANSQT); TRANSQT — SO basis two-electron integrals file. Type: integer; Default: PSIF_SO_TEI. SO_V_FILE (TRANSQT); TRANSQT — SO basis potential energy matrix file. Type: integer; Default: PSIF_OEI. SOCC (GLOBALS); GLOBALS — An array containing the number of singly-occupied orbitals per irrep (in Cotton order). The value of DOCC should also be set. Type: array; Default: No Default. SOCC (MCSCF); MCSCF — The number of singly occupied orbitals, per irrep. Type: array; Default: No Default. SOLVER_CONVERGENCE (CPHF); CPHF — Solver convergence threshold (max 2-norm). Type: conv double; Default: 1.0e-6. SOLVER_EXACT_DIAGONAL (CPHF); CPHF — Solver exact diagonal or eigenvalue difference?. Type: boolean; Default: false. SOLVER_MAX_SUBSPACE (CPHF); CPHF — DL Solver maximum number of subspace vectors. Type: integer; Default: 6. SOLVER_MAXITER (CPHF); CPHF — Solver maximum iterations. Type: integer; Default: 100. SO",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/autodoc_glossary_options_c-1.html:120780,energy,energy,120780,psi4manual/4.0b4/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/autodoc_glossary_options_c-1.html,4,['energy'],['energy']
Energy Efficiency,"ORT); CCSORT — Convert ROHF MOs to semicanonical MOs. Type: boolean; Default: true. SEMICANONICAL (CCTRIPLES); CCTRIPLES — Convert ROHF MOs to semicanonical MOs. Type: boolean; Default: true. SEMICANONICAL (TRANSQT2); TRANSQT2 — Convert ROHF MOs to semicanonical MOs. Type: boolean; Default: true. SF_RESTRICT (DETCI); DETCI (Expert) — Do eliminate determinants not valid for spin-complete spin-flip CI’s? [see J. S. Sears et al, J. Chem. Phys. 118, 9084-9094 (2003)]. Type: boolean; Default: false. SIGMA_OVERLAP (DETCI); DETCI (Expert) — Do print the sigma overlap matrix? Not generally useful. Type: boolean; Default: false. SINGLES_PRINT (CCEOM); CCEOM — Do print information on the iterative solution to the single-excitation EOM-CC problem used as a guess to full EOM-CC?. Type: boolean; Default: false. SMALL_CUTOFF (PSIMRCC); PSIMRCC —. Type: integer; Default: 0. SO_S_FILE (TRANSQT); TRANSQT — SO basis overlap matrix file. Type: integer; Default: PSIF_OEI. SO_T_FILE (TRANSQT); TRANSQT — SO basis kinetic energy matrix file. Type: integer; Default: PSIF_OEI. SO_TEI_FILE (TRANSQT); TRANSQT — SO basis two-electron integrals file. Type: integer; Default: PSIF_SO_TEI. SO_V_FILE (TRANSQT); TRANSQT — SO basis potential energy matrix file. Type: integer; Default: PSIF_OEI. SOCC (GLOBALS); GLOBALS — An array containing the number of singly-occupied orbitals per irrep (in Cotton order). Type: array; Default: No Default. SOCC (MCSCF); MCSCF — The number of singly occupied orbitals, per irrep. Type: array; Default: No Default. SOLVER_CONVERGENCE (CPHF); CPHF — Solver convergence threshold (max 2-norm). Type: conv double; Default: 1.0e-6. SOLVER_EXACT_DIAGONAL (CPHF); CPHF — Solver exact diagonal or eigenvalue difference?. Type: boolean; Default: false. SOLVER_MAX_SUBSPACE (CPHF); CPHF — DL Solver maximum number of subspace vectors. Type: integer; Default: 6. SOLVER_MAXITER (CPHF); CPHF — Solver maximum iterations. Type: integer; Default: 100. SOLVER_MIN_SUBSPACE (CPHF); CPHF — DL So",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/autodoc_glossary_options_c-1.html:114915,energy,energy,114915,psi4manual/4.0b3/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodoc_glossary_options_c-1.html,2,['energy'],['energy']
Energy Efficiency,"OS-OMP3 cc-pVDZ geometry optimization for the H2O molecule. sapt3; SAPT2+3 aug-cc-pVDZ computation of the water dimer interaction energy, using the aug-cc-pVDZ-JKFIT DF basis for SCF and aug-cc-pVDZ-RI for SAPT. scf5; Test of all different algorithms and reference types for SCF, on singlet and triplet O2, using the cc-pVTZ basis set. pywrap-opt-sowreap; Finite difference optimization, run in sow/reap mode. cc8a; ROHF-CCSD(T) cc-pVDZ frozen-core energy for the state of the CN radical, with Cartesian input. opt1-fd; SCF STO-3G geometry optimzation, with Z-matrix input, by finite-differences. dft-dldf; Dispersionless density functional (dlDF+D) internal match to Psi4 Extensive testing has been done to match supplemental info of Szalewicz et. al., Phys. Rev. Lett., 103, 263201 (2009) and Szalewicz et. al., J. Phys. Chem. Lett., 1, 550-555 (2010). castup1; Test of SAD/Cast-up (mainly not dying due to file weirdness). adc1; ADC/6-31G** on H2O. cc9; UHF-CCSD(T) cc-pVDZ frozen-core energy for the state of the CN radical, with Z-matrix input. pubchem1; Benzene vertical singlet-triplet energy difference computation, using the PubChem database to obtain the initial geometry, at the UHF an ROHF levels of theory. cc44; Test case for some of the PSI4 out-of-core codes. The code is given only 2.0 MB of memory, which is insufficient to hold either the A1 or B2 blocks of an ovvv quantity in-core, but is sufficient to hold at least two copies of an oovv quantity in-core. cc35; CC3(ROHF)/cc-pVDZ H2O geom from Olsen et al., JCP 104, 8007 (1996). cc9a; ROHF-CCSD(T) cc-pVDZ energy for the state of the CN radical, with Z-matrix input. dfmp2-2; Density fitted MP2 energy of H2, using density fitted reference and automatic looping over cc-pVDZ and cc-pVTZ basis sets. Results are tabulated using the built in table functions by using the default options and by specifiying the format. cc1; RHF-CCSD 6-31G** all-electron optimization of the H2O molecule. scf4; RHF cc-pVDZ energy for water, automa",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/autodoc_testsuite-1.html:16277,energy,energy,16277,psi4manual/4.0b3/autodoc_testsuite-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodoc_testsuite-1.html,4,['energy'],['energy']
Energy Efficiency,OTAL ENERGY; CUSTOM SCS-MP2 CORRELATION ENERGY; CUSTOM SCS-MP2 TOTAL ENERGY; CUSTOM SCS-MP2.5 CORRELATION ENERGY; CUSTOM SCS-MP2.5 TOTAL ENERGY; CUSTOM SCS-MP3 CORRELATION ENERGY; CUSTOM SCS-MP3 TOTAL ENERGY; CUSTOM SCS-OLCCD CORRELATION ENERGY; CUSTOM SCS-OLCCD TOTAL ENERGY; CUSTOM SCS-OMP2 CORRELATION ENERGY; CUSTOM SCS-OMP2 TOTAL ENERGY; CUSTOM SCS-OMP3 CORRELATION ENERGY; CUSTOM SCS-OMP3 TOTAL ENERGY; CUSTOM SCS-OREMP2 CORRELATION ENERGY; CUSTOM SCS-OREMP2 TOTAL ENERGY; CUSTOM SCS-REMP2 CORRELATION ENERGY; CUSTOM SCS-REMP2 TOTAL ENERGY; LCCD CORRELATION ENERGY; LCCD DOUBLES ENERGY; LCCD OPPOSITE-SPIN CORRELATION ENERGY; LCCD SAME-SPIN CORRELATION ENERGY; LCCD SINGLES ENERGY; LCCD TOTAL ENERGY; MP2 CORRELATION ENERGY; MP2 DOUBLES ENERGY; MP2 OPPOSITE-SPIN CORRELATION ENERGY; MP2 SAME-SPIN CORRELATION ENERGY; MP2 SINGLES ENERGY; MP2 TOTAL ENERGY; MP2.5 CORRELATION ENERGY; MP2.5 DOUBLES ENERGY; MP2.5 OPPOSITE-SPIN CORRELATION ENERGY; MP2.5 SAME-SPIN CORRELATION ENERGY; MP2.5 SINGLES ENERGY; MP2.5 TOTAL ENERGY; MP3 CORRELATION ENERGY; MP3 DOUBLES ENERGY; MP3 OPPOSITE-SPIN CORRELATION ENERGY; MP3 SAME-SPIN CORRELATION ENERGY; MP3 SINGLES ENERGY; MP3 TOTAL ENERGY; OLCCD CORRELATION ENERGY; OLCCD OPPOSITE-SPIN CORRELATION ENERGY; OLCCD REFERENCE CORRECTION ENERGY; OLCCD SAME-SPIN CORRELATION ENERGY; OLCCD TOTAL ENERGY; OMP2 CORRELATION ENERGY; OMP2 OPPOSITE-SPIN CORRELATION ENERGY; OMP2 REFERENCE CORRECTION ENERGY; OMP2 SAME-SPIN CORRELATION ENERGY; OMP2 TOTAL ENERGY; OMP2.5 CORRELATION ENERGY; OMP2.5 OPPOSITE-SPIN CORRELATION ENERGY; OMP2.5 REFERENCE CORRECTION ENERGY; OMP2.5 SAME-SPIN CORRELATION ENERGY; OMP2.5 TOTAL ENERGY; OMP3 CORRELATION ENERGY; OMP3 OPPOSITE-SPIN CORRELATION ENERGY; OMP3 REFERENCE CORRECTION ENERGY; OMP3 SAME-SPIN CORRELATION ENERGY; OMP3 TOTAL ENERGY; OREMP2 CORRELATION ENERGY; OREMP2 OPPOSITE-SPIN CORRELATION ENERGY; OREMP2 REFERENCE CORRECTION ENERGY; OREMP2 SAME-SPIN CORRELATION ENERGY; OREMP2 TOTAL ENERGY; REMP2 CORRELATION ENERGY; REMP2 DO,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/autodir_psivariables/module__occ.html:1332,ENERGY,ENERGY,1332,psi4manual/1.7.x/autodir_psivariables/module__occ.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/autodir_psivariables/module__occ.html,4,['ENERGY'],['ENERGY']
Energy Efficiency,"OUBLE, self.comm); return masses. # Respond to the <ELEMENTS command; def send_elements(self):; """""" Send the atomic number of each nucleus through MDI. :returns: *elements* Element of each atom; """"""; natom = self.molecule.natom(); elements = [self.molecule.true_atomic_number(iatom) for iatom in range(natom)]; MDI_Send(elements, natom, MDI_INT, self.comm); return elements. # Respond to the <ENERGY command; def send_energy(self):; """""" Send the total energy through MDI. :returns: *energy* Energy of the system; """"""; self.run_scf(); MDI_Send(self.energy, 1, MDI_DOUBLE, self.comm); return self.energy. # Respond to the <FORCES command; def send_forces(self):; """""" Send the nuclear forces through MDI. :returns: *forces* Atomic forces; """"""; force_matrix = psi4.driver.gradient(self.scf_method, **self.kwargs); forces = force_matrix.np.ravel(); MDI_Send(forces, len(forces), MDI_DOUBLE, self.comm); return forces. # Respond to the >CHARGES command; def recv_charges(self, charges=None):; """""" Receive a set of nuclear charges through MDI and assign them to the atoms in the current molecule. Arguments:; charges: New nuclear charges. If None, receive through MDI.; """"""; natom = self.molecule.natom(); if charges is None:; charges = MDI_Recv(natom, MDI_DOUBLE, self.comm). # Assign the charge of all atoms, taking care to avoid ghost atoms; jatom = 0; for iatom in range(natom):; while self.molecule.fZ(jatom) == 0 and jatom < self.molecule.nallatom():; jatom = jatom + 1; if jatom >= self.molecule.nallatom():; raise Exception('Unexpected number of ghost atoms when receiving masses'); self.molecule.set_nuclear_charge(iatom, charges[jatom]); jatom = jatom + 1. # Respond to the >COORDS command; def recv_coords(self, coords=None):; """""" Receive a set of nuclear coordinates through MDI and assign them to the atoms in the current molecule. Arguments:; coords: New nuclear coordinates. If None, receive through MDI.; """"""; natom = self.molecule.natom(); if coords is None:; coords = MDI_Recv(3 * natom, MD",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/mdi_engine.html:6561,charge,charges,6561,psi4manual/1.4.0/_modules/psi4/driver/mdi_engine.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/mdi_engine.html,35,"['CHARGE', 'charge']","['CHARGES', 'charges']"
Energy Efficiency,"OUR program [manual]. c4-scf; Hartree–Fock (HF). c4-mp2; 2nd-order Møller–Plesset perturbation theory (non-density-fitting) (MP2). c4-mp3; 3rd-order Møller–Plesset perturbation theory (MP3). c4-mp4(sdq); 4th-order MP perturbation theory (MP4) less triples. c4-mp4; full MP4. c4-cc2; approximate coupled cluster singles and doubles (CC2). c4-ccsd; coupled cluster singles and doubles (CCSD). c4-cc3; approximate CC singles, doubles, and triples (CC3). c4-ccsd(t); CCSD with perturbative triples (CCSD(T)). c4-ccsdt; coupled cluster singles, doubles, and triples (CCSDT). cfour; expert full control over cfour program. Examples:. >>> # [1] Analytic hf optimization; >>> optimize('hf'). >>> # [2] Finite difference mp5 optimization with gradient; >>> # printed to output file; >>> e, wfn = opt('mp5', return_wfn='yes'); >>> wfn.gradient().print_out(). >>> # [3] Can automatically perform complete basis set extrapolations; >>> optimize('MP2/cc-pV([D,T]+d)Z'). >>> # [4] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> optimize(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). >>> # [5] Get info like geometry, gradient, energy back after an; >>> # optimization fails. Note that the energy and gradient; >>> # correspond to the last optimization cycle, whereas the; >>> # geometry (by default) is the anticipated *next* optimization step.; >>> try:; >>> optimize('hf/cc-pvtz'); >>> except psi4.OptimizationConvergenceError as ex:; >>> next_geom_coords_as_numpy_array = np.asarray(ex.wfn.molecule().geometry()). table of contents. opt; opt(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. PSI4 API: Linking C++ and Python; opt. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/api/psi4.driver.opt.html:17052,energy,energy,17052,psi4manual/master/api/psi4.driver.opt.html,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.driver.opt.html,4,['energy'],['energy']
Energy Efficiency,"OUR — This keyword determines which action is taken by the linear response program. ON (=1) the full effective Hamiltonian is calculated and written to disk; OFF (=0) the “lambda” linear response equations are solved. Type: boolean; Default: false. CFOUR_HFSTABILITY (CFOUR); CFOUR — Control analysis of the stability of RHF, ROHF and UHF wavefunctions, as well as a possible search for a lower SCF solution. There are three possible options for this keyword. OFF (=0) does nothing, while ON (=1) performs a stability analysis and returns the number of negative eigenvalues in the orbital rotation Hessian. A third option, FOLLOW (=2) performs the stability analysis and then proceeds to rotate the SCF orbitals in the direction of a particular negative eigenvalue of the orbital rotation Hessian (see the explanation of keyword CFOUR_ROT_EVEC), after which the SCF is rerun. Type: string; Possible Values: OFF, ON, FOLLOW; Default: OFF. CFOUR_INCORE (CFOUR); CFOUR — This keyword can be used to significantly reduce disk i/o, and should be implemented very soon. The following options are available: OFF (= 0), no special algorithms are used (the default case); ALL (=1) all quantities except the \(\langle ab\vert\vert cd\rangle\) molecular integral lists are held in core; PARTIAL (= 2), the T2 and T1 vectors are held in core throughout the calculation; (=4) all quantities except the \(\langle ab\vert\vert cd\rangle\) and \(\langle ab\vert\vert ci\rangle\) integrals are held in core; (=5) \(\langle ij\vert\vert kl\rangle\) and \(\langle ij\vert\vert ka\rangle\) and two-index quantities are held in core; (=6) all direct access files (MOINTS, GAMLAM, etc.) are held in core. At present, these options have been implemented only in the energy code xvcc and the excitation energy code xvee. (Default: 0). Type: string; Possible Values: OFF, ALL, PARTIAL; Default: OFF. CFOUR_INPUT_MRCC (CFOUR); CFOUR — Specifies whether an input for mrcc is written (ON, =0) or not (OFF, =1) if CFOUR_CC_PROGRA",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/autodoc_glossary_options_c-1.html:51730,reduce,reduce,51730,psi4manual/1.2.1/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/autodoc_glossary_options_c-1.html,6,['reduce'],['reduce']
Energy Efficiency,"OUR — This keyword determines which action is taken by the linear response program. ON (=1) the full effective Hamiltonian is calculated and written to disk; OFF (=0) the “lambda” linear response equations are solved. Type: boolean; Default: false. CFOUR_HFSTABILITY (CFOUR); CFOUR — Control analysis of the stability of RHF, ROHF and UHF wavefunctions, as well as a possible search for a lower SCF solution. There are three possible options for this keyword. OFF (=0) does nothing, while ON (=1) performs a stability analysis and returns the number of negative eigenvalues in the orbital rotation Hessian. A third option, FOLLOW (=2) performs the stability analysis and then proceeds to rotate the SCF orbitals in the direction of a particular negative eigenvalue of the orbital rotation Hessian (see the explanation of keyword CFOUR_ROT_EVEC), after which the SCF is rerun. Type: string; Possible Values: OFF, ON, FOLLOW; Default: OFF. CFOUR_INCORE (CFOUR); CFOUR — This keyword can be used to significantly reduce disk i/o, and should be implemented very soon. The following options are available: OFF (= 0), no special algorithms are used (the default case); ALL (=1) all quantities except the molecular integral lists are held in core; PARTIAL (= 2), the T2 and T1 vectors are held in core throughout the calculation; (=4) all quantities except the and integrals are held in core; (=5) and and two-index quantities are held in core; (=6) all direct access files (MOINTS, GAMLAM, etc.) are held in core. At present, these options have been implemented only in the energy code xvcc and the excitation energy code xvee. (Default: 0). Type: string; Possible Values: OFF, ALL, PARTIAL; Default: OFF. CFOUR_INPUT_MRCC (CFOUR); CFOUR — Specifies whether an input for mrcc is written (ON, =0) or not (OFF, =1) if CFOUR_CC_PROGRAM =EXTERNAL has been specified. Type: boolean; Default: true. CFOUR_INTEGRALS (CFOUR); CFOUR — This keyword defines what type of integral input will be written by xjoda. VMOL ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_glossary_options_c-1.html:51584,reduce,reduce,51584,psi4manual/1.0.0/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_glossary_options_c-1.html,2,['reduce'],['reduce']
Energy Efficiency,"OUR). CFOUR_RELATIVISTIC (CFOUR). CFOUR_RELAX_DENS (CFOUR). CFOUR_RES_RAMAN (CFOUR). CFOUR_RESTART_CC (CFOUR). CFOUR_ROT_EVEC (CFOUR). CFOUR_SAVE_INTS (CFOUR). CFOUR_SCALE_ON (CFOUR). CFOUR_SCF_CONV (CFOUR). CFOUR_SCF_DAMPING (CFOUR). CFOUR_SCF_EXPORDER (CFOUR). CFOUR_SCF_EXPSTART (CFOUR). CFOUR_SCF_EXTRAPOLATION (CFOUR). CFOUR_SCF_MAXCYC (CFOUR). CFOUR_SD_FIELD (CFOUR). CFOUR_SPHERICAL (CFOUR). CFOUR_SPIN_FLIP (CFOUR). CFOUR_SPIN_ORBIT (CFOUR). CFOUR_SPIN_SCAL (CFOUR). CFOUR_SPINROTATION (CFOUR). CFOUR_SUBGROUP (CFOUR). CFOUR_SYM_CHECK (CFOUR). CFOUR_SYMMETRY (CFOUR). CFOUR_T3_EXTRAPOL (CFOUR). CFOUR_TAMP_SUM (CFOUR). CFOUR_THERMOCHEMISTRY (CFOUR). CFOUR_TRANS_INV (CFOUR). CFOUR_TREAT_PERT (CFOUR). CFOUR_UIJ_THRESHOLD (CFOUR). CFOUR_UNITS (CFOUR). CFOUR_UPDATE_HESSIAN (CFOUR). CFOUR_VIBRATION (CFOUR). CFOUR_VTRAN (CFOUR). CFOUR_XFIELD (CFOUR). CFOUR_XFORM_TOL (CFOUR). CFOUR_YFIELD (CFOUR). CFOUR_ZFIELD (CFOUR). CFOURERRORCODE. change_file_namespace() psi4.core.IO method, [1], [2]. charge. ; molecule. charge() psi4.core.Molecule method, [1], [2]. CheMPS2. CHOLESKY (DFOCC). cholesky_factorize() psi4.core.Matrix method, [1], [2]. CHOLESKY_TOLERANCE (DFOCC). (FNOCC). (SCF). CI. arbitrary-order coupled-cluster theory. arbitrary-order perturbation theory. basic-keywords. theory. CI_DIIS (MCSCF). CI_FILE_START (DETCI). CI_MAXITER (DETCI). ci_nat_orbs() psi4.core.CIWavefunction method, [1], [2]. CI_NUM_THREADS (DETCI). CI_TYPE (GLOBALS). CIBLKS_PRINT (DETCI). CICORRELATIONENERGY. CIDIPOLEX. CIDIPOLEY. CIDIPOLEZ. CInCORRELATIONENERGY. CInTOTALENERGY. CIQUADRUPOLEXX. CIQUADRUPOLEXY. CIQUADRUPOLEXZ. CIQUADRUPOLEYY. CIQUADRUPOLEYZ. CIQUADRUPOLEZZ. CIROOTn->ROOTmDIPOLEX. CIROOTn->ROOTmDIPOLEY. CIROOTn->ROOTmDIPOLEZ. CIROOTn->ROOTmQUADRUPOLEXX. CIROOTn->ROOTmQUADRUPOLEXY. CIROOTn->ROOTmQUADRUPOLEXZ. CIROOTn->ROOTmQUADRUPOLEYY. CIROOTn->ROOTmQUADRUPOLEYZ. CIROOTn->ROOTmQUADRUPOLEZZ. CIROOTnCORRELATIONENERGY. CIROOTnDIPOLEX. CIROOTnDIPOLEY. CIROOTnDIPOLEZ. CIROOTnQUADRUPOLEXX. CIR",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/genindex-1.html:20873,charge,charge,20873,psi4manual/1.1.0/genindex-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/genindex-1.html,2,['charge'],['charge']
Energy Efficiency,OUR). CFOUR_SCF_EXPORDER (CFOUR). CFOUR_SCF_EXPSTART (CFOUR). CFOUR_SCF_EXTRAPOLATION (CFOUR). CFOUR_SCF_MAXCYC (CFOUR). CFOUR_SD_FIELD (CFOUR). CFOUR_SPHERICAL (CFOUR). CFOUR_SPIN_FLIP (CFOUR). CFOUR_SPIN_ORBIT (CFOUR). CFOUR_SPIN_SCAL (CFOUR). CFOUR_SPINROTATION (CFOUR). CFOUR_SUBGROUP (CFOUR). CFOUR_SYM_CHECK (CFOUR). CFOUR_SYMMETRY (CFOUR). CFOUR_T3_EXTRAPOL (CFOUR). CFOUR_TAMP_SUM (CFOUR). CFOUR_THERMOCHEMISTRY (CFOUR). CFOUR_TRANS_INV (CFOUR). CFOUR_TREAT_PERT (CFOUR). CFOUR_UIJ_THRESHOLD (CFOUR). CFOUR_UNITS (CFOUR). CFOUR_UPDATE_HESSIAN (CFOUR). CFOUR_VIBRATION (CFOUR). CFOUR_VTRAN (CFOUR). CFOUR_XFIELD (CFOUR). CFOUR_XFORM_TOL (CFOUR). CFOUR_YFIELD (CFOUR). CFOUR_ZFIELD (CFOUR). cg_solver() (in module psi4.driver.p4util). chain_dot() (psi4.core.Matrix method). change_file_namespace() (psi4.core.IO static method). char_table() (psi4.core.PointGroup method). character() (psi4.core.IrreducibleRepresentation method). CharacterTable (class in psi4.core). charge. ; molecule. charge() (psi4.core.Molecule method). check_phases() (psi4.core.HF method). CheMPS2. CHOLESKY (DFOCC). cholesky_factorize() (psi4.core.Matrix method). CHOLESKY_TOLERANCE (DFOCC). (FNOCC). (SCF). CI. arbitrary-order coupled-cluster theory. arbitrary-order perturbation theory. basic-keywords. multi-configurational self-consistent-field. spin multiplicities of higher roots. theory. CI CORRELATION ENERGY. CI DIPOLE. CI QUADRUPOLE. CI ROOT n -> ROOT m DIPOLE. CI ROOT n -> ROOT m QUADRUPOLE. CI ROOT n CORRELATION ENERGY. CI ROOT n DIPOLE. CI ROOT n QUADRUPOLE. CI ROOT n TOTAL ENERGY. CI STATE-AVERAGED CORRELATION ENERGY. CI STATE-AVERAGED TOTAL ENERGY. CI TOTAL ENERGY. CI_DIIS (MCSCF). CI_FILE_START (DETCI). CI_MAXITER (DETCI). ci_nat_orbs() (psi4.core.CIWavefunction method). CI_NUM_THREADS (DETCI). CI_TYPE (GLOBALS). CIBLKS_PRINT (DETCI). CIn CORRELATION ENERGY. CIn TOTAL ENERGY. CISD CORRELATION ENERGY. CISD DIPOLE. CISD DOUBLES ENERGY. CISD OPPOSITE-SPIN CORRELATION ENERGY. CISD QUADRUPOLE. CISD,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/genindex.html:24284,charge,charge,24284,psi4manual/1.9.x/genindex.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/genindex.html,2,['charge'],['charge']
Energy Efficiency,"O_DIIS (DFOCC); DFOCC — Do apply DIIS extrapolation?. Type: boolean; Default: true. DO_DIIS (OCC); OCC — Do apply DIIS extrapolation?. Type: boolean; Default: true. DO_LEVEL_SHIFT (DFOCC); DFOCC — Do apply level shifting?. Type: boolean; Default: true. DO_LEVEL_SHIFT (OCC); OCC — Do apply level shifting?. Type: boolean; Default: true. DO_MBPT_DISP (SAPT); SAPT (Expert) — Do MBPT dispersion correction in SAPT2+, SAPT2+(3) or SAPT2+3, if also doing CCD?. Type: boolean; Default: true. DO_QQR_SIEVE (CPHF); CPHF — Do we do the QQR integral sieve of Maurer et al. When false, just uses * the Schwarz sieve. Type: boolean; Default: false. DO_SCS (DFOCC); DFOCC — Do perform spin-component-scaled OMP2 (SCS-OMP2)? In all computation, SCS-OMP2 energy is computed automatically. However, in order to perform geometry optimizations and frequency computations with SCS-OMP2, one needs to set ‘DO_SCS’ to true. Type: boolean; Default: false. DO_SCS (OCC); OCC — Do perform spin-component-scaled OMP2 (SCS-OMP2)? In all computation, SCS-OMP2 energy is computed automatically. However, in order to perform geometry optimizations and frequency computations with SCS-OMP2, one needs to set ‘DO_SCS’ to true. Type: boolean; Default: false. DO_SINGLETS (CPHF); CPHF — Do singlet states? Default true. Type: boolean; Default: true. DO_SOS (DFOCC); DFOCC — Do perform spin-opposite-scaled OMP2 (SOS-OMP2)? In all computation, SOS-OMP2 energy is computed automatically. However, in order to perform geometry optimizations and frequency computations with SOS-OMP2, one needs to set ‘DO_SOS’ to true. Type: boolean; Default: false. DO_SOS (OCC); OCC — Do perform spin-opposite-scaled OMP2 (SOS-OMP2)? In all computation, SOS-OMP2 energy is computed automatically. However, in order to perform geometry optimizations and frequency computations with SOS-OMP2, one needs to set ‘DO_SOS’ to true. Type: boolean; Default: false. DO_THIRD_ORDER (SAPT); SAPT (Expert) — Do compute third-order corrections?. Type: boolean; Defa",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_glossary_options_c-1.html:111209,energy,energy,111209,psi4manual/1.0.0/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_glossary_options_c-1.html,4,['energy'],['energy']
Energy Efficiency,"Obtaining PSI4; Compiling and Installing from Source; Capabilities and Alternate Implementations; Complete Basis Set; <no title>; CC: Coupled Cluster Theory; Interface to CFOUR by J. Stanton & J. Gauss; <no title>; <no title>; Interface to CheMPS2 by S. Wouters; Code style conventions; Conda Binary Distribution; Interface to CPPE by M. Scheurer; Generation of Cube Files — cubeprop(); Customization: Adding Simple Extensions; Database — database(); DCT: Density Cumulant Theory; Interface to ddx by A. Mikhalev, A. Jha, M. Nottoli and M. F. Herbst; CI: Configuration Interaction; DF-MP2: Density-Fitted 2nd-Order Møller–Plesset Perturbation Theory; DFT: Density Functional Theory; DFT Functionals; Interface to DFTD3 by S. Grimme; DFT-NL; Spectroscopic Constants for Diatomics; Interface to DKH by A. Wolf, M. Reiher, and B. A. Hess; DLPNO-MP2: Domain-Based Local Pair Natural Orbital MP2; Updating the PSI4 Users’ and Programmers’ Manual; Interface to LibECPInt by R. Shaw; Single-Point Energy — energy(); Interface to ERD by N. Flocke and V. Lotrich; Installation and Runtime Configuration; External API Objects; Interface to programs through FCHK files — fchk(); F/I-SAPT: Functional Group and/or Intramolecular SAPT; FNOCC: Frozen natural orbitals for CCSD(T), QCISD(T), CEPA, and MP4; Harmonic Vibrational Analysis and Visualization of Normal Modes — frequency() and hessian(); Interface to gau2grid by D. G. A. Smith; Interface to gCP by S. Grimme; Interface to GDMA Distributed Multipole Analysis by A. J. Stone — gdma(); Index; PSI Variables by Alpha; PSI4: Open-Source Quantum Chemistry; A PSI4 Tutorial; Function Intercalls; Interfaces: Enhancing PSI4 Capabilities; Introduction; Interface to LIBEFP by I. Kaliman; Interface to Libint by E. Valeev; Interface to Libxc by M. A. L. Marques; Adding Add-Ons; Git, Versioning; Managing: Git, Conda, CMake and all that; Release Procedures; MCSCF: Multi-Configurational Self-Consistent-Field; Theoretical Methods: SCF to FCI; Interface to Molden ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/index-wcopy.html:814753,energy,energy,814753,index-wcopy.html,https://psicode.org,https://psicode.org/index-wcopy.html,5,['energy'],['energy']
Energy Efficiency,"One-electron Overlap Matrix. X(). alpha_orbital_space(self, id, basis, subset); Creates OrbitalSpace with information about the requested alpha orbital space. aotoso(self); Returns the Atomic Orbital to Symmetry Orbital transformer. array_variable(self, arg0); Returns copy of the requested (case-insensitive) Matrix QC variable. array_variables(self); Returns the dictionary of all Matrix QC variables. arrays(). Deprecated since version 1.4. atomic_point_charges(self); Returns the set atomic point charges. basis_projection(self, arg0, arg1, arg2, arg3); Projects a orbital matrix from one basis to another. basisset(self); Returns the current orbital basis. beta_orbital_space(self, arg0, arg1, arg2); docstring. build(mol[, basis, quiet]). c1_deep_copy(self, basis); Returns a new wavefunction with internal data converted to \(C_1\) symmetry, using pre-c1-constructed basis. ci_nat_orbs(self); docstring. cleanup_ci(self); docstring. cleanup_dpd(self); docstring. compute_energy(self); Computes the energy of the Wavefunction. compute_gradient(self); Computes the gradient of the Wavefunction. compute_hessian(self); Computes the Hessian of the Wavefunction. compute_state_transfer(self, arg0, arg1, ...); docstring. deep_copy(self, arg0); Deep copies the internal data. del_array_variable(self, arg0); Removes the requested (case-insensitive) Matrix QC variable. del_potential_variable(self, arg0); Removes the requested (case-insensitive) ExternalPotential QC variable. del_scalar_variable(self, arg0); Removes the requested (case-insensitive) double QC variable. del_variable(key); Removes scalar or array QCVariable key from cls if present. density_fitted(self); Returns whether this wavefunction was obtained using density fitting or not. diag_h(self, arg0, arg1); docstring. doccpi(self); Returns the number of doubly occupied orbitals per irrep. efzc(self); Returns the frozen-core energy. energy(self); Returns the Wavefunction's energy. epsilon_a(self); Returns the Alpha Eigenvalues. e",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/api/psi4.core.CIWavefunction.html:2145,energy,energy,2145,psi4manual/1.6.x/api/psi4.core.CIWavefunction.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/api/psi4.core.CIWavefunction.html,2,['energy'],['energy']
Energy Efficiency,"Optional[ndarray]) – (3, 3 * nat) dipole derivatives in atomic units, [Eh a0/u] or [(e a0/a0)^2/u]; project_trans (bool) – Idealized translations projected out of final vibrational analysis.; project_rot (bool) – Idealized rotations projected out of final vibrational analysis. Returns:; Returns dictionary of vibration Datum objects (fields: label units data comment).; Also returns text suitable for printing. Return type:; dict, str. Notes. key; description (label & comment); units; data (real/imaginary modes). omega; frequency; cm^-1; ndarray(ndof) complex (real/imag). q; normal mode, normalized mass-weighted; a0 u^1/2; ndarray(ndof, ndof) float. w; normal mode, un-mass-weighted; a0; ndarray(ndof, ndof) float. x; normal mode, normalized un-mass-weighted; a0; ndarray(ndof, ndof) float. degeneracy; degree of degeneracy. ndarray(ndof) int. TRV; translation/rotation/vibration. ndarray(ndof) str ‘TR’ or ‘V’ or ‘-’ for partial. gamma; irreducible representation. ndarray(ndof) str irrep or None if unclassifiable. mu; reduced mass; u; ndarray(ndof) float (+/+). k; force constant; mDyne/A; ndarray(ndof) float (+/-). DQ0; RMS deviation v=0; a0 u^1/2; ndarray(ndof) float (+/0). Qtp0; Turning point v=0; a0 u^1/2; ndarray(ndof) float (+/0). Xtp0; Turning point v=0; a0; ndarray(ndof) float (+/0). theta_vib; char temp; K; ndarray(ndof) float (+/0). IR_intensity; infrared intensity; km/mol; ndarray(ndof) float (+/+). Examples; >>> # displacement of first atom in highest energy mode; >>> vibinfo['x'].data[:, -1].reshape(nat, 3)[0]. >>> # remove translations & rotations; >>> vibonly = filter_nonvib(vibinfo). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.7;  · . PSI4. Psithon Functions: Invoking a Calculation; Harmonic Vibrational Analysis and Visualization of Normal Modes — frequency() and hessian(); harmonic_analysis. © Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/api/psi4.driver.qcdb.vib.harmonic_analysis.html:1935,reduce,reduced,1935,psi4manual/1.7.x/api/psi4.driver.qcdb.vib.harmonic_analysis.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.driver.qcdb.vib.harmonic_analysis.html,4,"['energy', 'reduce']","['energy', 'reduced']"
Energy Efficiency,"Options. Navigation. Index. modules    .    .    .    .  · ; 1.1;  · . PSI4. Psithon Functions: Invoking a Calculation. Notes on Options¶. Note; The Python options referred to in the Psithon Functions: Invoking a Calculation section below; are placed as arguments to a Python; function (like energy()), not in set blocks or commands. Note; All PSI4 keyword names and values are insensitive to case, both; those that are placed in set blocks and as Python function arguments.; The one exception is documented for the subset option in the database(); function, where case structure must match the database file. Note; Boolean options can be specified by yes, on, true, or 1; for affirmative and no, off, false, or 0 for negative,; all insensitive to case. Note; The derivative level type for optimize() and frequency() functions can be specified by energy, none, or 0 for 0th derivative, gradient, first, or 1 for 1st derivative, and hessian, second, or 2 for 2nd derivative. For finite difference, as opposed to analytic, derivatives, the POINTS option can be increased to 5 for greater accuracy at increased cost. Note; Function option for the Psithon function called by the current function;; the default is usually energy(). See Sec. Function Intercalls; for a fuller description. Note that the value of the keyword is a Python object; and so is not wrapped in quotes like a string. Note; The molecule to be acted upon by the current function; the default is the; “active” molecule, which is the nearest preceeding molecule declared in a; molecule mymol {...} block or in an activate(mymol) statement. Note; that the value of this keyword (mymol in the example) is a Python object; and so is not wrapped in quotes like a string. Technically, this is a; Molecule object. Navigation. Index. modules    .    .    .    .  · ; 1.1;  · . PSI4. Psithon Functions: Invoking a Calculation. © Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/notes_py-1.html:1229,energy,energy,1229,psi4manual/1.1.0/notes_py-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/notes_py-1.html,2,['energy'],['energy']
Energy Efficiency,"Orbital to Symmetry Orbital transformer. arrays(self: psi4.core.Wavefunction) → Dict[str, psi4.core.Matrix]; Returns the map of all internal arrays. atomic_point_charges(self: psi4.core.Wavefunction) → psi4.core.Vector; Returns the set atomic point charges. basis_projection(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix, arg1: psi4.core.Dimension, arg2: psi4.core.BasisSet, arg3: psi4.core.BasisSet) → psi4.core.Matrix; Projects a orbital matrix from one basis to another. basisset(self: psi4.core.Wavefunction) → psi4.core.BasisSet; Returns the current orbital basis. beta_orbital_space(self: psi4.core.Wavefunction, arg0: str, arg1: str, arg2: str) → psi4.core.OrbitalSpace; docstring. static build(mol, basis=None). c1_deep_copy(self: psi4.core.Wavefunction, basis: psi4.core.BasisSet) → psi4.core.Wavefunction; Returns a new wavefunction with internal data converted to C_1 symmetry, using pre-c1-constructed BasisSet *basis. compute_energy(self: psi4.core.Wavefunction) → float; Computes the energy of the Wavefunction. compute_gradient(self: psi4.core.Wavefunction) → psi4.core.Matrix; Computes the gradient of the Wavefunction. compute_hessian(self: psi4.core.Wavefunction) → psi4.core.Matrix; Computes the Hessian of the Wavefunction. deep_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None; Deep copies the internal data. doccpi(self: psi4.core.Wavefunction) → psi4.core.Dimension; Returns the number of doubly occupied orbitals per irrep. energy(self: psi4.core.Wavefunction) → float; Returns the Wavefunctions energy. epsilon_a(self: psi4.core.Wavefunction) → psi4.core.Vector; Returns the Alpha Eigenvalues. epsilon_a_subset(self: psi4.core.Wavefunction, arg0: str, arg1: str) → psi4.core.Vector; Returns the requested Alpha Eigenvalues subset. epsilon_b(self: psi4.core.Wavefunction) → psi4.core.Vector; Returns the Beta Eigenvalues. epsilon_b_subset(self: psi4.core.Wavefunction, arg0: str, arg1: str) → psi4.core.Vector; Returns the requested Beta Eigenvalu",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/api/psi4.core.wavefunction.html:15929,energy,energy,15929,psi4manual/1.2.1/api/psi4.core.wavefunction.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/api/psi4.core.wavefunction.html,1,['energy'],['energy']
Energy Efficiency,"Order Møller–Plesset Perturbation Theory) interaction energies for dimer molecules.; The plugin is distributed under the 2-clause BSD license. Installation¶; Binary. snsmp2 is available as a conda package for Linux and macOS (and Windows, through the Ubuntu shell).; If using the Psi4conda installer, snsmp2 has already been installed alongside.; If using the PSI4 conda package, the snsmp2 conda package can; be obtained through conda install snsmp2 -c psi4 or conda install; psi4-rt -c psi4.; If using PSI4 built from source, and anaconda or miniconda has; already been installed (instructions at Quick Installation),; snsmp2 can be obtained through conda install snsmp2 -c psi4.; Then, hint its location with PYTHONPATH.; To remove a conda installation, conda remove snsmp2. Source. Download the plugin from the GitHub repository:; >>> git clone https://github.com/DEShawResearch/sns-mp2. Once dowloaded, the plugin can be installed as outlined in the documentation:; >>> cd {top-level-sns-mp2-directory}; >>> PSI4_PYTHON=$(head $(which psi4) -n 1 | sed -r 's/^.{2}//'); >>> $PSI4_PYTHON -m pip install . Sample Input¶; A sample input file, adapted from the documentation, is shown below:; # Sample SNS-MP2 calculation for two helium atoms. molecule dimer {; He 0 0 0; --; He 2 0 0; }. energy('sns-mp2'). Note that the two monomers are separated by double dashes, indicating that; they should be treated as separate molecules. (See; Analysis of Intermolecular Interactions for more details on; setting up dimer molecules.) This input file can be run in the usual fashion:; >>> psi4 input.dat. table of contents. Spin-Network-Scaled MP2 (SNS-MP2) by D. E. Shaw; Installation; Sample Input. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities; Spin-Network-Scaled MP2 (SNS-MP2) by D. E. Shaw. © Copyright 2022, The Psi4 Project.; Last updated on Thursday, 19 May 2022 08:57PM.; Created using Sphinx 4.5.0.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/plugin_snsmp2.html:1687,adapt,adapted,1687,psi4manual/1.6.x/plugin_snsmp2.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/plugin_snsmp2.html,2,"['adapt', 'energy']","['adapted', 'energy']"
Energy Efficiency,"Override which code computes the gcp correction. Now can use; classic gcp or mctc-gcp executables.; save_pairwise_disp (bool) – Whether to request atomic pairwise analysis. Methods Summary. compute_energy(molecule[, wfn]); Compute dispersion energy based on engine, dispersion level, and parameters in self. compute_gradient(molecule[, wfn]); Compute dispersion gradient based on engine, dispersion level, and parameters in self. compute_hessian(molecule[, wfn]); Compute dispersion Hessian based on engine, dispersion level, and parameters in self. print_out(); Format dispersion parameters of self for output file. Methods Documentation. compute_energy(molecule, wfn=None)[source]¶; Compute dispersion energy based on engine, dispersion level, and parameters in self. Parameters:. molecule (Molecule) – System for which to compute empirical dispersion correction.; wfn (Wavefunction) – Location to set QCVariables. Returns:; Dispersion energy [Eh]. Return type:; float. Notes. DISPERSION CORRECTION ENERGYDisp always set. Overridden in SCF finalization, but that only changes for “-3C” methods. fctl DISPERSION CORRECTION ENERGYSet if fctldash nonempty. compute_gradient(molecule, wfn=None)[source]¶; Compute dispersion gradient based on engine, dispersion level, and parameters in self. Parameters:. molecule (Molecule) – System for which to compute empirical dispersion correction.; wfn (Wavefunction) – Location to set QCVariables. Returns:; (nat, 3) dispersion gradient [Eh/a0]. Return type:; Matrix. compute_hessian(molecule, wfn=None)[source]¶; Compute dispersion Hessian based on engine, dispersion level, and parameters in self.; Uses finite difference, as no dispersion engine has analytic second derivatives. Parameters:. molecule (Molecule) – System for which to compute empirical dispersion correction.; wfn (Wavefunction) – Location to set QCVariables. Returns:; (3*nat, 3*nat) dispersion Hessian [Eh/a0/a0]. Return type:; Matrix. print_out()[source]¶; Format dispersion parameters of s",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.EmpiricalDispersion.html:4512,ENERGY,ENERGYDisp,4512,psi4manual/1.8.x/api/psi4.driver.EmpiricalDispersion.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.EmpiricalDispersion.html,1,['ENERGY'],['ENERGYDisp']
Energy Efficiency,"P and non-ECP orbital/fitting basis sets in a session. scf6; Tests RHF/ROHF/UHF SCF gradients. casscf-sp; CASSCF/6-31G** energy point. cc1; RHF-CCSD 6-31G** all-electron optimization of the H2O molecule. opt12; SCF cc-pVDZ geometry optimzation of ketene, starting from bent structure. omp3-grad2; OMP3 cc-pVDZ gradient for the NO radical. cbs-xtpl-freq; Various gradients for a strained helium dimer and water molecule. scf-auto-cholesky; Cholesky filter a complete basis. cc48; reproduces dipole moments in J.F. Stanton’s “biorthogonal” JCP paper. dft-pruning; Tests all grid pruning options available and screening of small weights. Check against grid size. cdomp2-1; OMP2 cc-pVDZ energy for the H2O molecule. soscf-dft; Triple and Singlet Oxygen energy SOSCF, also tests non-symmetric density matrices. cc11; Frozen-core CCSD(ROHF)/cc-pVDZ on CN radical with disk-based AO algorithm. cc13; UHF-CCSD/cc-pVDZ \(^{3}B_1\) CH2 geometry optimization via analytic gradients. dfccsdt1; DF-CCSD(T) cc-pVDZ energy for the H2O molecule. nbody-freq; Vibrational and thermo analysis of water trimer (geometry from J. Chem. Theory Comput. 11, 2126-2136 (2015)). omp2p5-2; OMP2.5 cc-pVDZ energy for the H2O molecule. dct-grad2; RHF-ODC-12 analytic gradient computations for H2O use AO_BASIS=DISK and AO_BASIS=NONE, respectively. RHF-ODC-06 analytic gradient computations for H2O use AO_BASIS=DISK and AO_BASIS=NONE, respectively. cc40; RHF-CC2-LR/cc-pVDZ optical rotation of H2O2. gauge = length, omega = (589 355 nm). cubeprop-esp; RHF orbitals and density for water. frac; Carbon/UHF Fractionally-Occupied SCF Test Case. cepa3; cc-pvdz H2O Test coupled-pair CISD against DETCI CISD. pywrap-opt-sowreap; Finite difference optimization, run in sow/reap mode. cc15; RHF-B-CCD(T)/6-31G** H2O single-point energy (fzc, MO-basis \(\langle ab|cd \rangle\)). castup2; SCF with various combinations of pk/density-fitting, castup/no-castup, and spherical/cartesian settings. Demonstrates that puream setting is getting ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/autodoc_testsuite_corepsi4-1.html:43074,energy,energy,43074,psi4manual/1.5.0/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/autodoc_testsuite_corepsi4-1.html,4,['energy'],['energy']
Energy Efficiency,"P object. efp_set_options(() -> None); Set EFP options from environment options object. fd_1_0((arg0: psi::Molecule, ...); Performs a finite difference gradient computation, from energy points. fd_freq_0((arg0: psi::Molecule, arg1: list, ...); Performs a finite difference frequency computation, from energy points, for a given irrep. fd_freq_1((arg0: psi::Molecule, arg1: list, ...); Performs a finite difference frequency computation, from gradients, for a given irrep. fd_geoms_1_0(...); Gets list of displacements needed for a finite difference gradient computation, from energy points. fd_geoms_freq_0((arg0: psi::Molecule, ...); Gets list of displacements needed for a finite difference frequency computation, from energy points, for a given irrep. fd_geoms_freq_1((arg0: psi::Molecule, ...); Gets list of displacements needed fof a finite difference frequency computation, from gradients, for a given irrep. finalize(() -> None). fisapt((arg0: psi::Wavefunction) -> float); Runs the functional-group intramolecular symmetry adapted perturbation theory code. flush_outfile(() -> None); Flushes the output file. fnocc(...); Runs the fno-ccsd(t)/qcisd(t)/mp4/cepa energy code. get_active_efp(() -> psi4.core.EFP); Returns the currently active EFP object. get_active_molecule(() -> psi::Molecule); Returns the currently active molecule object. get_array_variable((arg0: str) -> psi::Matrix); Returns one of the PSI variables set internally by the modules or python driver (see manual for full listing of variables available). get_array_variables(() -> Dict[str, psi::Matrix]); Returns dictionary of the PSI variables set internally by the modules or python driver. get_atomic_point_charges(() -> psi::Vector); Returns the most recently computed atomic point charges, as a double * object. get_efp_torque(() -> psi::Matrix); Returns the most recently computed gradient for the EFP portion, as a Nefp by 6 Matrix object. get_environment((arg0: str) -> str); Get enviromental vairable. get_frequencie",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/psi4api-1.html:164655,adapt,adapted,164655,psi4manual/1.1.0/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/psi4api-1.html,2,['adapt'],['adapted']
Energy Efficiency,"P support! No ECP data will be written to the FCHK file.""). # fix orbital coefficients and energies for DFMP2; if module_ in ['DFMP2']:; wfn_ = core.Wavefunction.build(wfn.molecule(), core.get_global_option('BASIS')); wfn_.deep_copy(wfn); refwfn = wfn.reference_wavefunction(); wfn_.set_reference_wavefunction(refwfn) # refwfn not deep_copied; wfn_.Ca().copy(refwfn.Ca()); wfn_.Cb().copy(refwfn.Cb()); wfn_.epsilon_a().copy(refwfn.epsilon_a()); wfn_.epsilon_b().copy(refwfn.epsilon_b()); fw = core.FCHKWriter(wfn_); else:; fw = core.FCHKWriter(wfn). if module_ in ['DCT', 'DFOCC']:; core.print_out(""""""FCHKWriter: Caution! For orbital-optimized correlated methods; the 'Orbital Energy' field contains ambiguous data. \n""""""). # At this point we don't know the method name, so we try to search for it.; # idea: get the method from the variable matching closely the 'current energy'; varlist = core.scalar_variables(); current = varlist['CURRENT ENERGY']. # delete problematic entries; for key in ['CURRENT ENERGY', 'CURRENT REFERENCE ENERGY']:; varlist.pop(key, None). # find closest matching energy; for (key, val) in varlist.items():; if (np.isclose(val, current, 1e-12)):; method = key.split()[0]; break. # The 'official' list of labels for compatibility.; # OMP2,MP2.5,OCCD, etc get reduced to MP2,CC.; allowed_labels = {; ""HF"": "" SCF Density"",; ""SCF"": "" SCF Density"",; ""DFT"": "" SCF Density"",; ""MP2"": "" MP2 Density"",; ""MP3"": "" MP3 Density"",; ""MP4"": "" MP4 Density"",; ""CI"": "" CI Density"",; ""CC"": "" CC Density"",; }; # assign label from method name; fchk_label = f"" {method} Density""; if strict_label:; in_list = False; for key in allowed_labels:; if key in method:; if key is not method:; core.print_out(f""FCHKWriter: !WARNING! method '{method}'' renamed to label '{key}'.\n""); fchk_label = allowed_labels[key]; in_list = True; if not in_list:; core.print_out(f""FCHKWriter: !WARNING! {method} is not recognized. Using non-standard label.\n""); core.print_out(f""FCHKWriter: Writing {filename} with label '",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:96738,ENERGY,ENERGY,96738,psi4manual/1.4.0/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html,4,['ENERGY'],['ENERGY']
Energy Efficiency,"P2.5CORRELATIONENERGY>` ; #; # >>> energy('mp2.5'); #; # """"""; # lowername = name.lower(); # kwargs = kwargs_lower(kwargs); #; # # Run detci calculation and collect conventional quantities; # energy('mp3', **kwargs); # e_scf = PsiMod.get_variable('SCF TOTAL ENERGY'); # ce_mp2 = PsiMod.get_variable('MP2 CORRELATION ENERGY'); # ce_mp3 = PsiMod.get_variable('MP3 CORRELATION ENERGY'); # e_mp2 = e_scf + ce_mp2; # e_mp3 = e_scf + ce_mp3; #; # # Compute quantities particular to MP2.5; # ce_mp25 = 0.5 * (ce_mp2 + ce_mp3); # e_mp25 = e_scf + ce_mp25; # PsiMod.set_variable('MP2.5 CORRELATION ENERGY', ce_mp25); # PsiMod.set_variable('MP2.5 TOTAL ENERGY', e_mp25); # PsiMod.set_variable('CURRENT CORRELATION ENERGY', ce_mp25); # PsiMod.set_variable('CURRENT ENERGY', e_mp25); #; # # build string of title banner and print results; # banners = ''; # banners += """"""PsiMod.print_out('\\n')\n""""""; # banners += """"""banner(' MP2.5 ')\n""""""; # banners += """"""PsiMod.print_out('\\n')\n\n""""""; # exec(banners); #; # tables = ''; # tables += """""" SCF total energy: %16.8f\n"""""" % (e_scf); # tables += """""" MP2 total energy: %16.8f\n"""""" % (e_mp2); # tables += """""" MP2.5 total energy: %16.8f\n"""""" % (e_mp25); # tables += """""" MP3 total energy: %16.8f\n\n"""""" % (e_mp3); # tables += """""" MP2 correlation energy: %16.8f\n"""""" % (ce_mp2); # tables += """""" MP2.5 correlation energy: %16.8f\n"""""" % (ce_mp25); # tables += """""" MP3 correlation energy: %16.8f\n"""""" % (ce_mp3); # PsiMod.print_out(tables); #; # return e_mp25. # A direct translation of a plugin input file into a function call. Function calls are the only; # way to call plugins in sow/reap mode for db(), opt(), etc. This isn't best practices; # but is an example of what to do for a more complicated procedure where different options ; # are set for different qc steps.; #def run_plugin_omega(name, **kwargs):; # r""""""Function encoding sequence of PSI module and plugin calls, as well; # as typical options, to access Rob Parrish's omega plugin.; #; # >>> energy('plugin_o",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/_modules/aliases.html:3584,energy,energy,3584,psi4manual/4.0b4/_modules/aliases.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/aliases.html,2,['energy'],['energy']
Energy Efficiency,"P22(T)(CCD) ENERGY; SAPT EXCH ENERGY; SAPT EXCH-DISP20 ENERGY; SAPT EXCH-DISP30 ENERGY; SAPT EXCH-IND-DISP30 ENERGY; SAPT EXCH-IND20,R ENERGY; SAPT EXCH-IND20,U ENERGY; SAPT EXCH-IND22 ENERGY; SAPT EXCH-IND30,R ENERGY; SAPT EXCH10 ENERGY; SAPT EXCH10(S^2) ENERGY; SAPT EXCH11(S^2) ENERGY; SAPT EXCH12(S^2) ENERGY; SAPT HF TOTAL ENERGY; SAPT IND ENERGY; SAPT IND-DISP30 ENERGY; SAPT IND20,R ENERGY; SAPT IND20,U ENERGY; SAPT IND22 ENERGY; SAPT IND30,R ENERGY; SAPT MP2 CORRELATION ENERGY; SAPT SAME-SPIN DISP20 ENERGY; SAPT SAME-SPIN EXCH-DISP20 ENERGY; SAPT TOTAL ENERGY; SAPT0 DISP ENERGY; SAPT0 ELST ENERGY; SAPT0 EXCH ENERGY; SAPT0 IND ENERGY; SAPT0 TOTAL ENERGY; SAPT2 DISP ENERGY; SAPT2 ELST ENERGY; SAPT2 EXCH ENERGY; SAPT2 IND ENERGY; SAPT2 TOTAL ENERGY; SAPT2+ DISP ENERGY; SAPT2+ ELST ENERGY; SAPT2+ EXCH ENERGY; SAPT2+ IND ENERGY; SAPT2+ TOTAL ENERGY; SAPT2+(3) DISP ENERGY; SAPT2+(3) ELST ENERGY; SAPT2+(3) EXCH ENERGY; SAPT2+(3) IND ENERGY; SAPT2+(3) TOTAL ENERGY; SAPT2+(3)(CCD) DISP ENERGY; SAPT2+(3)(CCD) ELST ENERGY; SAPT2+(3)(CCD) EXCH ENERGY; SAPT2+(3)(CCD) IND ENERGY; SAPT2+(3)(CCD) TOTAL ENERGY; SAPT2+(3)(CCD)DMP2 DISP ENERGY; SAPT2+(3)(CCD)DMP2 ELST ENERGY; SAPT2+(3)(CCD)DMP2 EXCH ENERGY; SAPT2+(3)(CCD)DMP2 IND ENERGY; SAPT2+(3)(CCD)DMP2 TOTAL ENERGY; SAPT2+(3)DMP2 DISP ENERGY; SAPT2+(3)DMP2 ELST ENERGY; SAPT2+(3)DMP2 EXCH ENERGY; SAPT2+(3)DMP2 IND ENERGY; SAPT2+(3)DMP2 TOTAL ENERGY; SAPT2+(CCD) DISP ENERGY; SAPT2+(CCD) ELST ENERGY; SAPT2+(CCD) EXCH ENERGY; SAPT2+(CCD) IND ENERGY; SAPT2+(CCD) TOTAL ENERGY; SAPT2+(CCD)DMP2 DISP ENERGY; SAPT2+(CCD)DMP2 ELST ENERGY; SAPT2+(CCD)DMP2 EXCH ENERGY; SAPT2+(CCD)DMP2 IND ENERGY; SAPT2+(CCD)DMP2 TOTAL ENERGY; SAPT2+3 DISP ENERGY; SAPT2+3 ELST ENERGY; SAPT2+3 EXCH ENERGY; SAPT2+3 IND ENERGY; SAPT2+3 TOTAL ENERGY; SAPT2+3(CCD) DISP ENERGY; SAPT2+3(CCD) ELST ENERGY; SAPT2+3(CCD) EXCH ENERGY; SAPT2+3(CCD) IND ENERGY; SAPT2+3(CCD) TOTAL ENERGY; SAPT2+3(CCD)DMP2 DISP ENERGY; SAPT2+3(CCD)DMP2 ELST ENERGY; SAPT2+3(CCD)DMP2 EXCH EN",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/autodir_psivariables/module__sapt-1.html:1625,ENERGY,ENERGY,1625,psi4manual/1.4.0/autodir_psivariables/module__sapt-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_psivariables/module__sapt-1.html,4,['ENERGY'],['ENERGY']
Energy Efficiency,"P3 TOTAL ENERGY¶. SCS-MP3 CORRELATION ENERGY¶; The total electronic energy [E_h] and correlation energy component [E_h]; for the MP3-like method formed by reweighting the difference between; MP3 DOUBLES ENERGY and MP2 DOUBLES ENERGY; by 0.25, atop the SCS-MP2 energy, with any singles carried along. SCS-OMP3 TOTAL ENERGY¶. SCS-OMP3 CORRELATION ENERGY¶; The total electronic energy [E_h] and correlation energy component [E_h]; for the OMP3-like method formed by reweighting the difference between; OMP3 DOUBLES ENERGY and OMP2 DOUBLES ENERGY; by 0.25, atop the SCS-OMP2 energy, with any singles carried along. SOS-MP2 TOTAL ENERGY¶. SOS-MP2 CORRELATION ENERGY¶; The total electronic energy [E_h] and correlation energy component [E_h]; for the MP2-like method formed by reweighting MP2 DOUBLES ENERGY; by 1.3 opposite-spin and 0 same-spin contributions, with; any singles carried along. SOS-OMP2 TOTAL ENERGY¶. SOS-OMP2 CORRELATION ENERGY¶; The total electronic energy [E_h] and correlation energy component [E_h]; for the OMP2-like method formed by reweighting OMP2 DOUBLES ENERGY; by 1.2 opposite-spin and 0 same-spin contributions, with; any singles carried along. SOS-OMP3 TOTAL ENERGY¶. SOS-OMP3 CORRELATION ENERGY¶; The total electronic energy [E_h] and correlation energy component [E_h]; for the OMP3-like method formed by reweighting the difference between; OMP3 DOUBLES ENERGY and OMP2 DOUBLES ENERGY; by 0.25, atop the SOS-OMP2; energy using non-canonical weighting, with any singles carried along. SOS-PI-MP2 TOTAL ENERGY¶. SOS-PI-MP2 CORRELATION ENERGY¶; The total electronic energy [E_h] and correlation energy component [E_h]; for the MP2-like method formed by reweighting MP2 DOUBLES ENERGY; by 1.4 opposite-spin and 0 same-spin contributions, with; any singles carried along. TD-fctl ROOT 0 -> ROOT n ELECTRIC TRANSITION DIPOLE MOMENT (VEL)¶; The electric transition dipole moment [e a0] in velocity gauge, for the transition; from the ground state to root m.; DFT functional labele",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/glossary_psivariables.html:56925,energy,energy,56925,psi4manual/1.7.x/glossary_psivariables.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/glossary_psivariables.html,8,['energy'],['energy']
Energy Efficiency,"P3 cc-pVDZ geometry optimization for the H2O molecule. dcft-grad4; Unrestricted DF-DCFT ODC-12 gradient for O2 with cc-pVTZ/cc-pVTZ-RI standard/auxiliary basis set. fd-freq-gradient; SCF STO-3G finite-differences frequencies from gradients for H2O. sapt-exch-ind-inf; SAPT(DFT) aug-cc-pVDZ interaction energy between Ne and Ar atoms. ocepa-grad2; OCEPA cc-pVDZ gradient for the NO radical. dfscf-bz2; Benzene Dimer DF-HF/cc-pVDZ. isapt1; This test case shows an example of running and analyzing an FI-SAPT0/jun-cc-pvdz computation for 2,4-pentanediol (targeting the intramolecular hydrogen bond between the two hydroxyl groups). dfmp2-2; Density fitted MP2 energy of H2, using density fitted reference and automatic looping over cc-pVDZ and cc-pVTZ basis sets. Results are tabulated using the built in table functions by using the default options and by specifiying the format. dfmp2-freq1; DF-MP2 frequency by difference of energies for H2O. cc8a; ROHF-CCSD(T) cc-pVDZ frozen-core energy for the \(^2\Sigma^+\) state of the CN radical, with Cartesian input. cbs-xtpl-gradient; Various gradients for a strained helium dimer and water molecule. dft-jk; DFT JK on-disk test. cbs-xtpl-opt; Various extrapolated optimization methods for the H2 molecule. ci-multi; BH single points, checking that program can run multiple instances of DETCI in a single input, without an intervening clean() call. fd-freq-gradient-large; SCF DZ finite difference frequencies by gradients for C4NH4. soscf-ref; Triple and Singlet Oxygen energy SOSCF, also tests non-symmetric density matrices. cisd-h2o+-0; 6-31G** H2O+ Test CISD Energy Point. sapt-dft-lrc; SAPT(DFT) aug-cc-pVDZ interaction energy between Ne and Ar atoms. serial-wfn; A simple hf/cc-pvdz water calculation. The resulting wavefunction is written to a file, and then a new wavefunction is generated from that file. The member variables of both wavefunctions should be identical in value. psimrcc-ccsd_t-4; Mk-MRCCSD(T) single point. \(^1A_1\) O$_3` state de",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/autodoc_testsuite_corepsi4-1.html:2074,energy,energy,2074,psi4manual/1.3.2/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/autodoc_testsuite_corepsi4-1.html,4,['energy'],['energy']
Energy Efficiency,P4 TOTAL ENERGY¶. MP4 CORRELATION ENERGY¶. MP4(SDTQ) TOTAL ENERGY¶. MP4(SDTQ) CORRELATION ENERGY¶; The total electronic energy [Eh] and correlation energy component [Eh]; for the full MP4 level of theory. Quantity MP4 CORRELATION; ENERGY / MP4(SDTQ) CORRELATION ENERGY; is left-hand term in Eq. (2). (2)¶\[E_{\text{MP4}} = E_{\text{MP4(SDQ)}} + E_{\text{MP4(T)}}\]. MPn TOTAL ENERGY¶. MPn CORRELATION ENERGY¶; The total electronic energy [Eh] and correlation energy component [Eh]; for the labeled Møller–Plesset perturbation theory level.; n is MP perturbation order. MP2 DOUBLES ENERGY¶. MP2.5 DOUBLES ENERGY¶. MP3 DOUBLES ENERGY¶. CEPA(0) DOUBLES ENERGY¶. CEPA(1) DOUBLES ENERGY¶. CEPA(2) DOUBLES ENERGY¶. CEPA(3) DOUBLES ENERGY¶. CISD DOUBLES ENERGY¶. QCISD DOUBLES ENERGY¶. LCCD DOUBLES ENERGY¶. CCD DOUBLES ENERGY¶. LCCSD DOUBLES ENERGY¶. CCSD DOUBLES ENERGY¶. OMP2 DOUBLES ENERGY¶. OMP2.5 DOUBLES ENERGY¶. OMP3 DOUBLES ENERGY¶. OLCCD DOUBLES ENERGY¶; The doubles portion [Eh] of the named correlation energy; including same-spin and opposite-spin correlations. MP2 SINGLES ENERGY¶. MP2.5 SINGLES ENERGY¶. MP3 SINGLES ENERGY¶. CEPA(0) SINGLES ENERGY¶. CEPA(1) SINGLES ENERGY¶. CEPA(2) SINGLES ENERGY¶. CEPA(3) SINGLES ENERGY¶. CISD SINGLES ENERGY¶. QCISD SINGLES ENERGY¶. LCCD SINGLES ENERGY¶. CCD SINGLES ENERGY¶. LCCSD SINGLES ENERGY¶. CCSD SINGLES ENERGY¶. OLCCD SINGLES ENERGY¶; The singles portion [Eh] of the named correlation energy.; Zero except in ROHF. MP2 SAME-SPIN CORRELATION ENERGY¶. MP2.5 SAME-SPIN CORRELATION ENERGY¶. MP3 SAME-SPIN CORRELATION ENERGY¶. CEPA(0) SAME-SPIN CORRELATION ENERGY¶. CEPA(1) SAME-SPIN CORRELATION ENERGY¶. CEPA(2) SAME-SPIN CORRELATION ENERGY¶. CEPA(3) SAME-SPIN CORRELATION ENERGY¶. CISD SAME-SPIN CORRELATION ENERGY¶. QCISD SAME-SPIN CORRELATION ENERGY¶. ACPF SAME-SPIN CORRELATION ENERGY¶. AQCC SAME-SPIN CORRELATION ENERGY¶. LCCD SAME-SPIN CORRELATION ENERGY¶. CCD SAME-SPIN CORRELATION ENERGY¶. LCCSD SAME-SPIN CORRELATION ENERGY¶. CCSD SAME-SPIN C,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/glossary_psivariables-1.html:29851,energy,energy,29851,psi4manual/1.4.0/glossary_psivariables-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/glossary_psivariables-1.html,5,['energy'],['energy']
Energy Efficiency,"P8 conventions (without the line-length restriction). I’m aiming for files to pass the line below, unless for good reason. The second line is for database Python files.; >>> pep8.py -r --ignore=E501 pythonfile.py; >>> pep8.py -r --ignore=E501,E221,E222,E241,E201,E202 databasefile.py. Your python function should not prevent any test case from passing. A test case(s) should be written and checked in for any major python function, so that others do not break your code. If most of your work was on the python (as opposed to c++) side, the test case prefix pywrap_ is suggested. Be sure to set any new PSI variables through lines like those below. Especially if the function returns an energy, set the ‘current energy’ variable. This last is needed to communicate with the optimizer.; psi4.set_variable('MP2.5 CORRELATION ENERGY', ce_mp25); psi4.set_variable('MP2.5 TOTAL ENERGY', e_mp25); psi4.set_variable('CURRENT ENERGY', e_mp25). Once your python function is fairly stable on its own, it’s potential for interoperability with energy()/opt()/cp()/db()/cbs()/etc. should be evaluated. If it makes physical sense that it should work, you should strive to make that interoperability a reality. Some steps:. If any interoperability is possible, define an argument xx_func, where xx is a short name for your function. Add near the top of your function code like the below (less the final two lines). The net result of this code is that if the user specifies no *_func arguments, then energy() gets called. If the user defines xx_func, then its value gets called. If the user defines func, then its value gets reassigned to xx_func, func itself is deleted, and xx_func() gets called. Whatever is getting called is stored in func within the function.; # Establish function to call; if not('xx_func' in kwargs):; if ('func' in kwargs):; kwargs['xx_func'] = kwargs['func']; del kwargs['func']; else:; kwargs['xx_func'] = energy; func = kwargs['xx_func']; if not func:; raise ValidationError('Function \'%s",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/bestpractices_py-1.html:4513,energy,energy,4513,psi4manual/1.0.0/bestpractices_py-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/bestpractices_py-1.html,2,['energy'],['energy']
Energy Efficiency,"PE by M. Scheurer; Generation of Cube Files — cubeprop(); Generation of Cube Files — cubeprop(); Customization: Adding Simple Extensions; Customization: Adding Simple Extensions; Database — database(); Database — database(); DCT: Density Cumulant Theory; DCT: Density Cumulant Theory; CI: Configuration Interaction; CI: Configuration Interaction; DF-MP2: Density-Fitted 2nd-Order Møller–Plesset Perturbation Theory; DF-MP2: Density-Fitted 2nd-Order Møller–Plesset Perturbation Theory; DFT: Density Functional Theory; DFT: Density Functional Theory; DFT Functionals; DFT Functionals; Interface to DFTD3 by S. Grimme; Interface to DFTD3 by S. Grimme; DFT-NL; DFT-NL; Spectroscopic Constants for Diatomics; Spectroscopic Constants for Diatomics; Interface to DKH by A. Wolf, M. Reiher, and B. A. Hess; Interface to DKH by A. Wolf, M. Reiher, and B. A. Hess; DLPNO-MP2: Domain-Based Local Pair Natural Orbital MP2; DLPNO-MP2: Domain-Based Local Pair Natural Orbital MP2; Updating the PSI4 Users’ and Programmers’ Manual; Updating the PSI4 Users’ and Programmers’ Manual; Single-Point Energy — energy(); Single-Point Energy — energy(); Interface to ERD by N. Flocke and V. Lotrich; Interface to ERD by N. Flocke and V. Lotrich; Installation and Runtime Configuration; Installation and Runtime Configuration; External API Objects; External API Objects; Interface to programs through FCHK files — fchk(); Interface to programs through FCHK files — fchk(); F/I-SAPT: Functional Group and/or Intramolecular SAPT; F/I-SAPT: Functional Group and/or Intramolecular SAPT; FNOCC: Frozen natural orbitals for CCSD(T), QCISD(T), CEPA, and MP4; FNOCC: Frozen natural orbitals for CCSD(T), QCISD(T), CEPA, and MP4; Harmonic Vibrational Analysis and Visualization of Normal Modes — frequency() and hessian(); Harmonic Vibrational Analysis and Visualization of Normal Modes — frequency() and hessian(); Interface to gau2grid by D. G. A. Smith; Interface to gau2grid by D. G. A. Smith; Interface to gCP by S. Grimme; Inter",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/index-wcopy.html:698756,energy,energy,698756,index-wcopy.html,https://psicode.org,https://psicode.org/index-wcopy.html,4,['energy'],['energy']
Energy Efficiency,"PF OPPOSITE-SPIN CORRELATION ENERGY; ACPF SAME-SPIN CORRELATION ENERGY; ACPF TOTAL ENERGY; AQCC CORRELATION ENERGY; AQCC OPPOSITE-SPIN CORRELATION ENERGY; AQCC SAME-SPIN CORRELATION ENERGY; AQCC TOTAL ENERGY; CCSD CORRELATION ENERGY; CCSD OPPOSITE-SPIN CORRELATION ENERGY; CCSD SAME-SPIN CORRELATION ENERGY; CCSD TOTAL ENERGY; CCSD(T) CORRELATION ENERGY; CCSD(T) TOTAL ENERGY; CEPA(0) CORRELATION ENERGY; CEPA(0) OPPOSITE-SPIN CORRELATION ENERGY; CEPA(0) SAME-SPIN CORRELATION ENERGY; CEPA(0) TOTAL ENERGY; CEPA(1) CORRELATION ENERGY; CEPA(1) OPPOSITE-SPIN CORRELATION ENERGY; CEPA(1) SAME-SPIN CORRELATION ENERGY; CEPA(1) TOTAL ENERGY; CEPA(2) CORRELATION ENERGY; CEPA(2) OPPOSITE-SPIN CORRELATION ENERGY; CEPA(2) SAME-SPIN CORRELATION ENERGY; CEPA(2) TOTAL ENERGY; CEPA(3) CORRELATION ENERGY; CEPA(3) OPPOSITE-SPIN CORRELATION ENERGY; CEPA(3) SAME-SPIN CORRELATION ENERGY; CEPA(3) TOTAL ENERGY; CISD CORRELATION ENERGY; CISD OPPOSITE-SPIN CORRELATION ENERGY; CISD SAME-SPIN CORRELATION ENERGY; CISD TOTAL ENERGY; CURRENT CORRELATION ENERGY; CURRENT ENERGY; DFCC NAUX; MP2 CORRELATION ENERGY; MP2 OPPOSITE-SPIN CORRELATION ENERGY; MP2 SAME-SPIN CORRELATION ENERGY; MP2 TOTAL ENERGY; MP2.5 CORRELATION ENERGY; MP2.5 TOTAL ENERGY; MP3 CORRELATION ENERGY; MP3 TOTAL ENERGY; MP4 CORRELATION ENERGY; MP4 TOTAL ENERGY; MP4(SDQ) CORRELATION ENERGY; MP4(SDQ) TOTAL ENERGY; MP4(SDTQ) CORRELATION ENERGY; MP4(SDTQ) TOTAL ENERGY; MP4(T) CORRECTION ENERGY; QCISD CORRELATION ENERGY; QCISD OPPOSITE-SPIN CORRELATION ENERGY; QCISD SAME-SPIN CORRELATION ENERGY; QCISD TOTAL ENERGY; QCISD(T) CORRELATION ENERGY; QCISD(T) TOTAL ENERGY; SCF TOTAL ENERGY. Previous topic; DFTSAPT; Next topic; LMP2; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » ; Appendices »; PSI Variables by Module ». © Copyright 2013, The Psi4 Project.; Last updated on Apr 29, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/autodir_psivariables/module__fnocc-1.html:1422,ENERGY,ENERGY,1422,psi4manual/4.0b4/autodir_psivariables/module__fnocc-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/autodir_psivariables/module__fnocc-1.html,36,['ENERGY'],['ENERGY']
Energy Efficiency,"PHERICAL_POINTS_FINAL. The defaults for both grids aim to balance; cost and accuracy.; Screening thresholds over integrals, densities, and basis extents are set; with the COSX_INTS_TOLERANCE, COSX_DENSITY_TOLERANCE, and; COSX_BASIS_TOLERANCE keywords, respectively. COSX_INTS_TOLERANCE; is the most consequential of the three thresholds in both cost and accuracy.; This keyword determines screening of negligible one-electron integrals.; COSX_DENSITY_TOLERANCE controls the threshold for significant; shell pairs in the density matrix. Lastly, COSX_BASIS_TOLERANCE is; a cutoff for the value of basis functions at grid points. This keyword is; used to determine the radial extent of the each basis shell, and it is the; COSX analogue to DFT_BASIS_TOLERANCE.; The COSX_INCFOCK keyword (defaults to true) increases performance; by constructing the Fock matrix from differences in the density matrix, which; are more amenable to screening. Consider disabling this keyword if SCF energy; convergence issues are observed, particularly when using diffuse basis functions.; The COSX_OVERLAP_FITTING keyword (defaults to true) reduces numerical; integration errors using the method described in [Izsak:2011:144105] and is; always recommended. LinK Exchange¶. Warning; The LinK code is currently under development and should not be used. Large SCF calculations can benefit from specialized screening procedures that further reduce the scaling of the ERI contribution to the Fock matrix.; LinK, the linear-scaling exchange method described in [Ochsenfeld:1998:1663], is available with the direct SCF algorithm (SCF_TYPE set to DIRECT).; LinK achieves linear-scaling by exploiting shell pair sparsity in the density matrix and overlap sparsity between shell pairs.; This method is most competitive when used with non-diffuse orbital basis sets, since orbital and density overlaps decay slower with diffuse functions.; LinK is especially powerful when combined with density-matrix based ERI screening (set SCREENI",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/scf.html:32340,energy,energy,32340,psi4manual/1.6.x/scf.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/scf.html,1,['energy'],['energy']
Energy Efficiency,"PHF — Do triplet states? Default true. Type: boolean; Default: true. DOCC (GLOBALS); GLOBALS — An array containing the number of doubly-occupied orbitals per irrep (in Cotton order). Type: array; Default: No Default. DOCC (MCSCF); MCSCF — The number of doubly occupied orbitals, per irrep. Type: array; Default: No Default. DOMAIN_PRINT (CIS); CIS — Do print the domains?. Type: boolean; Default: false. DOMAIN_PRINT_EXIT (LMP2); LMP2 — Do exit after printing the domains?. Type: boolean; Default: false. DOMAINS (CIS); CIS —. Type: array; Default: No Default. E3_SCALE (OMP3); OMP3 — Scaling value for 3rd order energy correction (S. Grimme, Vol. 24, pp. 1529, J. Comput. Chem.). Type: double; Default: 0.25. E_CONVERGENCE (CCEOM); CCEOM — Convergence criterion for excitation energy (change) in the Davidson algorithm for CC-EOM. Type: conv double; Default: 1e-8. E_CONVERGENCE (DETCI); DETCI — Convergence criterion for energy. Type: conv double; Default: 1e-6. E_CONVERGENCE (LMP2); LMP2 — Convergence criterion for energy (change). Type: conv double; Default: 1e-7. E_CONVERGENCE (MCSCF); MCSCF — Convergence criterion for energy. Type: conv double; Default: 1e-8. E_CONVERGENCE (MRCC); MRCC — This becomes tol (option #16) in fort.56. Type: conv double; Default: 1e-8. E_CONVERGENCE (OMP2); OMP2 — Convergence criterion for energy. Type: conv double; Default: 1e-8. E_CONVERGENCE (OMP3); OMP3 — Convergence criterion for energy. Type: conv double; Default: 1e-8. E_CONVERGENCE (PSIMRCC); PSIMRCC — Convergence criterion for energy. Type: conv double; Default: 1e-9. E_CONVERGENCE (SAPT); SAPT — Convergence criterion for energy (change) in the SAPT term during solution of the CPHF equations. Type: conv double; Default: 1e-10. E_CONVERGENCE (SCF); SCF — Convergence criterion for SCF energy. See Table SCF Convergence & Algorithm for default convergence criteria for different calculation types. Type: conv double; Default: 1e-8. EOM_GUESS (CCEOM); CCEOM — Specifies a set of single-excitation",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/autodoc_glossary_options_c-1.html:35871,energy,energy,35871,psi4manual/4.0b3/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodoc_glossary_options_c-1.html,2,['energy'],['energy']
Energy Efficiency,PIN CORRELATION ENERGY; AQCC SINGLES ENERGY; AQCC TOTAL ENERGY; CC ALPHA-ALPHA PAIR ENERGIES (array); CC ALPHA-BETA PAIR ENERGIES (array); CC D1 DIAGNOSTIC; CC SINGLET PAIR ENERGIES (array); CC T1 DIAGNOSTIC; CC TRIPLET PAIR ENERGIES (array); CCSD ALPHA-ALPHA PAIR ENERGIES (array); CCSD ALPHA-BETA PAIR ENERGIES (array); CCSD CORRELATION ENERGY; CCSD DOUBLES ENERGY; CCSD ITERATIONS; CCSD OPPOSITE-SPIN CORRELATION ENERGY; CCSD SAME-SPIN CORRELATION ENERGY; CCSD SINGLES ENERGY; CCSD SINGLET PAIR ENERGIES (array); CCSD TOTAL ENERGY; CCSD TRIPLET PAIR ENERGIES (array); CCSD(T) CORRELATION ENERGY; CCSD(T) TOTAL ENERGY; CEPA(0) CORRELATION ENERGY; CEPA(0) DOUBLES ENERGY; CEPA(0) OPPOSITE-SPIN CORRELATION ENERGY; CEPA(0) SAME-SPIN CORRELATION ENERGY; CEPA(0) SINGLES ENERGY; CEPA(0) TOTAL ENERGY; CEPA(1) CORRELATION ENERGY; CEPA(1) DOUBLES ENERGY; CEPA(1) OPPOSITE-SPIN CORRELATION ENERGY; CEPA(1) SAME-SPIN CORRELATION ENERGY; CEPA(1) SINGLES ENERGY; CEPA(1) TOTAL ENERGY; CEPA(2) CORRELATION ENERGY; CEPA(2) DOUBLES ENERGY; CEPA(2) OPPOSITE-SPIN CORRELATION ENERGY; CEPA(2) SAME-SPIN CORRELATION ENERGY; CEPA(2) SINGLES ENERGY; CEPA(2) TOTAL ENERGY; CEPA(3) CORRELATION ENERGY; CEPA(3) DOUBLES ENERGY; CEPA(3) OPPOSITE-SPIN CORRELATION ENERGY; CEPA(3) SAME-SPIN CORRELATION ENERGY; CEPA(3) SINGLES ENERGY; CEPA(3) TOTAL ENERGY; CISD CORRELATION ENERGY; CISD OPPOSITE-SPIN CORRELATION ENERGY; CISD SAME-SPIN CORRELATION ENERGY; CISD TOTAL ENERGY; CURRENT CORRELATION ENERGY; CURRENT ENERGY; LCCD CORRELATION ENERGY; LCCD DOUBLES ENERGY; LCCD OPPOSITE-SPIN CORRELATION ENERGY; LCCD SAME-SPIN CORRELATION ENERGY; LCCD SINGLES ENERGY; LCCD TOTAL ENERGY; LCCSD CORRELATION ENERGY; LCCSD DOUBLES ENERGY; LCCSD OPPOSITE-SPIN CORRELATION ENERGY; LCCSD SAME-SPIN CORRELATION ENERGY; LCCSD SINGLES ENERGY; LCCSD TOTAL ENERGY; MP2 ALPHA-ALPHA PAIR ENERGIES (array); MP2 ALPHA-BETA PAIR ENERGIES (array); MP2 CORRELATION ENERGY; MP2 DOUBLES ENERGY; MP2 OPPOSITE-SPIN CORRELATION ENERGY; MP2 SAME-SPIN CORRELA,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/autodir_psivariables/module__fnocc.html:1406,ENERGY,ENERGY,1406,psi4manual/1.7.x/autodir_psivariables/module__fnocc.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/autodir_psivariables/module__fnocc.html,4,['ENERGY'],['ENERGY']
Energy Efficiency,"PIN CORRELATION ENERGY¶. LCCD SAME-SPIN CORRELATION ENERGY¶. CCD SAME-SPIN CORRELATION ENERGY¶. LCCSD SAME-SPIN CORRELATION ENERGY¶. CCSD SAME-SPIN CORRELATION ENERGY¶. OLCCD SAME-SPIN CORRELATION ENERGY¶; The unscaled portion [Eh] of the named correlation energy; from same-spin or triplet doubles correlations. MP2 OPPOSITE-SPIN CORRELATION ENERGY¶. MP2.5 OPPOSITE-SPIN CORRELATION ENERGY¶. MP3 OPPOSITE-SPIN CORRELATION ENERGY¶. CEPA(0) OPPOSITE-SPIN CORRELATION ENERGY¶. CEPA(1) OPPOSITE-SPIN CORRELATION ENERGY¶. CEPA(2) OPPOSITE-SPIN CORRELATION ENERGY¶. CEPA(3) OPPOSITE-SPIN CORRELATION ENERGY¶. CISD OPPOSITE-SPIN CORRELATION ENERGY¶. QCISD OPPOSITE-SPIN CORRELATION ENERGY¶. ACPF OPPOSITE-SPIN CORRELATION ENERGY¶. AQCC OPPOSITE-SPIN CORRELATION ENERGY¶. LCCD OPPOSITE-SPIN CORRELATION ENERGY¶. CCD OPPOSITE-SPIN CORRELATION ENERGY¶. LCCSD OPPOSITE-SPIN CORRELATION ENERGY¶. CCSD OPPOSITE-SPIN CORRELATION ENERGY¶. OLCCD OPPOSITE-SPIN CORRELATION ENERGY¶; The unscaled portion [Eh] of the named correlation energy; from opposite-spin or singlet doubles correlations. MRPT TOTAL ENERGY¶. MP2-CCSD TOTAL ENERGY¶. MRCC TOTAL ENERGY¶; Energies [Eh] from correlated multi-reference theories. MULLIKEN CHARGES¶; Property of partial atomic charges [e] by the method of Mulliken, (nat,). NAUX (SCF)¶. NAUX (CC)¶; Convenience storage of number of functions [] in the auxiliary basis; set for named stage of the calculation. NBODY (i, j, ..., k)@(a, b, ..., c) TOTAL ENERGY¶; The total energy [Eh] of a component of the requested N-Body energy.; The first parenthetical list over i, j, …, k enumerates; molecular fragments included in the computation in 1-indexed,; input-file order, while the second enumerates list over a, b,; …, c enumerates which fragments contribute basis functions to the; computation. For example, (1, 2)@(1, 2, 3, 4) indicates that the; fragments 1 and 2 are explicitly included in the energy computation,; with basis functions from each of fragments 1, 2, 3, & 4 included in",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/glossary_psivariables-1.html:31712,energy,energy,31712,psi4manual/1.4.0/glossary_psivariables-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/glossary_psivariables-1.html,5,['energy'],['energy']
Energy Efficiency,"PLES_LOW_MEMORY¶. Do use low memory option for triples contribution? Note that this option is enabled automatically if the memory requirements of the conventional algorithm would exceed the available resources. Type: boolean; Default: false. Expert¶. CEPA_LEVEL¶. Which coupled-pair method is called? This parameter is used internally by the python driver. Changing its value won’t have any effect on the procedure. Type: string; Default: CEPA(0). COMPUTE_MP4_TRIPLES¶. Do compute MP4 triples contribution?. Type: boolean; Default: false. COMPUTE_TRIPLES¶. Do compute triples contribution?. Type: boolean; Default: true. RUN_CCSD¶. do ccsd rather than qcisd?. Type: boolean; Default: false. RUN_CEPA¶. Is this a CEPA job? This parameter is used internally by the pythond driver. Changing its value won’t have any effect on the procedure. Type: boolean; Default: false. RUN_MP2¶. do only evaluate mp2 energy?. Type: boolean; Default: false. RUN_MP3¶. do only evaluate mp3 energy?. Type: boolean; Default: false. RUN_MP4¶. do only evaluate mp4 energy?. Type: boolean; Default: false. USE_DF_INTS¶. Use 3-index integrals to generate 4-index ERI’s? This keyword is used for testing purposes only. Changing its value will have no effect on the computation. Type: boolean; Default: false. table of contents. FNOCC; General; ACTIVE_NAT_ORBS; BRUECKNER_MAXITER; CC_SCALE_OS; CC_SCALE_SS; CC_TIMINGS; CEPA_NO_SINGLES; CHOLESKY_TOLERANCE; DFCC; DF_BASIS_CC; DIIS_MAX_VECS; DIPMOM; E_CONVERGENCE; MAXITER; MP2_SCALE_OS; MP2_SCALE_SS; NAT_ORBS; OCC_PERCENTAGE; OCC_TOLERANCE; R_CONVERGENCE; SCS_CCSD; SCS_CEPA; SCS_MP2; TRIPLES_LOW_MEMORY. Expert; CEPA_LEVEL; COMPUTE_MP4_TRIPLES; COMPUTE_TRIPLES; RUN_CCSD; RUN_CEPA; RUN_MP2; RUN_MP3; RUN_MP4; USE_DF_INTS. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Appendices; Keywords by Module. © Copyright 2018, The Psi4 Project.; Last updated on Wednesday, 25 July 2018 04:21AM.; Created using Sphinx 1.7.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/autodir_options_c/module__fnocc-1.html:4257,energy,energy,4257,psi4manual/1.2.1/autodir_options_c/module__fnocc-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/autodir_options_c/module__fnocc-1.html,2,['energy'],['energy']
Energy Efficiency,"POINTS_FINAL¶. Number of spherical points in final COSX grid. Type: integer; Default: 110. COSX_SPHERICAL_POINTS_INITIAL¶. Number of spherical points in initial COSX grid. Type: integer; Default: 50. snLinK Algorithm¶. SNLINK_INTS_TOLERANCE¶. Screening criteria for integrals and intermediates in snLinK. Type: conv double; Default: 1.0e-11. SNLINK_RADIAL_POINTS¶. Number of radial points in snLinK grid. Type: integer; Default: 70. SNLINK_RADIAL_SCHEME¶. Radial Scheme for snLinK grid. MURA is default here as it matches the GauXC default option. Type: string; Possible Values: MURA, TREUTLER, EM; Default: MURA. SNLINK_SPHERICAL_POINTS¶. Number of spherical points in snLinK grid. Type: integer; Default: 302. SNLINK_USE_GPU¶. Use GPU for GauXC?. Type: boolean; Default: false. SAD Guess Algorithm¶. SAD_D_CONVERGENCE¶. Convergence criterion for SCF density in the SAD guess, analogous to D_CONVERGENCE. Type: conv double; Default: 1e-5. SAD_E_CONVERGENCE¶. Convergence criterion for SCF energy in the SAD guess, analogous to E_CONVERGENCE. Type: conv double; Default: 1e-5. DFT¶. DFT_ALPHA¶. The DFT Exact-exchange parameter. Type: double; Default: 0.0. DFT_ALPHA_C¶. The DFT Correlation hybrid parameter. Type: double; Default: 0.0. DFT_BASIS_TOLERANCE¶. DFT basis cutoff. Type: conv double; Default: 1.0e-12. DFT_BS_RADIUS_ALPHA¶. Factor for effective BS radius in radial grid. Type: double; Default: 1.0. DFT_DISPERSION_PARAMETERS¶. Parameters defining the dispersion correction. See Table -D Functionals for default values and Table Dispersion Corrections for the order in which parameters are to be specified in this array option. Unused for functionals constructed by user. Type: array; Default: No Default. DFT_GRAC_ALPHA¶. The gradient regularized asymptotic correction alpha value. Type: double; Default: 0.5. DFT_GRAC_BETA¶. The gradient regularized asymptotic correction beta value. Type: double; Default: 40.0. DFT_GRAC_SHIFT¶. The gradient regularized asymptotic correction shift value",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/autodir_options_c/module__scf.html:14200,energy,energy,14200,psi4manual/master/autodir_options_c/module__scf.html,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/module__scf.html,2,['energy'],['energy']
Energy Efficiency,"POLE XZ¶. CISD QUADRUPOLE YY¶. CISD QUADRUPOLE YZ¶. CISD QUADRUPOLE ZZ¶; The six components of the quadrupole [Debye Ang] for the; configuration interaction singles and doubles level of theory and root. CISD TOTAL ENERGY¶. CISD CORRELATION ENERGY¶. CISDT TOTAL ENERGY¶. CISDT CORRELATION ENERGY¶. CISDTQ CORRELATION ENERGY¶. CISDTQ TOTAL ENERGY¶. CIn CORRELATION ENERGY¶. CIn TOTAL ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the labeled configuration interaction level of theory and root.; n is CI order for n > 4. CP-CORRECTED 2-BODY INTERACTION ENERGY¶; The interaction energy [H] considering only two-body interactions,; computed with counterpoise correction.; Related variable UNCP-CORRECTED 2-BODY INTERACTION ENERGY. \[E_{\text{IE}} = E_{dimer} - \sum_{monomer}^{n}{E_{monomer}^{\text{CP}}}\]. CURRENT CORRELATION ENERGY¶; The correlation energy [H] corresponding to the CURRENT ENERGY variable. CURRENT ENERGY¶; The total electronic energy [H] of the most recent stage of a; calculation (frequently overwritten). This is the quantity tracked by; the geometry optimizer. CURRENT REFERENCE ENERGY¶; The total electronic energy [H] of the reference stage corresponding to; the CURRENT ENERGY variable. db_name DATABASE MEAN ABSOLUTE DEVIATION¶; The mean absolute deviation [kcal mol-1] of the requested method; name from the stored reference values for the requested reactions in; database db_name. If no reference is available, this will be a large; and nonsensical value. \[\frac{1}{n}\sum_{rxn}^{n}{| \textsf{\textsl{name}}_{rxn}-\text{REF}_{rxn} | }\]. db_name DATABASE MEAN SIGNED DEVIATION¶; The mean deviation [kcal mol-1] of the requested method name; from the stored reference values for the requested reactions in; database db_name. If no reference is available, this will be a large; and nonsensical value. \[\frac{1}{n}\sum_{rxn}^{n}{\textsf{\textsl{name}}_{rxn}-\text{REF}_{rxn}}\]. db_name DATABASE ROOT-MEAN-SQUARE SIGNED DEVIATION¶; The rms",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/glossary_psivariables-1.html:9848,energy,energy,9848,psi4manual/1.1.0/glossary_psivariables-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/glossary_psivariables-1.html,6,['energy'],['energy']
Energy Efficiency,"POLE X¶. CC DIPOLE Y¶. CC DIPOLE Z¶; The three components of the dipole [Debye] for the requested; coupled cluster level of theory and root. CC QUADRUPOLE XX¶. CC QUADRUPOLE XY¶. CC QUADRUPOLE XZ¶. CC QUADRUPOLE YY¶. CC QUADRUPOLE YZ¶. CC QUADRUPOLE ZZ¶; The six components of the quadrupole [Debye Ang] for the requested; coupled cluster level of theory and root. CCSD TOTAL ENERGY¶. CCSD CORRELATION ENERGY¶. CCSDT TOTAL ENERGY¶. CCSDT CORRELATION ENERGY¶. CCSDTQ TOTAL ENERGY¶. CCSDTQ CORRELATION ENERGY¶. CCn TOTAL ENERGY¶. CCn CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the requested full coupled-cluster (CCSD, CCSDT, up to CCn); level of theory. CCSD(T) TOTAL ENERGY¶. CCSD(T) CORRELATION ENERGY¶. A-CCSD(T) TOTAL ENERGY¶. A-CCSD(T) CORRELATION ENERGY¶. CCSDT(Q) TOTAL ENERGY¶. CCSDT(Q) CORRELATION ENERGY¶. CC(n-1)(n) TOTAL ENERGY¶. CC(n-1)(n) CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the perturbatively corrected coupled-cluster (CCSD(T), a-CCSD(T), CCSDT(Q),; up to CC(n-1)(n) level of theory. CCSDT-1a TOTAL ENERGY¶. CCSDT-1a CORRELATION ENERGY¶. CCSDTQ-1a TOTAL ENERGY¶. CCSDTQ-1a CORRELATION ENERGY¶. CCn-1a TOTAL ENERGY¶. CCn-1a CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the approximate coupled-cluster (CCSD(T)-1a, CCSDT(Q)-1a,; up to CCn-1a) level of theory. CCSDT-1b TOTAL ENERGY¶. CCSDT-1b CORRELATION ENERGY¶. CCSDTQ-1b TOTAL ENERGY¶. CCSDTQ-1b CORRELATION ENERGY¶. CCn-1b TOTAL ENERGY¶. CCn-1b CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the approximate coupled-cluster (CCSD(T)-1b, CCSDT(Q)-1b,; up to CCn-1b) level of theory. CCSDT-3 TOTAL ENERGY¶. CCSDT-3 CORRELATION ENERGY¶. CCSDTQ-3 TOTAL ENERGY¶. CCSDTQ-3 CORRELATION ENERGY¶. CCn-3 TOTAL ENERGY¶. CCn-3 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the approximate",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/glossary_psivariables-1.html:4273,energy,energy,4273,psi4manual/1.1.0/glossary_psivariables-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/glossary_psivariables-1.html,12,['energy'],['energy']
Energy Efficiency,"PRECONDITIONER (CCEOM). LOCAL_WEAKP (CCENERGY). (CCEOM). (CCLAMBDA). (CCRESPONSE). (CCSORT). (CIS). LOCK_OCC (DCFT). LOCK_SINGLET (PSIMRCC). LSE (DETCI). LSE_COLLAPSE (DETCI). LSE_TOLERANCE (DETCI). M. M_FILE (TRANSQT). MADMP2_SLEEP (DFMP2). MAT_NUM_COLUMN_PRINT (GLOBALS). MATRIX_SIZE (PLUGIN_TEST_MATRIX), [1]. MAX_BUCKETS (TRANSQT). MAX_DISP_G_CONVERGENCE (OPTKING). MAX_ENERGY_G_CONVERGENCE (OPTKING). MAX_FORCE_G_CONVERGENCE (OPTKING). MAX_MOGRAD_CONVERGENCE (OMP2). MAX_NUM_VECS (DETCI). MAXITER (CCENERGY). (CCEOM). (CCLAMBDA). (CCRESPONSE). (CIS). (DCFT). (DETCI). (LMP2). (MCSCF). (PSIMRCC). (SAPT). (SCF). memory. MEMORY (ADC). (LMP2). (PLUGIN_DFADC), [1]. (PLUGIN_MP2), [1]. (PLUGIN_TEST_MATRIX), [1]. method alias; . adding new. MIXED (DETCI). MIXED4 (DETCI). Mk-MRCC. MKL_NUM_THREADS. MO_MAXITER (OMP2). MO_READ (MCSCF). (OMP2). MO_RELAX (DCFT). MO_STEP_MAX (OMP2). MO_WRITE (OMP2). MODE (TRANSQT). MODULE (CPHF). (PLUGIN_FOCK), [1]. molden() (in module driver). molecule; . PubChem. charge. multiple fragments. multiple in input file. multiplicity. no_reorient. setting keywords. specification. symmetry. units. molutil (module). MOM_OCC (SCF). MOM_START (SCF). MOM_VIR (SCF). MOORDER (TRANSQT). MP2; . density-fitting. MP2.5CORRELATIONENERGY. MP2.5TOTALENERGY. MP2_AMPS_PRINT (CCENERGY). MP2_CCSD_METHOD (PSIMRCC). MP2_GUESS (PSIMRCC). MP2_OS_SCALE (CCENERGY). (DFMP2). (LMP2). (MP2). (OMP2). MP2_SS_SCALE (CCENERGY). (DFMP2). (LMP2). (MP2). (OMP2). MP2CORRELATIONENERGY. MP2R12A (TRANSQT). MP2TOTALENERGY. MP3CORRELATIONENERGY. MP3TOTALENERGY. MPN (DETCI). MPN_ORDER_SAVE (DETCI). MPN_SCHMIDT (DETCI). MPN_WIGNER (DETCI). MPnCORRELATIONENERGY. MPnTOTALENERGY. MRCC. MRCC_LEVEL (MRCC). MRCC_METHOD (MRCC). MRCC_NUM_SINGLET_ROOTS (MRCC). MRCC_NUM_TRIPLET_ROOTS (MRCC). MRCC_OMP_NUM_THREADS (MRCC). MRCC_RESTART (MRCC). MS0 (DETCI). multiplicity; . molecule. multireference. N. n_body() (in module wrappers). name() (PubChemObj method). NAT_ORBS (OMP2). (SAPT). NAT_ORBS_T2 (SAPT). NAT_O",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/genindex.html:17600,charge,charge,17600,psi4manual/4.0b2/genindex.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/genindex.html,1,['charge'],['charge']
Energy Efficiency,"PSI Variables, LIBSAPT_SOLVER. Warning; In rare cases with systems having a high degree of symmetry,; Psi4 gives (very obviously) wrong answers for SAPT computations; when the specification is in Z-matrix format. Use a Cartesian representation; to avoid this problem. Caution; In early versions (notably Psi4 alpha circa 2011; and before), frozen core was implemented incompletely and for; only selected terms. Comparisons with papers published using early; Psi4 SAPT code may show discrepancies of 0.01-0.10 kcal/mol in; individual terms, particularly and . Caution; January 28th 2016, the default for all NAT_ORBS options; was changed to true. Hence the code now by default uses natural; orbital truncation to speed up the evaluation of energy terms; wherever possible, according to literature recommendations.; In early July 2016, some total sapt energy psivars were renamed. Symmetry-adapted perturbation theory (SAPT) provides a means of directly; computing the noncovalent interaction between two molecules, that is, the; interaction energy is determined without computing the total energy of the; monomers or dimer. In addition, SAPT provides a decomposition of the; interaction energy into physically meaningful components: i.e.,; electrostatic, exchange, induction, and dispersion terms. In SAPT, the; Hamiltonian of the dimer is partitioned into contributions from each; monomer and the interaction. Here, the Hamiltonian is written as a sum of the usual monomer Fock; operators, , the fluctuation potential of each monomer, , and the; interaction potential, . The monomer Fock operators, , are; treated as the zeroth-order Hamiltonian and the interaction energy is; evaluated through a perturbative expansion of , , and .; Through first-order in , electrostatic and exchange interactions are; included; induction and dispersion first appear at second-order in . For; a complete description of SAPT, the reader is referred to the excellent; review by Jeziorski, Moszynski, and Szalewicz [Je",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/sapt-1.html:1243,adapt,adapted,1243,psi4manual/1.0.0/sapt-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/sapt-1.html,6,"['adapt', 'energy']","['adapted', 'energy']"
Energy Efficiency,"PSI4 built from source, and anaconda or miniconda has; already been installed (instructions at Quick Installation),; dkh can be obtained through conda install dkh -c psi4.; Then enable it as a feature with ENABLE_dkh,; hint its location with CMAKE_PREFIX_PATH,; and rebuild PSI4 to detect dkh and activate dependent code. Previous bullet had details. To build PSI4 from source and use; dkh from conda without thinking, consult sec:condapsi4dev. To remove a conda installation, conda remove dkh. Source. If using PSI4 built from source and you want dkh built from; from source also,; enable it as a feature with ENABLE_dkh,; and let the build system fetch and build it and activate dependent code. Input¶; For all electron calculations one can use the Douglas-Kroll-Hess (DKH); Hamiltonian to take into account scalar relativistic effects.; Minimal input for DKH single-point computation looks like this:; 1; 2; 3; 4; 5; 6; 7; 8molecule {; Mg; }. set basis aug-cc-pvdz-dk; set relativistic dkh. energy('scf'). By default a 2nd-order DKH calculation is performed. To change the default; order use the DKH_ORDER option. The version of the code found in; PSI4 is capable of up to 4th-order DKH calculations. Keywords¶. RELATIVISTIC¶. Relativistic Hamiltonian type. Type: string; Possible Values: NO, X2C; Default: NO. DKH_ORDER¶. Order of Douglas-Kroll-Hess. Type: integer; Default: 2. Reference¶; When using this code please make reference to the appropriate following paper:. “The Generalized Douglas-Kroll Transformation,” A. Wolf,; M. Reiher, and B. A. Hess, J. Chem. Phys. 117, 9215 (2002).; (doi: 10.1063/1.1515314). How to configure dkh for building Psi4¶; Role and Dependencies. Role — In PSI4, DKH is a library that provides additional; quantum chemical capabilities (relativistic effects).; Downstream Dependencies — PSI4 (\(\Leftarrow\) optional) dkh; Upstream Dependencies — dkh \(\Leftarrow\) Fortran. CMake Variables. ENABLE_dkh — CMake variable toggling whether Psi4 builds with dkh; CMAKE_",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/dkh-1.html:1510,energy,energy,1510,psi4manual/1.2.1/dkh-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/dkh-1.html,4,['energy'],['energy']
Energy Efficiency,"PSI4 for the computation of excited states,; see ADC capabilities of Psi4.; The methods are available via an interface to the adcc python module.; After a more general introduction, specific aspects of the implementation will be highlighted; in section Interface to adcc. ADC capabilities of Psi4¶. Method; References; Exc. Energies; Props; Supported values for kind keyword. ADC(1); RHF, UHF; yes; yes; any, singlet, triplet, spin_flip. ADC(2); RHF, UHF; yes; yes; any, singlet, triplet, spin_flip. ADC(2)-x; RHF, UHF; yes; yes; any, singlet, triplet, spin_flip. ADC(3); RHF, UHF; yes; yes | any, singlet, triplet, spin_flip. CVS-ADC(1); RHF, UHF; yes; yes | any, singlet, triplet. CVS-ADC(2); RHF, UHF; yes; yes; any, singlet, triplet. CVS-ADC(2)-x; RHF, UHF; yes; yes; any, singlet, triplet. CVS-ADC(3); RHF, UHF; yes; yes; any, singlet, triplet. The leftmost column of table ADC capabilities of Psi4 provides the supported ADC methods.; If only excitation energies are desired, one can simply pass one; of the listed method strings to the function energy().; For example, energy('adc(2)-x') will compute; excitation energies at ADC(2)-x level.; Properties such as oscillator strengths, transition or state dipole moments; are available by calling the function properties(); with appropriate arguments.; Most commonly users will want to compute at least oscillator strengths; along with the excitation energies,; resulting in a call like properties('adc(2)', properties=[""oscillator_strength""]). Running ADC calculations¶; Section author: Michael F. Herbst; Running an ADC calculation with PSI4 requires; the call to properties() as discussed above; as well as one or more mandatory keyword arguments.; The most important keyword argument is ROOTS_PER_IRREP,; which is an array with the number of excited states desired; for each irreducible representation. Most ADC methods; are only supported at C1 symmetry at the moment, such that; this option should in most cases be set to an array with a si",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/adc.html:4236,energy,energy,4236,psi4manual/1.7.x/adc.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/adc.html,4,['energy'],['energy']
Energy Efficiency,"PSI4 suite.; As seen in the neon dimer example from the tutorial section,; the nbody() wrapper provides automatic computation of; counterpoise-corrected interaction energies between two molecules. For; example,. PSIthonPsiAPIenergy('mp2', bsse_type='cp'). psi4.energy('mp2', bsse_type='cp'). will compute the counterpoise-corrected density-fitted MP2 interaction energy; between two molecules.; PSI4 also provides the cbs() wrapper,; which automatically computes a complete-basis-set extrapolation (and; automatically sets up the computations with different basis sets required to; do the extrapolation). For example,. PSIthonPsiAPI# all equivalent. energy('mp2', corl_basis='cc-pv[dt]z', corl_scheme='corl_xtpl_helgaker_2'). energy('mp2/cc-pv[dt]z'). # all equivalent. psi4.energy('mp2', corl_basis='cc-pv[dt]z', corl_scheme='corl_xtpl_helgaker_2'). psi4.energy('mp2/cc-pv[dt]z'). will compute a 2-point Helgaker extrapolation of the correlation energy; using the cc-pVDZ and cc-pVTZ basis sets (with method MP2) and add this; extrapolated correlation energy to the Hartree–Fock energy in the; largest basis (cc-pVTZ). cbs() can; be configured behind-the-scenes with explicit arguments, as in the; first example, or the convenience syntax of the equivalent second; example can be used.; Another very useful and powerful feature of PSI4 is the ability; to compute results on entire databases of molecules at a time,; as provided by the database() wrapper. For example,. PSIthonPsiAPIdatabase('mp2', 'S22', cp=1, benchmark='S22B'). psi4.wrapper_database.database('mp2', 'S22', cp=1, benchmark='S22B'). will perform DF-MP2 counterpoise-corrected interaction energies; (cp=1) on all members of Hobza’s S22 database set of van der Waals; dimers, and then compare the results against the S22B benchmark energies.; Built-in databases include S22, A24, HTBH, HBC6, HSG, S22by5, S66, JSCH,; NCB31, S66by8, and NBC10, among others.; These wrapper functions are discussed separately in; Psithon Functions: Invo",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/psithoninput.html:17050,energy,energy,17050,psi4manual/master/psithoninput.html,https://psicode.org,https://psicode.org/psi4manual/master/psithoninput.html,3,['energy'],['energy']
Energy Efficiency,"PSI4; executable. That is, the top line of bin/psi4 is something like; #!/path/to/miniconda/envs/p4deps/bin/python3.5, and that’s the Python; through which PSI4 is running, rather than the Python of which python.; To use a different Python with PSI4 in the short term, just; path/to/desired/python psi4 on the command line to override the; shebang line. To use a different Python with PSI4 in the long term,; edit the shebang line.; If you’re using PSI4 as a Python module, then PSI4 is running; the Python of which python. How to fix “undefined symbol: _Py_FalseStruct”¶; You’re probably loading a Py3-compiled Psi4 in Py2. Switch interpreters; and re-run. A python of proper Py2 or Py3-ness is baked into the PSI4; “executable”, so you’ll see this error only for Psi4 as Python module. How to use gdb and lldb with Psi4¶; Debugging PSI4 has gotten a little confusing now that it’s running through Python. Here’s the syntax; 1; 2; 3>>> cd {objdir}; >>> lldb -- python stage/bin/psi4 ../tests/tu1-h2o-energy/input.dat; >>> (lldb) run. 1; 2; 3>>> cd {objdir}; >>> gdb --args python stage/bin/psi4 ../tests/tu1-h2o-energy/input.dat; >>> (gdb) run. How to see the actual compiling commands (or errors) with cmake¶; CMake by default hides a lot of useful debugging information to make the; compilation cleaner. Issue make VERBOSE=1 to display the full; compilation commands and errors. How to highlight git merge conflicts in vi¶; Edit your ~/.vimrc file to include the lines below. Hitting the F7; key will toggle highlighting of git’s conflict markers.; >>> cat ~/.vimrc; set hlsearch; map <F7> :/\(<<<<<<<\\|=======\\|>>>>>>>\)<CR>. How to handle “runtime library may be hidden” when building with Anaconda Python¶; When building against Ana/Miniconda python (e.g., cmake; -DPYTHON_EXECUTABLE=/path/to/conda/bin/python), the warning below often; appears. It is harmless, proceed.; CMake Warning at src/bin/psi4/CMakeLists.txt:58 (add_executable):; Cannot generate a safe runtime search path for target",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/build_planning-1.html:45544,energy,energy,45544,psi4manual/1.3.2/build_planning-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/build_planning-1.html,2,['energy'],['energy']
Energy Efficiency,"PT (Expert) — Do compute third-order corrections?. Type: boolean; Default: false. DO_TRIPLETS (CPHF); CPHF — Do triplet states? Default true. Type: boolean; Default: true. DOCC (GLOBALS); GLOBALS — An array containing the number of doubly-occupied orbitals per irrep (in Cotton order). Type: array; Default: No Default. DOCC (MCSCF); MCSCF — The number of doubly occupied orbitals, per irrep. Type: array; Default: No Default. DOMAIN_PRINT (CIS); CIS — Do print the domains?. Type: boolean; Default: false. DOMAIN_PRINT_EXIT (LMP2); LMP2 — Do exit after printing the domains?. Type: boolean; Default: false. DOMAINS (CIS); CIS —. Type: array; Default: No Default. E3_SCALE (OMP3); OMP3 — Scaling value for 3rd order energy correction (S. Grimme, Vol. 24, pp. 1529, J. Comput. Chem.). Type: double; Default: 0.25. E_CONVERGENCE (CCEOM); CCEOM — Convergence criterion for excitation energy (change) in the Davidson algorithm for CC-EOM. Type: conv double; Default: 1e-8. E_CONVERGENCE (DETCI); DETCI — Convergence criterion for energy. Type: conv double; Default: 1e-6. E_CONVERGENCE (LMP2); LMP2 — Convergence criterion for energy (change). Type: conv double; Default: 1e-7. E_CONVERGENCE (MCSCF); MCSCF — Convergence criterion for energy. Type: conv double; Default: 1e-8. E_CONVERGENCE (MRCC); MRCC — This becomes tol (option #16) in fort.56. Type: conv double; Default: 1e-8. E_CONVERGENCE (OMP2); OMP2 — Convergence criterion for energy. Type: conv double; Default: 1e-8. E_CONVERGENCE (OMP3); OMP3 — Convergence criterion for energy. Type: conv double; Default: 1e-8. E_CONVERGENCE (PSIMRCC); PSIMRCC — Convergence criterion for energy. Type: conv double; Default: 1e-9. E_CONVERGENCE (SAPT); SAPT — Convergence criterion for energy (change) in the SAPT term during solution of the CPHF equations. Type: conv double; Default: 1e-10. E_CONVERGENCE (SCF); SCF — Convergence criterion for SCF energy. See Table SCF Convergence & Algorithm for default convergence criteria for different calculation ty",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/autodoc_glossary_options_c-1.html:35774,energy,energy,35774,psi4manual/4.0b3/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodoc_glossary_options_c-1.html,2,['energy'],['energy']
Energy Efficiency,"PT IND20,R ENERGY; SAPT IND20,U ENERGY; SAPT IND22 ENERGY; SAPT IND30,R ENERGY; SAPT MP2 CORRELATION ENERGY; SAPT SAME-SPIN DISP20 ENERGY; SAPT SAME-SPIN EXCH-DISP20 ENERGY; SAPT TOTAL ENERGY; SAPT0 DISP ENERGY; SAPT0 ELST ENERGY; SAPT0 EXCH ENERGY; SAPT0 IND ENERGY; SAPT0 TOTAL ENERGY; SAPT2 DISP ENERGY; SAPT2 ELST ENERGY; SAPT2 EXCH ENERGY; SAPT2 IND ENERGY; SAPT2 TOTAL ENERGY; SAPT2+ DISP ENERGY; SAPT2+ ELST ENERGY; SAPT2+ EXCH ENERGY; SAPT2+ IND ENERGY; SAPT2+ TOTAL ENERGY; SAPT2+(3) DISP ENERGY; SAPT2+(3) ELST ENERGY; SAPT2+(3) EXCH ENERGY; SAPT2+(3) IND ENERGY; SAPT2+(3) TOTAL ENERGY; SAPT2+(3)(CCD) DISP ENERGY; SAPT2+(3)(CCD) ELST ENERGY; SAPT2+(3)(CCD) EXCH ENERGY; SAPT2+(3)(CCD) IND ENERGY; SAPT2+(3)(CCD) TOTAL ENERGY; SAPT2+(3)(CCD)DMP2 DISP ENERGY; SAPT2+(3)(CCD)DMP2 ELST ENERGY; SAPT2+(3)(CCD)DMP2 EXCH ENERGY; SAPT2+(3)(CCD)DMP2 IND ENERGY; SAPT2+(3)(CCD)DMP2 TOTAL ENERGY; SAPT2+(3)DMP2 DISP ENERGY; SAPT2+(3)DMP2 ELST ENERGY; SAPT2+(3)DMP2 EXCH ENERGY; SAPT2+(3)DMP2 IND ENERGY; SAPT2+(3)DMP2 TOTAL ENERGY; SAPT2+(CCD) DISP ENERGY; SAPT2+(CCD) ELST ENERGY; SAPT2+(CCD) EXCH ENERGY; SAPT2+(CCD) IND ENERGY; SAPT2+(CCD) TOTAL ENERGY; SAPT2+(CCD)DMP2 DISP ENERGY; SAPT2+(CCD)DMP2 ELST ENERGY; SAPT2+(CCD)DMP2 EXCH ENERGY; SAPT2+(CCD)DMP2 IND ENERGY; SAPT2+(CCD)DMP2 TOTAL ENERGY; SAPT2+3 DISP ENERGY; SAPT2+3 ELST ENERGY; SAPT2+3 EXCH ENERGY; SAPT2+3 IND ENERGY; SAPT2+3 TOTAL ENERGY; SAPT2+3(CCD) DISP ENERGY; SAPT2+3(CCD) ELST ENERGY; SAPT2+3(CCD) EXCH ENERGY; SAPT2+3(CCD) IND ENERGY; SAPT2+3(CCD) TOTAL ENERGY; SAPT2+3(CCD)DMP2 DISP ENERGY; SAPT2+3(CCD)DMP2 ELST ENERGY; SAPT2+3(CCD)DMP2 EXCH ENERGY; SAPT2+3(CCD)DMP2 IND ENERGY; SAPT2+3(CCD)DMP2 TOTAL ENERGY; SAPT2+3DMP2 DISP ENERGY; SAPT2+3DMP2 ELST ENERGY; SAPT2+3DMP2 EXCH ENERGY; SAPT2+3DMP2 IND ENERGY; SAPT2+3DMP2 TOTAL ENERGY; SAPT2+DMP2 DISP ENERGY; SAPT2+DMP2 ELST ENERGY; SAPT2+DMP2 EXCH ENERGY; SAPT2+DMP2 IND ENERGY; SAPT2+DMP2 TOTAL ENERGY; SSAPT0 DISP ENERGY; SSAPT0 ELST ENERGY; SSAPT0 EXCH ENERGY; SSAPT0 I",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/autodir_psivariables/module__sapt-1.html:2004,ENERGY,ENERGY,2004,psi4manual/1.4.0/autodir_psivariables/module__sapt-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_psivariables/module__sapt-1.html,9,['ENERGY'],['ENERGY']
Energy Efficiency,"PT""),; ""RIFIT"", core.get_global_option(""BASIS"")); dimer_wfn.set_basisset(""DF_BASIS_SAPT"", aux_basis); if core.get_global_option(""DF_BASIS_ELST"") == """":; dimer_wfn.set_basisset(""DF_BASIS_ELST"", aux_basis); else:; aux_basis = core.BasisSet.build(dimer_wfn.molecule(), ""DF_BASIS_ELST"",; core.get_global_option(""DF_BASIS_ELST""),; ""RIFIT"", core.get_global_option(""BASIS"")); dimer_wfn.set_basisset(""DF_BASIS_ELST"", aux_basis). core.print_out('\n'); p4util.banner(name.upper()); core.print_out('\n'); e_sapt = core.sapt(dimer_wfn, monomerA_wfn, monomerB_wfn). from psi4.driver.qcdb.psivardefs import sapt_psivars; p4util.expand_psivars(sapt_psivars()); optstash.restore(); for term in ['ELST', 'EXCH', 'IND', 'DISP', 'TOTAL']:; core.set_variable(' '.join(['SAPT', term, 'ENERGY']),; core.get_variable(' '.join([name.upper(), term, 'ENERGY']))); core.set_variable('CURRENT ENERGY', core.get_variable('SAPT TOTAL ENERGY')). return dimer_wfn. def run_sapt_ct(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a charge-transfer SAPT calcuation of any level. """"""; optstash = p4util.OptionsState(; ['SCF', 'SCF_TYPE']). if 'ref_wfn' in kwargs:; core.print_out('\nWarning! Argument ref_wfn is not valid for sapt computations\n'). # Alter default algorithm; if not core.has_option_changed('SCF', 'SCF_TYPE'):; core.set_local_option('SCF', 'SCF_TYPE', 'DF'). # Get the molecule of interest; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; sapt_dimer = kwargs.pop('molecule', core.get_active_molecule()); else:; core.print_out('Warning! SAPT argument ""ref_wfn"" is only able to use molecule information.'); sapt_dimer = ref_wfn.molecule(); sapt_dimer.update_geometry() # make sure since mol from wfn, kwarg, or P::e; sapt_dimer.fix_orientation(True); sapt_dimer.fix_com(True). # Shifting to C1 so we need to copy the active molecule; if sapt_dimer.schoenflies_symbol() != 'c1':; core.print_out(' SAPT does not make use of molecular symmetry, further calculations in C1 point group.\n'",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/procrouting/proc.html:99858,charge,charge-transfer,99858,psi4manual/1.1.0/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/procrouting/proc.html,1,['charge'],['charge-transfer']
Energy Efficiency,"PT', 'E_CONVERGENCE', 10e-10); PsiMod.set_local_option('SAPT', 'D_CONVERGENCE', 10e-10); if (name.lower() == 'sapt0-ct'):; PsiMod.set_local_option('SAPT', 'SAPT_LEVEL', 'SAPT0'); elif (name.lower() == 'sapt2-ct'):; PsiMod.set_local_option('SAPT', 'SAPT_LEVEL', 'SAPT2'); elif (name.lower() == 'sapt2+-ct'):; PsiMod.set_local_option('SAPT', 'SAPT_LEVEL', 'SAPT2+'); elif (name.lower() == 'sapt2+(3)-ct'):; PsiMod.set_local_option('SAPT', 'SAPT_LEVEL', 'SAPT2+3'); PsiMod.set_local_option('SAPT', 'DO_THIRD_ORDER', False); elif (name.lower() == 'sapt2+3-ct'):; PsiMod.set_local_option('SAPT', 'SAPT_LEVEL', 'SAPT2+3'); PsiMod.set_local_option('SAPT', 'DO_THIRD_ORDER', True); PsiMod.print_out('\n'); banner('SAPT Charge Transfer'); PsiMod.print_out('\n'). PsiMod.print_out('\n'); banner('Dimer Basis SAPT'); PsiMod.print_out('\n'); PsiMod.IO.change_file_namespace(121, 'monomerA', 'dimer'); PsiMod.IO.change_file_namespace(122, 'monomerB', 'dimer'); e_sapt = PsiMod.sapt(); CTd = PsiMod.get_variable('SAPT CT ENERGY'). PsiMod.print_out('\n'); banner('Monomer Basis SAPT'); PsiMod.print_out('\n'); PsiMod.IO.change_file_namespace(121, 'monomerAm', 'dimer'); PsiMod.IO.change_file_namespace(122, 'monomerBm', 'dimer'); e_sapt = PsiMod.sapt(); CTm = PsiMod.get_variable('SAPT CT ENERGY'); CT = CTd - CTm. PsiMod.print_out('\n\n'); PsiMod.print_out(' SAPT Charge Transfer Analysis\n'); PsiMod.print_out(' -----------------------------------------------------------------------------\n'); line1 = ' SAPT Induction (Dimer Basis) %10.4lf mH %10.4lf kcal mol^-1\n' % (CTd * 1000.0, CTd * physconst.psi_hartree2kcalmol); line2 = ' SAPT Induction (Monomer Basis) %10.4lf mH %10.4lf kcal mol^-1\n' % (CTm * 1000.0, CTm * physconst.psi_hartree2kcalmol); line3 = ' SAPT Charge Transfer %10.4lf mH %10.4lf kcal mol^-1\n\n' % (CT * 1000.0, CT * physconst.psi_hartree2kcalmol); PsiMod.print_out(line1); PsiMod.print_out(line2); PsiMod.print_out(line3); PsiMod.set_variable('SAPT CT ENERGY', CT). molecule.reset_point_gr",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/_modules/proc.html:31648,ENERGY,ENERGY,31648,psi4manual/4.0b2/_modules/proc.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/proc.html,1,['ENERGY'],['ENERGY']
Energy Efficiency,"PT(DFT) aug-cc-pVDZ interaction energy between Ne and Ar atoms. dft-grad1; DF-BP86-D2 cc-pVDZ frozen core gradient of S22 HCN update ref gradient due to new BraggSlater radii. cbs-parser; mtd/basis syntax examples. options1; check all variety of options parsing. nbody-multi-level; Multilevel computation of water trimer energy (geometry from J. Chem. Theory Comput. 11, 2126-2136 (2015)). dct-grad3; Restricted DF-DCT ODC-12 gradient for ethylene with cc-pVDZ/cc-pVDZ-RI standard/auxiliary basis set. dfrasscf-sp; 6-31G** H2O Test RASSCF Energy Point will default to only singles and doubles in the active space. sapt-dft2; SAPT(DFT) aug-cc-pVDZ computation for the water dimer interaction energy. dfmp2-grad2; DF-MP2 cc-pVDZ gradient for the NO molecule. dfccsdat2; DF-A-CCSD(T) cc-pVDZ energy for the NH molecule. psithon2; Accesses basis sets, databases, plugins, and executables in non-install locations. dfccd-grad1; DF-CCSD cc-pVDZ gradients for the H2O molecule. dct9; UHF-ODC-12 and RHF-ODC-12 single-point energy for H2O. This performs a simultaneous update of orbitals and cumulants, using DIIS extrapolation. Four-virtual integrals are handled in the AO basis, where integral transformation is avoided. In the next RHF-ODC-12 computation, AO_BASIS=NONE is used, where four-virtual integrals are transformed into MO basis. density-screen-1; RHF Density Matrix based-Integral Screening Test for water. omp2-5; SOS-OMP2 cc-pVDZ geometry optimization for the H2O molecule. fd-freq-energy-large; SCF DZ finite difference frequencies by energies for C4NH4. scf5; Test of all different algorithms and reference types for SCF, on singlet and triplet O2, using the cc-pVTZ basis set. dfmp2-2; Density fitted MP2 energy of H2, using density fitted reference and automatic looping over cc-pVDZ and cc-pVTZ basis sets. Results are tabulated using the built in table functions by using the default options and by specifiying the format. cbs-xtpl-freq; Various gradients for a strained helium dimer and ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/autodoc_testsuite_corepsi4.html:15820,energy,energy,15820,psi4manual/1.7.x/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/autodoc_testsuite_corepsi4.html,2,['energy'],['energy']
Energy Efficiency,"PT. SAPT HF(2) ENERGY BC(0)¶; The Hartree–Fock energy [E_h] of subsystems B and C implemented for F/I-SAPT. SAPT HF(2) ENERGY A(0)¶; The Hartree–Fock energy [E_h] of subsystem A implemented for F/I-SAPT. SAPT HF(2) ENERGY B(0)¶; The Hartree–Fock energy [E_h] of subsystem B implemented for F/I-SAPT. SAPT HF(2) ENERGY AC(HF)¶; The Hartree–Fock localized energy [E_h] of subsystems A and C implemented for F/I-SAPT. SAPT HF(2) ENERGY BC(HF)¶; The Hartree–Fock localized energy [E_h] of subsystems B and C implemented for F/I-SAPT. SAPT HF(2) ENERGY AB(HF)¶; The Hartree–Fock localized energy [E_h] of subsystems A and B implemented for F/I-SAPT. SAPT HF(2) ENERGY A(HF)¶; The Hartree–Fock localized energy [E_h] of subsystem A implemented for F/I-SAPT. SAPT HF(2) ENERGY B(HF)¶; The Hartree–Fock localized energy [E_h] of subsystem B implemented for F/I-SAPT. SAPT HF(2) ENERGY C¶; The Hartree–Fock energy [E_h] of subsystem C implemented for F/I-SAPT. SAPT HF(2) ENERGY HF¶; The FI-SAPT Hartree–Fock interaction energy [E_h] implemented for F/I-SAPT. SAPT ELST12,R ENERGY¶; An electrostatics-classified SAPT term energy [E_h] implemented for SAPT2. SAPT EXCH11(S^2) ENERGY¶. SAPT EXCH12(S^2) ENERGY¶; An exchange-classified SAPT term energy [E_h] implemented for SAPT2. SAPT IND22 ENERGY¶. SAPT EXCH-IND22 ENERGY¶; An induction-classified SAPT term energy [E_h] implemented for SAPT2. SAPT DISP21 ENERGY¶; A dispersion-classified SAPT term energy [E_h] implemented for SAPT2+. SAPT DISP22(SDQ) ENERGY¶. SAPT DISP22(T) ENERGY¶. SAPT EST.DISP22(T) ENERGY¶; Dispersion-classified MBPT-based SAPT term energy [E_h] implemented for SAPT2+. SAPT DISP2(CCD) ENERGY¶. SAPT DISP22(S)(CCD) ENERGY¶. SAPT DISP22(T)(CCD) ENERGY¶. SAPT EST.DISP22(T)(CCD) ENERGY¶; Dispersion-classified coupled-cluster-based SAPT term energy [E_h] implemented for SAPT2+. SAPT ELST13,R ENERGY¶; An electrostatics-classified SAPT term energy [E_h] implemented for SAPT2+(3). SAPT IND30,R ENERGY¶. SAPT IND-DISP30 ENERGY¶. SAPT EXCH-",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/glossary_psivariables.html:47925,energy,energy,47925,psi4manual/1.7.x/glossary_psivariables.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/glossary_psivariables.html,4,['energy'],['energy']
Energy Efficiency,"PT0 exchange-scaling with F-SAPT. Type: boolean; Default: false. STABILITY_ADD_VECTORS (DCT)¶DCT (Expert) — The number of vectors that can be added simultaneously into the subspace for Davidson’s diagonalization in stability check. Type: integer; Default: 20. STABILITY_ANALYSIS (SCF)¶SCF — Whether to perform stability analysis after convergence. NONE prevents analysis being performed. CHECK will print out the analysis of the wavefunction stability at the end of the computation. FOLLOW will perform the analysis and, if a totally symmetric instability is found, will attempt to follow the eigenvector and re-run the computations to find a stable solution. Type: string; Possible Values: NONE, CHECK, FOLLOW; Default: NONE. STABILITY_AUGMENT_SPACE_TOL (DCT)¶DCT (Expert) — The value of the rms of the residual in Schmidt orthogonalization which is used as a threshold for augmenting the vector subspace in stability check. Type: conv double; Default: 0.1. STABILITY_CHECK (DCT)¶DCT (Expert) — Performs stability analysis of the DCT energy. Type: boolean; Default: false. STABILITY_CONVERGENCE (DCT)¶DCT (Expert) — Controls the convergence of the Davidson’s diagonalization in stability check. Type: conv double; Default: 1e-4. STABILITY_MAX_SPACE_SIZE (DCT)¶DCT (Expert) — The maximum size of the subspace for the stability check. The program will terminate if this parameter is exceeded and the convergence (STABILITY_CONVERGENCE) is not satisfied. Type: integer; Default: 200. STABILITY_N_EIGENVALUES (DCT)¶DCT (Expert) — The number of Hessian eigenvalues computed during the stability check. Type: integer; Default: 3. STABILITY_N_GUESS_VECTORS (DCT)¶DCT (Expert) — The number of guess vectors used for Davidson’s diagonalization in stability check. Type: integer; Default: 20. STEP_TYPE (OPTKING)¶OPTKING — Geometry optimization step type, either Newton-Raphson or Rational Function Optimization. Type: string; Possible Values: RFO, NR, SD, LINESEARCH_STATIC; Default: RFO. SUMMATION_FIELDS (P",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/autodoc_glossary_options_c-1.html:220860,energy,energy,220860,psi4manual/1.4.0/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodoc_glossary_options_c-1.html,5,['energy'],['energy']
Energy Efficiency,"PT0 exchange-scaling with F-SAPT. Type: boolean; Default: false. STABILITY_ADD_VECTORS (DCT)¶DCT (Expert) — The number of vectors that can be added simultaneously into the subspace for Davidson’s diagonalization in stability check. Type: integer; Default: 20. STABILITY_ANALYSIS (SCF)¶SCF — Whether to perform stability analysis after convergence. NONE prevents analysis being performed. CHECK will print out the analysis of the wavefunction stability at the end of the computation. FOLLOW will perform the analysis and, if a totally symmetric instability is found, will attempt to follow the eigenvector and re-run the computations to find a stable solution. Type: string; Possible Values: NONE, CHECK, FOLLOW; Default: NONE. STABILITY_AUGMENT_SPACE_TOL (DCT)¶DCT (Expert) — The value of the rms of the residual in Schmidt orthogonalization which is used as a threshold for augmenting the vector subspace in stability check. Type: conv double; Default: 0.1. STABILITY_CHECK (DCT)¶DCT (Expert) — Performs stability analysis of the DCT energy. Type: boolean; Default: false. STABILITY_CONVERGENCE (DCT)¶DCT (Expert) — Controls the convergence of the Davidson’s diagonalization in stability check. Type: conv double; Default: 1e-4. STABILITY_MAX_SPACE_SIZE (DCT)¶DCT (Expert) — The maximum size of the subspace for the stability check. The program will terminate if this parameter is exceeded and the convergence (STABILITY_CONVERGENCE) is not satisfied. Type: integer; Default: 200. STABILITY_N_EIGENVALUES (DCT)¶DCT (Expert) — The number of Hessian eigenvalues computed during the stability check. Type: integer; Default: 3. STABILITY_N_GUESS_VECTORS (DCT)¶DCT (Expert) — The number of guess vectors used for Davidson’s diagonalization in stability check. Type: integer; Default: 20. STEP_TYPE (OPTKING)¶OPTKING — Geometry optimization step type, either Newton-Raphson or Rational Function Optimization. Type: string; Possible Values: RFO, P_RFO, NR, SD, LINESEARCH; Default: RFO. SUMMATION_FIELDS (P",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/autodoc_glossary_options_c.html:226892,energy,energy,226892,psi4manual/1.7.x/autodoc_glossary_options_c.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/autodoc_glossary_options_c.html,3,['energy'],['energy']
Energy Efficiency,"PT0 exchange-scaling with F-SAPT. Type: boolean; Default: false. STABILITY_ADD_VECTORS (DCT)¶DCT (Expert) — The number of vectors that can be added simultaneously into the subspace for Davidson’s diagonalization in stability check. Type: integer; Default: 20. STABILITY_ANALYSIS (SCF)¶SCF — Whether to perform stability analysis after convergence. NONE prevents analysis being performed. CHECK will print out the analysis of the wavefunction stability at the end of the computation. FOLLOW will perform the analysis and, if a totally symmetric instability is found, will attempt to follow the eigenvector and re-run the computations to find a stable solution. Type: string; Possible Values: NONE, CHECK, FOLLOW; Default: NONE. STABILITY_AUGMENT_SPACE_TOL (DCT)¶DCT (Expert) — The value of the rms of the residual in Schmidt orthogonalization which is used as a threshold for augmenting the vector subspace in stability check. Type: conv double; Default: 0.1. STABILITY_CHECK (DCT)¶DCT (Expert) — Performs stability analysis of the DCT energy. Type: boolean; Default: false. STABILITY_CONVERGENCE (DCT)¶DCT (Expert) — Controls the convergence of the Davidson’s diagonalization in stability check. Type: conv double; Default: 1e-4. STABILITY_MAX_SPACE_SIZE (DCT)¶DCT (Expert) — The maximum size of the subspace for the stability check. The program will terminate if this parameter is exceeded and the convergence (STABILITY_CONVERGENCE) is not satisfied. Type: integer; Default: 200. STABILITY_N_EIGENVALUES (DCT)¶DCT (Expert) — The number of Hessian eigenvalues computed during the stability check. Type: integer; Default: 3. STABILITY_N_GUESS_VECTORS (DCT)¶DCT (Expert) — The number of guess vectors used for Davidson’s diagonalization in stability check. Type: integer; Default: 20. STEP_TYPE (OPTKING)¶OPTKING — Geometry optimization step type, either Newton-Raphson or Rational Function Optimization. Type: string; Possible Values: RFO, RS_I_RFO, P_RFO, NR, SD, LINESEARCH; Default: RFO. SUMMATION",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/autodoc_glossary_options_c.html:233894,energy,energy,233894,psi4manual/master/autodoc_glossary_options_c.html,https://psicode.org,https://psicode.org/psi4manual/master/autodoc_glossary_options_c.html,1,['energy'],['energy']
Energy Efficiency,"PT2 TOTAL ENERGY¶. SAPT2+ TOTAL ENERGY¶. SAPT2+(3) TOTAL ENERGY¶. SAPT2+3 TOTAL ENERGY¶; The total electronic interaction energy [H] for the labeled SAPT level; of theory. SAPT2+(CCD) TOTAL ENERGY¶. SAPT2+(3)(CCD) TOTAL ENERGY¶. SAPT2+3(CCD) TOTAL ENERGY¶; The total electronic interaction energy [H] for the labeled SAPT level; of theory that incorporates coupled-cluster dispersion. SAPT2+DMP2 TOTAL ENERGY¶. SAPT2+(3)DMP2 TOTAL ENERGY¶. SAPT2+3DMP2 TOTAL ENERGY¶. SAPT2+(CCD)DMP2 TOTAL ENERGY¶. SAPT2+(3)(CCD)DMP2 TOTAL ENERGY¶. SAPT2+3(CCD)DMP2 TOTAL ENERGY¶; The total electronic interaction energy [H] for the labeled SAPT level; of theory that incorporates MP2 induction correction. SCF DIPOLE X¶. SCF DIPOLE Y¶. SCF DIPOLE Z¶; The three components of the SCF dipole [Debye]. SCF QUADRUPOLE XX¶. SCF QUADRUPOLE XY¶. SCF QUADRUPOLE XZ¶. SCF QUADRUPOLE YY¶. SCF QUADRUPOLE YZ¶. SCF QUADRUPOLE ZZ¶; The six components of the SCF quadrupole [Debye Ang]. SCF TOTAL ENERGY¶; The total electronic energy [H] of the SCF stage of the calculation.; The CORRELATION ENERGY variables from subsequent stages of a; calculation are often the corresponding TOTAL ENERGY; variables less this quantity. Constructed from Eq. (4),; where this quantity is . (4); Unless the method includes a dispersion correction, this quantity is; equal to HF TOTAL ENERGY (for HF) or; DFT FUNCTIONAL TOTAL ENERGY (for; DFT). Unless the method is a DFT double-hybrid, this quantity is equal; to DFT TOTAL ENERGY. TWO-ELECTRON ENERGY¶; The two-electron energy contribution [H] to the total SCF energy.; Quantity in Eq. (4). UNCP-CORRECTED 2-BODY INTERACTION ENERGY¶; The interaction energy [H] considering only two-body interactions,; computed without counterpoise correction.; Related variable CP-CORRECTED 2-BODY INTERACTION ENERGY. ZAPTn TOTAL ENERGY¶. ZAPTn CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the labeled Z-averaged perturbation theory level.; n is ZAPT perturbation",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/glossary_psivariables-1.html:15822,energy,energy,15822,psi4manual/1.0.0/glossary_psivariables-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/glossary_psivariables-1.html,2,['energy'],['energy']
Energy Efficiency,"PT2 TOTAL ENERGY¶. SAPT2+ TOTAL ENERGY¶. SAPT2+(3) TOTAL ENERGY¶. SAPT2+3 TOTAL ENERGY¶; The total electronic interaction energy [H] for the labeled SAPT level; of theory. SAPT2+(CCD) TOTAL ENERGY¶. SAPT2+(3)(CCD) TOTAL ENERGY¶. SAPT2+3(CCD) TOTAL ENERGY¶; The total electronic interaction energy [H] for the labeled SAPT level; of theory that incorporates coupled-cluster dispersion. SAPT2+DMP2 TOTAL ENERGY¶. SAPT2+(3)DMP2 TOTAL ENERGY¶. SAPT2+3DMP2 TOTAL ENERGY¶. SAPT2+(CCD)DMP2 TOTAL ENERGY¶. SAPT2+(3)(CCD)DMP2 TOTAL ENERGY¶. SAPT2+3(CCD)DMP2 TOTAL ENERGY¶; The total electronic interaction energy [H] for the labeled SAPT level; of theory that incorporates MP2 induction correction. SCF DIPOLE X¶. SCF DIPOLE Y¶. SCF DIPOLE Z¶; The three components of the SCF dipole [Debye]. SCF QUADRUPOLE XX¶. SCF QUADRUPOLE XY¶. SCF QUADRUPOLE XZ¶. SCF QUADRUPOLE YY¶. SCF QUADRUPOLE YZ¶. SCF QUADRUPOLE ZZ¶; The six components of the SCF quadrupole [Debye Ang]. SCF TOTAL ENERGY¶; The total electronic energy [H] of the SCF stage of the calculation.; The CORRELATION ENERGY variables from subsequent stages of a; calculation are often the corresponding TOTAL ENERGY; variables less this quantity. Constructed from Eq. (4),; where this quantity is \(E_{\text{SCF}}\). \begin{align*}; E_{\text{SCF}} & = E_{NN} + E_{1e^-} + E_{2e^-} + E_{xc} + E_{\text{-D}} \\; & = E_{\text{FCTL/HF}} + E_{\text{-D}}; \end{align*}Unless the method includes a dispersion correction, this quantity is; equal to HF TOTAL ENERGY (for HF) or; DFT FUNCTIONAL TOTAL ENERGY (for; DFT). Unless the method is a DFT double-hybrid, this quantity is equal; to DFT TOTAL ENERGY. TWO-ELECTRON ENERGY¶; The two-electron energy contribution [H] to the total SCF energy.; Quantity \(E_{2e^-}\) in Eq. (4). UNCP-CORRECTED 2-BODY INTERACTION ENERGY¶; The interaction energy [H] considering only two-body interactions,; computed without counterpoise correction.; Related variable CP-CORRECTED 2-BODY INTERACTION ENERGY. \[E_{\text{IE}} = E_{dim",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/glossary_psivariables-1.html:17149,energy,energy,17149,psi4manual/1.1.0/glossary_psivariables-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/glossary_psivariables-1.html,6,['energy'],['energy']
Energy Efficiency,"PT2+(3) ENERGY¶. SAPT SAPT2+3 ENERGY¶; The total electronic interaction energy [H] for the labeled SAPT level; of theory. SAPT SAPT2+(CCD) ENERGY¶. SAPT SAPT2+(3)(CCD) ENERGY¶. SAPT SAPT2+3(CCD) ENERGY¶; The total electronic interaction energy [H] for the labeled SAPT level; of theory that incorporates coupled-cluster dispersion. SCF DIPOLE X¶. SCF DIPOLE Y¶. SCF DIPOLE Z¶; The three components of the SCF dipole [Debye]. SCF QUADRUPOLE XX¶. SCF QUADRUPOLE XY¶. SCF QUADRUPOLE XZ¶. SCF QUADRUPOLE YY¶. SCF QUADRUPOLE YZ¶. SCF QUADRUPOLE ZZ¶; The six components of the SCF quadrupole [Debye Ang]. SCF TOTAL ENERGY¶; The total electronic energy [H] of the SCF stage of the calculation.; The CORRELATION ENERGY variables from subsequent stages of a; calculation are often the corresponding TOTAL ENERGY; variables less this quantity. Constructed from Eq. (4),; where this quantity is . (4); Unless the method includes a dispersion correction, this quantity is; equal to HF TOTAL ENERGY (for HF) or; DFT FUNCTIONAL TOTAL ENERGY (for; DFT). Unless the method is a DFT double-hybrid, this quantity is equal; to DFT TOTAL ENERGY. TWO-ELECTRON ENERGY¶; The two-electron energy contribution [H] to the total SCF energy.; Quantity in Eq. (4). UNCP-CORRECTED 2-BODY INTERACTION ENERGY¶; The interaction energy [H] considering only two-body interactions,; computed without counterpoise correction.; Related variable CP-CORRECTED 2-BODY INTERACTION ENERGY. ZAPTn TOTAL ENERGY¶. ZAPTn CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the labeled Z-averaged perturbation theory level.; n is ZAPT perturbation order. Previous topic; WFN; Next topic; PSI Variables by Module; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » ; Appendices ». © Copyright 2013, The Psi4 Project.; Last updated on Apr 25, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/glossary_psivariables-1.html:15749,energy,energy,15749,psi4manual/4.0b4/glossary_psivariables-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/glossary_psivariables-1.html,10,['energy'],['energy']
Energy Efficiency,"PT2+(3) ENERGY¶. SAPT SAPT2+3 ENERGY¶; The total electronic interaction energy [H] for the labeled SAPT level; of theory. SAPT SAPT2+(CCD) ENERGY¶. SAPT SAPT2+(3)(CCD) ENERGY¶. SAPT SAPT2+3(CCD) ENERGY¶; The total electronic interaction energy [H] for the labeled SAPT level; of theory that incorporates coupled-cluster dispersion. SCF DIPOLE X¶. SCF DIPOLE Y¶. SCF DIPOLE Z¶; The three components of the SCF dipole [Debye]. SCF QUADRUPOLE XX¶. SCF QUADRUPOLE XY¶. SCF QUADRUPOLE XZ¶. SCF QUADRUPOLE YY¶. SCF QUADRUPOLE YZ¶. SCF QUADRUPOLE ZZ¶; The six components of the SCF quadrupole [Debye Ang]. SCF TOTAL ENERGY¶; The total electronic energy [H] of the SCF stage of the calculation.; The CORRELATION ENERGY variables from subsequent stages of a; calculation are often the corresponding TOTAL ENERGY; variables less this quantity. Constructed from Eq. (4),; where this quantity is . (4); Unless the method includes a dispersion correction, this quantity is; equal to HF TOTAL ENERGY (for HF) or; DFT FUNCTIONAL TOTAL ENERGY (for; DFT). Unless the method is a DFT double-hybrid, this quantity is equal; to DFT TOTAL ENERGY. TWO-ELECTRON ENERGY¶; The two-electron energy contribution [H] to the total SCF energy.; Quantity in Eq. (4). UNCP-CORRECTED 2-BODY INTERACTION ENERGY¶; The interaction energy [H] considering only two-body interactions,; computed without counterpoise correction.; Related variable CP-CORRECTED 2-BODY INTERACTION ENERGY. ZAPTn TOTAL ENERGY¶. ZAPTn CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the labeled Z-averaged perturbation theory level.; n is ZAPT perturbation order. Previous topic; WFN; Next topic; PSI Variables by Module; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta5] » ; Appendices ». © Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/glossary_psivariables-1.html:15925,energy,energy,15925,psi4manual/4.0b5/glossary_psivariables-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/glossary_psivariables-1.html,10,['energy'],['energy']
Energy Efficiency,"PT2+(3)(CCD) plus CT [manual]. sapt2+3(ccd)-ct; SAPT2+3(CCD) plus CT [manual]. adc; 2nd-order algebraic diagrammatic construction (ADC) [manual]. eom-cc2; EOM-CC2 [manual]. eom-ccsd; equation of motion (EOM) CCSD [manual]. eom-cc3; EOM-CC3 [manual]. Examples:. >>> # [1] Coupled-cluster singles and doubles calculation with psi code; >>> energy('ccsd'). >>> # [2] Charge-transfer SAPT calculation with scf projection from small into; >>> # requested basis, with specified projection fitting basis; >>> set basis_guess true; >>> set df_basis_guess jun-cc-pVDZ-JKFIT; >>> energy('sapt0-ct'). >>> # [3] Arbitrary-order MPn calculation; >>> energy('mp7'). >>> # [4] Converge scf as singlet, then run detci as triplet upon singlet reference; >>> # Note that the integral transformation is not done automatically when detci is run in a separate step.; >>> molecule H2 {\n0 1\nH\nH 1 0.74\n}; >>> set basis cc-pVDZ; >>> set reference rohf; >>> scf_e, scf_wfn = energy('scf', return_wfn=True); >>> H2.set_multiplicity(3); >>> core.MintsHelper(scf_wfn.basisset()).integrals(); >>> energy('detci', ref_wfn=scf_wfn). >>> # [5] Run two CI calculations, keeping the integrals generated in the first one.; >>> molecule ne {\nNe\n}; >>> set basis cc-pVDZ; >>> cisd_e, cisd_wfn = energy('cisd', return_wfn=True); >>> energy('fci', ref_wfn=cisd_wfn). >>> # [6] Can automatically perform complete basis set extrapolations; >>> energy(""CCSD/cc-pV[DT]Z""). >>> # [7] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> energy(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.3.2;  · . PSI4. Psithon Functions: Invoking a Calculation. © Copyright 2019, The Psi4 Project.; Last updated on Wednesday, 15 May 2019 08:49PM.; Created using Sphinx 1.8.5.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/energy-1.html:8039,energy,energy,8039,psi4manual/1.3.2/energy-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/energy-1.html,10,['energy'],['energy']
Energy Efficiency,"PTn. """"""; # dtl = docs_table_link(""dummy"", ""detci""). optstash = p4util.OptionsState(; ['DETCI', 'WFN'],; ['DETCI', 'MAX_NUM_VECS'],; ['DETCI', 'MPN_ORDER_SAVE'],; ['DETCI', 'MPN'],; ['DETCI', 'FCI'],; ['DETCI', 'EX_LEVEL']). # throw exception for UHF; if core.get_option('DETCI', 'REFERENCE') not in ['RHF', 'ROHF']:; raise ValidationError('Reference %s for DETCI is not available.' %; core.get_option('DETCI', 'REFERENCE')). # throw exception for DF/CD. many of these pre-trapped by select_* functions but some escape, incl. zapt; if (corl_type := method_algorithm_type(name).now) != ""CONV"":; raise ValidationError(f""Invalid type {corl_type} for DETCI energy through `run_detci`."") # See Capabilities Table""). mtdlvl_mobj = re.match(r""""""\A(?P<method>[a-z]+)(?P<level>\d+)\Z"""""", name.lower()). if mtdlvl_mobj and mtdlvl_mobj.group(""method"") == ""zapt"":; level = int(mtdlvl_mobj.group(""level"")). # throw exception for non-ROHF; if (ref := core.get_option(""SCF"", ""REFERENCE"")) != ""ROHF"":; raise UpgradeHelper(f""energy('zapt{level}')"", f""energy('mp{level}')"", 1.7,; "" Replace method ZAPT with method MP for RHF reference. DETCI is orders-of-magnitude inefficient for perturbation theory.""). core.set_local_option('DETCI', 'WFN', 'ZAPTN'); maxnvect = int((level + 1) / 2) + (level + 1) % 2; core.set_local_option('DETCI', 'MAX_NUM_VECS', maxnvect); if (level + 1) % 2:; core.set_local_option('DETCI', 'MPN_ORDER_SAVE', 2); else:; core.set_local_option('DETCI', 'MPN_ORDER_SAVE', 1); elif mtdlvl_mobj and mtdlvl_mobj.group(""method"") == ""mp"":; core.set_local_option('DETCI', 'WFN', 'DETCI'); core.set_local_option('DETCI', 'MPN', 'TRUE'); level = int(mtdlvl_mobj.group(""level"")); maxnvect = int((level + 1) / 2) + (level + 1) % 2; core.set_local_option('DETCI', 'MAX_NUM_VECS', maxnvect); if (level + 1) % 2:; core.set_local_option('DETCI', 'MPN_ORDER_SAVE', 2); else:; core.set_local_option('DETCI', 'MPN_ORDER_SAVE', 1); elif name == 'ccsd':; # untested; core.set_local_option('DETCI', 'WFN', 'DETCI'); co",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:132347,energy,energy,132347,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,16,['energy'],['energy']
Energy Efficiency,"PVDZ/cc-pVDZ-RI computation of formic acid dimer binding energy using explicit specification of ghost atoms. This is equivalent to the dfmp2_1 sample but uses both (equivalent) specifications of ghost atoms in a manual counterpoise correction. sapt3; SAPT2+3(CCD) aug-cc-pVDZ computation of the water dimer interaction energy, using the aug-cc-pVDZ-JKFIT DF basis for SCF and aug-cc-pVDZ-RI for SAPT. mints4; A demonstration of mixed Cartesian/ZMatrix geometry specification, using variables, for the benzene-hydronium complex. Atoms can be placed using ZMatrix coordinates, whether they belong to the same fragment or not. Note that the Cartesian specification must come before the ZMatrix entries because the former define absolute positions, while the latter are relative. tu4-h2o-freq; Optimization followed by frequencies H2O HF/cc-pVDZ. mp2p5-grad1; MP2.5 cc-pVDZ gradient for the H2O molecule. dfmp2-grad3; DF-MP2 cc-pVDZ gradients for the H2O molecule. dfomp2p5-1; DF-OMP2.5 cc-pVDZ energy for the H2O molecule. omp3-3; OMP3 cc-pVDZ energy with B3LYP initial guess for the NO radical. dfomp3-2; DF-OMP3 cc-pVDZ energy for the H2O+ cation. pubchem1; Benzene vertical singlet-triplet energy difference computation, using the PubChem database to obtain the initial geometry, which is optimized at the HF/STO-3G level, before computing single point energies at the RHF, UHF and ROHF levels of theory. opt2; SCF DZ allene geometry optimization, with Cartesian input, first in c2v symmetry, then in Cs symmetry from a starting point with a non-linear central bond angle. dfomp2-3; OMP2 cc-pVDZ energy for the H2O molecule. omp3-2; OMP3 cc-pVDZ energy with ROHF initial guess for the NO radical. ocepa3; OCEPA cc-pVDZ energy with ROHF initial guess for the NO radical. cisd-h2o+-1; 6-31G** H2O+ Test CISD Energy Point. mcscf1; ROHF 6-31G** energy of the \(^{3}B_1\) state of CH2, with Z-matrix input. The occupations are specified explicitly. dfomp2p5-grad2; DF-OMP2.5 cc-pVDZ gradients for the H2O+",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/testsuite-1.html:18861,energy,energy,18861,psi4manual/1.1.0/testsuite-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/testsuite-1.html,4,['energy'],['energy']
Energy Efficiency,"PY; PYTHON; SIMINT; SNSMP2; V2RDM_CASSCF. Sample inputs for PSI4 as distributed are below. Input File; Description. scf5; Test of all different algorithms and reference types for SCF, on singlet and triplet O2, using the cc-pVTZ basis set. cc13; UHF-CCSD/cc-pVDZ \(^{3}B_1\) CH2 geometry optimization via analytic gradients. mints9; A test of the basis specification. Various basis sets are specified outright and in blocks, both orbital and auxiliary. Constructs libmints BasisSet objects through the constructor that calls qcdb.BasisSet infrastructure. Checks that the resulting bases are of the right size and checks that symmetry of the Molecule observes the basis assignment to atoms. fci-h2o-2; 6-31G H2O Test FCI Energy Point. fd-gradient; SCF STO-3G finite-difference tests. omp2-grad2; OMP2 cc-pVDZ gradient for the NO radical. dfep2-2; Compute three IP and 2 EA’s for the PH3 molecule. phi-ao; Test computing values of basis functions (puream and non-puream) at points. dfcasscf-sp; CASSCF/6-31G** energy point. mints6; Patch of a glycine with a methyl group, to make alanine, then DF-SCF energy calculation with the cc-pVDZ basis set. dfmp2-grad1; DF-MP2 cc-pVDZ gradients for the H2O molecule. sapt-dft2; SAPT(DFT) aug-cc-pVDZ computation for the water dimer interaction energy. dfomp2p5-1; DF-OMP2.5 cc-pVDZ energy for the H2O molecule. freq-masses; check nonphysical masses possible. cc17; Single point energies of multiple excited states with EOM-CCSD. fci-coverage; 6-31G H2O Test for coverage. cdoremp-energy1; Cholesky decomposed OO-REMP/cc-pVDZ energy for the H2O molecule. sapt2; SAPT0 aug-cc-pVDZ computation of the benzene-methane interaction energy, using the aug-pVDZ-JKFIT DF basis for SCF, the aug-cc-pVDZ-RI DF basis for SAPT0 induction and dispersion, and the aug-pVDZ-JKFIT DF basis for SAPT0 electrostatics and induction. This example uses frozen core as well as asyncronous I/O while forming the DF integrals and CPHF coefficients. zaptn-nh2; ZAPT(n)/6-31G NH2 Energy P",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/testsuite.html:1778,energy,energy,1778,psi4manual/1.8.x/testsuite.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/testsuite.html,1,['energy'],['energy']
Energy Efficiency,"Parker, revamped by Lori A. Burns. Z(self: psi4.core.Molecule, arg0: int) → float; Nuclear charge of atom. activate_all_fragments(self: psi4.core.Molecule) → None; Sets all fragments in the molecule to be active. add_atom(self: psi4.core.Molecule, arg0: float, arg1: float, arg2: float, arg3: float, arg4: str, arg5: float, arg6: float, arg7: str, arg8: int) → None; Adds to Molecule arg1 an atom with atomic number arg2, Cartesian coordinates in Bohr (arg3, arg4, arg5), atomic symbol arg6, mass arg7, charge arg8 (optional), and lineno arg9 (optional). atom_at_position(self: psi4.core.Molecule, arg0: float, arg1: float) → int; Tests to see if an atom is at the position arg2 with a given tolerance arg3. basis_on_atom(self: psi4.core.Molecule, arg0: int) → str; Gets the label of the orbital basis set on a given atom. center_of_mass(self: psi4.core.Molecule) → psi4.core.Vector3; Computes center of mass of molecule (does not translate molecule). charge(self: psi4.core.Molecule, arg0: int) → float; Gets charge of atom. clone(self: psi4.core.Molecule) → psi4.core.Molecule; Returns a new Molecule identical to arg1. com_fixed(self: psi4.core.Molecule) → bool; Get whether or not COM is fixed. create_molecule_from_string(arg0: str) → psi4.core.Molecule; Returns a new Molecule with member data from the geometry string arg1 in psi4 format. create_psi4_string_from_molecule(self: psi4.core.Molecule) → str; Gets a string reexpressing in input format the current states of the molecule. deactivate_all_fragments(self: psi4.core.Molecule) → None; Sets all fragments in the molecule to be inactive. distance_matrix(self: psi4.core.Molecule) → psi4.core.Matrix; Returns Matrix of interatom distances. extract_subsets(*args, **kwargs); Overloaded function. extract_subsets(self: psi4.core.Molecule, arg0: List[int], arg1: List[int]) -> psi4.core.Molecule. Returns copy of arg1 with arg2 fragments Real and arg3 fragments Ghost. extract_subsets(self: psi4.core.Molecule, arg0: List[int], arg1: int) ->",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/api/psi4.core.molecule.html:38202,charge,charge,38202,psi4manual/1.2.1/api/psi4.core.molecule.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/api/psi4.core.molecule.html,1,['charge'],['charge']
Energy Efficiency,"PetiteList :. docstring; C++ signature :. N5boost10shared_ptrIN3psi10PetiteListEEE petite_list(N3psi10SOBasisSetE {lvalue}). SuperFunctional¶. psi4.SuperFunctional.add_c_functional()¶; Python Library Documentation: method add_c_functional; add_c_functional(...) unbound psi4.SuperFunctional method. add_c_functional( (SuperFunctional)arg1, (Functional)arg2) -> None :. docstring; C++ signature :. void add_c_functional(N3psi15SuperFunctionalE {lvalue},N5boost10shared_ptrIN3psi10FunctionalEEE). psi4.SuperFunctional.add_x_functional()¶; Python Library Documentation: method add_x_functional; add_x_functional(...) unbound psi4.SuperFunctional method. add_x_functional( (SuperFunctional)arg1, (Functional)arg2) -> None :. docstring; C++ signature :. void add_x_functional(N3psi15SuperFunctionalE {lvalue},N5boost10shared_ptrIN3psi10FunctionalEEE). psi4.SuperFunctional.allocate()¶; Python Library Documentation: method allocate; allocate(...) unbound psi4.SuperFunctional method. allocate( (SuperFunctional)arg1) -> None :. docstring; C++ signature :. void allocate(N3psi15SuperFunctionalE {lvalue}). psi4.SuperFunctional.ansatz()¶; Python Library Documentation: method ansatz; ansatz(...) unbound psi4.SuperFunctional method. ansatz( (SuperFunctional)arg1) -> int :. docstring; C++ signature :. i ansatz(N3psi15SuperFunctionalE {lvalue}). psi4.SuperFunctional.blank()¶; Python Library Documentation: built-in function blank; blank(...). blank() -> SuperFunctional :. docstring; C++ signature :. N5boost10shared_ptrIN3psi15SuperFunctionalEEE blank(). psi4.SuperFunctional.build()¶; Python Library Documentation: built-in function build; build(...). build( (str)arg1, (int)arg2, (int)arg3) -> SuperFunctional :. docstring; C++ signature :. N5boost10shared_ptrIN3psi15SuperFunctionalEEE build(Ss,i,i). psi4.SuperFunctional.c_alpha()¶; Python Library Documentation: method c_alpha; c_alpha(...) unbound psi4.SuperFunctional method. c_alpha( (SuperFunctional)arg1) -> float :. docstring; C++ signature :. ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html:329642,allocate,allocate,329642,psi4manual/1.0.0/autodoc_psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html,2,['allocate'],['allocate']
Energy Efficiency,"Phys. Chem. XXX This uses a “primary” virtual space 3s3p (RAS 2), a “secondary” virtual space 3d4s4p4d4f (RAS 3), and a “tertiary” virtual space consisting of the remaining virtuals. First, an initial CISD computation is run to get the natural orbitals; this allows a meaningful partitioning of the virtual orbitals into groups of different importance. Next, the RASCI is run. The split-virtual CISD[TQ] takes all singles and doubles, and all triples and quadruples with no more than 2 electrons in the secondary virtual subspace (RAS 3). If any electrons are present in the tertiary virtual subspace (RAS 4), then that excitation is only allowed if it is a single or double. mbis-1; MBIS calculation on H2O. x2c2; Test of SFX2C-1e on Water cc-pVDZ-DK. In this test the Dirac equation is solved in the uncontracted cc-pVDZ-DK basis. The reference numbers are from Lan Cheng’s implementation in Cfour. dft-grac; Gradient regularized asymptotic correction (GRAC) test. scf1; RHF cc-pVQZ energy for the BH molecule, with Cartesian input. dct2; DC-06 calculation for the He dimer. This performs a two-step update of the orbitals and cumulant, using DIIS extrapolation. Four-virtual integrals are handled in the MO Basis. dft-custom-hybrid; DFT (hybrids) test of implementations in: hybrid_superfuncs.py. scf-hess4; DF SCF 6-31G UHFl vs RHF test Tests DF UHF hessian code for Ca = Cb. scf-auto-cholesky; Cholesky filter a complete basis. mom; Maximum Overlap Method (MOM) Test. MOM is designed to stabilize SCF convergence and to target excited Slater determinants directly. psithon1; Spectroscopic constants of H2, and the full ci cc-pVTZ level of theory. cisd-h2o+-2; 6-31G** H2O+ Test CISD Energy Point. cc10; ROHF-CCSD cc-pVDZ energy for the \(^2\Sigma^+\) state of the CN radical. tdscf-2; td-uhf test on triplet states of methylene (tda), wfn passing. dft-pruning; Tests all grid pruning options available and screening of small weights. Check against grid size. dfccd1; DF-CCD cc-pVDZ energy for th",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/autodoc_testsuite_corepsi4.html:3880,energy,energy,3880,psi4manual/1.7.x/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/autodoc_testsuite_corepsi4.html,2,['energy'],['energy']
Energy Efficiency,"Possible Values: DC-06, DC-12, ODC-06, ODC-12, ODC-13, CEPA0; Default: ODC-12. DCFT_GUESS (DCFT); DCFT (Expert) — Whether to read the orbitals from a previous computation, or to compute an MP2 guess. Type: string; Possible Values: CC, BCC, MP2, DCFT; Default: MP2. DCFT_TYPE (DCFT); DCFT — What algorithm to use for the DCFT computation. Type: string; Possible Values: CONV, DF; Default: CONV. DEBUG (CPHF); CPHF — The amount of debug information printed to the output file. Type: integer; Default: 0. DEBUG (GLOBALS); GLOBALS (Expert) — The amount of information to print to the output file. Type: integer; Default: 0. DELETE_TEI (CCTRANSORT); CCTRANSORT — Delete the SO two-electron integrals after the transformation?. Type: boolean; Default: true. DELETE_TEI (TRANSQT2); TRANSQT2 — Boolean to delete the SO-basis two-electron integral file after the transformation. Type: boolean; Default: true. DENOMINATOR_ALGORITHM (SAPT); SAPT — Denominator algorithm for PT methods. Laplace transformations are slightly more efficient. Type: string; Possible Values: LAPLACE, CHOLESKY; Default: LAPLACE. DENOMINATOR_DELTA (SAPT); SAPT — Maximum error allowed (Max error norm in Delta tensor) in the approximate energy denominators employed for most of the and evaluation. Type: double; Default: 1.0e-6. DERTYPE (EFP); EFP (Expert) — Do EFP gradient?. Type: string; Possible Values: NONE, FIRST; Default: NONE. DERTYPE (GLOBALS); GLOBALS (Expert) — Derivative level. Type: string; Possible Values: NONE, FIRST, SECOND, RESPONSE; Default: NONE. DETCI_FREEZE_CORE (DETCI); DETCI — Do freeze core orbitals?. Type: boolean; Default: true. DF_BASIS_CC (FNOCC); FNOCC — Auxilliary basis for df-ccsd(t). Type: string; Possible Values: basis string; Default: No Default. DF_BASIS_CC (GLOBALS); GLOBALS — The density fitting basis to use in coupled cluster computations. Type: string; Possible Values: basis string; Default: No Default. DF_BASIS_DCFT (DCFT); DCFT — Auxiliary basis set for DCFT density fitting computat",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_glossary_options_c-1.html:94666,efficient,efficient,94666,psi4manual/1.0.0/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_glossary_options_c-1.html,2,['efficient'],['efficient']
Energy Efficiency,"Possible Values: NONE, LINEAR, QUADRATIC, CUBIC; Default: CUBIC. COUPLING_TERMS¶. Do include the terms that couple the reference determinants?. Type: boolean; Default: true. DAMPING_PERCENTAGE¶. The amount (percentage) of damping to apply to the amplitude updates. 0 will result in a full update, 100 will completely stall the update. A value around 20 (which corresponds to 20% of the amplitudes from the previous iteration being mixed into the current iteration) can help in cases where oscillatory convergence is observed. Type: double; Default: 0.0. DIAGONALIZE_HEFF¶. Do diagonalize the effective Hamiltonian?. Type: boolean; Default: false. DIAGONAL_CCSD_T¶. Do include the diagonal corrections in (T) computations?. Type: boolean; Default: true. DIIS_MAX_VECS¶. Maximum number of error vectors stored for DIIS extrapolation. Type: integer; Default: 7. DIIS_START¶. The number of DIIS vectors needed before extrapolation is performed. Type: integer; Default: 2. E_CONVERGENCE¶. Convergence criterion for energy. See Table Post-SCF Convergence for default convergence criteria for different calculation types. Type: conv double; Default: 1e-6. FAVG_CCSD_T¶. Do use the averaged Fock matrix over all references in (T) computations?. Type: boolean; Default: false. FOLLOW_ROOT¶. Which root of the effective hamiltonian is the target state?. Type: integer; Default: 1. FROZEN_DOCC¶. The number of frozen occupied orbitals per irrep. Type: array; Default: No Default. FROZEN_UOCC¶. The number of frozen virtual orbitals per irrep. Type: array; Default: No Default. HEFF4¶. Do include the fourth-order contributions to the effective Hamiltonian?. Type: boolean; Default: true. HEFF_PRINT¶. Do print the effective Hamiltonian?. Type: boolean; Default: false. LOCK_SINGLET¶. Do lock onto a singlet root?. Type: boolean; Default: false. MAXITER¶. Maximum number of iterations to determine the amplitudes. Type: integer; Default: 100. MP2_CCSD_METHOD¶. How to perform MP2_CCSD computations. Type: string;",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/autodir_options_c/module__psimrcc-1.html:2172,energy,energy,2172,psi4manual/4.0b5/autodir_options_c/module__psimrcc-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/module__psimrcc-1.html,4,['energy'],['energy']
Energy Efficiency,"Possible Values: NONE, LINEAR, QUADRATIC, CUBIC; Default: CUBIC. COUPLING_TERMS¶. Do include the terms that couple the reference determinants?. Type: boolean; Default: true. DAMPING_PERCENTAGE¶. The amount (percentage) of damping to apply to the amplitude updates. 0 will result in a full update, 100 will completely stall the update. A value around 20 (which corresponds to 20% of the amplitudes from the previous iteration being mixed into the current iteration) can help in cases where oscillatory convergence is observed. Type: double; Default: 0.0. DIAGONALIZE_HEFF¶. Do diagonalize the effective Hamiltonian?. Type: boolean; Default: false. DIAGONAL_CCSD_T¶. Do include the diagonal corrections in (T) computations?. Type: boolean; Default: true. DIIS_MAX_VECS¶. Maximum number of error vectors stored for DIIS extrapolation. Type: integer; Default: 7. DIIS_START¶. The number of DIIS vectors needed before extrapolation is performed. Type: integer; Default: 2. E_CONVERGENCE¶. Convergence criterion for energy. See Table Post-SCF Convergence for default convergence criteria for different calculation types. Type: conv double; Default: 1e-6. FAVG_CCSD_T¶. Do use the averaged Fock matrix over all references in (T) computations?. Type: boolean; Default: false. FOLLOW_ROOT¶. Which root of the effective hamiltonian is the target state?. Type: integer; Default: 1. HEFF4¶. Do include the fourth-order contributions to the effective Hamiltonian?. Type: boolean; Default: true. HEFF_PRINT¶. Do print the effective Hamiltonian?. Type: boolean; Default: false. LOCK_SINGLET¶. Do lock onto a singlet root?. Type: boolean; Default: false. MAXITER¶. Maximum number of iterations to determine the amplitudes. Type: integer; Default: 100. MP2_CCSD_METHOD¶. How to perform MP2_CCSD computations. Type: string; Possible Values: I, IA, II; Default: II. MP2_GUESS¶. Do start from a MP2 guess?. Type: boolean; Default: true. NO_SINGLES¶. Do disregard updating single excitation amplitudes?. Type: boolean; De",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/autodir_options_c/module__psimrcc-1.html:2064,energy,energy,2064,psi4manual/1.3.2/autodir_options_c/module__psimrcc-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/autodir_options_c/module__psimrcc-1.html,26,['energy'],['energy']
Energy Efficiency,"Possible Values: NONE, LINEAR, QUADRATIC, CUBIC; Default: CUBIC. COUPLING_TERMS¶. Do include the terms that couple the reference determinants?. Type: boolean; Default: true. DAMPING_PERCENTAGE¶. The amount (percentage) of damping to apply to the amplitude updates. 0 will result in a full update, 100 will completely stall the update. A value around 20 (which corresponds to 20% of the amplitudes from the previous iteration being mixed into the current iteration) can help in cases where oscillatory convergence is observed. Type: double; Default: 0.0. DIAGONALIZE_HEFF¶. Do diagonalize the effective Hamiltonian?. Type: boolean; Default: false. DIAGONAL_CCSD_T¶. Do include the diagonal corrections in (T) computations?. Type: boolean; Default: true. DIIS_MAX_VECS¶. Maximum number of error vectors stored for DIIS extrapolation. Type: integer; Default: 7. DIIS_START¶. The number of DIIS vectors needed before extrapolation is performed. Type: integer; Default: 2. E_CONVERGENCE¶. Convergence criterion for energy. See Table Post-SCF Convergence for default convergence criteria for different calculation types. Type: conv double; Default: 1e-8. FAVG_CCSD_T¶. Do use the averaged Fock matrix over all references in (T) computations?. Type: boolean; Default: false. FOLLOW_ROOT¶. Which root of the effective hamiltonian is the target state?. Type: integer; Default: 1. FROZEN_DOCC¶. The number of frozen occupied orbitals per irrep. Type: array; Default: No Default. FROZEN_UOCC¶. The number of frozen virtual orbitals per irrep. Type: array; Default: No Default. HEFF4¶. Do include the fourth-order contributions to the effective Hamiltonian?. Type: boolean; Default: true. HEFF_PRINT¶. Do print the effective Hamiltonian?. Type: boolean; Default: false. LOCK_SINGLET¶. Do lock onto a singlet root?. Type: boolean; Default: false. MAXITER¶. Maximum number of iterations to determine the amplitudes. Type: integer; Default: 100. MP2_CCSD_METHOD¶. How to perform MP2_CCSD computations. Type: string;",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/autodir_options_c/module__psimrcc-1.html:2172,energy,energy,2172,psi4manual/4.0b4/autodir_options_c/module__psimrcc-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/autodir_options_c/module__psimrcc-1.html,4,['energy'],['energy']
Energy Efficiency,"Possible Values: NONE, LINEAR, QUADRATIC, CUBIC; Default: CUBIC. COUPLING_TERMS¶. Do include the terms that couple the reference determinants?. Type: boolean; Default: true. DAMPING_PERCENTAGE¶. The amount (percentage) of damping to apply to the amplitude updates. 0 will result in a full update, 100 will completely stall the update. A value around 20 (which corresponds to 20% of the amplitudes from the previous iteration being mixed into the current iteration) can help in cases where oscillatory convergence is observed. Type: double; Default: 0.0. DIAGONALIZE_HEFF¶. Do diagonalize the effective Hamiltonian?. Type: boolean; Default: false. DIAGONAL_CCSD_T¶. Do include the diagonal corrections in (T) computations?. Type: boolean; Default: true. DIIS_MAX_VECS¶. Maximum number of error vectors stored for DIIS extrapolation. Type: integer; Default: 7. DIIS_START¶. The number of DIIS vectors needed before extrapolation is performed. Type: integer; Default: 2. E_CONVERGENCE¶. Convergence criterion for energy. Type: conv double; Default: 1e-9. FAVG_CCSD_T¶. Do use the averaged Fock matrix over all references in (T) computations?. Type: boolean; Default: false. FOLLOW_ROOT¶. Which root of the effective hamiltonian is the target state?. Type: integer; Default: 1. FROZEN_DOCC¶. The number of frozen occupied orbitals per irrep. Type: array; Default: No Default. FROZEN_UOCC¶. The number of frozen virtual orbitals per irrep. Type: array; Default: No Default. HEFF4¶. Do include the fourth-order contributions to the effective Hamiltonian?. Type: boolean; Default: true. HEFF_PRINT¶. Do print the effective Hamiltonian?. Type: boolean; Default: false. LOCK_SINGLET¶. Do lock onto a singlet root?. Type: boolean; Default: false. MAXITER¶. Maximum number of iterations to determine the amplitudes. Type: integer; Default: 100. MP2_CCSD_METHOD¶. How to perform MP2_CCSD computations. Type: string; Possible Values: I, IA, II; Default: II. MP2_GUESS¶. Do start from a MP2 guess?. Type: boolean; ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/autodir_options_c/module__psimrcc-1.html:2312,energy,energy,2312,psi4manual/4.0b2/autodir_options_c/module__psimrcc-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/autodir_options_c/module__psimrcc-1.html,8,['energy'],['energy']
Energy Efficiency,"Possible Values: basis string; Default: No Default. DOCC¶. An array containing the number of doubly-occupied orbitals per irrep (in Cotton order). Type: array; Default: No Default. FREEZE_CORE¶. Specifies how many core orbitals to freeze in correlated computations. TRUE or 1 will default to freezing the previous noble gas shell on each atom. In case of positive charges on fragments, an additional shell may be unfrozen, to ensure there are valence electrons in each fragment. With FALSE or 0, no electrons are frozen (with the exception of electrons treated by an ECP). With -1, -2, and -3, the user might request strict freezing of the previous first/second/third noble gas shell on every atom. In this case, when there are no valence electrons, the code raises an exception. More precise control over the number of frozen orbitals can be attained by using the keywords NUM_FROZEN_DOCC (gives the total number of orbitals to freeze, program picks the lowest-energy orbitals) or FROZEN_DOCC (gives the number of orbitals to freeze per irreducible representation) or by the option POLICY in combination with appropriate inputs to FREEZE_CORE_POLICY At present, POLICY is an experimental option and is subject to change. Type: string; Possible Values: FALSE, TRUE, 1, 0, -1, -2, -3, POLICY; Default: FALSE. FREEZE_CORE_POLICY¶. NOTE: This is an experimental feature and subject to change! Specifies a custom frozen-core policy on a per-element basis. Input should be a list of integers representing the number of orbitals to freeze for each atomic number MINUS one (so H is 0, He is 1, etc). For example, to specify that elements H-Be should have 0 frozen orbitals, B-Mg should have 1, and Al should have 2, you would provide the input [0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 2]. Please make sure to fill in the list up to the highest atomic number included in any calculations. This option is only used if FREEZE_CORE is set to POLICY. Type: array; Default: No Default. FROZEN_DOCC¶. An array containi",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/autodir_options_c/module__globals.html:3398,energy,energy,3398,psi4manual/1.7.x/autodir_options_c/module__globals.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/autodir_options_c/module__globals.html,8,['energy'],['energy']
Energy Efficiency,"Primary(self.basis); fitter.setAuxiliary(self.ribasis); fitter.setD(self.Da); self.da = fitter.fit(); self.da.scale(2.0). def populateExtern(self, extern):; # Electronic Part; extern.addBasis(self.ribasis, self.da); # Nuclear Part; for A in range(0, self.molecule.natom()):; extern.addCharge(self.molecule.Z(A), self.molecule.x(A), self.molecule.y(A), self.molecule.z(A)). [docs]class QMMM(object):. def __init__(self):; self.charges = []; self.diffuses = []; self.extern = core.ExternalPotential(). [docs] def addDiffuse(self, diffuse):; """"""Function to add a diffuse charge field *diffuse*.""""""; self.diffuses.append(diffuse). [docs] def addChargeBohr(self, Q, x, y, z):; """"""Function to add a point charge of magnitude *Q* at; position (*x*, *y*, *z*) Bohr. """"""; self.charges.append([Q, x, y, z]). [docs] def addChargeAngstrom(self, Q, x, y, z):; """"""Function to add a point charge of magnitude *Q* at; position (*x*, *y*, *z*) Angstroms. """"""; self.charges.append([Q, x / constants.bohr2angstroms, y / constants.bohr2angstroms, z / constants.bohr2angstroms]). def __str__(self):. s = ' ==> QMMM <==\n\n'. s = s + ' => Charges (a.u.) <=\n\n'; s = s + ' %11s %11s %11s %11s\n' % ('Z', 'x', 'y', 'z'); for k in range(0, len(self.charges)):; s = s + ' %11.7f %11.3E %11.3E %11.3E\n' % (self.charges[k][0], self.charges[k][1], self.charges[k][2], self.charges[k][3]); s = s + '\n'. s = s + ' => Diffuses <=\n\n'. for k in range(0, len(self.diffuses)):; s = s + str(self.diffuses[k]). return s. [docs] def populateExtern(self):; """"""Function to define a charge field external to the; molecule through point and diffuse charges. """"""; # Charges; for charge in self.charges:; self.extern.addCharge(charge[0], charge[1], charge[2], charge[3]); # Diffuses; for diffuse in self.diffuses:; diffuse.populateExtern(self.extern). Navigation. Index. modules    .    .  · ; 1.1;  · . PSI4. Module code. © Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/qmmm.html:4361,charge,charges,4361,psi4manual/1.1.0/_modules/psi4/driver/qmmm.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/qmmm.html,13,['charge'],"['charge', 'charges']"
Energy Efficiency,"Prints success; when value *computed* matches value *expected*.; Performs a system exit on failure. Used in input files in the test suite. :returns: a dictionary of energies computed from the MO integrals.; - 'NUCLEAR REPULSION ENERGY' : nuclear repulsion plus frozen core energy; - 'ONE-ELECTRON ENERGY' : SCF one-electron energy; - 'TWO-ELECTRON ENERGY' : SCF two-electron energy; - 'SCF TOTAL ENERGY' : SCF total energy; - 'MP2 CORRELATION ENERGY' : MP2 correlation energy. :param expected: reference FCIDUMP file; :param computed: computed FCIDUMP file; :param label: string labelling the test; """""". # Grab expected header and integrals; ref_intdump = fcidump_from_file(expected); intdump = fcidump_from_file(computed). # Compare headers; compare_recursive(; ref_intdump,; intdump,; 'FCIDUMP header',; forgive=['enuc', 'hcore', 'eri', 'epsilon']). ref_energies = energies_from_fcidump(ref_intdump); energies = energies_from_fcidump(intdump). pass_1el = compare_values(ref_energies['ONE-ELECTRON ENERGY'], energies['ONE-ELECTRON ENERGY'], 7,; label + '. 1-electron energy'); pass_2el = compare_values(ref_energies['TWO-ELECTRON ENERGY'], energies['TWO-ELECTRON ENERGY'], 7,; label + '. 2-electron energy'); pass_scf = compare_values(ref_energies['SCF TOTAL ENERGY'], energies['SCF TOTAL ENERGY'], 10,; label + '. SCF total energy'); pass_mp2 = compare_values(ref_energies['MP2 CORRELATION ENERGY'], energies['MP2 CORRELATION ENERGY'], 10,; label + '. MP2 correlation energy'). compare_integers(True, (pass_1el and pass_2el and pass_scf and pass_mp2), label). [docs]def energies_from_fcidump(intdump):; energies = {}; energies['NUCLEAR REPULSION ENERGY'] = intdump['enuc']; epsilon = intdump['epsilon']; Hcore = intdump['hcore']; eri = intdump['eri']. # Compute SCF energy; energies['ONE-ELECTRON ENERGY'], energies['TWO-ELECTRON ENERGY'] = _scf_energy(Hcore, eri,; np.where(epsilon < 0)[0],; intdump['uhf']); # yapf: disable; energies['SCF TOTAL ENERGY'] = energies['ONE-ELECTRON ENERGY'] + energie",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/fcidump.html:12993,ENERGY,ENERGY,12993,psi4manual/1.4.0/_modules/psi4/driver/p4util/fcidump.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/fcidump.html,4,['ENERGY'],['ENERGY']
Energy Efficiency,"Ps have not been tested with projected basis set guesses or with FI-SAPT calculations. If you require this functionality, please contact the developers on GitHub and/or the forum. External potentials and QM/MM¶; In addition to the implementation of EFP for accurate QM/MM; computations, PSI4 can perform more rudimentary QM/MM procedures via the; EXTERN keyword. The following snippet, extracted from the; extern1 test case, demonstrates its use for a TIP3P external potential:; 1; 2; 3; 4; 5Chrgfield = QMMM(); Chrgfield.extern.addCharge(-0.834, 1.649232019048, 0.0, -2.356023604706); Chrgfield.extern.addCharge( 0.417, 0.544757019107, 0.0, -3.799961446760); Chrgfield.extern.addCharge( 0.417, 0.544757019107, 0.0, -0.912085762652); psi4.set_global_option_python('EXTERN', Chrgfield.extern). First a QMMM object is created, then three separate particles are added to this; object before the SCF code is told about its existence on the last line. The; calls to addCharge take the atomic charge, x coordinate, y coordinate, and; z coordinate in that order. The atomic charge is specified in atomic units,; and the coordinates always use the same units as the geometry specification in; the regular QM region. Additional MM molecules may be specified by adding; extra calls to addCharge to describe the full MM region.; To run a computation in a constant dipole field, the PERTURB_H,; PERTURB_WITH and PERTURB_DIPOLE keywords can be used. As an; example, to add a dipole field of magnitude 0.05 a.u. in the y direction and; 0.1 a.u. in the z direction, we can use the following keywords:; 1; 2; 3set perturb_h true; set perturb_with dipole; set perturb_dipole [ 0, 0.05, 0.1 ]. Note that if any specified fields do not fall along a symmetry axis, the; symmetry of the calculation should be reduced accordingly; if in doubt run the; calculation in C1 symmetry. For examples of SCF and MP2 calculations in an; external field, see scf7 and dfmp2-grad5. Convergence and Algorithm Defaults¶. SCF algorithm an",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/scf-1.html:34840,charge,charge,34840,psi4manual/1.2.1/scf-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/scf-1.html,4,['charge'],['charge']
Energy Efficiency,"Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #. """"""Module with functions that encode the sequence of PSI module; calls for each of the *name* values of the energy(), optimize(),; response(), and frequency() function. *name* can be assumed lowercase by here. """"""; import os; import shutil; import subprocess. import numpy as np. from psi4 import extras; from psi4.driver import p4util; from psi4.driver import qcdb; from psi4.driver import psifiles as psif; from psi4.driver.p4util.exceptions import *; from psi4.driver.molutil import *; # never import driver, wrappers, or aliases into this file. from .roa import *; from . import proc_util; from . import empirical_dispersion; from . import dft; from . import mcscf; from . import response. # ATTN NEW ADDITIONS!; # consult http://psicode.org/psi4manual/master/proc_py.html. def select_mp2(name, **kwargs):; """"""Function selecting the algorithm for a MP2 energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); mtd_type = core.get_global_option('MP2_TYPE'); module = core.get_global_option('QC_MODULE'); # Considering only [df]occ/dfmp2/detci/fnocc. # MP2_TYPE exists largely for py-side reasoning, so must manage it; # here rather than passing to c-side unprepared for validation. func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module == 'DETCI':; func = run_detci; elif module == 'FNOCC':; func = run_fnocc; elif module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module == 'OCC':; func = run_dfocc; elif module in ['', 'DFMP2']:; func = run_dfmp2; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc; elif reference == 'UHF':; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module == 'OCC':; func = run_dfocc; elif module in ['', 'DFMP2']:; func = run_dfmp2; elif mtd_type == 'CD",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/procrouting/proc.html:1948,energy,energy,1948,psi4manual/1.3.2/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/procrouting/proc.html,1,['energy'],['energy']
Energy Efficiency,"PsiMod.Dispersion.build('-DAS2010', 1.0, 0.0, 0.0, 0.0)) # Does not have an s6, so set to 1.0. sup.allocate(); return sup. [docs]def build_b2plyp_superfunctional(name, npoints, deriv):. # Call this first; sup = PsiMod.SuperFunctional.blank(); sup.set_max_points(npoints); sup.set_deriv(deriv). # => User-Customization <= #. # No spaces, keep it short and according to convention; sup.set_name('B2PLYP'); # Tab in, trailing newlines; sup.set_description(' B2PLYP Double Hybrid Exchange-Correlation Functional\n'); # Tab in, trailing newlines; sup.set_citation(' S. Grimme, J. Chem. Phys., 124, 034108, 2006\n'). # Add member functionals; becke = build_functional('B88_X'); becke.set_alpha(1.0); sup.add_x_functional(becke); lyp = build_functional('LYP_C'); lyp.set_alpha(0.73); sup.add_c_functional(lyp). # Set GKS up after adding functionals; sup.set_x_omega(0.0); sup.set_c_omega(0.0); sup.set_x_alpha(0.53); sup.set_c_alpha(0.27). # => End User-Customization <= #. # Call this last; sup.allocate(); return sup. [docs]def build_wb97x_2tqz_superfunctional(name, npoints, deriv):. # Call this first; sup = PsiMod.SuperFunctional.blank(); sup.set_max_points(npoints); sup.set_deriv(deriv). # => User-Customization <= #. # No spaces, keep it short and according to convention; sup.set_name('wB97X-2(TQZ)'); # Tab in, trailing newlines; sup.set_description(' Double Hybrid LRC B97 GGA XC Functional (TQZ parametrization)\n'); # Tab in, trailing newlines; sup.set_citation(' J.-D. Chai and M. Head-Gordon, J. Chem. Phys., 131, 174105, 2009\n'). # Add member functionals; X = build_functional('wB97_X'); X.set_name('wB97X_X'); X.set_alpha(1.0 / (1.0 - 0.636158)). X.set_parameter('B97_gamma', 0.004); X.set_parameter('B97_a0', 3.15503E-1); X.set_parameter('B97_a1', 1.04772E0); X.set_parameter('B97_a2', -2.33506E0); X.set_parameter('B97_a3', 3.19909E0). C = build_functional('B_C'); C.set_name('wB97X_C'). C.set_parameter('B97_os_gamma', 0.006); C.set_parameter('B97_os_a0', 5.18198E-1); C.set_parameter('B",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/_modules/functional.html:70034,allocate,allocate,70034,psi4manual/4.0b4/_modules/functional.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/functional.html,2,['allocate'],['allocate']
Energy Efficiency,"PsiMod.print_out('\n'); PsiMod.IO.change_file_namespace(PSIF_SAPT_MONOMERA, 'monomerA', 'dimer'); PsiMod.IO.change_file_namespace(PSIF_SAPT_MONOMERB, 'monomerB', 'dimer'); e_sapt = PsiMod.sapt(); CTd = PsiMod.get_variable('SAPT CT ENERGY'). PsiMod.print_out('\n'); banner('Monomer Basis SAPT'); PsiMod.print_out('\n'); PsiMod.IO.change_file_namespace(PSIF_SAPT_MONOMERA, 'monomerAm', 'dimer'); PsiMod.IO.change_file_namespace(PSIF_SAPT_MONOMERB, 'monomerBm', 'dimer'); e_sapt = PsiMod.sapt(); CTm = PsiMod.get_variable('SAPT CT ENERGY'); CT = CTd - CTm. PsiMod.print_out('\n\n'); PsiMod.print_out(' SAPT Charge Transfer Analysis\n'); PsiMod.print_out(' -----------------------------------------------------------------------------\n'); line1 = ' SAPT Induction (Dimer Basis) %10.4lf mH %10.4lf kcal mol^-1\n' % (CTd * 1000.0, CTd * physconst.psi_hartree2kcalmol); line2 = ' SAPT Induction (Monomer Basis) %10.4lf mH %10.4lf kcal mol^-1\n' % (CTm * 1000.0, CTm * physconst.psi_hartree2kcalmol); line3 = ' SAPT Charge Transfer %10.4lf mH %10.4lf kcal mol^-1\n\n' % (CT * 1000.0, CT * physconst.psi_hartree2kcalmol); PsiMod.print_out(line1); PsiMod.print_out(line2); PsiMod.print_out(line3); PsiMod.set_variable('SAPT CT ENERGY', CT). molecule.reset_point_group(user_pg); molecule.update_geometry(). optstash.restore(); return e_sapt. [docs]def run_mrcc(name, **kwargs):; """"""Function that prepares environment and input files; for a calculation calling Kallay's MRCC code. """"""; # TODO: Check to see if we really need to run the SCF code.; scf_helper(name, **kwargs); vscf = PsiMod.get_variable('SCF TOTAL ENERGY'). # The parse_arbitrary_order method provides us the following information; # We require that level be provided. level is a dictionary; # of settings to be passed to PsiMod.mrcc; if not('level' in kwargs):; raise ValidationError('level parameter was not provided.'). level = kwargs['level']. # Fullname is the string we need to search for in iface; fullname = level['fullname']. # User can p",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/_modules/proc.html:63254,Charge,Charge,63254,psi4manual/4.0b4/_modules/proc.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/proc.html,1,['Charge'],['Charge']
Energy Efficiency,"PsiMod.set_global_option('WRITER_FILE_LABEL', '%s')\n"""""" % \; (user_writer_file_label + ('' if user_writer_file_label == '' else '-') + rgt). # all modes need to step through the reagents but all for different purposes; # continuous: defines necessary commands, executes energy(method) call, and collects results into dictionary; # sow: opens individual reagent input file, writes the necessary commands, and writes energy(method) call; # reap: opens individual reagent output file, collects results into a dictionary; if (db_mode.lower() == 'continuous'):; exec(banners); exec(format_molecule_for_input(GEOS[rgt])); exec(commands); #print 'MOLECULE LIVES %23s %8s %4d %4d %4s' % (rgt, PsiMod.get_global_option('REFERENCE'),; # molecule.molecular_charge(), molecule.multiplicity(), molecule.schoenflies_symbol()); PsiMod.set_variable('NATOM', molecule.natom()); PsiMod.set_variable('NUCLEAR REPULSION ENERGY', molecule.nuclear_repulsion_energy()); if re.match(r'^verify', lowername):; compare_values(DATA['NUCLEAR REPULSION ENERGY'][rgt], PsiMod.get_variable('NUCLEAR REPULSION ENERGY'), ; 4, '%s %.4f' % (rgt, PsiMod.get_variable('NUCLEAR REPULSION ENERGY'))); ERGT[rgt] = 7.0; else:; ERGT[rgt] = call_function_in_1st_argument(func, **kwargs); #print ERGT[rgt]; PsiMod.print_variables(); exec(actives); for envv in db_tabulate:; VRGT[rgt][envv.upper()] = PsiMod.get_variable(envv); PsiMod.set_global_option(""REFERENCE"", user_reference); PsiMod.clean(). elif (db_mode.lower() == 'sow'):; freagent = open('%s.in' % (rgt), 'w'); freagent.write('# This is a psi4 input file auto-generated from the database() wrapper.\n\n'); freagent.write(banners); freagent.write(format_molecule_for_input(GEOS[rgt])). freagent.write(commands); freagent.write('''\npickle_kw = (""""""'''); pickle.dump(kwargs, freagent); freagent.write('''"""""")\n'''); freagent.write(""""""\nkwargs = pickle.loads(pickle_kw)\n""""""); freagent.write(""""""electronic_energy = %s(**kwargs)\n\n"""""" % (func.__name__)); freagent.write(""""""PsiMod.print_v",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:43628,ENERGY,ENERGY,43628,psi4manual/4.0b4/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html,1,['ENERGY'],['ENERGY']
Energy Efficiency,"PsiMod.set_variable(""CURRENT CORRELATION ENERGY"",cemp3); elif ( lowername == 'mp4(sdq)'):; emp4sdq = PsiMod.get_variable(""MP4(SDQ) TOTAL ENERGY""); cemp4sdq = PsiMod.get_variable(""MP4(SDQ) CORRELATION ENERGY""); PsiMod.set_variable(""CURRENT ENERGY"",emp4sdq); PsiMod.set_variable(""CURRENT CORRELATION ENERGY"",cemp4sdq); elif ( lowername == 'fno-mp4(sdq)'):; emp4sdq = PsiMod.get_variable(""MP4(SDQ) TOTAL ENERGY""); cemp4sdq = PsiMod.get_variable(""MP4(SDQ) CORRELATION ENERGY""); PsiMod.set_variable(""CURRENT ENERGY"",emp4sdq); PsiMod.set_variable(""CURRENT CORRELATION ENERGY"",cemp4sdq); elif ( lowername == 'fno-mp4'):; emp4 = PsiMod.get_variable(""MP4 TOTAL ENERGY""); cemp4 = PsiMod.get_variable(""MP4 CORRELATION ENERGY""); PsiMod.set_variable(""CURRENT ENERGY"",emp4); PsiMod.set_variable(""CURRENT CORRELATION ENERGY"",cemp4); elif (lowername == 'fnocc-mp') and (level == 4):; emp4 = PsiMod.get_variable(""MP4 TOTAL ENERGY""); cemp4 = PsiMod.get_variable(""MP4 CORRELATION ENERGY""); PsiMod.set_variable(""CURRENT ENERGY"",emp4); PsiMod.set_variable(""CURRENT CORRELATION ENERGY"",cemp4). # restore symmetry for fno-cc; if (PsiMod.get_option('FNOCC','NAT_ORBS')):; molecule.reset_point_group(user_pg); molecule.update_geometry(). # restore options; optstash.restore(). return PsiMod.get_variable(""CURRENT ENERGY""). [docs]def run_cepa(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a cepa-like calculation. >>> energy('cepa(1)'). """"""; lowername = name.lower(); uppername = name.upper(); kwargs = kwargs_lower(kwargs). # save user options; optstash = OptionsState(; ['TRANSQT2', 'WFN'],; ['FNOCC', 'NAT_ORBS'],; ['FNOCC', 'RUN_CEPA'],; ['FNOCC', 'CEPA_NO_SINGLES']). PsiMod.set_local_option('FNOCC','RUN_CEPA', True). # what type of cepa?; cepa_level = uppername; if (lowername == 'cepa(2)'):; raise ValidationError(""Error: %s not implemented\n"" % lowername); if (lowername == 'dci'):; cepa_level = 'CISD'; if (lowername == 'sdci'):; cepa_level = 'CISD'. if (lowername == 'fno-cepa(0)'):; cepa",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/_modules/proc.html:75806,ENERGY,ENERGY,75806,psi4manual/4.0b4/_modules/proc.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/proc.html,1,['ENERGY'],['ENERGY']
Energy Efficiency,"Py. Return type:; Matrix | Vector. np_write(filename=None, prefix='')¶; Writes the irrepped matrix to a NumPy uncompressed file using numpy.savez().; Can return the packed data for saving many matrices into the same file. Parameters:. self (Union[Matrix, Vector]) – Instance to be serialized.; filename (Optional[str]) – File name where the data will be saved.; prefix (str) – Name of instance prepared for NumPy. Returns:; When filename given, it and dict serialization passed to; numpy.savez(), so .npz file saved and None returned.; When filename None, dict serialization returned. Return type:; None or Dict[str, Any]. partial_cholesky_factorize(self: psi4.core.Matrix, delta: float = 0.0, throw_if_negative: bool = False) → psi4.core.Matrix¶; Computes the fully pivoted partial Cholesky factorization of a real symmetric positive semidefinite matrix, to numerical precision delta. power(self: psi4.core.Matrix, alpha: float, cutoff: float = 1e-12) → psi4.core.Dimension¶; Takes the matrix to the alpha power with precision cutoff. print_atom_vector(self: psi4.core.Matrix, RMRoutfile: str = 'outfile') → None¶; Print the matrix with atom labels, assuming it is an natom X 3 tensor. print_out(self: psi4.core.Matrix) → None¶; Prints the matrix to the output file. pseudoinverse(self: psi4.core.Matrix, condition: float, nremoved: int) → psi4.core.Matrix¶; Computes the matrix which is the conditioned pseudoinverse of this matrix. remove_symmetry(self: psi4.core.Matrix, a: psi4.core.Matrix, transformer: psi4.core.Matrix) → None¶; Remove symmetry from a matrix A with PetiteList::sotoao(). rms(self: psi4.core.Matrix) → float¶; Returns the rms of this matrix. rotate_columns(self: psi4.core.Matrix, h: int, i: int, j: int, theta: float) → None¶; Rotates columns i and j in irrep h by angle theta. rowdim(self: psi4.core.Matrix) → psi4.core.Dimension¶; Returns the rows per irrep array. rows(self: psi4.core.Matrix, h: int = 0) → int¶; Returns the rows in irrep h. save(*args, **kwargs)¶; Overloa",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/api/psi4.core.Matrix.html:13226,power,power,13226,psi4manual/1.9.x/api/psi4.core.Matrix.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.Matrix.html,2,['power'],['power']
Energy Efficiency,"Python; fchk. fchk¶. psi4.driver.fchk(wfn, filename, *, debug=False, strict_label=True)[source]¶; Function to write wavefunction information in wfn to filename in; Gaussian FCHK format. New in version 0.6. Returns:; None. Parameters:. wfn (Wavefunction) – set of molecule, basis, orbitals from which to generate fchk file; filename (str) – destination file name for FCHK file; debug (bool) – returns a dictionary to aid with debugging; strict_label (bool) – If true set a density label compliant with what Gaussian would write. A warning will be printed if this is not possible.; Otherwise set the density label according to the method name. Notes. A description of the FCHK format is http://wild.life.nctu.edu.tw/~jsyu/compchem/g09/g09ur/f_formchk.htm; The allowed headers for methods are general and limited, i.e., “Total SCF|MP2|CI|CC Density”,; PSI4 will try to find the right one for the current calculation. If strict_label=False the PSI4 method name will be used as label.; Not all theory modules in PSI4 are compatible with the FCHK writer.; A warning will be printed if a theory module is not supported.; Caution! For orbital-optimized correlated methods (e.g. DCT, OMP2) the ‘Orbital Energy’ field contains ambiguous data. Examples:. Parameters:. wfn (Wavefunction) – ; filename (str) – ; debug (bool) – ; strict_label (bool) – . >>> # [1] FCHK file for DFT calculation; >>> E, wfn = energy('b3lyp', return_wfn=True); >>> fchk(wfn, 'mycalc.fchk'). >>> # [2] FCHK file for correlated densities; >>> E, wfn = gradient('ccsd', return_wfn=True); >>> fchk(wfn, 'mycalc.fchk'). >>> # [2] Write FCHK file with non-standard label.; >>> E, wfn = gradient('mp2.5', return_wfn=True); >>> fchk(wfn, 'mycalc.fchk', strict_label=False). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.7;  · . PSI4. PSI4 API: Linking C++ and Python; fchk. © Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/api/psi4.driver.fchk.html:1497,energy,energy,1497,psi4manual/1.7.x/api/psi4.driver.fchk.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.driver.fchk.html,3,"['Energy', 'energy']","['Energy', 'energy']"
Energy Efficiency,"Python; fchk. fchk¶. psi4.driver.fchk(wfn, filename, *, debug=False, strict_label=True)[source]¶; Function to write wavefunction information in wfn to filename in; Gaussian FCHK format. New in version 0.6. Returns; None. Parameters. wfn (Wavefunction) – set of molecule, basis, orbitals from which to generate fchk file; filename (str) – destination file name for FCHK file; debug (bool) – returns a dictionary to aid with debugging; strict_label (bool) – If true set a density label compliant with what Gaussian would write. A warning will be printed if this is not possible.; Otherwise set the density label according to the method name. Notes. A description of the FCHK format is http://wild.life.nctu.edu.tw/~jsyu/compchem/g09/g09ur/f_formchk.htm; The allowed headers for methods are general and limited, i.e., “Total SCF|MP2|CI|CC Density”,; PSI4 will try to find the right one for the current calculation. If strict_label=False the PSI4 method name will be used as label.; Not all theory modules in PSI4 are compatible with the FCHK writer.; A warning will be printed if a theory module is not supported.; Caution! For orbital-optimized correlated methods (e.g. DCT, OMP2) the ‘Orbital Energy’ field contains ambiguous data. Examples. Parameters. wfn (psi4.core.Wavefunction) – ; filename (str) – ; debug (bool) – ; strict_label (bool) – . >>> # [1] FCHK file for DFT calculation; >>> E, wfn = energy('b3lyp', return_wfn=True); >>> fchk(wfn, 'mycalc.fchk'). >>> # [2] FCHK file for correlated densities; >>> E, wfn = gradient('ccsd', return_wfn=True); >>> fchk(wfn, 'mycalc.fchk'). >>> # [2] Write FCHK file with non-standard label.; >>> E, wfn = gradient('mp2.5', return_wfn=True); >>> fchk(wfn, 'mycalc.fchk', strict_label=False). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. PSI4 API: Linking C++ and Python; fchk. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/api/psi4.driver.fchk-1.html:1503,energy,energy,1503,psi4manual/1.4.0/api/psi4.driver.fchk-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/api/psi4.driver.fchk-1.html,6,"['Energy', 'energy']","['Energy', 'energy']"
Energy Efficiency,"Python; fchk. fchk¶. psi4.driver.fchk(wfn, filename, *, debug=False, strict_label=True)[source]¶; Function to write wavefunction information in wfn to filename in; Gaussian FCHK format. New in version 0.6. Returns; None. Parameters. wfn (Wavefunction) – set of molecule, basis, orbitals from which to generate fchk file; filename (str) – destination file name for FCHK file; debug (bool) – returns a dictionary to aid with debugging; strict_label (bool) – If true set a density label compliant with what Gaussian would write. A warning will be printed if this is not possible.; Otherwise set the density label according to the method name. Notes. A description of the FCHK format is http://wild.life.nctu.edu.tw/~jsyu/compchem/g09/g09ur/f_formchk.htm; The allowed headers for methods are general and limited, i.e., “Total SCF|MP2|CI|CC Density”,; PSI4 will try to find the right one for the current calculation. If strict_label=False the PSI4 method name will be used as label.; Not all theory modules in PSI4 are compatible with the FCHK writer.; A warning will be printed if a theory module is not supported.; Caution! For orbital-optimized correlated methods (e.g. DCT, OMP2) the ‘Orbital Energy’ field contains ambiguous data. Examples. Parameters. wfn (psi4.core.Wavefunction) – ; filename (str) – ; debug (bool) – ; strict_label (bool) – . >>> # [1] FCHK file for DFT calculation; >>> E, wfn = energy('b3lyp', return_wfn=True); >>> fchk(wfn, 'mycalc.fchk'). >>> # [2] FCHK file for correlated densities; >>> E, wfn = gradient('ccsd', return_wfn=True); >>> fchk(wfn, 'mycalc.fchk'). >>> # [2] Write FCHK file with non-standard label.; >>> E, wfn = gradient('mp2.5', return_wfn=True); >>> fchk(wfn, 'mycalc.fchk', strict_label=False). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.5;  · . PSI4. PSI4 API: Linking C++ and Python; fchk. © Copyright 2021, The Psi4 Project.; Last updated on Sunday, 28 November 2021 02:41AM.; Created using Sphinx 4.3.1.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/api/psi4.driver.fchk-1.html:1503,energy,energy,1503,psi4manual/1.5.0/api/psi4.driver.fchk-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/api/psi4.driver.fchk-1.html,6,"['Energy', 'energy']","['Energy', 'energy']"
Energy Efficiency,"Q (DETCI). DIIS_MAX_VECS (CEPA). (DCFT). (DETCI). (LMP2). (MCSCF). (OMP2). (OMP3). (PSIMRCC). (SCF). DIIS_MIN_VECS (DCFT). (DETCI). (SCF). DIIS_START (PSIMRCC). (SCF). DIIS_START_CONVERGENCE (DCFT). DIIS_START_ITER (DETCI). (LMP2). DIPMOM (CEPA). (DETCI). DISP_SIZE (FINDIF). DISPERSIONCORRECTIONENERGY. distance() in module qcdb.vecutil. distance_matrix() LibmintsMolecule method. DISTANT_PAIR_CUTOFF (LMP2). DISTRIBUTED_MATRIX (SCF). DO_ALL_TEI (TRANSQT). DO_LEVEL_SHIFT (OMP2). (OMP3). DO_SCS (OMP2). (OMP3). DO_SINGLETS (CPHF). DO_SOS (OMP2). (OMP3). DO_THIRD_ORDER (SAPT). DO_TRIPLETS (CPHF). DOCC (GLOBALS). (MCSCF). DOMAIN_PRINT (CIS). DOMAIN_PRINT_EXIT (LMP2). DOMAINS (CIS). dot() in module qcdb.vecutil. DOUBLE-HYBRIDCORRECTIONENERGY. driver module. drop_duplicates() in module procutil. dynamic_variable_bind() in module molutil. E. E3_SCALE (OMP3). E_CONVERGENCE (CCEOM). (DETCI). (LMP2). (MCSCF). (MRCC). (OMP2). (OMP3). (PSIMRCC). (SAPT). (SCF). energy(). setting keywords. energy() in module driver. entry_number() CoordEntry method. environment variable; . MKL_NUM_THREADS, [1]. OMP_NESTED, [1], [2]. OMP_NUM_THREADS, [1], [2], [3], [4], [5]. PATH, [1], [2], [3], [4]. PSI_SCRATCH, [1], [2], [3]. PYTHONPATH, [1], [2], [3], [4]. EOM_GUESS (CCEOM). EOM_REFERENCE (CCEOM). (CCHBAR). (CCSORT). equivalent() LibmintsMolecule method. everything() CartesianEntry method. CoordEntry method. CoordValue method. LibmintsMolecule method. NumberValue method. VariableValue method. ZMatrixEntry method. EX_ALLOW (DETCI). EX_LEVEL (DETCI). EXCITATION_RANGE (CCEOM). EXPLICIT_HAMILTONIAN (CPHF). EXTERN (SCF). extract_cluster_indexing() in module molutil. extract_clusters() in module molutil. extract_fragments() LibmintsMolecule method. extract_subsets() LibmintsMolecule method. extrapolation schemes. F. FAIL_ON_MAXITER (SCF). FAVG (MCSCF). FAVG_CCSD_T (PSIMRCC). FAVG_START (MCSCF). fcharge() LibmintsMolecule method. FCI (DETCI). FCI_STRINGS (DETCI). FCICORRELATIONENERGY. FCITOTALENERGY. Feat",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/genindex.html:18188,energy,energy,18188,psi4manual/4.0b3/genindex.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/genindex.html,1,['energy'],['energy']
Energy Efficiency,"QC variables. arrays()¶. Deprecated since version 1.4: Use psi4.core.Wavefunction.variables() instead. atomic_point_charges(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the set atomic point charges. basis_projection(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix, arg1: psi4.core.Dimension, arg2: psi4.core.BasisSet, arg3: psi4.core.BasisSet) → psi4.core.Matrix¶; Projects a orbital matrix from one basis to another. basisset(self: psi4.core.Wavefunction) → psi4.core.BasisSet¶; Returns the current orbital basis. beta_orbital_space(self: psi4.core.Wavefunction, arg0: str, arg1: str, arg2: str) → psi4.core.OrbitalSpace¶; docstring. static build(mol, basis=None, *, quiet=False)¶. Parameters; quiet (bool) – . c1_deep_copy(self: psi4.core.Wavefunction, basis: psi4.core.BasisSet) → psi4.core.Wavefunction¶; Returns a new wavefunction with internal data converted to \(C_1\) symmetry, using pre-c1-constructed basis. compute_energy(self: psi4.core.Wavefunction) → float¶; Computes the energy of the Wavefunction. compute_gradient(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Computes the gradient of the Wavefunction. compute_hessian(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Computes the Hessian of the Wavefunction. deep_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; Deep copies the internal data. del_array_variable(self: psi4.core.Wavefunction, arg0: str) → int¶; Removes the requested (case-insensitive) Matrix QC variable. del_potential_variable(self: psi4.core.Wavefunction, arg0: str) → int¶; Removes the requested (case-insensitive) ExternalPotential QC variable. (This function is provisional and might be removed in the future.). del_scalar_variable(self: psi4.core.Wavefunction, arg0: str) → int¶; Removes the requested (case-insensitive) double QC variable. del_variable(key)¶; Removes scalar or array QCVariable key from cls if present. Return type; None. Parameters. cls (psi4.core.Wavefunction) – ; key (str) – . density_",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/api/psi4.core.CCWavefunction.html:12823,energy,energy,12823,psi4manual/1.6.x/api/psi4.core.CCWavefunction.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/api/psi4.core.CCWavefunction.html,4,['energy'],['energy']
Energy Efficiency,"QCVariables. Returns; -------; float; Dispersion energy [Eh]. Notes; -----; :psivar:`DISPERSION CORRECTION ENERGY`; Disp always set. Overridden in SCF finalization, but that only changes for ""-3C"" methods.; :psivar:`fctl DISPERSION CORRECTION ENERGY`; Set if :py:attr:`fctldash` nonempty. """"""; if self.engine in ['dftd3', 'mp2d', ""dftd4""]:; resi = AtomicInput(; **{; 'driver': 'energy',; 'model': {; 'method': self.fctldash,; 'basis': '(auto)',; },; 'keywords': {; 'level_hint': self.dashlevel,; 'params_tweaks': self.dashparams,; 'dashcoeff_supplement': self.dashcoeff_supplement,; 'pair_resolved': self.save_pairwise_disp,; 'verbose': 1,; },; 'molecule': molecule.to_schema(dtype=2),; 'provenance': p4util.provenance_stamp(__name__),; }); jobrec = qcng.compute(; resi,; self.engine,; raise_error=True,; local_options={""scratch_directory"": core.IOManager.shared_object().get_default_path(), ""ncores"": core.get_num_threads()}). dashd_part = float(jobrec.extras['qcvars']['DISPERSION CORRECTION ENERGY']); if wfn is not None:; for k, qca in jobrec.extras['qcvars'].items():; if (""CURRENT"" not in k) and (""PAIRWISE"" not in k):; wfn.set_variable(k, float(qca) if isinstance(qca, str) else qca). # Pass along the pairwise dispersion decomposition if we need it; if self.save_pairwise_disp is True:; wfn.set_variable(""PAIRWISE DISPERSION CORRECTION ANALYSIS"",; jobrec.extras['qcvars'][""2-BODY PAIRWISE DISPERSION CORRECTION ANALYSIS""]). if self.fctldash in ['hf3c', 'pbeh3c']:; jobrec = qcng.compute(; resi,; ""gcp"",; raise_error=True,; local_options={""scratch_directory"": core.IOManager.shared_object().get_default_path(), ""ncores"": core.get_num_threads()}); gcp_part = jobrec.return_result; dashd_part += gcp_part. return dashd_part. else:; ene = self.disp.compute_energy(molecule); core.set_variable('DISPERSION CORRECTION ENERGY', ene); if self.fctldash:; core.set_variable(f""{self.fctldash} DISPERSION CORRECTION ENERGY"", ene); return ene. [docs] def compute_gradient(self,; molecule: core.Molecule,; w",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/empirical_dispersion.html:8213,ENERGY,ENERGY,8213,psi4manual/1.6.x/_modules/psi4/driver/procrouting/empirical_dispersion.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/empirical_dispersion.html,1,['ENERGY'],['ENERGY']
Energy Efficiency,"QM; geometry in a molecule name {...} block, internally the handling; of EFP is not so clean. In straightforward input files that involve; any number of [molecule block, energy/opt/etc, clean()] portions,; there should be no problem; the energy/opt computation will always; be run on the molecule defined in the preceding block. For advanced; users, unexpected difficulties may arise due to: (1) the EFP fragment; from the last molecule block executed will always be active (and; potentially interfering with SCF) and (2) recalling a molecule; through activate(name) (where name was the python handle; in the molecule block) will not load up any EFP portion of that; molecule. This divergent treatment is a stopgap while we determine; how best to handle molecules with different domains. At this time, PSI4 is only able to perform pure-efp single-points and; geometry optimizations and mixed qm/efp SCF single-points. name; molecule composition; calls method. efp; efp; efp. pure EFP; EFP interaction energy (IE) on all frags. mixed QM/EFP; EFP IE on EFP frags only. pure QM; error. scf; scf; scf. pure EFP; error. mixed QM/EFP; SCF energy on QM frags w/coupling to EFP frags, plus EFP IE on EFP frags. pure QM; SCF energy on all frags (normal PSI4 operation). Fragment Library¶; Below are documented the EFP fragments available from the LIBEFP library.; These systems are accessible in molecule {...} blocks without; additional configuration. How to configure libefp for building Psi4¶; Role and Dependencies. Role — In PSI4, libefp is a library that provides additional; molecular modeling capabilities (EFP).; Downstream Dependencies — PSI4 (\(\Leftarrow\) optional) libefp; Upstream Dependencies — libefp \(\Leftarrow\) BLAS/LAPACK. CMake Variables. ENABLE_libefp — CMake variable toggling whether Psi4 builds with libefp; CMAKE_PREFIX_PATH — CMake list variable to specify where pre-built dependencies can be found. For libefp, set to an installation directory containing include/efp.h; libefp_D",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/libefp-1.html:7031,energy,energy,7031,psi4manual/1.2.1/libefp-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/libefp-1.html,13,['energy'],['energy']
Energy Efficiency,"QM; geometry in a molecule name {...} block, internally the handling; of EFP is not so clean. In straightforward input files that involve; any number of [molecule block, energy/opt/etc, clean()] portions,; there should be no problem; the energy/opt computation will always; be run on the molecule defined in the preceding block. For advanced; users, unexpected difficulties may arise due to: (1) the EFP fragment; from the last molecule block executed will always be active (and; potentially interfering with SCF) and (2) recalling a molecule; through activate(name) (where name was the python handle; in the molecule block) will not load up any EFP portion of that; molecule. This divergent treatment is a stopgap while we determine; how best to handle molecules with different domains. At this time, PSI4 is only able to perform pure-efp single-points and; geometry optimizations and mixed qm/efp SCF single-points. name; molecule composition; calls method. efp; efp; efp. pure EFP; EFP interaction energy (IE) on all frags. mixed QM/EFP; EFP IE on EFP frags only. pure QM; error. scf; scf; scf. pure EFP; error. mixed QM/EFP; SCF energy on QM frags w/coupling to EFP frags, plus EFP IE on EFP frags. pure QM; SCF energy on all frags (normal PSI4 operation). Fragment Library¶; Below are documented the EFP fragments available from the LIBEFP library.; These systems are accessible in molecule {...} blocks without; additional configuration. How to configure libefp for building Psi4¶; Role and Dependencies. Role — In PSI4, libefp is a library that provides additional; molecular modeling capabilities (EFP).; Downstream Dependencies — PSI4 (\(\Leftarrow\) optional) libefp; Upstream Dependencies — libefp \(\Leftarrow\) None. CMake Variables. ENABLE_libefp — CMake variable toggling whether Psi4 builds with libefp; CMAKE_PREFIX_PATH — CMake list variable to specify where pre-built dependencies can be found. For libefp, set to an installation directory containing include/efp.h; libefp_DIR — CM",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/libefp-1.html:6895,energy,energy,6895,psi4manual/1.1.0/libefp-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/libefp-1.html,2,['energy'],['energy']
Energy Efficiency,"QM; geometry in a molecule name {...} block, internally the handling; of EFP is not so clean. In straightforward input files that involve; any number of [molecule block, energy/opt/etc, clean()] portions,; there should be no problem; the energy/opt computation will always; be run on the molecule defined in the preceding block. For advanced; users, unexpected difficulties may arise due to: (1) the EFP fragment; from the last molecule block executed will always be active (and; potentially interfering with SCF) and (2) recalling a molecule; through activate(name) (where name was the python handle; in the molecule block) will not load up any EFP portion of that; molecule. This divergent treatment is a stopgap while we determine; how best to handle molecules with different domains. At this time, Psi4 is only able to perform pure-efp single-points and; geometry optimizations and mixed qm/efp SCF single-points. name; molecule composition; calls method. efp; efp; efp. pure EFP; EFP interaction energy (IE) on all frags. mixed QM/EFP; EFP IE on EFP frags only. pure QM; error. scf; scf; scf. pure EFP; error. mixed QM/EFP; SCF energy on QM frags w/coupling to EFP frags, plus EFP IE on EFP frags. pure QM; SCF energy on all frags (normal Psi4 operation). Fragment Library¶; Below are documented the EFP fragments available from the LIBEFP library.; These systems are accessible in molecule {...} blocks without; additional configuration. 2aminopyridine¶. rotate: click+drag; translate: alt+click+drag; zoom: scroll. Visualization by ChemDoodle Web; Comment; 2-aminopyridine, S22 Complex Elec.: 6-31G* Rest: 6-311++G(3df,2p). Full Geometry in Angstroms; N -0.297712 -1.170382 0.001714; C -0.912531 0.026013 0.004723; C -0.175714 1.226496 0.003700; C 1.204216 1.176210 0.000547; C 1.842683 -0.065832 -0.001280; C 1.045154 -1.196712 0.000533; H -0.697132 2.173907 0.003778; H 1.778223 2.092763 0.001427; H 2.918377 -0.152929 -0.000909; H 1.493951 -2.183173 0.004591; N -2.277071 0.027597 -0.043650",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/libefp-1.html:6189,energy,energy,6189,psi4manual/1.0.0/libefp-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/libefp-1.html,2,['energy'],['energy']
Energy Efficiency,R ENERGIES (array); CC ALPHA-BETA PAIR ENERGIES (array); CC CORRELATION ENERGY; CC D1 DIAGNOSTIC; CC D2 DIAGNOSTIC; CC NEW D1 DIAGNOSTIC; CC SINGLET PAIR ENERGIES (array); CC T1 DIAGNOSTIC; CC TOTAL ENERGY; CC TRIPLET PAIR ENERGIES (array); CC2 ALPHA-ALPHA PAIR ENERGIES; CC2 ALPHA-BETA PAIR ENERGIES; CC2 CORRELATION ENERGY; CC2 DIPOLE POLARIZABILITY @ xNM; CC2 DIPOLE POLARIZABILITY TENSOR @ xNM; CC2 QUADRUPOLE POLARIZABILITY TENSOR @ xNM; CC2 ROTATION (LEN) ORIGIN-DEPENDENCE @ xNM; CC2 SINGLET PAIR ENERGIES; CC2 SPECIFIC ROTATION (LEN) @ xNM; CC2 SPECIFIC ROTATION (MVG) @ xNM; CC2 SPECIFIC ROTATION (VEL) @ xNM; CC2 TOTAL ENERGY; CC2 TRIPLET PAIR ENERGIES; CC3 ALPHA-ALPHA PAIR ENERGIES; CC3 ALPHA-BETA PAIR ENERGIES; CC3 CORRELATION ENERGY; CC3 SINGLET PAIR ENERGIES; CC3 TOTAL ENERGY; CC3 TRIPLET PAIR ENERGIES; CCSD ALPHA-ALPHA PAIR ENERGIES; CCSD ALPHA-BETA PAIR ENERGIES; CCSD CORRELATION ENERGY; CCSD DIPOLE POLARIZABILITY @ xNM; CCSD DIPOLE POLARIZABILITY TENSOR @ xNM; CCSD DOUBLES ENERGY; CCSD ITERATIONS; CCSD OPPOSITE-SPIN CORRELATION ENERGY; CCSD QUADRUPOLE POLARIZABILITY TENSOR @ xNM; CCSD ROTATION (LEN) ORIGIN-DEPENDENCE @ xNM; CCSD SAME-SPIN CORRELATION ENERGY; CCSD SINGLES ENERGY; CCSD SINGLET PAIR ENERGIES; CCSD SPECIFIC ROTATION (LEN) @ xNM; CCSD SPECIFIC ROTATION (MVG) @ xNM; CCSD SPECIFIC ROTATION (VEL) @ xNM; CCSD TOTAL ENERGY; CCSD TRIPLET PAIR ENERGIES; CCSD(T) CORRELATION ENERGY; CCSD(T) TOTAL ENERGY; CCname ROOT m (IN h) -> ROOT n (IN i) EINSTEIN A (LEN); CCname ROOT m (IN h) -> ROOT n (IN i) EINSTEIN B (LEN); CCname ROOT m (IN h) -> ROOT n (IN i) OSCILLATOR STRENGTH (LEN); CCname ROOT m (IN h) -> ROOT n (IN i) ROTATORY STRENGTH (LEN); CCname ROOT m (IN h) -> ROOT n (IN i) ROTATORY STRENGTH (VEL); CCname ROOT m (h) -> ROOT n (i) EINSTEIN A (LEN); CCname ROOT m (h) -> ROOT n (i) EINSTEIN B (LEN); CCname ROOT m (h) -> ROOT n (i) OSCILLATOR STRENGTH (LEN); CCname ROOT m (h) -> ROOT n (i) ROTATORY STRENGTH (LEN); CCname ROOT m (h) -> ROOT n (i) ROTATORY S,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/autodir_psivariables/module__ccenergy.html:1471,ENERGY,ENERGY,1471,psi4manual/1.6.x/autodir_psivariables/module__ccenergy.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/autodir_psivariables/module__ccenergy.html,1,['ENERGY'],['ENERGY']
Energy Efficiency,"R ENERGY; SAPT EXCH-IND30,R(S^INF) ENERGY; SAPT EXCH10 ENERGY; SAPT EXCH10(S^2) ENERGY; SAPT EXCH11(S^2) ENERGY; SAPT EXCH12(S^2) ENERGY; SAPT HF TOTAL ENERGY; SAPT IND ENERGY; SAPT IND-DISP30 ENERGY; SAPT IND20,R ENERGY; SAPT IND20,U ENERGY; SAPT IND22 ENERGY; SAPT IND30,R ENERGY; SAPT MP2 CORRELATION ENERGY; SAPT SAME-SPIN DISP20 ENERGY; SAPT SAME-SPIN EXCH-DISP20 ENERGY; SAPT TOTAL ENERGY; SAPT0 DISP ENERGY; SAPT0 ELST ENERGY; SAPT0 EXCH ENERGY; SAPT0 IND ENERGY; SAPT0 TOTAL ENERGY; SAPT2 DISP ENERGY; SAPT2 ELST ENERGY; SAPT2 EXCH ENERGY; SAPT2 IND ENERGY; SAPT2 TOTAL ENERGY; SAPT2+ DISP ENERGY; SAPT2+ ELST ENERGY; SAPT2+ EXCH ENERGY; SAPT2+ IND ENERGY; SAPT2+ TOTAL ENERGY; SAPT2+(3) DISP ENERGY; SAPT2+(3) ELST ENERGY; SAPT2+(3) EXCH ENERGY; SAPT2+(3) IND ENERGY; SAPT2+(3) TOTAL ENERGY; SAPT2+(3)(CCD) DISP ENERGY; SAPT2+(3)(CCD) ELST ENERGY; SAPT2+(3)(CCD) EXCH ENERGY; SAPT2+(3)(CCD) IND ENERGY; SAPT2+(3)(CCD) TOTAL ENERGY; SAPT2+(3)(CCD)DMP2 DISP ENERGY; SAPT2+(3)(CCD)DMP2 ELST ENERGY; SAPT2+(3)(CCD)DMP2 EXCH ENERGY; SAPT2+(3)(CCD)DMP2 IND ENERGY; SAPT2+(3)(CCD)DMP2 TOTAL ENERGY; SAPT2+(3)DMP2 DISP ENERGY; SAPT2+(3)DMP2 ELST ENERGY; SAPT2+(3)DMP2 EXCH ENERGY; SAPT2+(3)DMP2 IND ENERGY; SAPT2+(3)DMP2 TOTAL ENERGY; SAPT2+(CCD) DISP ENERGY; SAPT2+(CCD) ELST ENERGY; SAPT2+(CCD) EXCH ENERGY; SAPT2+(CCD) IND ENERGY; SAPT2+(CCD) TOTAL ENERGY; SAPT2+(CCD)DMP2 DISP ENERGY; SAPT2+(CCD)DMP2 ELST ENERGY; SAPT2+(CCD)DMP2 EXCH ENERGY; SAPT2+(CCD)DMP2 IND ENERGY; SAPT2+(CCD)DMP2 TOTAL ENERGY; SAPT2+3 DISP ENERGY; SAPT2+3 ELST ENERGY; SAPT2+3 EXCH ENERGY; SAPT2+3 IND ENERGY; SAPT2+3 TOTAL ENERGY; SAPT2+3(CCD) DISP ENERGY; SAPT2+3(CCD) ELST ENERGY; SAPT2+3(CCD) EXCH ENERGY; SAPT2+3(CCD) IND ENERGY; SAPT2+3(CCD) TOTAL ENERGY; SAPT2+3(CCD)DMP2 DISP ENERGY; SAPT2+3(CCD)DMP2 ELST ENERGY; SAPT2+3(CCD)DMP2 EXCH ENERGY; SAPT2+3(CCD)DMP2 IND ENERGY; SAPT2+3(CCD)DMP2 TOTAL ENERGY; SAPT2+3DMP2 DISP ENERGY; SAPT2+3DMP2 ELST ENERGY; SAPT2+3DMP2 EXCH ENERGY; SAPT2+3DMP2 IND ENERGY; SAPT2+3DMP2",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/autodir_psivariables/module__sapt.html:1865,ENERGY,ENERGY,1865,psi4manual/1.6.x/autodir_psivariables/module__sapt.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/autodir_psivariables/module__sapt.html,5,['ENERGY'],['ENERGY']
Energy Efficiency,"R-CIS(D) and PR-ADC(2)]; and the implementation for ADC(2) excitation energies within PSI4. “Excited State Calculation for Free-Base and Metalloporphyrins with; the Partially Renormalized Polarization Propagator Approach,”; M. Saitow and Y. Mochizuki, Chem. Phys. Lett. 525, 144-149; (2012).; (doi: 10.1016/j.cplett.2011.12.063). Density Matrix Renormalization Group (DMRG)¶. “CheMPS2: a free open-source spin-adapted implementation of the density; matrix renormalization group for ab initio quantum chemistry,”; S. Wouters, W. Poelmans, P. W. Ayers and D. Van Neck,; Comput. Phys. Commun. 185 (6), 1501-1514 (2014).; (doi: 10.1016/j.cpc.2014.01.019).; “The density matrix renormalization group for ab initio quantum chemistry,”; S. Wouters and D. Van Neck, Eur. Phys. J. D 68 (9), 272 (2014).; (doi: 10.1140/epjd/e2014-50500-1). Scalar Relativistic Corrections¶; General theory for the exact two-component approach (X2C). “Analytic energy gradients for the spin-free exact two-component theory; using an exact block diagonalization for the one-electron Dirac; Hamiltonian,”; L. Cheng and J. Gauss, J. Chem. Phys. 135, 084114 (2011).; (doi: 10.1063/1.3624397). Implementation within Psi4. “Predicting Near Edge X-ray Absorption Spectra with the Spin-Free; Exact-Two-Component Hamiltonian and Orthogonality Constrained Density; Functional Theory,”; P. Verma, W. D. Derricotte and F. A. Evangelista,; J. Chem. Theory Comput. (2015).; (doi: 10.1021/acs.jctc.5b00817). Supported Systems¶. ArchitecturesThe majority of PSI4 was developed on Mac and Linux machines; in; principle, it should work on any Unix system. The latest version of the; PSI4 program package may be obtained at psicode.org.; The package is available as a binary (Installing from Binary) for Linux, macOS (not arm64), or Windows (both native and via Windows Subsystem for; Linux aka Bash on Ubuntu on Windows); or as source code (git repository or zipped archive from; https://github.com/psi4/psi4. CompilersPSI4 has been successfully ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/introduction.html:21347,energy,energy,21347,psi4manual/1.6.x/introduction.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/introduction.html,1,['energy'],['energy']
Energy Efficiency,"R-CIS(D) and PR-ADC(2)]; and the implementation for ADC(2) excitation energies within PSI4. “Excited State Calculation for Free-Base and Metalloporphyrins with; the Partially Renormalized Polarization Propagator Approach,”; M. Saitow and Y. Mochizuki, Chem. Phys. Lett. 525, 144-149; (2012).; (doi: 10.1016/j.cplett.2011.12.063). Density Matrix Renormalization Group (DMRG)¶. “CheMPS2: a free open-source spin-adapted implementation of the density; matrix renormalization group for ab initio quantum chemistry,”; S. Wouters, W. Poelmans, P. W. Ayers and D. Van Neck,; Comput. Phys. Commun. 185 (6), 1501-1514 (2014).; (doi: 10.1016/j.cpc.2014.01.019).; “The density matrix renormalization group for ab initio quantum chemistry,”; S. Wouters and D. Van Neck, Eur. Phys. J. D 68 (9), 272 (2014).; (doi: 10.1140/epjd/e2014-50500-1). Scalar Relativistic Corrections¶; General theory for the exact two-component approach (X2C). “Analytic energy gradients for the spin-free exact two-component theory; using an exact block diagonalization for the one-electron Dirac; Hamiltonian,”; L. Cheng and J. Gauss, J. Chem. Phys. 135, 084114 (2011).; (doi: 10.1063/1.3624397). Implementation within Psi4. “Predicting Near Edge X-ray Absorption Spectra with the Spin-Free; Exact-Two-Component Hamiltonian and Orthogonality Constrained Density; Functional Theory,”; P. Verma, W. D. Derricotte and F. A. Evangelista,; J. Chem. Theory Comput. (2015).; (doi: 10.1021/acs.jctc.5b00817). Supported Systems¶. ArchitecturesThe majority of PSI4 was developed on Mac and Linux machines; in; principle, it should work on any Unix system. The latest version of the; PSI4 program package may be obtained at psicode.org.; The package is available as a binary (Installing from Binary) for Linux, macOS, or Windows (both native and via Windows Subsystem for; Linux aka Bash on Ubuntu on Windows); or as source code (git repository or zipped archive from; https://github.com/psi4/psi4. CompilersPSI4 has been successfully compiled usi",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/introduction-1.html:21347,energy,energy,21347,psi4manual/1.4.0/introduction-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/introduction-1.html,4,['energy'],['energy']
Energy Efficiency,"R/cc-pVDZ dynamic polarizabilities of HOF molecule. dfomp2-2; OMP2 cc-pVDZ energy for the NO molecule. cc40; RHF-CC2-LR/cc-pVDZ optical rotation of H2O2. gauge = length, omega= (589 355 nm). dfcasscf-sa-sp; Example of state-averaged CASSCF for the C2 molecule. opt-irc-2; Compute the IRC for HCN <-> NCH interconversion at the RHF/DZP level of theory. cisd-h2o+-1; 6-31G** H2O+ Test CISD Energy Point. aediis-1; ADIIS test case, from 10.1063/1.3304922. scf-response2; Compute the dipole polarizability for water with custom basis set. cbs-xtpl-wrapper; RHF aug-cc-pVQZ energy for the BH molecule, with Cartesian input. Various gradients for a strained helium dimer and water molecule. scf-coverage; Lithium test for coverage. pywrap-checkrun-rhf; This checks that all energy methods can run with a minimal input and set symmetry. cisd-sp; 6-31G** H2O Test CISD Energy Point. tdscf-7; TD-HF test variable access. mbis-2; MBIS calculation on OH- (Expanded Arrays). sapt-dft1; SAPT(DFT) aug-cc-pVDZ interaction energy between Ne and Ar atoms. fci-h2o-fzcv; 6-31G H2O Test FCI Energy Point. mints3; Test individual integral objects for correctness. cbs-xtpl-nbody; RHF interaction energies using nbody and cbs parts of the driver Ne dimer with mp2/v[dt]z + d:ccsd(t)/vdz. cisd-opt-fd; H2O CISD/6-31G** Optimize Geometry by Energies. linK-3; UHF and ROHF Linear Exchange Algorithm test for benzyl cation. pubchem2; Superficial test of PubChem interface. sapt3; SAPT2+3(CCD) aug-cc-pVDZ+midbond computation of the water dimer interaction energy, using the aug-cc-pVDZ-JKFIT DF basis for SCF and aug-cc-pVDZ-RI for SAPT. olccd1; OLCCD cc-pVDZ energy for the H2O molecule. cc42; RHF-CC2-LR/STO-3G optical rotation of (S)-methyloxirane. gauge = length, omega = (589 355 nm). cepa2; cc-pvdz H2O Test ACPF Energy/Properties. cc48; reproduces dipole moments in J.F. Stanton’s “biorthogonal” JCP paper. sapt7; SAPT0 open-shell computation of H2O-HO2 interaction energy First with cc-pVDZ and density fitted integra",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/autodoc_testsuite_corepsi4.html:5649,energy,energy,5649,psi4manual/1.8.x/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/autodoc_testsuite_corepsi4.html,2,['energy'],['energy']
Energy Efficiency,"R; H 1 R 2 A. R = 1.075; A = 133.93; }. set reference uhf; set guess gwh; set basis cc-pvdz; set e_convergence 8. # Override the default value of omega; set dft_omega 2.0. E = energy('wb97x'). # Revoke the change for later computations if needed; revoke_global_option_changed('DFT_OMEGA'). This feature would be useful after finishing IP fitting procedure, for example.; Furthermore, new DFT functionals can be created from scratch from within the input file:; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19; 20; 21; 22; 23; 24; 25; 26; 27; 28# DFT Custom Functional. molecule h2o {; 0 1; O; H 1 1.0; H 1 1.0 2 104.5; }. set {; basis sto-3g; dft_spherical_points 302; dft_radial_points 99; reference rks; }. pbe0 = {; ""name"": ""my_PBE0"",; ""x_functionals"": {""GGA_X_PBE"": {""alpha"": 0.75}},; ""x_hf"": {""alpha"": 0.25},; ""c_functionals"": {""GGA_C_PBE"": {}}; }. func_call = energy('SCF', dft_functional=pbe0). # as PBE0 is a pre-defined functional, the call above is equivalent to both below:; func_call = energy('SCF', dft_functional=""PBE0""); func_call = energy('PBE0'). Supported keywords include:. name: string, name of the functional, for custom defined functionals used for printing only.; xc_functionals: dict, definition of a complete (X + C) functional based in LibXC name; x_functionals: dict, definition of exchange functionals using LibXC names; c_functionals: dict, definition of correlation functionals using LibXC names; x_hf: dict, parameters dealing with exact (HF) exchange settings for hybrid DFT; c_mp2: dict, parameters dealing with MP2 correlation for double hybrid DFT; dispersion: dict, definition of dispersion corrections; citation: string, citation for the method, for printing purposes; description: string, description of the method, for printing purposes. The full interface is defined in :ref:driver/procrouting/dft_funcs/dict_builder.py, all standard; functionals provided in Psi4 are implemented in the dict_*_funcs.py files in the same folder. table of cont",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/dft-1.html:29500,energy,energy,29500,psi4manual/1.2.1/dft-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/dft-1.html,4,['energy'],['energy']
Energy Efficiency,"RADIENT¶; The derivative of the requested DFT method dipole [E_h a0/u] = [(e a0/a0)^2/u] with respect to nuclear perturbations; as a degree-of-freedom by dipole component array, (3 * {nat}, 3). DFT TOTAL HESSIAN¶; The total electronic second derivative [E_h/a0/a0] for the requested DFT method, (3 * {nat}, 3 * {nat}). DFT XC ENERGY¶; The functional energy contribution [E_h] to the total SCF energy (DFT only).; Quantity \(E_{xc}\) in Eqs. (4) and (1). DFT VV10 ENERGY¶; The VV10 nonlocal contribution [E_h] to the total SCF energy (DFT only).; Included in DFT FUNCTIONAL TOTAL ENERGY. DISPERSION CORRECTION ENERGY¶. fctl DISPERSION CORRECTION ENERGY¶; The dispersion correction [E_h] appended to an underlying functional; when a DFT-D method is requested. Quantity \(E_{\text{-D}}\); in Eqs. (4) and (1).; When dispersion parameters are untweaked for a functional and dispersion; level, labeled QCVariable also defined. DOUBLE-HYBRID CORRECTION ENERGY¶; The scaled MP2 correlation energy correction [E_h] appended to an; underlying functional when a DH-DFT method is requested.; Quantity \(E_{\text{DH}}\) in Eq. (1). DMA DISTRIBUTED MULTIPOLES¶; Distributed multipoles in units given by GDMA_MULTIPOLE_UNITS; with the row index corresponding to the site and the column index; referencing the multipole component. Both indices are zero based,; and the Qlm components of the multipoles are ordered as Q00, Q10,; Q11c, Q11s, Q20, Q21c, Q21s, Q22c, Q22s, etc. DMA TOTAL MULTIPOLES¶; Distributed multipoles as a single row, whose columns are the total; multipoles, translated to GDMA_ORIGIN, and summed. DMRG-SCF TOTAL ENERGY¶; The total DMRG total electonic energy [E_h]. Not unique because oribital spaces vary. DMRG-CASPT2 TOTAL ENERGY¶; The total DMRG plus CASPT2 total electonic energy [E_h] . Not unique because orbital spaces vary. EFP DISP ENERGY¶. EFP ELST ENERGY¶. EFP EXCH ENERGY¶. EFP IND ENERGY¶; Respectively, the dispersion, electrostatics, exchange, and induction; components of the tot",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/glossary_psivariables.html:29988,energy,energy,29988,psi4manual/1.7.x/glossary_psivariables.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/glossary_psivariables.html,4,['energy'],['energy']
Energy Efficiency,"RAGED CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for state-averaged CI/CASSCF levels of theory. CI TOTAL ENERGY¶. CI CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the requested configuration interaction level of theory and root. CISD DIPOLE X¶. CISD DIPOLE Y¶. CISD DIPOLE Z¶; The three components of the dipole [Debye] for the; configuration interaction singles and doubles level of theory and root. CISD QUADRUPOLE XX¶. CISD QUADRUPOLE XY¶. CISD QUADRUPOLE XZ¶. CISD QUADRUPOLE YY¶. CISD QUADRUPOLE YZ¶. CISD QUADRUPOLE ZZ¶; The six components of the quadrupole [Debye Ang] for the; configuration interaction singles and doubles level of theory and root. CISD TOTAL ENERGY¶. CISD CORRELATION ENERGY¶. CISDT TOTAL ENERGY¶. CISDT CORRELATION ENERGY¶. CISDTQ CORRELATION ENERGY¶. CISDTQ TOTAL ENERGY¶. CIn CORRELATION ENERGY¶. CIn TOTAL ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the labeled configuration interaction level of theory and root.; n is CI order for n > 4. CP-CORRECTED 2-BODY INTERACTION ENERGY¶; The interaction energy [H] considering only two-body interactions,; computed with counterpoise correction.; Related variable UNCP-CORRECTED 2-BODY INTERACTION ENERGY. CURRENT CORRELATION ENERGY¶; The correlation energy [H] corresponding to the CURRENT ENERGY variable. CURRENT ENERGY¶; The total electronic energy [H] of the most recent stage of a; calculation (frequently overwritten). This is the quantity tracked by; the geometry optimizer. CURRENT REFERENCE ENERGY¶; The total electronic energy [H] of the reference stage corresponding to; the CURRENT ENERGY variable. db_name DATABASE MEAN ABSOLUTE DEVIATION¶; The mean absolute deviation [kcal mol-1] of the requested method; name from the stored reference values for the requested reactions in; database db_name. If no reference is available, this will be a large; and nonsensical value. db_name D",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/glossary_psivariables-1.html:8772,energy,energy,8772,psi4manual/1.0.0/glossary_psivariables-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/glossary_psivariables-1.html,16,['energy'],['energy']
Energy Efficiency,"RAGED CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for state-averaged CI/CASSCF levels of theory. CI TOTAL ENERGY¶. CI CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the requested configuration interaction level of theory and root. CISD DIPOLE X¶. CISD DIPOLE Y¶. CISD DIPOLE Z¶; The three components of the dipole [Debye] for the; configuration interaction singles and doubles level of theory and root. CISD QUADRUPOLE XX¶. CISD QUADRUPOLE XY¶. CISD QUADRUPOLE XZ¶. CISD QUADRUPOLE YY¶. CISD QUADRUPOLE YZ¶. CISD QUADRUPOLE ZZ¶; The six components of the quadrupole [Debye Ang] for the; configuration interaction singles and doubles level of theory and root. CISD TOTAL ENERGY¶. CISD CORRELATION ENERGY¶. CISDT TOTAL ENERGY¶. CISDT CORRELATION ENERGY¶. CISDTQ CORRELATION ENERGY¶. CISDTQ TOTAL ENERGY¶. CIn CORRELATION ENERGY¶. CIn TOTAL ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the labeled configuration interaction level of theory and root.; n is CI order for n > 4. CP-CORRECTED 2-BODY INTERACTION ENERGY¶; The interaction energy [H] considering only two-body interactions,; computed with counterpoise correction.; Related variable UNCP-CORRECTED 2-BODY INTERACTION ENERGY. \[E_{\text{IE}} = E_{dimer} - \sum_{monomer}^{n}{E_{monomer}^{\text{CP}}}\]. CURRENT CORRELATION ENERGY¶; The correlation energy [H] corresponding to the CURRENT ENERGY variable. CURRENT ENERGY¶; The total electronic energy [H] of the most recent stage of a; calculation (frequently overwritten). This is the quantity tracked by; the geometry optimizer. CURRENT REFERENCE ENERGY¶; The total electronic energy [H] of the reference stage corresponding to; the CURRENT ENERGY variable. db_name DATABASE MEAN ABSOLUTE DEVIATION¶; The mean absolute deviation [kcal mol-1] of the requested method; name from the stored reference values for the requested reactions in; database db_name. If no r",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/glossary_psivariables-1.html:9280,energy,energy,9280,psi4manual/1.1.0/glossary_psivariables-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/glossary_psivariables-1.html,12,['energy'],['energy']
Energy Efficiency,"RAG_MODE, generate the internal coordinates, and see how multiple; fragment systems are defined.; Coordinates may be frozen by adding an asterisk after the letter of the coordinate. The; asterisk results in that internal coordinate being frozen at its initial value. The; “intco” file below for water specifies an optimization with both O-H bonds frozen.:; F 1 3; R* 1 2; R* 1 3; B 2 1 3. If one instead wishes to optimize toward (“fix”) a value that is not satisfied by the; initial structure, then the value is added to the end of the line. The following; corresponds to an optimization that will add additional forces to move the O-H bonds; to 1.70 au.; F 1 3; R 1 2 1.70; R 1 3 1.70; B 2 1 3. Convergence Criteria¶; Optking monitors five quantities to evaluate the progress of a geometry; optimization. These are (with their keywords) the change in energy; (MAX_ENERGY_G_CONVERGENCE), the maximum element of; the gradient (MAX_FORCE_G_CONVERGENCE), the root-mean-square; of the gradient (RMS_FORCE_G_CONVERGENCE), the maximum element; of displacement (MAX_DISP_G_CONVERGENCE), and the; root-mean-square of displacement (RMS_DISP_G_CONVERGENCE),; all in internal coordinates and atomic units. Usually, these options will not; be set directly. Primary control for geometry convergence lies with the keyword; G_CONVERGENCE which sets the aforementioned in accordance; with Table Geometry Convergence. Summary of sets of geometry optimization criteria available in PSI4¶. G_CONVERGENCE; Max Energy; Max Force; RMS Force; Max Disp; RMS Disp. NWCHEM_LOOSE 4. \(4.5 \times 10^{-3}\); \(3.0 \times 10^{-3}\); \(5.4 \times 10^{-3}\); \(3.6 \times 10^{-3}\). GAU_LOOSE 6. \(2.5 \times 10^{-3}\); \(1.7 \times 10^{-3}\); \(1.0 \times 10^{-2}\); \(6.7 \times 10^{-3}\). TURBOMOLE 4; \(1.0 \times 10^{-6}\); \(1.0 \times 10^{-3}\); \(5.0 \times 10^{-4}\); \(1.0 \times 10^{-3}\); \(5.0 \times 10^{-4}\). GAU 3 6. \(4.5 \times 10^{-4}\); \(3.0 \times 10^{-4}\); \(1.8 \times 10^{-3}\); \(1.2 \times 10^{-3}\). C",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/optking-1.html:10948,energy,energy,10948,psi4manual/1.4.0/optking-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/optking-1.html,5,['energy'],['energy']
Energy Efficiency,"RAG_MODE, generate the internal coordinates, and see how multiple; fragment systems are defined.; Coordinates may be frozen by adding an asterisk after the letter of the coordinate. The; asterisk results in that internal coordinate being frozen at its initial value. The; “intco” file below for water specifies an optimization with both O-H bonds frozen.:; F 1 3; R* 1 2; R* 1 3; B 2 1 3. If one instead wishes to optimize toward (“fix”) a value that is not satisfied by the; initial structure, then the value is added to the end of the line. The following; corresponds to an optimization that will add additional forces to move the O-H bonds; to 1.70 au.; F 1 3; R 1 2 1.70; R 1 3 1.70; B 2 1 3. Convergence Criteria¶; Optking monitors five quantities to evaluate the progress of a geometry; optimization. These are (with their keywords) the change in energy; (MAX_ENERGY_G_CONVERGENCE), the maximum element of; the gradient (MAX_FORCE_G_CONVERGENCE), the root-mean-square; of the gradient (RMS_FORCE_G_CONVERGENCE), the maximum element; of displacement (MAX_DISP_G_CONVERGENCE), and the; root-mean-square of displacement (RMS_DISP_G_CONVERGENCE),; all in internal coordinates and atomic units. Usually, these options will not; be set directly. Primary control for geometry convergence lies with the keyword; G_CONVERGENCE which sets the aforementioned in accordance; with Table Geometry Convergence. Summary of sets of geometry optimization criteria available in Psi4¶. G_CONVERGENCE; Max Energy; Max Force; RMS Force; Max Disp; RMS Disp. NWCHEM_LOOSE [4];  . GAU_LOOSE [6];  . TURBOMOLE [4]. GAU [3] [6];  . CFOUR [4];  ;  .  ;  . QCHEM [1] [5].  .  . MOLPRO [2] [5].  .  . GAU_TIGHT [3] [6];  . GAU_VERYTIGHT [6];  . Footnotes. [1]Default. [2]Baker convergence criteria are the same. [3](1, 2) Counterpart NWCHEM convergence criteria are the same. [4](1, 2, 3) Convergence achieved when all active criteria are fulfilled. [5](1, 2, 3) Convergence achieved when Max Force and one of Max Energy or M",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/optking-1.html:10961,energy,energy,10961,psi4manual/1.0.0/optking-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/optking-1.html,2,['energy'],['energy']
Energy Efficiency,"RAMAN (CFOUR). CFOUR_RESTART_CC (CFOUR). CFOUR_ROT_EVEC (CFOUR). CFOUR_SAVE_INTS (CFOUR). CFOUR_SCALE_ON (CFOUR). CFOUR_SCF_CONV (CFOUR). CFOUR_SCF_DAMPING (CFOUR). CFOUR_SCF_EXPORDER (CFOUR). CFOUR_SCF_EXPSTART (CFOUR). CFOUR_SCF_EXTRAPOLATION (CFOUR). CFOUR_SCF_MAXCYC (CFOUR). CFOUR_SD_FIELD (CFOUR). CFOUR_SPHERICAL (CFOUR). CFOUR_SPIN_FLIP (CFOUR). CFOUR_SPIN_ORBIT (CFOUR). CFOUR_SPIN_SCAL (CFOUR). CFOUR_SPINROTATION (CFOUR). CFOUR_SUBGROUP (CFOUR). CFOUR_SYM_CHECK (CFOUR). CFOUR_SYMMETRY (CFOUR). CFOUR_T3_EXTRAPOL (CFOUR). CFOUR_TAMP_SUM (CFOUR). CFOUR_THERMOCHEMISTRY (CFOUR). CFOUR_TRANS_INV (CFOUR). CFOUR_TREAT_PERT (CFOUR). CFOUR_UIJ_THRESHOLD (CFOUR). CFOUR_UNITS (CFOUR). CFOUR_UPDATE_HESSIAN (CFOUR). CFOUR_VIBRATION (CFOUR). CFOUR_VTRAN (CFOUR). CFOUR_XFIELD (CFOUR). CFOUR_XFORM_TOL (CFOUR). CFOUR_YFIELD (CFOUR). CFOUR_ZFIELD (CFOUR). CFOURERRORCODE. chain_dot() psi4.core.Matrix method, [1], [2]. change_file_namespace() psi4.core.IO method, [1], [2]. charge. ; molecule. charge() psi4.core.Molecule method, [1], [2]. check_iwl_file_from_scf_type() in module psi4.driver. CheMPS2. CHOLESKY (DFOCC). cholesky_factorize() psi4.core.Matrix method, [1], [2]. CHOLESKY_TOLERANCE (DFOCC). (FNOCC). (SCF). CI. arbitrary-order coupled-cluster theory. arbitrary-order perturbation theory. basic-keywords. theory. CI_DIIS (MCSCF). CI_FILE_START (DETCI). CI_MAXITER (DETCI). ci_nat_orbs() psi4.core.CIWavefunction method, [1], [2]. CI_NUM_THREADS (DETCI). CI_TYPE (GLOBALS). CIBLKS_PRINT (DETCI). CICORRELATIONENERGY. CIDIPOLEX. CIDIPOLEY. CIDIPOLEZ. CInCORRELATIONENERGY. CInTOTALENERGY. CIQUADRUPOLEXX. CIQUADRUPOLEXY. CIQUADRUPOLEXZ. CIQUADRUPOLEYY. CIQUADRUPOLEYZ. CIQUADRUPOLEZZ. CIROOTn->ROOTmDIPOLEX. CIROOTn->ROOTmDIPOLEY. CIROOTn->ROOTmDIPOLEZ. CIROOTn->ROOTmQUADRUPOLEXX. CIROOTn->ROOTmQUADRUPOLEXY. CIROOTn->ROOTmQUADRUPOLEXZ. CIROOTn->ROOTmQUADRUPOLEYY. CIROOTn->ROOTmQUADRUPOLEYZ. CIROOTn->ROOTmQUADRUPOLEZZ. CIROOTnCORRELATIONENERGY. CIROOTnDIPOLEX. CIROOTnDIPOLEY. CIROOTnDIP",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/genindex-1.html:24531,charge,charge,24531,psi4manual/1.2.1/genindex-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/genindex-1.html,2,['charge'],['charge']
Energy Efficiency,"RANCE, which; defaults to 1E-7. If the smallest eigenvalue is below this cutoff, canonical; orthogonalization is forced, and all eigenvectors corresponding to eigenvalues; below the cutoff are eliminated. Use of canonical orthogonalization can be; forced by setting the S_ORTHOGONALIZATION option to CANONICAL. Note; that in practice, the MOs and OSOs are built separately within each irrep from; the symmetry-adapted combinations of AOs known as Unique Symmetry Orbitals; (USOs). For canonical orthogonalization, this implies that the number of MOs; and OSOs per irrep may be slightly smaller than the number of USOs per irrep.; A contrived example demonstrating OSOs/MOs vs. AOs with symmetry is shown; below:; molecule h2o {; 0 1; O; H 1 1.0; H 1 1.0 2 104.5; symmetry c2 # Two irreps is easier to comprehend; }. set {; s_tolerance 0.0001 # Set an unreasonably tight; # tolerance to force canonical; basis aug-cc-pv5z # This diffuse basis will have; # small-ish eigenvalues for even H2O; }. energy('scf'). Output:; ... Initialization ... ==> Pre-Iterations <==. Minimum eigenvalue in the overlap matrix is 1.6888059293E-05.; Using Canonical Orthogonalization with cutoff of 1.0000000000E-04.; Overall, 3 of 287 possible MOs eliminated. ... Initial Orbital Guess Information ... -------------------------------------------------------; Irrep Nso Nmo Nalpha Nbeta Ndocc Nsocc; -------------------------------------------------------; A 145 144 3 3 3 0; B 142 140 2 2 2 0; -------------------------------------------------------; Total 287 284 5 5 5 0; -------------------------------------------------------. In this example, there are 287 AO basis functions after spherical harmonics are; applied. These are used to produce 287 symmetry adapted USOs, 145 of which are; assigned to irrep A, and 142 of which are assigned to irrep B. Within irrep A,; 144 OSOs fall above the eigenvalue cutoff, and within irrep B 140 OSOs fall; above the eigenvalue cutoff. In total, 284 molecular orbitals are chosen ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/scf-1.html:12012,energy,energy,12012,psi4manual/1.0.0/scf-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/scf-1.html,10,['energy'],['energy']
Energy Efficiency,RATIO; CC D1 DIAGNOSTIC; CC D2 DIAGNOSTIC; CC NEW D1 DIAGNOSTIC; CC SINGLET PAIR ENERGIES (array); CC T1 DIAGNOSTIC; CC TOTAL ENERGY; CC TRIPLET PAIR ENERGIES (array); CC VIRIAL RATIO; CC2 ALPHA-ALPHA PAIR ENERGIES; CC2 ALPHA-BETA PAIR ENERGIES; CC2 CORRELATION ENERGY; CC2 DIPOLE POLARIZABILITY @ xNM; CC2 DIPOLE POLARIZABILITY TENSOR @ xNM; CC2 QUADRUPOLE POLARIZABILITY TENSOR @ xNM; CC2 ROTATION (LEN) ORIGIN-DEPENDENCE @ xNM; CC2 SINGLET PAIR ENERGIES; CC2 SPECIFIC ROTATION (LEN) @ xNM; CC2 SPECIFIC ROTATION (MVG) @ xNM; CC2 SPECIFIC ROTATION (VEL) @ xNM; CC2 TOTAL ENERGY; CC2 TRIPLET PAIR ENERGIES; CC3 ALPHA-ALPHA PAIR ENERGIES; CC3 ALPHA-BETA PAIR ENERGIES; CC3 CORRELATION ENERGY; CC3 SINGLET PAIR ENERGIES; CC3 TOTAL ENERGY; CC3 TRIPLET PAIR ENERGIES; CCSD ALPHA-ALPHA PAIR ENERGIES; CCSD ALPHA-BETA PAIR ENERGIES; CCSD CORRELATION ENERGY; CCSD DIPOLE POLARIZABILITY @ xNM; CCSD DIPOLE POLARIZABILITY TENSOR @ xNM; CCSD DOUBLES ENERGY; CCSD ITERATIONS; CCSD OPPOSITE-SPIN CORRELATION ENERGY; CCSD QUADRUPOLE POLARIZABILITY TENSOR @ xNM; CCSD ROTATION (LEN) ORIGIN-DEPENDENCE @ xNM; CCSD SAME-SPIN CORRELATION ENERGY; CCSD SINGLES ENERGY; CCSD SINGLET PAIR ENERGIES; CCSD SPECIFIC ROTATION (LEN) @ xNM; CCSD SPECIFIC ROTATION (MVG) @ xNM; CCSD SPECIFIC ROTATION (VEL) @ xNM; CCSD TOTAL ENERGY; CCSD TRIPLET PAIR ENERGIES; CCSD(T) CORRELATION ENERGY; CCSD(T) TOTAL ENERGY; CCname ROOT m (IN h) -> ROOT n (IN i) EINSTEIN A (LEN); CCname ROOT m (IN h) -> ROOT n (IN i) EINSTEIN B (LEN); CCname ROOT m (IN h) -> ROOT n (IN i) OSCILLATOR STRENGTH (LEN); CCname ROOT m (IN h) -> ROOT n (IN i) ROTATORY STRENGTH (LEN); CCname ROOT m (IN h) -> ROOT n (IN i) ROTATORY STRENGTH (VEL); CCname ROOT m (h) -> ROOT n (i) EINSTEIN A (LEN); CCname ROOT m (h) -> ROOT n (i) EINSTEIN B (LEN); CCname ROOT m (h) -> ROOT n (i) OSCILLATOR STRENGTH (LEN); CCname ROOT m (h) -> ROOT n (i) ROTATORY STRENGTH (LEN); CCname ROOT m (h) -> ROOT n (i) ROTATORY STRENGTH (VEL); CCname ROOT m -> ROOT n EINSTEIN A (LEN);,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/autodir_psivariables/module__ccenergy.html:1637,ENERGY,ENERGY,1637,psi4manual/1.7.x/autodir_psivariables/module__ccenergy.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/autodir_psivariables/module__ccenergy.html,4,['ENERGY'],['ENERGY']
Energy Efficiency,"RCCSD(T) single point. \(^1A_1\) CH2 state described using the Ms = 0 component of the singlet. Uses RHF singlet orbitals. dft-psivar; HF and DFT variants single-points on zmat methane, mostly to test that PSI variables are set and computed correctly. Now also testing that CSX harvesting PSI variables correctly update ref_dft_2e/xc due to new BraggSlater radii. pywrap-align; apply linear fragmentation algorithm to a water cluster. scf-hess2; UHF STO-3G (Cartesian) and cc-pVDZ (spherical) water Hessian test, against Psi3 reference values. This test should match RHF values exactly. cc13c; Tests RHF CCSD(T)gradients. dct-grad3; Restricted DF-DCT ODC-12 gradient for ethylene with cc-pVDZ/cc-pVDZ-RI standard/auxiliary basis set. fnocc1; Test QCISD(T) for H2O/cc-pvdz Energy. sapt3; SAPT2+3(CCD) aug-cc-pVDZ+midbond computation of the water dimer interaction energy, using the aug-cc-pVDZ-JKFIT DF basis for SCF and aug-cc-pVDZ-RI for SAPT. cc8; UHF-CCSD(T) cc-pVDZ frozen-core energy for the \(^2\Sigma^+\) state of the CN radical, with Z-matrix input. fci-tdm; He2+ FCI/cc-pVDZ Transition Dipole Moment. dfmp2-grad4; DF-MP2 cc-pVDZ gradient for the NO molecule. cc9; UHF-CCSD(T) cc-pVDZ frozen-core energy for the \(^2\Sigma^+\) state of the CN radical, with Z-matrix input. casscf-fzc-sp; CASSCF/6-31G** energy point. opt10; 6-31G MP2 transition-state optimization with initial, computed Hessian. fnocc6; Test method/basis with disk_df. pywrap-checkrun-uhf; This checks that all energy methods can run with a minimal input and set symmetry. scf11-freq-from-energies; Test frequencies by finite differences of energies for planar C4NH4 TS. sapt0-d; Tests SAPT0-D corrections, with a variety of damping functions/parameters. dct7; DCT calculation for the triplet O2 using ODC-06 and ODC-12 functionals. Only simultaneous algorithm is tested. cc32; CC3/cc-pVDZ H2O \(R_e\) geom from Olsen et al., JCP 104, 8007 (1996). cc15; RHF-B-CCD(T)/6-31G** H2O single-point energy (fzc, MO-basis \(\langle ab",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/autodoc_testsuite_corepsi4-1.html:20245,energy,energy,20245,psi4manual/1.4.0/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodoc_testsuite_corepsi4-1.html,4,['energy'],['energy']
Energy Efficiency,RECTED INTERACTION ENERGY THROUGH 2-BODY | |em| 1 | when vmfc in bsse_type & max_nbody>=2 | 2-body total data less 1-body total data for cumulative IE; inputs are total energies w/ vmfc treatment |; +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+; | |em| VMFC-CORRECTED INTERACTION ENERGY THROUGH {nb}-BODY | |em| 1 | when vmfc in bsse_type | {max_nbody}-body total data less 1-body total data for cumulative IE; inputs are total energies w/ vmfc treatment |; +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+; | |em| VMFC-CORRECTED INTERACTION ENERGY | |em| 1 | when vmfc in bsse_type | best available interaction energy with vmfc treatment: VMFC-CORRECTED INTERACTION ENERGY THROUGH {max_nbody}-BODY |; +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+; | |em| VMFC-CORRECTED 2-BODY CONTRIBUTION TO ENERGY | |em| 1 | when vmfc in bsse_type & max_nbody>=2 | 2-body total data less (2-1)-body total data for partial IE; inputs are total energies w/ vmfc treatment |; +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+; | |em| VMFC-CORRECTED {nb}-BODY CONTRIBUTION TO ENERGY | |em| 1 | when vmfc in bs,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver_nbody.html:55493,ENERGY,ENERGY,55493,psi4manual/1.6.x/_modules/psi4/driver/driver_nbody.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver_nbody.html,5,['ENERGY'],['ENERGY']
Energy Efficiency,RECTED TOTAL ENERGY THROUGH 2-BODY;   1; when cp in bsse_type & max_nbody>=2; MBE sum of subsystems of 2-body or fewer (cumulative); summed are total energies with cp treatment.   CP-CORRECTED TOTAL ENERGY THROUGH {nb}-BODY;   1; when cp in bsse_type; MBE sum of subsystems of {max_nbody}-body or fewer (cumulative); summed are total energies w/ cp treatment.   CP-CORRECTED TOTAL ENERGY;   1; when cp in bsse_type & rtd=T; best available total energy with cp treatment: CP-CORRECTED TOTAL ENERGY THROUGH {max_nbody}-BODY.   CP-CORRECTED INTERACTION ENERGY THROUGH 2-BODY;   1; when cp in bsse_type & max_nbody>=2; 2-body total data less 1-body total data for cumulative IE; inputs are total energies with cp treatment.   CP-CORRECTED INTERACTION ENERGY THROUGH {nb}-BODY;   1; when cp in bsse_type; {max_nbody}-body total data less 1-body total data for cumulative IE; inputs are total energies with cp treatment.   CP-CORRECTED INTERACTION ENERGY;   1; when cp in bsse_type; best available interaction energy with cp treatment: CP-CORRECTED INTERACTION ENERGY THROUGH {max_nbody}-BODY.   CP-CORRECTED 2-BODY CONTRIBUTION TO ENERGY;   1; when cp in bsse_type & max_nbody>=2; 2-body total data less (2-1)-body total data for partial IE; inputs are total energies w/ cp treatment.   CP-CORRECTED {nb}-BODY CONTRIBUTION TO ENERGY;   1; when cp in bsse_type; {max_nbody}-body total data less ({max_nbody}-1)-body data for partial IE; inputs are total energies w/ cp treat.   NOCP-CORRECTED TOTAL ENERGY THROUGH 1-BODY;   1; when nocp in bsse_type; MBE sum of subsystems of 1-body. summed are total energies without cp treatment.   NOCP-CORRECTED TOTAL ENERGY THROUGH 2-BODY;   1; when nocp in bsse_type & max_nbody>=2; MBE sum of subsystems of 2-body or fewer (cumulative); summed are total energies without cp treatment.   NOCP-CORRECTED TOTAL ENERGY THROUGH {nb}-BODY;   1; when nocp in bsse_type; MBE sum of subsystems of {max_nbody}-body or fewer (cumulative); summed are total energies w/o cp treatm,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/nbody.html:11711,energy,energy,11711,psi4manual/1.6.x/nbody.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/nbody.html,5,['energy'],['energy']
Energy Efficiency,"REEZE_CORE',""TRUE""); psi4.set_global_option('BASIS',""6-311G(D_P)""); ref = driver.proc.run_fnocc('qcisd(t)', return_wfn=True, **kwargs). # HLC: high-level correction based on number of valence electrons; nirrep = ref.nirrep(); frzcpi = ref.frzcpi(); nfzc = 0; for i in range (0,nirrep):; nfzc += frzcpi[i]; nalpha = ref.nalpha() - nfzc; nbeta = ref.nbeta() - nfzc; # hlc of gaussian-2; hlc = -0.00481 * nalpha -0.00019 * nbeta; # hlc of gaussian-1; hlc1 = -0.00614 * nalpha. eqci_6311gdp = psi4.get_variable(""QCISD(T) TOTAL ENERGY""); emp4_6311gd = psi4.get_variable(""MP4 TOTAL ENERGY""); emp2_6311gd = psi4.get_variable(""MP2 TOTAL ENERGY""); psi4.clean(). # correction for diffuse functions; psi4.set_global_option('BASIS',""6-311+G(D_P)""); driver.energy('mp4'); emp4_6311pg_dp = psi4.get_variable(""MP4 TOTAL ENERGY""); emp2_6311pg_dp = psi4.get_variable(""MP2 TOTAL ENERGY""); psi4.clean(). # correction for polarization functions; psi4.set_global_option('BASIS',""6-311G(2DF_P)""); driver.energy('mp4'); emp4_6311g2dfp = psi4.get_variable(""MP4 TOTAL ENERGY""); emp2_6311g2dfp = psi4.get_variable(""MP2 TOTAL ENERGY""); psi4.clean(). # big basis mp2; psi4.set_global_option('BASIS',""6-311+G(3DF_2P)""); #run_fnocc('_mp2',**kwargs); driver.energy('mp2'); emp2_big = psi4.get_variable(""MP2 TOTAL ENERGY""); psi4.clean(). eqci = eqci_6311gdp; e_delta_g2 = emp2_big + emp2_6311gd - emp2_6311g2dfp - emp2_6311pg_dp; e_plus = emp4_6311pg_dp - emp4_6311gd; e_2df = emp4_6311g2dfp - emp4_6311gd. eg2 = eqci + e_delta_g2 + e_plus + e_2df; eg2_mp2_0k = eqci + (emp2_big - emp2_6311gd) + hlc + zpe. psi4.print_out('\n'); psi4.print_out(' ==> G1/G2 Energy Components <==\n'); psi4.print_out('\n'); psi4.print_out(' QCISD(T): %20.12lf\n' % eqci); psi4.print_out(' E(Delta): %20.12lf\n' % e_delta_g2); psi4.print_out(' E(2DF): %20.12lf\n' % e_2df); psi4.print_out(' E(+): %20.12lf\n' % e_plus); psi4.print_out(' E(G1 HLC): %20.12lf\n' % hlc1); psi4.print_out(' E(G2 HLC): %20.12lf\n' % hlc); psi4.print_out(' E(ZPE): %20.12lf\n'",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/gaussian_n.html:3708,energy,energy,3708,psi4manual/1.0.0/_modules/gaussian_n.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/gaussian_n.html,1,['energy'],['energy']
Energy Efficiency,"RELATION ENERGY"": None,; ""MP2 OPPOSITE-SPIN CORRELATION ENERGY"": None,; ""MP2 SINGLES ENERGY"": None,; ""MP2 DOUBLES ENERGY"": None,; ""CCSD TOTAL ENERGY"": None,; ""CCSD CORRELATION ENERGY"": None,; ""CCSD SAME-SPIN CORRELATION ENERGY"": None,; ""CCSD OPPOSITE-SPIN CORRELATION ENERGY"": None,; ""CCSD SINGLES ENERGY"": None,; ""CCSD DOUBLES ENERGY"": None,; }. while True:; sort_func(ref_wfn). ref_wfn = core.ccenergy(ref_wfn); core.print_out('Brueckner convergence check: %s\n' % bool(core.variable('BRUECKNER CONVERGED'))); if core.variable('BRUECKNER CONVERGED'):; break. if bcc_iter_cnt >= core.get_option('CCENERGY', 'BCCD_MAXITER'):; core.print_out(""\n\nWarning! BCCD did not converge within the maximum number of iterations.""); core.print_out(""You can increase the number of BCCD iterations by changing BCCD_MAXITER.\n\n""); break; bcc_iter_cnt += 1. if bcc_iter_cnt == 1:; for pv in hold_qcvars:; hold_qcvars[pv] = ref_wfn.variable(pv). ref_wfn.set_variable(""BCCD TOTAL ENERGY"", ref_wfn.variable(""CCSD TOTAL ENERGY"")); ref_wfn.set_variable(""BCCD CORRELATION ENERGY"", ref_wfn.variable(""BCCD TOTAL ENERGY"") - ref_wfn.variable(""SCF TOTAL ENERGY"")); ref_wfn.set_variable(""CURRENT CORRELATION ENERGY"", ref_wfn.variable(""BCCD CORRELATION ENERGY"")). # copy back canonical MP2 and CCSD from initial iteration; for pv, v in hold_qcvars.items():; if v is not None:; ref_wfn.set_variable(pv, v); core.set_variable(pv, v). if name == 'bccd(t)':; core.cctriples(ref_wfn); ref_wfn.set_variable(""B(T) CORRECTION ENERGY"", ref_wfn.variable(""(T) CORRECTION ENERGY"")); ref_wfn.set_variable(""BCCD(T) TOTAL ENERGY"", ref_wfn.variable(""CCSD(T) TOTAL ENERGY"")); ref_wfn.set_variable(""BCCD(T) CORRELATION ENERGY"", ref_wfn.variable(""BCCD(T) TOTAL ENERGY"") - ref_wfn.variable(""SCF TOTAL ENERGY"")) # note != CCSD(T) CORRELATION ENERGY; ref_wfn.set_variable(""CURRENT CORRELATION ENERGY"", ref_wfn.variable(""BCCD(T) CORRELATION ENERGY"")). for pv in [""(T) CORRECTION ENERGY"", ""CCSD(T) TOTAL ENERGY"", ""CCSD(T) CORRELATION ENERGY""]:; ref_wfn",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:97218,ENERGY,ENERGY,97218,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,4,['ENERGY'],['ENERGY']
Energy Efficiency,RELATION ENERGY; AQCC SAME-SPIN CORRELATION ENERGY; AQCC SINGLES ENERGY; AQCC TOTAL ENERGY; CC ALPHA-ALPHA PAIR ENERGIES (array); CC ALPHA-BETA PAIR ENERGIES (array); CC D1 DIAGNOSTIC; CC SINGLET PAIR ENERGIES (array); CC T1 DIAGNOSTIC; CC TRIPLET PAIR ENERGIES (array); CCSD ALPHA-ALPHA PAIR ENERGIES (array); CCSD ALPHA-BETA PAIR ENERGIES (array); CCSD CORRELATION ENERGY; CCSD DOUBLES ENERGY; CCSD ITERATIONS; CCSD OPPOSITE-SPIN CORRELATION ENERGY; CCSD SAME-SPIN CORRELATION ENERGY; CCSD SINGLES ENERGY; CCSD SINGLET PAIR ENERGIES (array); CCSD TOTAL ENERGY; CCSD TRIPLET PAIR ENERGIES (array); CCSD(T) CORRELATION ENERGY; CCSD(T) TOTAL ENERGY; CEPA(0) CORRELATION ENERGY; CEPA(0) DOUBLES ENERGY; CEPA(0) OPPOSITE-SPIN CORRELATION ENERGY; CEPA(0) SAME-SPIN CORRELATION ENERGY; CEPA(0) SINGLES ENERGY; CEPA(0) TOTAL ENERGY; CEPA(1) CORRELATION ENERGY; CEPA(1) DOUBLES ENERGY; CEPA(1) OPPOSITE-SPIN CORRELATION ENERGY; CEPA(1) SAME-SPIN CORRELATION ENERGY; CEPA(1) SINGLES ENERGY; CEPA(1) TOTAL ENERGY; CEPA(2) CORRELATION ENERGY; CEPA(2) DOUBLES ENERGY; CEPA(2) OPPOSITE-SPIN CORRELATION ENERGY; CEPA(2) SAME-SPIN CORRELATION ENERGY; CEPA(2) SINGLES ENERGY; CEPA(2) TOTAL ENERGY; CEPA(3) CORRELATION ENERGY; CEPA(3) DOUBLES ENERGY; CEPA(3) OPPOSITE-SPIN CORRELATION ENERGY; CEPA(3) SAME-SPIN CORRELATION ENERGY; CEPA(3) SINGLES ENERGY; CEPA(3) TOTAL ENERGY; CISD CORRELATION ENERGY; CISD OPPOSITE-SPIN CORRELATION ENERGY; CISD SAME-SPIN CORRELATION ENERGY; CISD TOTAL ENERGY; CURRENT CORRELATION ENERGY; CURRENT ENERGY; LCCD CORRELATION ENERGY; LCCD DOUBLES ENERGY; LCCD OPPOSITE-SPIN CORRELATION ENERGY; LCCD SAME-SPIN CORRELATION ENERGY; LCCD SINGLES ENERGY; LCCD TOTAL ENERGY; LCCSD CORRELATION ENERGY; LCCSD DOUBLES ENERGY; LCCSD OPPOSITE-SPIN CORRELATION ENERGY; LCCSD SAME-SPIN CORRELATION ENERGY; LCCSD SINGLES ENERGY; LCCSD TOTAL ENERGY; MP2 ALPHA-ALPHA PAIR ENERGIES (array); MP2 ALPHA-BETA PAIR ENERGIES (array); MP2 CORRELATION ENERGY; MP2 DOUBLES ENERGY; MP2 OPPOSITE-SPIN CORRELATION E,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/autodir_psivariables/module__fnocc.html:1378,ENERGY,ENERGY,1378,psi4manual/1.7.x/autodir_psivariables/module__fnocc.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/autodir_psivariables/module__fnocc.html,4,['ENERGY'],['ENERGY']
Energy Efficiency,"RELATION ENERGY; MP2.5 SAME-SPIN CORRELATION ENERGY; MP2.5 SINGLES ENERGY; MP2.5 TOTAL ENERGY; MP3 CORRELATION ENERGY; MP3 DOUBLES ENERGY; MP3 OPPOSITE-SPIN CORRELATION ENERGY; MP3 SAME-SPIN CORRELATION ENERGY; MP3 SINGLES ENERGY; MP3 TOTAL ENERGY; OLCCD CORRELATION ENERGY; OLCCD OPPOSITE-SPIN CORRELATION ENERGY; OLCCD REFERENCE CORRECTION ENERGY; OLCCD SAME-SPIN CORRELATION ENERGY; OLCCD TOTAL ENERGY; OMP2 CORRELATION ENERGY; OMP2 OPPOSITE-SPIN CORRELATION ENERGY; OMP2 REFERENCE CORRECTION ENERGY; OMP2 SAME-SPIN CORRELATION ENERGY; OMP2 TOTAL ENERGY; OMP2.5 CORRELATION ENERGY; OMP2.5 OPPOSITE-SPIN CORRELATION ENERGY; OMP2.5 REFERENCE CORRECTION ENERGY; OMP2.5 SAME-SPIN CORRELATION ENERGY; OMP2.5 TOTAL ENERGY; OMP3 CORRELATION ENERGY; OMP3 OPPOSITE-SPIN CORRELATION ENERGY; OMP3 REFERENCE CORRECTION ENERGY; OMP3 SAME-SPIN CORRELATION ENERGY; OMP3 TOTAL ENERGY; OREMP2 CORRELATION ENERGY; OREMP2 OPPOSITE-SPIN CORRELATION ENERGY; OREMP2 REFERENCE CORRECTION ENERGY; OREMP2 SAME-SPIN CORRELATION ENERGY; OREMP2 TOTAL ENERGY; REMP2 CORRELATION ENERGY; REMP2 DOUBLES ENERGY; REMP2 OPPOSITE-SPIN CORRELATION ENERGY; REMP2 SAME-SPIN CORRELATION ENERGY; REMP2 SINGLES ENERGY; REMP2 TOTAL ENERGY; SCS(N)-MP2 CORRELATION ENERGY; SCS(N)-MP2 TOTAL ENERGY; SCS-MP2 CORRELATION ENERGY; SCS-MP2 TOTAL ENERGY; SCS-MP2-VDW CORRELATION ENERGY; SCS-MP2-VDW TOTAL ENERGY; SCS-MP3 CORRELATION ENERGY; SCS-MP3 TOTAL ENERGY; SCS-OMP2 CORRELATION ENERGY; SCS-OMP2 TOTAL ENERGY; SCS-OMP3 CORRELATION ENERGY; SCS-OMP3 TOTAL ENERGY; SOS-MP2 CORRELATION ENERGY; SOS-MP2 TOTAL ENERGY; SOS-OMP2 CORRELATION ENERGY; SOS-OMP2 TOTAL ENERGY; SOS-OMP3 CORRELATION ENERGY; SOS-OMP3 TOTAL ENERGY; SOS-PI-MP2 CORRELATION ENERGY; SOS-PI-MP2 TOTAL ENERGY. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. Appendices; PSI Variables by Module; OCC. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/autodir_psivariables/module__occ.html:1979,ENERGY,ENERGY,1979,psi4manual/1.8.x/autodir_psivariables/module__occ.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/autodir_psivariables/module__occ.html,37,['ENERGY'],['ENERGY']
Energy Efficiency,"RELATION ENERGY; MP2.5 SAME-SPIN CORRELATION ENERGY; MP2.5 SINGLES ENERGY; MP2.5 TOTAL ENERGY; MP3 CORRELATION ENERGY; MP3 DOUBLES ENERGY; MP3 OPPOSITE-SPIN CORRELATION ENERGY; MP3 SAME-SPIN CORRELATION ENERGY; MP3 SINGLES ENERGY; MP3 TOTAL ENERGY; OLCCD CORRELATION ENERGY; OLCCD OPPOSITE-SPIN CORRELATION ENERGY; OLCCD REFERENCE CORRECTION ENERGY; OLCCD SAME-SPIN CORRELATION ENERGY; OLCCD TOTAL ENERGY; OMP2 CORRELATION ENERGY; OMP2 OPPOSITE-SPIN CORRELATION ENERGY; OMP2 REFERENCE CORRECTION ENERGY; OMP2 SAME-SPIN CORRELATION ENERGY; OMP2 TOTAL ENERGY; OMP2.5 CORRELATION ENERGY; OMP2.5 OPPOSITE-SPIN CORRELATION ENERGY; OMP2.5 REFERENCE CORRECTION ENERGY; OMP2.5 SAME-SPIN CORRELATION ENERGY; OMP2.5 TOTAL ENERGY; OMP3 CORRELATION ENERGY; OMP3 OPPOSITE-SPIN CORRELATION ENERGY; OMP3 REFERENCE CORRECTION ENERGY; OMP3 SAME-SPIN CORRELATION ENERGY; OMP3 TOTAL ENERGY; OREMP2 CORRELATION ENERGY; OREMP2 OPPOSITE-SPIN CORRELATION ENERGY; OREMP2 REFERENCE CORRECTION ENERGY; OREMP2 SAME-SPIN CORRELATION ENERGY; OREMP2 TOTAL ENERGY; REMP2 CORRELATION ENERGY; REMP2 DOUBLES ENERGY; REMP2 OPPOSITE-SPIN CORRELATION ENERGY; REMP2 SAME-SPIN CORRELATION ENERGY; REMP2 SINGLES ENERGY; REMP2 TOTAL ENERGY; SCS(N)-MP2 CORRELATION ENERGY; SCS(N)-MP2 TOTAL ENERGY; SCS-MP2 CORRELATION ENERGY; SCS-MP2 TOTAL ENERGY; SCS-MP2-VDW CORRELATION ENERGY; SCS-MP2-VDW TOTAL ENERGY; SCS-MP3 CORRELATION ENERGY; SCS-MP3 TOTAL ENERGY; SCS-OMP2 CORRELATION ENERGY; SCS-OMP2 TOTAL ENERGY; SCS-OMP3 CORRELATION ENERGY; SCS-OMP3 TOTAL ENERGY; SOS-MP2 CORRELATION ENERGY; SOS-MP2 TOTAL ENERGY; SOS-OMP2 CORRELATION ENERGY; SOS-OMP2 TOTAL ENERGY; SOS-OMP3 CORRELATION ENERGY; SOS-OMP3 TOTAL ENERGY; SOS-PI-MP2 CORRELATION ENERGY; SOS-PI-MP2 TOTAL ENERGY. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.9.1;  · . PSI4. Appendices; PSI Variables by Module; OCC. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/autodir_psivariables/module__occ.html:1979,ENERGY,ENERGY,1979,psi4manual/1.9.x/autodir_psivariables/module__occ.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/autodir_psivariables/module__occ.html,37,['ENERGY'],['ENERGY']
Energy Efficiency,"RELATION ENERGY¶. AQCC OPPOSITE-SPIN CORRELATION ENERGY¶. REMP2 OPPOSITE-SPIN CORRELATION ENERGY¶. LCCD OPPOSITE-SPIN CORRELATION ENERGY¶. CCD OPPOSITE-SPIN CORRELATION ENERGY¶. LCCSD OPPOSITE-SPIN CORRELATION ENERGY¶. CCSD OPPOSITE-SPIN CORRELATION ENERGY¶. OMP2 OPPOSITE-SPIN CORRELATION ENERGY¶. OMP2.5 OPPOSITE-SPIN CORRELATION ENERGY¶. OMP3 OPPOSITE-SPIN CORRELATION ENERGY¶. OREMP2 OPPOSITE-SPIN CORRELATION ENERGY¶. OLCCD OPPOSITE-SPIN CORRELATION ENERGY¶; The unscaled portion [E_h] of the named correlation energy; from opposite-spin or singlet doubles correlations. MRPT TOTAL ENERGY¶. MP2-CCSD TOTAL ENERGY¶. MRCC TOTAL ENERGY¶; Energies [E_h] from correlated multi-reference theories. MULLIKEN CHARGES¶; Property of partial atomic charges [e] by the method of Mulliken, (nat,). NAUX (SCF)¶. NAUX (CC)¶; Convenience storage of number of functions [] in the auxiliary basis; set for named stage of the calculation. NBODY (i, j, ..., k)@(a, b, ..., c) TOTAL ENERGY¶; The total energy [E_h] of a component of the requested N-Body energy.; The first parenthetical list over i, j, …, k enumerates; molecular fragments included in the computation in 1-indexed,; input-file order, while the second enumerates list over a, b,; …, c enumerates which fragments contribute basis functions to the; computation. For example, (1, 2)@(1, 2, 3, 4) indicates that the; fragments 1 and 2 are explicitly included in the energy computation,; with basis functions from each of fragments 1, 2, 3, & 4 included in; the basis set. Therefore, the basis functions from fragments 3 and 4; are included as ghost functions within the energy computation. NUCLEAR REPULSION ENERGY¶; The nuclear repulsion energy contribution [E_h] to the total SCF energy.; Quantity \(E_{NN}\) in Eq. (4). (3)¶\[E_{NN} = \sum_{i, j<i}^{N_{atom}}\frac{Z_i Z_j}{|\mathbf{R}_i - \mathbf{R}_j|}\]. OCEPA(0) TOTAL ENERGY¶. OCEPA(0) CORRELATION ENERGY¶; The total electronic energy [E_h] and correlation energy component [E_h]; for the orbital-",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/glossary_psivariables.html:41003,energy,energy,41003,psi4manual/1.7.x/glossary_psivariables.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/glossary_psivariables.html,8,['energy'],['energy']
Energy Efficiency,"RELATION ENERGY¶. CEPA(2) OPPOSITE-SPIN CORRELATION ENERGY¶. CEPA(3) OPPOSITE-SPIN CORRELATION ENERGY¶. CISD OPPOSITE-SPIN CORRELATION ENERGY¶. QCISD OPPOSITE-SPIN CORRELATION ENERGY¶. ACPF OPPOSITE-SPIN CORRELATION ENERGY¶. AQCC OPPOSITE-SPIN CORRELATION ENERGY¶. LCCD OPPOSITE-SPIN CORRELATION ENERGY¶. CCD OPPOSITE-SPIN CORRELATION ENERGY¶. LCCSD OPPOSITE-SPIN CORRELATION ENERGY¶. CCSD OPPOSITE-SPIN CORRELATION ENERGY¶. OLCCD OPPOSITE-SPIN CORRELATION ENERGY¶; The unscaled portion [Eh] of the named correlation energy; from opposite-spin or singlet doubles correlations. MRPT TOTAL ENERGY¶. MP2-CCSD TOTAL ENERGY¶. MRCC TOTAL ENERGY¶; Energies [Eh] from correlated multi-reference theories. MULLIKEN CHARGES¶; Property of partial atomic charges [e] by the method of Mulliken, (nat,). NAUX (SCF)¶. NAUX (CC)¶; Convenience storage of number of functions [] in the auxiliary basis; set for named stage of the calculation. NBODY (i, j, ..., k)@(a, b, ..., c) TOTAL ENERGY¶; The total energy [Eh] of a component of the requested N-Body energy.; The first parenthetical list over i, j, …, k enumerates; molecular fragments included in the computation in 1-indexed,; input-file order, while the second enumerates list over a, b,; …, c enumerates which fragments contribute basis functions to the; computation. For example, (1, 2)@(1, 2, 3, 4) indicates that the; fragments 1 and 2 are explicitly included in the energy computation,; with basis functions from each of fragments 1, 2, 3, & 4 included in; the basis set. Therefore, the basis functions from fragments 3 and 4; are included as ghost functions within the energy computation. NUCLEAR REPULSION ENERGY¶; The nuclear repulsion energy contribution [Eh] to the total SCF energy.; Quantity \(E_{NN}\) in Eq. (4). (3)¶\[E_{NN} = \sum_{i, j<i}^{N_{atom}}\frac{Z_i Z_j}{|\mathbf{R}_i - \mathbf{R}_j|}\]. OCEPA(0) TOTAL ENERGY¶. OCEPA(0) CORRELATION ENERGY¶; The total electronic energy [Eh] and correlation energy component [Eh]; for the orbital-opt",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/glossary_psivariables-1.html:32181,energy,energy,32181,psi4manual/1.4.0/glossary_psivariables-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/glossary_psivariables-1.html,10,['energy'],['energy']
Energy Efficiency,"REMP2 TOTAL ENERGY¶. REMP2 CORRELATION ENERGY¶; The total electronic energy [E_h] and correlation energy component [E_h]; for the retaining-the-excitation-degree Møller–Plesset hybrid perturbation; theory level. SAPT DISP ENERGY¶. SAPT ELST ENERGY¶. SAPT EXCH ENERGY¶. SAPT IND ENERGY¶; Respectively, the dispersion, electrostatics, exchange, and induction; components of the total electronic interaction energy [E_h] for the; requested SAPT level of theory. The sum of these four components yields; SAPT TOTAL ENERGY. SAPT TOTAL ENERGY¶. SAPT ENERGY¶; The total electronic interaction energy [E_h] for the requested SAPT; level of theory. SAPT ELST10,R ENERGY¶; An electrostatics-classified SAPT term energy [E_h] implemented for SAPT0. SAPT ELST EXTERN-EXTERN ENERGY¶; Electrostatic interaction [E_h] between the point charges in fragments; A and B in F/I-SAPT. SAPT EXCH10 ENERGY¶; An exchange-classified SAPT term energy [E_h] implemented for SAPT0. SAPT EXCH10(S^2) ENERGY¶; An exchange-classified SAPT term energy [E_h] implemented for SAPT0. SAPT IND20,R ENERGY¶. SAPT EXCH-IND20,R ENERGY¶. SAPT IND20,U ENERGY¶. SAPT EXCH-IND20,U ENERGY¶; An induction-classified SAPT term energy [E_h] implemented for SAPT0. SAPT DISP20 ENERGY¶. SAPT EXCH-DISP20 ENERGY¶; A dispersion-classified SAPT term energy [E_h] implemented for SAPT0. SAPT EXCH-DISP20(S^INF) ENERGY¶; A dispersion-classified SAPT term energy [E_h] implemented for SAPT0. See Higher-Order Exchange Terms without Single-Exchange Approximation. SAPT SAME-SPIN DISP20 ENERGY¶. SAPT SAME-SPIN EXCH-DISP20 ENERGY¶; The portion of SAPT DISP20 ENERGY or; SAPT EXCH-DISP20 ENERGY resulting from; from same-spin or triplet doubles correlations. SAPT HF(2) ENERGY ABC(HF)¶; The total Hartree–Fock energy [E_h] of the supersystem implemented for F/I-SAPT. SAPT HF(2) ENERGY AC(0)¶; The Hartree–Fock energy [E_h] of subsystems A and C implemented for F/I-SAPT. SAPT HF(2) ENERGY BC(0)¶; The Hartree–Fock energy [E_h] of subsystems B and C implement",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/glossary_psivariables.html:46016,energy,energy,46016,psi4manual/1.7.x/glossary_psivariables.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/glossary_psivariables.html,4,['energy'],['energy']
Energy Efficiency,RENCE ENERGY; CUSTOM SCS-LCCD CORRELATION ENERGY; CUSTOM SCS-LCCD TOTAL ENERGY; CUSTOM SCS-MP2 CORRELATION ENERGY; CUSTOM SCS-MP2 TOTAL ENERGY; CUSTOM SCS-MP2.5 CORRELATION ENERGY; CUSTOM SCS-MP2.5 TOTAL ENERGY; CUSTOM SCS-MP3 CORRELATION ENERGY; CUSTOM SCS-MP3 TOTAL ENERGY; CUSTOM SCS-OLCCD CORRELATION ENERGY; CUSTOM SCS-OLCCD TOTAL ENERGY; CUSTOM SCS-OMP2 CORRELATION ENERGY; CUSTOM SCS-OMP2 TOTAL ENERGY; CUSTOM SCS-OMP3 CORRELATION ENERGY; CUSTOM SCS-OMP3 TOTAL ENERGY; CUSTOM SCS-OREMP2 CORRELATION ENERGY; CUSTOM SCS-OREMP2 TOTAL ENERGY; CUSTOM SCS-REMP2 CORRELATION ENERGY; CUSTOM SCS-REMP2 TOTAL ENERGY; LCCD CORRELATION ENERGY; LCCD DOUBLES ENERGY; LCCD OPPOSITE-SPIN CORRELATION ENERGY; LCCD SAME-SPIN CORRELATION ENERGY; LCCD SINGLES ENERGY; LCCD TOTAL ENERGY; MP2 CORRELATION ENERGY; MP2 DOUBLES ENERGY; MP2 OPPOSITE-SPIN CORRELATION ENERGY; MP2 SAME-SPIN CORRELATION ENERGY; MP2 SINGLES ENERGY; MP2 TOTAL ENERGY; MP2.5 CORRELATION ENERGY; MP2.5 DOUBLES ENERGY; MP2.5 OPPOSITE-SPIN CORRELATION ENERGY; MP2.5 SAME-SPIN CORRELATION ENERGY; MP2.5 SINGLES ENERGY; MP2.5 TOTAL ENERGY; MP3 CORRELATION ENERGY; MP3 DOUBLES ENERGY; MP3 OPPOSITE-SPIN CORRELATION ENERGY; MP3 SAME-SPIN CORRELATION ENERGY; MP3 SINGLES ENERGY; MP3 TOTAL ENERGY; OLCCD CORRELATION ENERGY; OLCCD OPPOSITE-SPIN CORRELATION ENERGY; OLCCD REFERENCE CORRECTION ENERGY; OLCCD SAME-SPIN CORRELATION ENERGY; OLCCD TOTAL ENERGY; OMP2 CORRELATION ENERGY; OMP2 OPPOSITE-SPIN CORRELATION ENERGY; OMP2 REFERENCE CORRECTION ENERGY; OMP2 SAME-SPIN CORRELATION ENERGY; OMP2 TOTAL ENERGY; OMP2.5 CORRELATION ENERGY; OMP2.5 OPPOSITE-SPIN CORRELATION ENERGY; OMP2.5 REFERENCE CORRECTION ENERGY; OMP2.5 SAME-SPIN CORRELATION ENERGY; OMP2.5 TOTAL ENERGY; OMP3 CORRELATION ENERGY; OMP3 OPPOSITE-SPIN CORRELATION ENERGY; OMP3 REFERENCE CORRECTION ENERGY; OMP3 SAME-SPIN CORRELATION ENERGY; OMP3 TOTAL ENERGY; OREMP2 CORRELATION ENERGY; OREMP2 OPPOSITE-SPIN CORRELATION ENERGY; OREMP2 REFERENCE CORRECTION ENERGY; OREMP2 SAME-SPIN CORRELAT,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/autodir_psivariables/module__occ.html:1274,ENERGY,ENERGY,1274,psi4manual/1.7.x/autodir_psivariables/module__occ.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/autodir_psivariables/module__occ.html,4,['ENERGY'],['ENERGY']
Energy Efficiency,RENGTH (LEN); CCname ROOT m (IN h) -> ROOT n (IN i) ROTATORY STRENGTH (VEL); CCname ROOT m (h) -> ROOT n (i) EINSTEIN A (LEN); CCname ROOT m (h) -> ROOT n (i) EINSTEIN B (LEN); CCname ROOT m (h) -> ROOT n (i) OSCILLATOR STRENGTH (LEN); CCname ROOT m (h) -> ROOT n (i) ROTATORY STRENGTH (LEN); CCname ROOT m (h) -> ROOT n (i) ROTATORY STRENGTH (VEL); CCname ROOT m -> ROOT n EINSTEIN A (LEN); CCname ROOT m -> ROOT n EINSTEIN A (LEN) - h TRANSITION; CCname ROOT m -> ROOT n EINSTEIN B (LEN); CCname ROOT m -> ROOT n EINSTEIN B (LEN) - h TRANSITION; CCname ROOT m -> ROOT n OSCILLATOR STRENGTH (LEN); CCname ROOT m -> ROOT n OSCILLATOR STRENGTH (LEN) - h TRANSITION; CCname ROOT m -> ROOT n ROTATORY STRENGTH (LEN); CCname ROOT m -> ROOT n ROTATORY STRENGTH (LEN) - h TRANSITION; CCname ROOT m -> ROOT n ROTATORY STRENGTH (VEL); CCname ROOT m -> ROOT n ROTATORY STRENGTH (VEL) - h TRANSITION; CCname ROOT n (IN h) CORRELATION ENERGY; CCname ROOT n (IN h) TOTAL ENERGY; CCname ROOT n (h) CORRELATION ENERGY; CCname ROOT n (h) DIPOLE; CCname ROOT n (h) QUADRUPOLE; CCname ROOT n (h) TOTAL ENERGY; CCname ROOT n CORRELATION ENERGY; CCname ROOT n CORRELATION ENERGY - h TRANSITION; CCname ROOT n DIPOLE; CCname ROOT n DIPOLE - h TRANSITION; CCname ROOT n QUADRUPOLE; CCname ROOT n QUADRUPOLE - h TRANSITION; CCname ROOT n TOTAL ENERGY; CCname ROOT n TOTAL ENERGY - h TRANSITION; CURRENT CORRELATION ENERGY; CURRENT ENERGY; LCC2 (+LMP2) TOTAL ENERGY; LCCSD (+LMP2) TOTAL ENERGY; LEFT-RIGHT CC2 EIGENVECTOR OVERLAP; LEFT-RIGHT CC3 EIGENVECTOR OVERLAP; LEFT-RIGHT CCSD EIGENVECTOR OVERLAP; LEFT-RIGHT CCSD(T) EIGENVECTOR OVERLAP; MP2 ALPHA-ALPHA PAIR ENERGIES (array); MP2 ALPHA-BETA PAIR ENERGIES (array); MP2 CORRELATION ENERGY; MP2 DOUBLES ENERGY; MP2 OPPOSITE-SPIN CORRELATION ENERGY; MP2 SAME-SPIN CORRELATION ENERGY; MP2 SINGLES ENERGY; MP2 SINGLET PAIR ENERGIES (array); MP2 TOTAL ENERGY; MP2 TRIPLET PAIR ENERGIES (array); SCF TOTAL ENERGY; SCS(N)-MP2 CORRELATION ENERGY; SCS(N)-MP2 TOTAL ENERGY; SCS-C,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/autodir_psivariables/module__ccenergy.html:3137,ENERGY,ENERGY,3137,psi4manual/1.6.x/autodir_psivariables/module__ccenergy.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/autodir_psivariables/module__ccenergy.html,5,['ENERGY'],['ENERGY']
Energy Efficiency,"RENT CORRELATION ENERGY"",cemp4sdq); elif ( lowername == 'fno-mp4(sdq)'):; emp4sdq = PsiMod.get_variable(""MP4(SDQ) TOTAL ENERGY""); cemp4sdq = PsiMod.get_variable(""MP4(SDQ) CORRELATION ENERGY""); PsiMod.set_variable(""CURRENT ENERGY"",emp4sdq); PsiMod.set_variable(""CURRENT CORRELATION ENERGY"",cemp4sdq); elif ( lowername == 'fno-mp4'):; emp4 = PsiMod.get_variable(""MP4 TOTAL ENERGY""); cemp4 = PsiMod.get_variable(""MP4 CORRELATION ENERGY""); PsiMod.set_variable(""CURRENT ENERGY"",emp4); PsiMod.set_variable(""CURRENT CORRELATION ENERGY"",cemp4); elif (lowername == 'fnocc-mp') and (level == 4):; emp4 = PsiMod.get_variable(""MP4 TOTAL ENERGY""); cemp4 = PsiMod.get_variable(""MP4 CORRELATION ENERGY""); PsiMod.set_variable(""CURRENT ENERGY"",emp4); PsiMod.set_variable(""CURRENT CORRELATION ENERGY"",cemp4). # restore symmetry for fno-cc; if (PsiMod.get_option('FNOCC','NAT_ORBS')):; molecule.reset_point_group(user_pg); molecule.update_geometry(). # restore options; optstash.restore(). return PsiMod.get_variable(""CURRENT ENERGY""). [docs]def run_cepa(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a cepa-like calculation. >>> energy('cepa(1)'). """"""; lowername = name.lower(); uppername = name.upper(); kwargs = kwargs_lower(kwargs). # save user options; optstash = OptionsState(; ['TRANSQT2', 'WFN'],; ['FNOCC', 'NAT_ORBS'],; ['FNOCC', 'RUN_CEPA'],; ['FNOCC', 'CEPA_NO_SINGLES']). PsiMod.set_local_option('FNOCC','RUN_CEPA', True). # what type of cepa?; cepa_level = uppername; if (lowername == 'cepa(2)'):; raise ValidationError(""Error: %s not implemented\n"" % lowername); if (lowername == 'dci'):; cepa_level = 'CISD'; if (lowername == 'sdci'):; cepa_level = 'CISD'. if (lowername == 'fno-cepa(0)'):; cepa_level = 'CEPA(0)'; PsiMod.set_local_option('FNOCC', 'NAT_ORBS', True); if (lowername == 'fno-cepa(1)'):; PsiMod.set_local_option('FNOCC', 'NAT_ORBS', True); cepa_level = 'CEPA(1)'; if (lowername == 'fno-cepa(3)'):; PsiMod.set_local_option('FNOCC', 'NAT_ORBS', True); cepa_level = '",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/_modules/proc.html:76094,ENERGY,ENERGY,76094,psi4manual/4.0b4/_modules/proc.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/proc.html,1,['ENERGY'],['ENERGY']
Energy Efficiency,"RENT CORRELATION ENERGY', dfmp2_wfn.variable('MP2 CORRELATION ENERGY')); for k, v in dfmp2_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); core.tstop(); return dfmp2_wfn. def run_dfmp2d_gradient(name, **kwargs):; """"""Encode MP2-D method."""""". dfmp2_wfn = run_dfmp2_gradient('mp2', **kwargs); wfn_grad = dfmp2_wfn.gradient().clone(). _, _disp_functor = build_disp_functor('MP2D', restricted=True); disp_grad = _disp_functor.compute_gradient(dfmp2_wfn.molecule(), dfmp2_wfn); wfn_grad.add(disp_grad); dfmp2_wfn.set_gradient(wfn_grad). dfmp2_wfn.set_variable('MP2D CORRELATION ENERGY', dfmp2_wfn.variable('MP2 CORRELATION ENERGY') + dfmp2_wfn.variable('DISPERSION CORRECTION ENERGY')); dfmp2_wfn.set_variable('MP2D TOTAL ENERGY', dfmp2_wfn.variable('MP2D CORRELATION ENERGY') + dfmp2_wfn.variable('HF TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('MP2D TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('MP2D CORRELATION ENERGY')). # Shove variables into global space; for k, v in dfmp2_wfn.variables().items():; core.set_variable(k, v). return dfmp2_wfn. def run_ccenergy(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a CCSD, CC2, and CC3 calculation. """"""; optstash = p4util.OptionsState(; ['TRANSQT2', 'WFN'],; ['CCSORT', 'WFN'],; ['CCENERGY', 'WFN']). if name == 'ccsd':; core.set_local_option('TRANSQT2', 'WFN', 'CCSD'); core.set_local_option('CCSORT', 'WFN', 'CCSD'); core.set_local_option('CCTRANSORT', 'WFN', 'CCSD'); core.set_local_option('CCENERGY', 'WFN', 'CCSD'); elif name == 'ccsd(t)':; core.set_local_option('TRANSQT2', 'WFN', 'CCSD_T'); core.set_local_option('CCSORT', 'WFN', 'CCSD_T'); core.set_local_option('CCTRANSORT', 'WFN', 'CCSD_T'); core.set_local_option('CCENERGY', 'WFN', 'CCSD_T'); elif name == 'a-ccsd(t)':; core.set_local_option('TRANSQT2', 'WFN', 'CCSD_AT'); core.set_local_option('CCSORT', 'WFN', 'CCSD_AT'); core.set_local_option('CCTRANSORT', 'WFN', 'CCS",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html:85435,ENERGY,ENERGY,85435,psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,4,['ENERGY'],['ENERGY']
Energy Efficiency,"RENT ENERGY; CURRENT REFERENCE ENERGY; CURRENT CORRELATION ENERGY. Caution; Some features are not yet implemented. Buy a developer a coffee. No way to tell function to boost fitting basis size for all calculations.; No way to extrapolate def2 family basis sets; Need to add more extrapolation schemes. As represented in the equation below, a CBS energy method is defined in several; sequential stages (scf, corl, delta, delta2, delta3, delta4, delta5) covering treatment; of the reference total energy, the correlation energy, a delta correction to the; correlation energy, and a second delta correction, etc.. Each is activated by its; stage_wfn keyword and is only allowed if all preceding stages are active. Here, is an energy or energy extrapolation scheme, and the following also hold. A translation of this ungainly equation to example [5] below is as; follows. In words, this is a double- and triple-zeta 2-point; Helgaker-extrapolated CCSD(T) coupled-cluster correlation correction; appended to a triple- and quadruple-zeta 2-point; Helgaker-extrapolated MP2 correlation energy appended to a SCF/aug-cc-pVQZ; reference energy. Energy Methods; The presence of a stage_wfn keyword is the indicator to incorporate; (and check for stage_basis and stage_scheme keywords) and compute; that stage in defining the CBS energy.; The cbs() function requires, at a minimum, name='scf' and scf_basis; keywords to be specified for reference-step only jobs and name and; corl_basis keywords for correlated jobs.; The following energy methods have been set up for cbs(). scf; mp2; mp2.5; mp3; mp4(sdq); mp4; mpn; omp2. omp2.5; omp3; olccd; lccd; lccsd; cepa(0); cepa(1); cepa(3). acpf; aqcc; qcisd; cc2; ccsd; fno-ccsd; bccd. cc3; qcisd(t); ccsd(t); fno-ccsd(t); bccd(t); cisd; cisdt. cisdtq; cin; fci; mrccsd; mrccsd(t); mrccsdt; mrccsdt(q). Parameters:; name (string) – 'scf' || 'ccsd' || etc.; First argument, usually unlabeled. Indicates the computational method; for the correlation energy, unless only r",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/cbs-1.html:2072,energy,energy,2072,psi4manual/1.0.0/cbs-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/cbs-1.html,4,['energy'],['energy']
Energy Efficiency,"RGY""); psi4.set_variable(""CURRENT ENERGY"",emp3); psi4.set_variable(""CURRENT CORRELATION ENERGY"",cemp3); elif ( lowername == 'fno-mp3' ):; emp3 = psi4.get_variable(""MP3 TOTAL ENERGY""); cemp3 = psi4.get_variable(""MP3 CORRELATION ENERGY""); psi4.set_variable(""CURRENT ENERGY"",emp3); psi4.set_variable(""CURRENT CORRELATION ENERGY"",cemp3); elif ( lowername == 'mp4(sdq)'):; emp4sdq = psi4.get_variable(""MP4(SDQ) TOTAL ENERGY""); cemp4sdq = psi4.get_variable(""MP4(SDQ) CORRELATION ENERGY""); psi4.set_variable(""CURRENT ENERGY"",emp4sdq); psi4.set_variable(""CURRENT CORRELATION ENERGY"",cemp4sdq); elif ( lowername == 'fno-mp4(sdq)'):; emp4sdq = psi4.get_variable(""MP4(SDQ) TOTAL ENERGY""); cemp4sdq = psi4.get_variable(""MP4(SDQ) CORRELATION ENERGY""); psi4.set_variable(""CURRENT ENERGY"",emp4sdq); psi4.set_variable(""CURRENT CORRELATION ENERGY"",cemp4sdq); elif ( lowername == 'fno-mp4'):; emp4 = psi4.get_variable(""MP4 TOTAL ENERGY""); cemp4 = psi4.get_variable(""MP4 CORRELATION ENERGY""); psi4.set_variable(""CURRENT ENERGY"",emp4); psi4.set_variable(""CURRENT CORRELATION ENERGY"",cemp4); elif (lowername == 'fnocc-mp') and (level == 4):; emp4 = psi4.get_variable(""MP4 TOTAL ENERGY""); cemp4 = psi4.get_variable(""MP4 CORRELATION ENERGY""); psi4.set_variable(""CURRENT ENERGY"",emp4); psi4.set_variable(""CURRENT CORRELATION ENERGY"",cemp4). # restore options; optstash.restore(). return psi4.get_variable(""CURRENT ENERGY""). [docs]def run_cepa(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a cepa-like calculation. >>> energy('cepa(1)'). """"""; lowername = name.lower(); uppername = name.upper(); kwargs = p4util.kwargs_lower(kwargs). # save user options; optstash = p4util.OptionsState(; ['TRANSQT2', 'WFN'],; ['FNOCC', 'NAT_ORBS'],; ['FNOCC', 'RUN_CEPA'],; ['FNOCC', 'USE_DF_INTS'],; ['FNOCC', 'CEPA_NO_SINGLES']). psi4.set_local_option('FNOCC','RUN_CEPA', True); psi4.set_local_option('FNOCC','USE_DF_INTS', False). # what type of cepa?; cepa_level = uppername; if (lowername == 'cepa(2)'):; raise",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/proc.html:71745,ENERGY,ENERGY,71745,psi4manual/4.0b5/_modules/proc.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/proc.html,1,['ENERGY'],['ENERGY']
Energy Efficiency,"RGY"": None,; ""MP2 DOUBLES ENERGY"": None,; ""CCSD TOTAL ENERGY"": None,; ""CCSD CORRELATION ENERGY"": None,; ""CCSD SAME-SPIN CORRELATION ENERGY"": None,; ""CCSD OPPOSITE-SPIN CORRELATION ENERGY"": None,; ""CCSD SINGLES ENERGY"": None,; ""CCSD DOUBLES ENERGY"": None,; }. while True:; sort_func(ref_wfn). ref_wfn = core.ccenergy(ref_wfn); core.print_out('Brueckner convergence check: %s\n' % bool(core.variable('BRUECKNER CONVERGED'))); if core.variable('BRUECKNER CONVERGED'):; break. if bcc_iter_cnt >= core.get_option('CCENERGY', 'BCCD_MAXITER'):; core.print_out(""\n\nWarning! BCCD did not converge within the maximum number of iterations.""); core.print_out(""You can increase the number of BCCD iterations by changing BCCD_MAXITER.\n\n""); break; bcc_iter_cnt += 1. if bcc_iter_cnt == 1:; for pv in hold_qcvars:; hold_qcvars[pv] = ref_wfn.variable(pv). ref_wfn.set_variable(""BCCD TOTAL ENERGY"", ref_wfn.variable(""CCSD TOTAL ENERGY"")); ref_wfn.set_variable(""BCCD CORRELATION ENERGY"", ref_wfn.variable(""BCCD TOTAL ENERGY"") - ref_wfn.variable(""SCF TOTAL ENERGY"")); ref_wfn.set_variable(""CURRENT CORRELATION ENERGY"", ref_wfn.variable(""BCCD CORRELATION ENERGY"")). # copy back canonical MP2 and CCSD from initial iteration; for pv, v in hold_qcvars.items():; if v is not None:; ref_wfn.set_variable(pv, v); core.set_variable(pv, v). if name == 'bccd(t)':; core.cctriples(ref_wfn); ref_wfn.set_variable(""B(T) CORRECTION ENERGY"", ref_wfn.variable(""(T) CORRECTION ENERGY"")); ref_wfn.set_variable(""BCCD(T) TOTAL ENERGY"", ref_wfn.variable(""CCSD(T) TOTAL ENERGY"")); ref_wfn.set_variable(""BCCD(T) CORRELATION ENERGY"", ref_wfn.variable(""BCCD(T) TOTAL ENERGY"") - ref_wfn.variable(""SCF TOTAL ENERGY"")) # note != CCSD(T) CORRELATION ENERGY; ref_wfn.set_variable(""CURRENT CORRELATION ENERGY"", ref_wfn.variable(""BCCD(T) CORRELATION ENERGY"")). for pv in [""(T) CORRECTION ENERGY"", ""CCSD(T) TOTAL ENERGY"", ""CCSD(T) CORRELATION ENERGY""]:; ref_wfn.del_variable(pv); core.del_variable(pv). for pv in [; ""BCCD TOTAL ENERGY"",; ""BCCD CORRE",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:97306,ENERGY,ENERGY,97306,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,4,['ENERGY'],['ENERGY']
Energy Efficiency,"RGY', energies[-1]). core.set_parent_symmetry(''); optstash.restore(); optstash_conv.restore(). if return_wfn:; return (wfn.hessian(), wfn); else:; return wfn.hessian(). [docs]def frequency(name, **kwargs):; r""""""Function to compute harmonic vibrational frequencies. :aliases: frequencies(), freq(). :returns: *float* |w--w| Total electronic energy in Hartrees. :returns: (*float*, :py:class:`~psi4.core.Wavefunction`) |w--w| energy and wavefunction when **return_wfn** specified. :type name: string; :param name: ``'scf'`` || ``'mp2'`` || ``'ci5'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the system. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :type return_wfn: :ref:`boolean <op_py_boolean>`; :param return_wfn: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return the :py:class:`~psi4.core.Wavefunction`; calculation result as the second element (after *float* energy) of a tuple.; Arrays of frequencies and the Hessian can be accessed through the wavefunction. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``gradient`` |dr| || ``energy`` || ``cbs``. Indicates the type of calculation to be performed on the molecule.; The default dertype accesses ``'gradient'`` or ``'energy'``, while; ``'cbs'`` performs a multistage finite difference calculation.; If a nested series of python functions is intended (see :ref:`sec:intercalls`),; use keyword ``freq_func`` instead of ``func``. :type mode: string; :param mode: |dl| ``'continuous'`` |dr| || ``'sow'`` || ``'reap'``. For a finite difference of energies or gradients frequency, indicates; whether the calculations required to complete the frequency are to be run; in one file (``'continuous'``) or are to be farmed out in an; embarrassingly parallel fashion (``'sow'``/``'reap'``)/ For the latter,; run an initial job with ``'sow'`` and follow instructions in its out",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/driver.html:81494,energy,energy,81494,psi4manual/1.1.0/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/driver.html,1,['energy'],['energy']
Energy Efficiency,"RGY',; 'fno-ccsd': 'CCSD TOTAL ENERGY'}; VARH['fno-ccsd(t)'] = {; 'hf': 'HF TOTAL ENERGY',; 'mp2': 'MP2 TOTAL ENERGY',; 'fno-ccsd': 'CCSD TOTAL ENERGY',; 'fno-ccsd(t)': 'CCSD(T) TOTAL ENERGY'}; VARH['qcisd(t)'] = {; 'hf': 'HF TOTAL ENERGY',; 'mp2': 'MP2 TOTAL ENERGY',; 'mp2.5': 'MP2.5 TOTAL ENERGY',; 'mp3': 'MP3 TOTAL ENERGY',; 'mp4(sdq)': 'MP4(SDQ) TOTAL ENERGY',; 'qcisd': 'QCISD TOTAL ENERGY',; 'qcisd(t)': 'QCISD(T) TOTAL ENERGY'}; VARH['ccsd(t)'] = {; 'hf': 'HF TOTAL ENERGY',; 'mp2': 'MP2 TOTAL ENERGY',; 'ccsd': 'CCSD TOTAL ENERGY',; 'ccsd(t)': 'CCSD(T) TOTAL ENERGY'}; VARH['ccsd(at)'] = {; 'hf': 'HF TOTAL ENERGY',; 'mp2': 'MP2 TOTAL ENERGY',; 'ccsd': 'CCSD TOTAL ENERGY',; 'ccsd(at)': 'CCSD(AT) TOTAL ENERGY'}; VARH[""a-ccsd(t)""] = VARH[""ccsd(at)""]; VARH['bccd(t)'] = {; 'hf': 'HF TOTAL ENERGY',; 'mp2': 'MP2 TOTAL ENERGY',; 'ccsd': 'CCSD TOTAL ENERGY',; 'bccd(t)': 'CCSD(T) TOTAL ENERGY'}; VARH['cisd'] = {; 'hf': 'HF TOTAL ENERGY',; 'cisd': 'CISD TOTAL ENERGY'}; VARH['cisdt'] = {; 'hf': 'HF TOTAL ENERGY',; 'cisdt': 'CISDT TOTAL ENERGY'}; VARH['cisdtq'] = {; 'hf': 'HF TOTAL ENERGY',; 'cisdtq': 'CISDTQ TOTAL ENERGY'}; VARH['fci'] = {; 'hf': 'HF TOTAL ENERGY',; 'fci': 'FCI TOTAL ENERGY'}; VARH['mrccsd'] = {; 'hf': 'HF TOTAL ENERGY',; 'mp2': 'MP2 TOTAL ENERGY',; 'mrccsd': 'CCSD TOTAL ENERGY'}; VARH['mrccsd(t)'] = {; 'hf': 'HF TOTAL ENERGY',; 'mp2': 'MP2 TOTAL ENERGY',; 'mrccsd': 'CCSD TOTAL ENERGY',; 'mrccsd(t)': 'CCSD(T) TOTAL ENERGY'}; VARH['mrccsdt'] = {; 'hf': 'HF TOTAL ENERGY',; 'mp2': 'MP2 TOTAL ENERGY',; 'mrccsdt': 'CCSDT TOTAL ENERGY'}; VARH['mrccsdt(q)'] = {; 'hf': 'HF TOTAL ENERGY',; 'mp2': 'MP2 TOTAL ENERGY',; 'mrccsdt': 'CCSDT TOTAL ENERGY',; 'mrccsdt(q)': 'CCSDT(Q) TOTAL ENERGY'}. for cilevel in range(2, 99):; VARH[f'ci{cilevel}'] = {; 'hf': 'HF TOTAL ENERGY',; f'ci{cilevel}': 'CI TOTAL ENERGY'}. for mplevel in range(5, 99):; VARH[f'mp{mplevel}'] = {; 'hf': 'HF TOTAL ENERGY',; f'mp{mplevel}': f'MP{mplevel} TOTAL ENERGY'}; for mplevel2 in range(2, mplevel):; V",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html:26514,ENERGY,ENERGY,26514,psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html,117,['ENERGY'],['ENERGY']
Energy Efficiency,"RGY':; psivar['MP2 CORRELATION ENERGY'] = line.split()[-2]; break. [docs]def harvest_coupled_cluster(lines, psivar):; """"""Harvest coupled cluster results; WARNING: Canonical and DLPNO print the coupled cluster results differently; """"""; """"""Sample (canonical) CCSD results block""""""; #----------------------; #COUPLED CLUSTER ENERGY; #----------------------; #; #E(0) ... -76.063720080; #E(CORR) ... -0.288938791; #E(TOT) ... -76.352658871; #Singles Norm <S|S>**1/2 ... 0.021106262; #T1 diagnostic ... 0.007462191; #. """"""Sample DLPNO coupled cluster block (CCSD)""""""; #----------------------; #COUPLED CLUSTER ENERGY; #----------------------; #; #E(0) ... -76.026019996; #E(CORR)(strong-pairs) ... -0.211953159; #E(CORR)(weak-pairs) ... -0.000007244; #E(CORR)(corrected) ... -0.211960403; #E(TOT) ... -76.237980399; #Singles Norm <S|S>**1/2 ... 0.014443573; #T1 diagnostic ... 0.005106574; #. """"""Sample CCSD(T) block (same for DLPNO and canonical)""""""; #; #Triples Correction (T) ... -0.001544381; #Final correlation energy ... -0.134770265; #E(CCSD) ... -75.709548429; #E(CCSD(T)) ... -75.711092810; #. cc_start = find_start(lines, 'COUPLED CLUSTER ENERGY'); if cc_start == -1:; return. #psivar[""CC REFERENCE""] = float(lines[cc_start + 3].split()[-1]). # CCSD energy block is less than 20 lines; for i, line in enumerate(lines[cc_start:cc_start + 20], start=cc_start):; if line[:6] == ""E(TOT)"":; psivar[""CCSD TOTAL ENERGY""] = line.split()[-1]; psivar[""CCSD CORRELATION ENERGY""] = lines[i-1].split()[-1]; #psivar[""SINGLES NORM""] = lines[i+1].split()[-1]; #psivar[""T1 DIAGNOSTIC""] = lines[i+2].split()[-1]; break. # CCSD(T) energy block; for i, line in enumerate(lines[cc_start:], start=cc_start):; if line[:22] == ""Triples Correction (T)"":; #psivar[""TRIPLES CORRELATION ENERGY""] = line.split()[-1]; psivar[""CCSD(T) CORRELATION ENERGY""] = lines[i+1].split()[-1]; psivar[""CCSD TOTAL ENERGY""] = lines[i+2].split()[-1]; psivar[""CCSD(T) TOTAL ENERGY""] = lines[i+3].split()[-1]; break. [docs]def harvest_engrad(e",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/orca.html:8473,energy,energy,8473,psi4manual/1.0.0/_modules/qcdb/orca.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/orca.html,1,['energy'],['energy']
Energy Efficiency,"RGY'], energies['TWO-ELECTRON ENERGY'], 7,; label + '. 2-electron energy'); pass_scf = compare_values(ref_energies['SCF TOTAL ENERGY'], energies['SCF TOTAL ENERGY'], 10,; label + '. SCF total energy'); pass_mp2 = compare_values(ref_energies['MP2 CORRELATION ENERGY'], energies['MP2 CORRELATION ENERGY'], 10,; label + '. MP2 correlation energy'). if (pass_1el and pass_2el and pass_scf and pass_mp2):; success(label). return True. [docs]def energies_from_fcidump(intdump):; energies = {}; energies['NUCLEAR REPULSION ENERGY'] = intdump['enuc']; epsilon = intdump['epsilon']; Hcore = intdump['hcore']; eri = intdump['eri']. # Compute SCF energy; energies['ONE-ELECTRON ENERGY'], energies['TWO-ELECTRON ENERGY'] = _scf_energy(Hcore, eri,; np.where(epsilon < 0)[0],; intdump['uhf']); # yapf: disable; energies['SCF TOTAL ENERGY'] = energies['ONE-ELECTRON ENERGY'] + energies['TWO-ELECTRON ENERGY'] + energies['NUCLEAR REPULSION ENERGY']; # yapf: enable. # Compute MP2 energy; energies['MP2 CORRELATION ENERGY'] = _mp2_energy(eri, epsilon, intdump['uhf']). return energies. def _scf_energy(Hcore, ERI, occ_sl, unrestricted):; scf_1el_e = np.einsum('ii->', Hcore[np.ix_(occ_sl, occ_sl)]); if not unrestricted:; scf_1el_e *= 2; coulomb = np.einsum('iijj->', ERI[np.ix_(occ_sl, occ_sl, occ_sl, occ_sl)]); exchange = np.einsum('ijij->', ERI[np.ix_(occ_sl, occ_sl, occ_sl, occ_sl)]); if unrestricted:; scf_2el_e = 0.5 * (coulomb - exchange); else:; scf_2el_e = 2.0 * coulomb - exchange. return scf_1el_e, scf_2el_e. def _mp2_energy(ERI, epsilon, unrestricted):; # Occupied and virtual slices; occ_sl = np.where(epsilon < 0)[0]; vir_sl = np.where(epsilon > 0)[0]; eocc = epsilon[occ_sl]; evir = epsilon[vir_sl]; denom = 1 / (eocc.reshape(-1, 1, 1, 1) - evir.reshape(-1, 1, 1) + eocc.reshape(-1, 1) - evir); MO = ERI[np.ix_(occ_sl, vir_sl, occ_sl, vir_sl)]; if unrestricted:; mp2_e = 0.5 * np.einsum(""abrs,abrs,abrs->"", MO, MO - MO.swapaxes(1, 3), denom); else:; mp2_e = np.einsum('iajb,iajb,iajb->', MO, MO, den",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/p4util/fcidump.html:14531,energy,energy,14531,psi4manual/1.3.2/_modules/psi4/driver/p4util/fcidump.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/p4util/fcidump.html,1,['energy'],['energy']
Energy Efficiency,RGY. CCSDT(Q)TOTALENERGY. CCSDT-1aCORRELATIONENERGY. CCSDT-1aTOTALENERGY. CCSDT-1bCORRELATIONENERGY. CCSDT-1bTOTALENERGY. CCSDT-3CORRELATIONENERGY. CCSDT-3TOTALENERGY. CCSDTCORRELATIONENERGY. CCSDTOTALENERGY. CCSDTQ-1aCORRELATIONENERGY. CCSDTQ-1aTOTALENERGY. CCSDTQ-1bCORRELATIONENERGY. CCSDTQ-1bTOTALENERGY. CCSDTQ-3CORRELATIONENERGY. CCSDTQ-3TOTALENERGY. CCSDTQCORRELATIONENERGY. CCSDTQTOTALENERGY. CCSDTTOTALENERGY. CCTOTALENERGY. center_of_mass() LibmintsMolecule method. CEPA. advanced-keywords. basic-keywords. theory. CEPA(0)CORRELATIONENERGY. CEPA(0)DIPOLEX. CEPA(0)DIPOLEY. CEPA(0)DIPOLEZ. CEPA(0)QUADRUPOLEXX. CEPA(0)QUADRUPOLEXY. CEPA(0)QUADRUPOLEXZ. CEPA(0)QUADRUPOLEYY. CEPA(0)QUADRUPOLEYZ. CEPA(0)QUADRUPOLEZZ. CEPA(0)TOTALENERGY. CEPA(1)CORRELATIONENERGY. CEPA(1)TOTALENERGY. CEPA(2)CORRELATIONENERGY. CEPA(2)TOTALENERGY. CEPA(3)CORRELATIONENERGY. CEPA(3)TOTALENERGY. CEPA_LEVEL (CEPA). CEPA_NO_SINGLES (CEPA). CEPA_SCALE_OS (CEPA). CEPA_SCALE_SS (CEPA). CEPA_VABCD_DIRECT (CEPA). charge; . molecule. charge() CoordEntry method. LibmintsMolecule method. charge_specified() LibmintsMolecule method. CHECK_C_ORTHONORM (TRANSQT). check_parentheses_and_brackets() in module input. CI. arbitrary-order coupled-cluster theory. arbitrary-order perturbation theory. basic-keywords. theory. CI_DIIS (MCSCF). CI_NUM_THREADS (DETCI). CIBLKS_PRINT (DETCI). CICORRELATIONENERGY. CIDIPOLEX. CIDIPOLEY. CIDIPOLEZ. CInCORRELATIONENERGY. CInTOTALENERGY. CIQUADRUPOLEXX. CIQUADRUPOLEXY. CIQUADRUPOLEXZ. CIQUADRUPOLEYY. CIQUADRUPOLEYZ. CIQUADRUPOLEZZ. CIROOTn->ROOTmDIPOLEX. CIROOTn->ROOTmDIPOLEY. CIROOTn->ROOTmDIPOLEZ. CIROOTn->ROOTmQUADRUPOLEXX. CIROOTn->ROOTmQUADRUPOLEXY. CIROOTn->ROOTmQUADRUPOLEXZ. CIROOTn->ROOTmQUADRUPOLEYY. CIROOTn->ROOTmQUADRUPOLEYZ. CIROOTn->ROOTmQUADRUPOLEZZ. CIROOTnCORRELATIONENERGY. CIROOTnDIPOLEX. CIROOTnDIPOLEY. CIROOTnDIPOLEZ. CIROOTnQUADRUPOLEXX. CIROOTnQUADRUPOLEXY. CIROOTnQUADRUPOLEXZ. CIROOTnQUADRUPOLEYY. CIROOTnQUADRUPOLEYZ. CIROOTnQUADRUPOLEZZ. CIROOTnTOTALENE,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/genindex.html:11803,charge,charge,11803,psi4manual/4.0b3/genindex.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/genindex.html,1,['charge'],['charge']
Energy Efficiency,RGY; CC TRIPLET PAIR ENERGIES (array); CC2 ALPHA-ALPHA PAIR ENERGIES; CC2 ALPHA-BETA PAIR ENERGIES; CC2 CORRELATION ENERGY; CC2 DIPOLE POLARIZABILITY @ xNM; CC2 DIPOLE POLARIZABILITY TENSOR @ xNM; CC2 QUADRUPOLE POLARIZABILITY TENSOR @ xNM; CC2 ROTATION (LEN) ORIGIN-DEPENDENCE @ xNM; CC2 SINGLET PAIR ENERGIES; CC2 SPECIFIC ROTATION (LEN) @ xNM; CC2 SPECIFIC ROTATION (MVG) @ xNM; CC2 SPECIFIC ROTATION (VEL) @ xNM; CC2 TOTAL ENERGY; CC2 TRIPLET PAIR ENERGIES; CC3 ALPHA-ALPHA PAIR ENERGIES; CC3 ALPHA-BETA PAIR ENERGIES; CC3 CORRELATION ENERGY; CC3 SINGLET PAIR ENERGIES; CC3 TOTAL ENERGY; CC3 TRIPLET PAIR ENERGIES; CCSD ALPHA-ALPHA PAIR ENERGIES; CCSD ALPHA-BETA PAIR ENERGIES; CCSD CORRELATION ENERGY; CCSD DIPOLE POLARIZABILITY @ xNM; CCSD DIPOLE POLARIZABILITY TENSOR @ xNM; CCSD DOUBLES ENERGY; CCSD ITERATIONS; CCSD OPPOSITE-SPIN CORRELATION ENERGY; CCSD QUADRUPOLE POLARIZABILITY TENSOR @ xNM; CCSD ROTATION (LEN) ORIGIN-DEPENDENCE @ xNM; CCSD SAME-SPIN CORRELATION ENERGY; CCSD SINGLES ENERGY; CCSD SINGLET PAIR ENERGIES; CCSD SPECIFIC ROTATION (LEN) @ xNM; CCSD SPECIFIC ROTATION (MVG) @ xNM; CCSD SPECIFIC ROTATION (VEL) @ xNM; CCSD TOTAL ENERGY; CCSD TRIPLET PAIR ENERGIES; CCSD(T) CORRELATION ENERGY; CCSD(T) TOTAL ENERGY; CCname ROOT m (IN h) -> ROOT n (IN i) EINSTEIN A (LEN); CCname ROOT m (IN h) -> ROOT n (IN i) EINSTEIN B (LEN); CCname ROOT m (IN h) -> ROOT n (IN i) OSCILLATOR STRENGTH (LEN); CCname ROOT m (IN h) -> ROOT n (IN i) ROTATORY STRENGTH (LEN); CCname ROOT m (IN h) -> ROOT n (IN i) ROTATORY STRENGTH (VEL); CCname ROOT m (h) -> ROOT n (i) EINSTEIN A (LEN); CCname ROOT m (h) -> ROOT n (i) EINSTEIN B (LEN); CCname ROOT m (h) -> ROOT n (i) OSCILLATOR STRENGTH (LEN); CCname ROOT m (h) -> ROOT n (i) ROTATORY STRENGTH (LEN); CCname ROOT m (h) -> ROOT n (i) ROTATORY STRENGTH (VEL); CCname ROOT m -> ROOT n EINSTEIN A (LEN); CCname ROOT m -> ROOT n EINSTEIN A (LEN) - h TRANSITION; CCname ROOT m -> ROOT n EINSTEIN B (LEN); CCname ROOT m -> ROOT n EINSTEIN B (LEN) - h T,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/autodir_psivariables/module__ccenergy.html:1673,ENERGY,ENERGY,1673,psi4manual/1.6.x/autodir_psivariables/module__ccenergy.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/autodir_psivariables/module__ccenergy.html,1,['ENERGY'],['ENERGY']
Energy Efficiency,RGY; LCCD CORRELATION ENERGY; LCCD DOUBLES ENERGY; LCCD OPPOSITE-SPIN CORRELATION ENERGY; LCCD SAME-SPIN CORRELATION ENERGY; LCCD SINGLES ENERGY; LCCD TOTAL ENERGY; MP2 CORRELATION ENERGY; MP2 DOUBLES ENERGY; MP2 OPPOSITE-SPIN CORRELATION ENERGY; MP2 SAME-SPIN CORRELATION ENERGY; MP2 SINGLES ENERGY; MP2 TOTAL ENERGY; MP2.5 CORRELATION ENERGY; MP2.5 DOUBLES ENERGY; MP2.5 OPPOSITE-SPIN CORRELATION ENERGY; MP2.5 SAME-SPIN CORRELATION ENERGY; MP2.5 SINGLES ENERGY; MP2.5 TOTAL ENERGY; MP3 CORRELATION ENERGY; MP3 DOUBLES ENERGY; MP3 OPPOSITE-SPIN CORRELATION ENERGY; MP3 SAME-SPIN CORRELATION ENERGY; MP3 SINGLES ENERGY; MP3 TOTAL ENERGY; OLCCD CORRELATION ENERGY; OLCCD OPPOSITE-SPIN CORRELATION ENERGY; OLCCD REFERENCE CORRECTION ENERGY; OLCCD SAME-SPIN CORRELATION ENERGY; OLCCD TOTAL ENERGY; OMP2 CORRELATION ENERGY; OMP2 OPPOSITE-SPIN CORRELATION ENERGY; OMP2 REFERENCE CORRECTION ENERGY; OMP2 SAME-SPIN CORRELATION ENERGY; OMP2 TOTAL ENERGY; OMP2.5 CORRELATION ENERGY; OMP2.5 OPPOSITE-SPIN CORRELATION ENERGY; OMP2.5 REFERENCE CORRECTION ENERGY; OMP2.5 SAME-SPIN CORRELATION ENERGY; OMP2.5 TOTAL ENERGY; OMP3 CORRELATION ENERGY; OMP3 OPPOSITE-SPIN CORRELATION ENERGY; OMP3 REFERENCE CORRECTION ENERGY; OMP3 SAME-SPIN CORRELATION ENERGY; OMP3 TOTAL ENERGY; OREMP2 CORRELATION ENERGY; OREMP2 OPPOSITE-SPIN CORRELATION ENERGY; OREMP2 REFERENCE CORRECTION ENERGY; OREMP2 SAME-SPIN CORRELATION ENERGY; OREMP2 TOTAL ENERGY; REMP2 CORRELATION ENERGY; REMP2 DOUBLES ENERGY; REMP2 OPPOSITE-SPIN CORRELATION ENERGY; REMP2 SAME-SPIN CORRELATION ENERGY; REMP2 SINGLES ENERGY; REMP2 TOTAL ENERGY; SCS(N)-MP2 CORRELATION ENERGY; SCS(N)-MP2 TOTAL ENERGY; SCS-MP2 CORRELATION ENERGY; SCS-MP2 TOTAL ENERGY; SCS-MP2-VDW CORRELATION ENERGY; SCS-MP2-VDW TOTAL ENERGY; SCS-MP3 CORRELATION ENERGY; SCS-MP3 TOTAL ENERGY; SCS-OMP2 CORRELATION ENERGY; SCS-OMP2 TOTAL ENERGY; SCS-OMP3 CORRELATION ENERGY; SCS-OMP3 TOTAL ENERGY; SOS-MP2 CORRELATION ENERGY; SOS-MP2 TOTAL ENERGY; SOS-OMP2 CORRELATION ENERGY; SOS-OMP2 TOTAL,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/autodir_psivariables/module__occ.html:1883,ENERGY,ENERGY,1883,psi4manual/1.7.x/autodir_psivariables/module__occ.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/autodir_psivariables/module__occ.html,4,['ENERGY'],['ENERGY']
Energy Efficiency,"RGY; LCCD TOTAL ENERGY; MP2 CORRELATION ENERGY; MP2 DOUBLES ENERGY; MP2 OPPOSITE-SPIN CORRELATION ENERGY; MP2 SAME-SPIN CORRELATION ENERGY; MP2 SINGLES ENERGY; MP2 TOTAL ENERGY; MP2.5 CORRELATION ENERGY; MP2.5 DOUBLES ENERGY; MP2.5 OPPOSITE-SPIN CORRELATION ENERGY; MP2.5 SAME-SPIN CORRELATION ENERGY; MP2.5 SINGLES ENERGY; MP2.5 TOTAL ENERGY; MP3 CORRELATION ENERGY; MP3 DOUBLES ENERGY; MP3 OPPOSITE-SPIN CORRELATION ENERGY; MP3 SAME-SPIN CORRELATION ENERGY; MP3 SINGLES ENERGY; MP3 TOTAL ENERGY; NAUX (SCF); OLCCD CORRELATION ENERGY; OLCCD OPPOSITE-SPIN CORRELATION ENERGY; OLCCD REFERENCE CORRECTION ENERGY; OLCCD SAME-SPIN CORRELATION ENERGY; OLCCD TOTAL ENERGY; OMP2 CORRELATION ENERGY; OMP2 OPPOSITE-SPIN CORRELATION ENERGY; OMP2 REFERENCE CORRECTION ENERGY; OMP2 SAME-SPIN CORRELATION ENERGY; OMP2 TOTAL ENERGY; OMP2.5 CORRELATION ENERGY; OMP2.5 OPPOSITE-SPIN CORRELATION ENERGY; OMP2.5 REFERENCE CORRECTION ENERGY; OMP2.5 SAME-SPIN CORRELATION ENERGY; OMP2.5 TOTAL ENERGY; OMP3 CORRELATION ENERGY; OMP3 OPPOSITE-SPIN CORRELATION ENERGY; OMP3 REFERENCE CORRECTION ENERGY; OMP3 SAME-SPIN CORRELATION ENERGY; OMP3 TOTAL ENERGY; OREMP2 CORRELATION ENERGY; OREMP2 REFERENCE CORRECTION ENERGY; OREMP2 TOTAL ENERGY; REMP2 CORRELATION ENERGY; REMP2 DOUBLES ENERGY; REMP2 OPPOSITE-SPIN CORRELATION ENERGY; REMP2 SAME-SPIN CORRELATION ENERGY; REMP2 SINGLES ENERGY; REMP2 TOTAL ENERGY; SCF TOTAL ENERGY; SCS(N)-MP2 CORRELATION ENERGY; SCS(N)-MP2 TOTAL ENERGY; SCS(N)-OMP2 CORRELATION ENERGY; SCS(N)-OMP2 TOTAL ENERGY; SCS-MP2 CORRELATION ENERGY; SCS-MP2 TOTAL ENERGY; SCS-OMP2 CORRELATION ENERGY; SCS-OMP2 TOTAL ENERGY; SOS-MP2 CORRELATION ENERGY; SOS-MP2 TOTAL ENERGY; SOS-OMP2 CORRELATION ENERGY; SOS-OMP2 TOTAL ENERGY. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; PSI Variables by Module; DFOCC. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/autodir_psivariables/module__dfocc.html:1739,ENERGY,ENERGY,1739,psi4manual/master/autodir_psivariables/module__dfocc.html,https://psicode.org,https://psicode.org/psi4manual/master/autodir_psivariables/module__dfocc.html,28,['ENERGY'],['ENERGY']
Energy Efficiency,"RGY; SAPT EXCH-IND-DISP30 ENERGY; SAPT EXCH-IND20,R ENERGY; SAPT EXCH-IND20,U ENERGY; SAPT EXCH-IND22 ENERGY; SAPT EXCH-IND30,R ENERGY; SAPT EXCH10 ENERGY; SAPT EXCH10(S^2) ENERGY; SAPT EXCH11(S^2) ENERGY; SAPT EXCH12(S^2) ENERGY; SAPT HF TOTAL ENERGY; SAPT IND ENERGY; SAPT IND-DISP30 ENERGY; SAPT IND20,R ENERGY; SAPT IND20,U ENERGY; SAPT IND22 ENERGY; SAPT IND30,R ENERGY; SAPT MP2 CORRELATION ENERGY; SAPT SAME-SPIN DISP20 ENERGY; SAPT SAME-SPIN EXCH-DISP20 ENERGY; SAPT TOTAL ENERGY; SAPT0 DISP ENERGY; SAPT0 ELST ENERGY; SAPT0 EXCH ENERGY; SAPT0 IND ENERGY; SAPT0 TOTAL ENERGY; SAPT2 DISP ENERGY; SAPT2 ELST ENERGY; SAPT2 EXCH ENERGY; SAPT2 IND ENERGY; SAPT2 TOTAL ENERGY; SAPT2+ DISP ENERGY; SAPT2+ ELST ENERGY; SAPT2+ EXCH ENERGY; SAPT2+ IND ENERGY; SAPT2+ TOTAL ENERGY; SAPT2+(3) DISP ENERGY; SAPT2+(3) ELST ENERGY; SAPT2+(3) EXCH ENERGY; SAPT2+(3) IND ENERGY; SAPT2+(3) TOTAL ENERGY; SAPT2+(3)(CCD) DISP ENERGY; SAPT2+(3)(CCD) ELST ENERGY; SAPT2+(3)(CCD) EXCH ENERGY; SAPT2+(3)(CCD) IND ENERGY; SAPT2+(3)(CCD) TOTAL ENERGY; SAPT2+(3)(CCD)DMP2 DISP ENERGY; SAPT2+(3)(CCD)DMP2 ELST ENERGY; SAPT2+(3)(CCD)DMP2 EXCH ENERGY; SAPT2+(3)(CCD)DMP2 IND ENERGY; SAPT2+(3)(CCD)DMP2 TOTAL ENERGY; SAPT2+(3)DMP2 DISP ENERGY; SAPT2+(3)DMP2 ELST ENERGY; SAPT2+(3)DMP2 EXCH ENERGY; SAPT2+(3)DMP2 IND ENERGY; SAPT2+(3)DMP2 TOTAL ENERGY; SAPT2+(CCD) DISP ENERGY; SAPT2+(CCD) ELST ENERGY; SAPT2+(CCD) EXCH ENERGY; SAPT2+(CCD) IND ENERGY; SAPT2+(CCD) TOTAL ENERGY; SAPT2+(CCD)DMP2 DISP ENERGY; SAPT2+(CCD)DMP2 ELST ENERGY; SAPT2+(CCD)DMP2 EXCH ENERGY; SAPT2+(CCD)DMP2 IND ENERGY; SAPT2+(CCD)DMP2 TOTAL ENERGY; SAPT2+3 DISP ENERGY; SAPT2+3 ELST ENERGY; SAPT2+3 EXCH ENERGY; SAPT2+3 IND ENERGY; SAPT2+3 TOTAL ENERGY; SAPT2+3(CCD) DISP ENERGY; SAPT2+3(CCD) ELST ENERGY; SAPT2+3(CCD) EXCH ENERGY; SAPT2+3(CCD) IND ENERGY; SAPT2+3(CCD) TOTAL ENERGY; SAPT2+3(CCD)DMP2 DISP ENERGY; SAPT2+3(CCD)DMP2 ELST ENERGY; SAPT2+3(CCD)DMP2 EXCH ENERGY; SAPT2+3(CCD)DMP2 IND ENERGY; SAPT2+3(CCD)DMP2 TOTAL ENERGY; SAPT2+3DMP2 DISP ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/autodir_psivariables/module__sapt-1.html:1708,ENERGY,ENERGY,1708,psi4manual/1.4.0/autodir_psivariables/module__sapt-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_psivariables/module__sapt-1.html,4,['ENERGY'],['ENERGY']
Energy Efficiency,"RGY; SAPT EXCH-IND20,R ENERGY; SAPT EXCH-IND20,U ENERGY; SAPT EXCH-IND22 ENERGY; SAPT EXCH-IND30,R ENERGY; SAPT EXCH10 ENERGY; SAPT EXCH10(S^2) ENERGY; SAPT EXCH11(S^2) ENERGY; SAPT EXCH12(S^2) ENERGY; SAPT HF TOTAL ENERGY; SAPT IND ENERGY; SAPT IND-DISP30 ENERGY; SAPT IND20,R ENERGY; SAPT IND20,U ENERGY; SAPT IND22 ENERGY; SAPT IND30,R ENERGY; SAPT MP2 CORRELATION ENERGY; SAPT SAME-SPIN DISP20 ENERGY; SAPT SAME-SPIN EXCH-DISP20 ENERGY; SAPT TOTAL ENERGY; SAPT0 DISP ENERGY; SAPT0 ELST ENERGY; SAPT0 EXCH ENERGY; SAPT0 IND ENERGY; SAPT0 TOTAL ENERGY; SAPT2 DISP ENERGY; SAPT2 ELST ENERGY; SAPT2 EXCH ENERGY; SAPT2 IND ENERGY; SAPT2 TOTAL ENERGY; SAPT2+ DISP ENERGY; SAPT2+ ELST ENERGY; SAPT2+ EXCH ENERGY; SAPT2+ IND ENERGY; SAPT2+ TOTAL ENERGY; SAPT2+(3) DISP ENERGY; SAPT2+(3) ELST ENERGY; SAPT2+(3) EXCH ENERGY; SAPT2+(3) IND ENERGY; SAPT2+(3) TOTAL ENERGY; SAPT2+(3)(CCD) DISP ENERGY; SAPT2+(3)(CCD) ELST ENERGY; SAPT2+(3)(CCD) EXCH ENERGY; SAPT2+(3)(CCD) IND ENERGY; SAPT2+(3)(CCD) TOTAL ENERGY; SAPT2+(3)(CCD)DMP2 DISP ENERGY; SAPT2+(3)(CCD)DMP2 ELST ENERGY; SAPT2+(3)(CCD)DMP2 EXCH ENERGY; SAPT2+(3)(CCD)DMP2 IND ENERGY; SAPT2+(3)(CCD)DMP2 TOTAL ENERGY; SAPT2+(3)DMP2 DISP ENERGY; SAPT2+(3)DMP2 ELST ENERGY; SAPT2+(3)DMP2 EXCH ENERGY; SAPT2+(3)DMP2 IND ENERGY; SAPT2+(3)DMP2 TOTAL ENERGY; SAPT2+(CCD) DISP ENERGY; SAPT2+(CCD) ELST ENERGY; SAPT2+(CCD) EXCH ENERGY; SAPT2+(CCD) IND ENERGY; SAPT2+(CCD) TOTAL ENERGY; SAPT2+(CCD)DMP2 DISP ENERGY; SAPT2+(CCD)DMP2 ELST ENERGY; SAPT2+(CCD)DMP2 EXCH ENERGY; SAPT2+(CCD)DMP2 IND ENERGY; SAPT2+(CCD)DMP2 TOTAL ENERGY; SAPT2+3 DISP ENERGY; SAPT2+3 ELST ENERGY; SAPT2+3 EXCH ENERGY; SAPT2+3 IND ENERGY; SAPT2+3 TOTAL ENERGY; SAPT2+3(CCD) DISP ENERGY; SAPT2+3(CCD) ELST ENERGY; SAPT2+3(CCD) EXCH ENERGY; SAPT2+3(CCD) IND ENERGY; SAPT2+3(CCD) TOTAL ENERGY; SAPT2+3(CCD)DMP2 DISP ENERGY; SAPT2+3(CCD)DMP2 ELST ENERGY; SAPT2+3(CCD)DMP2 EXCH ENERGY; SAPT2+3(CCD)DMP2 IND ENERGY; SAPT2+3(CCD)DMP2 TOTAL ENERGY; SAPT2+3DMP2 DISP ENERGY; SAPT2+3DMP2 ELST ENER",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/autodir_psivariables/module__sapt-1.html:1737,ENERGY,ENERGY,1737,psi4manual/1.4.0/autodir_psivariables/module__sapt-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_psivariables/module__sapt-1.html,4,['ENERGY'],['ENERGY']
Energy Efficiency,"RGY>` ; * :psivar:`MP2.5 CORRELATION ENERGY <MP2.5CORRELATIONENERGY>` . >>> energy('mp2.5'). """"""; lowername = name.lower(); kwargs = kwargs_lower(kwargs). # Run detci calculation and collect conventional quantities; energy('mp3', **kwargs); e_scf = PsiMod.get_variable('SCF TOTAL ENERGY'); ce_mp2 = PsiMod.get_variable('MP2 CORRELATION ENERGY'); ce_mp3 = PsiMod.get_variable('MP3 CORRELATION ENERGY'); e_mp2 = e_scf + ce_mp2; e_mp3 = e_scf + ce_mp3. # Compute quantities particular to MP2.5; ce_mp25 = 0.5 * (ce_mp2 + ce_mp3); e_mp25 = e_scf + ce_mp25; PsiMod.set_variable('MP2.5 CORRELATION ENERGY', ce_mp25); PsiMod.set_variable('MP2.5 TOTAL ENERGY', e_mp25); PsiMod.set_variable('CURRENT CORRELATION ENERGY', ce_mp25); PsiMod.set_variable('CURRENT ENERGY', e_mp25). # build string of title banner and print results; banners = ''; banners += """"""PsiMod.print_out('\\n')\n""""""; banners += """"""banner(' MP2.5 ')\n""""""; banners += """"""PsiMod.print_out('\\n')\n\n""""""; exec(banners). tables = ''; tables += """""" SCF total energy: %16.8f\n"""""" % (e_scf); tables += """""" MP2 total energy: %16.8f\n"""""" % (e_mp2); tables += """""" MP2.5 total energy: %16.8f\n"""""" % (e_mp25); tables += """""" MP3 total energy: %16.8f\n\n"""""" % (e_mp3); tables += """""" MP2 correlation energy: %16.8f\n"""""" % (ce_mp2); tables += """""" MP2.5 correlation energy: %16.8f\n"""""" % (ce_mp25); tables += """""" MP3 correlation energy: %16.8f\n"""""" % (ce_mp3); PsiMod.print_out(tables). return e_mp25. # A direct translation of a plugin input file into a function call. Function calls are the only; # way to call plugins in sow/reap mode for db(), opt(), etc. This isn't best practices; # but is an example of what to do for a more complicated procedure where different options ; # are set for different qc steps.; [docs]def run_plugin_omega(name, **kwargs):; r""""""Function encoding sequence of PSI module and plugin calls, as well; as typical options, to access Rob Parrish's omega plugin. >>> energy('plugin_omega'). """"""; lowername = name.lower(); kwargs = ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/_modules/aliases.html:3492,energy,energy,3492,psi4manual/4.0b3/_modules/aliases.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/_modules/aliases.html,2,['energy'],['energy']
Energy Efficiency,"RGY>`; * :psivar:`CBS CORRELATION ENERGY <CBSCORRELATIONENERGY>`; * :psivar:`CURRENT ENERGY <CURRENTENERGY>`; * :psivar:`CURRENT REFERENCE ENERGY <CURRENTREFERENCEENERGY>`; * :psivar:`CURRENT CORRELATION ENERGY <CURRENTCORRELATIONENERGY>`. .. caution:: Some features are not yet implemented. Buy a developer a coffee. - No way to tell function to boost fitting basis size for all calculations. - Need to add more extrapolation schemes. As represented in the equation below, a CBS energy method is defined in several; sequential stages (scf, corl, delta1, delta2, ... ) covering treatment; of the reference total energy, the correlation energy, a delta correction to the; correlation energy, and a second delta correction, etc.. Each is activated by its; stage_wfn keyword, or as a field in the ```cbs_metadata``` list, and is only; allowed if all preceding stages are active. .. include:: ../cbs_eqn.rst. * Energy Methods; The presence of a stage_wfn keyword is the indicator to incorporate; (and check for stage_basis and stage_scheme keywords) and compute; that stage in defining the CBS energy. The cbs() function requires, at a minimum, ``name='scf'`` and ``scf_basis``; keywords to be specified for reference-step only jobs and ``name`` and; ``corl_basis`` keywords for correlated jobs. The following energy methods have been set up for cbs(). .. hlist::; :columns: 5. * scf; * hf; * mp2; * mp2.5; * mp3; * mp4(sdq); * mp4; * mp\ *n*; * omp2; * omp2.5; * omp3; * olccd; * lccd; * lccsd; * cepa(0); * cepa(1); * cepa(3); * acpf; * aqcc; * qcisd; * cc2; * ccsd; * fno-ccsd; * bccd; * cc3; * qcisd(t); * ccsd(t); * fno-ccsd(t); * bccd(t); * cisd; * cisdt; * cisdtq; * ci\ *n*; * fci; * mrccsd; * mrccsd(t); * mrccsdt; * mrccsdt(q). :type name: str; :param name: ``'scf'`` || ``'ccsd'`` || etc. First argument, usually unlabeled. Indicates the computational method; for the correlation energy, unless only reference step to be performed,; in which case should be ``'scf'``. Overruled if stage_wfn key",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver_cbs.html:35185,energy,energy,35185,psi4manual/1.3.2/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver_cbs.html,1,['energy'],['energy']
Energy Efficiency,"RGY¶. CI ROOT n CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the requested configuration interaction level of theory and root; n (numbering starts at 1). CI STATE-AVERAGED TOTAL ENERGY¶. CI STATE-AVERAGED CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for state-averaged CI/CASSCF levels of theory. CI TOTAL ENERGY¶. CI CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the requested configuration interaction level of theory and root. CISD TOTAL ENERGY¶. CISD CORRELATION ENERGY¶. CISDT TOTAL ENERGY¶. CISDT CORRELATION ENERGY¶. CISDTQ CORRELATION ENERGY¶. CISDTQ TOTAL ENERGY¶. CIn CORRELATION ENERGY¶. CIn TOTAL ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the labeled configuration interaction level of theory and root.; n is CI order for n > 4. CP-CORRECTED 2-BODY INTERACTION ENERGY¶; The interaction energy [H] considering only two-body interactions,; computed with counterpoise correction.; Related variable UNCP-CORRECTED 2-BODY INTERACTION ENERGY. CURRENT CORRELATION ENERGY¶; The correlation energy [H] corresponding to the CURRENT ENERGY variable. CURRENT ENERGY¶; The total electronic energy [H] of the most recent stage of a; calculation (frequently overwritten). This is the quantity tracked by; the geometry optimizer. CURRENT REFERENCE ENERGY¶; The total electronic energy [H] of the reference stage corresponding to; the CURRENT ENERGY variable. db_name DATABASE MEAN ABSOLUTE DEVIATION¶; The mean absolute deviation [kcal mol-1] of the requested method; name from the stored reference values for the requested reactions in; database db_name. If no reference is available, this will be a large; and nonsensical value. db_name DATABASE MEAN SIGNED DEVIATION¶; The mean deviation [kcal mol-1] of the requested method name; from the stored reference values for the requested reactions in; database db_name. I",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/glossary_psivariables-1.html:4151,energy,energy,4151,psi4manual/4.0b2/glossary_psivariables-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/glossary_psivariables-1.html,2,['energy'],['energy']
Energy Efficiency,"RGY¶. LCCSD CORRELATION ENERGY¶; The total electronic energy [E_h] and correlation energy component [E_h]; for the linearized coupled cluster singles and doubles level of theory. LCC2 (+LMP2) TOTAL ENERGY¶; The total electronic energy [E_h] for the local CC2 level of theory. LCCSD (+LMP2) TOTAL ENERGY¶; The total electronic energy [E_h] for the local CCSD level of theory. LEFT-RIGHT CC2 EIGENVECTOR OVERLAP¶. LEFT-RIGHT CC3 EIGENVECTOR OVERLAP¶. LEFT-RIGHT CCSD EIGENVECTOR OVERLAP¶. LEFT-RIGHT CCSD(T) EIGENVECTOR OVERLAP¶; The overlap between the right-hand coupled coupled cluster eigenvector and the; left-hand eigenvector from the coupled cluster lambda (response) equations. LOWDIN CHARGES¶; Property of partial atomic charges [e] by the method of Löwdin, (nat,). MAYER INDICES¶; Property of Mayer bond indices, (nat, nat). MBIS CHARGES¶. MBIS DIPOLES¶. MBIS OCTUPOLES¶. MBIS QUADRUPOLES¶; Per-atom charges [e], dipoles [e a0], quadrupoles [e a0^2], and octupoles [e a0^3]; resulting from partitioning the total electron density through the Minimal Basis; Iterative Stockholder (MBIS) Charge Partitioning Scheme. MBIS FREE ATOM n VOLUME¶; Free-atom volume [a0^3] for atom n, computed using the MBIS charge; partitioning scheme. Free atom densities are computed at the same; level of theory as the parent MBIS calculation, with UHF turned on; as needed. MBIS RADIAL MOMENTS <R^3>¶; Per-atom expectation value of r^3 [a0^3], equivalent to the volume; of the MBIS-partitioned density. MBIS VALENCE CHARGES¶; Per-atom valence charges [e] computed from an MBIS partitioned density. MBIS VALENCE WIDTHS¶; Per-atom density width [a0] of the associated valence charge computed; from an MBIS partitioned density. Equivalent to the inverse of the; linear decay rate of the atomic density. MBIS VOLUME RATIOS¶; Per-atom ratio between the atomic volume (<R^3>) and the free-atomic; volume, unitless. MCSCF TOTAL ENERGY¶; Multiconfigurational self-consistent-field energy [E_h] in the course of; a config",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/glossary_psivariables.html:34188,charge,charges,34188,psi4manual/master/glossary_psivariables.html,https://psicode.org,https://psicode.org/psi4manual/master/glossary_psivariables.html,1,['charge'],['charges']
Energy Efficiency,"RGY¶. LCCSD CORRELATION ENERGY¶; The total electronic energy [E_h] and correlation energy component [E_h]; for the linearized coupled cluster singles and doubles level of theory. LCC2 (+LMP2) TOTAL ENERGY¶; The total electronic energy [E_h] for the local CC2 level of theory. LCCSD (+LMP2) TOTAL ENERGY¶; The total electronic energy [E_h] for the local CCSD level of theory. LEFT-RIGHT CC2 EIGENVECTOR OVERLAP¶. LEFT-RIGHT CC3 EIGENVECTOR OVERLAP¶. LEFT-RIGHT CCSD EIGENVECTOR OVERLAP¶. LEFT-RIGHT CCSD(T) EIGENVECTOR OVERLAP¶; The overlap between the right-hand coupled coupled cluster eigenvector and the; left-hand eigenvector from the coupled cluster lambda (response) equations. LOWDIN CHARGES¶; Property of partial atomic charges [e] by the method of Löwdin, (nat,). MAYER INDICES¶; Property of Mayer bond indices, (nat, nat). MBIS CHARGES¶. MBIS DIPOLES¶. MBIS OCTUPOLES¶. MBIS QUADRUPOLES¶; Per-atom charges [e], dipoles [e a0], quadrupoles [e a0^2], and octupoles [e a0^3]; resulting from partitioning the total electron density through the Minimal Basis; Iterative Stockholder (MBIS) Charge Partitioning Scheme. MBIS FREE ATOM n VOLUME¶; Free-atom volume [a0^3] for atom n, computed using the MBIS charge; partitioning scheme. Free atom densities are computed at the same; level of theory as the parent MBIS calculation, with UHF turned on; as needed. MBIS RADIAL MOMENTS <R^3>¶; Per-atom expectation value of r^3 [a0^3], equivalent to the volume; of the MBIS-partitioned density. MBIS VALENCE WIDTHS¶; Per-atom density width [a0] of the associated valence charge computed; from an MBIS partitioned density. Equivalent to the inverse of the; linear decay rate of the atomic density. MBIS VOLUME RATIOS¶; Per-atom ratio between the atomic volume (<R^3>) and the free-atomic; volume, unitless. MCSCF TOTAL ENERGY¶; Multiconfigurational self-consistent-field energy [E_h] in the course of; a configuration interaction computation. May be single-root or state-averaged. mtd DIPOLE¶; Dipole arra",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/glossary_psivariables.html:34179,charge,charges,34179,psi4manual/1.7.x/glossary_psivariables.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/glossary_psivariables.html,3,['charge'],['charges']
Energy Efficiency,"RGY¶. SAPT EXCH-IND20,R ENERGY¶. SAPT IND20,U ENERGY¶. SAPT EXCH-IND20,U ENERGY¶; An induction-classified SAPT term energy [E_h] implemented for SAPT0. SAPT DISP20 ENERGY¶. SAPT EXCH-DISP20 ENERGY¶; A dispersion-classified SAPT term energy [E_h] implemented for SAPT0. SAPT EXCH-DISP20(S^INF) ENERGY¶; A dispersion-classified SAPT term energy [E_h] implemented for SAPT0. See Higher-Order Exchange Terms without Single-Exchange Approximation. SAPT SAME-SPIN DISP20 ENERGY¶. SAPT SAME-SPIN EXCH-DISP20 ENERGY¶; The portion of SAPT DISP20 ENERGY or; SAPT EXCH-DISP20 ENERGY resulting from; from same-spin or triplet doubles correlations. SAPT HF(2) ENERGY ABC(HF)¶; The total Hartree–Fock energy [E_h] of the supersystem implemented for F/I-SAPT. SAPT HF(2) ENERGY AC(0)¶; The Hartree–Fock energy [E_h] of subsystems A and C implemented for F/I-SAPT. SAPT HF(2) ENERGY BC(0)¶; The Hartree–Fock energy [E_h] of subsystems B and C implemented for F/I-SAPT. SAPT HF(2) ENERGY A(0)¶; The Hartree–Fock energy [E_h] of subsystem A implemented for F/I-SAPT. SAPT HF(2) ENERGY B(0)¶; The Hartree–Fock energy [E_h] of subsystem B implemented for F/I-SAPT. SAPT HF(2) ENERGY AC(HF)¶; The Hartree–Fock localized energy [E_h] of subsystems A and C implemented for F/I-SAPT. SAPT HF(2) ENERGY BC(HF)¶; The Hartree–Fock localized energy [E_h] of subsystems B and C implemented for F/I-SAPT. SAPT HF(2) ENERGY AB(HF)¶; The Hartree–Fock localized energy [E_h] of subsystems A and B implemented for F/I-SAPT. SAPT HF(2) ENERGY A(HF)¶; The Hartree–Fock localized energy [E_h] of subsystem A implemented for F/I-SAPT. SAPT HF(2) ENERGY B(HF)¶; The Hartree–Fock localized energy [E_h] of subsystem B implemented for F/I-SAPT. SAPT HF(2) ENERGY C¶; The Hartree–Fock energy [E_h] of subsystem C implemented for F/I-SAPT. SAPT HF(2) ENERGY HF¶; The FI-SAPT Hartree–Fock interaction energy [E_h] implemented for F/I-SAPT. SAPT ELST12,R ENERGY¶; An electrostatics-classified SAPT term energy [E_h] implemented for SAPT2. SAPT E",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/glossary_psivariables.html:47063,energy,energy,47063,psi4manual/1.7.x/glossary_psivariables.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/glossary_psivariables.html,4,['energy'],['energy']
Energy Efficiency,"RGY¶. SAPT2+(3)(CCD)DMP2 TOTAL ENERGY¶. SAPT2+3(CCD)DMP2 TOTAL ENERGY¶; The total electronic interaction energy [H] for the labeled SAPT level; of theory that incorporates MP2 induction correction. SCF DIPOLE X¶. SCF DIPOLE Y¶. SCF DIPOLE Z¶; The three components of the SCF dipole [Debye]. SCF QUADRUPOLE XX¶. SCF QUADRUPOLE XY¶. SCF QUADRUPOLE XZ¶. SCF QUADRUPOLE YY¶. SCF QUADRUPOLE YZ¶. SCF QUADRUPOLE ZZ¶; The six components of the SCF quadrupole [Debye Ang]. SCF TOTAL ENERGY¶; The total electronic energy [H] of the SCF stage of the calculation.; The CORRELATION ENERGY variables from subsequent stages of a; calculation are often the corresponding TOTAL ENERGY; variables less this quantity. Constructed from Eq. (4),; where this quantity is \(E_{\text{SCF}}\). \begin{align*}; E_{\text{SCF}} & = E_{NN} + E_{1e^-} + E_{2e^-} + E_{xc} + E_{\text{-D}} \\; & = E_{\text{FCTL/HF}} + E_{\text{-D}}; \end{align*}Unless the method includes a dispersion correction, this quantity is; equal to HF TOTAL ENERGY (for HF) or; DFT FUNCTIONAL TOTAL ENERGY (for; DFT). Unless the method is a DFT double-hybrid, this quantity is equal; to DFT TOTAL ENERGY. TWO-ELECTRON ENERGY¶; The two-electron energy contribution [H] to the total SCF energy.; Quantity \(E_{2e^-}\) in Eq. (4). UNCP-CORRECTED 2-BODY INTERACTION ENERGY¶; The interaction energy [H] considering only two-body interactions,; computed without counterpoise correction.; Related variable CP-CORRECTED 2-BODY INTERACTION ENERGY. \[E_{\text{IE}} = E_{dimer} - \sum_{monomer}^{n}{E_{monomer}^{\text{unCP}}}\]. ZAPTn TOTAL ENERGY¶. ZAPTn CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the labeled Z-averaged perturbation theory level.; n is ZAPT perturbation order. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Appendices. © Copyright 2018, The Psi4 Project.; Last updated on Wednesday, 25 July 2018 04:21AM.; Created using Sphinx 1.7.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/glossary_psivariables-1.html:20129,energy,energy,20129,psi4manual/1.2.1/glossary_psivariables-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/glossary_psivariables-1.html,10,['energy'],['energy']
Energy Efficiency,"RGY¶; Respectively, the dispersion, electrostatics, exchange, and induction; components of the total electronic interaction energy [H] for the the; requested SAPT level of theory. The sum of these four components yields; SAPT TOTAL ENERGY. SAPT TOTAL ENERGY¶; The total electronic interaction energy [H] for the requested SAPT; level of theory. SAPT0 TOTAL ENERGY¶. SSAPT0 TOTAL ENERGY¶. SAPT2 TOTAL ENERGY¶. SAPT2+ TOTAL ENERGY¶. SAPT2+(3) TOTAL ENERGY¶. SAPT2+3 TOTAL ENERGY¶; The total electronic interaction energy [H] for the labeled SAPT level; of theory. SAPT2+(CCD) TOTAL ENERGY¶. SAPT2+(3)(CCD) TOTAL ENERGY¶. SAPT2+3(CCD) TOTAL ENERGY¶; The total electronic interaction energy [H] for the labeled SAPT level; of theory that incorporates coupled-cluster dispersion. SAPT2+DMP2 TOTAL ENERGY¶. SAPT2+(3)DMP2 TOTAL ENERGY¶. SAPT2+3DMP2 TOTAL ENERGY¶. SAPT2+(CCD)DMP2 TOTAL ENERGY¶. SAPT2+(3)(CCD)DMP2 TOTAL ENERGY¶. SAPT2+3(CCD)DMP2 TOTAL ENERGY¶; The total electronic interaction energy [H] for the labeled SAPT level; of theory that incorporates MP2 induction correction. SCF DIPOLE X¶. SCF DIPOLE Y¶. SCF DIPOLE Z¶; The three components of the SCF dipole [Debye]. SCF QUADRUPOLE XX¶. SCF QUADRUPOLE XY¶. SCF QUADRUPOLE XZ¶. SCF QUADRUPOLE YY¶. SCF QUADRUPOLE YZ¶. SCF QUADRUPOLE ZZ¶; The six components of the SCF quadrupole [Debye Ang]. SCF TOTAL ENERGY¶; The total electronic energy [H] of the SCF stage of the calculation.; The CORRELATION ENERGY variables from subsequent stages of a; calculation are often the corresponding TOTAL ENERGY; variables less this quantity. Constructed from Eq. (4),; where this quantity is . (4); Unless the method includes a dispersion correction, this quantity is; equal to HF TOTAL ENERGY (for HF) or; DFT FUNCTIONAL TOTAL ENERGY (for; DFT). Unless the method is a DFT double-hybrid, this quantity is equal; to DFT TOTAL ENERGY. TWO-ELECTRON ENERGY¶; The two-electron energy contribution [H] to the total SCF energy.; Quantity in Eq. (4). UNCP-CORRECTED 2",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/glossary_psivariables-1.html:15422,energy,energy,15422,psi4manual/1.0.0/glossary_psivariables-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/glossary_psivariables-1.html,2,['energy'],['energy']
Energy Efficiency,"RGY¶; Respectively, the dispersion, electrostatics, exchange, and induction; components of the total electronic interaction energy [H] for the the; requested SAPT level of theory. The sum of these four components yields; SAPT TOTAL ENERGY. SAPT TOTAL ENERGY¶; The total electronic interaction energy [H] for the requested SAPT; level of theory. SAPT0 TOTAL ENERGY¶. SSAPT0 TOTAL ENERGY¶. SAPT2 TOTAL ENERGY¶. SAPT2+ TOTAL ENERGY¶. SAPT2+(3) TOTAL ENERGY¶. SAPT2+3 TOTAL ENERGY¶; The total electronic interaction energy [H] for the labeled SAPT level; of theory. SAPT2+(CCD) TOTAL ENERGY¶. SAPT2+(3)(CCD) TOTAL ENERGY¶. SAPT2+3(CCD) TOTAL ENERGY¶; The total electronic interaction energy [H] for the labeled SAPT level; of theory that incorporates coupled-cluster dispersion. SAPT2+DMP2 TOTAL ENERGY¶. SAPT2+(3)DMP2 TOTAL ENERGY¶. SAPT2+3DMP2 TOTAL ENERGY¶. SAPT2+(CCD)DMP2 TOTAL ENERGY¶. SAPT2+(3)(CCD)DMP2 TOTAL ENERGY¶. SAPT2+3(CCD)DMP2 TOTAL ENERGY¶; The total electronic interaction energy [H] for the labeled SAPT level; of theory that incorporates MP2 induction correction. SCF DIPOLE X¶. SCF DIPOLE Y¶. SCF DIPOLE Z¶; The three components of the SCF dipole [Debye]. SCF QUADRUPOLE XX¶. SCF QUADRUPOLE XY¶. SCF QUADRUPOLE XZ¶. SCF QUADRUPOLE YY¶. SCF QUADRUPOLE YZ¶. SCF QUADRUPOLE ZZ¶; The six components of the SCF quadrupole [Debye Ang]. SCF TOTAL ENERGY¶; The total electronic energy [H] of the SCF stage of the calculation.; The CORRELATION ENERGY variables from subsequent stages of a; calculation are often the corresponding TOTAL ENERGY; variables less this quantity. Constructed from Eq. (4),; where this quantity is \(E_{\text{SCF}}\). \begin{align*}; E_{\text{SCF}} & = E_{NN} + E_{1e^-} + E_{2e^-} + E_{xc} + E_{\text{-D}} \\; & = E_{\text{FCTL/HF}} + E_{\text{-D}}; \end{align*}Unless the method includes a dispersion correction, this quantity is; equal to HF TOTAL ENERGY (for HF) or; DFT FUNCTIONAL TOTAL ENERGY (for; DFT). Unless the method is a DFT double-hybrid, this quantity",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/glossary_psivariables-1.html:16749,energy,energy,16749,psi4manual/1.1.0/glossary_psivariables-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/glossary_psivariables-1.html,6,['energy'],['energy']
Energy Efficiency,"RHF-CCSD-LR/cc-pVDZ static polarizability of HOF. dfomp2-1; OMP2 cc-pVDZ energy for the H2O molecule. cc35; CC3(ROHF)/cc-pVDZ H2O \(R_e\) geom from Olsen et al., JCP 104, 8007 (1996). fd-freq-energy-large; SCF DZ finite difference frequencies by energies for C4NH4. dfomp2-grad2; OMP2 cc-pVDZ energy for the NO molecule. cc1; RHF-CCSD 6-31G** all-electron optimization of the H2O molecule. psimrcc-sp1; Mk-MRCCSD single point. \(^3 \Sigma ^-\) O2 state described using the Ms = 0 component of the triplet. Uses ROHF triplet orbitals. castup2; SCF with various combinations of pk/density-fitting, castup/no-castup, and spherical/cartesian settings. Demonstrates that puream setting is getting set by orbital basis for all df/castup parts of calc. Demonstrates that answer doesn’t depend on presence/absence of castup. Demonstrates (by comparison to castup3) that output file doesn’t depend on options (scf_type) being set global or local. This input uses global. cc10; ROHF-CCSD cc-pVDZ energy for the \(^2\Sigma^+\) state of the CN radical. opt-freeze-coords; SCF/cc-pVDZ optimization example with frozen cartesian. cc27; Single point gradient of 1-1B2 state of H2O with EOM-CCSD. mpn-bh; MP(n)/aug-cc-pVDZ BH Energy Point, with n=2-19. Compare against M. L. Leininger et al., J. Chem. Phys. 112, 9213 (2000). cbs-delta-energy; Extrapolated energies with delta correction. omp2-5; SOS-OMP2 cc-pVDZ geometry optimization for the H2O molecule. scf-freq1; Analytic vs. finite difference DF-SCF frequency test for water. cc22; ROHF-EOM-CCSD/DZ on the lowest two states of each irrep in \(^{3}B_1\) CH2. cc14; ROHF-CCSD/cc-pVDZ \(^{3}B_1\) CH2 geometry optimization via analytic gradients. mp2-1; All-electron MP2 6-31G** geometry optimization of water. cepa1; cc-pvdz H2O Test CEPA(1) Energy. casscf-fzc-sp; CASSCF/6-31G** energy point. extern2; External potential calculation involving a TIP3P water and a QM water for DFMP2. Finite different test of the gradient is performed to validate forces. opt9; V",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/testsuite-1.html:15731,energy,energy,15731,psi4manual/1.1.0/testsuite-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/testsuite-1.html,4,['energy'],['energy']
Energy Efficiency,RIBUTION TO ENERGY | |em| 1 | when nocp in bsse_type & max_nbody>=2 | 2-body total data less (2-1)-body total data for partial IE; inputs are total energies w/o cp treatment |; +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+; | |em| NOCP-CORRECTED {nb}-BODY CONTRIBUTION TO ENERGY | |em| 1 | when nocp in bsse_type | {max_nbody}-body total data less ({max_nbody}-1)-body data for partial IE; inputs are total energies w/o cp treat. |; +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+; | | | | |; +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+; | |em| VMFC-CORRECTED TOTAL ENERGY THROUGH 1-BODY | |em| 1 | when vmfc in bsse_type | MBE sum of subsystems of 1-body. summed are total energies with vmfc treatment |; +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+; | |em| VMFC-CORRECTED TOTAL ENERGY THROUGH 2-BODY | |em| 1 | when vmfc in bsse_type & max_nbody>=2 | MBE sum of subsystems of 2-body or fewer (cumulative); summed are total energies with vmfc treatment |; +---------------------------------------------------------------+----------------------+---------------------------------------,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver_nbody.html:52655,ENERGY,ENERGY,52655,psi4manual/1.6.x/_modules/psi4/driver/driver_nbody.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver_nbody.html,5,['ENERGY'],['ENERGY']
Energy Efficiency,"ROOT 0 (IN h) -> ROOT n (IN i) ROTATORY STRENGTH (LEN)¶; The length-gauge oscillator strength of the transition from root m within irrep h; to root n within irrep i.; DFT functional labeled if canonical. CCname ROOT m (h) -> ROOT n (i) ROTATORY STRENGTH (LEN)¶. TD-fctl ROOT 0 (h) -> ROOT n (i) ROTATORY STRENGTH (LEN)¶; The length-gauge oscillator strength of the transition from root m to root n,; which are in irreps h and i, respectively..; DFT functional labeled if canonical. CCname ROOT m -> ROOT n ROTATORY STRENGTH (LEN) - h TRANSITION¶. TD-fctl ROOT 0 -> ROOT n ROTATORY STRENGTH (LEN) - h TRANSITION¶; The length-gauge oscillator strength of the transition from root m to root n,; and the transition is of irrep h.; DFT functional labeled if canonical. CC TOTAL ENERGY¶. CC CORRELATION ENERGY¶. CC CORRELATION KINETIC ENERGY¶; The correlation correction to the kinetic energy [E_h], as computed by a coupled cluster method. CC CORRELATION POTENTIAL ENERGY¶; The correlation correction to the potential energy [E_h], as computed by a coupled cluster method. CC CORRELATION VIRIAL RATIO¶; The correlation virial ratio, as defined in https://doi/org/10.1063/1.1535440 for basis set completeness analysis. Computed using coupled cluster. CC VIRIAL RATIO¶; The virial ratio, as computed by a coupled cluster method. Only defined for a fully quantum mechanical computation, i.e., not QM/MM or solvated. CC T1 DIAGNOSTIC¶. CC D1 DIAGNOSTIC¶. CC NEW D1 DIAGNOSTIC¶. CC D2 DIAGNOSTIC¶; Diagnostic of multireference character. CC2 TOTAL ENERGY¶. CC2 CORRELATION ENERGY¶. CC3 TOTAL ENERGY¶. CC3 CORRELATION ENERGY¶. CC4 TOTAL ENERGY¶. CC4 CORRELATION ENERGY¶. CCnn TOTAL ENERGY¶. CCnn CORRELATION ENERGY¶; The total electronic energy [E_h] and correlation energy component [E_h]; for the requested approximate coupled-cluster (CC2, CC3, up to CCnn); level of theory. CC DIPOLE¶; Dipole array [e a0] for the requested coupled cluster level of theory and root, (3,). CC2 DIPOLE POLARIZABILITY @ xNM¶. CC",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/glossary_psivariables.html:14048,energy,energy,14048,psi4manual/1.7.x/glossary_psivariables.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/glossary_psivariables.html,4,['energy'],['energy']
Energy Efficiency,"ROTATORY STRENGTH (VEL) - h TRANSITION¶. TD-fctl ROOT 0 -> ROOT n ROTATORY STRENGTH (VEL) - h TRANSITION¶; The velocity-gauge oscillator strength of the transition from root m to root n,; and the transition is of irrep h.; DFT functional labeled if canonical. ADC ROOT n TOTAL ENERGY - h TRANSITION¶; The total ADC energy of root n within irrep h. This variable is only defined for Psi’s; built-in ADC and will be removed for 1.7. ADC ROOT 0 -> ROOT n CORRELATION ENERGY - h TRANSITION¶; The correlation energy contribution to the excitation energy from the ground state to; root n within irrep h. This variable is only defined for Psi’s built-in ADC and will be removed for 1.7. AQCC DIPOLE¶; Dipole array [e a0] for the averaged quadratic coupled-cluster level of theory, (3,). AQCC QUADRUPOLE¶; Redundant quadrupole array [e a0^2] for the averaged quadratic coupled-cluster level of theory, (3, 3). AQCC TOTAL ENERGY¶. AQCC CORRELATION ENERGY¶; The total electronic energy [Eh] and correlation energy component [Eh]; for the averaged quadratic coupled-cluster level of theory. BRUECKNER CONVERGED¶; Value 1 (0) when the Brueckner orbitals have (have not) converged. CBS NUMBER¶. NBODY NUMBER¶. FINDIF NUMBER¶; Number of tasks [] the named procedure performs. These are immediate; tasks, so if procedures are nested, the total number of tasks is; the product. CBS TOTAL ENERGY¶. CBS CORRELATION ENERGY¶. CBS REFERENCE ENERGY¶; The total electronic energy [Eh] and its breakdown into reference total; energy [Eh] and correlation correction components [Eh] for the compound; method requested through cbs(). CCname ROOT n TOTAL ENERGY¶. TD-fctl ROOT n TOTAL ENERGY¶; The total electronic energy [Eh] for the requested theory and root n (n starts at 0).; DFT functional labeled if canonical. CCname ROOT n (IN h) TOTAL ENERGY¶. TD-fctl ROOT n (IN h) TOTAL ENERGY¶; The total electronic energy [Eh] for the requested theory and root n within irrep h (n starts at 0).; DFT functional labeled if canonical",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/glossary_psivariables.html:7861,energy,energy,7861,psi4manual/1.6.x/glossary_psivariables.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/glossary_psivariables.html,2,['energy'],['energy']
Energy Efficiency,ROUGH 2-BODY;   1; when nocp in bsse_type & max_nbody>=2; MBE sum of subsystems of 2-body or fewer (cumulative); summed are total energies without cp treatment.   NOCP-CORRECTED TOTAL ENERGY THROUGH {nb}-BODY;   1; when nocp in bsse_type; MBE sum of subsystems of {max_nbody}-body or fewer (cumulative); summed are total energies w/o cp treatment.   NOCP-CORRECTED TOTAL ENERGY;   1; when nocp in bsse_type; best available total energy without cp treatment: NOCP-CORRECTED TOTAL ENERGY THROUGH {max_nbody}-BODY.   NOCP-CORRECTED INTERACTION ENERGY THROUGH 2-BODY;   1; when nocp in bsse_type & max_nbody>=2; 2-body total data less 1-body total data for cumulative IE; inputs are total energies w/o cp treatment.   NOCP-CORRECTED INTERACTION ENERGY THROUGH {nb}-BODY;   1; when nocp in bsse_type; {max_nbody}-body total data less 1-body total data for cumulative IE; inputs are total energies w/o cp treatment.   NOCP-CORRECTED INTERACTION ENERGY;   1; when nocp in bsse_type; best available interaction energy without cp treatment: NOCP-CORRECTED INTERACTION ENERGY THROUGH {max_nbody}-BODY.   NOCP-CORRECTED 2-BODY CONTRIBUTION TO ENERGY;   1; when nocp in bsse_type & max_nbody>=2; 2-body total data less (2-1)-body total data for partial IE; inputs are total energies w/o cp treatment.   NOCP-CORRECTED {nb}-BODY CONTRIBUTION TO ENERGY;   1; when nocp in bsse_type; {max_nbody}-body total data less ({max_nbody}-1)-body data for partial IE; inputs are total energies w/o cp treat.   VMFC-CORRECTED TOTAL ENERGY THROUGH 1-BODY;   1; when vmfc in bsse_type; MBE sum of subsystems of 1-body. summed are total energies with vmfc treatment.   VMFC-CORRECTED TOTAL ENERGY THROUGH 2-BODY;   1; when vmfc in bsse_type & max_nbody>=2; MBE sum of subsystems of 2-body or fewer (cumulative); summed are total energies with vmfc treatment.   VMFC-CORRECTED TOTAL ENERGY THROUGH {nb}-BODY;   1; when vmfc in bsse_type; MBE sum of subsystems of {max_nbody}-body or fewer (cumulative); summed are total energies ,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/nbody.html:13368,energy,energy,13368,psi4manual/1.6.x/nbody.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/nbody.html,5,['energy'],['energy']
Energy Efficiency,ROUGH 2-BODY;   1; when vmfc in bsse_type & max_nbody>=2; MBE sum of subsystems of 2-body or fewer (cumulative); summed are total energies with vmfc treatment.   VMFC-CORRECTED TOTAL ENERGY THROUGH {nb}-BODY;   1; when vmfc in bsse_type; MBE sum of subsystems of {max_nbody}-body or fewer (cumulative); summed are total energies w/ vmfc treatment.   VMFC-CORRECTED TOTAL ENERGY;   1; when vmfc in bsse_type; best available total energy with vmfc treatment: VMFC-CORRECTED TOTAL ENERGY THROUGH {max_nbody}-BODY.   VMFC-CORRECTED INTERACTION ENERGY THROUGH 2-BODY;   1; when vmfc in bsse_type & max_nbody>=2; 2-body total data less 1-body total data for cumulative IE; inputs are total energies w/ vmfc treatment.   VMFC-CORRECTED INTERACTION ENERGY THROUGH {nb}-BODY;   1; when vmfc in bsse_type; {max_nbody}-body total data less 1-body total data for cumulative IE; inputs are total energies w/ vmfc treatment.   VMFC-CORRECTED INTERACTION ENERGY;   1; when vmfc in bsse_type; best available interaction energy with vmfc treatment: VMFC-CORRECTED INTERACTION ENERGY THROUGH {max_nbody}-BODY.   VMFC-CORRECTED 2-BODY CONTRIBUTION TO ENERGY;   1; when vmfc in bsse_type & max_nbody>=2; 2-body total data less (2-1)-body total data for partial IE; inputs are total energies w/ vmfc treatment.   VMFC-CORRECTED {nb}-BODY CONTRIBUTION TO ENERGY;   1; when vmfc in bsse_type; {max_nbody}-body total data less ({max_nbody}-1)-body data for partial IE; inputs are total energies w/ vmfc treat. energy_body_dict; max_nbody; always; total energies at each n-body level.   1;   1; always; zeroed if cp & rtd=F; cumulative through 1-body total energies w/ cp/nocp/vmfc treatment (dep. on 1st of bsse_type).   2;   1; max_nbody>=2; cumulative through 2-body total energies w/ cp/nocp/vmfc treatment (dep. on 1st of bsse_type).   {max_nbody};   1; always; cumulative through {max_nbody}-body total energies w/ cp/nocp/vmfc treatment (dep. on 1st of bsse_type). gradient_body_dict; max_nbody; when driver is g/h.   1,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/nbody.html:15040,energy,energy,15040,psi4manual/1.6.x/nbody.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/nbody.html,5,['energy'],['energy']
Energy Efficiency,"RRECTED TOTAL ENERGY""] = cp_body_dict[metadata['max_nbody']]; nbody_dict[""CP-CORRECTED INTERACTION ENERGY""] = cp_body_dict[metadata['max_nbody']] - cp_body_dict[1]. for nb in nbodies[1:]:; nbody_dict[f""CP-CORRECTED INTERACTION ENERGY THROUGH {nb}-BODY""] = cp_body_dict[nb] - cp_body_dict[1]; nbody_dict[f""CP-CORRECTED {nb}-BODY CONTRIBUTION TO ENERGY""] = cp_body_dict[nb] - cp_body_dict[nb-1]; for nb in nbodies:; nbody_dict[f""CP-CORRECTED TOTAL ENERGY THROUGH {nb}-BODY""] = cp_body_dict[nb]. # Compute nocp; if 'nocp' in metadata['bsse_type']:; for nb in range(1, nbodies[-1] + 1):; if nb == metadata['nfragments']:; if ptype == ""energy"":; nocp_body_dict[nb] = nocp_by_level[nb]; else:; nocp_body_dict[nb][:] = nocp_by_level[nb]; continue. for k in range(1, nb + 1):; take_nk = math.comb(metadata['nfragments'] - k - 1, nb - k); sign = ((-1)**(nb - k)); nocp_body_dict[nb] += take_nk * sign * nocp_by_level[k]. if ptype == ""energy"":; if not metadata[""quiet""]:; _print_nbody_energy(nocp_body_dict, ""Non-Counterpoise Corrected (NoCP)"", metadata[""nfragments""], metadata['embedding_charges']). nbody_dict['NOCP-CORRECTED TOTAL ENERGY'] = nocp_body_dict[metadata['max_nbody']]; nbody_dict['NOCP-CORRECTED INTERACTION ENERGY'] = nocp_body_dict[metadata['max_nbody']] - nocp_body_dict[1]. for nb in nbodies[1:]:; nbody_dict[f""NOCP-CORRECTED INTERACTION ENERGY THROUGH {nb}-BODY""] = nocp_body_dict[nb] - nocp_body_dict[1]; nbody_dict[f""NOCP-CORRECTED {nb}-BODY CONTRIBUTION TO ENERGY""] = nocp_body_dict[nb] - nocp_body_dict[nb-1]; for nb in nbodies:; nbody_dict[f""NOCP-CORRECTED TOTAL ENERGY THROUGH {nb}-BODY""] = nocp_body_dict[nb]. # Compute vmfc; if 'vmfc' in metadata['bsse_type']:; for nb in nbodies:; if ptype == ""energy"":; for k in range(1, nb + 1):; vmfc_body_dict[nb] += vmfc_by_level[k]. else:; if nb > 1:; vmfc_body_dict[nb] = vmfc_by_level[nb - 1]; vmfc_body_dict[nb] += vmfc_by_level[nb]. if ptype == ""energy"":; if not metadata[""quiet""]:; _print_nbody_energy(vmfc_body_dict, ""Valiron-Mayer Funct",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver_nbody.html:28081,energy,energy,28081,psi4manual/1.6.x/_modules/psi4/driver/driver_nbody.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver_nbody.html,10,['energy'],['energy']
Energy Efficiency,"RRELATION ENERGY <MP2.5CORRELATIONENERGY>`; #; # >>> energy('mp2.5'); #; # """"""; # lowername = name.lower(); # kwargs = kwargs_lower(kwargs); #; # # Run detci calculation and collect conventional quantities; # energy('mp3', **kwargs); # e_scf = psi4.get_variable('SCF TOTAL ENERGY'); # ce_mp2 = psi4.get_variable('MP2 CORRELATION ENERGY'); # ce_mp3 = psi4.get_variable('MP3 CORRELATION ENERGY'); # e_mp2 = e_scf + ce_mp2; # e_mp3 = e_scf + ce_mp3; #; # # Compute quantities particular to MP2.5; # ce_mp25 = 0.5 * (ce_mp2 + ce_mp3); # e_mp25 = e_scf + ce_mp25; # psi4.set_variable('MP2.5 CORRELATION ENERGY', ce_mp25); # psi4.set_variable('MP2.5 TOTAL ENERGY', e_mp25); # psi4.set_variable('CURRENT CORRELATION ENERGY', ce_mp25); # psi4.set_variable('CURRENT ENERGY', e_mp25); #; # # build string of title banner and print results; # banners = ''; # banners += """"""psi4.print_out('\\n')\n""""""; # banners += """"""banner(' MP2.5 ')\n""""""; # banners += """"""psi4.print_out('\\n')\n\n""""""; # exec(banners); #; # tables = ''; # tables += """""" SCF total energy: %16.8f\n"""""" % (e_scf); # tables += """""" MP2 total energy: %16.8f\n"""""" % (e_mp2); # tables += """""" MP2.5 total energy: %16.8f\n"""""" % (e_mp25); # tables += """""" MP3 total energy: %16.8f\n\n"""""" % (e_mp3); # tables += """""" MP2 correlation energy: %16.8f\n"""""" % (ce_mp2); # tables += """""" MP2.5 correlation energy: %16.8f\n"""""" % (ce_mp25); # tables += """""" MP3 correlation energy: %16.8f\n"""""" % (ce_mp3); # psi4.print_out(tables); #; # return e_mp25. # A direct translation of a plugin input file into a function call. Function calls are the only; # way to call plugins in sow/reap mode for db(), opt(), etc. This isn't best practices; # but is an example of what to do for a more complicated procedure where different options; # are set for different qc steps.; #def run_plugin_omega(name, **kwargs):; # r""""""Function encoding sequence of PSI module and plugin calls, as well; # as typical options, to access Rob Parrish's omega plugin.; #; # >>> energy('plugin_omeg",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/aliases.html:7744,energy,energy,7744,psi4manual/4.0b5/_modules/aliases.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/aliases.html,2,['energy'],['energy']
Energy Efficiency,"RRELATION ENERGY', dfmp2_wfn.variable('MP2 CORRELATION ENERGY')); for k, v in dfmp2_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); core.tstop(); return dfmp2_wfn. def run_dfmp2d_gradient(name, **kwargs):; """"""Encode MP2-D method."""""". dfmp2_wfn = run_dfmp2_gradient('mp2', **kwargs); wfn_grad = dfmp2_wfn.gradient().clone(). _, _disp_functor = build_functional_and_disp('MP2D', restricted=True); disp_grad = _disp_functor.compute_gradient(dfmp2_wfn.molecule(), dfmp2_wfn); wfn_grad.add(disp_grad); dfmp2_wfn.set_gradient(wfn_grad). dfmp2_wfn.set_variable('MP2D CORRELATION ENERGY', dfmp2_wfn.variable('MP2 CORRELATION ENERGY') + dfmp2_wfn.variable('DISPERSION CORRECTION ENERGY')); dfmp2_wfn.set_variable('MP2D TOTAL ENERGY', dfmp2_wfn.variable('MP2D CORRELATION ENERGY') + dfmp2_wfn.variable('HF TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('MP2D TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('MP2D CORRELATION ENERGY')). # Shove variables into global space; for k, v in dfmp2_wfn.variables().items():; core.set_variable(k, v). return dfmp2_wfn. def run_ccenergy(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a CCSD, CC2, and CC3 calculation. """"""; optstash = p4util.OptionsState(; ['TRANSQT2', 'WFN'],; ['CCSORT', 'WFN'],; ['CCENERGY', 'WFN']). if name == 'ccsd':; core.set_local_option('TRANSQT2', 'WFN', 'CCSD'); core.set_local_option('CCSORT', 'WFN', 'CCSD'); core.set_local_option('CCTRANSORT', 'WFN', 'CCSD'); core.set_local_option('CCENERGY', 'WFN', 'CCSD'); elif name == 'ccsd(t)':; core.set_local_option('TRANSQT2', 'WFN', 'CCSD_T'); core.set_local_option('CCSORT', 'WFN', 'CCSD_T'); core.set_local_option('CCTRANSORT', 'WFN', 'CCSD_T'); core.set_local_option('CCENERGY', 'WFN', 'CCSD_T'); elif name == 'a-ccsd(t)':; core.set_local_option('TRANSQT2', 'WFN', 'CCSD_AT'); core.set_local_option('CCSORT', 'WFN', 'CCSD_AT'); core.set_local_option('CCTRANSORT', 'WFN', 'CCS",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:89823,ENERGY,ENERGY,89823,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,3,['ENERGY'],['ENERGY']
Energy Efficiency,"RRELATION ENERGY', ene - vscf); except ValueError:; continue. # The last 'ene' in iface is the one the user requested.; ref_wfn.set_variable('CURRENT ENERGY', ene); ref_wfn.set_variable('CURRENT CORRELATION ENERGY', ene - vscf). for subm in [""MP2"", ""CCSD""]:; if ref_wfn.has_variable(f""{subm} TOTAL ENERGY"") and core.get_option(""SCF"", ""REFERENCE"") in [""RHF"", ""UHF""]:; ref_wfn.set_variable(f""{subm} SINGLES ENERGY"", 0.0); ref_wfn.set_variable(f""{subm} DOUBLES ENERGY"", ref_wfn.variable(f""{subm} CORRELATION ENERGY"")). if ref_wfn.has_variable(""CCSD(T) CORRELATION ENERGY"") and ref_wfn.has_variable(""CCSD CORRELATION ENERGY""):; ref_wfn.set_variable(""(T) CORRECTION ENERGY"", ref_wfn.variable(""CCSD(T) CORRELATION ENERGY"") - ref_wfn.variable(""CCSD CORRELATION ENERGY"")). if ref_wfn.has_variable(""A-CCSD(T) CORRELATION ENERGY"") and ref_wfn.has_variable(""CCSD CORRELATION ENERGY""):; ref_wfn.set_variable(""A-(T) CORRECTION ENERGY"", ref_wfn.variable(""A-CCSD(T) CORRELATION ENERGY"") - ref_wfn.variable(""CCSD CORRELATION ENERGY"")). # Load the iface file; iface = open('iface', 'r'); iface_contents = iface.read(). # Delete mrcc tempdir; os.chdir('..'); try:; # Delete unless we're told not to; if (keep is False and not('path' in kwargs)):; shutil.rmtree(mrcc_tmpdir); except OSError as e:; print('Unable to remove MRCC temporary directory %s' % e, file=sys.stderr); exit(1). # Return to submission directory; os.chdir(current_directory). # If we're told to keep the files or the user provided a path, do nothing.; if keep or ('path' in kwargs):; core.print_out('\nMRCC scratch files have been kept.\n'); core.print_out('They can be found in ' + mrcc_tmpdir). # Dump iface contents to output; core.print_out('\n'); p4util.banner('Full results from MRCC'); core.print_out('\n'); core.print_out(iface_contents). # Shove variables into global space; for k, v in ref_wfn.variables().items():; core.set_variable(k, v). core.print_variables(); return ref_wfn. def run_fnodfcc(name, **kwargs):; """"""Function encoding sequ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:165528,ENERGY,ENERGY,165528,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,4,['ENERGY'],['ENERGY']
Energy Efficiency,"RRELATION ENERGY'], 10,; label + '. MP2 correlation energy'). compare_integers(True, (pass_1el and pass_2el and pass_scf and pass_mp2), label). [docs]def energies_from_fcidump(intdump) -> Dict[str, float]:; """"""From integrals dictionary generated from :py:func:`fcidump_from_file`,; compute energies. :returns: a dictionary with energies. - 'NUCLEAR REPULSION ENERGY'; - 'ONE-ELECTRON ENERGY'; - 'TWO-ELECTRON ENERGY'; - 'SCF TOTAL ENERGY'; - 'MP2 CORRELATION ENERGY'. """"""; energies = {}; energies['NUCLEAR REPULSION ENERGY'] = intdump['enuc']; epsilon = intdump['epsilon']; Hcore = intdump['hcore']; eri = intdump['eri']. # Compute SCF energy; energies['ONE-ELECTRON ENERGY'], energies['TWO-ELECTRON ENERGY'] = _scf_energy(Hcore, eri,; np.where(epsilon < 0)[0],; intdump['uhf']); # yapf: disable; energies['SCF TOTAL ENERGY'] = energies['ONE-ELECTRON ENERGY'] + energies['TWO-ELECTRON ENERGY'] + energies['NUCLEAR REPULSION ENERGY']; # yapf: enable. # Compute MP2 energy; energies['MP2 CORRELATION ENERGY'] = _mp2_energy(eri, epsilon, intdump['uhf']). return energies. def _scf_energy(Hcore, ERI, occ_sl, unrestricted):; scf_1el_e = np.einsum('ii->', Hcore[np.ix_(occ_sl, occ_sl)]); if not unrestricted:; scf_1el_e *= 2; coulomb = np.einsum('iijj->', ERI[np.ix_(occ_sl, occ_sl, occ_sl, occ_sl)]); exchange = np.einsum('ijij->', ERI[np.ix_(occ_sl, occ_sl, occ_sl, occ_sl)]); if unrestricted:; scf_2el_e = 0.5 * (coulomb - exchange); else:; scf_2el_e = 2.0 * coulomb - exchange. return scf_1el_e, scf_2el_e. def _mp2_energy(ERI, epsilon, unrestricted):; # Occupied and virtual slices; occ_sl = np.where(epsilon < 0)[0]; vir_sl = np.where(epsilon > 0)[0]; eocc = epsilon[occ_sl]; evir = epsilon[vir_sl]; denom = 1 / (eocc.reshape(-1, 1, 1, 1) - evir.reshape(-1, 1, 1) + eocc.reshape(-1, 1) - evir); MO = ERI[np.ix_(occ_sl, vir_sl, occ_sl, vir_sl)]; if unrestricted:; mp2_e = 0.5 * np.einsum(""abrs,abrs,abrs->"", MO, MO - MO.swapaxes(1, 3), denom); else:; mp2_e = np.einsum('iajb,iajb,iajb->', MO, MO, den",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/fcidump.html:14775,energy,energy,14775,psi4manual/1.7.x/_modules/psi4/driver/p4util/fcidump.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/fcidump.html,3,"['ENERGY', 'energy']","['ENERGY', 'energy']"
Energy Efficiency,RRELATION ENERGY; ACPF SINGLES ENERGY; ACPF TOTAL ENERGY; AQCC CORRELATION ENERGY; AQCC DOUBLES ENERGY; AQCC OPPOSITE-SPIN CORRELATION ENERGY; AQCC SAME-SPIN CORRELATION ENERGY; AQCC SINGLES ENERGY; AQCC TOTAL ENERGY; CC ALPHA-ALPHA PAIR ENERGIES (array); CC ALPHA-BETA PAIR ENERGIES (array); CC D1 DIAGNOSTIC; CC SINGLET PAIR ENERGIES (array); CC T1 DIAGNOSTIC; CC TRIPLET PAIR ENERGIES (array); CCSD ALPHA-ALPHA PAIR ENERGIES (array); CCSD ALPHA-BETA PAIR ENERGIES (array); CCSD CORRELATION ENERGY; CCSD DOUBLES ENERGY; CCSD ITERATIONS; CCSD OPPOSITE-SPIN CORRELATION ENERGY; CCSD SAME-SPIN CORRELATION ENERGY; CCSD SINGLES ENERGY; CCSD SINGLET PAIR ENERGIES (array); CCSD TOTAL ENERGY; CCSD TRIPLET PAIR ENERGIES (array); CCSD(T) CORRELATION ENERGY; CCSD(T) TOTAL ENERGY; CEPA(0) CORRELATION ENERGY; CEPA(0) DOUBLES ENERGY; CEPA(0) OPPOSITE-SPIN CORRELATION ENERGY; CEPA(0) SAME-SPIN CORRELATION ENERGY; CEPA(0) SINGLES ENERGY; CEPA(0) TOTAL ENERGY; CEPA(1) CORRELATION ENERGY; CEPA(1) DOUBLES ENERGY; CEPA(1) OPPOSITE-SPIN CORRELATION ENERGY; CEPA(1) SAME-SPIN CORRELATION ENERGY; CEPA(1) SINGLES ENERGY; CEPA(1) TOTAL ENERGY; CEPA(2) CORRELATION ENERGY; CEPA(2) DOUBLES ENERGY; CEPA(2) OPPOSITE-SPIN CORRELATION ENERGY; CEPA(2) SAME-SPIN CORRELATION ENERGY; CEPA(2) SINGLES ENERGY; CEPA(2) TOTAL ENERGY; CEPA(3) CORRELATION ENERGY; CEPA(3) DOUBLES ENERGY; CEPA(3) OPPOSITE-SPIN CORRELATION ENERGY; CEPA(3) SAME-SPIN CORRELATION ENERGY; CEPA(3) SINGLES ENERGY; CEPA(3) TOTAL ENERGY; CISD CORRELATION ENERGY; CISD OPPOSITE-SPIN CORRELATION ENERGY; CISD SAME-SPIN CORRELATION ENERGY; CISD TOTAL ENERGY; CURRENT CORRELATION ENERGY; CURRENT ENERGY; LCCD CORRELATION ENERGY; LCCD DOUBLES ENERGY; LCCD OPPOSITE-SPIN CORRELATION ENERGY; LCCD SAME-SPIN CORRELATION ENERGY; LCCD SINGLES ENERGY; LCCD TOTAL ENERGY; LCCSD CORRELATION ENERGY; LCCSD DOUBLES ENERGY; LCCSD OPPOSITE-SPIN CORRELATION ENERGY; LCCSD SAME-SPIN CORRELATION ENERGY; LCCSD SINGLES ENERGY; LCCSD TOTAL ENERGY; MP2 ALPHA-ALPHA PAIR ENERG,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/autodir_psivariables/module__fnocc.html:1252,ENERGY,ENERGY,1252,psi4manual/1.7.x/autodir_psivariables/module__fnocc.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/autodir_psivariables/module__fnocc.html,4,['ENERGY'],['ENERGY']
Energy Efficiency,RRELATION ENERGY; LCCD DOUBLES ENERGY; LCCD OPPOSITE-SPIN CORRELATION ENERGY; LCCD SAME-SPIN CORRELATION ENERGY; LCCD SINGLES ENERGY; LCCD TOTAL ENERGY; MP2 CORRELATION ENERGY; MP2 DOUBLES ENERGY; MP2 OPPOSITE-SPIN CORRELATION ENERGY; MP2 SAME-SPIN CORRELATION ENERGY; MP2 SINGLES ENERGY; MP2 TOTAL ENERGY; MP2.5 CORRELATION ENERGY; MP2.5 DOUBLES ENERGY; MP2.5 OPPOSITE-SPIN CORRELATION ENERGY; MP2.5 SAME-SPIN CORRELATION ENERGY; MP2.5 SINGLES ENERGY; MP2.5 TOTAL ENERGY; MP3 CORRELATION ENERGY; MP3 DOUBLES ENERGY; MP3 OPPOSITE-SPIN CORRELATION ENERGY; MP3 SAME-SPIN CORRELATION ENERGY; MP3 SINGLES ENERGY; MP3 TOTAL ENERGY; NAUX (SCF); OLCCD CORRELATION ENERGY; OLCCD OPPOSITE-SPIN CORRELATION ENERGY; OLCCD REFERENCE CORRECTION ENERGY; OLCCD SAME-SPIN CORRELATION ENERGY; OLCCD TOTAL ENERGY; OMP2 CORRELATION ENERGY; OMP2 OPPOSITE-SPIN CORRELATION ENERGY; OMP2 REFERENCE CORRECTION ENERGY; OMP2 SAME-SPIN CORRELATION ENERGY; OMP2 TOTAL ENERGY; OMP2.5 CORRELATION ENERGY; OMP2.5 OPPOSITE-SPIN CORRELATION ENERGY; OMP2.5 REFERENCE CORRECTION ENERGY; OMP2.5 SAME-SPIN CORRELATION ENERGY; OMP2.5 TOTAL ENERGY; OMP3 CORRELATION ENERGY; OMP3 OPPOSITE-SPIN CORRELATION ENERGY; OMP3 REFERENCE CORRECTION ENERGY; OMP3 SAME-SPIN CORRELATION ENERGY; OMP3 TOTAL ENERGY; OREMP2 CORRELATION ENERGY; OREMP2 REFERENCE CORRECTION ENERGY; OREMP2 TOTAL ENERGY; REMP2 CORRELATION ENERGY; REMP2 DOUBLES ENERGY; REMP2 OPPOSITE-SPIN CORRELATION ENERGY; REMP2 SAME-SPIN CORRELATION ENERGY; REMP2 SINGLES ENERGY; REMP2 TOTAL ENERGY; SCF TOTAL ENERGY; SCS(N)-MP2 CORRELATION ENERGY; SCS(N)-MP2 TOTAL ENERGY; SCS(N)-OMP2 CORRELATION ENERGY; SCS(N)-OMP2 TOTAL ENERGY; SCS-MP2 CORRELATION ENERGY; SCS-MP2 TOTAL ENERGY; SCS-OMP2 CORRELATION ENERGY; SCS-OMP2 TOTAL ENERGY; SOS-MP2 CORRELATION ENERGY; SOS-MP2 TOTAL ENERGY; SOS-OMP2 CORRELATION ENERGY; SOS-OMP2 TOTAL ENERGY. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; PSI Variables by Module; DFOCC,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/autodir_psivariables/module__dfocc.html:1645,ENERGY,ENERGY,1645,psi4manual/master/autodir_psivariables/module__dfocc.html,https://psicode.org,https://psicode.org/psi4manual/master/autodir_psivariables/module__dfocc.html,1,['ENERGY'],['ENERGY']
Energy Efficiency,RRELATION ENERGY; LCCD DOUBLES ENERGY; LCCD OPPOSITE-SPIN CORRELATION ENERGY; LCCD SAME-SPIN CORRELATION ENERGY; LCCD SINGLES ENERGY; LCCD TOTAL ENERGY; MP2 CORRELATION ENERGY; MP2 DOUBLES ENERGY; MP2 OPPOSITE-SPIN CORRELATION ENERGY; MP2 SAME-SPIN CORRELATION ENERGY; MP2 SINGLES ENERGY; MP2 TOTAL ENERGY; MP2.5 CORRELATION ENERGY; MP2.5 DOUBLES ENERGY; MP2.5 OPPOSITE-SPIN CORRELATION ENERGY; MP2.5 SAME-SPIN CORRELATION ENERGY; MP2.5 SINGLES ENERGY; MP2.5 TOTAL ENERGY; MP3 CORRELATION ENERGY; MP3 DOUBLES ENERGY; MP3 OPPOSITE-SPIN CORRELATION ENERGY; MP3 SAME-SPIN CORRELATION ENERGY; MP3 SINGLES ENERGY; MP3 TOTAL ENERGY; NAUX (SCF); OLCCD CORRELATION ENERGY; OLCCD OPPOSITE-SPIN CORRELATION ENERGY; OLCCD REFERENCE CORRECTION ENERGY; OLCCD SAME-SPIN CORRELATION ENERGY; OLCCD TOTAL ENERGY; OMP2 CORRELATION ENERGY; OMP2 OPPOSITE-SPIN CORRELATION ENERGY; OMP2 REFERENCE CORRECTION ENERGY; OMP2 SAME-SPIN CORRELATION ENERGY; OMP2 TOTAL ENERGY; OMP2.5 CORRELATION ENERGY; OMP2.5 OPPOSITE-SPIN CORRELATION ENERGY; OMP2.5 REFERENCE CORRECTION ENERGY; OMP2.5 SAME-SPIN CORRELATION ENERGY; OMP2.5 TOTAL ENERGY; OMP3 CORRELATION ENERGY; OMP3 OPPOSITE-SPIN CORRELATION ENERGY; OMP3 REFERENCE CORRECTION ENERGY; OMP3 SAME-SPIN CORRELATION ENERGY; OMP3 TOTAL ENERGY; OREMP2 CORRELATION ENERGY; OREMP2 REFERENCE CORRECTION ENERGY; OREMP2 TOTAL ENERGY; REMP2 CORRELATION ENERGY; REMP2 DOUBLES ENERGY; REMP2 OPPOSITE-SPIN CORRELATION ENERGY; REMP2 SAME-SPIN CORRELATION ENERGY; REMP2 SINGLES ENERGY; REMP2 TOTAL ENERGY; SCF TOTAL ENERGY; SCS(N)-MP2 CORRELATION ENERGY; SCS(N)-MP2 TOTAL ENERGY; SCS(N)-OMP2 CORRELATION ENERGY; SCS(N)-OMP2 TOTAL ENERGY; SCS-MP2 CORRELATION ENERGY; SCS-MP2 TOTAL ENERGY; SCS-OMP2 CORRELATION ENERGY; SCS-OMP2 TOTAL ENERGY; SOS-MP2 CORRELATION ENERGY; SOS-MP2 TOTAL ENERGY; SOS-OMP2 CORRELATION ENERGY; SOS-OMP2 TOTAL ENERGY. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.7;  · . PSI4. Appendices; PSI Variables by Module; DFOCC. © Copyr,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/autodir_psivariables/module__dfocc.html:1636,ENERGY,ENERGY,1636,psi4manual/1.7.x/autodir_psivariables/module__dfocc.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/autodir_psivariables/module__dfocc.html,1,['ENERGY'],['ENERGY']
Energy Efficiency,RRELATION ENERGY; LCCD DOUBLES ENERGY; LCCD OPPOSITE-SPIN CORRELATION ENERGY; LCCD SAME-SPIN CORRELATION ENERGY; LCCD SINGLES ENERGY; LCCD TOTAL ENERGY; MP2 CORRELATION ENERGY; MP2 DOUBLES ENERGY; MP2 OPPOSITE-SPIN CORRELATION ENERGY; MP2 SAME-SPIN CORRELATION ENERGY; MP2 SINGLES ENERGY; MP2 TOTAL ENERGY; MP2.5 CORRELATION ENERGY; MP2.5 DOUBLES ENERGY; MP2.5 OPPOSITE-SPIN CORRELATION ENERGY; MP2.5 SAME-SPIN CORRELATION ENERGY; MP2.5 SINGLES ENERGY; MP2.5 TOTAL ENERGY; MP3 CORRELATION ENERGY; MP3 DOUBLES ENERGY; MP3 OPPOSITE-SPIN CORRELATION ENERGY; MP3 SAME-SPIN CORRELATION ENERGY; MP3 SINGLES ENERGY; MP3 TOTAL ENERGY; NAUX (SCF); OLCCD CORRELATION ENERGY; OLCCD OPPOSITE-SPIN CORRELATION ENERGY; OLCCD REFERENCE CORRECTION ENERGY; OLCCD SAME-SPIN CORRELATION ENERGY; OLCCD TOTAL ENERGY; OMP2 CORRELATION ENERGY; OMP2 OPPOSITE-SPIN CORRELATION ENERGY; OMP2 REFERENCE CORRECTION ENERGY; OMP2 SAME-SPIN CORRELATION ENERGY; OMP2 TOTAL ENERGY; OMP2.5 CORRELATION ENERGY; OMP2.5 OPPOSITE-SPIN CORRELATION ENERGY; OMP2.5 REFERENCE CORRECTION ENERGY; OMP2.5 SAME-SPIN CORRELATION ENERGY; OMP2.5 TOTAL ENERGY; OMP3 CORRELATION ENERGY; OMP3 OPPOSITE-SPIN CORRELATION ENERGY; OMP3 REFERENCE CORRECTION ENERGY; OMP3 SAME-SPIN CORRELATION ENERGY; OMP3 TOTAL ENERGY; OREMP2 CORRELATION ENERGY; OREMP2 REFERENCE CORRECTION ENERGY; OREMP2 TOTAL ENERGY; REMP2 CORRELATION ENERGY; REMP2 DOUBLES ENERGY; REMP2 OPPOSITE-SPIN CORRELATION ENERGY; REMP2 SAME-SPIN CORRELATION ENERGY; REMP2 SINGLES ENERGY; REMP2 TOTAL ENERGY; SCF TOTAL ENERGY; SCS(N)-MP2 CORRELATION ENERGY; SCS(N)-MP2 TOTAL ENERGY; SCS(N)-OMP2 CORRELATION ENERGY; SCS(N)-OMP2 TOTAL ENERGY; SCS-MP2 CORRELATION ENERGY; SCS-MP2 TOTAL ENERGY; SCS-OMP2 CORRELATION ENERGY; SCS-OMP2 TOTAL ENERGY; SOS-MP2 CORRELATION ENERGY; SOS-MP2 TOTAL ENERGY; SOS-OMP2 CORRELATION ENERGY; SOS-OMP2 TOTAL ENERGY. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. Appendices; PSI Variables by Module; DFOCC. © Cop,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/autodir_psivariables/module__dfocc.html:1638,ENERGY,ENERGY,1638,psi4manual/1.8.x/autodir_psivariables/module__dfocc.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/autodir_psivariables/module__dfocc.html,1,['ENERGY'],['ENERGY']
Energy Efficiency,RRELATION ENERGY; LCCD DOUBLES ENERGY; LCCD OPPOSITE-SPIN CORRELATION ENERGY; LCCD SAME-SPIN CORRELATION ENERGY; LCCD SINGLES ENERGY; LCCD TOTAL ENERGY; MP2 CORRELATION ENERGY; MP2 DOUBLES ENERGY; MP2 OPPOSITE-SPIN CORRELATION ENERGY; MP2 SAME-SPIN CORRELATION ENERGY; MP2 SINGLES ENERGY; MP2 TOTAL ENERGY; MP2.5 CORRELATION ENERGY; MP2.5 DOUBLES ENERGY; MP2.5 OPPOSITE-SPIN CORRELATION ENERGY; MP2.5 SAME-SPIN CORRELATION ENERGY; MP2.5 SINGLES ENERGY; MP2.5 TOTAL ENERGY; MP3 CORRELATION ENERGY; MP3 DOUBLES ENERGY; MP3 OPPOSITE-SPIN CORRELATION ENERGY; MP3 SAME-SPIN CORRELATION ENERGY; MP3 SINGLES ENERGY; MP3 TOTAL ENERGY; NAUX (SCF); OLCCD CORRELATION ENERGY; OLCCD OPPOSITE-SPIN CORRELATION ENERGY; OLCCD REFERENCE CORRECTION ENERGY; OLCCD SAME-SPIN CORRELATION ENERGY; OLCCD TOTAL ENERGY; OMP2 CORRELATION ENERGY; OMP2 OPPOSITE-SPIN CORRELATION ENERGY; OMP2 REFERENCE CORRECTION ENERGY; OMP2 SAME-SPIN CORRELATION ENERGY; OMP2 TOTAL ENERGY; OMP2.5 CORRELATION ENERGY; OMP2.5 OPPOSITE-SPIN CORRELATION ENERGY; OMP2.5 REFERENCE CORRECTION ENERGY; OMP2.5 SAME-SPIN CORRELATION ENERGY; OMP2.5 TOTAL ENERGY; OMP3 CORRELATION ENERGY; OMP3 OPPOSITE-SPIN CORRELATION ENERGY; OMP3 REFERENCE CORRECTION ENERGY; OMP3 SAME-SPIN CORRELATION ENERGY; OMP3 TOTAL ENERGY; OREMP2 CORRELATION ENERGY; OREMP2 REFERENCE CORRECTION ENERGY; OREMP2 TOTAL ENERGY; REMP2 CORRELATION ENERGY; REMP2 DOUBLES ENERGY; REMP2 OPPOSITE-SPIN CORRELATION ENERGY; REMP2 SAME-SPIN CORRELATION ENERGY; REMP2 SINGLES ENERGY; REMP2 TOTAL ENERGY; SCF TOTAL ENERGY; SCS(N)-MP2 CORRELATION ENERGY; SCS(N)-MP2 TOTAL ENERGY; SCS(N)-OMP2 CORRELATION ENERGY; SCS(N)-OMP2 TOTAL ENERGY; SCS-MP2 CORRELATION ENERGY; SCS-MP2 TOTAL ENERGY; SCS-OMP2 CORRELATION ENERGY; SCS-OMP2 TOTAL ENERGY; SOS-MP2 CORRELATION ENERGY; SOS-MP2 TOTAL ENERGY; SOS-OMP2 CORRELATION ENERGY; SOS-OMP2 TOTAL ENERGY. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.9.1;  · . PSI4. Appendices; PSI Variables by Module; DFOCC. © Cop,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/autodir_psivariables/module__dfocc.html:1638,ENERGY,ENERGY,1638,psi4manual/1.9.x/autodir_psivariables/module__dfocc.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/autodir_psivariables/module__dfocc.html,1,['ENERGY'],['ENERGY']
Energy Efficiency,"RRELATION ENERGY¶; The total electronic energy [E_h] and correlation energy component [E_h]; for state-averaged CI/CASSCF levels of theory. CI TOTAL ENERGY¶. CI CORRELATION ENERGY¶; The total electronic energy [E_h] and correlation energy component [E_h]; for the requested configuration interaction level of theory and root. CISD DIPOLE¶; Dipole array [e a0] for the configuration interaction singles and doubles level of theory, (3,). CISD QUADRUPOLE¶; Redundant quadrupole array [e a0^2] for the configuration interaction singles and doubles level of theory, (3, 3). CISD TOTAL ENERGY¶. CISD CORRELATION ENERGY¶. CISDT TOTAL ENERGY¶. CISDT CORRELATION ENERGY¶. CISDTQ CORRELATION ENERGY¶. CISDTQ TOTAL ENERGY¶. CIn CORRELATION ENERGY¶. CIn TOTAL ENERGY¶; The total electronic energy [E_h] and correlation energy component [E_h]; for the labeled configuration interaction level of theory and root.; n is CI order for n > 4. CP-CORRECTED 2-BODY INTERACTION ENERGY¶; The interaction energy [E_h] considering only two-body interactions,; computed with counterpoise correction.; Related variable UNCP-CORRECTED 2-BODY INTERACTION ENERGY. \[E_{\text{IE}} = E_{dimer} - \sum_{monomer}^{n}{E_{monomer}^{\text{CP}}}\]. CURRENT CORRELATION ENERGY¶; The correlation energy [E_h] corresponding to the CURRENT ENERGY variable. CURRENT ENERGY¶; The total electronic energy [E_h] of the most recent stage of a; calculation (frequently overwritten). This is the quantity tracked by; the geometry optimizer. CURRENT REFERENCE ENERGY¶; The total electronic energy [E_h] of the reference stage corresponding to; the CURRENT ENERGY variable. CURRENT DIPOLE¶; The total dipole [e a0] of the most recent stage of a calculation (frequently overwritten), (3,). CURRENT GRADIENT¶; The total electronic gradient [E_h/a0] of the most recent stage of a; calculation (frequently overwritten). This is the quantity tracked by; the geometry optimizer, ({nat}, 3). CURRENT DIPOLE GRADIENT¶; The derivative of the dipole with resp",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/glossary_psivariables.html:23289,energy,energy,23289,psi4manual/1.7.x/glossary_psivariables.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/glossary_psivariables.html,4,['energy'],['energy']
Energy Efficiency,"RRELATIONENERGY>` . >>> energy('mp2.5'). """"""; lowername = name.lower(); kwargs = kwargs_lower(kwargs). # Run detci calculation and collect conventional quantities; energy('mp3', **kwargs); e_scf = PsiMod.get_variable('SCF TOTAL ENERGY'); ce_mp2 = PsiMod.get_variable('MP2 CORRELATION ENERGY'); ce_mp3 = PsiMod.get_variable('MP3 CORRELATION ENERGY'); e_mp2 = e_scf + ce_mp2; e_mp3 = e_scf + ce_mp3. # Compute quantities particular to MP2.5; ce_mp25 = 0.5 * (ce_mp2 + ce_mp3); e_mp25 = e_scf + ce_mp25; PsiMod.set_variable('MP2.5 CORRELATION ENERGY', ce_mp25); PsiMod.set_variable('MP2.5 TOTAL ENERGY', e_mp25); PsiMod.set_variable('CURRENT CORRELATION ENERGY', ce_mp25); PsiMod.set_variable('CURRENT ENERGY', e_mp25). # build string of title banner and print results; banners = ''; banners += """"""PsiMod.print_out('\\n')\n""""""; banners += """"""banner(' MP2.5 ')\n""""""; banners += """"""PsiMod.print_out('\\n')\n\n""""""; exec(banners). tables = ''; tables += """""" SCF total energy: %16.8f\n"""""" % (e_scf); tables += """""" MP2 total energy: %16.8f\n"""""" % (e_mp2); tables += """""" MP2.5 total energy: %16.8f\n"""""" % (e_mp25); tables += """""" MP3 total energy: %16.8f\n\n"""""" % (e_mp3); tables += """""" MP2 correlation energy: %16.8f\n"""""" % (ce_mp2); tables += """""" MP2.5 correlation energy: %16.8f\n"""""" % (ce_mp25); tables += """""" MP3 correlation energy: %16.8f\n"""""" % (ce_mp3); PsiMod.print_out(tables). return e_mp25. # A direct translation of a plugin input file into a function call. Function calls are the only; # way to call plugins in sow/reap mode for db(), opt(), etc. This isn't best practices; # but is an example of what to do for a more complicated procedure where different options ; # are set for different qc steps.; [docs]def run_plugin_omega(name, **kwargs):; r""""""Function encoding sequence of PSI module and plugin calls, as well; as typical options, to access Rob Parrish's omega plugin. >>> energy('plugin_omega'). """"""; lowername = name.lower(); kwargs = kwargs_lower(kwargs). plugfile = PsiMod.Process.envir",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/_modules/aliases.html:3547,energy,energy,3547,psi4manual/4.0b3/_modules/aliases.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/_modules/aliases.html,2,['energy'],['energy']
Energy Efficiency,"RRENT CORRELATION ENERGY <CURRENTCORRELATIONENERGY>`. .. caution:: Some features are not yet implemented. Buy a developer a coffee. - Not all methods hooked in through PSI variables, configuration interaction and arbitrary order MP in particular. - No scheme defaults for given basis zeta number, so scheme must be specified explicitly. - No way to tell function to boost fitting basis size for all calculations. - No way to extrapolate def2 family basis sets. - Need to add more extrapolation schemes. As represented in the equation below, a CBS energy method is defined in four; sequential stages (scf, corl, delta, delta2) covering treatment of the; reference total energy, the correlation energy, a delta correction to the; correlation energy, and a second delta correction. Each is activated by its; stage_wfn keyword and is only allowed if all preceding stages are active. .. include:: cbs_eqn.rst. * Energy Methods; The presence of a stage_wfn keyword is the indicator to incorporate; (and check for stage_basis and stage_scheme keywords) and compute; that stage in defining the CBS energy. The cbs() function requires, at a minimum, ``name='scf'`` and ``scf_basis``; keywords to be specified for reference-step only jobs and ``name`` and; ``corl_basis`` keywords for correlated jobs. The following energy methods have been set up for cbs(). .. hlist::; :columns: 5. * scf; * df-scf; * mp2; * df-mp2; * cc2; * ccsd; * bccd; * cc3; * ccsd(t); * cisd; * cisdt; * cisdtq; * ci\ *n*; * fci. :type name: string; :param name: ``'scf'`` || ``'ccsd'`` || etc. First argument, usually unlabeled. Indicates the computational method; for the correlation energy, unless only reference step to be performed,; in which case should be ``'scf'``. Overruled if stage_wfn keywords supplied. :type corl_wfn: string; :param corl_wfn: ``'mp2'`` || ``'ccsd(t)'`` || etc. Indicates the energy method for which the correlation energy is to be; obtained. Can also be specified with ``name`` or as the unlabeled; first a",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/_modules/wrappers.html:53664,energy,energy,53664,psi4manual/4.0b3/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/_modules/wrappers.html,3,"['Energy', 'energy']","['Energy', 'energy']"
Energy Efficiency,"RRENT CORRELATION ENERGY <CURRENTCORRELATIONENERGY>`. .. caution:: Some features are not yet implemented. Buy a developer a coffee. - Not all methods hooked in through PSI variables, configuration interaction and arbitrary order MP in particular. - No scheme defaults for given basis zeta number, so scheme must be specified explicitly. - No way to tell function to boost fitting basis size for all calculations. - No way to extrapolate def2 family basis sets. - Need to add more extrapolation schemes. As represented in the equation below, a CBS energy method is defined in four; sequential stages (scf, corl, delta, delta2) covering treatment of the; reference total energy, the correlation energy, a delta correction to the; correlation energy, and a second delta correction. Each is activated by its; stage_wfn keyword and is only allowed if all preceding stages are active. .. include:: cbs_eqn.rst. * Energy Methods; The presence of a stage_wfn keyword is the indicator to incorporate; (and check for stage_basis and stage_scheme keywords) and compute; that stage in defining the CBS energy. The cbs() function requires, at a minimum, ``name='scf'`` and ``scf_basis``; keywords to be specified for reference-step only jobs and ``name`` and; ``corl_basis`` keywords for correlated jobs. The following energy methods have been set up for cbs(). .. hlist::; :columns: 5. * scf; * df-scf; * mp2; * df-mp2; * cc2; * ccsd; * bccd; * cc3; * ccsd(t); * fci. :type name: string; :param name: ``'scf'`` || ``'ccsd'`` || etc. First argument, usually unlabeled. Indicates the computational method; for the correlation energy, unless only reference step to be performed,; in which case should be ``'scf'``. Overruled if stage_wfn keywords supplied. :type corl_wfn: string; :param corl_wfn: ``'mp2'`` || ``'ccsd(t)'`` || etc. Indicates the energy method for which the correlation energy is to be; obtained. Can also be specified with ``name`` or as the unlabeled; first argument to the function. :type delta_w",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:52758,energy,energy,52758,psi4manual/4.0b2/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html,3,"['Energy', 'energy']","['Energy', 'energy']"
Energy Efficiency,"RRENT CORRELATION ENERGY <CURRENTCORRELATIONENERGY>`. .. caution:: Some features are not yet implemented. Buy a developer a coffee. - Not all methods hooked in through PSI variables, configuration interaction and arbitrary order MP in particular. - No scheme defaults for given basis zeta number, so scheme must be specified explicitly. - No way to tell function to boost fitting basis size for all calculations. - No way to extrapolate def2 family basis sets. - Need to add more extrapolation schemes. As represented in the equation below, a CBS energy method is defined in four; sequential stages (scf, corl, delta, delta2) covering treatment of the; reference total energy, the correlation energy, a delta correction to the; correlation energy, and a second delta correction. Each is activated by its; stage_wfn keyword and is only allowed if all preceding stages are active. .. include:: cbs_eqn.rst. * Energy Methods; The presence of a stage_wfn keyword is the indicator to incorporate; (and check for stage_basis and stage_scheme keywords) and compute; that stage in defining the CBS energy. The cbs() function requires, at a minimum, ``name='scf'`` and ``scf_basis``; keywords to be specified for reference-step only jobs and ``name`` and; ``corl_basis`` keywords for correlated jobs. The following energy methods have been set up for cbs(). .. hlist::; :columns: 5. * scf; * mp2; * mp2.5; * mp3; * mp4(sdq); * mp4; * omp2; * omp3; * ocepa; * cepa0; * cepa(0); * cepa(1); * cepa(3); * acpf; * aqcc; * qcisd; * cc2; * ccsd; * fno-df-ccsd; * bccd; * cc3; * qcisd(t); * ccsd(t); * fno-df-ccsd(t); * bccd(t); * cisd; * cisdt; * cisdtq; * ci\ *n*; * fci. :type name: string; :param name: ``'scf'`` || ``'ccsd'`` || etc. First argument, usually unlabeled. Indicates the computational method; for the correlation energy, unless only reference step to be performed,; in which case should be ``'scf'``. Overruled if stage_wfn keywords supplied. :type corl_wfn: string; :param corl_wfn: ``'mp2'`` || ``'c",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:53965,energy,energy,53965,psi4manual/4.0b4/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html,3,"['Energy', 'energy']","['Energy', 'energy']"
Energy Efficiency,"RRENT CORRELATION ENERGY; CURRENT ENERGY; CURRENT REFERENCE ENERGY; MP2 CORRELATION ENERGY; MP2 OPPOSITE-SPIN ENERGY; MP2 SAME-SPIN ENERGY; MP2 TOTAL ENERGY; MP2.5 CORRELATION ENERGY; MP2.5 TOTAL ENERGY; MP3 CORRELATION ENERGY; MP3 TOTAL ENERGY; OCEPA(0) CORRELATION ENERGY; OCEPA(0) TOTAL ENERGY; OMP2 CORRELATION ENERGY; OMP2 TOTAL ENERGY; OMP2.5 CORRELATION ENERGY; OMP2.5 TOTAL ENERGY; OMP3 CORRELATION ENERGY; OMP3 TOTAL ENERGY; SCS-MP2 CORRELATION ENERGY; SCS-MP2 TOTAL ENERGY; SCS-MP2-VDW CORRELATION ENERGY; SCS-MP2-VDW TOTAL ENERGY; SCS-MP3 CORRELATION ENERGY; SCS-MP3 TOTAL ENERGY; SCS-MP3-VDW CORRELATION ENERGY; SCS-MP3-VDW TOTAL ENERGY; SCS-OCEPA(0) CORRELATION ENERGY; SCS-OCEPA(0) TOTAL ENERGY; SCS-OMP2 CORRELATION ENERGY; SCS-OMP2 TOTAL ENERGY; SCS-OMP2-VDW CORRELATION ENERGY; SCS-OMP2-VDW TOTAL ENERGY; SCS-OMP3 CORRELATION ENERGY; SCS-OMP3 TOTAL ENERGY; SCS-OMP3-VDW CORRELATION ENERGY; SCS-OMP3-VDW TOTAL ENERGY; SCSN-MP2 CORRELATION ENERGY; SCSN-MP2 TOTAL ENERGY; SCSN-MP3 CORRELATION ENERGY; SCSN-MP3 TOTAL ENERGY; SCSN-OMP2 CORRELATION ENERGY; SCSN-OMP2 TOTAL ENERGY; SCSN-OMP3 CORRELATION ENERGY; SCSN-OMP3 TOTAL ENERGY; SOS-MP2 CORRELATION ENERGY; SOS-MP2 TOTAL ENERGY; SOS-MP3 CORRELATION ENERGY; SOS-MP3 TOTAL ENERGY; SOS-OCEPA(0) CORRELATION ENERGY; SOS-OCEPA(0) TOTAL ENERGY; SOS-OMP2 CORRELATION ENERGY; SOS-OMP2 TOTAL ENERGY; SOS-OMP3 CORRELATION ENERGY; SOS-OMP3 TOTAL ENERGY; SOS-PI-MP2 CORRELATION ENERGY; SOS-PI-MP2 TOTAL ENERGY; SOS-PI-MP3 CORRELATION ENERGY; SOS-PI-MP3 TOTAL ENERGY; SOS-PI-OMP2 CORRELATION ENERGY; SOS-PI-OMP2 TOTAL ENERGY; SOS-PI-OMP3 CORRELATION ENERGY; SOS-PI-OMP3 TOTAL ENERGY. Previous topic; MRCC; Next topic; OPTKING; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » ; Appendices »; PSI Variables by Module ». © Copyright 2013, The Psi4 Project.; Last updated on Apr 29, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/autodir_psivariables/module__occ-1.html:658,ENERGY,ENERGY,658,psi4manual/4.0b4/autodir_psivariables/module__occ-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/autodir_psivariables/module__occ-1.html,94,['ENERGY'],['ENERGY']
Energy Efficiency,"RUPOLE YZ¶. CI ROOT n QUADRUPOLE ZZ¶; The six components of the quadrupole [Debye Ang] for the requested; configuration interaction level of theory and root n. CI ROOT n TOTAL ENERGY¶. CI ROOT n CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the requested configuration interaction level of theory and root; n (numbering starts at 1). CI STATE-AVERAGED TOTAL ENERGY¶. CI STATE-AVERAGED CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for state-averaged CI/CASSCF levels of theory. CI TOTAL ENERGY¶. CI CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the requested configuration interaction level of theory and root. CISD TOTAL ENERGY¶. CISD CORRELATION ENERGY¶. CISDT TOTAL ENERGY¶. CISDT CORRELATION ENERGY¶. CISDTQ CORRELATION ENERGY¶. CISDTQ TOTAL ENERGY¶. CIn CORRELATION ENERGY¶. CIn TOTAL ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the labeled configuration interaction level of theory and root.; n is CI order for n > 4. CP-CORRECTED 2-BODY INTERACTION ENERGY¶; The interaction energy [H] considering only two-body interactions,; computed with counterpoise correction.; Related variable UNCP-CORRECTED 2-BODY INTERACTION ENERGY. CURRENT CORRELATION ENERGY¶; The correlation energy [H] corresponding to the CURRENT ENERGY variable. CURRENT ENERGY¶; The total electronic energy [H] of the most recent stage of a; calculation (frequently overwritten). This is the quantity tracked by; the geometry optimizer. CURRENT REFERENCE ENERGY¶; The total electronic energy [H] of the reference stage corresponding to; the CURRENT ENERGY variable. db_name DATABASE MEAN ABSOLUTE DEVIATION¶; The mean absolute deviation [kcal mol-1] of the requested method; name from the stored reference values for the requested reactions in; database db_name. If no reference is available, this will be a large; and nonsensical value. db_name D",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/glossary_psivariables-1.html:3951,energy,energy,3951,psi4manual/4.0b2/glossary_psivariables-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/glossary_psivariables-1.html,4,['energy'],['energy']
Energy Efficiency,"RUPOLE', title='H3O+ SCF'). """"""; oe = core.OEProp(wfn); if 'title' in kwargs:; oe.set_title(kwargs['title']); for prop in args:; oe.add(prop). # If we're doing MBIS, we want the free-atom volumes; # in order to compute volume ratios,; # but only if we're calling oeprop as the whole molecule; free_atom = kwargs.get('free_atom',False); if ""MBIS_VOLUME_RATIOS"" in prop.upper() and not free_atom:; core.print_out("" Computing free-atom volumes\n""); free_atom_volumes(wfn). oe.compute(). [docs]; def cubeprop(wfn: core.Wavefunction, **kwargs):; """"""Evaluate properties on a grid and generate cube files. .. versionadded:: 0.5; *wfn* parameter passed explicitly. :returns: None. :param wfn: set of molecule, basis, orbitals from which to generate cube files. :examples:. >>> # [1] Cube files for all orbitals; >>> E, wfn = energy('b3lyp', return_wfn=True); >>> cubeprop(wfn). >>> # [2] Cube files for density (alpha, beta, total, spin) and four orbitals; >>> # (two alpha, two beta); >>> set cubeprop_tasks ['orbitals', 'density']; >>> set cubeprop_orbitals [5, 6, -5, -6]; >>> E, wfn = energy('scf', return_wfn=True); >>> cubeprop(wfn). """"""; # By default compute the orbitals; if not core.has_global_option_changed('CUBEPROP_TASKS'):; core.set_global_option('CUBEPROP_TASKS', ['ORBITALS']). if ((core.get_global_option('INTEGRAL_PACKAGE') == 'ERD') and ('ESP' in core.get_global_option('CUBEPROP_TASKS'))):; raise ValidationError('INTEGRAL_PACKAGE ERD does not play nicely with electrostatic potential, so stopping.'). cp = core.CubeProperties(wfn); cp.compute_properties(). [docs]; def set_memory(inputval: Union[str, int, float], execute: bool = True, quiet: bool = False) -> int:; """"""Reset the total memory allocation. Parameters; ----------; inputval; Memory value. An Integer or float is taken literally as bytes to be set.; A string is taken as a unit-containing value (e.g., 30 mb), which is; case-insensitive.; execute; When False, interpret *inputval* without setting in Psi4 core.; quiet; When T",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/util.html:3179,energy,energy,3179,psi4manual/1.8.x/_modules/psi4/driver/p4util/util.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/util.html,2,['energy'],['energy']
Energy Efficiency,"R_OCCUPATION. Specifies the orbital occupancy of the reference function in terms of the occupation numbers of the orbitals and their irreducible representations. The occupancy is specified by either NIRREP or 2*NIRREP integers specifying the number of occupied orbitals of each symmetry type, where NIRREP is the number of irreducible representations in the computational point group. If there are no orbitals of a particular symmetry type a zero must be entered. If the reference function is for an open-shell system, two strings of NIRREP occupation numbers separated by a slash are input for the \(\alpha\) and \(\beta\) sets of orbitals. An example of the use of the OCCUPATION keyword for the water molecule would be OCCUPATION=3-1-1-0. For the \(^2A_1\) water cation, an open-shell system, the keyword would be specified by OCCUPATION=3-1-1-0/2-1-1-0. It should be noted that the xvmol integral program orders the irreducible representations in a strange way, which most users do not perceive to be a logical order. Hence, it is usually advisable initially to run just a single point integral and HF-SCF calculation in order to determine the number and ordering of the irreducible representations. The occupation keyword may be omitted, in which case an initial orbital occupancy is determined by diagonalization of the core Hamiltonian. In many cases, HF-SCF calculations run with the core Hamiltonian guess will usually converge to the lowest energy HF-SCF solution, but this should not be blindly assumed. (Default: The occupation is given by the core Hamiltonian initial guess). Psi4 Interface: The arrays above are specified in PSI as (white space tolerant) [3,1,1,0] and [[3,1,1,0],[3,0,1,0]]. Type: array; Default: No Default. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.3.2;  · . PSI4. Appendices; Keywords by Module; CFOUR. © Copyright 2019, The Psi4 Project.; Last updated on Wednesday, 15 May 2019 08:49PM.; Created using Sphinx 1.8.5.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/autodir_options_c/cfour__cfour_occupation-1.html:1579,energy,energy,1579,psi4manual/1.3.2/autodir_options_c/cfour__cfour_occupation-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/autodir_options_c/cfour__cfour_occupation-1.html,2,['energy'],['energy']
Energy Efficiency,"Raghavachari:1989], and related methods be reduced by constructing a; compact representation of the virtual space based on the natural orbitals; of second-order perturbation theory [Sosa:1989:148]. The most demanding; steps in the CCSD and (T) algorithms scale as \({\cal{O}}(o^2v^4)\); and \({\cal{O}}(o^3v^4)\), where \(o\) and \(v\) represent the; number of oribitals that are occupied and unoccupied (virtual) in the; reference function, respectively. By reducing the the size of the virtual; space, the cost of evaluating these terms reduces by a factor of \((v; / v_{FNO})^4\), where \(v_{FNO}\) represents the number of virtual; orbitals retained after the FNO truncation.; The general outline for the FNO procedure in PSI4 is:. construct the virtual-virtual block of the unrelaxed MP2 one-particle density matrix (OPDM); diagonalize this block of the OPDM to obtain a set of natural virtual orbitals; based on some occupancy threshold, determine which orbitals are unimportant and may be discarded; project the virtual-virtual block of the Fock matrix onto the truncated space; construct semicanonical orbitals by diagonalizing the virtual-virtual block of the Fock matrix; proceed with the QCISD(T) / CCSD(T) / MP4 computation in the reduced virtual space. A second-order correction based upon the MP2 energies in the full and; truncated spaces captures much of the missing correlation effects. More; details on the implementation and numerical accuracy of FNO methods in; PSI4 can be found in [DePrince:2013:293]. FNO computations; are controlled through the keywords NAT_ORBS and; OCC_TOLERANCE, or by prepending a valid method name with “fno” in; the energy call as; 1energy('fno-ccsd(t)'). If you wish to specify the number of active natural orbitals manually, use; the keyword ACTIVE_NAT_ORBS. This keyword will override the; keyword OCC_TOLERANCE. QCISD(T), CCSD(T), MP4, and CEPA¶; The FNOCC module in PSI4 supports several related many-body quantum; chemistry methods, including the ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/fnocc-1.html:2145,reduce,reduced,2145,psi4manual/1.1.0/fnocc-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/fnocc-1.html,6,['reduce'],['reduced']
Energy Efficiency,"Raghavachari:1989], and related methods be reduced by constructing a; compact representation of the virtual space based on the natural orbitals; of second-order perturbation theory [Sosa:1989:148]. The most demanding; steps in the CCSD and (T) algorithms scale as \({\cal{O}}(o^2v^4)\); and \({\cal{O}}(o^3v^4)\), where \(o\) and \(v\) represent the; number of oribitals that are occupied and unoccupied (virtual) in the; reference function, respectively. By reducing the the size of the virtual; space, the cost of evaluating these terms reduces by a factor of \((v; / v_{FNO})^4\), where \(v_{FNO}\) represents the number of virtual; orbitals retained after the FNO truncation.; The general outline for the FNO procedure in PSI4 is:. construct the virtual-virtual block of the unrelaxed MP2 one-particle density matrix (OPDM); diagonalize this block of the OPDM to obtain a set of natural virtual orbitals; based on some occupancy threshold, determine which orbitals are unimportant and may be discarded; project the virtual-virtual block of the Fock matrix onto the truncated space; construct semicanonical orbitals by diagonalizing the virtual-virtual block of the Fock matrix; proceed with the QCISD(T) / CCSD(T) / MP4 computation in the reduced virtual space. A second-order correction based upon the MP2 energies in the full and; truncated spaces captures much of the missing correlation effects. More; details on the implementation and numerical accuracy of FNO methods in; PSI4 can be found in [DePrince:2013:293]. FNO computations; are controlled through the keywords NAT_ORBS and; OCC_TOLERANCE, or by prepending a valid method name with “fno” in; the energy call as; energy('fno-ccsd(t)'). If you wish to specify the number of active natural orbitals manually, use; the keyword ACTIVE_NAT_ORBS. This keyword will override the; keyword OCC_TOLERANCE. QCISD(T), CCSD(T), MP4, and CEPA¶; The FNOCC module in PSI4 supports several related many-body quantum; chemistry methods, including the C",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/fnocc-1.html:2214,reduce,reduced,2214,psi4manual/1.4.0/fnocc-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/fnocc-1.html,9,['reduce'],['reduced']
Energy Efficiency,"Read the literature to determine which functional technology to use. The world; contains far too many papers using B3LYP on noncovalent interactions without a -D. The “best-practice” input file for KS-DFT is:; memory 1 GB # As much as you've got, the DF algorithm can use. molecule {; H; H 1 0.7; }. set {; basis cc-pvdz; scf_type df; guess sad; }. energy('b3lyp'). Advanced Functional Use and Manipulation¶; New DFT functionals can be created from scratch from within the input; file and accessed using the dft_functional keyword argument in the; energy call:; # DFT Custom Functional. molecule h2o {; 0 1; O; H 1 1.0; H 1 1.0 2 104.5; }. set {; basis sto-3g; dft_spherical_points 302; dft_radial_points 99; reference rks; }. pbe0 = {; ""name"": ""my_PBE0"",; ""x_functionals"": {""GGA_X_PBE"": {""alpha"": 0.75}},; ""x_hf"": {""alpha"": 0.25},; ""c_functionals"": {""GGA_C_PBE"": {}}; }. func_call = energy('SCF', dft_functional=pbe0). # as PBE0 is a pre-defined functional, the call above is equivalent to both below:; func_call = energy('SCF', dft_functional=""PBE0""); func_call = energy('PBE0'). Supported keywords include:. name: string, name of the functional. for custom defined functionals used for printing only.; xc_functionals: dict, definition of a complete (X + C) functional based in LibXC name; x_functionals: dict, definition of exchange functionals using LibXC names; c_functionals: dict, definition of correlation functionals using LibXC names; x_hf: dict, parameters dealing with exact (HF) exchange settings for hybrid DFT; c_mp2: dict, parameters dealing with MP2 correlation for double hybrid DFT; dispersion: dict, definition of dispersion corrections; citation: string, citation for the method, for printing purposes; description: string, description of the method, for printing purposes. The full interface is defined in; psi4/psi4/driver/procrouting/dft/dft_builder.py. All; standard functionals provided in PSI4 are implemented in the; *_functionals.py files in the same folder. """"""; Superfu",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/dft-1.html:29369,energy,energy,29369,psi4manual/1.4.0/dft-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/dft-1.html,18,['energy'],['energy']
Energy Efficiency,"Recommendations¶; The KS-DFT code is quite new, but relatively complete. During code development,; emphasis was placed on flexibility of functional technology, efficiency for; medium to large systems in difficult electronic environments (e.g., compact; spatial extents, diffuse basis sets, low band-gaps, LRC and/or hybrid GKS; functionals), and time to code completion. We are very interested in optimizing; and extending the code, so expect performance gains and extensions to; gradients/hessians and TDDFT in future releases.; Some rough guidelines for using the KS-DFT code are as follows,. Use DF for the ERI algorithm wherever possible.; PSI4 is a “tight” code, meaning we’ve set the default numerical cutoffs; for integrals, grids, and convergence criteria in such a way that you will often; get many more digits of precision than needed. You may be able to realize; additional speed gains by loosening some of these thresholds. See; SCF Convergence for default convergence criteria.; Read the literature to determine which functional technology to use. The world; contains far too many papers using B3LYP on noncovalent interactions without a -D. The “best-practice” input file for KS-DFT is:; memory 1 GB # As much as you've got, the DF algorithm can use. molecule {; H; H 1 0.7; }. set {; basis cc-pvdz; scf_type df; guess sad; }. energy('b3lyp'). Table Of Contents. DFT: Density Functional Theory; Theory; Minimal Input; Spin/Symmetry Treatment; Functional Selection; Grid Selection; ERI Algorithms; IP Fitting; Fractional Particle Curves; Dispersion Corrections; Recommendations. Previous topic; HF: Hartree–Fock Theory; Next topic; DCFT: Density Cumulant Functional Theory; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » ; Theoretical Methods: SCF to FCI ». © Copyright 2013, The Psi4 Project.; Last updated on Apr 25, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/dft-1.html:23458,energy,energy,23458,psi4manual/4.0b4/dft-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/dft-1.html,2,['energy'],['energy']
Energy Efficiency,"Recommendations¶; The KS-DFT code is quite new, but relatively complete. During code development,; emphasis was placed on flexibility of functional technology, efficiency for; medium to large systems in difficult electronic environments (e.g., compact; spatial extents, diffuse basis sets, low band-gaps, LRC and/or hybrid GKS; functionals), and time to code completion. We are very interested in optimizing; and extending the code, so expect performance gains and extensions to; gradients/hessians and TDDFT in future releases.; Some rough guidelines for using the KS-DFT code are as follows,. Use DF for the ERI algorithm wherever possible.; PSI4 is a “tight” code, meaning we’ve set the default numerical cutoffs; for integrals, grids, and convergence criteria in such a way that you will often; get many more digits of precision than needed. You may be able to realize; additional speed gains by loosening some of these thresholds. See; SCF Convergence for default convergence criteria.; Read the literature to determine which functional technology to use. The world; contains far too many papers using B3LYP on noncovalent interactions without a -D. The “best-practice” input file for KS-DFT is:; memory 1 GB # As much as you've got, the DF algorithm can use. molecule {; H; H 1 0.7; }. set {; basis cc-pvdz; scf_type df; guess sad; }. energy('b3lyp'). Table Of Contents. DFT: Density Functional Theory; Theory; Minimal Input; Spin/Symmetry Treatment; Functional Selection; Grid Selection; ERI Algorithms; IP Fitting; Fractional Particle Curves; Dispersion Corrections; Recommendations. Previous topic; HF: Hartree–Fock Theory; Next topic; DCFT: Density Cumulant Functional Theory; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta5] » ; Theoretical Methods: SCF to FCI ». © Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/dft-1.html:23458,energy,energy,23458,psi4manual/4.0b5/dft-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/dft-1.html,2,['energy'],['energy']
Energy Efficiency,"Redundant hexadecapole array [e a0^4] for the named method, (3, 3, 3, 3). mtd 32-POLE¶; Redundant 32-pole array [e a0^5] for the named method, (3, 3, 3, 3, 3). mtd 64-POLE¶; Redundant 64-pole array [e a0^6] for the named method, (3, 3, 3, 3, 3, 3). mtd 128-POLE¶; Redundant 128-pole array [e a0^7] for the named method, (3, 3, 3, 3, 3, 3, 3). MP2 TOTAL ENERGY¶. MP2 CORRELATION ENERGY¶; The total electronic energy [E_h] and correlation energy component [E_h]; for the MP2 level of theory. MP2 TOTAL GRADIENT¶. The total electronic gradient [E_h/a0] of the MP2 level of theory, ({nat}, 3).¶. MP2 DIPOLE GRADIENT¶; The derivative of the MP2 level of theory dipole [E_h a0/u] = [(e a0/a0)^2/u] with respect to nuclear perturbations; as a degree-of-freedom by dipole component array, (3 * {nat}, 3). MP2 TOTAL HESSIAN¶; The total electronic second derivative [E_h/a0/a0] for the MP2 level of theory, (3 * {nat}, 3 * {nat}). MP2.5 TOTAL ENERGY¶. MP2.5 CORRELATION ENERGY¶; The total electronic energy [E_h] and correlation energy component [E_h]; for the MP2.5 level of theory. MP3 TOTAL ENERGY¶. MP3 CORRELATION ENERGY¶; The total electronic energy [E_h] and correlation energy component [E_h]; for the MP3 level of theory. MP4(T) CORRECTION ENERGY¶; The MP4 triples component [E_h]. Quantity is second right-hand term in; Eq. (2). MP4(SDQ) TOTAL ENERGY¶. MP4(SDQ) CORRELATION ENERGY¶; The total electronic energy [E_h] and correlation energy component [E_h]; for the MP4 singles, doubles, quadruples level of theory. Quantity; MP4(SDQ) CORRELATION ENERGY is; first right-hand term in Eq. (2). MP4 TOTAL ENERGY¶. MP4 CORRELATION ENERGY¶. MP4(SDTQ) TOTAL ENERGY¶. MP4(SDTQ) CORRELATION ENERGY¶; The total electronic energy [E_h] and correlation energy component [E_h]; for the full MP4 level of theory. Quantity MP4 CORRELATION; ENERGY / MP4(SDTQ) CORRELATION ENERGY; is left-hand term in Eq. (2). (2)¶\[E_{\text{MP4}} = E_{\text{MP4(SDQ)}} + E_{\text{MP4(T)}}\]. MPn TOTAL ENERGY¶. MPn CORRELATION ENERGY",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/glossary_psivariables.html:36482,energy,energy,36482,psi4manual/1.7.x/glossary_psivariables.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/glossary_psivariables.html,8,['energy'],['energy']
Energy Efficiency,"Relies upon van der Waals radii and so faulty for close; (esp. hydrogen-bonded) fragments. Original code from; Michael S. Marshall. Z(self: psi4.core.Molecule, arg0: int) → float¶; Nuclear charge of atom arg1 (0-indexed). activate_all_fragments(self: psi4.core.Molecule) → None¶; Sets all fragments in the molecule to be active. add_atom(self: psi4.core.Molecule, arg0: int, arg1: float, arg2: float, arg3: float, arg4: str, arg5: float, arg6: float, arg7: int) → None¶; Adds to Molecule arg0 an atom with atomic number arg1, Cartesian coordinates in Bohr (arg2, arg3, arg4), atomic symbol arg5, mass arg6, charge arg7 (optional), and lineno arg8 (optional). atom_at_position(self: psi4.core.Molecule, arg0: float, arg1: float) → int¶; Tests to see if an atom is at the position arg2 with a given tolerance arg3. center_of_mass(self: psi4.core.Molecule) → psi4.core.Vector3¶; Computes center of mass of molecule (does not translate molecule). charge(self: psi4.core.Molecule, arg0: int) → float¶; Gets charge of atom arg1 (0-indexed). clone(self: psi4.core.Molecule) → psi4.core.Molecule¶; Returns a new Molecule identical to arg0. create_molecule_from_string(arg0: str) → psi4.core.Molecule¶; Returns a new Molecule with member data from the geometry string arg0 in Psi4 format. create_psi4_string_from_molecule(self: psi4.core.Molecule) → str¶; Gets a string reexpressing in input format the current states of the molecule. deactivate_all_fragments(self: psi4.core.Molecule) → None¶; Sets all fragments in the molecule to be inactive. distance_matrix(self: psi4.core.Molecule) → psi4.core.Matrix¶; Returns Matrix of interatom distances. extract_subsets(*args, **kwargs)¶; Overloaded function. extract_subsets(self: psi4.core.Molecule, arg0: list, arg1: list) -> psi4.core.Molecule. Returns copy of arg1 with arg2 fragments Real and arg3 fragments Ghost. extract_subsets(self: psi4.core.Molecule, arg0: list, arg1: int) -> psi4.core.Molecule. Returns copy of arg1 with arg2 fragments Real and arg3 f",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/psi4api-1.html:79027,charge,charge,79027,psi4manual/1.1.0/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/psi4api-1.html,3,['charge'],['charge']
Energy Efficiency,"Returns a list describing how to handle each fragment {Real, Ghost, Absent}. get_fragments(self); Returns list of pairs of atom ranges defining each fragment from parent molecule(fragments[frag_ind] = <Afirst,Alast+1>). get_full_point_group(self); Gets point group name such as C3v or S8. get_full_point_group_with_n(self); Gets point group name such as Cnv or Sn. get_variable(self, arg0); Returns the value of variable arg0 in the structural variables list. inertia_tensor(self); Returns intertial tensor. input_units_to_au(self); Returns unit conversion to [a0] for geometry. irrep_labels(self); Returns Irreducible Representation symmetry labels. is_variable(self, arg0); Checks if variable arg0 is in the structural variables list. label(self, atom); Gets the original label of the atom as given in the input file (C2, H4)(0-indexed without dummies). mass(self, atom); Returns mass of atom (0-indexed). mass_number(self, arg0); Mass number (A) of atom if known, else -1. molecular_charge(self); Gets the molecular charge. move_to_com(self); Moves molecule to center of mass. multiplicity(self); Gets the multiplicity (defined as 2Ms + 1). nallatom(self); Number of real and dummy atoms. name(self); Gets molecule name. natom(self); Number of real atoms. nfragments(self); Gets the number of fragments in the molecule. nuclear_dipole(*args, **kwargs); Overloaded function. nuclear_repulsion_energy(self, dipole_field, …); Computes nuclear repulsion energy. nuclear_repulsion_energy_deriv1(self, …); Returns first derivative of nuclear repulsion energy as a matrix (natom, 3). nuclear_repulsion_energy_deriv2(self); Returns second derivative of nuclear repulsion energy as a matrix (natom X 3, natom X 3). orientation_fixed(self); Get whether or not orientation is fixed. point_group(self); Returns the current point group object. print_bond_angles(self); Print the bond angle geometrical parameters. print_cluster(self); Prints the molecule in Cartesians in input units adding fragment separators.",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/api/psi4.core.molecule.html:5013,charge,charge,5013,psi4manual/1.3.2/api/psi4.core.molecule.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/api/psi4.core.molecule.html,3,['charge'],['charge']
Energy Efficiency,"Returns a list describing how to handle each fragment {Real, Ghost, Absent}. get_fragments(self); Returns list of pairs of atom ranges defining each fragment from parent molecule(fragments[frag_ind] = <Afirst,Alast+1>). get_full_point_group(self); Gets point group name such as C3v or S8. get_full_point_group_with_n(self); Gets point group name such as Cnv or Sn. get_variable(self, arg0); Returns the value of variable arg0 in the structural variables list. inertia_tensor(self); Returns intertial tensor. input_units_to_au(self); Returns unit conversion to [a0] for geometry. irrep_labels(self); Returns Irreducible Representation symmetry labels. is_variable(self, arg0); Checks if variable arg0 is in the structural variables list. label(self, atom); Gets the original label of the atom as given in the input file (C2, H4)(0-indexed without dummies). mass(self, atom); Returns mass of atom (0-indexed). mass_number(self, arg0); Mass number (A) of atom if known, else -1. molecular_charge(self); Gets the molecular charge. move_to_com(self); Moves molecule to center of mass. multiplicity(self); Gets the multiplicity (defined as 2Ms + 1). nallatom(self); Number of real and dummy atoms. name(self); Gets molecule name. natom(self); Number of real atoms. nfragments(self); Gets the number of fragments in the molecule. nuclear_dipole(*args, **kwargs); Overloaded function. nuclear_repulsion_energy(self[, dipole_field]); Computes nuclear repulsion energy. nuclear_repulsion_energy_deriv1(self[, ...]); Returns first derivative of nuclear repulsion energy as a matrix (natom, 3). nuclear_repulsion_energy_deriv2(self); Returns second derivative of nuclear repulsion energy as a matrix (natom X 3, natom X 3). orientation_fixed(self); Get whether or not orientation is fixed. point_group(self); Returns the current point group object. print_bond_angles(self); Print the bond angle geometrical parameters. print_cluster(self); Prints the molecule in Cartesians in input units adding fragment separato",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/api/psi4.core.molecule.html:5031,charge,charge,5031,psi4manual/1.5.0/api/psi4.core.molecule.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/api/psi4.core.molecule.html,4,['charge'],['charge']
Energy Efficiency,"Returns the One-electron Overlap Matrix. X(). alpha_orbital_space(self, id, basis, subset); Creates OrbitalSpace with information about the requested alpha orbital space. aotoso(self); Returns the Atomic Orbital to Symmetry Orbital transformer. array_variable(self, arg0); Returns copy of the requested (case-insensitive) Matrix QC variable. array_variables(self); Returns the dictionary of all Matrix QC variables. arrays(). Deprecated since version 1.4. atomic_point_charges(self); Returns the set atomic point charges. basis_projection(self, arg0, arg1, arg2, arg3); Projects a orbital matrix from one basis to another. basisset(self); Returns the current orbital basis. beta_orbital_space(self, arg0, arg1, arg2); docstring. build(mol[, basis]). c1_deep_copy(self, basis); Returns a new wavefunction with internal data converted to \(C_1\) symmetry, using pre-c1-constructed basis. compute(self, arg0); Computes the density-fitted EP2 energy for the input orbitals. compute_energy(self); Computes the energy of the Wavefunction. compute_gradient(self); Computes the gradient of the Wavefunction. compute_hessian(self); Computes the Hessian of the Wavefunction. deep_copy(self, arg0); Deep copies the internal data. del_array_variable(self, arg0); Removes the requested (case-insensitive) Matrix QC variable. del_potential_variable(self, arg0); Removes the requested (case-insensitive) ExternalPotential QC variable. del_scalar_variable(self, arg0); Removes the requested (case-insensitive) double QC variable. del_variable(key); Removes scalar or array QCVariable key from cls if present. density_fitted(self); Returns whether this wavefunction was obtained using density fitting or not. doccpi(self); Returns the number of doubly occupied orbitals per irrep. efzc(self); Returns the frozen-core energy. energy(self); Returns the Wavefunction's energy. epsilon_a(self); Returns the Alpha Eigenvalues. epsilon_a_subset(self, basis, subset); Returns the requested Alpha orbital energies subset. epsi",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/api/psi4.core.dfep2wavefunction.html:2138,energy,energy,2138,psi4manual/1.5.0/api/psi4.core.dfep2wavefunction.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/api/psi4.core.dfep2wavefunction.html,2,['energy'],['energy']
Energy Efficiency,"Returns the One-electron Overlap Matrix. X(). alpha_orbital_space(self, id, basis, subset); Creates OrbitalSpace with information about the requested alpha orbital space. aotoso(self); Returns the Atomic Orbital to Symmetry Orbital transformer. array_variable(self, arg0); Returns copy of the requested (case-insensitive) Matrix QC variable. array_variables(self); Returns the dictionary of all Matrix QC variables. arrays(). Deprecated since version 1.4. atomic_point_charges(self); Returns the set atomic point charges. basis_projection(self, arg0, arg1, arg2, arg3); Projects a orbital matrix from one basis to another. basisset(self); Returns the current orbital basis. beta_orbital_space(self, arg0, arg1, arg2); docstring. build(mol[, basis]). c1_deep_copy(self, basis); Returns a new wavefunction with internal data converted to \(C_1\) symmetry, using pre-c1-constructed basis. compute(self, arg0); Computes the density-fitted EP2 energy for the input orbitals. compute_energy(self); Computes the energy of the Wavefunction. compute_gradient(self); Computes the gradient of the Wavefunction. compute_hessian(self); Computes the Hessian of the Wavefunction. deep_copy(self, arg0); Deep copies the internal data. del_array_variable(self, arg0); Removes the requested (case-insensitive) Matrix QC variable. del_potential_variable(self, arg0); Removes the requested (case-insensitive) ExternalPotential QC variable. del_scalar_variable(self, arg0); Removes the requested (case-insensitive) double QC variable. del_variable(key); Removes scalar or array QCVariable key from cls if present. density_fitted(self); Returns whether this wavefunction was obtained using density fitting or not. doccpi(self); Returns the number of doubly occupied orbitals per irrep. efzc(self); Returns the frozen-core energy. energy(self); Returns the Wavefunction’s energy. epsilon_a(self); Returns the Alpha Eigenvalues. epsilon_a_subset(self, arg0, arg1); Returns the requested Alpha Eigenvalues subset. epsilon_b(se",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/api/psi4.core.dfep2wavefunction.html:2138,energy,energy,2138,psi4manual/1.4.0/api/psi4.core.dfep2wavefunction.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/api/psi4.core.dfep2wavefunction.html,1,['energy'],['energy']
Energy Efficiency,"Returns the hash for the provided type.; * @param type Keyword from input file.; * @returns the hash string for basis. """"""; try:; return self.PYshells[key]; except (ValueError, KeyError):; raise ValidationError('CoordEntry::shells: Shells not set for %s and type of %s' % \; (self.PYlabel, key)). [docs] def shells(self):; """"""Returns shells sets to atom map""""""; return self.PYshells. [docs] def everything(self):; print('\nCoordEntry\n Entry Number = %d\n Computed = %s\n Z = %d\n Charge = %f\n Mass = %f\n Symbol = %s\n Label = %s\n Ghosted = %s\n Coordinates = %s\n Basissets = %s\n\n Shells = %s\n\n' %; (self.entry_number(), self.is_computed(), self.Z(), self.charge(),; self.mass(), self.symbol(), self.label(), self.is_ghosted(),; self.coordinates, self.PYbasissets, self.PYshells)). [docs]class CartesianEntry(CoordEntry):; """"""Class to hold all information about an atom, including its; coordinate specification as three Cartesians. """""". def __init__(self, entry_number, Z, charge, mass, symbol, label, x, y, z, basis=None, shells=None):; CoordEntry.__init__(self, entry_number, Z, charge, mass, symbol, label, basis, shells); self.x = x; self.y = y; self.z = z. [docs] def compute(self):; """"""Computes the values of the coordinates (in whichever units; were inputted), returning them in a Vector. """"""; if self.computed:; return self.coordinates; self.coordinates[0] = self.x.compute(); self.coordinates[1] = self.y.compute(); self.coordinates[2] = self.z.compute(); self.computed = True; return self.coordinates. [docs] def set_coordinates(self, x, y, z):; """"""Given the current set of coordinates, updates the values of this; atom's coordinates and any variables that may depend on it. """"""; self.coordinates[0] = x; self.coordinates[1] = y; self.coordinates[2] = z. self.x.rset(x); self.y.rset(y); self.z.rset(z). self.computed = True. [docs] def type(self):; """"""The type of CoordEntry specialization.""""""; return 'CartesianCoord'. [docs] def print_in_input_format(self):; """"""Prints the updated ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintscoordentry.html:11660,charge,charge,11660,psi4manual/1.0.0/_modules/qcdb/libmintscoordentry.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintscoordentry.html,1,['charge'],['charge']
Energy Efficiency,"Returns true if the alpha and beta densities are the same. same_a_b_orbs(self: psi4.core.Wavefunction) → bool¶; Returns true if the alpha and beta orbitals are the same. save_density_and_energy(self: psi4.core.HF) → None; docstring. scalar_variable(self: psi4.core.Wavefunction, arg0: str) → float¶; Returns the requested (case-insensitive) double QC variable. scalar_variables(self: psi4.core.Wavefunction) → Dict[str, float]¶; Returns the dictionary of all double QC variables. semicanonicalize(self: psi4.core.HF) → None; Semicanonicalizes the orbitals for ROHF. set_array(key, val)¶. set_array_variable(self: psi4.core.Wavefunction, arg0: str, arg1: psi4.core.Matrix) → None¶; Sets the requested (case-insensitive) Matrix QC variable. set_basisset(self: psi4.core.Wavefunction, arg0: str, arg1: psi4.core.BasisSet) → None¶; Sets the requested auxiliary basis. set_energies(self: psi4.core.HF, arg0: str, arg1: float) → None; docstring. set_energy(self: psi4.core.Wavefunction, arg0: float) → None¶; Sets the Wavefunction’s energy. set_external_potential(self: psi4.core.Wavefunction, arg0: psi4.core.ExternalPotential) → None¶; Sets the requested external potential. set_frequencies(val)¶. set_gradient(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix) → None¶; Sets the Wavefunction’s gradient. set_hessian(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix) → None¶; Sets the Wavefunction’s Hessian. set_jk(self: psi4.core.HF, arg0: psi4.core.JK) → None; Sets the internal JK object !expert. set_legacy_frequencies(self: psi4.core.Wavefunction, arg0: psi4.core.Vector) → None¶; Sets the frequencies of the Hessian. set_name(self: psi4.core.Wavefunction, arg0: str) → None¶; Sets the level of theory this wavefunction corresponds to. set_print(self: psi4.core.Wavefunction, arg0: int) → None¶; Sets the print level of the Wavefunction. set_reference_wavefunction(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; docstring. set_sad_basissets(self: psi4.core.HF, arg0: Lis",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/api/psi4.core.hf.html:23470,energy,energy,23470,psi4manual/1.3.2/api/psi4.core.hf.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/api/psi4.core.hf.html,1,['energy'],['energy']
Energy Efficiency,"Robert M. Parrish; Module: Keywords, PSI Variables, LIBFUNCTIONAL, LIBFOCK, LIBSCF_SOLVER; Both density functional theory and Hartree–Fock theory are controlled; through the SCF module, and the SCF Introduction; section is also relevant here. Theory¶; Generalized Kohn-Sham Density Functional Theory (KS-DFT) [Kohn:1965:A1133] [Parr:1989] is one of the primary; workhorses of modern computational chemistry due to its phenomenal accuracy/cost; ratio.; Pure Kohn-Sham DFT is built on the Hohenberg-Kohn theorems [Hohenberg:1964:136] which states: A) the energy is a universal; functional of the one-particle electronic density and B) there exists a set of; noninteracting quasiparticles with the same density as the true set of; electrons, with the quasiparticle states determined as eigenvectors of an; effective one-body potential encapsulating the true -body quantum; effects. The former idea allows the electronic density to be dealt with instead; of the much more complicated wavefunction, while the latter allows for the; treatment of the troublesome kinetic energy term via the implicit one-body; Kohn-Sham orbitals. KS-DFT borrows much of the machinery of Hartree-Fock, as is; evident by looking at the energy expression,. Here is the noninteracting quasiparticle kinetic energy operator,; is the nucleus-electron attraction potential, ; is the total electron density matrix, and is the (potentially nonlocal) exchange, correlation, and residual; kinetic energy functional. The residual kinetic energy term is usually quite; small, and is often ignored, hence is often referred to; as simply the exchange-correlation functional (exchange and correlation, not; just exchange-type correlation).; In practice, the first few generations of KS-DFT functionals were chosen to be; local, meaning that the form of the exchange correlation energy is an integral; over all of space of a function depending only on local information in the; density, such as the density value or derivatives. The simplest",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/dft-1.html:1354,energy,energy,1354,psi4manual/1.0.0/dft-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/dft-1.html,2,['energy'],['energy']
Energy Efficiency,"Runs the coupled cluster response theory code.; ; ccsort(...); ccsort() -> float :; Runs CCSORT, which reorders integrals for use in the coupled cluster codes.; ; cctriples(...); cctriples() -> float :; Runs the coupled cluster (T) energy code.; ; cepa(...); cepa() -> float :; Runs the coupled electron pair approximation code; ; clean(...); clean() -> None :; Function to remove scratch files. Call between independent jobs.; ; close_outfile(...); close_outfile() -> None :; Closes the output file.; ; dcft(...); dcft() -> float :; Runs the density cumulant functional theory code.; ; deriv(...); deriv() -> int :; Runs deriv, which contracts density matrices with derivative integrals, to compute gradients.; ; detci(...); detci() -> float :; Runs the determinant-based configuration interaction code.; ; dfmp2(...); dfmp2() -> float :; Runs the DF-MP2 code.; ; dfmp2grad(...); dfmp2grad() -> float :; Runs the DF-MP2 gradient.; ; fd_1_0(...); fd_1_0( (list)arg1) -> PsiReturnType :; Performs a finite difference gradient computation, from energy points.; ; fd_freq_0(...); fd_freq_0( (list)arg1, (int)arg2) -> PsiReturnType :; Performs a finite difference frequency computation, from energy points, for a given irrep.; ; fd_freq_1(...); fd_freq_1( (list)arg1, (int)arg2) -> PsiReturnType :; Performs a finite difference frequency computation, from gradients, for a given irrep.; ; fd_geoms_1_0(...); fd_geoms_1_0() -> matrix_vector :; Gets the list of displacements needed for a finite difference gradient computation, from energy points.; ; fd_geoms_freq_0(...); fd_geoms_freq_0( (int)arg1) -> matrix_vector :; Gets the list of displacements needed for a finite difference frequency computation, from energy points, for a given irrep.; ; fd_geoms_freq_1(...); fd_geoms_freq_1( (int)arg1) -> matrix_vector :; Gets the list of displacements needed fof a finite difference frequency computation, from gradients, for a given irrep; ; fd_geoms_hessian_0(...); fd_geoms_hessian_0() -> matrix_vector :; ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/psimod-1.html:105771,energy,energy,105771,psi4manual/4.0b3/psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod-1.html,2,['energy'],['energy']
Energy Efficiency,"R}_i - \mathbf{R}_j|}\]. NBODY (i, j, ..., k)@(a, b, ..., c) TOTAL ENERGY¶; The total energy [Eh] of a component of the requested N-Body energy.; The first parenthetical list over i, j, …, k enumerates; molecular fragments included in the computation in 1-indexed,; input-file order, while the second enumerates list over a, b,; …, c enumerates which fragments contribute basis functions to the; computation. For example, (1, 2)@(1, 2, 3, 4) indicates that the; fragments 1 and 2 are explicitly included in the energy computation,; with basis functions from each of fragments 1, 2, 3, & 4 included in; the basis set. Therefore, the basis functions from fragments 3 and 4; are included as ghost functions within the energy computation. OCEPA(0) TOTAL ENERGY¶. OCEPA(0) CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the orbital-optimized CEPA(0) level of theory. OMP2 TOTAL ENERGY¶. OMP2 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the orbital-optimized MP2 level of theory. OMP3 TOTAL ENERGY¶. OMP3 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the orbital-optimized MP3 level of theory. ONE-ELECTRON ENERGY¶; The one-electron energy contribution [H] to the total SCF energy.; Quantity \(E_{1e^-}\) in Eq. (4). QCISD TOTAL ENERGY¶. QCISD CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the quadratic configuration interaction singles and doubles level; of theory. QCISD(T) TOTAL ENERGY¶. QCISD(T) CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the quadratic configuration interaction singles and doubles with; perturbative triples correction level of theory. SAPT DISP ENERGY¶. SAPT ELST ENERGY¶. SAPT EXCH ENERGY¶. SAPT IND ENERGY¶; Respectively, the dispersion, electrostatics, exchange, and induction; components of the total electronic interaction energy",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/glossary_psivariables-1.html:17164,energy,energy,17164,psi4manual/1.2.1/glossary_psivariables-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/glossary_psivariables-1.html,8,['energy'],['energy']
Energy Efficiency,"S (SCF); SCF — Number of colatitude grid points for sphereical potential integration. Type: integer; Default: 360. THICKNESS (SCF); SCF — Thickness (bohr) of a hard-sphere external potential. Type: double; Default: 20.0. TIKHONOW_MAX (PSIMRCC); PSIMRCC — The cycle after which Tikhonow regularization is stopped. Set to zero to allow regularization in all iterations. Type: integer; Default: 5. TIKHONOW_OMEGA (DCFT); DCFT (Expert) — The shift applied to the denominator in the density cumulant update iterations. Type: double; Default: 0.0. TIKHONOW_OMEGA (PSIMRCC); PSIMRCC — The shift to apply to the denominators, {it c.f.} Taube and Bartlett, JCP, 130, 144112 (2009). Type: double; Default: 0.0. TIKHONOW_TRIPLES (PSIMRCC); PSIMRCC (Expert) — Do use Tikhonow regularization in (T) computations?. Type: boolean; Default: false. TILE_SZ (SCF); SCF (Expert) — The tile size for the distributed matrices. Type: integer; Default: 512. TPDM (DCFT); DCFT (Expert) — Controls whether to compute unrelaxed two-particle density matrix at the end of the energy computation. Type: boolean; Default: false. TPDM (DETCI); DETCI — Do compute two-particle density matrix if not otherwise required?. Type: boolean; Default: false. TPDM_ABCD_TYPE (OCC); OCC — How to take care of the TPDM VVVV-block. The COMPUTE option means it will be computed via an IC/OOC algoritm. The DIRECT option (default) means it will not be computed and stored, instead its contribution will be directly added to Generalized-Fock Matrix. Type: string; Possible Values: DIRECT, COMPUTE; Default: DIRECT. TPDM_ADD_REF (TRANSQT); TRANSQT — Do add reference contribution to TPDM?. Type: boolean; Default: false. TPDM_FILE (TRANSQT); TRANSQT — MO-basis two-particle density matrix file. Type: integer; Default: PSIF_MO_TPDM. TPDM_PRINT (DETCI); DETCI — Do print the two-particle density matrix? (Warning: large tensor). Type: boolean; Default: false. TRIPLES_ALGORITHM (PSIMRCC); PSIMRCC — The type of algorithm to use for (T) computations. ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/autodoc_glossary_options_c-1.html:127983,energy,energy,127983,psi4manual/4.0b4/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/autodoc_glossary_options_c-1.html,4,['energy'],['energy']
Energy Efficiency,"S REFERENCE ENERGY; CBS CORRELATION ENERGY; CURRENT ENERGY; CURRENT REFERENCE ENERGY; CURRENT CORRELATION ENERGY. Caution; Some features are not yet implemented. Buy a developer a coffee. Not all methods hooked in through PSI variables, configuration interaction and arbitrary order MP in particular.; No scheme defaults for given basis zeta number, so scheme must be specified explicitly.; No way to tell function to boost fitting basis size for all calculations.; No way to extrapolate def2 family basis sets; Need to add more extrapolation schemes. As represented in the equation below, a CBS energy method is defined in several; sequential stages (scf, corl, delta, delta2, delta3, delta4, delta5) covering treatment; of the reference total energy, the correlation energy, a delta correction to the; correlation energy, and a second delta correction, etc.. Each is activated by its; stage_wfn keyword and is only allowed if all preceding stages are active. Here, is an energy or energy extrapolation scheme, and the following also hold. A translation of this ungainly equation to example [5] below is as; follows. In words, this is a double- and triple-zeta 2-point; Helgaker-extrapolated CCSD(T) coupled-cluster correlation correction; appended to a triple- and quadruple-zeta 2-point; Helgaker-extrapolated MP2 correlation energy appended to a SCF/aug-cc-pVQZ; reference energy. Energy Methods; The presence of a stage_wfn keyword is the indicator to incorporate; (and check for stage_basis and stage_scheme keywords) and compute; that stage in defining the CBS energy.; The cbs() function requires, at a minimum, name='scf' and scf_basis; keywords to be specified for reference-step only jobs and name and; corl_basis keywords for correlated jobs.; The following energy methods have been set up for cbs(). scf; mp2; mp2.5; mp3; mp4(sdq); mp4; omp2. omp3; ocepa; cepa0; cepa(0); cepa(1); cepa(3); acpf. aqcc; qcisd; cc2; ccsd; fno-df-ccsd; bccd; cc3. qcisd(t); ccsd(t); fno-df-ccsd(t); bccd(t);",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/cbs-1.html:1913,energy,energy,1913,psi4manual/4.0b5/cbs-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/cbs-1.html,4,['energy'],['energy']
Energy Efficiency,"S""); psi4.set_global_option(""DF_INTS_IO"", ""SAVE""); psi4.print_out(""""""\n\t==> IP Fitting SCF: Burn-in <==\n""""""); E, wfn = energy('scf', return_wfn=True, molecule=molecule, **kwargs); psi4.set_global_option(""DF_INTS_IO"", ""LOAD""). # Determine HOMO, to determine mult1; eps_a = wfn.epsilon_a(); eps_b = wfn.epsilon_b(); if Na == Nb:; HOMO = -Nb; elif Nb == 0:; HOMO = Na; else:; E_a = eps_a[int(Na - 1)]; E_b = eps_b[int(Nb - 1)]; if E_a >= E_b:; HOMO = Na; else:; HOMO = -Nb. Na1 = Na;; Nb1 = Nb;; if HOMO > 0:; Na1 = Na1 - 1;; else:; Nb1 = Nb1 - 1;. charge1 = charge0 + 1;; mult1 = Na1 - Nb1 + 1. omegas = []; E0s = []; E1s = []; kIPs = []; IPs = []; types = []. # Right endpoint; psi4.set_global_option('DFT_OMEGA', omega_r). # Neutral; if read:; psi4.set_global_option(""GUESS"", ""READ""); p4util.copy_file_to_scratch(read180, 'psi', 'ot', 180). molecule.set_molecular_charge(charge0); molecule.set_multiplicity(mult0); psi4.print_out(""""""\n\t==> IP Fitting SCF: Neutral, Right Endpoint <==\n""""""); E0r, wfn = energy('scf', return_wfn=True, molecule=molecule, **kwargs); eps_a = wfn.epsilon_a(); eps_b = wfn.epsilon_b(); E_HOMO = 0.0;; if Nb == 0:; E_HOMO = eps_a[int(Na - 1)]; else:; E_a = eps_a[int(Na - 1)]; E_b = eps_b[int(Nb - 1)]; if E_a >= E_b:; E_HOMO = E_a; else:; E_HOMO = E_b; E_HOMOr = E_HOMO; psi4.IO.change_file_namespace(180, ""ot"", ""neutral""). # Cation; if read:; psi4.set_global_option(""GUESS"", ""READ""); p4util.copy_file_to_scratch(read180, 'psi', 'ot', 180). molecule.set_molecular_charge(charge1); molecule.set_multiplicity(mult1); psi4.print_out(""""""\n\t==> IP Fitting SCF: Cation, Right Endpoint <==\n""""""); E1r = energy('scf', molecule=molecule, **kwargs); psi4.IO.change_file_namespace(180, ""ot"", ""cation""). IPr = E1r - E0r;; kIPr = -E_HOMOr;; delta_r = IPr - kIPr;. if IPr > kIPr:; message = (""""""\n***IP Fitting Error: Right Omega limit should have kIP > IP""""""); raise ValidationError(message). omegas.append(omega_r); types.append('Right Limit'); E0s.append(E0r); E1s.append(E1r); IP",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/frac.html:13641,energy,energy,13641,psi4manual/1.0.0/_modules/frac.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/frac.html,1,['energy'],['energy']
Energy Efficiency,"S')). # Call dmrcc, directing all screen output to the output file; try:; if psi4.outfile_name() == 'stdout':; retcode = subprocess.call('dmrcc', shell=True); else:; retcode = subprocess.call('dmrcc >> ' + current_directory + '/' + psi4.outfile_name(), shell=True). if retcode < 0:; print('MRCC was terminated by signal %d' % -retcode, file=sys.stderr); exit(1); elif retcode > 0:; print('MRCC errored %d' % retcode, file=sys.stderr); exit(1). except OSError as e:; print('Execution failed: %s' % e, file=sys.stderr); exit(1). # Restore the OMP_NUM_THREADS that the user set.; if omp_num_threads_found == True:; if psi4.has_option_changed('MRCC', 'MRCC_OMP_NUM_THREADS') == True:; os.environ['OMP_NUM_THREADS'] = omp_num_threads_user. # Scan iface file and grab the file energy.; e = 0.0; for line in file('iface'):; fields = line.split(); m = fields[1]; try:; e = float(fields[5]); if m == ""MP(2)"":; m = ""MP2""; psi4.set_variable(m + ' TOTAL ENERGY', e); psi4.set_variable(m + ' CORRELATION ENERGY', e - vscf); except ValueError:; continue. # The last 'e' in iface is the one the user requested.; psi4.set_variable('CURRENT ENERGY', e); psi4.set_variable('CURRENT CORRELATION ENERGY', e - vscf). # Load the iface file; iface = open('iface', 'r'); iface_contents = iface.read(). # Delete mrcc tempdir; os.chdir('..'); try:; # Delete unless we're told not to; if (keep == False and not('path' in kwargs)):; shutil.rmtree(mrcc_tmpdir); except OSError as e:; print('Unable to remove MRCC temporary directory %s' % e, file=sys.stderr); exit(1). # Revert to previous current directory location; os.chdir(current_directory). # Reopen output file; psi4.reopen_outfile(). # If we're told to keep the files or the user provided a path, do nothing.; if (keep != False or ('path' in kwargs)):; psi4.print_out('\nMRCC scratch files have been kept.\n'); psi4.print_out('They can be found in ' + mrcc_tmpdir). # Dump iface contents to output; psi4.print_out('\n'); p4util.banner('Full results from MRCC'); psi4.prin",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/proc.html:62482,ENERGY,ENERGY,62482,psi4manual/4.0b5/_modules/proc.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/proc.html,1,['ENERGY'],['ENERGY']
Energy Efficiency,"S); GLOBALS — When several modules can compute the same methods and the default routing is not suitable, this targets a module. CCENERGY covers CCHBAR, etc. OCC covers OCC and DFOCC. Type: string; Possible Values: CCENERGY, DETCI, DFMP2, FNOCC, OCC; Default: No Default. QC_TYPE (DCFT); DCFT — Controls the type of the quadratically-convergent algorithm (effective for ALGORITHM = QC). If set to TWOSTEP the Newton-Raphson equations are only solved for the orbital updates, the cumulant is updated using the standard Jacobi algorithm. If set to SIMULTANEOUS both cumulant and orbitals are updated in a single Newton-Raphson step. Type: string; Possible Values: TWOSTEP, SIMULTANEOUS; Default: SIMULTANEOUS. QCHF (DFOCC); DFOCC — Do perform a QCHF computation?. Type: boolean; Default: false. QCHF (SCF); SCF — Do perform a QCHF computation?. Type: boolean; Default: false. QMEFP (EFP); EFP (Expert) — Do turn on QM/EFP terms?. Type: boolean; Default: false. QMEFP_ELST (EFP); EFP — Do include electrostatics energy term in QM/EFP computation?. Type: boolean; Default: true. QMEFP_POL (EFP); EFP — Do include polarization energy term in EFP computation?. Type: boolean; Default: true. R4S (DETCI); DETCI (Expert) — Do restrict strings with \(e-\) in RAS IV? Useful to reduce the number of strings required if MIXED4=true, as in a split-virutal CISD[TQ] computation. If more than one electron is in RAS IV, then the holes in RAS I cannot exceed the number of particles in RAS III + RAS IV (i.e., EX_LEVEL), or else the string is discarded. Type: boolean; Default: false. R_CONVERGENCE (CCENERGY); CCENERGY — Convergence criterion for wavefunction (change) in CC amplitude equations. Type: conv double; Default: 1e-7. R_CONVERGENCE (CCEOM); CCEOM — Convergence criterion for norm of the residual vector in the Davidson algorithm for CC-EOM. Type: conv double; Default: 1e-6. R_CONVERGENCE (CCLAMBDA); CCLAMBDA — Convergence criterion for wavefunction (change) in CC lambda-amplitude equations. Type: con",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/autodoc_glossary_options_c-1.html:188021,energy,energy,188021,psi4manual/1.1.0/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/autodoc_glossary_options_c-1.html,2,['energy'],['energy']
Energy Efficiency,"S); GLOBALS — When several modules can compute the same methods and the default routing is not suitable, this targets a module. CCENERGY covers CCHBAR, etc. OCC covers OCC and DFOCC. Type: string; Possible Values: CCENERGY, DETCI, DFMP2, FNOCC, OCC; Default: No Default. QC_TYPE (DCFT); DCFT — Controls the type of the quadratically-convergent algorithm (effective for ALGORITHM = QC). If set to TWOSTEP the Newton-Raphson equations are only solved for the orbital updates, the cumulant is updated using the standard Jacobi algorithm. If set to SIMULTANEOUS both cumulant and orbitals are updated in a single Newton-Raphson step. Type: string; Possible Values: TWOSTEP, SIMULTANEOUS; Default: SIMULTANEOUS. QCHF (DFOCC); DFOCC — Do perform a QCHF computation?. Type: boolean; Default: false. QCHF (SCF); SCF — Do perform a QCHF computation?. Type: boolean; Default: false. QMEFP (EFP); EFP (Expert) — Do turn on QM/EFP terms?. Type: boolean; Default: false. QMEFP_ELST (EFP); EFP — Do include electrostatics energy term in QM/EFP computation?. Type: boolean; Default: true. QMEFP_POL (EFP); EFP — Do include polarization energy term in EFP computation?. Type: boolean; Default: true. R4S (DETCI); DETCI (Expert) — Do restrict strings with in RAS IV? Useful to reduce the number of strings required if MIXED4=true, as in a split-virutal CISD[TQ] computation. If more than one electron is in RAS IV, then the holes in RAS I cannot exceed the number of particles in RAS III + RAS IV (i.e., EX_LEVEL), or else the string is discarded. Type: boolean; Default: false. R_CONVERGENCE (CCENERGY); CCENERGY — Convergence criterion for wavefunction (change) in CC amplitude equations. Type: conv double; Default: 1e-7. R_CONVERGENCE (CCEOM); CCEOM — Convergence criterion for norm of the residual vector in the Davidson algorithm for CC-EOM. Type: conv double; Default: 1e-6. R_CONVERGENCE (CCLAMBDA); CCLAMBDA — Convergence criterion for wavefunction (change) in CC lambda-amplitude equations. Type: conv doubl",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_glossary_options_c-1.html:188346,energy,energy,188346,psi4manual/1.0.0/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_glossary_options_c-1.html,2,['energy'],['energy']
Energy Efficiency,"S-CCSD TOTAL ENERGY¶. SCS-CCSD CORRELATION ENERGY¶; The total electronic energy [Eh] and correlation energy component [Eh]; for the CCSD-like method formed by reweighting CCSD DOUBLES ENERGY; by 1.27 opposite-spin and 1.13 same-spin contributions, with; any singles carried along. SCS-MP2 TOTAL ENERGY¶. SCS-MP2 CORRELATION ENERGY¶; The total electronic energy [Eh] and correlation energy component [Eh]; for the MP2-like method formed by reweighting MP2 DOUBLES ENERGY; by 6/5 opposite-spin and 1/3 same-spin contributions, with; any singles carried along. SCS-MP2-VDW TOTAL ENERGY¶. SCS-MP2-VDW CORRELATION ENERGY¶; The total electronic energy [Eh] and correlation energy component [Eh]; for the MP2-like method formed by reweighting MP2 DOUBLES ENERGY; by 1.28 opposite-spin and 0.50 same-spin contributions, with; any singles carried along. DOI: 10.1080/00268970802641242. SCS(N)-MP2 TOTAL ENERGY¶. SCS(N)-MP2 CORRELATION ENERGY¶; The total electronic energy [Eh] and correlation energy component [Eh]; for the MP2-like method formed by reweighting MP2 DOUBLES ENERGY; by 0 opposite-spin and 1.76 same-spin contributions, with; any singles carried along. doi: 10.1021/ct6002737. SCS(N)-OMP2 CORRELATION ENERGY¶. SCS(N)-OMP2 TOTAL ENERGY¶. SCSN-OMP2 CORRELATION ENERGY¶. SCSN-OMP2 TOTAL ENERGY¶; Two spellings of a discontinued QCVariable that may still appear; because the code is frozen pending an update. SCS-OMP2 TOTAL ENERGY¶. SCS-OMP2 CORRELATION ENERGY¶; The total electronic energy [Eh] and correlation energy component [Eh]; for the OMP2-like method formed by reweighting OMP2 DOUBLES ENERGY; by 6/5 opposite-spin and 1/3 same-spin contributions, with; any singles carried along. SCS-MP3 TOTAL ENERGY¶. SCS-MP3 CORRELATION ENERGY¶; The total electronic energy [Eh] and correlation energy component [Eh]; for the MP3-like method formed by reweighting the difference between; MP3 DOUBLES ENERGY and MP2 DOUBLES ENERGY; by 0.25, atop the SCS-MP2 energy, with any singles carried along. SCS-O",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/glossary_psivariables-1.html:44964,energy,energy,44964,psi4manual/1.4.0/glossary_psivariables-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/glossary_psivariables-1.html,10,['energy'],['energy']
Energy Efficiency,"S-OMP2 cc-pVDZ geometry optimization for the H2O molecule. fsapt-d; Tests SAPT0-D corrections, with a variety of damping functions/parameters. matrix1; An example of using BLAS and LAPACK calls directly from the Psi input file, demonstrating matrix multiplication, eigendecomposition, Cholesky decomposition and LU decomposition. These operations are performed on vectors and matrices provided from the Psi library. mints-helper; A general test of the MintsHelper function. cc10; ROHF-CCSD cc-pVDZ energy for the \(^2\Sigma^+\) state of the CN radical. olccd3; OLCCD cc-pVDZ energy with ROHF initial guess for the NO radical. pywrap-freq-e-sowreap; Finite difference of energies frequency, run in sow/reap mode. dfmp2-3; DF-MP2 cc-pVDZ frozen core gradient of benzene, computed at the DF-SCF cc-pVDZ geometry. cepa2; cc-pvdz H2O Test ACPF Energy/Properties. cc34; RHF-CCSD/cc-pVDZ energy of H2O partitioned into pair energy contributions. mints8; Patch of a glycine with a methyl group, to make alanine, then DF-SCF energy calculation with the cc-pVDZ basis set. psimrcc-sp1; Mk-MRCCSD single point. \(^3 \Sigma ^-\) O2 state described using the Ms = 0 component of the triplet. Uses ROHF triplet orbitals. density-screen-1; RHF Density Matrix based-Integral Screening Test for water. fnocc7; Test fnocc with linear dependencies. sapt5; SAPT0 aug-cc-pVTZ computation of the charge transfer energy of the water dimer. fsapt-ext-abc; FSAPT with external charge on trimer. isapt1; This test case shows an example of running and analyzing an FI-SAPT0/jun-cc-pvdz computation for 2,4-pentanediol (targeting the intramolecular hydrogen bond between the two hydroxyl groups). mints2; A test of the basis specification. A benzene atom is defined using a ZMatrix containing dummy atoms and various basis sets are assigned to different atoms. The symmetry of the molecule is automatically lowered to account for the different basis sets. olccd-grad1; OLCCD cc-pVDZ gradient for the H2O molecule. scf-level-shif",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/autodoc_testsuite_corepsi4.html:45557,energy,energy,45557,psi4manual/1.6.x/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/autodoc_testsuite_corepsi4.html,2,['energy'],['energy']
Energy Efficiency,"S. MKL_ROOT. MO_DIIS_NUM_VECS (DFOCC). (OCC). mo_erf_eri() psi4.core.MintsHelper method, [1], [2]. mo_eri() psi4.core.MintsHelper method, [1], [2]. mo_f12() psi4.core.MintsHelper method, [1], [2]. mo_f12_double_commutator() psi4.core.MintsHelper method, [1], [2]. mo_f12_squared() psi4.core.MintsHelper method, [1], [2]. mo_f12g12() psi4.core.MintsHelper method, [1], [2]. MO_MAXITER (DFOCC). (OCC). MO_READ (MCSCF). (OCC). MO_RELAX (DCFT). mo_spin_eri() psi4.core.MintsHelper method, [1], [2]. MO_STEP_MAX (DFOCC). (OCC). mo_transform() psi4.core.MintsHelper method, [1], [2]. MO_WRITE (OCC). MODULE (CPHF). moFa() psi4.core.ROHF method, [1], [2]. moFb() psi4.core.ROHF method, [1], [2]. moFeff() psi4.core.ROHF method, [1], [2]. MOGRAD_DAMPING (OCC). Molden. molden() in module psi4. in module psi4.driver. MOLDEN_WITH_VIRTUAL (GLOBALS). MOLDEN_WRITE (DCFT). (DFOCC). (SCF). MoldenWriter class in psi4.core, [1]. molecular_charge() psi4.core.Molecule method, [1], [2]. molecule. ; EFP. PubChem. charge. ghost. isotope. multiple fragments. multiple in input file. multiplicity. no_reorient. setting keywords. specification. symmetry. units. Molecule class in psi4.core, [1]. molecule() psi4.core.BasisSet method, [1], [2]. psi4.core.CIWavefunction method, [1]. psi4.core.CUHF method, [1]. psi4.core.HF method, [1]. psi4.core.RHF method, [1]. psi4.core.ROHF method, [1]. psi4.core.UHF method, [1]. psi4.core.Wavefunction method, [1], [2]. molecule_get_attr() in module psi4.driver. molecule_set_attr() in module psi4.driver. MOM. MOM_OCC (SCF). MOM_START (SCF). MOM_VIR (SCF). MONTAGE. move_to_com() psi4.core.Molecule method, [1], [2]. MOWriter class in psi4.core, [1]. MP2. ; density-fitting. MP2.5CORRELATIONENERGY. MP2.5TOTALENERGY. MP2_AMP_TYPE (DFOCC). MP2_AMPS_PRINT (CCENERGY). MP2_CCSD_METHOD (PSIMRCC). MP2_GUESS (PSIMRCC). MP2_OS_SCALE (CCENERGY). (DFMP2). (DFOCC). (OCC). MP2_SCALE_OS (FNOCC). MP2_SCALE_SS (FNOCC). MP2_SOS_SCALE (DFOCC). (OCC). MP2_SOS_SCALE2 (DFOCC). (OCC). MP2_SS_SCAL",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/genindex-1.html:62200,charge,charge,62200,psi4manual/1.1.0/genindex-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/genindex-1.html,2,['charge'],['charge']
Energy Efficiency,"S/R: Read energy from each displaced geometry output file and save in energies array; elif (opt_mode.lower() == 'reap'):; E = 0.0; exec(banners). try:; freagent = open('%s.out' % (rfile), 'r'); except IOError:; ValidationError('Aborting upon output file \'%s.out\' not found.\n' % (rfile)); return 0.0; else:; while 1:; line = freagent.readline(); if not line:; if E == 0.0:; ValidationError('Aborting upon output file \'%s.out\' has no %s RESULT line.\n' % (rfile, 'GRADIENT')); break; s = line.split(); if (len(s) != 0) and (s[0:3] == ['GRADIENT', 'RESULT:', 'computation']):; if int(s[3]) != opt_linkage:; raise ValidationError('Output file \'%s.out\' has linkage %s incompatible with master.in linkage %s.'; % (rfile, str(s[3]), str(opt_linkage))); if s[6] != str(n + 1):; raise ValidationError('Output file \'%s.out\' has nominal affiliation %s incompatible with item %s.'; % (rfile, s[6], str(n + 1))); if (s[8:10] == ['electronic', 'energy']):; E = float(s[10]); PsiMod.print_out('%s RESULT: electronic energy = %20.12f\n' % ('GRADIENT', E)); freagent.close(); energies.append(E). # S/R: Quit sow after writing files; if (opt_mode.lower() == 'sow'):; optstash.restore(); return 0.0. if (opt_mode.lower() == 'reap'):; PsiMod.set_variable('CURRENT ENERGY', energies[-1]). # Obtain the gradient; PsiMod.fd_1_0(energies); ; # The last item in the list is the reference energy, return it; optstash.restore(); return energies[-1]. [docs]def property(name, **kwargs):; r""""""Function to compute various properties. :aliases: prop(). :returns: none. .. caution:: Some features are not yet implemented. Buy a developer a coffee. - This function at present handles property functions only for CC methods.; Consult the keywords sections for other modules for further property capabilities. +-------------------------+---------------------------------------------------------------------------------------+; | name | calls method |; +=========================+===============================================",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/_modules/driver.html:40494,energy,energy,40494,psi4manual/4.0b4/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/driver.html,2,['energy'],['energy']
Energy Efficiency,"S/R: Read energy from each displaced geometry output file and save in energies array; elif (opt_mode.lower() == 'reap'):; E = 0.0; exec(banners). try:; freagent = open('%s.out' % (rfile), 'r'); except IOError:; ValidationError('Aborting upon output file \'%s.out\' not found.\n' % (rfile)); return 0.0; else:; while 1:; line = freagent.readline(); if not line:; if E == 0.0:; ValidationError('Aborting upon output file \'%s.out\' has no %s RESULT line.\n' % (rfile, 'GRADIENT')); break; s = line.split(); if (len(s) != 0) and (s[0:3] == ['GRADIENT', 'RESULT:', 'computation']):; if int(s[3]) != opt_linkage:; raise ValidationError('Output file \'%s.out\' has linkage %s incompatible with master.in linkage %s.'; % (rfile, str(s[3]), str(opt_linkage))); if s[6] != str(n + 1):; raise ValidationError('Output file \'%s.out\' has nominal affiliation %s incompatible with item %s.'; % (rfile, s[6], str(n + 1))); if (s[8:10] == ['electronic', 'energy']):; E = float(s[10]); PsiMod.print_out('%s RESULT: electronic energy = %20.12f\n' % ('GRADIENT', E)); freagent.close(); energies.append(E). # S/R: Quit sow after writing files; if (opt_mode.lower() == 'sow'):; return 0.0. if (opt_mode.lower() == 'reap'):; PsiMod.set_variable('CURRENT ENERGY', energies[-1]). # Obtain the gradient; PsiMod.fd_1_0(energies). # The last item in the list is the reference energy, return it; return energies[-1]. [docs]def property(name, **kwargs):; r""""""Function to compute various properties. :aliases: prop(). :returns: none. .. caution:: Some features are not yet implemented. Buy a developer a coffee. - This function at present handles property functions only for CC methods.; Consult the keywords sections for other modules for further property capabilities. +-------------------------+---------------------------------------------------------------------------------------+; | name | calls method |; +=========================+=======================================================================================+;",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/_modules/driver.html:32051,energy,energy,32051,psi4manual/4.0b3/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/_modules/driver.html,2,['energy'],['energy']
Energy Efficiency,"S2; COOKBOOK; DFTD3; DKH; LIBEFP; ERD; GCP; GDMA; GPU_DFCC; JSON; MRCC; PCMSOLVER; PSI4NUMPY; PYTHON; SIMINT; SNSMP2; V2RDM_CASSCF. Sample inputs for PSI4 as distributed are below. Input File; Description. dft-custom-gga; DFT (LDA/GGA) test of custom implementations in: gga_superfuncs.py. mints5; Tests to determine full point group symmetry. Currently, these only matter for the rotational symmetry number in thermodynamic computations. tdscf-5; td-camb3lyp with DiskDF and method/basis specification. scf-cholesky-basis; incremental Cholesky filtered SCF. cc8b; ROHF-CCSD cc-pVDZ frozen-core energy for the \(^2\Sigma^+\) state of the CN radical, with Cartesian input. rasscf-sp; 6-31G** H2O Test RASSCF Energy Point will default to only singles and doubles in the active space. pywrap-basis; SAPT calculation on bimolecular complex where monomers are unspecified so driver auto-fragments it. Basis set and auxiliary basis sets are assigned by atom type. sapt5; SAPT0 aug-cc-pVTZ computation of the charge transfer energy of the water dimer. dfmp2-freq1; DF-MP2 frequency by difference of energies for H2O. mp2-property; MP2 cc-pvDZ properties for Nitrogen oxide. scf-upcast-custom-basis; test scf castup with custom basis sets. scf1; RHF cc-pVQZ energy for the BH molecule, with Cartesian input. cisd-sp-2; 6-31G** H2O Test CISD Energy Point. dlpnomp2-2; comparison of DF-MP2 and DLPNO-MP2 with a CBS extrapolation. cepa2; cc-pvdz H2O Test ACPF Energy/Properties. dfomp2-4; OMP2 cc-pVDZ energy for the NO molecule. fnocc2; Test G2 method for H2O. dfomp3-1; DF-OMP3 cc-pVDZ energy for the H2O molecule. sapt4; SAPT2+(3) aug-cc-pVDZ computation of the formamide dimer interaction energy, using the aug-cc-pVDZ-JKFIT DF basis for SCF and aug-cc-pVDZ-RI for SAPT. This example uses frozen core as well as MP2 natural orbital approximations. omp3-grad1; OMP3 cc-pVDZ gradient for the H2O molecule. opt14; 6-31G(d) optimization of SF4 starting from linear bond angle that is not linear in the optimized ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/testsuite-1.html:1679,charge,charge,1679,psi4manual/1.5.0/testsuite-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/testsuite-1.html,4,"['charge', 'energy']","['charge', 'energy']"
Energy Efficiency,"SAPT EXCH10(S^2) ENERGY; SAPT EXCH11(S^2) ENERGY; SAPT EXCH12(S^2) ENERGY; SAPT HF TOTAL ENERGY; SAPT IND ENERGY; SAPT IND-DISP30 ENERGY; SAPT IND20,R ENERGY; SAPT IND20,U ENERGY; SAPT IND22 ENERGY; SAPT IND30,R ENERGY; SAPT MP2 CORRELATION ENERGY; SAPT SAME-SPIN DISP20 ENERGY; SAPT SAME-SPIN EXCH-DISP20 ENERGY; SAPT TOTAL ENERGY; SAPT0 DISP ENERGY; SAPT0 ELST ENERGY; SAPT0 EXCH ENERGY; SAPT0 IND ENERGY; SAPT0 TOTAL ENERGY; SAPT2 DISP ENERGY; SAPT2 ELST ENERGY; SAPT2 EXCH ENERGY; SAPT2 IND ENERGY; SAPT2 TOTAL ENERGY; SAPT2+ DISP ENERGY; SAPT2+ ELST ENERGY; SAPT2+ EXCH ENERGY; SAPT2+ IND ENERGY; SAPT2+ TOTAL ENERGY; SAPT2+(3) DISP ENERGY; SAPT2+(3) ELST ENERGY; SAPT2+(3) EXCH ENERGY; SAPT2+(3) IND ENERGY; SAPT2+(3) TOTAL ENERGY; SAPT2+(3)(CCD) DISP ENERGY; SAPT2+(3)(CCD) ELST ENERGY; SAPT2+(3)(CCD) EXCH ENERGY; SAPT2+(3)(CCD) IND ENERGY; SAPT2+(3)(CCD) TOTAL ENERGY; SAPT2+(3)(CCD)DMP2 DISP ENERGY; SAPT2+(3)(CCD)DMP2 ELST ENERGY; SAPT2+(3)(CCD)DMP2 EXCH ENERGY; SAPT2+(3)(CCD)DMP2 IND ENERGY; SAPT2+(3)(CCD)DMP2 TOTAL ENERGY; SAPT2+(3)DMP2 DISP ENERGY; SAPT2+(3)DMP2 ELST ENERGY; SAPT2+(3)DMP2 EXCH ENERGY; SAPT2+(3)DMP2 IND ENERGY; SAPT2+(3)DMP2 TOTAL ENERGY; SAPT2+(CCD) DISP ENERGY; SAPT2+(CCD) ELST ENERGY; SAPT2+(CCD) EXCH ENERGY; SAPT2+(CCD) IND ENERGY; SAPT2+(CCD) TOTAL ENERGY; SAPT2+(CCD)DMP2 DISP ENERGY; SAPT2+(CCD)DMP2 ELST ENERGY; SAPT2+(CCD)DMP2 EXCH ENERGY; SAPT2+(CCD)DMP2 IND ENERGY; SAPT2+(CCD)DMP2 TOTAL ENERGY; SAPT2+3 DISP ENERGY; SAPT2+3 ELST ENERGY; SAPT2+3 EXCH ENERGY; SAPT2+3 IND ENERGY; SAPT2+3 TOTAL ENERGY; SAPT2+3(CCD) DISP ENERGY; SAPT2+3(CCD) ELST ENERGY; SAPT2+3(CCD) EXCH ENERGY; SAPT2+3(CCD) IND ENERGY; SAPT2+3(CCD) TOTAL ENERGY; SAPT2+3(CCD)DMP2 DISP ENERGY; SAPT2+3(CCD)DMP2 ELST ENERGY; SAPT2+3(CCD)DMP2 EXCH ENERGY; SAPT2+3(CCD)DMP2 IND ENERGY; SAPT2+3(CCD)DMP2 TOTAL ENERGY; SAPT2+3DMP2 DISP ENERGY; SAPT2+3DMP2 ELST ENERGY; SAPT2+3DMP2 EXCH ENERGY; SAPT2+3DMP2 IND ENERGY; SAPT2+3DMP2 TOTAL ENERGY; SAPT2+DMP2 DISP ENERGY; SAPT2+DMP2 ELST ENERGY; ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/autodir_psivariables/module__sapt-1.html:1864,ENERGY,ENERGY,1864,psi4manual/1.4.0/autodir_psivariables/module__sapt-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_psivariables/module__sapt-1.html,9,['ENERGY'],['ENERGY']
Energy Efficiency,"SAPT IND-DISP30 ENERGY; SAPT IND20,R ENERGY; SAPT IND20,U ENERGY; SAPT IND22 ENERGY; SAPT IND30,R ENERGY; SAPT MP2 CORRELATION ENERGY; SAPT SAME-SPIN DISP20 ENERGY; SAPT SAME-SPIN EXCH-DISP20 ENERGY; SAPT TOTAL ENERGY; SAPT0 DISP ENERGY; SAPT0 ELST ENERGY; SAPT0 EXCH ENERGY; SAPT0 IND ENERGY; SAPT0 TOTAL ENERGY; SAPT2 DISP ENERGY; SAPT2 ELST ENERGY; SAPT2 EXCH ENERGY; SAPT2 IND ENERGY; SAPT2 TOTAL ENERGY; SAPT2+ DISP ENERGY; SAPT2+ ELST ENERGY; SAPT2+ EXCH ENERGY; SAPT2+ IND ENERGY; SAPT2+ TOTAL ENERGY; SAPT2+(3) DISP ENERGY; SAPT2+(3) ELST ENERGY; SAPT2+(3) EXCH ENERGY; SAPT2+(3) IND ENERGY; SAPT2+(3) TOTAL ENERGY; SAPT2+(3)(CCD) DISP ENERGY; SAPT2+(3)(CCD) ELST ENERGY; SAPT2+(3)(CCD) EXCH ENERGY; SAPT2+(3)(CCD) IND ENERGY; SAPT2+(3)(CCD) TOTAL ENERGY; SAPT2+(3)(CCD)DMP2 DISP ENERGY; SAPT2+(3)(CCD)DMP2 ELST ENERGY; SAPT2+(3)(CCD)DMP2 EXCH ENERGY; SAPT2+(3)(CCD)DMP2 IND ENERGY; SAPT2+(3)(CCD)DMP2 TOTAL ENERGY; SAPT2+(3)DMP2 DISP ENERGY; SAPT2+(3)DMP2 ELST ENERGY; SAPT2+(3)DMP2 EXCH ENERGY; SAPT2+(3)DMP2 IND ENERGY; SAPT2+(3)DMP2 TOTAL ENERGY; SAPT2+(CCD) DISP ENERGY; SAPT2+(CCD) ELST ENERGY; SAPT2+(CCD) EXCH ENERGY; SAPT2+(CCD) IND ENERGY; SAPT2+(CCD) TOTAL ENERGY; SAPT2+(CCD)DMP2 DISP ENERGY; SAPT2+(CCD)DMP2 ELST ENERGY; SAPT2+(CCD)DMP2 EXCH ENERGY; SAPT2+(CCD)DMP2 IND ENERGY; SAPT2+(CCD)DMP2 TOTAL ENERGY; SAPT2+3 DISP ENERGY; SAPT2+3 ELST ENERGY; SAPT2+3 EXCH ENERGY; SAPT2+3 IND ENERGY; SAPT2+3 TOTAL ENERGY; SAPT2+3(CCD) DISP ENERGY; SAPT2+3(CCD) ELST ENERGY; SAPT2+3(CCD) EXCH ENERGY; SAPT2+3(CCD) IND ENERGY; SAPT2+3(CCD) TOTAL ENERGY; SAPT2+3(CCD)DMP2 DISP ENERGY; SAPT2+3(CCD)DMP2 ELST ENERGY; SAPT2+3(CCD)DMP2 EXCH ENERGY; SAPT2+3(CCD)DMP2 IND ENERGY; SAPT2+3(CCD)DMP2 TOTAL ENERGY; SAPT2+3DMP2 DISP ENERGY; SAPT2+3DMP2 ELST ENERGY; SAPT2+3DMP2 EXCH ENERGY; SAPT2+3DMP2 IND ENERGY; SAPT2+3DMP2 TOTAL ENERGY; SAPT2+DMP2 DISP ENERGY; SAPT2+DMP2 ELST ENERGY; SAPT2+DMP2 EXCH ENERGY; SAPT2+DMP2 IND ENERGY; SAPT2+DMP2 TOTAL ENERGY; SSAPT0 DISP ENERGY; SSAPT0 ELST ENERGY; SS",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/autodir_psivariables/module__sapt-1.html:1978,ENERGY,ENERGY,1978,psi4manual/1.4.0/autodir_psivariables/module__sapt-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_psivariables/module__sapt-1.html,9,['ENERGY'],['ENERGY']
Energy Efficiency,"SAPT uses a separate set of keywords.; The following keywords are relevant for higher-order SAPT. Basic Keywords for Higher-order SAPT¶. BASIS¶. Primary basis set, describes the monomer molecular orbitals. Type: string; Possible Values: basis string; Default: No Default. DF_BASIS_SAPT¶. Auxiliary basis set for SAPT density fitting computations. Defaults to a RI basis. Type: string; Possible Values: basis string; Default: No Default. FREEZE_CORE¶. Specifies how many core orbitals to freeze in correlated computations. TRUE will default to freezing the standard default number of core orbitals. For heavier elements, there can be some ambiguity in how many core orbitals to freeze; in such cases, SMALL picks the most conservative standard setting (freezes fewer orbitals), and LARGE picks the least conservative standard setting (freezes more orbitals). More precise control over the number of frozen orbitals can be attained by using the keywords NUM_FROZEN_DOCC (gives the total number of orbitals to freeze, program picks the lowest-energy orbitals) or FROZEN_DOCC (gives the number of orbitals to freeze per irreducible representation). Type: string; Possible Values: FALSE, TRUE, SMALL, LARGE; Default: FALSE. PRINT¶. The amount of information to print to the output file for the sapt module. For 0, only the header and final results are printed. For 1, (recommended for large calculations) some intermediate quantities are also printed. Type: integer; Default: 1. Advanced Keywords for Higher-order SAPT¶. INTS_TOLERANCE¶. Minimum absolute value below which all three-index DF integrals and those contributing to four-index integrals are neglected. The default is conservative, but there isn’t much to be gained from loosening it, especially for higher-order SAPT. Type: conv double; Default: 1.0e-12. SAPT_MEM_CHECK¶. Do force SAPT2 and higher to die if it thinks there isn’t enough memory? Turning this off is ill-advised. Type: boolean; Default: true. DEBUG¶. The amount of information to",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/sapt-1.html:9715,energy,energy,9715,psi4manual/4.0b3/sapt-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/sapt-1.html,2,['energy'],['energy']
Energy Efficiency,"SAPT""),; ""RIFIT"", core.get_global_option(""BASIS""),; ref_wfn.basisset().has_puream()); ref_wfn.set_basisset(""DF_BASIS_SAPT"", sapt_basis). minao = core.BasisSet.build(ref_wfn.molecule(), ""BASIS"", core.get_global_option(""MINAO_BASIS"")); ref_wfn.set_basisset(""MINAO"", minao). # Turn of dispersion for -d; if ""-d"" in name.lower():; core.set_local_option(""FISAPT"", ""FISAPT_DO_FSAPT_DISP"", False). fisapt_wfn = core.FISAPT(ref_wfn); from .sapt import fisapt_proc; fisapt_wfn.compute_energy(external_potentials=kwargs.get(""external_potentials"", None)). # Compute -D dispersion; if ""-d"" in name.lower():; proc_util.sapt_empirical_dispersion(name, ref_wfn). optstash.restore(); return ref_wfn. def run_mrcc(name, **kwargs):; """"""Function that prepares environment and input files; for a calculation calling Kallay's MRCC code. """""". # Check to see if we really need to run the SCF code.; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs); vscf = core.variable('SCF TOTAL ENERGY'). # The parse_arbitrary_order method provides us the following information; # We require that level be provided. level is a dictionary; # of settings to be passed to core.mrcc; if not('level' in kwargs):; raise ValidationError('level parameter was not provided.'). level = kwargs['level']. # Fullname is the string we need to search for in iface; fullname = level['fullname']. # User can provide 'keep' to the method.; # When provided, do not delete the MRCC scratch directory.; keep = False; if 'keep' in kwargs:; keep = kwargs['keep']. # Save current directory location; current_directory = os.getcwd(). # Find environment by merging PSIPATH and PATH environment variables; lenv = {; 'PATH': ':'.join([os.path.abspath(x) for x in os.environ.get('PSIPATH', '').split(':') if x != '']) + \; ':' + os.environ.get('PATH'),; 'LD_LIBRARY_PATH': os.environ.get('LD_LIBRARY_PATH'); }; # Filter out None values as subprocess will fault on them; lenv = {k: v for k, v in lenv.items() if v is not",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html:147807,ENERGY,ENERGY,147807,psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,1,['ENERGY'],['ENERGY']
Energy Efficiency,"SAPT: Symmetry-Adapted Perturbation Theory¶; Code author: Edward G. Hohenstein and Rob M. Parrish; Section author: Edward G. Hohenstein; Module: Keywords, PSI Variables, LIBSAPT_SOLVER. Warning; In rare cases with systems having a high degree of symmetry,; Psi4 gives (very obviously) wrong answers for SAPT computations; when the specification is in Z-matrix format. Use a Cartesian representation; to avoid this problem. Caution; In early versions (notably Psi4 alpha circa 2011; and before), frozen core was implemented incompletely and for; only selected terms. Comparisons with papers published using early; Psi4 SAPT code may show discrepancies of 0.01-0.10 kcal/mol in; individual terms, particularly and . Caution; January 28th 2016, the default for all NAT_ORBS options; was changed to true. Hence the code now by default uses natural; orbital truncation to speed up the evaluation of energy terms; wherever possible, according to literature recommendations.; In early July 2016, some total sapt energy psivars were renamed. Symmetry-adapted perturbation theory (SAPT) provides a means of directly; computing the noncovalent interaction between two molecules, that is, the; interaction energy is determined without computing the total energy of the; monomers or dimer. In addition, SAPT provides a decomposition of the; interaction energy into physically meaningful components: i.e.,; electrostatic, exchange, induction, and dispersion terms. In SAPT, the; Hamiltonian of the dimer is partitioned into contributions from each; monomer and the interaction. Here, the Hamiltonian is written as a sum of the usual monomer Fock; operators, , the fluctuation potential of each monomer, , and the; interaction potential, . The monomer Fock operators, , are; treated as the zeroth-order Hamiltonian and the interaction energy is; evaluated through a perturbative expansion of , , and .; Through first-order in , electrostatic and exchange interactions are; included; induction and dispersion first ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/sapt-1.html:1205,energy,energy,1205,psi4manual/1.0.0/sapt-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/sapt-1.html,2,['energy'],['energy']
Energy Efficiency,"SAPT_LEVEL¶. The level of theory for SAPT. Type: string; Possible Values: SAPT0, SAPT2, SAPT2+, SAPT2+3; Default: SAPT0. SAPT_MEM_CHECK¶. Do force SAPT2 and higher to die if it thinks there isn’t enough memory? Turning this off is ill-advised. Type: boolean; Default: true. SAPT_MEM_SAFETY¶. Memory safety. Type: double; Default: 0.9. SAPT(DFT)¶. SAPT_DFT_DO_DHF¶. Compute the Delta-HF correction?. Type: boolean; Default: true. SAPT_DFT_GRAC_DETERMINATION¶. How is the GRAC correction determined?. Type: string; Possible Values: INPUT; Default: INPUT. SAPT_DFT_GRAC_SHIFT_A¶. Monomer A GRAC shift?. Type: double; Default: 0.0. SAPT_DFT_GRAC_SHIFT_B¶. Monomer B GRAC shift?. Type: double; Default: 0.0. Expert SAPT(HF)¶. COUPLED_INDUCTION¶. Solve the CPHF equations to compute coupled induction and exchange-induction. These are not available for ROHF, and the option is automatically false in this case. In all other cases, coupled induction is strongly recommended. Only turn it off if the induction energy is not going to be used. Type: boolean; Default: true. DO_CCD_DISP¶. Do CCD dispersion correction in SAPT2+, SAPT2+(3) or SAPT2+3?. Type: boolean; Default: false. DO_IND_EXCH_SINF¶. For SAPT(DFT) computes the S^inf Exchange-Induction terms. Type: boolean; Default: false. DO_MBPT_DISP¶. Do MBPT dispersion correction in SAPT2+, SAPT2+(3) or SAPT2+3, if also doing CCD?. Type: boolean; Default: true. DO_THIRD_ORDER¶. Do compute third-order corrections?. Type: boolean; Default: false. SAPT0_E10¶. For SAPT0 only, compute only first-order electrostatics and exchange. The integrals are computed before any terms, so all integrals will be computed even if they are not needed for the requested term. Type: boolean; Default: false. SAPT0_E20DISP¶. For SAPT0 only, compute only second-order induction The integrals are computed before any terms, so all integrals will be computed even if they are not needed for the requested term. Type: boolean; Default: false. SAPT0_E20IND¶. For SAPT0 only, c",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/autodir_options_c/module__sapt-1.html:5390,energy,energy,5390,psi4manual/1.3.2/autodir_options_c/module__sapt-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/autodir_options_c/module__sapt-1.html,4,['energy'],['energy']
Energy Efficiency,"SAVE'). optstash2 = p4util.OptionsState(['NUM_FROZEN_DOCC']); core.set_global_option(""NUM_FROZEN_DOCC"", nfc_ab); core.timer_on(""SAPT: Dimer SCF""); dimer_wfn = scf_helper('RHF', molecule=sapt_dimer, **kwargs); core.timer_off(""SAPT: Dimer SCF""). if do_delta_mp2:; select_mp2(""mp2"", ref_wfn=dimer_wfn, **kwargs); mp2_corl_interaction_e = core.variable('MP2 CORRELATION ENERGY'). optstash2.restore(); if (sapt_basis == 'dimer') and (ri == 'DF'):; core.set_global_option('DF_INTS_IO', 'LOAD'). # Compute Monomer A wavefunction; if (sapt_basis == 'dimer') and (ri == 'DF'):; core.IO.change_file_namespace(97, 'dimer', 'monomerA'). core.IO.set_default_namespace('monomerA'); core.print_out('\n'); p4util.banner('Monomer A HF'); core.print_out('\n'). core.timer_on(""SAPT: Monomer A SCF""); monomerA_wfn = scf_helper('RHF', molecule=monomerA, **kwargs); core.timer_off(""SAPT: Monomer A SCF""). if do_delta_mp2:; select_mp2(""mp2"", ref_wfn=monomerA_wfn, **kwargs); mp2_corl_interaction_e -= core.variable('MP2 CORRELATION ENERGY'). # Compute Monomer B wavefunction; if (sapt_basis == 'dimer') and (ri == 'DF'):; core.IO.change_file_namespace(97, 'monomerA', 'monomerB'); core.IO.set_default_namespace('monomerB'); core.print_out('\n'); p4util.banner('Monomer B HF'); core.print_out('\n'). core.timer_on(""SAPT: Monomer B SCF""); monomerB_wfn = scf_helper('RHF', molecule=monomerB, **kwargs); core.timer_off(""SAPT: Monomer B SCF""). # Delta MP2; if do_delta_mp2:; select_mp2(""mp2"", ref_wfn=monomerB_wfn, **kwargs); mp2_corl_interaction_e -= core.variable('MP2 CORRELATION ENERGY'); core.set_variable(""SAPT MP2 CORRELATION ENERGY"", mp2_corl_interaction_e) # P::e SAPT; core.set_global_option('DF_INTS_IO', df_ints_io). if core.get_option('SCF', 'REFERENCE') == 'RHF':; core.IO.change_file_namespace(psif.PSIF_SAPT_MONOMERA, 'monomerA', 'dimer'); core.IO.change_file_namespace(psif.PSIF_SAPT_MONOMERB, 'monomerB', 'dimer'). core.IO.set_default_namespace('dimer'); core.set_local_option('SAPT', 'E_CONVERGENCE', 10e-10); ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:148391,ENERGY,ENERGY,148391,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,2,['ENERGY'],['ENERGY']
Energy Efficiency,"SCALE2¶. Spin-opposite scaling (SOS) value for optimized-MP2 orbitals. Type: double; Default: 1.2. NAT_ORBS¶. Do compute natural orbitals?. Type: boolean; Default: false. OCC_ORBS_PRINT¶. Do print OCC orbital energies?. Type: boolean; Default: false. TPDM_ABCD_TYPE¶. How to take care of the TPDM VVVV-block. The COMPUTE option means it will be computed via an IC/OOC algoritm. The DIRECT option (default) means it will not be computed and stored, instead its contribution will be directly added to Generalized-Fock Matrix. Type: string; Possible Values: DIRECT, COMPUTE; Default: DIRECT. DO_DIIS¶. Do apply DIIS extrapolation?. Type: boolean; Default: true. DO_LEVEL_SHIFT¶. Do apply level shifting?. Type: boolean; Default: true. OCC: Conventional Møller–Plesset Perturbation Theories¶; Module: Keywords, PSI Variables, OCC; PSI4 also has a non-density-fitted MP2 algorithm for RHF and UHF; energies and gradients. The; density-fitted module DFMP2 is always the default, so to access the; conventional MP2 code, set MP2_TYPE to conv and call as usual; energy('mp2')/optimize('mp2'). Basic Keywords¶. MP2_TYPE¶. Algorithm to use for non-OO MP2 computation. Type: string; Possible Values: DF, CONV; Default: DF. MP2_OS_SCALE¶. MP2 opposite-spin scaling value. Type: double; Default: 6.0/5.0. MP2_SS_SCALE¶. MP2 same-spin scaling value. Type: double; Default: 1.0/3.0. Non-orbital-optimized counterparts to higher order MPn methods are also; available. Summarizing from tables above, the following methods are; available and can be controlled through OCC keywards. Name; Calls Method; Energy; Gradient; Reference. conv-mp2; MP2; Y; Y; RHF/ROHF/UHF. mp3; MP3; Y; Y; RHF/UHF. mp2.5; MP2.5; Y; Y; RHF/UHF. cepa0; CEPA(0) (identical to Linearized CCD); Y; Y; RHF/UHF. Table Of Contents. OCC: Orbital-Optimized Coupled-Cluster and Møller–Plesset Perturbation Theories; Introduction; Theory; Convergence Problems; Methods; Basic Keywords; E_CONVERGENCE; R_CONVERGENCE; RMS_MOGRAD_CONVERGENCE; MAX_MOGRAD_CON",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/occ-1.html:10833,energy,energy,10833,psi4manual/4.0b5/occ-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/occ-1.html,2,['energy'],['energy']
Energy Efficiency,"SCALE2¶. Spin-opposite scaling (SOS) value for optimized-MP2 orbitals. Type: double; Default: 1.2. NAT_ORBS¶. Do compute natural orbitals?. Type: boolean; Default: false. OCC_ORBS_PRINT¶. Do print OCC orbital energies?. Type: boolean; Default: false. TPDM_ABCD_TYPE¶. How to take care of the TPDM VVVV-block. The COMPUTE option means it will be computed via an IC/OOC algoritm. The DIRECT option (default) means it will not be computed and stored, instead its contribution will be directly added to Generalized-Fock Matrix. Type: string; Possible Values: DIRECT, COMPUTE; Default: DIRECT. DO_DIIS¶. Do apply DIIS extrapolation?. Type: boolean; Default: true. DO_LEVEL_SHIFT¶. Do apply level shifting?. Type: boolean; Default: true. OCC: Conventional Møller–Plesset Perturbation Theories¶; Module: Keywords, PSI Variables, OCC; PSI4 also has a non-density-fitted MP2 algorithm for RHF and UHF; energies and gradients. The; density-fitted module DFMP2 is always the default, so to access the; conventional MP2 code, set MP2_TYPE to conv and call as usual; energy('mp2')/optimize('mp2'). Basic Keywords¶. MP2_TYPE¶. Algorithm to use for non-OO MP2 computation. Type: string; Possible Values: DF, CONV; Default: DF. MP2_OS_SCALE¶. MP2 opposite-spin scaling value. Type: double; Default: 6.0/5.0. MP2_SS_SCALE¶. MP2 same-spin scaling value. Type: double; Default: 1.0/3.0. Non-orbital-optimized counterparts to higher order MPn methods are also; available. Summarizing from tables above, the following methods are; available and can be controlled through OCC keywards. Name; Calls Method; Energy; Gradient; Reference. conv-mp2; MP2; Y; Y; RHF/ROHF/UHF. mp3; MP3; Y; Y; RHF/UHF. mp2.5; MP2.5; Y; Y; RHF/UHF. cepa0; CEPA(0) (identical to Linearized CCD); Y; Y; RHF/UHF. Table Of Contents. OCC: Orbital-Optimized Coupled-Cluster and Møller–Plesset Perturbation Theories; Introduction; Theory; Methods; Basic Keywords; E_CONVERGENCE; R_CONVERGENCE; RMS_MOGRAD_CONVERGENCE; MAX_MOGRAD_CONVERGENCE; MO_MAXITER; ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/occ-1.html:10236,energy,energy,10236,psi4manual/4.0b4/occ-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/occ-1.html,2,['energy'],['energy']
Energy Efficiency,"SCF and aug-cc-pVDZ-RI for SAPT. mints4; A demonstration of mixed Cartesian/ZMatrix geometry specification, using variables, for the benzene-hydronium complex. Atoms can be placed using ZMatrix coordinates, whether they belong to the same fragment or not. Note that the Cartesian specification must come before the ZMatrix entries because the former define absolute positions, while the latter are relative. tu4-h2o-freq; Optimization followed by frequencies H2O HF/cc-pVDZ. cbs-parser; mtd/basis syntax examples. dft-reference; MP2 with a PBE0 reference computation. mp2p5-grad1; MP2.5 cc-pVDZ gradient for the H2O molecule. dfmp2-grad3; DF-MP2 cc-pVDZ gradients for the H2O molecule. dfomp2p5-1; DF-OMP2.5 cc-pVDZ energy for the H2O molecule. omp3-3; OMP3 cc-pVDZ energy with B3LYP initial guess for the NO radical. dfomp3-2; DF-OMP3 cc-pVDZ energy for the H2O+ cation. pubchem1; Benzene vertical singlet-triplet energy difference computation, using the PubChem database to obtain the initial geometry, which is optimized at the HF/STO-3G level, before computing single point energies at the RHF, UHF and ROHF levels of theory. opt2; SCF DZ allene geometry optimization, with Cartesian input, first in c2v symmetry, then in Cs symmetry from a starting point with a non-linear central bond angle. dfomp2-3; OMP2 cc-pVDZ energy for the H2O molecule. omp3-2; OMP3 cc-pVDZ energy with ROHF initial guess for the NO radical. ocepa3; OCEPA cc-pVDZ energy with ROHF initial guess for the NO radical. cisd-h2o+-1; 6-31G** H2O+ Test CISD Energy Point. mcscf1; ROHF 6-31G** energy of the \(^{3}B_1\) state of CH2, with Z-matrix input. The occupations are specified explicitly. dfomp2p5-grad2; DF-OMP2.5 cc-pVDZ gradients for the H2O+ cation. freq-isotope2; Vibrational and thermo analysis of several water isotopologs. Demonstrates Hessian reuse for different temperatures, pressures, and isotopologs. props3; DF-SCF cc-pVDZ multipole moments of benzene, up to 7th order and electrostatic potentials evaluate",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/autodoc_testsuite_corepsi4-1.html:20830,energy,energy,20830,psi4manual/1.2.1/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/autodoc_testsuite_corepsi4-1.html,8,['energy'],['energy']
Energy Efficiency,"SCF', 'D_CONVERGENCE', 6); else:; PsiMod.set_local_option('SCF', 'D_CONVERGENCE', 10). # Set post-scf convergence criteria (global will cover all correlated modules); if not PsiMod.has_global_option_changed('E_CONVERGENCE'):; if not procedures['energy'][lowername] == run_scf and not procedures['energy'][lowername] == run_dft:; PsiMod.set_global_option('E_CONVERGENCE', 8). returnvalue = procedures['property'][lowername](lowername, **kwargs). except KeyError:; raise ValidationError('Property method %s not available.' % (lowername)). optstash.restore(); return returnvalue. ## Aliases ##; prop = property. [docs]def optimize(name, **kwargs):; r""""""Function to perform a geometry optimization. :aliases: opt(). :returns: (*float*) Total electronic energy of optimized structure in Hartrees. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`CURRENT ENERGY <CURRENTENERGY>`. .. note:: Analytic gradients area available for all methods in the table; below. Optimizations with other methods in the energy table proceed; by finite differences. .. _`table:grad_gen`:. +-------------------------+---------------------------------------------------------------------------------------+; | name | calls method |; +=========================+=======================================================================================+; | scf | Hartree--Fock (HF) or density functional theory (DFT) :ref:`[manual] <sec:scf>` |; +-------------------------+---------------------------------------------------------------------------------------+; | dcft | density cumulant functional theory :ref:`[manual] <sec:dcft>` |; +-------------------------+---------------------------------------------------------------------------------------+; | mp2 | 2nd-order Moller-Plesset perturbation theory (MP2) :ref:`[manual] <sec:dfmp2>` |; +-------------------------+---------------------------------------------------------------------------------------+; | df-mp2 | MP2 with density fitting :ref:`[manual] <sec:dfmp2>` |; +-",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/_modules/driver.html:45368,energy,energy,45368,psi4manual/4.0b4/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/driver.html,2,['energy'],['energy']
Energy Efficiency,"SCF: Burn-in', **kwargs); core.set_local_option(""SCF"", ""DF_INTS_IO"", ""LOAD""). if not wfn.functional().is_x_lrc():; raise ValidationError(""""""Not sensible to optimize omega for non-long-range-correction functional.""""""). # Determine HOMO, to determine mult1; eps_a = wfn.epsilon_a(); eps_b = wfn.epsilon_b(); if Na == Nb:; HOMO = -Nb; elif Nb == 0:; HOMO = Na; else:; E_a = eps_a.np[int(Na - 1)]; E_b = eps_b.np[int(Nb - 1)]; if E_a >= E_b:; HOMO = Na; else:; HOMO = -Nb. Na1 = Na; Nb1 = Nb; if HOMO > 0:; Na1 -= 1; else:; Nb1 -= 1. charge1 = charge0 + 1; mult1 = Na1 - Nb1 + 1. omegas = []; E0s = []; E1s = []; kIPs = []; IPs = []; types = []. # Right endpoint; core.set_local_option('SCF', 'DFT_OMEGA', omega_r). # Neutral; if read:; core.set_local_option(""SCF"", ""GUESS"", ""READ""); p4util.copy_file_to_scratch(read180, 'psi', 'ot', 180). molecule.set_molecular_charge(charge0); molecule.set_multiplicity(mult0); E0r, wfn = driver.energy('scf', dft_functional=name, return_wfn=True, molecule=molecule,; banner='IP Fitting SCF: Neutral, Right Endpoint', **kwargs); eps_a = wfn.epsilon_a(); eps_b = wfn.epsilon_b(); if Nb == 0:; E_HOMO = eps_a.np[int(Na - 1)]; else:; E_a = eps_a.np[int(Na - 1)]; E_b = eps_b.np[int(Nb - 1)]; E_HOMO = max(E_a, E_b); E_HOMOr = E_HOMO; core.IO.change_file_namespace(180, ""ot"", ""neutral""). # Cation; if read:; core.set_local_option(""SCF"", ""GUESS"", ""READ""); p4util.copy_file_to_scratch(read180, 'psi', 'ot', 180). molecule.set_molecular_charge(charge1); molecule.set_multiplicity(mult1); E1r = driver.energy('scf', dft_functional=name, molecule=molecule,; banner='IP Fitting SCF: Cation, Right Endpoint', **kwargs); core.IO.change_file_namespace(180, ""ot"", ""cation""). IPr = E1r - E0r; kIPr = -E_HOMOr; delta_r = IPr - kIPr. if IPr > kIPr:; raise ValidationError(""""""\n***IP Fitting Error: Right Omega limit should have kIP > IP: {} !> {}"""""".format(kIPr, IPr)). omegas.append(omega_r); types.append('Right Limit'); E0s.append(E0r); E1s.append(E1r); IPs.append(IPr); kIPs.append(",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/frac.html:17882,energy,energy,17882,psi4manual/1.7.x/_modules/psi4/driver/frac.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/frac.html,8,['energy'],['energy']
Energy Efficiency,SCS-OLCCD TOTAL ENERGY; CUSTOM SCS-OMP2 CORRELATION ENERGY; CUSTOM SCS-OMP2 TOTAL ENERGY; CUSTOM SCS-OMP3 CORRELATION ENERGY; CUSTOM SCS-OMP3 TOTAL ENERGY; CUSTOM SCS-OREMP2 CORRELATION ENERGY; CUSTOM SCS-OREMP2 TOTAL ENERGY; CUSTOM SCS-REMP2 CORRELATION ENERGY; CUSTOM SCS-REMP2 TOTAL ENERGY; LCCD CORRELATION ENERGY; LCCD DOUBLES ENERGY; LCCD OPPOSITE-SPIN CORRELATION ENERGY; LCCD SAME-SPIN CORRELATION ENERGY; LCCD SINGLES ENERGY; LCCD TOTAL ENERGY; MP2 CORRELATION ENERGY; MP2 DOUBLES ENERGY; MP2 OPPOSITE-SPIN CORRELATION ENERGY; MP2 SAME-SPIN CORRELATION ENERGY; MP2 SINGLES ENERGY; MP2 TOTAL ENERGY; MP2.5 CORRELATION ENERGY; MP2.5 DOUBLES ENERGY; MP2.5 OPPOSITE-SPIN CORRELATION ENERGY; MP2.5 SAME-SPIN CORRELATION ENERGY; MP2.5 SINGLES ENERGY; MP2.5 TOTAL ENERGY; MP3 CORRELATION ENERGY; MP3 DOUBLES ENERGY; MP3 OPPOSITE-SPIN CORRELATION ENERGY; MP3 SAME-SPIN CORRELATION ENERGY; MP3 SINGLES ENERGY; MP3 TOTAL ENERGY; OLCCD CORRELATION ENERGY; OLCCD OPPOSITE-SPIN CORRELATION ENERGY; OLCCD REFERENCE CORRECTION ENERGY; OLCCD SAME-SPIN CORRELATION ENERGY; OLCCD TOTAL ENERGY; OMP2 CORRELATION ENERGY; OMP2 OPPOSITE-SPIN CORRELATION ENERGY; OMP2 REFERENCE CORRECTION ENERGY; OMP2 SAME-SPIN CORRELATION ENERGY; OMP2 TOTAL ENERGY; OMP2.5 CORRELATION ENERGY; OMP2.5 OPPOSITE-SPIN CORRELATION ENERGY; OMP2.5 REFERENCE CORRECTION ENERGY; OMP2.5 SAME-SPIN CORRELATION ENERGY; OMP2.5 TOTAL ENERGY; OMP3 CORRELATION ENERGY; OMP3 OPPOSITE-SPIN CORRELATION ENERGY; OMP3 REFERENCE CORRECTION ENERGY; OMP3 SAME-SPIN CORRELATION ENERGY; OMP3 TOTAL ENERGY; OREMP2 CORRELATION ENERGY; OREMP2 OPPOSITE-SPIN CORRELATION ENERGY; OREMP2 REFERENCE CORRECTION ENERGY; OREMP2 SAME-SPIN CORRELATION ENERGY; OREMP2 TOTAL ENERGY; REMP2 CORRELATION ENERGY; REMP2 DOUBLES ENERGY; REMP2 OPPOSITE-SPIN CORRELATION ENERGY; REMP2 SAME-SPIN CORRELATION ENERGY; REMP2 SINGLES ENERGY; REMP2 TOTAL ENERGY; SCS(N)-MP2 CORRELATION ENERGY; SCS(N)-MP2 TOTAL ENERGY; SCS-MP2 CORRELATION ENERGY; SCS-MP2 TOTAL ENERGY; SCS-MP2-VDW COR,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/autodir_psivariables/module__occ.html:1352,ENERGY,ENERGY,1352,psi4manual/1.7.x/autodir_psivariables/module__occ.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/autodir_psivariables/module__occ.html,68,['ENERGY'],['ENERGY']
Energy Efficiency,"SD gradient calculation. """"""; optstash = p4util.OptionsState(; ['CCDENSITY', 'XI'],; ['CCDENSITY', 'ZETA'],; ['CCLAMBDA', 'ZETA'],; ['DERTYPE'],; ['CCDENSITY', 'WFN'],; ['CCLAMBDA', 'WFN']). psi4.set_global_option('DERTYPE', 'FIRST'). if (name.lower() == 'eom-ccsd'):; psi4.set_local_option('CCLAMBDA', 'WFN', 'EOM_CCSD'); psi4.set_local_option('CCDENSITY', 'WFN', 'EOM_CCSD'); run_eom_cc(name, **kwargs). psi4.set_local_option('CCLAMBDA', 'ZETA', 'FALSE'); psi4.set_local_option('CCDENSITY', 'ZETA', 'FALSE'); psi4.set_local_option('CCDENSITY', 'XI', 'TRUE'); psi4.cclambda(); psi4.ccdensity(); psi4.set_local_option('CCLAMBDA', 'ZETA', 'TRUE'); psi4.set_local_option('CCDENSITY', 'ZETA', 'TRUE'); psi4.set_local_option('CCDENSITY', 'XI', 'FALSE'); psi4.cclambda(); psi4.ccdensity(); psi4.deriv(). optstash.restore(). [docs]def run_adc(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; an algebraic diagrammatic construction calculation. .. caution:: Get rid of active molecule lines- should be handled in energy. """"""; if (psi4.get_option('ADC', 'REFERENCE') != 'RHF'):; raise ValidationError('ADC requires reference RHF'). # Bypass routine scf if user did something special to get it to converge; if not (('bypass_scf' in kwargs) and yes.match(str(kwargs['bypass_scf']))):; scf_helper(name, **kwargs). return psi4.adc(). [docs]def run_dft(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a density-functional-theory calculation. """"""; optstash = p4util.OptionsState(; ['SCF', 'DFT_FUNCTIONAL'],; ['SCF', 'REFERENCE'],; ['SCF', 'SCF_TYPE'],; ['DF_BASIS_MP2'],; ['DFMP2', 'MP2_OS_SCALE'],; ['DFMP2', 'MP2_SS_SCALE']). # Alter default algorithm; if not psi4.has_option_changed('SCF', 'SCF_TYPE'):; psi4.set_local_option('SCF', 'SCF_TYPE', 'DF'). psi4.set_local_option('SCF', 'DFT_FUNCTIONAL', name). user_ref = psi4.get_option('SCF', 'REFERENCE'); if (user_ref == 'RHF'):; psi4.set_local_option('SCF', 'REFERENCE', 'RKS'); elif (user_ref == 'UHF'):; psi4.s",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/proc.html:37032,energy,energy,37032,psi4manual/4.0b5/_modules/proc.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/proc.html,2,['energy'],['energy']
Energy Efficiency,"SD gradient call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module in ['', 'CCENERGY']:; func = run_ccenergy_gradient; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc_gradient; elif reference == 'UHF':; if mtd_type == 'CONV':; if module in ['', 'CCENERGY']:; func = run_ccenergy_gradient; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc_gradient; elif reference == 'ROHF':; if mtd_type == 'CONV':; if module in ['', 'CCENERGY']:; func = run_ccenergy_gradient. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_fnoccsd_t_(name, **kwargs):; """"""Function selecting the algorithm for a FNO-CCSD(T) energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module in ['', 'FNOCC']:; func = run_fnocc; elif mtd_type == 'DF':; if module in ['', 'FNOCC']:; func = run_fnodfcc; elif mtd_type == 'CD':; if module in ['', 'FNOCC']:; func = run_fnodfcc. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_ccsd_t_(name, **kwargs):; """"""Function selecting the algorithm for a CCSD(T) energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:24830,energy,energy,24830,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,8,['energy'],['energy']
Energy Efficiency,"SD'. PsiMod.set_local_option('FNOCC', 'CEPA_LEVEL', cepa_level). # override symmetry for fno-cepa; if (PsiMod.get_option('FNOCC','NAT_ORBS')):; molecule = PsiMod.get_active_molecule(); user_pg = molecule.schoenflies_symbol(); molecule.reset_point_group('c1'); molecule.update_geometry(); if user_pg != 'c1':; PsiMod.print_out(' FNOCC does not make use of molecular symmetry, further calculations in C1 point group.\n'). # throw an exception for open-shells; if (PsiMod.get_option('SCF','REFERENCE') != 'RHF' ):; raise ValidationError(""Error: %s requires \""reference rhf\""."" % lowername). PsiMod.set_local_option('TRANSQT2', 'WFN', 'CCSD'); scf_helper(name, **kwargs). # If the scf type is DF, then the AO integrals were never generated; if PsiMod.get_option('SCF', 'SCF_TYPE') == 'DF':; mints = PsiMod.MintsHelper(); mints.integrals(). if PsiMod.get_option('FNOCC','NAT_ORBS') == False:; PsiMod.set_local_option('TRANSQT2', 'WFN', 'CCSD'); PsiMod.transqt2(). # run cepa; PsiMod.fnocc(). # one-electron properties; if PsiMod.get_option('FNOCC', 'DIPMOM'):; if cepa_level == ""CEPA(1)"" or cepa_level == ""CEPA(3)"":; PsiMod.print_out(""\n""); PsiMod.print_out("" Error: one-electron properties not implemented for %s\n"" % lowername); PsiMod.print_out(""\n""); elif PsiMod.get_option('FNOCC','NAT_ORBS'):; PsiMod.print_out(""\n""); PsiMod.print_out("" Error: one-electron properties not implemented for %s\n"" % lowername); PsiMod.print_out(""\n""); else:; oeprop('DIPOLE','QUADRUPOLE','MULLIKEN_CHARGES','NO_OCCUPATIONS',title = cepa_level). # restore symmetry for fno-cepa; if (PsiMod.get_option('FNOCC','NAT_ORBS')):; molecule.reset_point_group(user_pg); molecule.update_geometry(). # restore options ; optstash.restore(). return PsiMod.get_variable(""CURRENT ENERGY""). Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    ; PSI4 [beta4] » ; Module code ». © Copyright 2013, The Psi4 Project.; Last updated on Mar 20, 2014.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/_modules/proc.html:79253,ENERGY,ENERGY,79253,psi4manual/4.0b4/_modules/proc.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/proc.html,1,['ENERGY'],['ENERGY']
Energy Efficiency,"SD(AT) energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); mtd_type = core.get_global_option('CC_TYPE'); module = core.get_global_option('QC_MODULE'); # Considering only [df]occ/ccenergy. func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module in ['', 'CCENERGY']:; func = run_ccenergy; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc. if func is None:; raise ManagedMethodError(['select_ccsd_at_', name, 'CC_TYPE', mtd_type, reference, module]). if name.lower() == ""a-ccsd(t)"":; pass; elif name.lower() in [""ccsd(at)"", ""lambda-ccsd(t)""]:; core.print_out(f""""""\nMethod ""{name.lower()}"" has been regularized to ""a-ccsd(t)"" for QCVariables.""""""); name = ""a-ccsd(t)"". if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_cisd(name, **kwargs):; """"""Function selecting the algorithm for a CISD energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); mtd_type = core.get_global_option('CI_TYPE'); module = core.get_global_option('QC_MODULE'); # Considering only detci/fnocc. func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module == 'DETCI':; func = run_detci; elif module in ['', 'FNOCC']:; func = run_cepa; elif reference == 'ROHF':; if mtd_type == 'CONV':; if module in ['', 'DETCI']:; func = run_detci. if func is None:; raise ManagedMethodError(['select_cisd', name, 'CI_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_mp4(name, **kwargs):; """"""Function selecting the algorithm for a MP4 energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); mtd_type = core.get_global_option('MP_TYPE'); module = core.get_global_option('QC_MODULE'); # Conside",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html:27846,energy,energy,27846,psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,6,['energy'],['energy']
Energy Efficiency,"SD(T) cc-pVDZ frozen-core energy for the state of the CN radical, with Z-matrix input. pubchem1; Benzene vertical singlet-triplet energy difference computation, using the PubChem database to obtain the initial geometry, at the UHF an ROHF levels of theory. cc44; Test case for some of the PSI4 out-of-core codes. The code is given only 2.0 MB of memory, which is insufficient to hold either the A1 or B2 blocks of an ovvv quantity in-core, but is sufficient to hold at least two copies of an oovv quantity in-core. cc35; CC3(ROHF)/cc-pVDZ H2O geom from Olsen et al., JCP 104, 8007 (1996). cc9a; ROHF-CCSD(T) cc-pVDZ energy for the state of the CN radical, with Z-matrix input. cc1; RHF-CCSD 6-31G** all-electron optimization of the H2O molecule. scf4; RHF cc-pVDZ energy for water, automatically scanning the symmetric stretch and bending coordinates using Python’s built-in loop mechanisms. The geometry is apecified using a Z-matrix with variables that are updated during the potential energy surface scan, and then the same procedure is performed using polar coordinates, converted to Cartesian coordinates. cisd-h2o-clpse; 6-31G** H2O Test CISD Energy Point with subspace collapse. dfmp2_2; Density fitted MP2 energy of H2, using density fitted reference and automatic looping over cc-pVDZ and cc-pVTZ basis sets. Results are tabulated using the built in table functions by using the default options and by specifiying the format. cc24; Single point gradient of 1-2B1 state of H2O+ with EOM-CCSD. cc14; ROHF-CCSD/cc-pVDZ CH2 geometry optimization via analytic gradients. cc29; CCSD/cc-pVDZ optical rotation calculation (both gauges) on Cartesian H2O2. dfscf-bz2; Benzene Dimer DF-HF/cc-pVDZ. matrix1; An example of using BLAS and LAPACK calls directly from the Psi input file, demonstrating matrix multiplication, eigendecomposition, Cholesky decomposition and LU decomposition. These operations are performed on vectors and matrices provided from the Psi library. cc36; CC2(RHF)/cc-pVDZ energy of",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/autodoc_testsuite-1.html:14553,energy,energy,14553,psi4manual/4.0b2/autodoc_testsuite-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/autodoc_testsuite-1.html,4,['energy'],['energy']
Energy Efficiency,"SD}^{(1)}}^{\dagger}(\omega-; \mathbf{A_{DD}^{(0)}})^{-1}\mathbf{A_{DS}^{(1)}}]\mathbf{X_{S}}=; \omega\mathbf{X_{S}}.\]; This form of the ADC(2) equation requires 7–10 iterations for; convergence on only one root. But thanks to Newton-Raphson; acceleration,. \[\omega^{n+1}=\omega^{n}-; \frac{\omega^n-\mathbf{X_{S}}(\omega^n)^{\dagger}; [\mathbf{A_{SS}^{(2)}}+; \mathbf{A_{SD}^{(1)}}^{\dagger}(\omega^n-\mathbf{A_{DD}^{(0)}})^{-1}; \mathbf{A_{DS}^{(1)}}]\mathbf{X_{S}}(\omega^n)}{1+\mathbf{X_{S}}; (\omega^n)^{\dagger}[\mathbf{A_{SD}^{(1)}}^{\dagger}; (\omega^n-\mathbf{A_{DD}^{(0)}})^{-2}\mathbf{A_{DS}^{(1)}}]\mathbf{X_{S}}; (\omega^n)}\]; the computational time reduces to shorter than half of the simple iterative; procedure. Construction of the denominator of the second term in the above; equation is less computationally expensive than construction of one \(\sigma\)-vector; with respect to the effective response matrix. The non-iterative excitation energy stated; above is calculated as a diagonal element of the Davidson mini-Hamiltonian matrix in the SEM as,. \[\omega^{Non-Iterative}=; \mathbf{X_{CIS}}^{\dagger}[\mathbf{A_{SS}^{(2)}}+; \mathbf{A_{SD}^{(1)}}^{\dagger}(\omega^{CIS}-\mathbf{A_{DD}^{(0)}})^{-1}; \mathbf{A_{DS}^{(1)}}]\mathbf{X_{CIS}}\]; where \(\omega^{CIS}\) and \(\mathbf{X_{CIS}}\) denote the CIS; excitation energy and wave function, respectively. The explicit form of the; σ-vector is provided in a note accompanying the source code,; in the file psi4/psi4/src/psi4/adc/sigma.pdf. table of contents. ADC: Ab Initio Polarization Propagator; Available ADC methods; Running ADC calculations; REFERENCE; R_CONVERGENCE; NUM_GUESSES; CUTOFF_AMPS_PRINT. Interface to adcc; Built-in ADC(2) code. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Theoretical Methods: SCF to FCI; ADC: Ab Initio Polarization Propagator. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using S",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/adc-1.html:17006,energy,energy,17006,psi4manual/1.4.0/adc-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/adc-1.html,2,['energy'],['energy']
Energy Efficiency,"SD}^{(1)}}^{\dagger}(\omega-; \mathbf{A_{DD}^{(0)}})^{-1}\mathbf{A_{DS}^{(1)}}]\mathbf{X_{S}}=; \omega\mathbf{X_{S}}.\]; This form of the ADC(2) equation requires 7–10 iterations for; convergence on only one root. But thanks to Newton-Raphson; acceleration,. \[\omega^{n+1}=\omega^{n}-; \frac{\omega^n-\mathbf{X_{S}}(\omega^n)^{\dagger}; [\mathbf{A_{SS}^{(2)}}+; \mathbf{A_{SD}^{(1)}}^{\dagger}(\omega^n-\mathbf{A_{DD}^{(0)}})^{-1}; \mathbf{A_{DS}^{(1)}}]\mathbf{X_{S}}(\omega^n)}{1+\mathbf{X_{S}}; (\omega^n)^{\dagger}[\mathbf{A_{SD}^{(1)}}^{\dagger}; (\omega^n-\mathbf{A_{DD}^{(0)}})^{-2}\mathbf{A_{DS}^{(1)}}]\mathbf{X_{S}}; (\omega^n)}\]; the computational time reduces to shorter than half of the simple iterative; procedure. Construction of the denominator of the second term in the above; equation is less computationally expensive than construction of one \(\sigma\)-vector; with respect to the effective response matrix. The non-iterative excitation energy stated; above is calculated as a diagonal element of the Davidson mini-Hamiltonian matrix in the SEM as,. \[\omega^{Non-Iterative}=; \mathbf{X_{CIS}}^{\dagger}[\mathbf{A_{SS}^{(2)}}+; \mathbf{A_{SD}^{(1)}}^{\dagger}(\omega^{CIS}-\mathbf{A_{DD}^{(0)}})^{-1}; \mathbf{A_{DS}^{(1)}}]\mathbf{X_{CIS}}\]; where \(\omega^{CIS}\) and \(\mathbf{X_{CIS}}\) denote the CIS; excitation energy and wave function, respectively. The explicit form of the; σ-vector is provided in a note accompanying the source code,; in the file psi4/psi4/src/psi4/adc/sigma.pdf. table of contents. ADC: Ab Initio Polarization Propagator; Available ADC methods; Running ADC calculations; REFERENCE; R_CONVERGENCE; NUM_GUESSES; CUTOFF_AMPS_PRINT. Interface to adcc; Built-in ADC(2) code. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.5;  · . PSI4. Theoretical Methods: SCF to FCI; ADC: Ab Initio Polarization Propagator. © Copyright 2021, The Psi4 Project.; Last updated on Sunday, 28 November 2021 02:41AM.; Created using S",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/adc-1.html:17006,energy,energy,17006,psi4manual/1.5.0/adc-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/adc-1.html,2,['energy'],['energy']
Energy Efficiency,"SD}^{(1)}}^{\dagger}(\omega-; \mathbf{A_{DD}^{(0)}})^{-1}\mathbf{A_{DS}^{(1)}}]\mathbf{X_{S}}=; \omega\mathbf{X_{S}}.\]; This form of the ADC(2) equation requires 7–10 iterations for; convergence on only one root. But thanks to Newton-Raphson; acceleration,. \[\omega^{n+1}=\omega^{n}-; \frac{\omega^n-\mathbf{X_{S}}(\omega^n)^{\dagger}; [\mathbf{A_{SS}^{(2)}}+; \mathbf{A_{SD}^{(1)}}^{\dagger}(\omega^n-\mathbf{A_{DD}^{(0)}})^{-1}; \mathbf{A_{DS}^{(1)}}]\mathbf{X_{S}}(\omega^n)}{1+\mathbf{X_{S}}; (\omega^n)^{\dagger}[\mathbf{A_{SD}^{(1)}}^{\dagger}; (\omega^n-\mathbf{A_{DD}^{(0)}})^{-2}\mathbf{A_{DS}^{(1)}}]\mathbf{X_{S}}; (\omega^n)}\]; the computational time reduces to shorter than half of the simple iterative; procedure. Construction of the denominator of the second term in the above; equation is less computationally expensive than construction of one \(\sigma\)-vector; with respect to the effective response matrix. The non-iterative excitation energy stated; above is calculated as a diagonal element of the Davidson mini-Hamiltonian matrix in the SEM as,. \[\omega^{Non-Iterative}=; \mathbf{X_{CIS}}^{\dagger}[\mathbf{A_{SS}^{(2)}}+; \mathbf{A_{SD}^{(1)}}^{\dagger}(\omega^{CIS}-\mathbf{A_{DD}^{(0)}})^{-1}; \mathbf{A_{DS}^{(1)}}]\mathbf{X_{CIS}}\]; where \(\omega^{CIS}\) and \(\mathbf{X_{CIS}}\) denote the CIS; excitation energy and wave function, respectively. The explicit form of the; σ-vector is provided in a note accompanying the source code,; in the file psi4/psi4/src/psi4/adc/sigma.pdf. table of contents. ADC: Ab Initio Polarization Propagator; Available ADC methods; Running ADC calculations; REFERENCE; R_CONVERGENCE; NUM_GUESSES; CUTOFF_AMPS_PRINT. Interface to adcc; Built-in ADC(2) code. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Theoretical Methods: SCF to FCI; ADC: Ab Initio Polarization Propagator. © Copyright 2022, The Psi4 Project.; Last updated on Thursday, 19 May 2022 08:57PM.; Created using Sphi",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/adc.html:17264,energy,energy,17264,psi4manual/1.6.x/adc.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/adc.html,1,['energy'],['energy']
Energy Efficiency,"SE); CCRESPONSE — Desired treatment of “weak pairs” in the local-CCSD method. The value of NONE (unique avaliable option) treats weak pairs in the same manner as strong pairs. Type: string; Default: NONE. LOCAL_WEAKP (CCSORT); CCSORT — Desired treatment of “weak pairs” in the local-CCSD method. The value of NONE (unique avaliable option) treats weak pairs in the same manner as strong pairs. Type: string; Default: NONE. LOCK_OCC (DCFT); DCFT (Expert) — Controls whether to force the occupation to be that of the SCF guess. For practical applications only the default must be used. Type: boolean; Default: true. LOCK_SINGLET (PSIMRCC); PSIMRCC — Do lock onto a singlet root?. Type: boolean; Default: false. LSE (DETCI); DETCI — Do use least-squares extrapolation in iterative solution of CI vector?. Type: boolean; Default: false. LSE_COLLAPSE (DETCI); DETCI — Number of iterations between least-squares extrapolations. Type: integer; Default: 3. LSE_TOLERANCE (DETCI); DETCI — Minimum converged energy for least-squares extrapolation to be performed. Type: conv double; Default: 3. M_FILE (TRANSQT); TRANSQT — Output integrals file. Type: integer; Default: 0. MADMP2_SLEEP (DFMP2); DFMP2 (Expert) — A helpful option, used only in debugging the MADNESS version. Type: integer; Default: 0. MAT_NUM_COLUMN_PRINT (GLOBALS); GLOBALS (Expert) — Number of columns to print in calls to Matrix::print_mat. Type: integer; Default: 5. MAX_BUCKETS (TRANSQT); TRANSQT — Maximum buckets. Type: integer; Default: 499. MAX_CCD_DIISVECS (SAPT); SAPT — Maximum number of vectors used in CCD-DIIS. Type: integer; Default: 10. MAX_DISP_G_CONVERGENCE (OPTKING); OPTKING — Convergence criterion for geometry optmization: maximum displacement (internal coordinates, atomic units). Type: conv double; Default: 1.2e-3. MAX_ENERGY_G_CONVERGENCE (OPTKING); OPTKING — Convergence criterion for geometry optmization: maximum energy change. Type: conv double; Default: 1.0e-6. MAX_FORCE_G_CONVERGENCE (OPTKING); OPTKING — Conver",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/autodoc_glossary_options_c-1.html:72173,energy,energy,72173,psi4manual/4.0b5/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodoc_glossary_options_c-1.html,2,['energy'],['energy']
Energy Efficiency,"SE_ALOGRITHM = TWOSTEP). Type: integer; Default: 50. TIKHONOW_OMEGA¶. The shift applied to the denominator in the density cumulant update iterations. Type: double; Default: 0.0. Expert¶. CACHELEVEL¶. Controls how to cache quantities within the DPD library. Type: integer; Default: 2. DCFT_GUESS¶. Whether to read the orbitals from a previous computation, or to compute an MP2 guess. Type: string; Possible Values: CC, BCC, MP2; Default: MP2. IGNORE_TAU¶. Controls whether to ignore terms containing non-idempotent contribution to OPDM or not (for debug puproses only). For practical applications only the default must be used. Type: boolean; Default: false. INTS_TOLERANCE¶. Minimum absolute value below which integrals are neglected. Type: conv double; Default: 1e-14. LOCK_OCC¶. Controls whether to force the occupation to be that of the SCF guess. For practical applications only the default must be used. Type: boolean; Default: true. MO_RELAX¶. Controls whether to relax the orbitals during the energy computation or not (for debug puproses only). For practical applications only the default must be used. Type: boolean; Default: true. QC_COUPLING¶. Controls whether to include the coupling terms in the DCFT electronic Hessian (for ALOGRITHM = QC only). Type: boolean; Default: true. RELAX_GUESS_ORBITALS¶. Controls whether to relax the guess orbitals by taking the guess density cumulant and performing orbital update on the first macroiteration (for ALOGRITHM = TWOSTEP only). Type: boolean; Default: false. RELAX_TAU¶. Controls whether to relax tau during the cumulant updates or not. Type: boolean; Default: true. STABILITY_ADD_VECTORS¶. The number of vectors that can be added simultaneously into the subspace for Davidson’s diagonalization in stability check. Type: integer; Default: 20. STABILITY_AUGMENT_SPACE_TOL¶. The value of the rms of the residual in Schmidt orthogonalization which is used as a threshold for augmenting the vector subspace in stability check. Type: conv double; De",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/autodir_options_c/module__dcft-1.html:4060,energy,energy,4060,psi4manual/4.0b3/autodir_options_c/module__dcft-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/module__dcft-1.html,4,['energy'],['energy']
Energy Efficiency,SFunctions; ROHF; run_gdma; SADGuess; SalcComponent; sapt; SaveType; scalar_variable; scalar_variables; scatter; scfgrad; scfhess; set_active_molecule; set_array_variable; set_datadir; set_global_option; set_global_option_python; set_local_option; set_local_option_python; set_memory_bytes; set_num_threads; set_output_file; set_psi_file_prefix; set_scalar_variable; set_variable; ShellInfo; Slice; SOBasisSet; SOMCSCF; SuperFunctional; SymmetryOperation; test_matrix_dpd_interface; ThreeCenterOverlapInt; timer_off; timer_on; TLaplaceDenominator; TracelessQuadrupoleInt; triplet; tstart; tstop; TwoBodyAOInt; TwoElectronInt; UHF; UKSFunctions; variable; variables; VBase; Vector; Vector3; version; Wavefunction; activate; AtomicComputer; banner; basis_helper; cbs; compare_fchkfiles; compare_fcidumps; compare_moldenfiles; ConvergenceError; copy_file_from_scratch; copy_file_to_scratch; create_plugin; cubeprop; docs_table_link; dynamic_variable_bind; EmpiricalDispersion; energies_from_fcidump; energy; fchk; fcidump; fcidump_from_file; find_approximate_string_matches; freq; frequencies; frequency; gdma; geometry; get_memory; gradient; hessian; ipi_broker; levenshtein; ManagedMethodError; mdi_run; message_box; MissingMethodError; molden; molecule_get_attr; molecule_set_attr; oeprop; opt; OptimizationConvergenceError; optimize; optimize_geometric; all_casings; array_to_matrix; banner; basis_helper; block_diagonal_array; cg_solver; compare_fchkfiles; compare_fcidumps; compare_moldenfiles; copy_file_from_scratch; copy_file_to_scratch; cubeprop; davidson_solver; DIIS; docs_table_link; drop_duplicates; energies_from_fcidump; expand_psivars; fcidump; fcidump_from_file; find_approximate_string_matches; format_molecule_for_input; format_options_for_input; free_atom_volumes; Gaussian; get_memory; get_psifile; getattr_ignorecase; hamiltonian_solver; hold_options_state; import_ignorecase; InPsight; kwargs_lower; levenshtein; Lineshape; Lorentzian; mat2arr; message_box; oeprop; OptionsState; ,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/index-wcopy.html:792775,energy,energy,792775,index-wcopy.html,https://psicode.org,https://psicode.org/index-wcopy.html,1,['energy'],['energy']
Energy Efficiency,SFunctions; ROHF; run_gdma; SADGuess; SalcComponent; sapt; SaveType; scalar_variable; scalar_variables; scatter; scfgrad; scfhess; set_active_molecule; set_array_variable; set_datadir; set_global_option; set_global_option_python; set_local_option; set_local_option_python; set_memory_bytes; set_num_threads; set_output_file; set_psi_file_prefix; set_scalar_variable; set_variable; ShellInfo; Slice; SOBasisSet; SOMCSCF; SuperFunctional; SymmetryOperation; test_matrix_dpd_interface; ThreeCenterOverlapInt; timer_off; timer_on; TLaplaceDenominator; TracelessQuadrupoleInt; triplet; tstart; tstop; TwoBodyAOInt; TwoElectronInt; UHF; UKSFunctions; variable; variables; VBase; Vector; Vector3; version; Wavefunction; activate; AtomicComputer; banner; basis_helper; cbs; compare_fchkfiles; compare_fcidumps; compare_moldenfiles; ConvergenceError; copy_file_from_scratch; copy_file_to_scratch; create_plugin; cubeprop; docs_table_link; dynamic_variable_bind; EmpiricalDispersion; energies_from_fcidump; energy; fchk; fcidump; fcidump_from_file; find_approximate_string_matches; freq; frequencies; frequency; gdma; geometry; get_memory; gradient; hessian; ipi_broker; levenshtein; libint2_configuration; libint2_print_out; ManagedMethodError; mdi_run; message_box; MissingMethodError; molden; molecule_get_attr; molecule_set_attr; oeprop; opt; OptimizationConvergenceError; optimize; optimize_geometric; all_casings; array_to_matrix; banner; basis_helper; block_diagonal_array; cg_solver; compare_fchkfiles; compare_fcidumps; compare_moldenfiles; copy_file_from_scratch; copy_file_to_scratch; cubeprop; davidson_solver; DIIS; docs_table_link; drop_duplicates; energies_from_fcidump; expand_psivars; fcidump; fcidump_from_file; find_approximate_string_matches; format_molecule_for_input; format_options_for_input; free_atom_volumes; Gaussian; get_memory; get_psifile; getattr_ignorecase; hamiltonian_solver; hold_options_state; import_ignorecase; InPsight; kwargs_lower; levenshtein; libint2_configuration; li,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/index-wcopy.html:823124,energy,energy,823124,index-wcopy.html,https://psicode.org,https://psicode.org/index-wcopy.html,2,['energy'],['energy']
Energy Efficiency,"SI Variables, PSIMRCC; State-specific Multireference coupled cluster theories provide highly; accurate energies and properties of electronic states that require; a multiconfigurational zeroth-order wavefunction. The PSIMRCC; module contained in PSI4 implements the state-specific; multireference coupled-cluster approach of Mukherjee and co-workers; (Mk-MRCC). This method is implemented and shown to be a powerful tool in; [Evangelista:2006:154113] and [Evangelista:2008:124104]. Mk-MRCC is; based on the Jeziorski-Monkhorst ansatz [Jeziorski:1981:1668] for the; wavefunction, . where are the reference determinants,; are reference-specific excitation operators, and; are expansion coefficients obtained through diagonalization; of the Mk-MRCC effective Hamiltonian matrix that allows the various; reference determinants to interact. As an example of how this works; the Mk-MRCCSD excitation operators for each reference is contracted; two-body terms. where. and. The Mk-MRCC energy is a chosen eigenvalue of the effective Hamiltonian,. where. PSI4 currently implements Mk-MRCC with singles and doubles; [Mk-MRCCSD] and Mk-MRCCSD with perturbative triples [Mk-MRCCSD(T)]; as formulated in [Evangelista:2010:074107]. A companion perturbation; method (Mk-MRPT2) has been developed based on the Mukherjee formalisim; as shown in [Evangelista:2009:4728].; The current version of the code is limited to reference active spaces; in which all determinants are connected to each other by no more than two; excitations. In practice, this usually means that the active space can have; at most two particles, or at most two holes. Examples would include; CAS(2,2), CAS(2,8), CAS(4,3), etc., where CAS(n,m) refers to a; complete-active-space configuration interaction (CAS-CI) reference with n; electrons in m orbitals. If the user specifies active spaces that do not fit; these limitations, then the code will still run, but some relevant; determinants will be missing, and the answer obtained will be an approx",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/psimrcc-1.html:1330,energy,energy,1330,psi4manual/4.0b3/psimrcc-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimrcc-1.html,6,['energy'],['energy']
Energy Efficiency,"SI Variables, PSIMRCC; State-specific Multireference coupled cluster theories provide highly; accurate energies and properties of electronic states that require; a multiconfigurational zeroth-order wavefunction. The PSIMRCC; module contained in Psi4 implements the state-specific; multireference coupled-cluster approach of Mukherjee and co-workers; (Mk-MRCC). This method is implemented and shown to be a powerful tool in; [Evangelista:2006:154113] and [Evangelista:2008:124104]. Mk-MRCC is; based on the Jeziorski-Monkhorst ansatz [Jeziorski:1981:1668] for the; wavefunction, . where are the reference determinants,; are reference-specific excitation operators, and; are expansion coefficients obtained through diagonalization; of the Mk-MRCC effective Hamiltonian matrix that allows the various; reference determinants to interact. As an example of how this works; the Mk-MRCCSD excitation operators for each reference is contracted; two-body terms. where. and. The Mk-MRCC energy is a chosen eigenvalue of the effective Hamiltonian,. where. Psi4 currently implements Mk-MRCC with singles and doubles; [Mk-MRCCSD] and Mk-MRCCSD with perturbative triples [Mk-MRCCSD(T)]; as formulated in [Evangelista:2010:074107]. A companion perturbation; method (Mk-MRPT2) has been developed based on the Mukherjee formalisim; as shown in [Evangelista:2009:4728].; The current version of the code is limited to reference active spaces; in which all determinants are connected to each other by no more than two; excitations. In practice, this usually means that the active space can have; at most two particles, or at most two holes. Examples would include; CAS(2,2), CAS(2,8), CAS(4,3), etc., where CAS(n,m) refers to a; complete-active-space configuration interaction (CAS-CI) reference with n; electrons in m orbitals. If the user specifies active spaces that do not fit; these limitations, then the code will still run, but some relevant; determinants will be missing, and the answer obtained will be an approx",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/psimrcc-1.html:1337,energy,energy,1337,psi4manual/1.0.0/psimrcc-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/psimrcc-1.html,2,['energy'],['energy']
Energy Efficiency,"SI4. Psithon Functions: Invoking a Calculation; Notes on Options. Notes on Options¶. Note; The Python options referred to in the Psithon Functions: Invoking a Calculation section below; are placed as arguments to a Python; function (like energy()), not in set blocks or commands. Note; All PSI4 keyword names and values are insensitive to case, both; those that are placed in set blocks and as Python function arguments.; The one exception is documented for the subset option in the database(); function, where case structure must match the database file. Note; Boolean options can be specified by yes, on, true, or 1; for affirmative and no, off, false, or 0 for negative,; all insensitive to case. Note; The derivative level type for optimize() and frequency() functions can be specified by energy, none, or 0 for 0th derivative, gradient, first, or 1 for 1st derivative, and hessian, second, or 2 for 2nd derivative. For finite difference, as opposed to analytic, derivatives, the POINTS option can be increased to 5 for greater accuracy at increased cost. Note; Function option for the Psithon function called by the current function;; the default is usually energy(). See Sec. Function Intercalls; for a fuller description. Note that the value of the keyword is a Python object; and so is not wrapped in quotes like a string. Note; The molecule to be acted upon by the current function; the default is the; “active” molecule, which is the nearest preceeding molecule declared in a; molecule mymol {...} block or in an activate(mymol) statement. Note; that the value of this keyword (mymol in the example) is a Python object; and so is not wrapped in quotes like a string. Technically, this is a; Molecule object. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Psithon Functions: Invoking a Calculation; Notes on Options. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/notes_py-1.html:1247,energy,energy,1247,psi4manual/1.4.0/notes_py-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/notes_py-1.html,2,['energy'],['energy']
Energy Efficiency,"SI4. Psithon Functions: Invoking a Calculation; Notes on Options. Notes on Options¶. Note; The Python options referred to in the Psithon Functions: Invoking a Calculation section below; are placed as arguments to a Python; function (like energy()), not in set blocks or commands. Note; All PSI4 keyword names and values are insensitive to case, both; those that are placed in set blocks and as Python function arguments.; The one exception is documented for the subset option in the database(); function, where case structure must match the database file. Note; Boolean options can be specified by yes, on, true, or 1; for affirmative and no, off, false, or 0 for negative,; all insensitive to case. Note; The derivative level type for optimize() and frequency() functions can be specified by energy, none, or 0 for 0th derivative, gradient, first, or 1 for 1st derivative, and hessian, second, or 2 for 2nd derivative. For finite difference, as opposed to analytic, derivatives, the POINTS option can be increased to 5 for greater accuracy at increased cost. Note; Function option for the Psithon function called by the current function;; the default is usually energy(). See Sec. Function Intercalls; for a fuller description. Note that the value of the keyword is a Python object; and so is not wrapped in quotes like a string. Note; The molecule to be acted upon by the current function; the default is the; “active” molecule, which is the nearest preceeding molecule declared in a; molecule mymol {...} block or in an activate(mymol) statement. Note; that the value of this keyword (mymol in the example) is a Python object; and so is not wrapped in quotes like a string. Technically, this is a; Molecule object. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.5;  · . PSI4. Psithon Functions: Invoking a Calculation; Notes on Options. © Copyright 2021, The Psi4 Project.; Last updated on Sunday, 28 November 2021 02:41AM.; Created using Sphinx 4.3.1.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/notes_py-1.html:1247,energy,energy,1247,psi4manual/1.5.0/notes_py-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/notes_py-1.html,2,['energy'],['energy']
Energy Efficiency,"SI4. Theoretical Methods: SCF to FCI; DCT: Density Cumulant Theory. DCT: Density Cumulant Theory¶; Code author: Alexander Yu. Sokolov, Andrew C. Simmonett, and Xiao Wang; Section author: Alexander Yu. Sokolov; Module: Keywords, PSI Variables, DCT. Theory¶; Density cumulant theory (DCT) is a density-based ab initio theory; that can compute electronic energies without the use of a wavefunction. The; theory starts by writing the exact energy expression in terms of the one- and; two-particle density matrices (\(\boldsymbol{\gamma_1}\) and \(\boldsymbol{\gamma_2}\)):. \[E = h_p^q \gamma_q^p + \frac{1}{2} g_{pq}^{rs} \gamma_{rs}^{pq}\]; Here we used Einstein convention for the summation over the repeated indices.; \(h_p^q\) and \(g_{pq}^{rs}\) are the standard one- and two-electron integrals, and; \(\gamma_p^q\) and \(\gamma_{pq}^{rs}\) are the elements of \(\boldsymbol{\gamma_1}\) and \(\boldsymbol{\gamma_2}\),; respectively. Naively, one might expect that it is possible to minimize the; energy functional in the equation above and obtain the exact energy. This is,; however, not trivial, as the density matrix elements \(\gamma_p^q\) and; \(\gamma_{pq}^{rs}\) cannot be varied arbitrarily, but must satisfy some; conditions that make sure that the density matrices are N-representable, i.e.; correspond to an antisymmetric N-electron wavefunction. Unfortunately, no; simple set of necessary and sufficient N-representability conditions are known,; and some of the known conditions are not easily imposed. In addition, the lack; of separability of the density matrices may result in the loss of; size-consistency and size-extensivity. In DCT, one takes a different route and; replaces \(\boldsymbol{\gamma_2}\) in favor of its two-particle density cumulant:. \[\lambda_{pq}^{rs} = \gamma_{pq}^{rs} - \gamma_p^r \gamma_q^s + \gamma_p^s \gamma_q^r\]; The one-particle density matrix is separated into its idempotent part; \(\boldsymbol{\kappa}\) and a correction \(\boldsymbol{\tau}\):. \[\ga",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/dct-1.html:1094,energy,energy,1094,psi4manual/1.4.0/dct-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/dct-1.html,18,['energy'],['energy']
Energy Efficiency,"SINGLETS (CPHF). DO_SOS (DFOCC). (OCC). DO_THIRD_ORDER (SAPT). DO_TRIPLETS (CPHF). DOCC (GLOBALS). (MCSCF). dot() in module qcdb.vecutil. DOUBLE-HYBRIDCORRECTIONENERGY. driver module. driver_cbs module. driver_nbody module. driver_util module. drop_duplicates() in module p4util.procutil. in module qcdb.dbproc. in module qcdb.psiutil. DYNAMIC_LEVEL (OPTKING). dynamic_variable_bind() in module molutil. E. E() SymmetryOperation method. SymRep method. E3_SCALE (DFOCC). (OCC). E_CONVERGENCE (CCENERGY). (CCEOM). (DCFT). (DETCI). (DFOCC). (FNOCC). (MCSCF). (MRCC). (OCC). (PSIMRCC). (SAPT). (SCF). EA_POLES (OCC). EFP. adding new. library fragments, [1]. molecule specification. EFP_DISP (EFP). EFP_DISP_DAMPING (EFP). EFP_ELST (EFP). EFP_ELST_DAMPING (EFP). EFP_EXCH (EFP). EFP_POL (EFP). EFP_POL_DAMPING (EFP). EKT_EA (OCC). EKT_IP (DFOCC). (OCC). elevation InPsight attribute. empty() in module qcdb.textables. end_latex_document() in module qcdb.textables. energy(). setting keywords. energy() in module driver. ENERGY_LEVEL_SHIFT (DCFT). ENSURE_BT_CONVERGENCE (OPTKING). entry_number() CoordEntry method. environment variable; . MKL_NUM_THREADS, [1], [2]. MONTAGE. OMP_NESTED, [1], [2]. OMP_NUM_THREADS, [1], [2], [3], [4], [5], [6], [7], [8], [9], [10]. PATH, [1], [2], [3], [4], [5], [6], [7], [8], [9], [10], [11], [12], [13], [14], [15], [16], [17]. PSIDATADIR, [1], [2]. PSIPATH, [1], [2], [3], [4], [5], [6], [7], [8], [9], [10], [11], [12], [13], [14], [15], [16], [17], [18], [19], [20], [21]. PSI_SCRATCH, [1], [2], [3], [4], [5], [6], [7], [8]. PYTHONPATH, [1], [2], [3], [4]. VMDPATH. EOM_GUESS (CCEOM). EOM_REFERENCE (CCEOM). (CCHBAR). (CCSORT). EP_EA_POLES (OCC). EP_IP_POLES (OCC). EP_MAXITER (OCC). equal_but_for_row_order() in module qcdb.libmintsmolecule. equivalent() LibmintsMolecule method. erd_coef() ShellInfo method. erd_normalize_shell() ShellInfo method. Error class in qcdb.modelchems. everything() CartesianEntry method. CoordEntry method. CoordValue method. LibmintsMol",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/genindex.html:31976,energy,energy,31976,psi4manual/1.0.0/genindex.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/genindex.html,1,['energy'],['energy']
Energy Efficiency,"SIS',""6-311G(D_P)""); run_fnocc('qcisd(t)',**kwargs). # HLC: high-level correction based on number of valence electrons; ref = PsiMod.wavefunction(); nirrep = ref.nirrep(); frzcpi = ref.frzcpi(); nfzc = 0; for i in range (0,nirrep):; nfzc += frzcpi[i]; nalpha = ref.nalpha() - nfzc; nbeta = ref.nbeta() - nfzc; # hlc of gaussian-2; hlc = -0.00481 * nalpha -0.00019 * nbeta; # hlc of gaussian-1; hlc1 = -0.00614 * nalpha. eqci_6311gdp = PsiMod.get_variable(""QCISD(T) TOTAL ENERGY""); emp4_6311gd = PsiMod.get_variable(""MP4 TOTAL ENERGY""); emp2_6311gd = PsiMod.get_variable(""MP2 TOTAL ENERGY""); PsiMod.clean(). # correction for diffuse functions; PsiMod.set_global_option('BASIS',""6-311+G(D_P)""); energy('mp4'); emp4_6311pg_dp = PsiMod.get_variable(""MP4 TOTAL ENERGY""); emp2_6311pg_dp = PsiMod.get_variable(""MP2 TOTAL ENERGY""); PsiMod.clean(). # correction for polarization functions; PsiMod.set_global_option('BASIS',""6-311G(2DF_P)""); energy('mp4'); emp4_6311g2dfp = PsiMod.get_variable(""MP4 TOTAL ENERGY""); emp2_6311g2dfp = PsiMod.get_variable(""MP2 TOTAL ENERGY""); PsiMod.clean(). # big basis mp2; PsiMod.set_global_option('BASIS',""6-311+G(3DF_2P)""); run_fnocc('_mp2',**kwargs); emp2_big = PsiMod.get_variable(""MP2 TOTAL ENERGY""); PsiMod.clean(). eqci = eqci_6311gdp; e_delta_g2 = emp2_big + emp2_6311gd - emp2_6311g2dfp - emp2_6311pg_dp; e_plus = emp4_6311pg_dp - emp4_6311gd; e_2df = emp4_6311g2dfp - emp4_6311gd. eg2 = eqci + e_delta_g2 + e_plus + e_2df; eg2_mp2_0k = eqci + (emp2_big - emp2_6311gd) + hlc + zpe. PsiMod.print_out('\n'); PsiMod.print_out(' ==> G1/G2 Energy Components <==\n'); PsiMod.print_out('\n'); PsiMod.print_out(' QCISD(T): %20.12lf\n' % eqci); PsiMod.print_out(' E(Delta): %20.12lf\n' % e_delta_g2); PsiMod.print_out(' E(2DF): %20.12lf\n' % e_2df); PsiMod.print_out(' E(+): %20.12lf\n' % e_plus); PsiMod.print_out(' E(G1 HLC): %20.12lf\n' % hlc1); PsiMod.print_out(' E(G2 HLC): %20.12lf\n' % hlc); PsiMod.print_out(' E(ZPE): %20.12lf\n' % zpe); PsiMod.print_out('\n'); PsiMod.",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/_modules/gaussian_n.html:2734,ENERGY,ENERGY,2734,psi4manual/4.0b4/_modules/gaussian_n.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/gaussian_n.html,1,['ENERGY'],['ENERGY']
Energy Efficiency,"SIS_ELST¶. Auxiliary basis set for SAPT Elst10 and Exch10 density fitting computations, may be important if heavier elements are involved. Defaults to a JKFIT basis. Previous to v1.6, defaulted to DF_BASIS_SAPT See fitting notes . Type: string; Possible Values: basis string; Default: No Default. DF_BASIS_SAPT¶. Auxiliary basis set for SAPT density fitting computations. Defaults to a RI basis. Type: string; Possible Values: basis string; Default: No Default. D_CONVERGENCE¶. Convergence criterion for residual of the CPHF coefficients in the SAPT \(E_{ind,resp}^{(20)}\) term. Type: conv double; Default: 1e-8. EXCH_SCALE_ALPHA¶. Whether or not to perform exchange scaling for SAPT exchange components. Default is false, i.e. no scaling. If set to true, performs scaling with \(Exch10 / Exch10(S^2)\). If set to a value \(\alpha\), performs scaling with \((Exch10 / Exch10(S^2))^{\alpha}\). Type: string; Default: FALSE. E_CONVERGENCE¶. Convergence criterion for energy (change) in the SAPT \(E_{ind,resp}^{(20)}\) term during solution of the CPHF equations. Type: conv double; Default: 1e-10. FREEZE_CORE¶. The scope of core orbitals to freeze in evaluation of SAPT \(E_{disp}^{(20)}\) and \(E_{exch-disp}^{(20)}\) terms. Recommended true for all SAPT computations. Type: string; Possible Values: FALSE, TRUE; Default: FALSE. INTS_TOLERANCE¶. Schwarz screening threshold. Minimum absolute value below which all three-index DF integrals and those contributing to four-index integrals are neglected. The default is conservative, but there isn’t much to be gained from loosening it, especially for higher-order SAPT. Type: conv double; Default: 1.0e-12. MAXITER¶. Maximum number of CPHF iterations. Type: integer; Default: 50. MAX_CCD_DIISVECS¶. Maximum number of vectors used in CCD-DIIS. Type: integer; Default: 10. MIN_CCD_DIISVECS¶. Minimum number of vectors used in CCD-DIIS. Type: integer; Default: 4. NAT_ORBS_T2¶. Do use MP2 natural orbital approximations for the \(v^4\) block of two-electr",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/autodir_options_c/module__sapt.html:2404,energy,energy,2404,psi4manual/1.6.x/autodir_options_c/module__sapt.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/autodir_options_c/module__sapt.html,8,['energy'],['energy']
Energy Efficiency,"SIS_MP2'],; ['SCF_TYPE']). # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'); core.print_out("""""" SCF Algorithm Type (re)set to DF.\n""""""). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. core.tstart(); core.print_out('\n'); p4util.banner('DFMP2'); core.print_out('\n'). if core.get_global_option('REFERENCE') == ""ROHF"":; ref_wfn.semicanonicalize(). aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_MP2"",; core.get_option(""DFMP2"", ""DF_BASIS_MP2""),; ""RIFIT"", core.get_global_option('BASIS')); ref_wfn.set_basisset(""DF_BASIS_MP2"", aux_basis). dfmp2_wfn = core.dfmp2(ref_wfn); dfmp2_wfn.compute_energy(). if name == 'scs-mp2':; dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('SCS-MP2 TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('SCS-MP2 CORRELATION ENERGY')). elif name == 'mp2':; dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('MP2 TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('MP2 CORRELATION ENERGY')). # Shove variables into global space; for k, v in dfmp2_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); core.tstop(); return dfmp2_wfn. def run_dfep2(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a density-fitted MP2 calculation. """"""; core.tstart(); optstash = p4util.OptionsState(; ['DF_BASIS_MP2'],; ['SCF_TYPE']). # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'); core.print_out("""""" SCF Algorithm Type (re)set to DF.\n""""""). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. if core.get_global_option('REFERENCE') != ""RHF"":; raise ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html:126201,ENERGY,ENERGY,126201,psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,7,['ENERGY'],['ENERGY']
Energy Efficiency,"SK. For more recommendations on the choice of the algorithm see; Recommendations section. Analytic Gradients¶; Analytic gradients are available for the DC-06 method. Gradients are only; available if the ALGORITHM option is set to TWOSTEP or SIMULTANEOUS for; the energy computation. Evaluation of the analytic gradients requires the solution of the; coupled response equations. Two algorithms are available for their iterative; solution: two-step (default) and simultaneous. These algorithms are similar to those; described for the orbital and cumulant updates in the Iterative Algorithms; section and usually exhibit the similar efficiency. The choice of the algorithm can; be made using the RESPONSE_ALGORITHM option. For the DC-12 method the; analytic gradients are not yet available, one has to use numerical gradients to; perform the geometry optimizations. Minimal Input¶; Minimal input for the DCFT single-point computation looks like this:; molecule {; H; H 1 1.0; }. set basis 3-21G. energy('dcft'). The energy('dcft') call to energy() executes the DCFT module, which will first call the SCF module and perform the SCF computation with UHF reference to obtain the guess for the DCFT orbitals. After the SCF is converged, the program will perform the energy computation using the DC-06 method. By default, the two-step algorithm will be used for the solution of the equations. Note that while the default value for the option REFERENCE is RHF, this option is set to UHF before the DCFT module is executed. For the DC-06 method one can also request to perform the geometry optimization following the example below:; molecule {; H; H 1 1.0; }. set basis 3-21G. optimize('dcft'). The optimize('dcft') call will first perform all of the procedures; described above to obtain the DC-06 energy. After that the DC-06 analytic; gradients code will be executed to perform the solution of the DCFT response; equations, compute the analytic gradients of the DCFT energy and perform the; geometry optimiz",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/dcft-1.html:10012,energy,energy,10012,psi4manual/4.0b5/dcft-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/dcft-1.html,2,['energy'],['energy']
Energy Efficiency,"SON, SEM, SEMTEST; Default: SEM. DIAGONAL_CCSD_T (PSIMRCC); PSIMRCC — Do include the diagonal corrections in (T) computations?. Type: boolean; Default: true. DIAGONALIZE_HEFF (PSIMRCC); PSIMRCC — Do diagonalize the effective Hamiltonian?. Type: boolean; Default: false. DIE_IF_NOT_CONVERGED (GLOBALS); GLOBALS (Expert) — PSI4 dies if energy does not converge. Type: boolean; Default: true. DIIS (CCENERGY); CCENERGY — Do use DIIS extrapolation to accelerate convergence?. Type: boolean; Default: true. DIIS (CCLAMBDA); CCLAMBDA — Do use DIIS extrapolation to accelerate convergence?. Type: boolean; Default: true. DIIS (CCRESPONSE); CCRESPONSE — Do use DIIS extrapolation to accelerate convergence?. Type: boolean; Default: true. DIIS (DETCI); DETCI — Do use DIIS extrapolation to accelerate CC convergence?. Type: boolean; Default: true. DIIS (LMP2); LMP2 — Do use DIIS extrapolation to accelerate convergence?. Type: boolean; Default: true. DIIS (MCSCF); MCSCF — Do use DIIS extrapolation to accelerate convergence of the SCF energy (MO coefficients only)?. Type: boolean; Default: true. DIIS (SCF); SCF — Do use DIIS extrapolation to accelerate convergence?. Type: boolean; Default: true. DIIS_FREQ (DETCI); DETCI — How often to do a DIIS extrapolation. 1 means do DIIS every iteration, 2 is every other iteration, etc. Type: integer; Default: 1. DIIS_MAX_VECS (CEPA); CEPA — Number of vectors to store for DIIS extrapolation. Type: integer; Default: 8. DIIS_MAX_VECS (DCFT); DCFT — Maximum number of error vectors stored for DIIS extrapolation. Type: integer; Default: 6. DIIS_MAX_VECS (DETCI); DETCI — Maximum number of error vectors stored for DIIS extrapolation. Type: integer; Default: 5. DIIS_MAX_VECS (LMP2); LMP2 — Maximum number of error vectors stored for DIIS extrapolation. Type: integer; Default: 5. DIIS_MAX_VECS (MCSCF); MCSCF — Maximum number of error vectors stored for DIIS extrapolation. Type: integer; Default: 7. DIIS_MAX_VECS (OMP2); OMP2 — Number of vectors used in DIIS. Typ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/autodoc_glossary_options_c-1.html:30242,energy,energy,30242,psi4manual/4.0b3/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodoc_glossary_options_c-1.html,2,['energy'],['energy']
Energy Efficiency,"SON, SEM, SEMTEST; Default: SEM. DIAGONAL_CCSD_T (PSIMRCC); PSIMRCC — Do include the diagonal corrections in (T) computations?. Type: boolean; Default: true. DIAGONALIZE_HEFF (PSIMRCC); PSIMRCC — Do diagonalize the effective Hamiltonian?. Type: boolean; Default: false. DIE_IF_NOT_CONVERGED (GLOBALS); GLOBALS (Expert) — PSI4 dies if energy does not converge. Type: boolean; Default: true. DIIS (CCENERGY); CCENERGY — Do use DIIS extrapolation to accelerate convergence?. Type: boolean; Default: true. DIIS (CCLAMBDA); CCLAMBDA — Do use DIIS extrapolation to accelerate convergence?. Type: boolean; Default: true. DIIS (CCRESPONSE); CCRESPONSE — Do use DIIS extrapolation to accelerate convergence?. Type: boolean; Default: true. DIIS (DETCI); DETCI — Do use DIIS extrapolation to accelerate CC convergence?. Type: boolean; Default: true. DIIS (LMP2); LMP2 — Do use DIIS extrapolation to accelerate convergence?. Type: boolean; Default: true. DIIS (MCSCF); MCSCF — Do use DIIS extrapolation to accelerate convergence of the SCF energy (MO coefficients only)?. Type: boolean; Default: true. DIIS (SCF); SCF — Do use DIIS extrapolation to accelerate convergence?. Type: boolean; Default: true. DIIS_FREQ (DETCI); DETCI — How often to do a DIIS extrapolation. 1 means do DIIS every iteration, 2 is every other iteration, etc. Type: integer; Default: 1. DIIS_MAX_VECS (DCFT); DCFT (Expert) — Maximum number of error vectors stored for DIIS extrapolation. Type: integer; Default: 6. DIIS_MAX_VECS (DETCI); DETCI — Maximum number of error vectors stored for DIIS extrapolation. Type: integer; Default: 5. DIIS_MAX_VECS (FNOCC); FNOCC — Desired number of DIIS vectors. Type: integer; Default: 8. DIIS_MAX_VECS (LMP2); LMP2 — Maximum number of error vectors stored for DIIS extrapolation. Type: integer; Default: 5. DIIS_MAX_VECS (MCSCF); MCSCF — Maximum number of error vectors stored for DIIS extrapolation. Type: integer; Default: 7. DIIS_MAX_VECS (PSIMRCC); PSIMRCC — Maximum number of error vectors store",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/autodoc_glossary_options_c-1.html:32110,energy,energy,32110,psi4manual/4.0b4/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/autodoc_glossary_options_c-1.html,2,['energy'],['energy']
Energy Efficiency,"SOS, SOSPI; Default: SOS. SOS_TYPE (OCC); OCC — Type of the SOS method. Type: string; Possible Values: SOS, SOSPI; Default: SOS. SOSCF (SCF); SCF — Do use second-order SCF convergence methods?. Type: boolean; Default: false. SOSCF_CONV (SCF); SCF — Second order convergence threshold. Cease microiterating at this value. Type: conv double; Default: 5.0e-3. SOSCF_MAX_ITER (SCF); SCF — Maximum number of second-order microiterations to perform. Type: integer; Default: 5. SOSCF_MIN_ITER (SCF); SCF — Minimum number of second-order microiterations to perform. Type: integer; Default: 1. SOSCF_PRINT (SCF); SCF — Do we print the SOSCF microiterations?. Type: boolean; Default: false. SOSCF_START_CONVERGENCE (SCF); SCF — When to start second-order SCF iterations based on gradient RMS. Type: conv double; Default: 1.0e-2. SPINADAPT_ENERGIES (CCENERGY); CCENERGY — Do print spin-adapted pair energies?. Type: boolean; Default: false. SS_E_CONVERGENCE (CCEOM); CCEOM — Convergence criterion for excitation energy (change) in the Davidson algorithm for the CIS guess to CC-EOM. Type: conv double; Default: 1e-6. SS_R_CONVERGENCE (CCEOM); CCEOM — Convergence criterion for norm of the residual vector in the Davidson algorithm for the CIS guess to CC-EOM. Type: conv double; Default: 1e-6. SS_SKIP_DIAG (CCEOM); CCEOM — Do skip diagonalization of Hbar SS block?. Type: boolean; Default: false. SS_VECS_PER_ROOT (CCEOM); CCEOM — SS vectors stored per root. Type: integer; Default: 5. SSAPT0_SCALE (FISAPT); FISAPT — Do sSAPT0 exchange-scaling with F-SAPT. Type: boolean; Default: false. STABILITY_ADD_VECTORS (DCFT); DCFT (Expert) — The number of vectors that can be added simultaneously into the subspace for Davidson’s diagonalization in stability check. Type: integer; Default: 20. STABILITY_ANALYSIS (SCF); SCF — Whether to perform stability analysis after convergence. NONE prevents analysis being performed. CHECK will print out the analysis of the wavefunction stability at the end of the computation.",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/autodoc_glossary_options_c-1.html:211976,energy,energy,211976,psi4manual/1.3.2/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/autodoc_glossary_options_c-1.html,2,['energy'],['energy']
Energy Efficiency,"SOSCF is only available for RHF, ROHF, and UHF reference. To turn on simply set; the option SOSCF to true. Additional options to modify the number of; microiterations taken are as follows:. SOSCF_R_START: when to start SOSCF based on the current density RMS; SOSCF_MAX_ITER: the maximum number of SOSCF microiterations per macroiteration; SOSCF_CONV: the relative convergence tolerance of the SOSCF microiterations; SOSCF_PRINT: option to print the microiterations or not. Stability Analysis¶; SCF algorithms attempt to minimize the gradient of the energy with respect; to orbital variation parameters. At convergence, the gradient should be approximately zero; given a convergence criterion. Although this is enough to make sure the SCF converged to a; stationary point, this is not a sufficient condition for a minimal SCF solution. It may be; a sadle point or a maximum.; To ensure that a minimum has been found, the electronic Hessian, i.e. the matrix of second; derivatives of the energy with respect to orbital variation parameters, must be computed.; If one or more eigenvalues of the electronic Hessian are negative, the SCF solution is not a minimum.; In that case, orbital parameters can be varied along the lowest Hessian eigenvector to lower the energy.; Orbital variation parameters are usually constrained. For example, in RHF the; spatial parts of the and orbitals are the same. In; UHF, the orbital coefficients are usually constrained to be real. A stability analysis; can check whether a lower SCF solution exists while respecting the constraints of the original; solution; this is an internal instability. If one or more constraints have to be relaxed to reach; a lower-energy solution, there is an external instability. In Psi4, the only external instability; that can be checked at present is the RHF->UHF one.; Currently, two algorithms exist in Psi4 for stability analysis: the original; Direct Inversion and the newly implemented Davidson algorithms. We will first describe; o",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/scf-1.html:23816,energy,energy,23816,psi4manual/1.0.0/scf-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/scf-1.html,2,['energy'],['energy']
Energy Efficiency,"SP22(T) ENERGY¶. SAPT EST.DISP22(T) ENERGY¶; Dispersion-classified MBPT-based SAPT term energy [E_h] implemented for SAPT2+. SAPT DISP2(CCD) ENERGY¶. SAPT DISP22(S)(CCD) ENERGY¶. SAPT DISP22(T)(CCD) ENERGY¶. SAPT EST.DISP22(T)(CCD) ENERGY¶; Dispersion-classified coupled-cluster-based SAPT term energy [E_h] implemented for SAPT2+. SAPT ELST13,R ENERGY¶; An electrostatics-classified SAPT term energy [E_h] implemented for SAPT2+(3). SAPT IND30,R ENERGY¶. SAPT IND-DISP30 ENERGY¶. SAPT EXCH-IND30,R ENERGY¶; A induction-classified SAPT term energy [E_h] implemented for SAPT2+3. SAPT EXCH-IND30(S^INF) ENERGY¶. SAPT EXCH-IND30,R(S^INF) ENERGY¶; A induction-classified SAPT term energy [E_h] implemented for SAPT2+3. See Higher-Order Exchange Terms without Single-Exchange Approximation. SAPT DISP30 ENERGY¶. SAPT EXCH-DISP30 ENERGY¶. SAPT EXCH-IND-DISP30 ENERGY¶; A dispersion-classified SAPT term energy [E_h] implemented for SAPT2+3. SAPT ALPHA¶; SAPT exchange-scaling alpha. SAPT CT ENERGY¶; SAPT charge-transfer energy. SAPT HF TOTAL ENERGY¶; An induction-classified correction from HF implemented for SAPT0.; Value varies by SAPT level. SAPT MP2 CORRELATION ENERGY¶; An induction-classified correction from MP2 implemented for SAPT2.; Value varies by SAPT level. SAPT0 DISP ENERGY¶. SAPT0 ELST ENERGY¶. SAPT0 EXCH ENERGY¶. SAPT0 IND ENERGY¶. SSAPT0 DISP ENERGY¶. SSAPT0 ELST ENERGY¶. SSAPT0 EXCH ENERGY¶. SSAPT0 IND ENERGY¶. SAPT2 DISP ENERGY¶. SAPT2 ELST ENERGY¶. SAPT2 EXCH ENERGY¶. SAPT2 IND ENERGY¶. SAPT2+ DISP ENERGY¶. SAPT2+ ELST ENERGY¶. SAPT2+ EXCH ENERGY¶. SAPT2+ IND ENERGY¶. SAPT2+(3) DISP ENERGY¶. SAPT2+(3) ELST ENERGY¶. SAPT2+(3) EXCH ENERGY¶. SAPT2+(3) IND ENERGY¶. SAPT2+3 DISP ENERGY¶. SAPT2+3 ELST ENERGY¶. SAPT2+3 EXCH ENERGY¶. SAPT2+3 IND ENERGY¶; Respectively, the dispersion, electrostatics, exchange, and induction; components of the total electronic interaction energy [E_h] for the; given SAPT level of theory. The sum of these four components yields; the SAPT Level TO",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/glossary_psivariables.html:49423,charge,charge-transfer,49423,psi4manual/1.7.x/glossary_psivariables.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/glossary_psivariables.html,8,"['charge', 'energy']","['charge-transfer', 'energy']"
Energy Efficiency,"SPHERICAL).; Specifying keywords that control geometry optimization is; straightforward. Unless the optimization is invoked in sandwich mode,; all Cfour optimization keywords (e.g., CFOUR_GEO_MAXCYC) are; ineffective, as the Cfour optimizer is never invoked. PSI4; optimization keywords (e.g., GEOM_MAXITER) instead fill; these roles.; Specifying the computational method (through, for instance,; energy('c4-ccsd') instead of energy('cfour')) often; sets additional keywords consistent with best practices (e.g.,; CFOUR_CC_PROGRAM). Since those settings are implicit, any; explicit setting of those those keywords, whether contradicting or; concurring, takes priority (halts never generated). The following are; some concrete examples. For the moment, click the source button at; muster_modelchem for details of what keywords; get set. runs in vcc since that’s Cfour’s default for cc_program; set cfour_calc_level ccsd; energy('cfour'). runs in ecc since Cfour’s default overwritten by keyword; set cfour_calc_level ccsd; set cfour_cc_program ecc; energy('cfour'). runs in ecc since that’s best practice for the requested ccsd; energy('c4-ccsd'). runs in vcc since hidden default overwritten by keyword; set cfour_cc_program vcc; energy('c4-ccsd'). Specifying certain keywords that are nominally applicable for pure-PSI4 modules directs them to fulfil analogous roles; in the Cfour program (e.g., MAXITER is used to set; CFOUR_SCF_MAXCYC). This keyword translation only takes place; if the keywords are explicitly set in the input file (part of that; contract that you mean it), meaning that PSI4‘s defaults don’t; get imposed on Cfour. Also, in the case where a translatable pure-PSI4 keyword and its translation Cfour keyword are both set,; the value attached to the latter is always used. Below are a few; clarifying examples. uses \(10^{-7}\) SCF conv crit since that’s Cfour’s default; for CFOUR_SCF_CONV; energy('c4-scf'). uses \(10^{-6}\) SCF conv crit since default overwritten by; keyword; s",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/cfour-1.html:32286,energy,energy,32286,psi4manual/1.4.0/cfour-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/cfour-1.html,9,['energy'],['energy']
Energy Efficiency,SPIN CORRELATION ENERGY; ACPF TOTAL ENERGY; AQCC CORRELATION ENERGY; AQCC OPPOSITE-SPIN CORRELATION ENERGY; AQCC SAME-SPIN CORRELATION ENERGY; AQCC TOTAL ENERGY; CC ALPHA-ALPHA PAIR ENERGIES (array); CC ALPHA-BETA PAIR ENERGIES (array); CC D1 DIAGNOSTIC; CC SINGLET PAIR ENERGIES (array); CC T1 DIAGNOSTIC; CC TRIPLET PAIR ENERGIES (array); CCSD ALPHA-ALPHA PAIR ENERGIES (array); CCSD ALPHA-BETA PAIR ENERGIES (array); CCSD CORRELATION ENERGY; CCSD DOUBLES ENERGY; CCSD ITERATIONS; CCSD OPPOSITE-SPIN CORRELATION ENERGY; CCSD SAME-SPIN CORRELATION ENERGY; CCSD SINGLES ENERGY; CCSD SINGLET PAIR ENERGIES (array); CCSD TOTAL ENERGY; CCSD TRIPLET PAIR ENERGIES (array); CCSD(T) CORRELATION ENERGY; CCSD(T) TOTAL ENERGY; CEPA(0) CORRELATION ENERGY; CEPA(0) DOUBLES ENERGY; CEPA(0) OPPOSITE-SPIN CORRELATION ENERGY; CEPA(0) SAME-SPIN CORRELATION ENERGY; CEPA(0) SINGLES ENERGY; CEPA(0) TOTAL ENERGY; CEPA(1) CORRELATION ENERGY; CEPA(1) OPPOSITE-SPIN CORRELATION ENERGY; CEPA(1) SAME-SPIN CORRELATION ENERGY; CEPA(1) TOTAL ENERGY; CEPA(2) CORRELATION ENERGY; CEPA(2) OPPOSITE-SPIN CORRELATION ENERGY; CEPA(2) SAME-SPIN CORRELATION ENERGY; CEPA(2) TOTAL ENERGY; CEPA(3) CORRELATION ENERGY; CEPA(3) OPPOSITE-SPIN CORRELATION ENERGY; CEPA(3) SAME-SPIN CORRELATION ENERGY; CEPA(3) TOTAL ENERGY; CISD CORRELATION ENERGY; CISD OPPOSITE-SPIN CORRELATION ENERGY; CISD SAME-SPIN CORRELATION ENERGY; CISD TOTAL ENERGY; CURRENT CORRELATION ENERGY; CURRENT ENERGY; LCCD CORRELATION ENERGY; LCCD DOUBLES ENERGY; LCCD OPPOSITE-SPIN CORRELATION ENERGY; LCCD SAME-SPIN CORRELATION ENERGY; LCCD SINGLES ENERGY; LCCD TOTAL ENERGY; LCCSD CORRELATION ENERGY; LCCSD DOUBLES ENERGY; LCCSD OPPOSITE-SPIN CORRELATION ENERGY; LCCSD SAME-SPIN CORRELATION ENERGY; LCCSD SINGLES ENERGY; LCCSD TOTAL ENERGY; MP2 ALPHA-ALPHA PAIR ENERGIES (array); MP2 ALPHA-BETA PAIR ENERGIES (array); MP2 CORRELATION ENERGY; MP2 DOUBLES ENERGY; MP2 OPPOSITE-SPIN CORRELATION ENERGY; MP2 SAME-SPIN CORRELATION ENERGY; MP2 SINGLES ENERGY; MP2 SINGLET P,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/autodir_psivariables/module__fnocc.html:1224,ENERGY,ENERGY,1224,psi4manual/1.6.x/autodir_psivariables/module__fnocc.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/autodir_psivariables/module__fnocc.html,1,['ENERGY'],['ENERGY']
Energy Efficiency,"SPIN CORRELATION ENERGY¶. CEPA(1) OPPOSITE-SPIN CORRELATION ENERGY¶. CEPA(2) OPPOSITE-SPIN CORRELATION ENERGY¶. CEPA(3) OPPOSITE-SPIN CORRELATION ENERGY¶. CISD OPPOSITE-SPIN CORRELATION ENERGY¶. QCISD OPPOSITE-SPIN CORRELATION ENERGY¶. ACPF OPPOSITE-SPIN CORRELATION ENERGY¶. AQCC OPPOSITE-SPIN CORRELATION ENERGY¶. REMP2 OPPOSITE-SPIN CORRELATION ENERGY¶. LCCD OPPOSITE-SPIN CORRELATION ENERGY¶. CCD OPPOSITE-SPIN CORRELATION ENERGY¶. LCCSD OPPOSITE-SPIN CORRELATION ENERGY¶. CCSD OPPOSITE-SPIN CORRELATION ENERGY¶. OMP2 OPPOSITE-SPIN CORRELATION ENERGY¶. OMP2.5 OPPOSITE-SPIN CORRELATION ENERGY¶. OMP3 OPPOSITE-SPIN CORRELATION ENERGY¶. OREMP2 OPPOSITE-SPIN CORRELATION ENERGY¶. OLCCD OPPOSITE-SPIN CORRELATION ENERGY¶; The unscaled portion [E_h] of the named correlation energy; from opposite-spin or singlet doubles correlations. MRPT TOTAL ENERGY¶. MP2-CCSD TOTAL ENERGY¶. MRCC TOTAL ENERGY¶; Energies [E_h] from correlated multi-reference theories. MULLIKEN CHARGES¶; Property of partial atomic charges [e] by the method of Mulliken, (nat,). NAUX (SCF)¶. NAUX (CC)¶; Convenience storage of number of functions [] in the auxiliary basis; set for named stage of the calculation. NBODY (i, j, ..., k)@(a, b, ..., c) TOTAL ENERGY¶; The total energy [E_h] of a component of the requested N-Body energy.; The first parenthetical list over i, j, …, k enumerates; molecular fragments included in the computation in 1-indexed,; input-file order, while the second enumerates list over a, b,; …, c enumerates which fragments contribute basis functions to the; computation. For example, (1, 2)@(1, 2, 3, 4) indicates that the; fragments 1 and 2 are explicitly included in the energy computation,; with basis functions from each of fragments 1, 2, 3, & 4 included in; the basis set. Therefore, the basis functions from fragments 3 and 4; are included as ghost functions within the energy computation. NUCLEAR REPULSION ENERGY¶; The nuclear repulsion energy contribution [E_h] to the total SCF energy.; Quanti",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/glossary_psivariables.html:40760,charge,charges,40760,psi4manual/1.7.x/glossary_psivariables.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/glossary_psivariables.html,4,['charge'],['charges']
Energy Efficiency,"SP¶. Do MBPT dispersion correction in SAPT2+, SAPT2+(3) or SAPT2+3, if also doing CCD?. Type: boolean; Default: true. DO_THIRD_ORDER¶. Do compute third-order corrections?. Type: boolean; Default: false. INTS_TOLERANCE¶. Minimum absolute value below which all three-index DF integrals and those contributing to four-index integrals are neglected. The default is conservative, but there isn’t much to be gained from loosening it, especially for higher-order SAPT. Type: conv double; Default: 1.0e-12. SAPT_MEM_CHECK¶. Do force SAPT2 and higher to die if it thinks there isn’t enough memory? Turning this off is ill-advised. Type: boolean; Default: true. DEBUG¶. The amount of information to print to the output file. Type: integer; Default: 0. MP2 Natural Orbitals¶; One of the unique features of the SAPT module is its ability to use; MP2 natural orbitals (NOs) to speed up the evaluation of the triples; contribution to dispersion. By transforming to the MP2 NO basis, we can; throw away virtual orbitals that are expected to contribute little to the; dispersion energy. Speedups in excess of \(50 \times\) are possible. In; practice, this approximation is very good and should always be applied.; Publications resulting from the use of MP2 NO-based approximations should; cite the following: [Hohenstein:2010:104107]. Basic Keywords Controlling MP2 NO Approximations¶. NAT_ORBS_T2¶. Do use MP2 natural orbital approximations for the \(v^4\) block of two-electron integrals in the evaluation of second-order T2 amplitudes? Recommended true for all SAPT computations. Type: boolean; Default: true. NAT_ORBS_T3¶. Do natural orbitals to speed up evaluation of the triples contribution to dispersion by truncating the virtual orbital space? Recommended true for all SAPT computations. Type: boolean; Default: true. NAT_ORBS_V4¶. Do use MP2 natural orbital approximations for the \(v^4\) block of two-electron integrals in the evaluation of CCD T2 amplitudes? Recommended true for all SAPT computations. Ty",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/sapt-1.html:23066,energy,energy,23066,psi4manual/1.1.0/sapt-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/sapt-1.html,4,['energy'],['energy']
Energy Efficiency,"SP¶. Do MBPT dispersion correction in SAPT2+, SAPT2+(3) or SAPT2+3, if also doing CCD?. Type: boolean; Default: true. DO_THIRD_ORDER¶. Do compute third-order corrections?. Type: boolean; Default: false. INTS_TOLERANCE¶. Minimum absolute value below which all three-index DF integrals and those contributing to four-index integrals are neglected. The default is conservative, but there isn’t much to be gained from loosening it, especially for higher-order SAPT. Type: conv double; Default: 1.0e-12. SAPT_MEM_CHECK¶. Do force SAPT2 and higher to die if it thinks there isn’t enough memory? Turning this off is ill-advised. Type: boolean; Default: true. DEBUG¶. The amount of information to print to the output file. Type: integer; Default: 0. MP2 Natural Orbitals¶; One of the unique features of the SAPT module is its ability to use; MP2 natural orbitals (NOs) to speed up the evaluation of the triples; contribution to dispersion. By transforming to the MP2 NO basis, we can; throw away virtual orbitals that are expected to contribute little to the; dispersion energy. Speedups in excess of are possible. In; practice, this approximation is very good and should always be applied.; Publications resulting from the use of MP2 NO-based approximations should; cite the following: [Hohenstein:2010:104107]. Basic Keywords Controlling MP2 NO Approximations¶. NAT_ORBS_T2¶. Do use MP2 natural orbital approximations for the block of two-electron integrals in the evaluation of second-order T2 amplitudes? Recommended true for all SAPT computations. Type: boolean; Default: true. NAT_ORBS_T3¶. Do natural orbitals to speed up evaluation of the triples contribution to dispersion by truncating the virtual orbital space? Recommended true for all SAPT computations. Type: boolean; Default: true. NAT_ORBS_V4¶. Do use MP2 natural orbital approximations for the block of two-electron integrals in the evaluation of CCD T2 amplitudes? Recommended true for all SAPT computations. Type: boolean; Default: true. OC",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/sapt-1.html:16044,energy,energy,16044,psi4manual/1.0.0/sapt-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/sapt-1.html,2,['energy'],['energy']
Energy Efficiency,"SQT2); TRANSQT2 — Convert ROHF MOs to semicanonical MOs. Type: boolean; Default: true. SF_RESTRICT (DETCI); DETCI (Expert) — Do eliminate determinants not valid for spin-complete spin-flip CI’s? [see J. S. Sears et al, J. Chem. Phys. 118, 9084-9094 (2003)]. Type: boolean; Default: false. SIGMA_OVERLAP (DETCI); DETCI (Expert) — Do print the sigma overlap matrix? Not generally useful. Type: boolean; Default: false. SINGLES_PRINT (CCEOM); CCEOM — Do print information on the iterative solution to the single-excitation EOM-CC problem used as a guess to full EOM-CC?. Type: boolean; Default: false. SMALL_CUTOFF (PSIMRCC); PSIMRCC —. Type: integer; Default: 0. SO_S_FILE (TRANSQT); TRANSQT — SO basis overlap matrix file. Type: integer; Default: PSIF_OEI. SO_T_FILE (TRANSQT); TRANSQT — SO basis kinetic energy matrix file. Type: integer; Default: PSIF_OEI. SO_TEI_FILE (TRANSQT); TRANSQT — SO basis two-electron integrals file. Type: integer; Default: PSIF_SO_TEI. SO_V_FILE (TRANSQT); TRANSQT — SO basis potential energy matrix file. Type: integer; Default: PSIF_OEI. SOCC (GLOBALS); GLOBALS — An array containing the number of singly-occupied orbitals per irrep (in Cotton order). The value of DOCC should also be set. Type: array; Default: No Default. SOCC (MCSCF); MCSCF — The number of singly occupied orbitals, per irrep. Type: array; Default: No Default. SOLVER_CONVERGENCE (CPHF); CPHF — Solver convergence threshold (max 2-norm). Type: conv double; Default: 1.0e-6. SOLVER_EXACT_DIAGONAL (CPHF); CPHF — Solver exact diagonal or eigenvalue difference?. Type: boolean; Default: false. SOLVER_MAX_SUBSPACE (CPHF); CPHF — DL Solver maximum number of subspace vectors. Type: integer; Default: 6. SOLVER_MAXITER (CPHF); CPHF — Solver maximum iterations. Type: integer; Default: 100. SOLVER_MIN_SUBSPACE (CPHF); CPHF — DL Solver number of subspace vectors to collapse to. Type: integer; Default: 2. SOLVER_N_GUESS (CPHF); CPHF — DL Solver number of guesses. Type: integer; Default: 1. SOLVER_N_ROO",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/autodoc_glossary_options_c-1.html:120992,energy,energy,120992,psi4manual/4.0b4/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/autodoc_glossary_options_c-1.html,4,['energy'],['energy']
Energy Efficiency,"SQT2); TRANSQT2 — Convert ROHF MOs to semicanonical MOs. Type: boolean; Default: true. SF_RESTRICT (DETCI); DETCI (Expert) — Do eliminate determinants not valid for spin-complete spin-flip CI’s? [see J. S. Sears et al, J. Chem. Phys. 118, 9084-9094 (2003)]. Type: boolean; Default: false. SIGMA_OVERLAP (DETCI); DETCI (Expert) — Do print the sigma overlap matrix? Not generally useful. Type: boolean; Default: false. SINGLES_PRINT (CCEOM); CCEOM — Do print information on the iterative solution to the single-excitation EOM-CC problem used as a guess to full EOM-CC?. Type: boolean; Default: false. SMALL_CUTOFF (PSIMRCC); PSIMRCC —. Type: integer; Default: 0. SO_S_FILE (TRANSQT); TRANSQT — SO basis overlap matrix file. Type: integer; Default: PSIF_OEI. SO_T_FILE (TRANSQT); TRANSQT — SO basis kinetic energy matrix file. Type: integer; Default: PSIF_OEI. SO_TEI_FILE (TRANSQT); TRANSQT — SO basis two-electron integrals file. Type: integer; Default: PSIF_SO_TEI. SO_V_FILE (TRANSQT); TRANSQT — SO basis potential energy matrix file. Type: integer; Default: PSIF_OEI. SOCC (GLOBALS); GLOBALS — An array containing the number of singly-occupied orbitals per irrep (in Cotton order). Type: array; Default: No Default. SOCC (MCSCF); MCSCF — The number of singly occupied orbitals, per irrep. Type: array; Default: No Default. SOLVER_CONVERGENCE (CPHF); CPHF — Solver convergence threshold (max 2-norm). Type: conv double; Default: 1.0e-6. SOLVER_EXACT_DIAGONAL (CPHF); CPHF — Solver exact diagonal or eigenvalue difference?. Type: boolean; Default: false. SOLVER_MAX_SUBSPACE (CPHF); CPHF — DL Solver maximum number of subspace vectors. Type: integer; Default: 6. SOLVER_MAXITER (CPHF); CPHF — Solver maximum iterations. Type: integer; Default: 100. SOLVER_MIN_SUBSPACE (CPHF); CPHF — DL Solver number of subspace vectors to collapse to. Type: integer; Default: 2. SOLVER_N_GUESS (CPHF); CPHF — DL Solver number of guesses. Type: integer; Default: 1. SOLVER_N_ROOT (CPHF); CPHF — DL Solver number of r",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/autodoc_glossary_options_c-1.html:115127,energy,energy,115127,psi4manual/4.0b3/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodoc_glossary_options_c-1.html,2,['energy'],['energy']
Energy Efficiency,"SQUARESIGNEDDEVIATION>`. .. note:: It is very easy to make a database from a collection of xyz files; using the script :source:`lib/scripts/ixyz2database.pl`.; See :ref:`sec:createDatabase` for details. .. caution:: Some features are not yet implemented. Buy a developer some coffee. - In sow/reap mode, use only global options (e.g., the local option set by ``set scf scf_type df`` will not be respected). :type name: string; :param name: ``'scf'`` || ``'sapt0'`` || ``'ccsd(t)'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; :py:func:`~driver.energy`. :type db_name: string; :param db_name: ``'BASIC'`` || ``'S22'`` || ``'HTBH'`` || etc. Second argument, usually unlabeled. Indicates the requested database; name, matching the name of a python file in ``psi4/lib/databases``.; Consult that directory for available databases and literature citations. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``energy`` |dr| || ``optimize`` || ``cbs``. Indicates the type of calculation to be performed on each database; member. The default performs a single-point ``energy('name')``, while; ``optimize`` perfoms a geometry optimization on each reagent, and; ``cbs`` performs a compound single-point energy. If a nested series; of python functions is intended (see :ref:`sec:intercalls`), use; keyword ``db_func`` instead of ``func``. :type mode: string; :param mode: |dl| ``'continuous'`` |dr| || ``'sow'`` || ``'reap'``. Indicates whether the calculations required to complete the; database are to be run in one file (``'continuous'``) or are to be; farmed out in an embarrassingly parallel fashion; (``'sow'``/``'reap'``). For the latter, run an initial job with; ``'sow'`` and follow instructions in its output file. :type cp: :ref:`boolean <op_py_boolean>`; :param cp: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether counterpoise correction is employed in computing; interaction energies. U",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:24035,energy,energy,24035,psi4manual/4.0b2/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html,2,['energy'],['energy']
Energy Efficiency,"SSIGNMENT=SAOx/SIAOx Link A orthogonalized to A in whole (interacting) molecule or in the (noninteracting) fragment?. Type: string; Possible Values: FRAGMENT, WHOLE, NONE; Default: FRAGMENT. FISAPT_LINK_SELECTION¶. Specification algorithm for link bonds in ISAPT. Type: string; Possible Values: AUTOMATIC, MANUAL; Default: AUTOMATIC. FISAPT_MANUAL_LINKS¶. Manual link bond specification [[Atom1, Atom2], …]. Type: array; Default: No Default. FISAPT_PLOT_FILEPATH¶. Filepath to drop scalar data within input file directory. Type: string; Default: plot/. INTS_TOLERANCE¶. Schwarz screening threshold. Mininum absolute value below which TEI are neglected. Type: conv double; Default: 0.0. LOCAL_CONVERGENCE¶. Relative convergence in orbital localization. Type: conv double; Default: 1.0e-12. LOCAL_IBO_POWER¶. IBO localization metric power. Type: integer; Default: 4. LOCAL_IBO_STARS¶. IBO Centers for Pi Degeneracy. Type: array; Default: No Default. LOCAL_IBO_STARS_COMPLETENESS¶. IBO Charge metric for classification as Pi. Type: double; Default: 0.90. LOCAL_IBO_USE_STARS¶. IBO Stars procedure. Type: boolean; Default: false. LOCAL_MAXITER¶. Maximum iterations in localization. Type: integer; Default: 1000. MAXITER¶. Maximum number of iterations for CPHF. Type: integer; Default: 50. SSAPT0_SCALE¶. Do sSAPT0 exchange-scaling with F-SAPT. Type: boolean; Default: false. Expert¶. CUBIC_BASIS_TOLERANCE¶. CubicScalarGrid basis cutoff. Type: conv double; Default: 1.0e-12. CUBIC_BLOCK_MAX_POINTS¶. CubicScalarGrid maximum number of grid points per evaluation block. Type: integer; Default: 1000. FISAPT_MEM_SAFETY_FACTOR¶. Memory safety factor for heavy FISAPT operations. Type: double; Default: 0.9. LOCAL_IBO_CONDITION¶. Condition number to use in IBO metric inversions. Type: double; Default: 1.0e-7. LOCAL_USE_GHOSTS¶. Use ghost atoms in Pipek-Mezey or IBO metric. Type: boolean; Default: false. MINAO_BASIS¶. MinAO Basis for IBO. Type: string; Default: CC-PVTZ-MINAO. table of contents. FISAPT; Ge",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/autodir_options_c/module__fisapt.html:3286,Charge,Charge,3286,psi4manual/1.8.x/autodir_options_c/module__fisapt.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/autodir_options_c/module__fisapt.html,3,['Charge'],['Charge']
Energy Efficiency,"ST ENERGY. EFP EXCH ENERGY. EFP IND ENERGY. EFP TORQUE. EFP TOTAL ENERGY. EFP_DISP (EFP). EFP_DISP_DAMPING (EFP). EFP_ELST (EFP). EFP_ELST_DAMPING (EFP). EFP_EXCH (EFP). EFP_IND (EFP). EFP_IND_DAMPING (EFP). EFP_QM_ELST (EFP). EFP_QM_IND (EFP). efzc() psi4.core.Wavefunction method. EKT_EA (OCC). EKT_IP (DFOCC). (OCC). electric_field() psi4.core.IntegralFactory method. psi4.core.MintsHelper method. electric_field_value() psi4.core.MintsHelper method. ElectricFieldInt class in psi4.core. electrostatic() psi4.core.IntegralFactory method. electrostatic_potential_value() psi4.core.MintsHelper method. ElectrostaticInt class in psi4.core. elevation psi4.driver.p4util.InPsight attribute. elst() psi4.core.FISAPT method. embedding_charges psi4.driver.driver_nbody.ManyBodyComputer attribute. EmpiricalDispersion class in psi4.driver. class in psi4.driver.procrouting.empirical_dispersion. end() psi4.core.Slice method. energies_from_fcidump() in module psi4.driver. in module psi4.driver.p4util. energy(). setting keywords. energy() in module psi4.driver. psi4.core.Wavefunction method. ENERGY_LEVEL_SHIFT (DCT). engine psi4.driver.EmpiricalDispersion attribute. psi4.driver.procrouting.empirical_dispersion.EmpiricalDispersion attribute. ENSURE_BT_CONVERGENCE (OPTKING). ENTHALPY. ENTHALPY CORRECTION. environment variable. ; BRIANQC_ENABLE, [1]. BRIANQC_INSTALL_PATH, [1], [2]. BRIANQC_SDK_INSTALL, [1]. CONDA_PREFIX, [1], [2]. CRAY_ADD_RPATH. CRAYPE_LINK_TYPE. HOST, [1], [2]. MATH_ROOT. MKL_NUM_THREADS, [1]. MKL_ROOT. MONTAGE, [1]. OMP_NESTED, [1], [2]. OMP_NUM_THREADS, [1], [2], [3], [4], [5], [6], [7], [8], [9]. PATH, [1], [2], [3], [4], [5], [6], [7], [8], [9], [10], [11], [12], [13], [14], [15], [16], [17], [18], [19], [20], [21], [22], [23], [24], [25], [26], [27], [28], [29], [30], [31], [32], [33]. PSI_SCRATCH, [1], [2], [3], [4], [5], [6], [7], [8], [9], [10], [11], [12]. PSIDATADIR, [1], [2], [3], [4], [5], [6], [7], [8], [9]. PSIPATH, [1], [2], [3], [4], [5], [6], [7], [8], [9",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/genindex.html:45550,energy,energy,45550,psi4manual/1.7.x/genindex.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/genindex.html,2,['energy'],['energy']
Energy Efficiency,"STO-3G basis set, leaving the unlabelled hydrogen; atoms with the DZ basis set. Likewise, the fourth line assigns the STO-3G; basis set to just the carbon atoms labelled C1. This bizarre example was; constructed to demonstrate the syntax, but the flexibility of the basis set; specification is advantageous, for example, when selectively omitting diffuse; functions to make computations more tractable.; In the above example the basis sets have been assigned asymmetrically, reducing; the effective symmetry from \(D_{6h}\) to \(C_{2v}\); PSI4 will detect this; automatically and run in the appropriate point group.; Basis blocks can also be named, e.g., basis; optional_basis_name {...} and the basis defined by it later; applied to another molecule.; # sets basis keyword; basis mybas {; assign aug-cc-pvtz; assign f cc-pvtz; }. # re-sets basis keyword; set basis aug-cc-pvtz. molecule hf {; H; F 1 1.0; }. molecule h2o {; O; H 1 1.0; H 1 1.0 2 90.0; }. # runs HF and H2O with aug-cc-pvtz; energy('hf', molecule=hf); energy('hf', molecule=h2o). # re-re-sets basis keyword; set basis mybas. # runs HF with cc-pvtz on F and aug-cc-pvtz on H; energy('hf', molecule=hf). # runs H2O with aug-cc-pvtz, effectively; energy('hf', molecule=h2o). Finally, we note that the basis {...} block may also be used; for defining basis sets, as detailed in User-Defined Basis Sets.; Calculations requesting density fitting (on by default for many methods); require auxiliary fitting basis set(s) in addition to the primary; orbital one associated with the BASIS keyword.; When most popular basis sets are being used, including Dunning and; Pople-style, the SCF, DF-MP2, and SAPT codes will chose the appropriate; auxiliary basis set automatically according to Auxiliary Basis Sets,; unless instructed otherwise by setting the auxiliary basis set in the; input.; Should needed elements be missing from the best; auxiliary basis or should the orbital basis be unknown to PSI4,; the auxiliary basis will fall back on def",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/basissets-1.html:4446,energy,energy,4446,psi4manual/1.4.0/basissets-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/basissets-1.html,18,['energy'],['energy']
Energy Efficiency,"STO-3G finite-difference tests. mints5; Tests to determine full point group symmetry. Currently, these only matter for the rotational symmetry number in thermodynamic computations. sapt6; checks that all SAPT physical components (elst, exch, indc, disp) and total IE are being computed correctly for SAPT2+3(CCD)dMP2/aug-cc-pvdz and all lesser methods thereof. cc4a; RHF-CCSD(T) cc-pVQZ frozen-core energy of the BH molecule, with Cartesian input. This version tests the FROZEN_DOCC option explicitly. matrix1; An example of using BLAS and LAPACK calls directly from the Psi input file, demonstrating matrix multiplication, eigendecomposition, Cholesky decomposition and LU decomposition. These operations are performed on vectors and matrices provided from the Psi library. mp2-property; MP2 cc-pvDZ properties for Nitrogen oxide. pywrap-checkrun-rohf; This checks that all energy methods can run with a minimal input and set symmetry. dft-smoke; DFT Functional Smoke Test. omp2p5-2; OMP2 cc-pVDZ energy for the H2O molecule. dcft1; DC-06, DC-12, ODC-06 and ODC-12 calculation for the He dimer. This performs a simultaneous update of the orbitals and cumulant, using DIIS extrapolation. Four-virtual integrals are handled in the MO Basis. opt7; Various constrained energy minimizations of HOOH with cc-pvdz RHF. For “fixed” coordinates, the final value is provided by the user. sapt4; SAPT2+(3) aug-cc-pVDZ computation of the formamide dimer interaction energy, using the aug-cc-pVDZ-JKFIT DF basis for SCF and aug-cc-pVDZ-RI for SAPT. This example uses frozen core as well as MP2 natural orbital approximations. cc26; Single-point gradient, analytic and via finite-differences of 2-1A1 state of H2O with EOM-CCSD. scf-guess-read2; Test if the the guess read in the same basis converges. dft-pbe0-2; Internal match to psi4, test to match to literature values in litref.in/litref.out. gibbs; Test Gibbs free energies at 298 K of N2, H2O, and CH4. props2; DF-SCF cc-pVDZ of benzene-hydronium ion, scan",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/autodoc_testsuite_corepsi4-1.html:33210,energy,energy,33210,psi4manual/1.2.1/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/autodoc_testsuite_corepsi4-1.html,4,['energy'],['energy']
Energy Efficiency,"S_BUFFER']['value'] = 512; options['QCHEM']['QCHEM_MAX_SCF_CYCLES']['value'] = 200. options['QCHEM']['QCHEM_SYM_IGNORE']['value'] = True; options['QCHEM']['QCHEM_SYMMETRY']['value'] = False; options['QCHEM']['QCHEM_INTEGRALS_BUFFER']['value'] = 512. return text, options. [docs]def muster_modelchem(name, dertype):; """"""Transform calculation method *name* and derivative level *dertype*; into options for cfour. While deliberately requested pieces,; generally |cfour__cfour_deriv_level| and |cfour__cfour_calc_level|,; are set to complain if contradicted ('clobber' set to True), other; 'recommended' settings, like |cfour__cfour_cc_program|, can be; countermanded by keywords in input file ('clobber' set to False).; Occasionally, want these pieces to actually overcome keywords in; input file ('superclobber' set to True). """"""; text = ''; lowername = name.lower(); options = defaultdict(lambda: defaultdict(dict)). if dertype == 0:; options['QCHEM']['QCHEM_JOBTYPE']['value'] = 'SP'; # text += """"""energy('""""""; else:; raise ValidationError(""""""Requested Psi4 dertype %d is not available."""""" % (dertype)). if lowername == 'wb97x-v':; options['QCHEM']['QCHEM_EXCHANGE']['value'] = 'omegaB97X-V'. # text += """"""mp2')\n\n""""""; #; # elif lowername == 'df-mp2':; # options['GLOBALS']['FREEZE_CORE']['value'] = True; # options['SCF']['SCF_TYPE']['value'] = 'df'; # options['MP2']['MP2_TYPE']['value'] = 'df'; # text += """"""mp2')\n\n""""""; #; # elif lowername == 'sapt0':; # options['GLOBALS']['FREEZE_CORE']['value'] = True; # options['SCF']['SCF_TYPE']['value'] = 'df'; # text += """"""sapt0')\n\n""""""; #; # elif lowername == 'sapt2+':; # options['GLOBALS']['FREEZE_CORE']['value'] = True; # options['SCF']['SCF_TYPE']['value'] = 'df'; # options['SAPT']['NAT_ORBS_T2']['value'] = True; # options['SAPT']['NAT_ORBS_T3']['value'] = True; # options['SAPT']['NAT_ORBS_V4']['value'] = True; # options['SAPT']['OCC_TOLERANCE']['value'] = 1.0e-6; # text += """"""sapt2+')\n\n""""""; #; # elif lowername == 'sapt2+(3)':; # options[",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/qchem.html:12031,energy,energy,12031,psi4manual/1.0.0/_modules/qcdb/qchem.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/qchem.html,1,['energy'],['energy']
Energy Efficiency,"S_SCALE (OCC); OCC — CEPA opposite-spin scaling value from SCS-CCSD. Type: double; Default: 1.27. CEPA_SOS_SCALE (OCC); OCC — CEPA Spin-opposite scaling (SOS) value. Type: double; Default: 1.3. CEPA_SS_SCALE (OCC); OCC — CEPA same-spin scaling value from SCS-CCSD. Type: double; Default: 1.13. CEPA_TYPE (OCC); OCC — CEPA type such as CEPA0, CEPA1 etc. currently we have only CEPA0. Type: string; Possible Values: CEPA0; Default: CEPA0. CFOUR_ABCDTYPE (CFOUR); CFOUR — Specifies the way the molecular orbital integrals are handled in post-MP2 calculations. STANDARD (= 0) uses directly the corresponding MO integrals and thus results in an algorithm which in particular for large-scale calculations results in excessive use of disk space (storage of all integrals. AOBASIS (=2) uses an AO-based algorithm to evaluate all terms involving the integrals and significantly reduces the amount of disk storage. The use of ABCDTYPE=AOBASIS is strongly recommended for all CC calculations up to CCSD(T) and has been implemented for energy, gradient, second-derivative, and excitation energy calculations. Type: string; Possible Values: STANDARD, AOBASIS; Default: STANDARD. CFOUR_ACTIVE_ORBI (CFOUR); CFOUR — Specifies the active orbitals used in a TCSCF calculation and has to be used in combination with the keyword CFOUR_CORE_ORBITALS. The active orbitals are specified by either NIRREP or 2*NIRREP integers specifying the number of active orbitals of each symmetry type, where NIRREP is the number of irreducible representations in the computational point group. If there are no orbitals of a particular symmetry type a zero must be entered. For more information and an example see CFOUR_OCCUPATION . Type: array; Default: No Default. CFOUR_ANH_ALGORITHM (CFOUR); CFOUR — Specifies which algorithm is used for CFOUR_ANHARMONIC =VIBROT, VPT2, and FULLQUARTIC calculations. If STANDARD (=0) is chosen, then simply invoking xcfour will cause a complete job to be run with all second-derivative calculations ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_glossary_options_c-1.html:17912,energy,energy,17912,psi4manual/1.0.0/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_glossary_options_c-1.html,4,['energy'],['energy']
Energy Efficiency,"S_SCF"",; core.get_option(""SCF"", ""DF_BASIS_SCF""),; ""JKFIT"", core.get_global_option('BASIS'),; puream=ref_wfn.basisset().has_puream()); ref_wfn.set_basisset(""DF_BASIS_SCF"", scf_aux_basis). if core.get_global_option(""RELATIVISTIC"") in [""X2C"", ""DKH""]:; rel_bas = core.BasisSet.build(ref_wfn.molecule(), ""BASIS_RELATIVISTIC"",; core.get_option(""SCF"", ""BASIS_RELATIVISTIC""),; ""DECON"", core.get_global_option('BASIS'),; puream=ref_wfn.basisset().has_puream()); ref_wfn.set_basisset('BASIS_RELATIVISTIC',rel_bas). fnocc_wfn = core.fnocc(ref_wfn). # set current correlation energy and total energy. only need to treat mpn here.; if name in [""mp3"", ""fno-mp3""]:; fnocc_wfn.set_variable(""CURRENT ENERGY"", fnocc_wfn.variable(""MP3 TOTAL ENERGY"")); fnocc_wfn.set_variable(""CURRENT CORRELATION ENERGY"", fnocc_wfn.variable(""MP3 CORRELATION ENERGY"")); elif name in [""mp4(sdq)"", ""fno-mp4(sdq)""]:; fnocc_wfn.set_variable(""CURRENT ENERGY"", fnocc_wfn.variable(""MP4(SDQ) TOTAL ENERGY"")); fnocc_wfn.set_variable(""CURRENT CORRELATION ENERGY"", fnocc_wfn.variable(""MP4(SDQ) CORRELATION ENERGY"")); elif name in [""mp4"", ""fno-mp4""]:; fnocc_wfn.set_variable(""CURRENT ENERGY"", fnocc_wfn.variable(""MP4 TOTAL ENERGY"")); fnocc_wfn.set_variable(""CURRENT CORRELATION ENERGY"", fnocc_wfn.variable(""MP4 CORRELATION ENERGY"")). # Shove variables into global space; for k, v in fnocc_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); return fnocc_wfn. def run_cepa(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a cepa-like calculation. >>> energy('cepa(1)'). """"""; kwargs = p4util.kwargs_lower(kwargs). # save user options; optstash = p4util.OptionsState(; ['TRANSQT2', 'WFN'],; ['FNOCC', 'NAT_ORBS'],; ['FNOCC', 'RUN_CEPA'],; ['FNOCC', 'USE_DF_INTS'],; ['FNOCC', 'CEPA_NO_SINGLES']). core.set_local_option('FNOCC', 'RUN_CEPA', True); core.set_local_option('FNOCC', 'USE_DF_INTS', False). # what type of cepa?; if name in ['lccd', 'fno-lccd']:; cepa_level = 'cepa(0)'; core.set_local_option('FNOCC'",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html:160300,ENERGY,ENERGY,160300,psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,3,['ENERGY'],['ENERGY']
Energy Efficiency,"Same as :py:func:`print_out` only displays dummy atoms. """"""; text = """"; if self.natom():; if self.pg:; text += """""" Molecular point group: %s\n"""""" % (self.pg.symbol()); if self.full_pg:; text += """""" Full point group: %s\n\n"""""" % (self.get_full_point_group()); text += """""" Geometry (in %s), charge = %d, multiplicity = %d:\n\n"""""" % \; (self.units(), self.molecular_charge(), self.multiplicity()); text += """""" Center X Y Z \n""""""; text += """""" ------------ ----------------- ----------------- -----------------\n"""""". for i in range(self.nallatom()):; geom = self.full_atoms[i].compute(); text += """""" %8s%4s """""" % (self.fsymbol(i), """" if self.fZ(i) else ""(Gh)""); for j in range(3):; text += """""" %17.12f"""""" % (geom[j]); text += ""\n""; text += ""\n""; else:; text += "" No atoms in this molecule.\n""; print(text); # TODO outfile. [docs] def print_in_input_format(self):; """"""Print the molecule in the same format that the user provided.; """"""; text = """"; if self.nallatom():; text += "" Geometry (in %s), charge = %d, multiplicity = %d:\n\n"" % \; (""Angstrom"" if self.units() == 'Angstrom' else ""Bohr"",; self.molecular_charge(), self.multiplicity()); for i in range(self.nallatom()):; if self.fZ(i) or self.fsymbol(i) == ""X"":; text += "" %-8s"" % (self.fsymbol(i)); else:; text += "" %-8s"" % (""Gh("" + self.fsymbol(i) + "")""); text += self.full_atoms[i].print_in_input_format(); text += ""\n""; if len(self.geometry_variables):; for vb, val in self.geometry_variables.items():; text += """""" %-10s=%16.10f\n"""""" % (vb, val); text += ""\n"". print(text); # TODO outfile. [docs] def everything(self):; """"""Quick print of class data""""""; text = """""" ==> qcdb Molecule %s <==\n\n"""""" % (self.name()); text += """""" Natom %d\t\tNallatom %d\n"""""" % (self.natom(), self.nallatom()); text += """""" charge %d\t\tspecified? %s\n"""""" % (self.molecular_charge(), self.charge_specified()); text += """""" multiplicity %d\t\tspecified? %s\n"""""" % (self.multiplicity(), self.multiplicity_specified()); text += """""" units %s\tconversion %f\n"""""" % (self.units()",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html:30037,charge,charge,30037,psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html,1,['charge'],['charge']
Energy Efficiency,"Sample Inputs; <no title>. Input File; Description. psithon2; Accesses basis sets, databases, plugins, and executables in non-install locations. cc14; ROHF-CCSD/cc-pVDZ \(^{3}B_1\) CH2 geometry optimization via analytic gradients. ci-multi; BH single points, checking that program can run multiple instances of DETCI in a single input, without an intervening clean() call. omp3-2; OMP3 cc-pCVDZ energy with ROHF initial guess for the NO radical. fd-gradient; SCF STO-3G finite-difference tests. cc36; CC2(RHF)/cc-pVDZ energy of H2O. molden2; Test of the superposition of atomic densities (SAD) guess, using a highly distorted water geometry with a cc-pVDZ basis set. This is just a test of the code and the user need only specify guess=sad to the SCF module’s (or global) options in order to use a SAD guess. The test is first performed in C2v symmetry, and then in C1. fd-freq-gradient; SCF STO-3G finite-differences frequencies from gradients for H2O. soscf-dft; Triple and Singlet Oxygen energy SOSCF, also tests non-symmetric density matrices. mp2p5-grad1; MP2.5 cc-pVDZ gradient for the H2O molecule. cc5; RHF CCSD(T) cc-pVDZ frozen-core energy of C4NH4 Anion. tdscf-3; td-wb97x excitation energies of singlet states of h2o, wfn passing. psimrcc-ccsd_t-4; Mk-MRCCSD(T) single point. \(^1A_1\) O$_3` state described using the Ms = 0 component of the singlet. Uses TCSCF orbitals. castup2; SCF with various combinations of pk/density-fitting, castup/no-castup, and spherical/cartesian settings. Demonstrates that puream setting is getting set by orbital basis for all df/castup parts of calc. Demonstrates that answer doesn’t depend on presence/absence of castup. Demonstrates (by comparison to castup3) that output file doesn’t depend on options (scf_type) being set global or local. This input uses global. cc32; CC3/cc-pVDZ H2O \(R_e\) geom from Olsen et al., JCP 104, 8007 (1996). scf-response2; Compute the dipole polarizability for water with custom basis set. dct5; DC-06 calculation for th",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/autodoc_testsuite_corepsi4.html:1103,energy,energy,1103,psi4manual/1.9.x/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/autodoc_testsuite_corepsi4.html,1,['energy'],['energy']
Energy Efficiency,"Scaling', 'STR', 'Yes'); 	cavity.add_kw('AddSpheres', 'STR', 'Yes'); cavity.add_kw('Mode','STR','Explicit'); cavity.add_kw('Atoms','INT_ARRAY'); cavity.add_kw('Radii','DBL_ARRAY'); 	cavity.add_kw('RadiiSet', 'STR', 'Bondi'); 	cavity.add_kw('Spheres','DBL_ARRAY', callback=verify_spheres); 	top.add_sect(cavity); ; 	medium=getkw.Section('Medium', callback=verify_medium); 	medium.add_kw('Solvent', 'STR', 'Water'); 	medium.add_kw('SolverType', 'STR', 'IEFPCM'); 	medium.add_kw('EquationType','STR', 'SecondKind'); 	medium.add_kw('Correction', 'DBL', 0.0); 	medium.add_kw('ProbeRadius', 'DBL', 1.0); 	top.add_sect(medium); 	; 	green=getkw.Section('Green', callback=verify_green); 	green.add_kw('Type', 'STR', 'Vacuum'); 	green.add_kw('Der', 'STR', 'Derivative'); 	green.add_kw('Eps', 'DBL', 1.0); 	green.add_kw('EpsRe', 'DBL', 1.0); 	green.add_kw('EpsImg', 'DBL', 1.0); 	green.add_kw('SphereRadius', 'DBL', 1.0); 	green.add_kw('SpherePosition', 'DBL_ARRAY'); 	medium.add_sect(green). 	green_part = deepcopy(green); 	green.add_sect(green_part). 	return top. [docs]def verify_top(section):; 	global isAngstrom; 	allowed_units = ('AU', 'Angstrom'); 	key = section.get('Units'); 	val = key.get(); 	if (val not in allowed_units):; 	 	print ""Allowed units are: "", allowed_units; 		sys.exit(1); 	if (val == 'Angstrom'):; 		isAngstrom = True. [docs]def verify_cavity(section):; 	allowed = ('GePol', 'Wavelet'); type = section.get('Type'); if (type.get() not in allowed):; 	print ""Allowed types are: "", allowed; 	sys.exit(1). 	if section['Area'].is_set(): convert_area_scalar(section['Area']); 	if (type.get() == 'GePol'):; 	area=section.get('Area'); 	a=area.get(); 	if (a < 0.01):; 		print ""Area value is too small""; 		print ""Minimum value: 0.01""; 		sys.exit(1); elif (type.get() == 'Wavelet'):; 	key = section.get('PatchLevel'); 	if (key.get() < 1):; 		print ""Patch level must be > 0""; 		sys.exit(1); 	key = section.get('Coarsity'); 	if (key.get() < 0.0 or key.get() >= 1.0):; 		print ""Coarsity has to be withi",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/pcmpreprocess.html:1587,green,green,1587,psi4manual/4.0b5/_modules/pcmpreprocess.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/pcmpreprocess.html,4,['green'],['green']
Energy Efficiency,"Second Order GGA Exchange-Correlation Functional. sogga_x; Second Order GGA Exchange Hole (Parameter Free). svwn; SVWN3 (RPA) LSDA Functional. s_x; Slater LSDA Exchange. vwn3rpa_c; VWN3 (RPA) LSDA Correlation. vwn3_c; VWN3 LSDA Correlation. vwn5rpa_c; VWN5 (RPA) LSDA Correlation. vwn5_c; VWN5 LSDA Correlation. dldf; Dispersionless Hybrid Meta-GGA XC Functional. dldf+d; Dispersionless Hybrid Meta-GGA XC Functional w/ Podeszwa and Szalewicz Dispersion Correction. dldf+d09; Dispersionless Hybrid Meta-GGA XC Functional w/ Podeszwa and Szalewicz Dispersion Correction. Warning; Optimizations where the molecule is specified in Z-matrix format ; with dummy atoms will result in the geometry being converted to a Cartesian representation. Parameters:; name (string) – 'scf' || 'df-mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; energy(). func (function) – gradient || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. mode (string) – 'continuous' || 'sow' || 'reap'; For a finite difference of energies optimization, indicates whether; the calculations required to complete the; optimization are to be run in one file ('continuous') or are to be; farmed out in an embarrassingly parallel fashion; ('sow'/'reap'). For the latter, run an initial job with; 'sow' and follow instructions in its output file. dertype (dertype) – 'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. Examples :. >>> # [1] Analytic scf optimization; >>> optimize('scf'). >>> # [2] Finite d",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/opt-1.html:6660,energy,energy,6660,psi4manual/4.0b4/opt-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/opt-1.html,2,['energy'],['energy']
Energy Efficiency,"Section('Cavity', callback=verify_cavity); 	cavity.add_kw('Type','STR'); 	cavity.add_kw('PatchLevel', 'INT', 2); 	cavity.add_kw('Coarsity', 'DBL', 0.5); 	cavity.add_kw('Area','DBL', 0.3); 	cavity.add_kw('Scaling', 'STR', 'Yes'); 	cavity.add_kw('AddSpheres', 'STR', 'Yes'); cavity.add_kw('Mode','STR','Explicit'); cavity.add_kw('Atoms','INT_ARRAY'); cavity.add_kw('Radii','DBL_ARRAY'); 	cavity.add_kw('RadiiSet', 'STR', 'Bondi'); 	cavity.add_kw('Spheres','DBL_ARRAY', callback=verify_spheres); 	top.add_sect(cavity); ; 	medium=getkw.Section('Medium', callback=verify_medium); 	medium.add_kw('Solvent', 'STR', 'Water'); 	medium.add_kw('SolverType', 'STR', 'IEFPCM'); 	medium.add_kw('EquationType','STR', 'SecondKind'); 	medium.add_kw('Correction', 'DBL', 0.0); 	medium.add_kw('ProbeRadius', 'DBL', 1.0); 	top.add_sect(medium); 	; 	green=getkw.Section('Green', callback=verify_green); 	green.add_kw('Type', 'STR', 'Vacuum'); 	green.add_kw('Der', 'STR', 'Derivative'); 	green.add_kw('Eps', 'DBL', 1.0); 	green.add_kw('EpsRe', 'DBL', 1.0); 	green.add_kw('EpsImg', 'DBL', 1.0); 	green.add_kw('SphereRadius', 'DBL', 1.0); 	green.add_kw('SpherePosition', 'DBL_ARRAY'); 	medium.add_sect(green). 	green_part = deepcopy(green); 	green.add_sect(green_part). 	return top. [docs]def verify_top(section):; 	global isAngstrom; 	allowed_units = ('AU', 'Angstrom'); 	key = section.get('Units'); 	val = key.get(); 	if (val not in allowed_units):; 	 	print ""Allowed units are: "", allowed_units; 		sys.exit(1); 	if (val == 'Angstrom'):; 		isAngstrom = True. [docs]def verify_cavity(section):; 	allowed = ('GePol', 'Wavelet'); type = section.get('Type'); if (type.get() not in allowed):; 	print ""Allowed types are: "", allowed; 	sys.exit(1). 	if section['Area'].is_set(): convert_area_scalar(section['Area']); 	if (type.get() == 'GePol'):; 	area=section.get('Area'); 	a=area.get(); 	if (a < 0.01):; 		print ""Area value is too small""; 		print ""Minimum value: 0.01""; 		sys.exit(1); elif (type.get() == 'Wavelet'):; 	key = sect",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/pcmpreprocess.html:1378,green,green,1378,psi4manual/4.0b5/_modules/pcmpreprocess.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/pcmpreprocess.html,2,['green'],['green']
Energy Efficiency,See Table// Post-SCF Convergence for default convergence// criteria for different calculation types. Type: conv double; Default: 1e-6. E_CONVERGENCE (CCEOM); CCEOM — Convergence criterion for excitation energy (change) in the Davidson algorithm for CC-EOM. See Table Post-SCF Convergence for default convergence criteria for different calculation types. Type: conv double; Default: 1e-6. E_CONVERGENCE (DETCI); DETCI — Convergence criterion for energy. See Table Post-SCF Convergence for default convergence criteria for different calculation types. Type: conv double; Default: 1e-6. E_CONVERGENCE (FNOCC); FNOCC — Convergence criterion for CC energy. See Table Post-SCF Convergence for default convergence criteria for different calculation types. Note that convergence is met only when E_CONVERGENCE and R_CONVERGENCE are satisfied. Type: conv double; Default: 1.0e-6. E_CONVERGENCE (MCSCF); MCSCF — Convergence criterion for energy. Type: conv double; Default: 1e-6. E_CONVERGENCE (MRCC); MRCC — Convergence criterion for energy. See Table Post-SCF Convergence for default convergence criteria for different calculation types. This becomes tol (option #16) in fort.56. Type: conv double; Default: 1e-6. E_CONVERGENCE (OCC); OCC — Convergence criterion for energy. See Table Post-SCF Convergence for default convergence criteria for different calculation types. Type: conv double; Default: 1e-6. E_CONVERGENCE (PSIMRCC); PSIMRCC — Convergence criterion for energy. See Table Post-SCF Convergence for default convergence criteria for different calculation types. Type: conv double; Default: 1e-6. E_CONVERGENCE (SAPT); SAPT — Convergence criterion for energy (change) in the SAPT term during solution of the CPHF equations. Type: conv double; Default: 1e-10. E_CONVERGENCE (SCF); SCF — Convergence criterion for SCF energy. See Table SCF Convergence & Algorithm for default convergence criteria for different calculation types. Type: conv double; Default: 1e-6. EA_POLES (OCC); OCC — Do compute OCC p,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/autodoc_glossary_options_c-1.html:38229,energy,energy,38229,psi4manual/4.0b5/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodoc_glossary_options_c-1.html,2,['energy'],['energy']
Energy Efficiency,"Sherrill and P. Piecuch, J. Chem. Phys. 122, 124104 (2005). cbs-xtpl-wrapper; RHF aug-cc-pVQZ energy for the BH molecule, with Cartesian input. Various gradients for a strained helium dimer and water molecule. pywrap-align; apply linear fragmentation algorithm to a water cluster. dfccsd1; DF-CCSD cc-pVDZ energy for the H2O molecule. cc13b; Tests RHF CCSD(T)gradients. x2c1; Test of SFX2C-1e on water uncontracted cc-pVDZ-DK The reference numbers are from Lan Cheng’s implementation in Cfour. scf-property; UFH and B3LYP cc-pVQZ properties for the CH2 molecule. dfomp2p5-2; DF-OMP2.5 cc-pVDZ energy for the H2O+ cation. soscf-dft; Triple and Singlet Oxygen energy SOSCF, also tests non-symmetric density matrices. opt14; 6-31G(d) optimization of SF4 starting from linear bond angle that is not linear in the optimized structure but is in a symmetry plane of the molecule. dcft-grad1; DCFT DC-06 gradient for the O2 molecule with cc-pVDZ basis set. pywrap-checkrun-rhf; This checks that all energy methods can run with a minimal input and set symmetry. opt5; 6-31G** UHF CH2 3B1 optimization. Uses a Z-Matrix with dummy atoms, just for demo and testing purposes. cc53; Matches Table II a-CCSD(T)/cc-pVDZ H2O @ 2.5 * Re value from Crawford and Stanton, IJQC 98, 601-611 (1998). dfomp3-1; DF-OMP3 cc-pVDZ energy for the H2O molecule. psithon1; Spectroscopic constants of H2, and the full ci cc-pVTZ level of theory. scf-response1; Compute the dipole, quadrupole, and traceless quadrupoles for water. tu5-sapt; Example SAPT computation for ethene*ethine (i.e., ethylene*acetylene), test case 16 from the S22 database. cc39; RHF-CC2-LR/cc-pVDZ dynamic polarizabilities of HOF molecule. cc18; RHF-CCSD-LR/cc-pVDZ static polarizability of HOF. frac-ip-fitting; Omega optimization for LRC functional wB97 on water. dfomp2-1; OMP2 cc-pVDZ energy for the H2O molecule. cc35; CC3(ROHF)/cc-pVDZ H2O \(R_e\) geom from Olsen et al., JCP 104, 8007 (1996). fd-freq-energy-large; SCF DZ finite difference frequencies",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/autodoc_testsuite_corepsi4-1.html:15417,energy,energy,15417,psi4manual/1.2.1/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/autodoc_testsuite_corepsi4-1.html,8,['energy'],['energy']
Energy Efficiency,"Simmonett. psi4.driver.diatomic.anharmonicity(rvals, energies, plot_fit='', mol=None)[source]¶; Generates spectroscopic constants for a diatomic molecules.; Fits a diatomic potential energy curve using a weighted least squares approach; (c.f. https://doi.org/10.1063/1.4862157, particularly eqn. 7), locates the minimum; energy point, and then applies second order vibrational perturbation theory to obtain spectroscopic; constants. Any number of points greater than 4 may be provided, and they should bracket the minimum.; The data need not be evenly spaced, and can be provided in any order. The data are weighted such that; those closest to the minimum have highest impact.; A dictionary with the following keys, which correspond to spectroscopic constants, is returned:. Parameters:. rvals (List[float]) – The bond lengths (in Angstrom) for which energies are; provided, of length at least 5 and equal to the length of the energies array; energies (List[float]) – The energies (Eh) computed at the bond lengths in the rvals list; plot_fit (str) – A string describing where to save a plot of the harmonic and anharmonic fits, the; inputted data points, re, r0 and the first few energy levels, if matplotlib; is available. Set to ‘screen’ to generate an interactive plot on the screen instead. If a filename is; provided, the image type is determined by the extension; see matplotlib for supported file types. Return type:; Dict[str, Any]. Returns:; (dict) Keys: “re”, “r0”, “we”, “wexe”, “nu”, “ZPVE(harmonic)”, “ZPVE(anharmonic)”, “Be”, “B0”, “ae”, “De”; corresponding to the spectroscopic constants in cm-1. table of contents. Spectroscopic Constants for Diatomics; anharmonicity(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. Psithon Functions: Invoking a Calculation; Spectroscopic Constants for Diatomics. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/diatomic.html:1438,energy,energy,1438,psi4manual/1.8.x/diatomic.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/diatomic.html,1,['energy'],['energy']
Energy Efficiency,"Simmonett. psi4.driver.diatomic.anharmonicity(rvals, energies, plot_fit='', mol=None)[source]¶; Generates spectroscopic constants for a diatomic molecules.; Fits a diatomic potential energy curve using a weighted least squares approach; (c.f. https://doi.org/10.1063/1.4862157, particularly eqn. 7), locates the minimum; energy point, and then applies second order vibrational perturbation theory to obtain spectroscopic; constants. Any number of points greater than 4 may be provided, and they should bracket the minimum.; The data need not be evenly spaced, and can be provided in any order. The data are weighted such that; those closest to the minimum have highest impact.; A dictionary with the following keys, which correspond to spectroscopic constants, is returned:. Parameters:. rvals (List[float]) – The bond lengths (in Angstrom) for which energies are; provided, of length at least 5 and equal to the length of the energies array; energies (List[float]) – The energies (Eh) computed at the bond lengths in the rvals list; plot_fit (str) – A string describing where to save a plot of the harmonic and anharmonic fits, the; inputted data points, re, r0 and the first few energy levels, if matplotlib; is available. Set to ‘screen’ to generate an interactive plot on the screen instead. If a filename is; provided, the image type is determined by the extension; see matplotlib for supported file types. Return type:; Dict[str, Any]. Returns:; (dict) Keys: “re”, “r0”, “we”, “wexe”, “nu”, “ZPVE(harmonic)”, “ZPVE(anharmonic)”, “Be”, “B0”, “ae”, “De”; corresponding to the spectroscopic constants in cm-1. table of contents. Spectroscopic Constants for Diatomics; anharmonicity(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.9.1;  · . PSI4. Psithon Functions: Invoking a Calculation; Spectroscopic Constants for Diatomics. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/diatomic.html:1438,energy,energy,1438,psi4manual/1.9.x/diatomic.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/diatomic.html,1,['energy'],['energy']
Energy Efficiency,"Slater radii. cc25; Single point gradient of 1-2B2 state of H2O+ with EOM-CCSD. scf-ecp; Water-Argon complex with ECP present; check of energies and forces. dlpnomp2-3; comparison of DF-MP2 and DLPNO-MP2 with a cartesian basis set. scf-hess2; UHF STO-3G (Cartesian) and cc-pVDZ (spherical) water Hessian test, against Psi3 reference values. This test should match RHF values exactly. scf-level-shift-cuhf; SCF level shift on a CUHF computation. cubeprop; RHF orbitals and density for water. fci-tdm; He2+ FCI/cc-pVDZ Transition Dipole Moment. scf-hess1; RHF STO-3G (Cartesian) and cc-pVDZ (spherical) water Hessian test, against Psi3 reference values. rasci-c2-active; 6-31G* C2 Test RASCI Energy Point, testing two different ways of specifying the active space, either with the ACTIVE keyword, or with RAS1, RAS2, RESTRICTED_DOCC, and RESTRICTED_UOCC. cc53; Matches Table II a-CCSD(T)/cc-pVDZ H2O @ 2.5 * Re value from Crawford and Stanton, IJQC 98, 601-611 (1998). scf1; RHF cc-pVQZ energy for the BH molecule, with Cartesian input. mom; Maximum Overlap Method (MOM) Test. MOM is designed to stabilize SCF convergence and to target excited Slater determinants directly. dft-custom-hybrid; DFT (hybrids) test of implementations in: hybrid_superfuncs.py. fsapt-ext-abc2; FSAPT with external charge on dimer. cc34; RHF-CCSD/cc-pVDZ energy of H2O partitioned into pair energy contributions. cc23; ROHF-EOM-CCSD/DZ analytic gradient lowest \(^{2}B_1\) state of H2O+ (A1 excitation). omp3-1; OMP3 cc-pVDZ energy for the H2O molecule. pywrap-db3; Test that Python Molecule class processes geometry like psi4 Molecule class. dft-freq-analytic; Analytic SVWN frequencies, compared to finite difference values. scf-response3; UHF Dipole Polarizability Test. psithon2; Accesses basis sets, databases, plugins, and executables in non-install locations. cc36; CC2(RHF)/cc-pVDZ energy of H2O. opt11; Transition-state optimizations of HOOH to both torsional transition states. opt6; Various constrained energy min",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/autodoc_testsuite_corepsi4.html:11545,energy,energy,11545,psi4manual/1.8.x/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/autodoc_testsuite_corepsi4.html,2,['energy'],['energy']
Energy Efficiency,"Spectroscopic Constants for Diatomics. Navigation. Index. modules    .    .    .    .  · ; 1.1;  · . PSI4. Psithon Functions: Invoking a Calculation. Spectroscopic Constants for Diatomics¶; Code author: Andrew C. Simmonett. psi4.driver.diatomic.anharmonicity(rvals, energies, plot_fit)[source]¶; Generates spectroscopic constants for a diatomic molecules.; Fits a diatomic potential energy curve using a weighted least squares approach; (c.f. http://dx.doi.org/10.1063/1.4862157, particularly eqn. 7), locates the minimum; energy point, and then applies second order vibrational perturbation theory to obtain spectroscopic; constants. Any number of points greater than 4 may be provided, and they should bracket the minimum.; The data need not be evenly spaced, and can be provided in any order. The data are weighted such that; those closest to the minimum have highest impact.; A dictionary with the following keys, which correspond to spectroscopic constants, is returned:. Parameters:; rvals (list) – The bond lengths (in Angstrom) for which energies are; provided, of length at least 5 and equal to the length of the energies array; energies (list) – The energies (Eh) computed at the bond lengths in the rvals list; plot_fit (string) – A string describing where to save a plot of the harmonic and anharmonic fits, the; inputted data points, re, r0 and the first few energy levels, if matplotlib; is available. Set to ‘screen’ to generate an interactive plot on the screen instead. If a filename is; provided, the image type is determined by the extension; see matplotlib for supported file types. Returns:(dict) Keys: “re”, “r0”, “we”, “wexe”, “nu”, “ZPVE(harmonic)”, “ZPVE(anharmonic)”, “Be”, “B0”, “ae”, “De”; corresponding to the spectroscopic constants in cm-1. Navigation. Index. modules    .    .    .    .  · ; 1.1;  · . PSI4. Psithon Functions: Invoking a Calculation. © Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/diatomic-1.html:1375,energy,energy,1375,psi4manual/1.1.0/diatomic-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/diatomic-1.html,2,['energy'],['energy']
Energy Efficiency,"Superficial test of PubChem interface. dfomp2-4; OMP2 cc-pVDZ energy for the NO molecule. dfmp2-freq2; DF-MP2 frequency by difference of energies for H2O. soscf-ref; Triple and Singlet Oxygen energy SOSCF, also tests non-symmetric density matrices. cc36; CC2(RHF)/cc-pVDZ energy of H2O. cbs-xtpl-gradient; Various gradients for a strained helium dimer and water molecule. dft-smoke; DFT Functional Smoke Test. dfmp2-2; Density fitted MP2 energy of H2, using density fitted reference and automatic looping over cc-pVDZ and cc-pVTZ basis sets. Results are tabulated using the built in table functions by using the default options and by specifiying the format. fci-coverage; 6-31G H2O Test for coverage. tdscf-5; td-camb3lyp with DiskDF and method/basis specification. scf-guess; Test initial SCF guesses on FH and FH+ in cc-pVTZ basis. opt1; SCF STO-3G geometry optimzation, with Z-matrix input. fsaptd-terms; F-SAPT0/jun-cc-pvdz procedure for methane dimer. cc4a; RHF-CCSD(T) cc-pVQZ frozen-core energy of the BH molecule, with Cartesian input. This version tests the FROZEN_DOCC option explicitly. sapt-exch-disp-inf; SAPT0 with S^inf exch-disp20. pywrap-opt-sowreap; Finite difference optimization, run in sow/reap mode. tu1-h2o-energy; Sample HF/cc-pVDZ H2O computation. mbis-5; MBIS calculation on ZnO. mbis-2; MBIS calculation on OH- (Expanded Arrays). nbody-he-cluster; MP2/aug-cc-pv[DT]Z many body energies of an arbitrary Helium complex Size vs cost tradeoff is rough here. pywrap-basis; SAPT calculation on bimolecular complex where monomers are unspecified so driver auto-fragments it. Basis set and auxiliary basis sets are assigned by atom type. mp2-property; MP2 cc-pvDZ properties for Nitrogen oxide. dft-freq-analytic; Analytic SVWN frequencies, compared to finite difference values. cc10; ROHF-CCSD cc-pVDZ energy for the \(^2\Sigma^+\) state of the CN radical. casscf-sp; CASSCF/6-31G** energy point. extern3; External potential calculation with one Ghost atom and one point charge at",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/autodoc_testsuite_corepsi4-1.html:6612,energy,energy,6612,psi4manual/1.4.0/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodoc_testsuite_corepsi4-1.html,4,['energy'],['energy']
Energy Efficiency,"T (see fsapt1 for a real example). cepa3; cc-pvdz H2O Test coupled-pair CISD against DETCI CISD. cc32; CC3/cc-pVDZ H2O \(R_e\) geom from Olsen et al., JCP 104, 8007 (1996). scf-hess1; RHF STO-3G (Cartesian) and cc-pVDZ (spherical) water Hessian test, against Psi3 reference values. ocepa-freq1; OCEPA cc-pVDZ freqs for C2H2. dfccsdt1; DF-CCSD(T) cc-pVDZ energy for the H2O molecule. pywrap-db2; Database calculation, run in sow/reap mode. sad1; Test of the superposition of atomic densities (SAD) guess, using a highly distorted water geometry with a cc-pVDZ basis set. This is just a test of the code and the user need only specify guess=sad to the SCF module’s (or global) options in order to use a SAD guess. The test is first performed in C2v symmetry, and then in C1. dft-psivar; HF and DFT variants single-points on zmat methane, mostly to test that PSI variables are set and computed correctly. Now also testing that CSX harvesting PSI variables correctly. ocepa2; OCEPA cc-pVDZ energy with B3LYP initial guess for the NO radical. dcft5; DC-06 calculation for the O2 molecule (triplet ground state). This performs geometry optimization using two-step and simultaneous solution of the response equations for the analytic gradient. opt-irc-1; Compute the IRC for HOOH torsional rotation at the RHF/DZP level of theory. dcft2; DC-06 calculation for the He dimer. This performs a two-step update of the orbitals and cumulant, using DIIS extrapolation. Four-virtual integrals are handled in the MO Basis. fci-tdm-2; BH-H2+ FCI/cc-pVDZ Transition Dipole Moment. dfcasscf-fzc-sp; CASSCF/6-31G** energy point. cepa2; cc-pvdz H2O Test ACPF Energy/Properties. cc24; Single point gradient of 1-2B1 state of H2O+ with EOM-CCSD. castup1; Test of SAD/Cast-up (mainly not dying due to file weirdness). dfomp3-grad1; DF-OMP3 cc-pVDZ gradients for the H2O molecule. pywrap-alias; Test parsed and exotic calls to energy() like zapt4, mp2.5, and cisd are working. fci-dipole; 6-31G H2O Test FCI Energy Point. cc2",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/testsuite-1.html:10086,energy,energy,10086,psi4manual/1.1.0/testsuite-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/testsuite-1.html,4,['energy'],['energy']
Energy Efficiency,"T EXCH-IND20,R ENERGY; SAPT EXCH-IND20,U ENERGY; SAPT EXCH-IND22 ENERGY; SAPT EXCH-IND30(S^INF) ENERGY; SAPT EXCH-IND30,R ENERGY; SAPT EXCH-IND30,R(S^INF) ENERGY; SAPT EXCH10 ENERGY; SAPT EXCH10(S^2) ENERGY; SAPT EXCH11(S^2) ENERGY; SAPT EXCH12(S^2) ENERGY; SAPT HF TOTAL ENERGY; SAPT IND ENERGY; SAPT IND-DISP30 ENERGY; SAPT IND20,R ENERGY; SAPT IND20,U ENERGY; SAPT IND22 ENERGY; SAPT IND30,R ENERGY; SAPT MP2 CORRELATION ENERGY; SAPT SAME-SPIN DISP20 ENERGY; SAPT SAME-SPIN EXCH-DISP20 ENERGY; SAPT TOTAL ENERGY; SAPT0 DISP ENERGY; SAPT0 ELST ENERGY; SAPT0 EXCH ENERGY; SAPT0 IND ENERGY; SAPT0 TOTAL ENERGY; SAPT2 DISP ENERGY; SAPT2 ELST ENERGY; SAPT2 EXCH ENERGY; SAPT2 IND ENERGY; SAPT2 TOTAL ENERGY; SAPT2+ DISP ENERGY; SAPT2+ ELST ENERGY; SAPT2+ EXCH ENERGY; SAPT2+ IND ENERGY; SAPT2+ TOTAL ENERGY; SAPT2+(3) DISP ENERGY; SAPT2+(3) ELST ENERGY; SAPT2+(3) EXCH ENERGY; SAPT2+(3) IND ENERGY; SAPT2+(3) TOTAL ENERGY; SAPT2+(3)(CCD) DISP ENERGY; SAPT2+(3)(CCD) ELST ENERGY; SAPT2+(3)(CCD) EXCH ENERGY; SAPT2+(3)(CCD) IND ENERGY; SAPT2+(3)(CCD) TOTAL ENERGY; SAPT2+(3)(CCD)DMP2 DISP ENERGY; SAPT2+(3)(CCD)DMP2 ELST ENERGY; SAPT2+(3)(CCD)DMP2 EXCH ENERGY; SAPT2+(3)(CCD)DMP2 IND ENERGY; SAPT2+(3)(CCD)DMP2 TOTAL ENERGY; SAPT2+(3)DMP2 DISP ENERGY; SAPT2+(3)DMP2 ELST ENERGY; SAPT2+(3)DMP2 EXCH ENERGY; SAPT2+(3)DMP2 IND ENERGY; SAPT2+(3)DMP2 TOTAL ENERGY; SAPT2+(CCD) DISP ENERGY; SAPT2+(CCD) ELST ENERGY; SAPT2+(CCD) EXCH ENERGY; SAPT2+(CCD) IND ENERGY; SAPT2+(CCD) TOTAL ENERGY; SAPT2+(CCD)DMP2 DISP ENERGY; SAPT2+(CCD)DMP2 ELST ENERGY; SAPT2+(CCD)DMP2 EXCH ENERGY; SAPT2+(CCD)DMP2 IND ENERGY; SAPT2+(CCD)DMP2 TOTAL ENERGY; SAPT2+3 DISP ENERGY; SAPT2+3 ELST ENERGY; SAPT2+3 EXCH ENERGY; SAPT2+3 IND ENERGY; SAPT2+3 TOTAL ENERGY; SAPT2+3(CCD) DISP ENERGY; SAPT2+3(CCD) ELST ENERGY; SAPT2+3(CCD) EXCH ENERGY; SAPT2+3(CCD) IND ENERGY; SAPT2+3(CCD) TOTAL ENERGY; SAPT2+3(CCD)DMP2 DISP ENERGY; SAPT2+3(CCD)DMP2 ELST ENERGY; SAPT2+3(CCD)DMP2 EXCH ENERGY; SAPT2+3(CCD)DMP2 IND ENERGY; SAPT2+3(CCD)DMP2 TOTA",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/autodir_psivariables/module__sapt.html:1745,ENERGY,ENERGY,1745,psi4manual/1.6.x/autodir_psivariables/module__sapt.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/autodir_psivariables/module__sapt.html,5,['ENERGY'],['ENERGY']
Energy Efficiency,"T EXCH12(S^2) ENERGY¶; An exchange-classified SAPT term energy [Eh] implemented for SAPT2. SAPT IND22 ENERGY¶. SAPT EXCH-IND22 ENERGY¶; An induction-classified SAPT term energy [Eh] implemented for SAPT2. SAPT DISP21 ENERGY¶; A dispersion-classified SAPT term energy [Eh] implemented for SAPT2+. SAPT DISP22(SDQ) ENERGY¶. SAPT DISP22(T) ENERGY¶. SAPT EST.DISP22(T) ENERGY¶; Dispersion-classified MBPT-based SAPT term energy [Eh] implemented for SAPT2+. SAPT DISP2(CCD) ENERGY¶. SAPT DISP22(S)(CCD) ENERGY¶. SAPT DISP22(T)(CCD) ENERGY¶. SAPT EST.DISP22(T)(CCD) ENERGY¶; Dispersion-classified coupled-cluster-based SAPT term energy [Eh] implemented for SAPT2+. SAPT ELST13,R ENERGY¶; An electrostatics-classified SAPT term energy [Eh] implemented for SAPT2+(3). SAPT IND30,R ENERGY¶. SAPT IND-DISP30 ENERGY¶. SAPT EXCH-IND30,R ENERGY¶; A induction-classified SAPT term energy [Eh] implemented for SAPT2+3. SAPT DISP30 ENERGY¶. SAPT EXCH-DISP30 ENERGY¶. SAPT EXCH-IND-DISP30 ENERGY¶; A dispersion-classified SAPT term energy [Eh] implemented for SAPT2+3. SAPT ALPHA¶; SAPT exchange-scaling alpha. SAPT CT ENERGY¶; SAPT charge-transfer energy. SAPT HF TOTAL ENERGY¶; An induction-classified correction from HF implemented for SAPT0.; Value varies by SAPT level. SAPT MP2 CORRELATION ENERGY¶; An induction-classified correction from MP2 implemented for SAPT2.; Value varies by SAPT level. SAPT0 DISP ENERGY¶. SAPT0 ELST ENERGY¶. SAPT0 EXCH ENERGY¶. SAPT0 IND ENERGY¶. SSAPT0 DISP ENERGY¶. SSAPT0 ELST ENERGY¶. SSAPT0 EXCH ENERGY¶. SSAPT0 IND ENERGY¶. SAPT2 DISP ENERGY¶. SAPT2 ELST ENERGY¶. SAPT2 EXCH ENERGY¶. SAPT2 IND ENERGY¶. SAPT2+ DISP ENERGY¶. SAPT2+ ELST ENERGY¶. SAPT2+ EXCH ENERGY¶. SAPT2+ IND ENERGY¶. SAPT2+(3) DISP ENERGY¶. SAPT2+(3) ELST ENERGY¶. SAPT2+(3) EXCH ENERGY¶. SAPT2+(3) IND ENERGY¶. SAPT2+3 DISP ENERGY¶. SAPT2+3 ELST ENERGY¶. SAPT2+3 EXCH ENERGY¶. SAPT2+3 IND ENERGY¶; Respectively, the dispersion, electrostatics, exchange, and induction; components of the total electronic inter",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/glossary_psivariables-1.html:38740,energy,energy,38740,psi4manual/1.4.0/glossary_psivariables-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/glossary_psivariables-1.html,5,['energy'],['energy']
Energy Efficiency,"T FUNCTIONAL TOTAL ENERGY¶; The total electronic energy [H] for the underlying functional of the; requested DFT method, without any dispersion correction; the first four; terms in Eq. (3) or (1). Quantity; in Eqs. (3) and (1).; Unless the method includes a dispersion correction, this quantity is; equal to SCF TOTAL ENERGY. DFT TOTAL ENERGY¶; The total electronic energy [H] for the requested DFT method,; in Eq. (1). (1); Unless the method is a DFT double-hybrid, this quantity is equal to; SCF TOTAL ENERGY. If the method is neither a; double-hybrid, nor dispersion corrected, this quantity is equal to; DFT FUNCTIONAL TOTAL ENERGY. DFT XC ENERGY¶; The functional energy contribution [H] to the total SCF energy (DFT only).; Quantity in Eqs. (3) and (1). DISPERSION CORRECTION ENERGY¶; The dispersion correction [H] appended to an underlying functional; when a DFT-D method is requested. Quantity ; in Eqs. (3) and (1). DOUBLE-HYBRID CORRECTION ENERGY¶; The scaled MP2 correlation energy correction [H] appended to an; underlying functional when a DH-DFT method is requested.; Quantity in Eq. (1). FCI TOTAL ENERGY¶. FCI CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the full configuration interaction level of theory. HF TOTAL ENERGY¶; The total electronic energy [H] for the Hartree–Fock method, without; any dispersion correction; the first three (or four, since; ) terms in Eq. (3). Quantity ; in Eq. (3). LCC2 (+LMP2) TOTAL ENERGY¶; The total electronic energy [H] for the local CC2 level of theory. LCCSD (+LMP2) TOTAL ENERGY¶; The total electronic energy [H] for the local CCSD level of theory. MP2 TOTAL ENERGY¶. MP2 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the MP2 level of theory. MP2.5 TOTAL ENERGY¶. MP2.5 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the MP2.5 level of theory. MP3 TOTAL ENERGY¶. MP3 CORRELATION ENERGY¶; The total ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/glossary_psivariables-1.html:11126,energy,energy,11126,psi4manual/4.0b3/glossary_psivariables-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/glossary_psivariables-1.html,2,['energy'],['energy']
Energy Efficiency,"T FUNCTIONAL TOTAL ENERGY¶; The total electronic energy [H] for the underlying functional of the; requested DFT method, without any dispersion correction; the first four; terms in Eq. (4) or (1). Quantity; in Eqs. (4) and (1).; Unless the method includes a dispersion correction, this quantity is; equal to SCF TOTAL ENERGY. DFT TOTAL ENERGY¶; The total electronic energy [H] for the requested DFT method,; in Eq. (1). (1); Unless the method is a DFT double-hybrid, this quantity is equal to; SCF TOTAL ENERGY. If the method is neither a; double-hybrid, nor dispersion corrected, this quantity is equal to; DFT FUNCTIONAL TOTAL ENERGY. DFT XC ENERGY¶; The functional energy contribution [H] to the total SCF energy (DFT only).; Quantity in Eqs. (4) and (1). DISPERSION CORRECTION ENERGY¶; The dispersion correction [H] appended to an underlying functional; when a DFT-D method is requested. Quantity ; in Eqs. (4) and (1). DOUBLE-HYBRID CORRECTION ENERGY¶; The scaled MP2 correlation energy correction [H] appended to an; underlying functional when a DH-DFT method is requested.; Quantity in Eq. (1). FCI TOTAL ENERGY¶. FCI CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the full configuration interaction level of theory. HF TOTAL ENERGY¶; The total electronic energy [H] for the Hartree–Fock method, without; any dispersion correction; the first three (or four, since; ) terms in Eq. (4). Quantity ; in Eq. (4). LCC2 (+LMP2) TOTAL ENERGY¶; The total electronic energy [H] for the local CC2 level of theory. LCCSD (+LMP2) TOTAL ENERGY¶; The total electronic energy [H] for the local CCSD level of theory. MP2 TOTAL ENERGY¶. MP2 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the MP2 level of theory. MP2.5 TOTAL ENERGY¶. MP2.5 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the MP2.5 level of theory. MP3 TOTAL ENERGY¶. MP3 CORRELATION ENERGY¶; The total ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/glossary_psivariables-1.html:11320,energy,energy,11320,psi4manual/1.0.0/glossary_psivariables-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/glossary_psivariables-1.html,6,['energy'],['energy']
Energy Efficiency,"T functional labeled if canonical. CCname ROOT m (h) -> ROOT n (i) ROTATORY STRENGTH (LEN)¶. TD-fctl ROOT 0 (h) -> ROOT n (i) ROTATORY STRENGTH (LEN)¶; The length-gauge oscillator strength of the transition from root m to root n,; which are in irreps h and i, respectively..; DFT functional labeled if canonical. CCname ROOT m -> ROOT n ROTATORY STRENGTH (LEN) - h TRANSITION¶. TD-fctl ROOT 0 -> ROOT n ROTATORY STRENGTH (LEN) - h TRANSITION¶; The length-gauge oscillator strength of the transition from root m to root n,; and the transition is of irrep h.; DFT functional labeled if canonical. CC TOTAL ENERGY¶. CC CORRELATION ENERGY¶. CC T1 DIAGNOSTIC¶. CC D1 DIAGNOSTIC¶. CC NEW D1 DIAGNOSTIC¶. CC D2 DIAGNOSTIC¶; Diagnostic of multireference character. CC2 TOTAL ENERGY¶. CC2 CORRELATION ENERGY¶. CC3 TOTAL ENERGY¶. CC3 CORRELATION ENERGY¶. CC4 TOTAL ENERGY¶. CC4 CORRELATION ENERGY¶. CCnn TOTAL ENERGY¶. CCnn CORRELATION ENERGY¶; The total electronic energy [Eh] and correlation energy component [Eh]; for the requested approximate coupled-cluster (CC2, CC3, up to CCnn); level of theory. CC DIPOLE¶; Dipole array [e a0] for the requested coupled cluster level of theory and root, (3,). CC2 DIPOLE POLARIZABILITY @ xNM¶. CCSD DIPOLE POLARIZABILITY @ xNM¶; The dipole polarizability in atomic units [(e^2 a0^2)/E_h] calculated at; the CC level for a given (x) wavelength, (x) rounded to nearest integer. CC2 DIPOLE POLARIZABILITY TENSOR @ xNM¶. CCSD DIPOLE POLARIZABILITY TENSOR @ xNM¶; The dipole polarizability tensor in atomic units [(e^2 a0^2)/E_h] calculated at; the CC level for a given (x) wavelength, (x) rounded to nearest integer. CC2 QUADRUPOLE POLARIZABILITY @ xNM¶. CCSD QUADRUPOLE POLARIZABILITY @ xNM¶; The quadrupole polarizability in atomic units [(e^2 a0^3)/E_h] calculated at; the CC level for a given (x) wavelength, (x) rounded to nearest integer. CC2 QUADRUPOLE POLARIZABILITY TENSOR @ xNM¶. CCSD QUADRUPOLE POLARIZABILITY TENSOR @ xNM¶; The quadrupole polarizability in atom",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/glossary_psivariables.html:14557,energy,energy,14557,psi4manual/1.6.x/glossary_psivariables.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/glossary_psivariables.html,2,['energy'],['energy']
Energy Efficiency,"T — Chooses appropriate DCFT method. Type: string; Possible Values: DC-06, DC-12, ODC-06, ODC-12, ODC-13, CEPA0; Default: ODC-12. DCFT_GUESS (DCFT); DCFT (Expert) — Whether to read the orbitals from a previous computation, or to compute an MP2 guess. Type: string; Possible Values: CC, BCC, MP2, DCFT; Default: MP2. DCFT_TYPE (DCFT); DCFT — What algorithm to use for the DCFT computation. Type: string; Possible Values: CONV, DF; Default: CONV. DEBUG (CCDENSITY); CCDENSITY — Reproducing energies from densities ?. Type: integer; Default: 0. DEBUG (CPHF); CPHF — The amount of debug information printed to the output file. Type: integer; Default: 0. DEBUG (GLOBALS); GLOBALS (Expert) — The amount of information to print to the output file. Type: integer; Default: 0. DELETE_TEI (CCTRANSORT); CCTRANSORT — Delete the SO two-electron integrals after the transformation?. Type: boolean; Default: true. DENOMINATOR_ALGORITHM (SAPT); SAPT — Denominator algorithm for PT methods. Laplace transformations are slightly more efficient. Type: string; Possible Values: LAPLACE, CHOLESKY; Default: LAPLACE. DENOMINATOR_DELTA (SAPT); SAPT — Maximum error allowed (Max error norm in Delta tensor) in the approximate energy denominators employed for most of the \(E_{disp}^{(20)}\) and \(E_{exch-disp}^{(20)}\) evaluation. Type: double; Default: 1.0e-6. DERTYPE (EFP); EFP (Expert) — Do EFP gradient?. Type: string; Possible Values: NONE, FIRST; Default: NONE. DERTYPE (GLOBALS); GLOBALS (Expert) — Derivative level. Type: string; Possible Values: NONE, FIRST, SECOND, RESPONSE; Default: NONE. DETCI_FREEZE_CORE (DETCI); DETCI — Do freeze core orbitals?. Type: boolean; Default: true. DF_BASIS_CC (FNOCC); FNOCC — Auxilliary basis for df-ccsd(t). Type: string; Possible Values: basis string; Default: No Default. DF_BASIS_CC (GLOBALS); GLOBALS — The density fitting basis to use in coupled cluster computations. Type: string; Possible Values: basis string; Default: No Default. DF_BASIS_DCFT (DCFT); DCFT — Auxiliar",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/autodoc_glossary_options_c-1.html:94436,efficient,efficient,94436,psi4manual/1.3.2/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/autodoc_glossary_options_c-1.html,2,['efficient'],['efficient']
Energy Efficiency,"T""),; ""RIFIT"", core.get_global_option(""BASIS""),; ref_wfn.basisset().has_puream()); ref_wfn.set_basisset(""DF_BASIS_SAPT"", sapt_basis). minao = core.BasisSet.build(ref_wfn.molecule(), ""BASIS"", core.get_global_option(""MINAO_BASIS"")); ref_wfn.set_basisset(""MINAO"", minao). # Turn of dispersion for -d; if ""-d"" in name.lower():; core.set_local_option(""FISAPT"", ""FISAPT_DO_FSAPT_DISP"", False). fisapt_wfn = core.FISAPT(ref_wfn); from .sapt import fisapt_proc; fisapt_wfn.compute_energy(external_potentials=kwargs.get(""external_potentials"", None)). # Compute -D dispersion; if ""-d"" in name.lower():; proc_util.sapt_empirical_dispersion(name, ref_wfn). optstash.restore(); return ref_wfn. def run_mrcc(name, **kwargs):; """"""Function that prepares environment and input files; for a calculation calling Kallay's MRCC code. """""". # Check to see if we really need to run the SCF code.; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs); vscf = ref_wfn.variable('SCF TOTAL ENERGY'). # The parse_arbitrary_order method provides us the following information; # We require that level be provided. level is a dictionary; # of settings to be passed to core.mrcc; if not('level' in kwargs):; raise ValidationError('level parameter was not provided.'). level = kwargs['level']. # Fullname is the string we need to search for in iface; fullname = level['fullname']. # User can provide 'keep' to the method.; # When provided, do not delete the MRCC scratch directory.; keep = False; if 'keep' in kwargs:; keep = kwargs['keep']. # Save current directory location; current_directory = os.getcwd(). # Find environment by merging PSIPATH and PATH environment variables; lenv = {; 'PATH': ':'.join([os.path.abspath(x) for x in os.environ.get('PSIPATH', '').split(':') if x != '']) + \; ':' + os.environ.get('PATH'),; 'LD_LIBRARY_PATH': os.environ.get('LD_LIBRARY_PATH'); }; # Filter out None values as subprocess will fault on them; lenv = {k: v for k, v in lenv.items() if v is not",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/_modules/psi4/driver/procrouting/proc.html:150642,ENERGY,ENERGY,150642,psi4manual/1.5.0/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/_modules/psi4/driver/procrouting/proc.html,1,['ENERGY'],['ENERGY']
Energy Efficiency,"T""),; ""RIFIT"", core.get_global_option(""BASIS""),; ref_wfn.basisset().has_puream()); ref_wfn.set_basisset(""DF_BASIS_SAPT"", sapt_basis). minao = core.BasisSet.build(ref_wfn.molecule(), ""BASIS"", core.get_global_option(""MINAO_BASIS"")); ref_wfn.set_basisset(""MINAO"", minao). # Turn of dispersion for -d; if ""-d"" in name.lower():; core.set_local_option(""FISAPT"", ""FISAPT_DO_FSAPT_DISP"", False). fisapt_wfn = core.FISAPT(ref_wfn); from .sapt import fisapt_proc; fisapt_wfn.compute_energy(external_potentials=kwargs.get(""external_potentials"", None)). # Compute -D dispersion; if ""-d"" in name.lower():; proc_util.sapt_empirical_dispersion(name, ref_wfn). optstash.restore(); return ref_wfn. def run_mrcc(name, **kwargs):; """"""Function that prepares environment and input files; for a calculation calling Kallay's MRCC code. """""". # Check to see if we really need to run the SCF code.; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs); vscf = ref_wfn.variable('SCF TOTAL ENERGY'). # The parse_arbitrary_order method provides us the following information; # We require that level be provided. level is a dictionary; # of settings to be passed to core.mrcc; if not('level' in kwargs):; raise ValidationError('level parameter was not provided.'). level = kwargs['level']. # Fullname is the string we need to search for in iface; fullname = level['fullname']. # User can provide 'keep' to the method.; # When provided, do not delete the MRCC scratch directory.; keep = False; if 'keep' in kwargs:; keep = kwargs['keep']. # Save current directory location; current_directory = os.getcwd(). # Find environment by merging PSIPATH and PATH environment variables; lenv = {; 'PATH': ':'.join([os.path.abspath(x) for x in os.environ.get('PSIPATH', '').split(':') if x != '']) +; ':' + os.environ.get('PATH'),; 'LD_LIBRARY_PATH': os.environ.get('LD_LIBRARY_PATH'); }; # Filter out None values as subprocess will fault on them; lenv = {k: v for k, v in lenv.items() if v is not N",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:156444,ENERGY,ENERGY,156444,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,1,['ENERGY'],['ENERGY']
Energy Efficiency,"T)) ECC should be preferred due to the better performance of xecc (available currently for CCSD, CCSD+T, CCSD(T), and closed-shell CCSDT-n, CC3, and CCSDT). MRCC and External are intended for CC programs outside the CFOUR suite, e.g., the general CC module mrcc written by M. Kallay (Budapest, Hungary). Default: VCC Note: Using the option ECC is not recommended for ROHF gradients. That is, if you are doing a geometry optimization with ROHF as your reference wave function then it is safe to use the option VCC. Psi4 Interface: Keyword set according to best practice for the computational method CFOUR_CALC_LEVEL reference CFOUR_REFERENCE (NYI) and derivative level CFOUR_DERIV_LEVEL according to Table Best Practices when method specified by argument to computation command (e.g., when energy('c4-ccsd') requested but not when energy('cfour') requested). Value can always be set explicitly. Type: string; Possible Values: VCC, ECC, NCC, MRCC, EXTERNAL; Default: VCC. CFOUR_CHARGE¶. Specifies the molecular charge. Psi4 Interface: Keyword set from active molecule. Type: integer; Default: 0. CFOUR_CIS_CONV¶. Specifies the convergence threshold as \(10^{-N}\) for CIS calculations. Type: integer; Default: 5. CFOUR_CONTINUUM¶. Signifies that one or more “continuum” orbitals should be added to the calculation. VIRTUAL and DVIRTUAL specify one or two orbital which should be initially unoccupied (in the SCF calculation), while OCCUPIED and DOCCUPIED specify one or two orbitals which should be initially occupied. Type: string; Possible Values: NONE, VIRTUAL, DVIRTUAL, OCCUPIED, DOCCUPIED; Default: NONE. CFOUR_CONTRACTION¶. Specifies the contraction scheme used by the integral and integral derivative program. SEGMENTED (=0) uses a segmented contraction scheme; GENERAL (=1) uses a general contraction scheme, and UNCONTRACTED (=2) uses the corresponding uncontracted sets. Note that even for truly segmented basis sets, the integral programs run significantly faster in the GENERAL mode. Type:",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/autodir_options_c/module__cfour-1.html:10386,charge,charge,10386,psi4manual/1.3.2/autodir_options_c/module__cfour-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/autodir_options_c/module__cfour-1.html,22,['charge'],['charge']
Energy Efficiency,"T)) ECC should be preferred due to the better performance of xecc (available currently for CCSD, CCSD+T, CCSD(T), and closed-shell CCSDT-n, CC3, and CCSDT). MRCC and External are intended for CC programs outside the CFOUR suite, e.g., the general CC module mrcc written by M. Kallay (Budapest, Hungary). Default: VCC Note: Using the option ECC is not recommended for ROHF gradients. That is, if you are doing a geometry optimization with ROHF as your reference wave function then it is safe to use the option VCC. Psi4 Interface: Keyword set according to best practice for the computational method CFOUR_CALC_LEVEL, reference CFOUR_REFERENCE (NYI) and derivative level CFOUR_DERIV_LEVEL according to Table Best Practices when method specified by argument to computation command (e.g., when energy('c4-ccsd') requested but not when energy('cfour') requested). Value can always be set explicitly. Type: string; Possible Values: VCC, ECC, NCC, MRCC, EXTERNAL; Default: VCC. CFOUR_CHARGE (CFOUR)¶CFOUR — Specifies the molecular charge. Psi4 Interface: Keyword set from active molecule. Type: integer; Default: 0. CFOUR_CIS_CONV (CFOUR)¶CFOUR — Specifies the convergence threshold as \(10^{-N}\) for CIS calculations. Type: integer; Default: 5. CFOUR_CONTINUUM (CFOUR)¶CFOUR — Signifies that one or more “continuum” orbitals should be added to the calculation. VIRTUAL and DVIRTUAL specify one or two orbital which should be initially unoccupied (in the SCF calculation), while OCCUPIED and DOCCUPIED specify one or two orbitals which should be initially occupied. Type: string; Possible Values: NONE, VIRTUAL, DVIRTUAL, OCCUPIED, DOCCUPIED; Default: NONE. CFOUR_CONTRACTION (CFOUR)¶CFOUR — Specifies the contraction scheme used by the integral and integral derivative program. SEGMENTED (=0) uses a segmented contraction scheme; GENERAL (=1) uses a general contraction scheme, and UNCONTRACTED (=2) uses the corresponding uncontracted sets. Note that even for truly segmented basis sets, the integral prog",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/autodoc_glossary_options_c-1.html:28360,charge,charge,28360,psi4manual/1.4.0/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodoc_glossary_options_c-1.html,9,['charge'],['charge']
Energy Efficiency,"T). (TRANSQT2). invalidate() CartesianEntry method. CoordValue method. ZMatrixEntry method. ip_fitting() in module frac. IP_POLES (OCC). IRC; . geometry optimization. IRC_DIRECTION (OPTKING). IRC_STEP_SIZE (OPTKING). IRC_STOP (OPTKING). irrep_labels() LibmintsMolecule method. is_axis() LibmintsMolecule method. is_computed() CoordEntry method. is_equivalent_to() CoordEntry method. is_ghosted() CoordEntry method. is_linear_planar() LibmintsMolecule method. is_plane() LibmintsMolecule method. is_required() Keyword method. Section method. is_set() Keyword method. Section method. is_type() Keyword method. is_variable() LibmintsMolecule method. ISTOP (DETCI). IVO (TRANSQT). J. J_FILE (TRANSQT). JOBTYPE (CCLAMBDA). (CPHF). JSCH module, [1]. K. KEEP_INTCOS (OPTKING). KEEP_J (TRANSQT). KEEP_OEIFILE (CCSORT). KEEP_PRESORT (TRANSQT). KEEP_TEIFILE (CCSORT). Keyword class in pcmgetkw. keywords; . C-side, setting. anharmonicity(), setting. cbs(), setting. cp(), setting. database(), setting. energy(), setting. molecule, setting. optimize(), setting. property(), setting. kwargs_lower() in module p4util.procutil. L. label() CoordEntry method. LibmintsMolecule method. LAG_IN_FILE (TRANSQT). LAGRAN_DOUBLE (TRANSQT). LAGRAN_HALVE (TRANSQT). LAMBDA_MAXITER (DCFT). LCC2(+LMP2)TOTALENERGY. LCCSD(+LMP2)TOTALENERGY. LEVEL_SHIFT (MCSCF). (OCC). LibmintsMolecule class in qcdb.libmintsmolecule. like_world_axis() LibmintsMolecule static method. LINEAR (CCRESPONSE). LINEQ_SOLVER (OCC). LINESEARCH_STATIC_MAX (OPTKING). LINESEARCH_STATIC_MIN (OPTKING). LINESEARCH_STATIC_N (OPTKING). load_basfam_dunning() in module p4util.basislistdunning. load_basfam_other() in module p4util.basislistother. load_basis_families() in module p4util.basislist. LOCAL (CCENERGY). (CCEOM). (CCLAMBDA). (CCRESPONSE). (CCSORT). LOCAL_AMPS_PRINT_CUTOFF (CCENERGY). LOCAL_CORE_CUTOFF (CCSORT). LOCAL_CPHF_CUTOFF (CCENERGY). (CCLAMBDA). (CCRESPONSE). (CCSORT). LOCAL_CUTOFF (CCENERGY). (CCEOM). (CCLAMBDA). (CCRESPONSE). (CCSORT). ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/genindex.html:27158,energy,energy,27158,psi4manual/4.0b5/genindex.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/genindex.html,1,['energy'],['energy']
Energy Efficiency,"T)¶DCT — Convergence criterion for energy. See Table Post-SCF Convergence for default convergence criteria for different calculation types. Type: conv double; Default: 1e-10. E_CONVERGENCE (DETCI)¶DETCI — Convergence criterion for energy. See Table Post-SCF Convergence for default convergence criteria for different calculation types. Type: conv double; Default: 1e-6. E_CONVERGENCE (DFOCC)¶DFOCC — Convergence criterion for energy. See Table Post-SCF Convergence for default convergence criteria for different calculation types. Type: conv double; Default: 1e-6. E_CONVERGENCE (DLPNO)¶DLPNO — Energy convergence criteria for local MP2 iterations. Type: conv double; Default: 1e-6. E_CONVERGENCE (FNOCC)¶FNOCC — Convergence criterion for CC energy. See Table Post-SCF Convergence for default convergence criteria for different calculation types. Note that convergence is met only when E_CONVERGENCE and R_CONVERGENCE are satisfied. Type: conv double; Default: 1.0e-6. E_CONVERGENCE (MCSCF)¶MCSCF — Convergence criterion for energy. Type: conv double; Default: 1e-6. E_CONVERGENCE (MRCC)¶MRCC — Convergence criterion for energy. See Table Post-SCF Convergence for default convergence criteria for different calculation types. This becomes tol (option #16) in fort.56. Type: conv double; Default: 1e-6. E_CONVERGENCE (OCC)¶OCC — Convergence criterion for energy. See Table Post-SCF Convergence for default convergence criteria for different calculation types. Type: conv double; Default: 1e-6. E_CONVERGENCE (PSIMRCC)¶PSIMRCC — Convergence criterion for energy. See Table Post-SCF Convergence for default convergence criteria for different calculation types. Type: conv double; Default: 1e-6. E_CONVERGENCE (SAPT)¶SAPT — Convergence criterion for energy (change) in the SAPT \(E_{ind,resp}^{(20)}\) term during solution of the CPHF equations. Type: conv double; Default: 1e-10. E_CONVERGENCE (SCF)¶SCF — Convergence criterion for SCF energy. See Table SCF Convergence & Algorithm for default convergen",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/autodoc_glossary_options_c-1.html:118151,energy,energy,118151,psi4manual/1.5.0/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/autodoc_glossary_options_c-1.html,6,['energy'],['energy']
Energy Efficiency,T)¶DCT — Convergence criterion for energy. See Table Post-SCF Convergence for default convergence criteria for different calculation types. Type: conv double; Default: 1e-10. E_CONVERGENCE (DETCI)¶DETCI — Convergence criterion for energy. See Table Post-SCF Convergence for default convergence criteria for different calculation types. Type: conv double; Default: 1e-6. E_CONVERGENCE (DFOCC)¶DFOCC — Convergence criterion for energy. See Table Post-SCF Convergence for default convergence criteria for different calculation types. Type: conv double; Default: 1e-6. E_CONVERGENCE (DLPNO)¶DLPNO — Energy convergence criteria for local MP2 iterations. Type: conv double; Default: 1e-6. E_CONVERGENCE (FNOCC)¶FNOCC — Convergence criterion for CC energy. See Table Post-SCF Convergence for default convergence criteria for different calculation types. Note that convergence is met only when E_CONVERGENCE and R_CONVERGENCE are satisfied. Type: conv double; Default: 1.0e-6. E_CONVERGENCE (MCSCF)¶MCSCF — Convergence criterion for energy. Type: conv double; Default: 1e-6. E_CONVERGENCE (MRCC)¶MRCC — Convergence criterion for energy. See Table Post-SCF Convergence for default convergence criteria for different calculation types. This becomes tol (option #16) in fort.56. Type: conv double; Default: 1e-6. E_CONVERGENCE (OCC)¶OCC — Convergence criterion for energy. See Table Post-SCF Convergence for default convergence criteria for different calculation types. Type: conv double; Default: 1e-6. E_CONVERGENCE (PSIMRCC)¶PSIMRCC — Convergence criterion for energy. See Table Post-SCF Convergence for default convergence criteria for different calculation types. Type: conv double; Default: 1e-6. E_CONVERGENCE (SCF)¶SCF — Convergence criterion for SCF energy. See Table SCF Convergence & Algorithm for default convergence criteria for different calculation types. Type: conv double; Default: 1e-6. EA_POLES (OCC)¶OCC — Do compute OCC poles for electron affinities? Only valid for OMP2. Type: boolean; Def,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/autodoc_glossary_options_c.html:124412,energy,energy,124412,psi4manual/master/autodoc_glossary_options_c.html,https://psicode.org,https://psicode.org/psi4manual/master/autodoc_glossary_options_c.html,1,['energy'],['energy']
Energy Efficiency,"T, the AO-basis integrals will be computed on the fly as necessary. NB: The DIRECT option is not fully implemented and should only be used by experts. Default is NONE. Note: The developers recommend use of this keyword only as a last resort because it significantly slows the calculation. The current algorithms for handling the MO-basis four-virtual-index integrals have been significantly improved and are preferable to the AO-based approach. Type: string; Possible Values: NONE, DISK, DIRECT; Default: NONE. AO_BASIS (CCLAMBDA); CCLAMBDA — The algorithm to use for the terms. Type: string; Possible Values: NONE, DISK, DIRECT; Default: NONE. AO_BASIS (CCSORT); CCSORT — The algorithm to use for the terms. Type: string; Possible Values: NONE, DISK, DIRECT; Default: NONE. AO_BASIS (DCFT); DCFT — Controls whether to avoid the AO->MO transformation of the two-electron integrals for the four-virtual case (<VV||VV>) by computing the corresponding terms in the AO basis. AO_BASIS = DISK algorithm reduces the memory requirements. It is, however, less efficient due to the extra I/O, so the default algorithm is preferred. Type: string; Possible Values: NONE, DISK; Default: NONE. AO_BASIS (TRANSQT); TRANSQT — The algorithm to use for the terms. Type: string; Possible Values: NONE, DISK, DIRECT; Default: NONE. AO_BASIS (TRANSQT2); TRANSQT2 — The algorithm to use for the terms. Type: string; Possible Values: NONE, DISK, DIRECT; Default: NONE. AVG_STATES (DETCI); DETCI — Array giving the root numbers of the states to average in a state-averaged procedure such as SA-CASSCF. Root numbering starts from 1. Type: array; Default: No Default. AVG_WEIGHTS (DETCI); DETCI — Array giving the weights for each state in a state-averaged procedure. Type: array; Default: No Default. B_RAS3_MAX (DETCI); DETCI — maximum number of beta electrons in RAS III. Type: integer; Default: -1. BASIS (DFMP2); DFMP2 — Primary basis set. Type: string; Possible Values: basis string; Default: NONE. BASIS (MINTS); MINTS ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/autodoc_glossary_options_c-1.html:3509,reduce,reduces,3509,psi4manual/4.0b2/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/autodoc_glossary_options_c-1.html,4,['reduce'],['reduces']
Energy Efficiency,"T. DMRG_SCF_DIIS_THR¶. When the update norm is smaller than this value DIIS starts. Type: double; Default: 1e-2. DMRG_SCF_GRAD_THR¶. The density RMS convergence to stop an instruction during successive DMRG instructions. Type: double; Default: 1.e-6. DMRG_SCF_MAX_ITER¶. Maximum number of DMRG iterations. Type: integer; Default: 100. DMRG_SCF_STATE_AVG¶. Whether or not to use state-averaging for roots >=2 with DMRG-SCF. Type: boolean; Default: true. DMRG_SWEEP_DVDSON_RTOL¶. The residual tolerances for the Davidson diagonalization during DMRG instructions. Type: array; Default: No Default. DMRG_SWEEP_ENERGY_CONV¶. The energy convergence to stop an instruction during successive DMRG instructions. Type: array; Default: No Default. DMRG_SWEEP_MAX_SWEEPS¶. The maximum number of sweeps to stop an instruction during successive DMRG instructions. Type: array; Default: No Default. DMRG_SWEEP_NOISE_PREFAC¶. The noise prefactors for successive DMRG instructions. Type: array; Default: No Default. DMRG_SWEEP_STATES¶. The number of reduced renormalized basis states to be retained during successive DMRG instructions. Type: array; Default: No Default. DMRG_UNITARY_WRITE¶. Whether or not to store the unitary on disk (convenient for restarting). Type: boolean; Default: true. table of contents. DMRG; General; DMRG_CASPT2_CALC; DMRG_CASPT2_IMAG; DMRG_CASPT2_IPEA; DMRG_CASPT2_ORBS; DMRG_DIIS; DMRG_DIIS_WRITE; DMRG_EXCITATION; DMRG_IRREP; DMRG_LOCAL_INIT; DMRG_MOLDEN_WRITE; DMRG_MPS_WRITE; DMRG_MULTIPLICITY; DMRG_OPDM_AO_PRINT; DMRG_PRINT_CORR; DMRG_SCF_ACTIVE_SPACE; DMRG_SCF_DIIS_THR; DMRG_SCF_GRAD_THR; DMRG_SCF_MAX_ITER; DMRG_SCF_STATE_AVG; DMRG_SWEEP_DVDSON_RTOL; DMRG_SWEEP_ENERGY_CONV; DMRG_SWEEP_MAX_SWEEPS; DMRG_SWEEP_NOISE_PREFAC; DMRG_SWEEP_STATES; DMRG_UNITARY_WRITE. Navigation. Index. modules    .    .    .    .  · ; 1.1;  · . PSI4. Appendices; Keywords by Module. © Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/autodir_options_c/module__dmrg-1.html:3409,reduce,reduced,3409,psi4manual/1.1.0/autodir_options_c/module__dmrg-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/autodir_options_c/module__dmrg-1.html,2,['reduce'],['reduced']
Energy Efficiency,"T. SAPT EXCH10 ENERGY¶; An exchange-classified SAPT term energy [E_h] implemented for SAPT0. SAPT EXCH10(S^2) ENERGY¶; An exchange-classified SAPT term energy [E_h] implemented for SAPT0. SAPT IND20,R ENERGY¶. SAPT EXCH-IND20,R ENERGY¶. SAPT IND20,U ENERGY¶. SAPT EXCH-IND20,U ENERGY¶; An induction-classified SAPT term energy [E_h] implemented for SAPT0. SAPT DISP20 ENERGY¶. SAPT EXCH-DISP20 ENERGY¶; A dispersion-classified SAPT term energy [E_h] implemented for SAPT0. SAPT EXCH-DISP20(S^INF) ENERGY¶; A dispersion-classified SAPT term energy [E_h] implemented for SAPT0. See Higher-Order Exchange Terms without Single-Exchange Approximation. SAPT SAME-SPIN DISP20 ENERGY¶. SAPT SAME-SPIN EXCH-DISP20 ENERGY¶; The portion of SAPT DISP20 ENERGY or; SAPT EXCH-DISP20 ENERGY resulting from; from same-spin or triplet doubles correlations. SAPT HF(2) ENERGY ABC(HF)¶; The total Hartree–Fock energy [E_h] of the supersystem implemented for F/I-SAPT. SAPT HF(2) ENERGY AC(0)¶; The Hartree–Fock energy [E_h] of subsystems A and C implemented for F/I-SAPT. SAPT HF(2) ENERGY BC(0)¶; The Hartree–Fock energy [E_h] of subsystems B and C implemented for F/I-SAPT. SAPT HF(2) ENERGY A(0)¶; The Hartree–Fock energy [E_h] of subsystem A implemented for F/I-SAPT. SAPT HF(2) ENERGY B(0)¶; The Hartree–Fock energy [E_h] of subsystem B implemented for F/I-SAPT. SAPT HF(2) ENERGY AC(HF)¶; The Hartree–Fock localized energy [E_h] of subsystems A and C implemented for F/I-SAPT. SAPT HF(2) ENERGY BC(HF)¶; The Hartree–Fock localized energy [E_h] of subsystems B and C implemented for F/I-SAPT. SAPT HF(2) ENERGY AB(HF)¶; The Hartree–Fock localized energy [E_h] of subsystems A and B implemented for F/I-SAPT. SAPT HF(2) ENERGY A(HF)¶; The Hartree–Fock localized energy [E_h] of subsystem A implemented for F/I-SAPT. SAPT HF(2) ENERGY B(HF)¶; The Hartree–Fock localized energy [E_h] of subsystem B implemented for F/I-SAPT. SAPT HF(2) ENERGY C¶; The Hartree–Fock energy [E_h] of subsystem C implemented for F/I-SAPT.",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/glossary_psivariables.html:46856,energy,energy,46856,psi4manual/1.7.x/glossary_psivariables.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/glossary_psivariables.html,4,['energy'],['energy']
Energy Efficiency,"T0 aug-cc-pVTZ computation of the charge transfer energy of the water dimer. dfccsdt1; DF-CCSD(T) cc-pVDZ energy for the H2O molecule. pywrap-checkrun-uhf; This checks that all energy methods can run with a minimal input and set symmetry. scf2; RI-SCF cc-pVTZ energy of water, with Z-matrix input and cc-pVTZ-RI auxilliary basis. mcscf3; RHF 6-31G** energy of water, using the MCSCF module and Z-matrix input. pywrap-checkrun-rohf; This checks that all energy methods can run with a minimal input and set symmetry. cc41; RHF-CC2-LR/cc-pVDZ optical rotation of H2O2. gauge = both, omega = (589 355 nm). pywrap-db1; Database calculation, so no molecule section in input file. Portions of the full databases, restricted by subset keyword, are computed by sapt0 and dfmp2 methods. cisd-sp-2; 6-31G** H2O Test CISD Energy Point. olccd3; OLCCD cc-pVDZ energy with ROHF initial guess for the NO radical. cc19; CCSD/cc-pVDZ dipole polarizability at two frequencies. cc4; RHF-CCSD(T) cc-pVQZ frozen-core energy of the BH molecule, with Cartesian input. After the computation, the checkpoint file is renamed, using the PSIO handler. casscf-sp; CASSCF/6-31G** energy point. dfccsd-grad2; DF-CCSD cc-pVDZ gradient for the NH molecule. opt15; 6-31G(d) optimization of SF4 starting from linear bond angle that is not linear in the optimized structure but is in a symmetry plane of the molecule. sapt-dft1; SAPT(DFT) aug-cc-pVDZ interaction energy between Ne and Ar atoms. cbs-xtpl-wrapper; RHF aug-cc-pVQZ energy for the BH molecule, with Cartesian input. Various gradients for a strained helium dimer and water molecule. pywrap-align; apply linear fragmentation algorithm to a water cluster. cubeprop-frontier; ROHF frontier orbitals of CH2(s) and CH2(t). nbody-multi-level-2; many-body different levels of theory on each body of helium tetramer. cc47; EOM-CCSD/cc-pVDZ on H2O2 with two excited states in each irrep. fci-h2o-2; 6-31G H2O Test FCI Energy Point. lccd-grad1; LCCD cc-pVDZ gradient for the H2O molecu",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/autodoc_testsuite_corepsi4.html:6068,energy,energy,6068,psi4manual/1.7.x/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/autodoc_testsuite_corepsi4.html,2,['energy'],['energy']
Energy Efficiency,"T0/aug-cc-pVDZ computation for a positively charged system, illustrating the cation-pi interaction. The SIAO1 link partitioning algorithm is used. The system is taken from http://dx.doi.org/10.1016/j.comptc.2014.02.008. cc13; UHF-CCSD/cc-pVDZ \(^{3}B_1\) CH2 geometry optimization via analytic gradients. dft-freq; Frequencies for H2O B3LYP/6-31G* at optimized geometry. props2; DF-SCF cc-pVDZ of benzene-hydronium ion, scanning the dissociation coordinate with Python’s built-in loop mechanism. The geometry is specified by a Z-matrix with dummy atoms, fixed parameters, updated parameters, and separate charge/multiplicity specifiers for each monomer. One-electron properties computed for dimer and one monomer. dlpnomp2-2; comparison of DF-MP2 and DLPNO-MP2 with a CBS extrapolation. cepa-module; routing check on lccd, lccsd, cepa(0). dfccsd-t-grad1; DF-CCSD(T) cc-pVDZ gradients for the H2O molecule. olccd2; OLCCD cc-pVDZ energy with B3LYP initial guess for the NO radical. ao-casscf-sp; CASSCF/6-31G** energy point. cisd-h2o+-0; 6-31G** H2O+ Test CISD Energy Point. dfmp2-freq1; DF-MP2 frequency by difference of energies for H2O. scf4; RHF cc-pVDZ energy for water, automatically scanning the symmetric stretch and bending coordinates using Python’s built-in loop mechanisms. The geometry is specified using a Z-matrix with variables that are updated during the potential energy surface scan, and then the same procedure is performed using polar coordinates, converted to Cartesian coordinates. cc33; CC3(UHF)/cc-pVDZ H2O \(R_e\) geom from Olsen et al., JCP 104, 8007 (1996). dct-grad2; RHF-ODC-12 analytic gradient computations for H2O use AO_BASIS=DISK and AO_BASIS=NONE, respectively. RHF-ODC-06 analytic gradient computations for H2O use AO_BASIS=DISK and AO_BASIS=NONE, respectively. lccd-grad1; LCCD cc-pVDZ gradient for the H2O molecule. sapt-exch-ind-inf; SAPT(DFT) aug-cc-pVDZ interaction energy between Ne and Ar atoms. dct2; DC-06 calculation for the He dimer. This performs a two-s",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/autodoc_testsuite_corepsi4.html:38691,energy,energy,38691,psi4manual/1.9.x/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/autodoc_testsuite_corepsi4.html,2,['energy'],['energy']
Energy Efficiency,"T2+(3) aug-cc-pVDZ computation of the formamide dimer interaction energy, using the aug-cc-pVDZ-JKFIT DF basis for SCF and aug-cc-pVDZ-RI for SAPT. This example uses frozen core as well as MP2 natural orbital approximations. cc47; EOM-CCSD/cc-pVDZ on H2O2 with two excited states in each irrep. dft-freq; Frequencies for H2O B3LYP/6-31G* at optimized geometry. mp2-grad1; MP2 cc-pVDZ gradient for the H2O molecule. scf3; are specified explicitly. ocepa-grad2; OCEPA cc-pVDZ gradient for the NO radical. dftd3-energy; Exercises the various DFT-D corrections, both through python directly and through c++. pywrap-db1; Database calculation, so no molecule section in input file. Portions of the full databases, restricted by subset keyword, are computed by sapt0 and dfmp2 methods. cc52; CCSD Response for H2O2. pywrap-db2; Database calculation, run in sow/reap mode. cc50; EOM-CC3(ROHF) on CH radical with user-specified basis and properties for particular root. omp2-2; OMP2 cc-pVDZ energy with ROHF initial guess orbitals for the NO radical. cc12; Single point energies of multiple excited states with EOM-CCSD. cisd-sp; 6-31G** H2O Test CISD Energy Point. mints6; Patch of a glycine with a methyl group, to make alanine, then DF-SCF energy calculation with the cc-pVDZ basis set. mrcc4; CCSDT cc-pVDZ optimization and frequencies for the H2O molecule using MRCC. omp2-5; SOS-OMP2 cc-pVDZ geometry optimization for the H2O molecule. props1; RHF STO-3G dipole moment computation, performed by applying a finite electric field and numerical differentiation. cc42; RHF-CC2-LR/STO-3G optical rotation of (S)-methyloxirane. gauge = length, omega = (589 355 nm). omp2_5-1; OMP2 cc-pVDZ energy for the H2O molecule. fci-dipole; 6-31G H2O Test FCI Energy Point. fnocc3; Test FNO-QCISD(T) computation. tu4-h2o-freq; Frequencies for H2O HF/cc-pVDZ at optimized geometry. dcft3; DC-06 calculation for the He dimer. This performs a simultaneous update of the orbitals and cumulant, using DIIS extrapolation. Four-",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/autodoc_testsuite-1.html:12601,energy,energy,12601,psi4manual/4.0b4/autodoc_testsuite-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/autodoc_testsuite-1.html,4,['energy'],['energy']
Energy Efficiency,"T2+(3) aug-cc-pVDZ computation of the formamide dimer interaction energy, using the aug-cc-pVDZ-JKFIT DF basis for SCF and aug-cc-pVDZ-RI for SAPT. This example uses frozen core as well as MP2 natural orbital approximations. cc47; EOM-CCSD/cc-pVDZ on H2O2 with two excited states in each irrep. dft-freq; Frequencies for H2O B3LYP/6-31G* at optimized geometry. mp2-grad1; MP2 cc-pVDZ gradient for the H2O molecule. scf3; are specified explicitly. ocepa-grad2; OCEPA cc-pVDZ gradient for the NO radical. dftd3-energy; Exercises the various DFT-D corrections, both through python directly and through c++. pywrap-db1; Database calculation, so no molecule section in input file. Portions of the full databases, restricted by subset keyword, are computed by sapt0 and dfmp2 methods. cc52; CCSD Response for H2O2. pywrap-db2; Database calculation, run in sow/reap mode. cc50; EOM-CC3(ROHF) on CH radical with user-specified basis and properties for particular root. omp2-2; OMP2 cc-pVDZ energy with ROHF initial guess orbitals for the NO radical. cc12; Single point energies of multiple excited states with EOM-CCSD. cisd-sp; 6-31G** H2O Test CISD Energy Point. mints6; Patch of a glycine with a methyl group, to make alanine, then DF-SCF energy calculation with the cc-pVDZ basis set. mrcc4; CCSDT cc-pVDZ optimization and frequencies for the H2O molecule using MRCC. omp2-5; SOS-OMP2 cc-pVDZ geometry optimization for the H2O molecule. props1; RHF STO-3G dipole moment computation, performed by applying a finite electric field and numerical differentiation. cc42; RHF-CC2-LR/STO-3G optical rotation of (S)-methyloxirane. gauge = length, omega = (589 355 nm). omp2_5-1; OMP2 cc-pVDZ energy for the H2O molecule. fci-dipole; 6-31G H2O Test FCI Energy Point. pywrap-freq-e-sowreap; Finite difference of energies frequency, run in sow/reap mode. fnocc3; Test FNO-QCISD(T) computation. tu4-h2o-freq; Frequencies for H2O HF/cc-pVDZ at optimized geometry. dcft3; DC-06 calculation for the He dimer. This perfor",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/autodoc_testsuite-1.html:12599,energy,energy,12599,psi4manual/4.0b5/autodoc_testsuite-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodoc_testsuite-1.html,4,['energy'],['energy']
Energy Efficiency,"TAL ENERGY'.format(ssuper.name()), returnvalue). scf_wfn.set_variable('CURRENT ENERGY', returnvalue); scf_wfn.set_energy(returnvalue); core.print_out('\n\n'); core.print_out(' %s Energy Summary\n' % (name.upper())); core.print_out(' ' + '-' * (15 + len(name)) + '\n'); core.print_out(' DFT Reference Energy = %22.16lf\n' % (returnvalue - vdh)); core.print_out(' Scaled MP2 Correlation = %22.16lf\n' % (vdh)); core.print_out(' @Final double-hybrid DFT total energy = %22.16lf\n\n' % (returnvalue)); core.tstop(). if ssuper.name() == 'MP2D':; for pv, pvv in dfmp2_wfn.variables().items():; scf_wfn.set_variable(pv, pvv). # Conversely, remove DFT qcvars from MP2D; for var in scf_wfn.variables():; if 'DFT ' in var or 'DOUBLE-HYBRID ' in var:; scf_wfn.del_variable(var). # DFT groups dispersion with SCF. Reshuffle so dispersion with MP2 for MP2D.; for pv in ['SCF TOTAL ENERGY', 'SCF ITERATION ENERGY', 'MP2 TOTAL ENERGY']:; scf_wfn.set_variable(pv, scf_wfn.variable(pv) - scf_wfn.variable('DISPERSION CORRECTION ENERGY')). scf_wfn.set_variable('MP2D CORRELATION ENERGY', scf_wfn.variable('MP2 CORRELATION ENERGY') + scf_wfn.variable('DISPERSION CORRECTION ENERGY')); scf_wfn.set_variable('MP2D TOTAL ENERGY', scf_wfn.variable('MP2D CORRELATION ENERGY') + scf_wfn.variable('HF TOTAL ENERGY')); scf_wfn.set_variable('CURRENT ENERGY', scf_wfn.variable('MP2D TOTAL ENERGY')); scf_wfn.set_variable('CURRENT CORRELATION ENERGY', scf_wfn.variable('MP2D CORRELATION ENERGY')); scf_wfn.set_variable('CURRENT REFERENCE ENERGY', scf_wfn.variable('SCF TOTAL ENERGY')). # Shove variables into global space; for k, v in scf_wfn.variables().items():; core.set_variable(k, v). optstash_scf.restore(); optstash_mp2.restore(); return scf_wfn. def run_scf_gradient(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a SCF gradient calculation. """""". dft_func = False; if ""dft_functional"" in kwargs:; dft_func = True. optstash = proc_util.scf_set_reference_local(name, is_dft=dft_func). # Bypass the ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html:78344,ENERGY,ENERGY,78344,psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,7,['ENERGY'],['ENERGY']
Energy Efficiency,"TAL ENERGY¶. MP2.5 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the MP2.5 level of theory. MP3 TOTAL ENERGY¶. MP3 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the MP3 level of theory. MP4(SDQ) TOTAL ENERGY¶. MP4(SDQ) CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the MP4 singles, doubles, quadruples level of theory. Quantity; MP4(SDQ) CORRELATION ENERGY is; first right-hand term in Eq. (2). MP4 TOTAL ENERGY¶. MP4 CORRELATION ENERGY¶. MP4(SDTQ) TOTAL ENERGY¶. MP4(SDTQ) CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the full MP4 level of theory. Quantity MP4 CORRELATION; ENERGY / MP4(SDTQ) CORRELATION ENERGY is left-hand term in Eq. (2). (2)¶\[E_{\text{MP4}} = E_{\text{MP4(SDQ)}} + E_{\text{MP4(T)}}\]. MPn TOTAL ENERGY¶. MPn CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the labeled Møller–Plesset perturbation theory level.; n is MP perturbation order. NUCLEAR REPULSION ENERGY¶; The nuclear repulsion energy contribution [H] to the total SCF energy.; Quantity \(E_{NN}\) in Eq. (4). (3)¶\[E_{NN} = \sum_{i, j<i}^{N_{atom}}\frac{Z_i Z_j}{|\mathbf{R}_i - \mathbf{R}_j|}\]. NBODY (i, j, ..., k)@(a, b, ..., c) TOTAL ENERGY¶; The total energy [Eh] of a component of the requested N-Body energy.; The first parenthetical list over i, j, …, k enumerates; molecular fragments included in the computation in 1-indexed,; input-file order, while the second enumerates list over a, b,; …, c enumerates which fragments contribute basis functions to the; computation. For example, (1, 2)@(1, 2, 3, 4) indicates that the; fragments 1 and 2 are explicitly included in the energy computation,; with basis functions from each of fragments 1, 2, 3, & 4 included in; the basis set. Therefore, the basis functions from fragments 3 and 4; are included as ghost functi",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/glossary_psivariables-1.html:15857,energy,energy,15857,psi4manual/1.2.1/glossary_psivariables-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/glossary_psivariables-1.html,8,['energy'],['energy']
Energy Efficiency,"TAL ENERGY¶. MP2.5 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the MP2.5 level of theory. MP3 TOTAL ENERGY¶. MP3 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the MP3 level of theory. MP4(SDQ) TOTAL ENERGY¶. MP4(SDQ) CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the MP4 singles, doubles, quadruples level of theory. Quantity; MP4(SDQ) CORRELATION ENERGY is; first right-hand term in Eq. (2). MP4 TOTAL ENERGY¶. MP4 CORRELATION ENERGY¶. MP4(SDTQ) TOTAL ENERGY¶. MP4(SDTQ) CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the full MP4 level of theory. Quantity MP4 CORRELATION; ENERGY / MP4(SDTQ) CORRELATION ENERGY is left-hand term in Eq. (2). (2)¶\[E_{\text{MP4}} = E_{\text{MP4(SDQ)}} + E_{\text{MP4(T)}}\]. MPn TOTAL ENERGY¶. MPn CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the labeled Møller–Plesset perturbation theory level.; n is MP perturbation order. NUCLEAR REPULSION ENERGY¶; The nuclear repulsion energy contribution [H] to the total SCF energy.; Quantity \(E_{NN}\) in Eq. (4). (3)¶\[E_{NN} = \sum_{i, j<i}^{N_{atom}}\frac{Z_i Z_j}{|\mathbf{R}_i - \mathbf{R}_j|}\]. OCEPA(0) TOTAL ENERGY¶. OCEPA(0) CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the orbital-optimized CEPA(0) level of theory. OMP2 TOTAL ENERGY¶. OMP2 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the orbital-optimized MP2 level of theory. OMP3 TOTAL ENERGY¶. OMP3 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the orbital-optimized MP3 level of theory. ONE-ELECTRON ENERGY¶; The one-electron energy contribution [H] to the total SCF energy.; Quantity \(E_{1e^-}\) in Eq. (4). QCISD TOTAL ENERGY¶. QCISD CORRELATION ENERGY¶; The",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/glossary_psivariables-1.html:14271,energy,energy,14271,psi4manual/1.1.0/glossary_psivariables-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/glossary_psivariables-1.html,4,['energy'],['energy']
Energy Efficiency,TAL ENERGY¶. OLCCD CORRELATION ENERGY¶; The total electronic energy [E_h] and correlation energy component [E_h]; for the orbital-optimized linearized coupled cluster doubles level of theory. OLCCD REFERENCE CORRECTION ENERGY¶; The difference [E_h] between the single-determinant energy of the final and; initial orbitals for the orbital-optimized linearized coupled cluster; doubles level of theory. OMP2 TOTAL ENERGY¶. OMP2 CORRELATION ENERGY¶; The total electronic energy [E_h] and correlation energy component [E_h]; for the orbital-optimized MP2 level of theory. OMP2 REFERENCE CORRECTION ENERGY¶; The difference [E_h] between the single-determinant energy of the final and; initial orbitals for the orbital-optimized MP2 level of theory. OMP2.5 TOTAL ENERGY¶. OMP2.5 CORRELATION ENERGY¶; The total electronic energy [E_h] and correlation energy component [E_h]; for the orbital-optimized MP2.5 level of theory. OMP2.5 REFERENCE CORRECTION ENERGY¶; The difference [E_h] between the single-determinant energy of the final and; initial orbitals for the orbital-optimized MP2.5 level of theory. OMP3 TOTAL ENERGY¶. OMP3 CORRELATION ENERGY¶; The total electronic energy [E_h] and correlation energy component [E_h]; for the orbital-optimized MP3 level of theory. OMP3 REFERENCE CORRECTION ENERGY¶; The difference [E_h] between the single-determinant energy of the final and; initial orbitals for the orbital-optimized MP3 level of theory. OREMP2 TOTAL ENERGY¶. OREMP2 CORRELATION ENERGY¶; The total electronic energy [E_h] and correlation energy component [E_h]; for the orbital-optimized retaining-the-excitation-degree Møller–Plesset; hybrid perturbation theory level. OREMP2 REFERENCE CORRECTION ENERGY¶; The difference [E_h] between the single-determinant energy of the final and; initial orbitals for the orbital-optimized retaining-the-excitation-degree; Møller–Plesset hybrid perturbation theory level. ONE-ELECTRON ENERGY¶; The one-electron energy contribution [E_h] to the total SCF energy.,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/glossary_psivariables.html:43067,energy,energy,43067,psi4manual/1.7.x/glossary_psivariables.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/glossary_psivariables.html,4,['energy'],['energy']
Energy Efficiency,"TAL HESSIAN""] = H0; properties[""return_hessian""] = H0. # if isinstance(lowername, str) and lowername in procedures['energy']:; # # this correctly filters out cbs fn and ""hf/cc-pvtz""; # # it probably incorrectly filters out mp5, but reconsider in DDD. findif_model = AtomicResult(; **{; 'driver': self.driver,; 'model': {; ""basis"": self.basis,; 'method': self.method,; },; 'molecule': self.molecule.to_schema(dtype=2),; 'properties': properties,; 'provenance': p4util.provenance_stamp(__name__, module=self.findifrec[""reference""][""module""]),; 'extras': {; 'qcvars': qcvars,; 'findif_record': copy.deepcopy(self.findifrec),; },; 'return_result': self.findifrec['reference'][self.driver.name],; 'success': True,; }). logger.debug('\nFINDIF QCSchema:\n' + pp.pformat(findif_model.dict())). return findif_model. [docs]; def get_psi_results(; self,; client: Optional[""qcportal.FractalClient""] = None,; *,; return_wfn: bool = False) -> EnergyGradientHessianWfnReturn:; """"""Called by driver to assemble results into FiniteDifference-flavored QCSchema,; then reshape and return them in the customary Psi4 driver interface: ``(e/g/h, wfn)``. Parameters; ----------; return_wfn; Whether to additionally return the dummy :py:class:`~psi4.core.Wavefunction`; calculation result as the second element of a tuple. Contents are:. - undisplaced molecule; - compute basis if simple, else dummy basis def2-svp; - e/g/h member data; - QCVariables; - module. Returns; -------; ret; Gradient or Hessian according to self.driver.; wfn; Wavefunction described above when *return_wfn* specified. """"""; findif_model = self.get_results(client=client). ret_ptype = core.Matrix.from_array(findif_model.return_result); wfn = _findif_schema_to_wfn(findif_model). gradient_write(wfn); hessian_write(wfn). if return_wfn:; return (ret_ptype, wfn); else:; return ret_ptype. def _findif_schema_to_wfn(findif_model: AtomicResult) -> core.Wavefunction:; """"""Helper function to produce Wavefunction and Psi4 files from a FiniteDifference-flavo",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html:52346,Energy,EnergyGradientHessianWfnReturn,52346,psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html,3,['Energy'],['EnergyGradientHessianWfnReturn']
Energy Efficiency,TCI — Do write the natural orbitals?. Type: boolean; Default: false. NAT_ORBS_WRITE_ROOT (DETCI); DETCI — Sets the root number for which CI natural orbitals are written to PSIF_CHKPT. The default value is 1 (lowest root). Type: integer; Default: 1. NEGLECT_DISTANT_PAIR (CCENERGY); CCENERGY — Do neglect distant pairs?. Type: boolean; Default: true. NEW_TRIPLES (CCENERGY); CCENERGY — Do use new triples?. Type: boolean; Default: true. NEW_TRIPLES (CCEOM); CCEOM — Do use new triples?. Type: boolean; Default: true. NEWTON_CONVERGENCE (ADC); ADC — The convergence criterion for pole searching step. Type: conv double; Default: 1e-7. NO_DFILE (DETCI); DETCI (Expert) — Do use the last vector space in the BVEC file to write scratch DVEC rather than using a separate DVEC file? (Only possible if NUM_ROOTS = 1.). Type: boolean; Default: false. NO_RESPONSE (SAPT); SAPT — Don’t solve the CPHF equations? Evaluate and instead of their response-including coupterparts. Only turn on this option if the induction energy is not going to be used. Type: boolean; Default: false. NO_SINGLES (PSIMRCC); PSIMRCC — Do disregard updating single excitation amplitudes?. Type: boolean; Default: false. NORM_TOLERANCE (ADC); ADC — The cutoff norm of residual vector in SEM step. Type: conv double; Default: 1e-6. NUM_AMPS_PRINT (ADC); ADC — Number of components of transition amplitudes printed. Type: integer; Default: 5. NUM_AMPS_PRINT (CCENERGY); CCENERGY — Number of important and amplitudes to print. Type: integer; Default: 10. NUM_AMPS_PRINT (CCEOM); CCEOM — Number of important CC amplitudes to print. Type: integer; Default: 5. NUM_AMPS_PRINT (CCLAMBDA); CCLAMBDA — Number of important CC amplitudes per excitation level to print. CC analog to NUM_DETS_PRINT. Type: integer; Default: 10. NUM_AMPS_PRINT (CCRESPONSE); CCRESPONSE — Number of important CC amplitudes per excitation level to print. CC analog to NUM_DETS_PRINT. Type: integer; Default: 5. NUM_AMPS_PRINT (DETCI); DETCI — Number of important CC amp,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/autodoc_glossary_options_c-1.html:86020,energy,energy,86020,psi4manual/4.0b5/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodoc_glossary_options_c-1.html,2,['energy'],['energy']
Energy Efficiency,TCI); DETCI — Do write the natural orbitals?. Type: boolean; Default: false. NAT_ORBS_WRITE_ROOT (DETCI); DETCI — Sets the root number for which CI natural orbitals are written to PSIF_CHKPT. The default value is 1 (lowest root). Type: integer; Default: 1. NEGLECT_DISTANT_PAIR (LMP2); LMP2 — Do neglect distant pairs?. Type: boolean; Default: true. NEW_TRIPLES (CCENERGY); CCENERGY — Do use new triples?. Type: boolean; Default: true. NEW_TRIPLES (CCEOM); CCEOM — Do use new triples?. Type: boolean; Default: true. NEWTON_CONVERGENCE (ADC); ADC — The convergence criterion for pole searching step. Type: conv double; Default: 1e-7. NO_DFILE (DETCI); DETCI (Expert) — Do use the last vector space in the BVEC file to write scratch DVEC rather than using a separate DVEC file? (Only possible if NUM_ROOTS = 1.). Type: boolean; Default: false. NO_RESPONSE (SAPT); SAPT — Don’t solve the CPHF equations? Evaluate and instead of their response-including coupterparts. Only turn on this option if the induction energy is not going to be used. Type: boolean; Default: false. NO_SINGLES (PSIMRCC); PSIMRCC — Do disregard updating single excitation amplitudes?. Type: boolean; Default: false. NORM_TOLERANCE (ADC); ADC — The cutoff norm of residual vector in SEM step. Type: conv double; Default: 1e-6. NUM_AMPS_PRINT (ADC); ADC — Number of components of transition amplitudes printed. Type: integer; Default: 5. NUM_AMPS_PRINT (CCENERGY); CCENERGY — Number of important and amplitudes to print. Type: integer; Default: 10. NUM_AMPS_PRINT (CCEOM); CCEOM — Number of important CC amplitudes to print. Type: integer; Default: 5. NUM_AMPS_PRINT (CCLAMBDA); CCLAMBDA — Number of important CC amplitudes per excitation level to print. CC analog to NUM_DETS_PRINT. Type: integer; Default: 10. NUM_AMPS_PRINT (CCRESPONSE); CCRESPONSE — Number of important CC amplitudes per excitation level to print. CC analog to NUM_DETS_PRINT. Type: integer; Default: 5. NUM_AMPS_PRINT (DETCI); DETCI — Number of important CC amp,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/autodoc_glossary_options_c-1.html:82691,energy,energy,82691,psi4manual/4.0b3/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodoc_glossary_options_c-1.html,4,['energy'],['energy']
Energy Efficiency,"TCI)¶DETCI (Expert) — The required phase (1 or -1) between the two determinants specified by FILTER_GUESS_DET1 and FILTER_GUESS_DET2. Type: integer; Default: 1. FILTER_ZERO_DET (DETCI)¶DETCI (Expert) — If present, the code will try to filter out a particular determinant by setting its CI coefficient to zero. FILTER_ZERO_DET = [alphastr, betastr] specifies the absolute alpha and beta string numbers of the target determinant. This could be useful for trying to exclude states that have a nonzero CI coefficient for the given determinant. However, this option was experimental and may not be effective. Type: array; Default: No Default. FINAL_GEOM_WRITE (OPTKING)¶OPTKING — Do save and print the geometry from the last projected step at the end of a geometry optimization? Otherwise (and by default), save and print the previous geometry at which was computed the gradient that satisfied the convergence criteria. Type: boolean; Default: false. FISAPT_CHARGE_COMPLETENESS (FISAPT)¶FISAPT — Amount of fragment charge completeness to distinguish link bonds. Type: double; Default: 0.8. FISAPT_DO_FSAPT (FISAPT)¶FISAPT — Do an F-SAPT analysis?. Type: boolean; Default: true. FISAPT_DO_FSAPT_DISP (FISAPT)¶FISAPT — Do F-SAPT Dispersion?. Type: boolean; Default: true. FISAPT_DO_PLOT (FISAPT)¶FISAPT — Plot a scalar-field analysis. Type: boolean; Default: false. FISAPT_FSAPT_EXCH_SCALE (FISAPT)¶FISAPT — Do F-SAPT exchange scaling? (ratio of S^infty to S^2). Type: boolean; Default: true. FISAPT_FSAPT_FILEPATH (FISAPT)¶FISAPT — Filepath to drop F-SAPT data within input file directory. Type: string; Default: fsapt/. FISAPT_FSAPT_IND_RESPONSE (FISAPT)¶FISAPT — Do F-SAPT coupled response? (not recommended). Type: boolean; Default: false. FISAPT_FSAPT_IND_SCALE (FISAPT)¶FISAPT — Do F-SAPT induction scaling? (ratio of HF induction to F-SAPT induction). Type: boolean; Default: true. FISAPT_FSSAPT_FILEPATH (FISAPT)¶FISAPT — Filepath to drop sSAPT0 exchange-scaling F-SAPT data within input file directo",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/autodoc_glossary_options_c-1.html:127638,charge,charge,127638,psi4manual/1.4.0/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodoc_glossary_options_c-1.html,5,['charge'],['charge']
Energy Efficiency,"TCSCF singlet orbitals. omp2p5-1; OMP2 cc-pVDZ energy for the H2O molecule. cepa0-grad1; CEPA0 cc-pVDZ gradient for the H2O molecule. dfomp2p5-1; DF-OMP2.5 cc-pVDZ energy for the H2O molecule. cisd-sp-2; 6-31G** H2O Test CISD Energy Point. rasci-h2o; RASCI/6-31G** H2O Energy Point. dfccd-grad1; DF-CCSD cc-pVDZ gradients for the H2O molecule. dfomp3-1; DF-OMP3 cc-pVDZ energy for the H2O molecule. dcft-grad2; RHF-ODC-12 analytic gradient computations for H2O use AO_BASIS=DISK and AO_BASIS=NONE, respectively. RHF-ODC-06 analytic gradient computations for H2O use AO_BASIS=DISK and AO_BASIS=NONE, respectively. cc32; CC3/cc-pVDZ H2O geom from Olsen et al., JCP 104, 8007 (1996). dfmp2-grad1; DF-MP2 cc-pVDZ gradients for the H2O molecule. cc8; UHF-CCSD(T) cc-pVDZ frozen-core energy for the state of the CN radical, with Z-matrix input. cc17; Single point energies of multiple excited states with EOM-CCSD. dfmp2-grad4; DF-MP2 cc-pVDZ gradient for the NO molecule. cc15; RHF-B-CCD(T)/6-31G** H2O single-point energy (fzc, MO-basis ). fci-dipole; 6-31G H2O Test FCI Energy Point. pywrap-basis; SAPT calculation on bimolecular complex where monomers are unspecified so driver auto-fragments it. Basis set and auxiliary basis sets are assigned by atom type. fd-freq-energy-large; SCF DZ finite difference frequencies by energies for C4NH4. matrix1; An example of using BLAS and LAPACK calls directly from the Psi input file, demonstrating matrix multiplication, eigendecomposition, Cholesky decomposition and LU decomposition. These operations are performed on vectors and matrices provided from the Psi library. cc25; Single point gradient of 1-2B2 state of H2O+ with EOM-CCSD. dfcasscf-fzc-sp; CASSCF/6-31G** energy point. fd-freq-energy; SCF STO-3G finite-difference frequencies from energies. cc29; CCSD/cc-pVDZ optical rotation calculation (both gauges) on Cartesian H2O2. dfmp2-grad3; DF-MP2 cc-pVDZ gradients for the H2O molecule. opt12; SCF cc-pVDZ geometry optimzation of ketene, starting from",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_testsuite_corepsi4-1.html:20598,energy,energy,20598,psi4manual/1.0.0/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_testsuite_corepsi4-1.html,4,['energy'],['energy']
Energy Efficiency,"TDA':; self.geometry_variables[vstr] = 360.0 * math.atan(math.sqrt(2)) / math.pi. # handle negative variable values (ignore leading '-' and return minus the value); if vstr[0] == '-':; self.all_variables.append(vstr[1:]); return VariableValue(vstr[1:], self.geometry_variables, True). # handle normal variable values; else:; self.all_variables.append(vstr); return VariableValue(vstr, self.geometry_variables). [docs] def add_atom(self, Z, x, y, z, label="""", mass=0.0, charge=0.0, lineno=-1):; """"""Add an atom to the molecule; *Z* atomic number; *x* cartesian coordinate; *y* cartesian coordinate; *z* cartesian coordinate; *symb* atomic symbol to use; *mass* mass to use if non standard; *charge* charge to use if non standard; *lineno* line number when taken from a string. """"""; self.lock_frame = False. if self.atom_at_position([x, y, z]) == -1:; # Dummies go to full_atoms, ghosts need to go to both.; self.full_atoms.append(CartesianEntry(self.nallatom(), Z, charge, mass, label, label, \; NumberValue(x), NumberValue(y), NumberValue(z))); if label.upper() != 'X':; self.atoms.append(self.full_atoms[-1]); else:; raise ValidationError(""Molecule::add_atom: Adding atom on top of an existing atom.""). [docs] def atom_entry(self, atom):; """"""Returns the CoordEntry for an atom.""""""; return self.atoms[atom]. [docs] def atom_at_position(self, b, tol=0.05):; """"""Tests to see of an atom is at the passed position *b* in Bohr with a tolerance *tol*. >>> print H2OH2O.atom_at_position([1.35*(1.0/psi_bohr2angstroms), 0.10*(1.0/psi_bohr2angstroms), 0.0*(1.0/psi_bohr2angstroms)]); 3. """"""; if len(b) != 3:; raise ValidationError('ERROR: atom_at_position() requires as argument a vector of length 3\n'). for at in range(self.natom()):; a = self.xyz(at); if distance(b, a) < tol:; return at; return -1. [docs] def is_variable(self, vstr):; """"""Checks to see if the variable str is in the list, returns; true if it is, and returns false if not. >>> H2OH2O.is_variable('R'); False. """"""; return True if vstr.upper()",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/_modules/qcdb/libmintsmolecule.html:30432,charge,charge,30432,psi4manual/4.0b3/_modules/qcdb/libmintsmolecule.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/_modules/qcdb/libmintsmolecule.html,6,['charge'],['charge']
Energy Efficiency,"TDA':; self.geometry_variables[vstr] = 360.0 * math.atan(math.sqrt(2)) / math.pi. # handle negative variable values (ignore leading '-' and return minus the value); if vstr[0] == '-':; self.all_variables.append(vstr[1:]); return VariableValue(vstr[1:], self.geometry_variables, True). # handle normal variable values; else:; self.all_variables.append(vstr); return VariableValue(vstr, self.geometry_variables). [docs] def add_atom(self, Z, x, y, z, label="""", mass=0.0, charge=0.0, lineno=-1):; """"""Add an atom to the molecule; *Z* atomic number; *x* cartesian coordinate; *y* cartesian coordinate; *z* cartesian coordinate; *symb* atomic symbol to use; *mass* mass to use if non standard; *charge* charge to use if non standard; *lineno* line number when taken from a string. """"""; self.lock_frame = False. if self.atom_at_position([x, y, z]) == -1:; # Dummies go to full_atoms, ghosts need to go to both.; self.full_atoms.append(CartesianEntry(self.nallatom(), Z, charge, mass, label, label, \; NumberValue(x), NumberValue(y), NumberValue(z))); if label.upper() != 'X':; self.atoms.append(self.full_atoms[-1]); else:; raise ValidationError(""Molecule::add_atom: Adding atom on top of an existing atom.""). [docs] def atom_entry(self, atom):; """"""Returns the CoordEntry for an atom.""""""; return self.atoms[atom]. [docs] def atom_at_position(self, b, tol=0.05):; """"""Tests to see of an atom is at the passed position *b* in Bohr with a tolerance *tol*. >>> print H2OH2O.atom_at_position([1.35*(1.0/psi_bohr2angstroms), 0.10*(1.0/psi_bohr2angstroms), 0.0*(1.0/psi_bohr2angstroms)]); 3. """"""; if len(b) != 3:; raise ValidationError('Molecule::atom_at_position: Argument vector not of length 3\n'). for at in range(self.natom()):; a = self.xyz(at); if distance(b, a) < tol:; return at; return -1. [docs] def is_variable(self, vstr):; """"""Checks to see if the variable str is in the list, returns; true if it is, and returns false if not. >>> H2OH2O.is_variable('R'); False. """"""; #if self.all_variables; #print 'vst",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html:34403,charge,charge,34403,psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html,1,['charge'],['charge']
Energy Efficiency,TE-SPIN CORRELATION ENERGY; ACPF SAME-SPIN CORRELATION ENERGY; ACPF TOTAL ENERGY; AQCC CORRELATION ENERGY; AQCC OPPOSITE-SPIN CORRELATION ENERGY; AQCC SAME-SPIN CORRELATION ENERGY; AQCC TOTAL ENERGY; CC ALPHA-ALPHA PAIR ENERGIES (array); CC ALPHA-BETA PAIR ENERGIES (array); CC D1 DIAGNOSTIC; CC SINGLET PAIR ENERGIES (array); CC T1 DIAGNOSTIC; CC TRIPLET PAIR ENERGIES (array); CCSD ALPHA-ALPHA PAIR ENERGIES (array); CCSD ALPHA-BETA PAIR ENERGIES (array); CCSD CORRELATION ENERGY; CCSD DOUBLES ENERGY; CCSD ITERATIONS; CCSD OPPOSITE-SPIN CORRELATION ENERGY; CCSD SAME-SPIN CORRELATION ENERGY; CCSD SINGLES ENERGY; CCSD SINGLET PAIR ENERGIES (array); CCSD TOTAL ENERGY; CCSD TRIPLET PAIR ENERGIES (array); CCSD(T) CORRELATION ENERGY; CCSD(T) TOTAL ENERGY; CEPA(0) CORRELATION ENERGY; CEPA(0) DOUBLES ENERGY; CEPA(0) OPPOSITE-SPIN CORRELATION ENERGY; CEPA(0) SAME-SPIN CORRELATION ENERGY; CEPA(0) SINGLES ENERGY; CEPA(0) TOTAL ENERGY; CEPA(1) CORRELATION ENERGY; CEPA(1) OPPOSITE-SPIN CORRELATION ENERGY; CEPA(1) SAME-SPIN CORRELATION ENERGY; CEPA(1) TOTAL ENERGY; CEPA(2) CORRELATION ENERGY; CEPA(2) OPPOSITE-SPIN CORRELATION ENERGY; CEPA(2) SAME-SPIN CORRELATION ENERGY; CEPA(2) TOTAL ENERGY; CEPA(3) CORRELATION ENERGY; CEPA(3) OPPOSITE-SPIN CORRELATION ENERGY; CEPA(3) SAME-SPIN CORRELATION ENERGY; CEPA(3) TOTAL ENERGY; CISD CORRELATION ENERGY; CISD OPPOSITE-SPIN CORRELATION ENERGY; CISD SAME-SPIN CORRELATION ENERGY; CISD TOTAL ENERGY; CURRENT CORRELATION ENERGY; CURRENT ENERGY; LCCD CORRELATION ENERGY; LCCD DOUBLES ENERGY; LCCD OPPOSITE-SPIN CORRELATION ENERGY; LCCD SAME-SPIN CORRELATION ENERGY; LCCD SINGLES ENERGY; LCCD TOTAL ENERGY; LCCSD CORRELATION ENERGY; LCCSD DOUBLES ENERGY; LCCSD OPPOSITE-SPIN CORRELATION ENERGY; LCCSD SAME-SPIN CORRELATION ENERGY; LCCSD SINGLES ENERGY; LCCSD TOTAL ENERGY; MP2 ALPHA-ALPHA PAIR ENERGIES (array); MP2 ALPHA-BETA PAIR ENERGIES (array); MP2 CORRELATION ENERGY; MP2 DOUBLES ENERGY; MP2 OPPOSITE-SPIN CORRELATION ENERGY; MP2 SAME-SPIN CORRELATION ENE,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/autodir_psivariables/module__fnocc.html:1186,ENERGY,ENERGY,1186,psi4manual/1.6.x/autodir_psivariables/module__fnocc.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/autodir_psivariables/module__fnocc.html,1,['ENERGY'],['ENERGY']
Energy Efficiency,"TELSTENERGY. SAPTENERGY. SAPTEXCHENERGY. SAPTINDENERGY. SAPTSAPT0ENERGY. SAPTSAPT2+(3)ENERGY. SAPTSAPT2+3ENERGY. SAPTSAPT2+ENERGY. SAPTSAPT2ENERGY. save() (Table method). SAVE_JK (SCF). SCALE (STABILITY). scale() (Table method). SCF. theory. scf_helper() (in module proc). SCF_MAXITER (DCFT). SCF_MEM_SAFETY_FACTOR (SCF). SCF_TYPE (CPHF). (JK), [1]. (SCF). scf_xtpl_helgaker_2() (in module wrappers). scf_xtpl_helgaker_3() (in module wrappers). SCFTOTALENERGY. SCHMIDT_ADD_RESIDUAL_TOLERANCE (CCEOM). SCHWARZ_CUTOFF (CPHF). (JK), [1]. scratch files. SCREEN_INTS (LMP2). SCS (LMP2). (MP2). SCS_CCSD (CCENERGY). SCS_MP2 (CCENERGY). SCS_N (LMP2). (MP2). SCSN_MP2 (CCENERGY). SEKINO (CCLAMBDA). (CCRESPONSE). SEM_MAX (PLUGIN_DFADC), [1]. SEM_MAXITER (ADC). SEMICANONICAL (CCENERGY). (CCEOM). (CCSORT). (CCTRIPLES). (PLUGIN_CCSORT), [1]. (TRANSQT2). set_memory() (in module util). set_num_threads() (in module util). setting; . keywords C-side. keywords cbs(). keywords cp(). keywords database(). keywords energy(). keywords molecule. keywords optimize(). keywords property(). SF_RESTRICT (DETCI). sherrillgroup_gold_standard() (in module aliases). SIGMA_OVERLAP (DETCI). single-point. SINGLES_PRINT (CCEOM). SMALL_CUTOFF (PSIMRCC). SO_S_FILE (TRANSQT). SO_T_FILE (TRANSQT). SO_TEI_FILE (TRANSQT). SO_V_FILE (TRANSQT). SOCC (GLOBALS). (MCSCF). SOLVER_CONVERGENCE (CPHF). (SOLVER), [1]. SOLVER_EXACT_DIAGONAL (CPHF). SOLVER_MAX_SUBSPACE (CPHF). (SOLVER), [1]. SOLVER_MAXITER (CPHF). (SOLVER), [1]. SOLVER_MIN_SUBSPACE (CPHF). (SOLVER), [1]. SOLVER_N_GUESS (CPHF). (SOLVER), [1]. SOLVER_N_ROOT (CPHF). (SOLVER), [1]. SOLVER_NORM (CPHF). (SOLVER), [1]. SOLVER_PRECONDITION (CPHF). (SOLVER), [1]. SOLVER_PRECONDITION_MAXITER (CPHF). SOLVER_PRECONDITION_STEPS (CPHF). SOLVER_QUANTITY (CPHF). SOLVER_TYPE (CPHF). SORTED_TEI_FILE (TRANSQT). SOS_SCALE (OMP2). SOS_SCALE2 (OMP2). SPINADAPT_ENERGIES (CCENERGY). split_menial() (in module wrappers). SS_E_CONVERGENCE (CCEOM). SS_R_CONVERGENCE (CCEOM). SS_SKIP_DIAG (C",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/genindex.html:26398,energy,energy,26398,psi4manual/4.0b2/genindex.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/genindex.html,1,['energy'],['energy']
Energy Efficiency,"TER (FNOCC); FNOCC — Maximum number of CC iterations. Type: integer; Default: 100. MAXITER (MCSCF); MCSCF — Maximum number of iterations. Type: integer; Default: 100. MAXITER (PSIMRCC); PSIMRCC — Maximum number of iterations to determine the amplitudes. Type: integer; Default: 100. MAXITER (SAPT); SAPT — Maxmum number of CPHF iterations. Type: integer; Default: 50. MAXITER (SCF); SCF — Maximum number of iterations. Cfour Interface: Keyword translates into CFOUR_SCF_MAXCYC. Type: integer; Default: 100. MCSCF_ALGORITHM (DETCI); DETCI (Expert) — Convergence algorithm to utilize. This is a flag for the future. Type: string; Possible Values: ONE_STEP, TWO_STEP; Default: TWO_STEP. MCSCF_DIIS_FREQ (DETCI); DETCI — How often to do a DIIS extrapolation. Type: integer; Default: 1. MCSCF_DIIS_MAX_VECS (DETCI); DETCI — Maximum number of DIIS vectors. Type: integer; Default: 8. MCSCF_DIIS_START (DETCI); DETCI — Iteration to turn on DIIS. Type: integer; Default: 3. MCSCF_E_CONVERGENCE (DETCI); DETCI — Convergence criterion for energy. See Table Post-SCF Convergence for default convergence criteria for different calculation types. Type: conv double; Default: 1e-7. MCSCF_MAX_ROT (DETCI); DETCI — Maximum value in the rotation matrix. If a value is greater than this number all values are scaled. Type: double; Default: 0.5. MCSCF_MAXITER (DETCI); DETCI — Maximum number MCSCF of iterations. Type: integer; Default: 30. MCSCF_R_CONVERGENCE (DETCI); DETCI — Convergence criterion for the RMS of the orbital gradient. Type: conv double; Default: 1e-4. MCSCF_SO (DETCI); DETCI (Expert) — Do second-order orbital-orbital MCSCF. Without one-step this typically slows the overall computation considerably. Type: boolean; Default: false. MCSCF_SO_START_E (DETCI); DETCI (Expert) — Start second-order orbital-orbital MCSCF based on energy convergence. Type: double; Default: 1e-3. MCSCF_SO_START_GRAD (DETCI); DETCI (Expert) — Start second-order orbital-orbital MCSCF based on RMS of orbital gradient. Type:",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_glossary_options_c-1.html:158589,energy,energy,158589,psi4manual/1.0.0/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_glossary_options_c-1.html,2,['energy'],['energy']
Energy Efficiency,"TERACTION ENERGY'] = nocp_body_dict[metadata['max_nbody']] - nocp_body_dict[1]. for nb in nbodies[1:]:; nbody_dict[f""NOCP-CORRECTED INTERACTION ENERGY THROUGH {nb}-BODY""] = nocp_body_dict[nb] - nocp_body_dict[1]; nbody_dict[f""NOCP-CORRECTED {nb}-BODY CONTRIBUTION TO ENERGY""] = nocp_body_dict[nb] - nocp_body_dict[nb-1]; for nb in nbodies:; nbody_dict[f""NOCP-CORRECTED TOTAL ENERGY THROUGH {nb}-BODY""] = nocp_body_dict[nb]. # Compute vmfc; if 'vmfc' in metadata['bsse_type']:; for nb in nbodies:; if ptype == ""energy"":; for k in range(1, nb + 1):; vmfc_body_dict[nb] += vmfc_by_level[k]. else:; if nb > 1:; vmfc_body_dict[nb] = vmfc_by_level[nb - 1]; vmfc_body_dict[nb] += vmfc_by_level[nb]. if ptype == ""energy"":; if not metadata[""quiet""]:; _print_nbody_energy(vmfc_body_dict, ""Valiron-Mayer Function Counterpoise (VMFC)"", metadata[""nfragments""], metadata['embedding_charges']). vmfc_interaction_energy = vmfc_body_dict[metadata['max_nbody']] - vmfc_body_dict[1]; nbody_dict['VMFC-CORRECTED TOTAL ENERGY'] = vmfc_body_dict[metadata['max_nbody']]; nbody_dict['VMFC-CORRECTED INTERACTION ENERGY'] = vmfc_interaction_energy. for nb in nbodies[1:]:; nbody_dict[f""VMFC-CORRECTED INTERACTION ENERGY THROUGH {nb}-BODY""] = vmfc_body_dict[nb] - vmfc_body_dict[1]; nbody_dict[f""VMFC-CORRECTED {nb}-BODY CONTRIBUTION TO ENERGY""] = vmfc_body_dict[nb] - vmfc_body_dict[nb-1]; for nb in nbodies:; nbody_dict[f""VMFC-CORRECTED TOTAL ENERGY THROUGH {nb}-BODY""] = vmfc_body_dict[nb]. # Collect specific and generalized returns; results = {; f""cp_{ptype}_body_dict"" : {f""{nb}cp"": j for nb, j in cp_body_dict.items()},; f""nocp_{ptype}_body_dict"": {f""{nb}nocp"": j for nb, j in nocp_body_dict.items()},; f""vmfc_{ptype}_body_dict"": {f""{nb}vmfc"": j for nb, j in vmfc_body_dict.items()},; }. if ptype == ""energy"":; results['nbody'] = nbody_dict. return_bsse_type = metadata[""bsse_type""][0]. if return_bsse_type == ""cp"":; results[f""{ptype}_body_dict""] = cp_body_dict; elif return_bsse_type == ""nocp"":; results[f""{ptype}_body_d",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver_nbody.html:29357,ENERGY,ENERGY,29357,psi4manual/1.6.x/_modules/psi4/driver/driver_nbody.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver_nbody.html,10,['ENERGY'],['ENERGY']
Energy Efficiency,"TERPOISE CORRECTED INTERACTION ENERGY"": (""CP-CORRECTED INTERACTION ENERGY"", 1.7),; ""NON-COUNTERPOISE CORRECTED TOTAL ENERGY"": (""NOCP-CORRECTED TOTAL ENERGY"", 1.7),; ""NON-COUNTERPOISE CORRECTED INTERACTION ENERGY"": (""NOCP-CORRECTED INTERACTION ENERGY"", 1.7),; ""VALIRON-MAYER FUNCTION COUTERPOISE TOTAL ENERGY"": (""VALIRON-MAYER FUNCTION COUNTERPOISE TOTAL ENERGY"", 1.7), # note misspelling; ""VALIRON-MAYER FUNCTION COUTERPOISE INTERACTION ENERGY"": (""VMFC-CORRECTED INTERACTION ENERGY"", 1.7), # note misspelling; }. _qcvar_cancellations = {; ""SCSN-MP2 SAME-SPIN CORRELATION ENERGY"": [""MP2 SAME-SPIN CORRELATION ENERGY""],; ""SCSN-MP2 OPPOSITE-SPIN CORRELATION ENERGY"": [""MP2 OPPOSITE-SPIN CORRELATION ENERGY""],; ""SCS-CCSD SAME-SPIN CORRELATION ENERGY"": [""CCSD SAME-SPIN CORRELATION ENERGY""],; ""SCS-CCSD OPPOSITE-SPIN CORRELATION ENERGY"": [""CCSD OPPOSITE-SPIN CORRELATION ENERGY""],; ""SCS-MP2 SAME-SPIN CORRELATION ENERGY"": [""MP2 SAME-SPIN CORRELATION ENERGY""],; ""SCS-MP2 OPPOSITE-SPIN CORRELATION ENERGY"": [""MP2 OPPOSITE-SPIN CORRELATION ENERGY""],; ""SCS(N)-OMP2 CORRELATION ENERGY"": [""OMP2 SAME-SPIN CORRELATION ENERGY"", ""OMP2 OPPOSITE-SPIN CORRELATION ENERGY""],; ""SCS(N)-OMP2 TOTAL ENERGY"": [""OMP2 SAME-SPIN CORRELATION ENERGY"", ""OMP2 OPPOSITE-SPIN CORRELATION ENERGY""],; ""SCSN-OMP2 CORRELATION ENERGY"": [""OMP2 SAME-SPIN CORRELATION ENERGY"", ""OMP2 OPPOSITE-SPIN CORRELATION ENERGY""],; ""SCSN-OMP2 TOTAL ENERGY"": [""OMP2 SAME-SPIN CORRELATION ENERGY"", ""OMP2 OPPOSITE-SPIN CORRELATION ENERGY""],; }. def _qcvar_warnings(key: str) -> str:; """"""Intercept QCVariable keys to issue warnings or upgrade hints. Otherwise,; pass through. """"""; if any([key.upper().endswith("" DIPOLE "" + cart) for cart in [""X"", ""Y"", ""Z""]]):; raise UpgradeHelper(key.upper(), key.upper()[:-2], 1.6, "" Note the Debye -> a.u. units change.""). if any([key.upper().endswith("" QUADRUPOLE "" + cart) for cart in [""XX"", ""YY"", ""ZZ"", ""XY"", ""XZ"", ""YZ""]]):; raise UpgradeHelper(key.upper(), key.upper()[:-3], 1.6, "" Note the Debye -> a.u. units change",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/python_helpers.html:25715,ENERGY,ENERGY,25715,psi4manual/1.7.x/_modules/psi4/driver/p4util/python_helpers.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/python_helpers.html,96,['ENERGY'],['ENERGY']
Energy Efficiency,"TERPOISE CORRECTED INTERACTION ENERGY"": (""CP-CORRECTED INTERACTION ENERGY"", 1.7),; ""NON-COUNTERPOISE CORRECTED TOTAL ENERGY"": (""NOCP-CORRECTED TOTAL ENERGY"", 1.7),; ""NON-COUNTERPOISE CORRECTED INTERACTION ENERGY"": (""NOCP-CORRECTED INTERACTION ENERGY"", 1.7),; ""VALIRON-MAYER FUNCTION COUTERPOISE TOTAL ENERGY"": (""VALIRON-MAYER FUNCTION COUNTERPOISE TOTAL ENERGY"", 1.7), # note misspelling; ""VALIRON-MAYER FUNCTION COUTERPOISE INTERACTION ENERGY"": (""VMFC-CORRECTED INTERACTION ENERGY"", 1.7), # note misspelling; }. _qcvar_cancellations = {; ""SCSN-MP2 SAME-SPIN CORRELATION ENERGY"": [""MP2 SAME-SPIN CORRELATION ENERGY""],; ""SCSN-MP2 OPPOSITE-SPIN CORRELATION ENERGY"": [""MP2 OPPOSITE-SPIN CORRELATION ENERGY""],; ""SCS-CCSD SAME-SPIN CORRELATION ENERGY"": [""CCSD SAME-SPIN CORRELATION ENERGY""],; ""SCS-CCSD OPPOSITE-SPIN CORRELATION ENERGY"": [""CCSD OPPOSITE-SPIN CORRELATION ENERGY""],; ""SCS-MP2 SAME-SPIN CORRELATION ENERGY"": [""MP2 SAME-SPIN CORRELATION ENERGY""],; ""SCS-MP2 OPPOSITE-SPIN CORRELATION ENERGY"": [""MP2 OPPOSITE-SPIN CORRELATION ENERGY""],; ""SCS(N)-OMP2 CORRELATION ENERGY"": [""OMP2 SAME-SPIN CORRELATION ENERGY"", ""OMP2 OPPOSITE-SPIN CORRELATION ENERGY""],; ""SCS(N)-OMP2 TOTAL ENERGY"": [""OMP2 SAME-SPIN CORRELATION ENERGY"", ""OMP2 OPPOSITE-SPIN CORRELATION ENERGY""],; ""SCSN-OMP2 CORRELATION ENERGY"": [""OMP2 SAME-SPIN CORRELATION ENERGY"", ""OMP2 OPPOSITE-SPIN CORRELATION ENERGY""],; ""SCSN-OMP2 TOTAL ENERGY"": [""OMP2 SAME-SPIN CORRELATION ENERGY"", ""OMP2 OPPOSITE-SPIN CORRELATION ENERGY""],; }. def _qcvar_warnings(key: str) -> str:; if any([key.upper().endswith("" DIPOLE "" + cart) for cart in [""X"", ""Y"", ""Z""]]):; raise UpgradeHelper(key.upper(), key.upper()[:-2], 1.6, "" Note the Debye -> a.u. units change.""). if any([key.upper().endswith("" QUADRUPOLE "" + cart) for cart in [""XX"", ""YY"", ""ZZ"", ""XY"", ""XZ"", ""YZ""]]):; raise UpgradeHelper(key.upper(), key.upper()[:-3], 1.6, "" Note the Debye -> a.u. units change.""). if key.upper() in _qcvar_transitions:; replacement, version = _qcvar_transitions[key.upper(",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/p4util/python_helpers.html:20998,ENERGY,ENERGY,20998,psi4manual/1.6.x/_modules/psi4/driver/p4util/python_helpers.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/p4util/python_helpers.html,24,['ENERGY'],['ENERGY']
Energy Efficiency,"THOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU General Public License for more details.; #; # You should have received a copy of the GNU General Public License along; # with this program; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #. """"""Module with utility functions for use in input files.""""""; import sys; import os; import math; import numpy as np; from .exceptions import *. [docs]def oeprop(wfn, *args, **kwargs):; """"""Evaluate one-electron properties. :returns: None. :type wfn: :ref:`Wavefunction<sec:psimod_Wavefunction>`; :param wfn: set of molecule, basis, orbitals from which to compute properties. How to specify args, which are actually the most important. :type title: string; :param title: label prepended to all psivars computed. :examples:. >>> # [1] Moments with specific label; >>> E, wfn = energy('hf', return_wfn=True); >>> oeprop(wfn, 'DIPOLE', 'QUADRUPOLE', title='H3O+ SCF'). """"""; oe = psi4.OEProp(wfn); if 'title' in kwargs:; oe.set_title(kwargs['title']); for prop in args:; oe.add(prop); oe.compute(). [docs]def cubeprop(wfn, **kwargs):; """"""Evaluate properties on a grid and generate cube files. .. versionadded:: 0.5; *wfn* parameter passed explicitly. :returns: None. :type wfn: :ref:`Wavefunction<sec:psimod_Wavefunction>`; :param wfn: set of molecule, basis, orbitals from which to generate cube files. :examples:. >>> # [1] Cube files for all orbitals; >>> E, wfn = energy('b3lyp', return_wfn=True); >>> cubeprop(wfn). >>> # [2] Cube files for density (alpha, beta, total, spin) and four orbitals ; >>> # (two alpha, two beta); >>> set cubeprop_tasks ['orbitals', 'density']; >>> set cubeprop_orbitals [5, 6, -5, -6]; >>> E, wfn = energy('scf', return_wfn=True); >>> cubeprop(wfn). """"""; # By default compute the orbitals; if not psi4.has_global_option_changed('CUBEPROP_TASKS'):; psi4.set_global_",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/p4util/util.html:1701,energy,energy,1701,psi4manual/1.0.0/_modules/p4util/util.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/p4util/util.html,1,['energy'],['energy']
Energy Efficiency,"TH_LAST (CCEOM); CCEOM — Do collapse with last vector?. Type: boolean; Default: true. COMPLEX_TOLERANCE (CCEOM); CCEOM — Complex tolerance applied in CCEOM computations. Type: conv double; Default: 1e-12. COMPUT_S2 (DFOCC); DFOCC — Do compute \(\langle \hat{S}^2 \rangle\) for DF-OMP2/DF-MP2?. Type: boolean; Default: false. COMPUTE_MP4_TRIPLES (FNOCC); FNOCC (Expert) — Do compute MP4 triples contribution?. Type: boolean; Default: false. COMPUTE_TRIPLES (FNOCC); FNOCC (Expert) — Do compute triples contribution?. Type: boolean; Default: true. CONSECUTIVE_BACKSTEPS (OPTKING); OPTKING — Set number of consecutive backward steps allowed in optimization. Type: integer; Default: 0. CORR_ANSATZ (PSIMRCC); PSIMRCC — The ansatz to use for MRCC computations. Type: string; Possible Values: SR, MK, BW, APBW; Default: MK. CORR_CCSD_T (PSIMRCC); PSIMRCC — The type of CCSD(T) computation to perform. Type: string; Possible Values: STANDARD, PITTNER; Default: STANDARD. CORR_CHARGE (PSIMRCC); PSIMRCC — The molecular charge of the target state. Type: integer; Default: 0. CORR_MULTP (PSIMRCC); PSIMRCC — The multiplicity, \(M_S(M_S+1)\), of the target state. Must be specified if different from the reference \(M_s\). Type: integer; Default: 1. CORR_WFN (PSIMRCC); PSIMRCC — The type of correlated wavefunction. Type: string; Possible Values: PT2, CCSD, MP2-CCSD, CCSD_T; Default: CCSD. COUPLED_INDUCTION (SAPT); SAPT (Expert) — Solve the CPHF equations to compute coupled induction and exchange-induction. These are not available for ROHF, and the option is automatically false in this case. In all other cases, coupled induction is strongly recommended. Only turn it off if the induction energy is not going to be used. Type: boolean; Default: true. COUPLING (PSIMRCC); PSIMRCC — The order of coupling terms to include in MRCCSDT computations. Type: string; Possible Values: NONE, LINEAR, QUADRATIC, CUBIC; Default: CUBIC. COUPLING_TERMS (PSIMRCC); PSIMRCC — Do include the terms that couple the reference",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/autodoc_glossary_options_c-1.html:88942,charge,charge,88942,psi4manual/1.2.1/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/autodoc_glossary_options_c-1.html,4,['charge'],['charge']
Energy Efficiency,"TH_LAST (CCEOM); CCEOM — Do collapse with last vector?. Type: boolean; Default: true. COMPLEX_TOLERANCE (CCEOM); CCEOM — Complex tolerance applied in CCEOM computations. Type: conv double; Default: 1e-12. COMPUT_S2 (DFOCC); DFOCC — Do compute \(\langle \hat{S}^2 \rangle\) for DF-OMP2/DF-MP2?. Type: boolean; Default: false. COMPUTE_MP4_TRIPLES (FNOCC); FNOCC (Expert) — Do compute MP4 triples contribution?. Type: boolean; Default: false. COMPUTE_TRIPLES (FNOCC); FNOCC (Expert) — Do compute triples contribution?. Type: boolean; Default: true. CONSECUTIVE_BACKSTEPS (OPTKING); OPTKING — Set number of consecutive backward steps allowed in optimization. Type: integer; Default: 0. CORR_ANSATZ (PSIMRCC); PSIMRCC — The ansatz to use for MRCC computations. Type: string; Possible Values: SR, MK, BW, APBW; Default: MK. CORR_CCSD_T (PSIMRCC); PSIMRCC — The type of CCSD(T) computation to perform. Type: string; Possible Values: STANDARD, PITTNER; Default: STANDARD. CORR_CHARGE (PSIMRCC); PSIMRCC — The molecular charge of the target state. Type: integer; Default: 0. CORR_MULTP (PSIMRCC); PSIMRCC — The multiplicity, \(M_S(M_S+1)\), of the target state. Must be specified if different from the reference \(M_s\). Type: integer; Default: 1. CORR_WFN (PSIMRCC); PSIMRCC — The type of correlated wavefunction. Type: string; Possible Values: PT2, CCSD, MP2-CCSD, CCSD_T; Default: CCSD. COUPLED_INDUCTION (SAPT); SAPT (Expert) — Whether or not to compute coupled induction, applies only to the open-shell SAPT0 code. Coupled induction is not available for ROHF, and the option is automatically false in this case. Note that when coupled induction is turned off, the Psi variables SAPT IND20,R ENERGY and SAPT EXCH-IND20,R ENERGY actually contain the uncoupled induction! A corresponding warning is issued in the output file. Type: boolean; Default: true. COUPLING (PSIMRCC); PSIMRCC — The order of coupling terms to include in MRCCSDT computations. Type: string; Possible Values: NONE, LINEAR, QUADRATIC, CU",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/autodoc_glossary_options_c-1.html:88716,charge,charge,88716,psi4manual/1.1.0/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/autodoc_glossary_options_c-1.html,2,['charge'],['charge']
Energy Efficiency,TION ENERGY¶; The coupled-cluster perturbative triples correction [H]. AAA (T) CORRECTION ENERGY¶. AAB (T) CORRECTION ENERGY¶. ABB (T) CORRECTION ENERGY¶. BBB (T) CORRECTION ENERGY¶; Components of the coupled-cluster perturbative triples correction [H]. BRUECKNER CONVERGED¶; Value 1 (0) when the Brueckner orbitals have (have not) converged. CBS TOTAL ENERGY¶. CBS CORRELATION ENERGY¶. CBS REFERENCE ENERGY¶; The total electronic energy [H] and its breakdown into reference total; energy [H] and correlation correction components [H] for the compound; method requested through cbs(). CC ROOT n TOTAL ENERGY¶; The total electronic energy [H]; for the requested coupled cluster level of theory and root; n (numbering starts at GS = 0). CC TOTAL ENERGY¶. CC CORRELATION ENERGY¶. CC2 TOTAL ENERGY¶. CC2 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the CC2 level of theory. CC3 TOTAL ENERGY¶. CC3 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the CC3 level of theory. CCSD TOTAL ENERGY¶. CCSD CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the CCSD level of theory. CCSD(T) TOTAL ENERGY¶. CCSD(T) CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the CCSD(T) level of theory. CI DIPOLE X¶. CI DIPOLE Y¶. CI DIPOLE Z¶; The three components of the dipole [Debye] for the requested; configuration interaction level of theory and root. CI QUADRUPOLE XX¶. CI QUADRUPOLE XY¶. CI QUADRUPOLE XZ¶. CI QUADRUPOLE YY¶. CI QUADRUPOLE YZ¶. CI QUADRUPOLE ZZ¶; The six components of the quadrupole [Debye Ang] for the requested; configuration interaction level of theory and root. CI ROOT n -> ROOT m DIPOLE X¶. CI ROOT n -> ROOT m DIPOLE Y¶. CI ROOT n -> ROOT m DIPOLE Z¶; The three components of the transition dipole [Debye] between roots n; and m for the requested configuration interaction level of theory. CI ROOT n -> RO,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/glossary_psivariables-1.html:1328,energy,energy,1328,psi4manual/4.0b2/glossary_psivariables-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/glossary_psivariables-1.html,4,['energy'],['energy']
Energy Efficiency,"TN), DETCI will compute the ZAPTn series. GUESS_VECTOR must be set to UNIT, HD_OTF must be set to TRUE, and HD_AVG must be set to orb_ener; these should happen by default for MPN = TRUE. Type: boolean; Default: false. For larger computations, additional keywords may be required, as; described in the DETCI section of the Appendix DETCI. Arbitrary Order Perturbation Theory¶; The DETCI module is capable of computing energies for arbitrary; order Møller–Plesset perturbation theory (MPn, for closed-shell; systems with an RHF reference) and for Z-averaged perturbation theory; (ZAPTn, open-shell systems with a ROHF reference). However, please; note that these computations are essentially doing high-order CI (up to; full CI) computations to obtain these results, and hence they will only; be possible for very small systems (generally a dozen electrons or less).; The simplest way to run high-order perturbation theory computations is to; call, e.g., energy('mp10') to invoke a MP10 computation or; energy('zapt25') to invoke a ZAPT25 computation. This will; automatically set several additional user options to their appropriate; values. The program uses the Wigner (2n+1) rule to obtain higher-order; energies from lower-order wavefunctions.; For the interested reader, the additional user options that are; automatically set up by the calls above are as follows. A call like; energy('mp10') sets MPN to TRUE.; The program uses the Wigner (2n+1) rule by default; (MPN_WIGNER = TRUE); and figures out what order of wavefunction is; necessary to reach the desired order in the energy. The program then; sets MAX_NUM_VECS to the required order in the; wavefunction.; By default, the requested n-th order energy is saved as the current; energy to the process environment. ZAPTN works essentially the same; way for an ROHF reference. Arbitrary Order Coupled-Cluster Theory¶; This DETCI-based version of this feature is not yet released. However,; the current version of the code does include an interf",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/detci-1.html:10658,energy,energy,10658,psi4manual/1.2.1/detci-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/detci-1.html,12,['energy'],['energy']
Energy Efficiency,"TNESS FOR A PARTICULAR PURPOSE. See the; # GNU General Public License for more details.; #; # You should have received a copy of the GNU General Public License along; # with this program; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #. """"""Module with classes to integrate MM charges into; a QM calculation. """"""; from __future__ import absolute_import; import re; import os; import math; from driver import *. [docs]class Diffuse(object):. def __init__(self, molecule, basisname, ribasisname):. self.molecule = molecule; self.basisname = basisname; self.ribasisname = ribasisname; self.basis = None; self.ribasis = None; self.da = None; self.Da = None; self.wfn = None. def __str__(self):. s = ' => Diffuse <=\n\n'; s = s + ' ' + str(self.molecule) + '\n'; s = s + ' ' + self.basisname + '\n'; s = s + ' ' + self.ribasisname + '\n'; s = s + '\n'. return s. [docs] def fitScf(self):; """"""Function to run scf and fit a system of diffuse charges to; resulting density. """"""; basisChanged = psi4.has_option_changed(""BASIS""); ribasisChanged = psi4.has_option_changed(""DF_BASIS_SCF""); scftypeChanged = psi4.has_option_changed(""SCF_TYPE""). basis = psi4.get_option(""BASIS""); ribasis = psi4.get_option(""DF_BASIS_SCF""); scftype = psi4.get_option(""SCF_TYPE""). psi4.print_out("" => Diffuse SCF (Determines Da) <=\n\n""). psi4.set_global_option(""BASIS"", self.basisname); psi4.set_global_option(""DF_BASIS_SCF"", self.ribasisname); psi4.set_global_option(""SCF_TYPE"", ""DF""); E, ref = energy('scf', return_wfn=True, molecule=self.molecule); self.wfn = ref; psi4.print_out(""\n""). self.fitGeneral(). psi4.clean(). psi4.set_global_option(""BASIS"", basis); psi4.set_global_option(""DF_BASIS_SCF"", ribasis); psi4.set_global_option(""SCF_TYPE"", scftype). if not basisChanged:; psi4.revoke_option_changed(""BASIS""); if not ribasisChanged:; psi4.revoke_option_changed(""DF_BASIS_SCF""); if not scftypeChanged:; psi4.revoke_option_changed(""SCF_TYP",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qmmm.html:1810,charge,charges,1810,psi4manual/1.0.0/_modules/qmmm.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qmmm.html,1,['charge'],['charges']
Energy Efficiency,"TOLERANCE (SCF). sad_ psi4.core.CUHF attribute. psi4.core.HF attribute. psi4.core.RHF attribute. psi4.core.ROHF attribute. psi4.core.UHF attribute. SAD_CHOL_TOLERANCE (SCF). SAD_D_CONVERGENCE (SCF). SAD_E_CONVERGENCE (SCF). SAD_FRAC_OCC (SCF). SAD_MAXITER (SCF). SAD_PRINT (SCF). SAD_SCF_TYPE (SCF). SAD_SPIN_AVERAGE (SCF). SADGuess class in psi4.core. salc_name() psi4.core.CdSalcList method. SalcComponent class in psi4.core. same_a_b_dens() psi4.core.CCWavefunction method. psi4.core.CIWavefunction method. psi4.core.CUHF method. psi4.core.DFEP2Wavefunction method. psi4.core.HF method. psi4.core.RHF method. psi4.core.ROHF method. psi4.core.UHF method. psi4.core.Wavefunction method. same_a_b_orbs() psi4.core.CCWavefunction method. psi4.core.CIWavefunction method. psi4.core.CUHF method. psi4.core.DFEP2Wavefunction method. psi4.core.HF method. psi4.core.RHF method. psi4.core.ROHF method. psi4.core.UHF method. psi4.core.Wavefunction method. sanitize_name() in module psi4.driver. SAPT. charge-transfer. higher-order. output. SAPT(DFT). SAPT0. theory. SAPT (SCF). SAPT ALPHA. SAPT CT ENERGY. SAPT DISP ENERGY. SAPT DISP2(CCD) ENERGY. SAPT DISP20 ENERGY. SAPT DISP21 ENERGY. SAPT DISP22(S)(CCD) ENERGY. SAPT DISP22(SDQ) ENERGY. SAPT DISP22(T) ENERGY. SAPT DISP22(T)(CCD) ENERGY. SAPT DISP30 ENERGY. SAPT ELST ENERGY. SAPT ELST EXTERN-EXTERN ENERGY. SAPT ELST10,R ENERGY. SAPT ELST12,R ENERGY. SAPT ELST13,R ENERGY. SAPT ENERGY. SAPT EST.DISP22(T) ENERGY. SAPT EST.DISP22(T)(CCD) ENERGY. SAPT EXCH ENERGY. SAPT EXCH-DISP20 ENERGY. SAPT EXCH-DISP20(S^INF) ENERGY. SAPT EXCH-DISP30 ENERGY. SAPT EXCH-IND-DISP30 ENERGY. SAPT EXCH-IND20,R ENERGY. SAPT EXCH-IND20,U ENERGY. SAPT EXCH-IND22 ENERGY. SAPT EXCH-IND30,R ENERGY. SAPT EXCH10 ENERGY. SAPT EXCH10(S^2) ENERGY. SAPT EXCH11(S^2) ENERGY. SAPT EXCH12(S^2) ENERGY. SAPT HF TOTAL ENERGY. SAPT HF(2) ENERGY A(0). SAPT HF(2) ENERGY A(HF). SAPT HF(2) ENERGY AB(HF). SAPT HF(2) ENERGY ABC(HF). SAPT HF(2) ENERGY AC(0). SAPT HF(2) ENERGY AC(HF). SAPT HF(",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/genindex-1.html:115509,charge,charge-transfer,115509,psi4manual/1.4.0/genindex-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/genindex-1.html,5,['charge'],['charge-transfer']
Energy Efficiency,"TOLERANCE. This keyword overrides OCC_TOLERANCE and OCC_PERCENTAGE. Type: array; Default: No Default. ADD_AUXILIARY_BONDS (OPTKING)¶OPTKING — Do add bond coordinates at nearby atoms for non-bonded systems?. Type: boolean; Default: true. AEL (CCDENSITY)¶CCDENSITY (Expert) — Do compute the approximate excitation level? See Stanton and Bartlett, JCP, 98, 1993, 7034. Type: boolean; Default: false. AIO_CPHF (SAPT)¶SAPT — Do use asynchronous disk I/O in the solution of the CPHF equations? Use may speed up the computation slightly at the cost of spawning an additional thread. Type: boolean; Default: false. AIO_DF_INTS (SAPT)¶SAPT — Do use asynchronous disk I/O in the formation of the DF integrals? Use may speed up the computation slightly at the cost of spawning an additional thread. Type: boolean; Default: false. ALGORITHM (DCT)¶DCT — Algorithm to use for the density cumulant and orbital updates in the DCT energy computation. Two-step algorithm is usually more efficient for small systems, but for large systems simultaneous algorithm (default) is recommended. If convergence problems are encountered (especially for highly symmetric systems) QC algorithm can be used. Type: string; Possible Values: TWOSTEP, SIMULTANEOUS, QC; Default: SIMULTANEOUS. ANALYZE (CCENERGY)¶CCENERGY — Do analyze T2 amplitudes. Type: boolean; Default: false. ANALYZE (CCRESPONSE)¶CCRESPONSE — Do analyze X2 amplitudes. Type: boolean; Default: false. AO_BASIS (CCDENSITY)¶CCDENSITY — The algorithm to use for the \(\left\langle VV||VV\right \rangle\) terms. Type: string; Possible Values: NONE, DISK, DIRECT; Default: NONE. AO_BASIS (CCENERGY)¶CCENERGY (Expert) — The algorithm to use for the \(\left\langle VV||VV\right\rangle\) terms If AO_BASIS is NONE, the MO-basis integrals will be used; if AO_BASIS is DISK, the AO-basis integrals stored on disk will be used; if AO_BASIS is DIRECT, the AO-basis integrals will be computed on the fly as necessary. NB: The DIRECT option is not fully implemented and should onl",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/autodoc_glossary_options_c-1.html:2063,efficient,efficient,2063,psi4manual/1.4.0/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodoc_glossary_options_c-1.html,5,['efficient'],['efficient']
Energy Efficiency,"TOLERANCE.; The following input file sets up a DF-CCSD(T); computation using CD integrals; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14molecule h2o {; 0 1; O; H 1 1.0; H 1 1.0 2 104.5; }. set {; scf_type cd; cc_type cd; basis aug-cc-pvdz; freeze_core true; }; energy('ccsd(t)'). The resulting CCSD(T) correlation energy will be equivalent to that; obtained from a conventional computation if CHOLESKY_TOLERANCE is; sufficiently small (e.g. 1e-9). Gn theory¶; The FNOCC module contains all the components that comprise the Gn family; of composite methods. Currently, only the G2 method is supported; [Curtiss:1991:7221]. The G2 procedure may be called through the; energy() wrapper:; 1energy('gaussian-2'). Supported methods¶; The various methods supported by the FNOCC module in PSI4 are detailed; in Table FNOCC Methods. Note that these methods; are implemented for closed-shell references only. For open-shell references,; the calls energy('mp2.5'), energy('mp3'), and energy('mp4') will; default to implementations of these methods in other modules. name; calls method; type select. qcisd; quadratic configuration interaction singles doubles; CI_TYPE CONV. qcisd(t); qcisd with perturbative triples; CI_TYPE CONV. mp2.5; average of second- and third-order perturbation theories; MP_TYPE CONV. mp3; third-order perturbation theory; MP_TYPE CONV. mp4(sdq); fourth-order perturbation theory, minus triples contribution; MP_TYPE CONV. mp4; full fourth-order perturbation theory; MP_TYPE CONV. lccd; linear ccd; CC_TYPE CONV. cepa(0), lccsd; coupled electron pair approximation, variant 0; CC_TYPE CONV. cepa(1); coupled electron pair approximation, variant 1; CC_TYPE CONV. cepa(3); coupled electron pair approximation, variant 3; CC_TYPE CONV. acpf; averaged coupled-pair functional; CC_TYPE CONV. aqcc; averaged quadratic coupled-cluster; CC_TYPE CONV. cisd; configuration interaction with single and double excitations; CI_TYPE CONV. fno-qcisd; qcisd with frozen natural orbitals; CI_TYPE CONV. fno",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/fnocc-1.html:12909,energy,energy,12909,psi4manual/1.1.0/fnocc-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/fnocc-1.html,12,['energy'],['energy']
Energy Efficiency,"TOTAL ENERGY'); escsmp2 = variable('SCS-MP2 TOTAL ENERGY'); rows.append((R, A)); table.append([escf, escsmp2, edfmp2]). import pandas as pd; df = pd.DataFrame(table, columns = [""E(SCF)"", ""E(SCS)"", ""E(DFMP2)""], index=rows); print(df). # E(SCF) E(SCS) E(DFMP2); # (0.9, 100) -76.020680 -76.217006 -76.221189; # (0.9, 102) -76.021305 -76.217439 -76.221605; # (1.0, 100) -76.021264 -76.224987 -76.228727; # (1.0, 102) -76.021460 -76.224946 -76.228668; # (1.1, 100) -75.990195 -76.201891 -76.205087; # (1.1, 102) -75.990085 -76.201498 -76.204676. Python Wrappers¶; The Python foundations of the PSI4 driver and Psithon syntax permit; many commonly performed post-processing procedures to be integrated into; the PSI4 suite.; As seen in the neon dimer example from the tutorial section,; the nbody() wrapper provides automatic computation of; counterpoise-corrected interaction energies between two molecules. For; example,; energy('mp2', bsse_type='cp'). will compute the counterpoise-corrected density-fitted MP2 interaction energy; between two molecules.; PSI4 also provides the cbs() wrapper,; which automatically computes a complete-basis-set extrapolation (and; automatically sets up the computations with different basis sets required to; do the extrapolation). For example,:; # all equivalent. energy('mp2', corl_basis='cc-pv[dt]z', corl_scheme=corl_xtpl_helgaker_2). energy('mp2/cc-pv[dt]z'). will compute a 2-point Helgaker extrapolation of the correlation energy; using the cc-pVDZ and cc-pVTZ basis sets (with method MP2) and add this; extrapolated correlation energy to the Hartree–Fock energy in the; largest basis (cc-pVTZ). cbs() can; be configured behind-the-scenes with explicit arguments, as in the; first example, or the convenience syntax of the equivalent second; example can be used.; Another very useful and powerful feature of PSI4 is the ability; to compute results on entire databases of molecules at a time,; as provided by the database() wrapper. For example,:; database('mp2',",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/psithoninput.html:13423,energy,energy,13423,psi4manual/1.7.x/psithoninput.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/psithoninput.html,3,['energy'],['energy']
Energy Efficiency,"TOTAL ENERGY¶. SCS-CCSD CORRELATION ENERGY¶; The total electronic energy [E_h] and correlation energy component [E_h]; for the CCSD-like method formed by reweighting CCSD DOUBLES ENERGY; by 1.27 opposite-spin and 1.13 same-spin contributions, with; any singles carried along. SCS-MP2 TOTAL ENERGY¶. SCS-MP2 CORRELATION ENERGY¶; The total electronic energy [E_h] and correlation energy component [E_h]; for the MP2-like method formed by reweighting MP2 DOUBLES ENERGY; by 6/5 opposite-spin and 1/3 same-spin contributions, with; any singles carried along. SCS-MP2-VDW TOTAL ENERGY¶. SCS-MP2-VDW CORRELATION ENERGY¶; The total electronic energy [E_h] and correlation energy component [E_h]; for the MP2-like method formed by reweighting MP2 DOUBLES ENERGY; by 1.28 opposite-spin and 0.50 same-spin contributions, with; any singles carried along. DOI: 10.1080/00268970802641242. SCS(N)-MP2 TOTAL ENERGY¶. SCS(N)-MP2 CORRELATION ENERGY¶; The total electronic energy [E_h] and correlation energy component [E_h]; for the MP2-like method formed by reweighting MP2 DOUBLES ENERGY; by 0 opposite-spin and 1.76 same-spin contributions, with; any singles carried along. doi: 10.1021/ct6002737. SCS(N)-OMP2 CORRELATION ENERGY¶. SCS(N)-OMP2 TOTAL ENERGY¶. SCSN-OMP2 CORRELATION ENERGY¶. SCSN-OMP2 TOTAL ENERGY¶; Two spellings of a discontinued QCVariable that may still appear; because the code is frozen pending an update. SCS-OMP2 TOTAL ENERGY¶. SCS-OMP2 CORRELATION ENERGY¶; The total electronic energy [E_h] and correlation energy component [E_h]; for the OMP2-like method formed by reweighting OMP2 DOUBLES ENERGY; by 6/5 opposite-spin and 1/3 same-spin contributions, with; any singles carried along. SCS-MP3 TOTAL ENERGY¶. SCS-MP3 CORRELATION ENERGY¶; The total electronic energy [E_h] and correlation energy component [E_h]; for the MP3-like method formed by reweighting the difference between; MP3 DOUBLES ENERGY and MP2 DOUBLES ENERGY; by 0.25, atop the SCS-MP2 energy, with any singles carried along. ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/glossary_psivariables.html:55217,energy,energy,55217,psi4manual/1.7.x/glossary_psivariables.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/glossary_psivariables.html,8,['energy'],['energy']
Energy Efficiency,"TOTAL ENERGY¶; The total electronic energy [Eh] for the requested theory and root n within irrep h (n starts at 0).; DFT functional labeled if canonical. CCname ROOT n (h) TOTAL ENERGY¶. TD-fctl ROOT n (h) TOTAL ENERGY¶; The total electronic energy [Eh] for the requested theory and root n, which is of irrep h (n starts at 0).; DFT functional labeled if canonical. CCname ROOT n TOTAL ENERGY - h TRANSITION¶. TD-fctl ROOT n TOTAL ENERGY - h TRANSITION¶; The total electronic energy [Eh] for the requested theory and root n, and the transition is of irrep h, (n starts at 0). CCname ROOT n CORRELATION ENERGY¶; The correlation energy [Eh] for the requested coupled cluster level of theory and root n (n starts at 0).; DFT functional labeled if canonical. CCname ROOT n (IN h) CORRELATION ENERGY¶; The correlation energy [Eh] for the requested coupled cluster level of theory and root n within irrep h (n starts at 0). CCname ROOT n (h) CORRELATION ENERGY¶; The correlation energy [Eh] for the requested coupled cluster level of theory and root n, which is of irrep h (n starts at 0). CCname ROOT n CORRELATION ENERGY - h TRANSITION¶; The correlation energy [Eh] for the requested coupled cluster level of theory and root n, and the transition is of irrep h, (n starts at 0). CCname ROOT n DIPOLE¶; Dipole array [e a0] for the requested coupled cluster level of theory and root n (n starts at 0), (3,). CCname ROOT n (IN h) DIPOLE¶; Dipole array [e a0] for the requested coupled cluster level of theory and root n within irrep h (n starts at 0), (3,). CCname ROOT n (h) DIPOLE¶; Dipole array [e a0] for the requested coupled cluster level of theory and root n, which is of irrep h (n starts at 0), (3,). CCname ROOT n DIPOLE - h TRANSITION¶; Dipole array [e a0] for the requested coupled cluster level of theory and root n, and the transition is of irrep h, (n starts at 0), (3,). CCname ROOT n QUADRUPOLE¶; Redundant quadrupole array [e a0^2] for the requested coupled cluster level of theory and roo",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/glossary_psivariables.html:9713,energy,energy,9713,psi4manual/1.6.x/glossary_psivariables.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/glossary_psivariables.html,1,['energy'],['energy']
Energy Efficiency,"TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference (both equivalent); >>> energy('cbs', corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z'); >>> energy('cbs', corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme='corl_xtpl_helgaker_2', delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z', delta_scheme='corl_xtpl_helgaker_2'). >>> # [6] a D-zeta ccsd(t) correction atop a DT-zeta extrapolated ccsd cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference; >>> energy('cbs', corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd', delta_basis='aug-cc-pv[dt]z', delta_scheme='corl_xtpl_helgaker_2', delta2_wfn='ccsd(t)', delta2_wfn_lesser='ccsd', delta2_basis='aug-cc-pvdz'). >>> # [7] a Q5-zeta MP2 calculation, corrected by CCSD(T) at the TQ-zeta extrapolated level, and all-electron CCSD(T) correlation at T-zeta level; >>> energy(cbs, cbs_metadata=[{""wfn"": ""hf"", ""basis"": ""cc-pv5z""}, {""wfn"": ""mp2"", ""basis"": ""cc-pv[q5]z""}, {""wfn"": ""ccsd(t)"", ""basis"": ""cc-pv[tq]z""}, {""wfn"": ""ccsd(t)"", ""basis"": ""cc-pvtz"", ""options"": {""freeze_core"": ""False""}}]). >>> # [8] cbs() coupled with database(); >>> TODO database('mp2', 'BASIC', subset=['h2o','nh3'], symm='on', func=cbs, corl_basis='cc-pV[tq]z', corl_scheme='corl_xtpl_helgaker_2', delta_wfn='ccsd(t)', delta_basis='sto-3g'). >>> # [9] cbs() coupled with optimize(); >>> TODO optimize('mp2', corl_basis='cc-pV[DT]Z', corl_scheme='corl_xtpl_helgaker_2', func=cbs). """""". ## Aliases ##; complete_basis_set = cbs. # LAB: below is a piece of pre-class cbs() that didn't make the transition. it has details, so preserving for future revival; #; # #psioh = core.IOManager.shared_object(); # #psioh.set_specific_retention(psif.PSIF_SCF_MOS, True); # # projection across point groups not allowed and cbs() usually a mix of symm-enabled and symm-tol calls; # # needs to be communicated to optimize() so reset by that optstash;",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/driver_cbs.html:35033,energy,energy,35033,psi4manual/1.9.x/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/driver_cbs.html,4,['energy'],['energy']
Energy Efficiency,"TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference (both equivalent); >>> energy('cbs', corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z'); >>> energy('cbs', corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme='corl_xtpl_helgaker_2', delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z', delta_scheme='corl_xtpl_helgaker_2'). >>> # [6] a D-zeta ccsd(t) correction atop a DT-zeta extrapolated ccsd cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference; >>> energy('cbs', corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd', delta_basis='aug-cc-pv[dt]z', delta_scheme='corl_xtpl_helgaker_2', delta2_wfn='ccsd(t)', delta2_wfn_lesser='ccsd', delta2_basis='aug-cc-pvdz'). >>> # [7] a Q5-zeta MP2 calculation, corrected by CCSD(T) at the TQ-zeta extrapolated level, and all-electron CCSD(T) correlation at T-zeta level; >>> energy(cbs, cbs_metadata=[{""wfn"": ""hf"", ""basis"": ""cc-pv5z""}, {""wfn"": ""mp2"", ""basis"": ""cc-pv[q5]z""}, {""wfn"": ""ccsd(t)"", ""basis"": ""cc-pv[tq]z""}, {""wfn"": ""ccsd(t)"", ""basis"": ""cc-pvtz"", ""options"": {""freeze_core"": ""False""}}]). >>> # [8] cbs() coupled with database(); >>> TODO database('mp2', 'BASIC', subset=['h2o','nh3'], symm='on', func=cbs, corl_basis='cc-pV[tq]z', corl_scheme='corl_xtpl_helgaker_2', delta_wfn='ccsd(t)', delta_basis='sto-3g'). >>> # [9] cbs() coupled with optimize(); >>> TODO optimize('mp2', corl_basis='cc-pV[DT]Z', corl_scheme='corl_xtpl_helgaker_2', func=cbs). """"""; pass. ## Aliases ##; complete_basis_set = cbs. # LAB: below is a piece of pre-class cbs() that didn't make the transition. it has details, so preserving for future revival; #; # #psioh = core.IOManager.shared_object(); # #psioh.set_specific_retention(psif.PSIF_SCF_MOS, True); # # projection across point groups not allowed and cbs() usually a mix of symm-enabled and symm-tol calls; # # needs to be communicated to optimize() so reset by that opt",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver_cbs.html:34812,energy,energy,34812,psi4manual/1.6.x/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver_cbs.html,6,['energy'],['energy']
Energy Efficiency,"TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference (both equivalent); >>> energy('cbs', corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z'); >>> energy('cbs', corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme='corl_xtpl_helgaker_2', delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z', delta_scheme='corl_xtpl_helgaker_2'). >>> # [6] a D-zeta ccsd(t) correction atop a DT-zeta extrapolated ccsd cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference; >>> energy('cbs', corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd', delta_basis='aug-cc-pv[dt]z', delta_scheme='corl_xtpl_helgaker_2', delta2_wfn='ccsd(t)', delta2_wfn_lesser='ccsd', delta2_basis='aug-cc-pvdz'). >>> # [7] a Q5-zeta MP2 calculation, corrected by CCSD(T) at the TQ-zeta extrapolated level, and all-electron CCSD(T) correlation at T-zeta level; >>> energy(cbs, cbs_metadata=[{""wfn"": ""hf"", ""basis"": ""cc-pv5z""}, {""wfn"": ""mp2"", ""basis"": ""cc-pv[q5]z""}, {""wfn"": ""ccsd(t)"", ""basis"": ""cc-pv[tq]z""}, {""wfn"": ""ccsd(t)"", ""basis"": ""cc-pvtz"", ""options"": {""freeze_core"": ""False""}}]). >>> # [8] cbs() coupled with database(); >>> TODO database('mp2', 'BASIC', subset=['h2o','nh3'], symm='on', func=cbs, corl_basis='cc-pV[tq]z', corl_scheme='corl_xtpl_helgaker_2', delta_wfn='ccsd(t)', delta_basis='sto-3g'). >>> # [9] cbs() coupled with optimize(); >>> TODO optimize('mp2', corl_basis='cc-pV[DT]Z', corl_scheme='corl_xtpl_helgaker_2', func=cbs). Note; As of October 2018, only two explicit `deltaN_[wfn,basis,scheme]` sets of options are active; if more delta functions are required, use the `cbs_metadata` interface. Also, temporarily extrapolations are performed on differences of target and scf total energies, rather than on correlation energies directly. This doesn’t affect the extrapolated values of the particular formulas defined here (though it does affect the betas, which are commented ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/cbs.html:16415,energy,energy,16415,psi4manual/1.6.x/cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/cbs.html,5,['energy'],['energy']
Energy Efficiency,TRIPLES_LOW_MEMORY¶. Do use low memory option for triples contribution? Note that this option is enabled automatically if the memory requirements of the conventional algorithm would exceed the available resources. The low memory algorithm is faster in general and has been turned on by default starting September 2020. Type: boolean; Default: true. Expert¶. CEPA_LEVEL¶. Which coupled-pair method is called? This parameter is used internally by the python driver. Changing its value won’t have any effect on the procedure. Type: string; Default: CEPA(0). COMPUTE_MP4_TRIPLES¶. Do compute MP4 triples contribution?. Type: boolean; Default: false. COMPUTE_TRIPLES¶. Do compute triples contribution?. Type: boolean; Default: true. RUN_CCSD¶. do ccsd rather than qcisd?. Type: boolean; Default: false. RUN_CEPA¶. Is this a CEPA job? This parameter is used internally by the pythond driver. Changing its value won’t have any effect on the procedure. Type: boolean; Default: false. RUN_MP2¶. do only evaluate mp2 energy?. Type: boolean; Default: false. RUN_MP3¶. do only evaluate mp3 energy?. Type: boolean; Default: false. RUN_MP4¶. do only evaluate mp4 energy?. Type: boolean; Default: false. USE_DF_INTS¶. Use 3-index integrals to generate 4-index ERI’s? This keyword is used for testing purposes only. Changing its value will have no effect on the computation. Type: boolean; Default: false. table of contents. FNOCC; General; ACTIVE_NAT_ORBS; BRUECKNER_MAXITER; CC_SCALE_OS; CC_SCALE_SS; CC_TIMINGS; CEPA_NO_SINGLES; CHOLESKY_TOLERANCE; DFCC; DF_BASIS_CC; DIIS_MAX_VECS; DIPMOM; E_CONVERGENCE; MAXITER; MP2_SCALE_OS; MP2_SCALE_SS; NAT_ORBS; OCC_PERCENTAGE; OCC_TOLERANCE; R_CONVERGENCE; SCS_CCSD; SCS_CEPA; SCS_MP2; TRIPLES_LOW_MEMORY. Expert; CEPA_LEVEL; COMPUTE_MP4_TRIPLES; COMPUTE_TRIPLES; RUN_CCSD; RUN_CEPA; RUN_MP2; RUN_MP3; RUN_MP4; USE_DF_INTS. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; FNOC,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/autodir_options_c/module__fnocc.html:4229,energy,energy,4229,psi4manual/master/autodir_options_c/module__fnocc.html,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/module__fnocc.html,2,['energy'],['energy']
Energy Efficiency,TRIPLES_LOW_MEMORY¶. Do use low memory option for triples contribution? Note that this option is enabled automatically if the memory requirements of the conventional algorithm would exceed the available resources. The low memory algorithm is faster in general and has been turned on by default starting September 2020. Type: boolean; Default: true. Expert¶. CEPA_LEVEL¶. Which coupled-pair method is called? This parameter is used internally by the python driver. Changing its value won’t have any effect on the procedure. Type: string; Default: CEPA(0). COMPUTE_MP4_TRIPLES¶. Do compute MP4 triples contribution?. Type: boolean; Default: false. COMPUTE_TRIPLES¶. Do compute triples contribution?. Type: boolean; Default: true. RUN_CCSD¶. do ccsd rather than qcisd?. Type: boolean; Default: false. RUN_CEPA¶. Is this a CEPA job? This parameter is used internally by the pythond driver. Changing its value won’t have any effect on the procedure. Type: boolean; Default: false. RUN_MP2¶. do only evaluate mp2 energy?. Type: boolean; Default: false. RUN_MP3¶. do only evaluate mp3 energy?. Type: boolean; Default: false. RUN_MP4¶. do only evaluate mp4 energy?. Type: boolean; Default: false. USE_DF_INTS¶. Use 3-index integrals to generate 4-index ERI’s? This keyword is used for testing purposes only. Changing its value will have no effect on the computation. Type: boolean; Default: false. table of contents. FNOCC; General; ACTIVE_NAT_ORBS; BRUECKNER_MAXITER; CC_SCALE_OS; CC_SCALE_SS; CC_TIMINGS; CEPA_NO_SINGLES; CHOLESKY_TOLERANCE; DFCC; DF_BASIS_CC; DIIS_MAX_VECS; DIPMOM; E_CONVERGENCE; MAXITER; MP2_SCALE_OS; MP2_SCALE_SS; NAT_ORBS; OCC_PERCENTAGE; OCC_TOLERANCE; R_CONVERGENCE; SCS_CCSD; SCS_CEPA; SCS_MP2; TRIPLES_LOW_MEMORY. Expert; CEPA_LEVEL; COMPUTE_MP4_TRIPLES; COMPUTE_TRIPLES; RUN_CCSD; RUN_CEPA; RUN_MP2; RUN_MP3; RUN_MP4; USE_DF_INTS. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; FNOCC. © Copy,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/autodir_options_c/module__fnocc-1.html:4220,energy,energy,4220,psi4manual/1.4.0/autodir_options_c/module__fnocc-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/module__fnocc-1.html,4,['energy'],['energy']
Energy Efficiency,TRIPLES_LOW_MEMORY¶. Do use low memory option for triples contribution? Note that this option is enabled automatically if the memory requirements of the conventional algorithm would exceed the available resources. The low memory algorithm is faster in general and has been turned on by default starting September 2020. Type: boolean; Default: true. Expert¶. CEPA_LEVEL¶. Which coupled-pair method is called? This parameter is used internally by the python driver. Changing its value won’t have any effect on the procedure. Type: string; Default: CEPA(0). COMPUTE_MP4_TRIPLES¶. Do compute MP4 triples contribution?. Type: boolean; Default: false. COMPUTE_TRIPLES¶. Do compute triples contribution?. Type: boolean; Default: true. RUN_CCSD¶. do ccsd rather than qcisd?. Type: boolean; Default: false. RUN_CEPA¶. Is this a CEPA job? This parameter is used internally by the pythond driver. Changing its value won’t have any effect on the procedure. Type: boolean; Default: false. RUN_MP2¶. do only evaluate mp2 energy?. Type: boolean; Default: false. RUN_MP3¶. do only evaluate mp3 energy?. Type: boolean; Default: false. RUN_MP4¶. do only evaluate mp4 energy?. Type: boolean; Default: false. USE_DF_INTS¶. Use 3-index integrals to generate 4-index ERI’s? This keyword is used for testing purposes only. Changing its value will have no effect on the computation. Type: boolean; Default: false. table of contents. FNOCC; General; ACTIVE_NAT_ORBS; BRUECKNER_MAXITER; CC_SCALE_OS; CC_SCALE_SS; CC_TIMINGS; CEPA_NO_SINGLES; CHOLESKY_TOLERANCE; DFCC; DF_BASIS_CC; DIIS_MAX_VECS; DIPMOM; E_CONVERGENCE; MAXITER; MP2_SCALE_OS; MP2_SCALE_SS; NAT_ORBS; OCC_PERCENTAGE; OCC_TOLERANCE; R_CONVERGENCE; SCS_CCSD; SCS_CEPA; SCS_MP2; TRIPLES_LOW_MEMORY. Expert; CEPA_LEVEL; COMPUTE_MP4_TRIPLES; COMPUTE_TRIPLES; RUN_CCSD; RUN_CEPA; RUN_MP2; RUN_MP3; RUN_MP4; USE_DF_INTS. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.5;  · . PSI4. Appendices; Keywords by Module; FNOCC. © Copy,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/autodir_options_c/module__fnocc-1.html:4220,energy,energy,4220,psi4manual/1.5.0/autodir_options_c/module__fnocc-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/autodir_options_c/module__fnocc-1.html,4,['energy'],['energy']
Energy Efficiency,TRIPLES_LOW_MEMORY¶. Do use low memory option for triples contribution? Note that this option is enabled automatically if the memory requirements of the conventional algorithm would exceed the available resources. The low memory algorithm is faster in general and has been turned on by default starting September 2020. Type: boolean; Default: true. Expert¶. CEPA_LEVEL¶. Which coupled-pair method is called? This parameter is used internally by the python driver. Changing its value won’t have any effect on the procedure. Type: string; Default: CEPA(0). COMPUTE_MP4_TRIPLES¶. Do compute MP4 triples contribution?. Type: boolean; Default: false. COMPUTE_TRIPLES¶. Do compute triples contribution?. Type: boolean; Default: true. RUN_CCSD¶. do ccsd rather than qcisd?. Type: boolean; Default: false. RUN_CEPA¶. Is this a CEPA job? This parameter is used internally by the pythond driver. Changing its value won’t have any effect on the procedure. Type: boolean; Default: false. RUN_MP2¶. do only evaluate mp2 energy?. Type: boolean; Default: false. RUN_MP3¶. do only evaluate mp3 energy?. Type: boolean; Default: false. RUN_MP4¶. do only evaluate mp4 energy?. Type: boolean; Default: false. USE_DF_INTS¶. Use 3-index integrals to generate 4-index ERI’s? This keyword is used for testing purposes only. Changing its value will have no effect on the computation. Type: boolean; Default: false. table of contents. FNOCC; General; ACTIVE_NAT_ORBS; BRUECKNER_MAXITER; CC_SCALE_OS; CC_SCALE_SS; CC_TIMINGS; CEPA_NO_SINGLES; CHOLESKY_TOLERANCE; DFCC; DF_BASIS_CC; DIIS_MAX_VECS; DIPMOM; E_CONVERGENCE; MAXITER; MP2_SCALE_OS; MP2_SCALE_SS; NAT_ORBS; OCC_PERCENTAGE; OCC_TOLERANCE; R_CONVERGENCE; SCS_CCSD; SCS_CEPA; SCS_MP2; TRIPLES_LOW_MEMORY. Expert; CEPA_LEVEL; COMPUTE_MP4_TRIPLES; COMPUTE_TRIPLES; RUN_CCSD; RUN_CEPA; RUN_MP2; RUN_MP3; RUN_MP4; USE_DF_INTS. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Appendices; Keywords by Module; FNOCC. © Copy,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/autodir_options_c/module__fnocc.html:4220,energy,energy,4220,psi4manual/1.6.x/autodir_options_c/module__fnocc.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/autodir_options_c/module__fnocc.html,2,['energy'],['energy']
Energy Efficiency,TRIPLES_LOW_MEMORY¶. Do use low memory option for triples contribution? Note that this option is enabled automatically if the memory requirements of the conventional algorithm would exceed the available resources. The low memory algorithm is faster in general and has been turned on by default starting September 2020. Type: boolean; Default: true. Expert¶. CEPA_LEVEL¶. Which coupled-pair method is called? This parameter is used internally by the python driver. Changing its value won’t have any effect on the procedure. Type: string; Default: CEPA(0). COMPUTE_MP4_TRIPLES¶. Do compute MP4 triples contribution?. Type: boolean; Default: false. COMPUTE_TRIPLES¶. Do compute triples contribution?. Type: boolean; Default: true. RUN_CCSD¶. do ccsd rather than qcisd?. Type: boolean; Default: false. RUN_CEPA¶. Is this a CEPA job? This parameter is used internally by the pythond driver. Changing its value won’t have any effect on the procedure. Type: boolean; Default: false. RUN_MP2¶. do only evaluate mp2 energy?. Type: boolean; Default: false. RUN_MP3¶. do only evaluate mp3 energy?. Type: boolean; Default: false. RUN_MP4¶. do only evaluate mp4 energy?. Type: boolean; Default: false. USE_DF_INTS¶. Use 3-index integrals to generate 4-index ERI’s? This keyword is used for testing purposes only. Changing its value will have no effect on the computation. Type: boolean; Default: false. table of contents. FNOCC; General; ACTIVE_NAT_ORBS; BRUECKNER_MAXITER; CC_SCALE_OS; CC_SCALE_SS; CC_TIMINGS; CEPA_NO_SINGLES; CHOLESKY_TOLERANCE; DFCC; DF_BASIS_CC; DIIS_MAX_VECS; DIPMOM; E_CONVERGENCE; MAXITER; MP2_SCALE_OS; MP2_SCALE_SS; NAT_ORBS; OCC_PERCENTAGE; OCC_TOLERANCE; R_CONVERGENCE; SCS_CCSD; SCS_CEPA; SCS_MP2; TRIPLES_LOW_MEMORY. Expert; CEPA_LEVEL; COMPUTE_MP4_TRIPLES; COMPUTE_TRIPLES; RUN_CCSD; RUN_CEPA; RUN_MP2; RUN_MP3; RUN_MP4; USE_DF_INTS. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.7;  · . PSI4. Appendices; Keywords by Module; FNOCC. © Copy,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/autodir_options_c/module__fnocc.html:4220,energy,energy,4220,psi4manual/1.7.x/autodir_options_c/module__fnocc.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/autodir_options_c/module__fnocc.html,2,['energy'],['energy']
Energy Efficiency,TRIPLES_LOW_MEMORY¶. Do use low memory option for triples contribution? Note that this option is enabled automatically if the memory requirements of the conventional algorithm would exceed the available resources. The low memory algorithm is faster in general and has been turned on by default starting September 2020. Type: boolean; Default: true. Expert¶. CEPA_LEVEL¶. Which coupled-pair method is called? This parameter is used internally by the python driver. Changing its value won’t have any effect on the procedure. Type: string; Default: CEPA(0). COMPUTE_MP4_TRIPLES¶. Do compute MP4 triples contribution?. Type: boolean; Default: false. COMPUTE_TRIPLES¶. Do compute triples contribution?. Type: boolean; Default: true. RUN_CCSD¶. do ccsd rather than qcisd?. Type: boolean; Default: false. RUN_CEPA¶. Is this a CEPA job? This parameter is used internally by the pythond driver. Changing its value won’t have any effect on the procedure. Type: boolean; Default: false. RUN_MP2¶. do only evaluate mp2 energy?. Type: boolean; Default: false. RUN_MP3¶. do only evaluate mp3 energy?. Type: boolean; Default: false. RUN_MP4¶. do only evaluate mp4 energy?. Type: boolean; Default: false. USE_DF_INTS¶. Use 3-index integrals to generate 4-index ERI’s? This keyword is used for testing purposes only. Changing its value will have no effect on the computation. Type: boolean; Default: false. table of contents. FNOCC; General; ACTIVE_NAT_ORBS; BRUECKNER_MAXITER; CC_SCALE_OS; CC_SCALE_SS; CC_TIMINGS; CEPA_NO_SINGLES; CHOLESKY_TOLERANCE; DFCC; DF_BASIS_CC; DIIS_MAX_VECS; DIPMOM; E_CONVERGENCE; MAXITER; MP2_SCALE_OS; MP2_SCALE_SS; NAT_ORBS; OCC_PERCENTAGE; OCC_TOLERANCE; R_CONVERGENCE; SCS_CCSD; SCS_CEPA; SCS_MP2; TRIPLES_LOW_MEMORY. Expert; CEPA_LEVEL; COMPUTE_MP4_TRIPLES; COMPUTE_TRIPLES; RUN_CCSD; RUN_CEPA; RUN_MP2; RUN_MP3; RUN_MP4; USE_DF_INTS. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. Appendices; Keywords by Module; FNOCC. © Co,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/autodir_options_c/module__fnocc.html:4222,energy,energy,4222,psi4manual/1.8.x/autodir_options_c/module__fnocc.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/autodir_options_c/module__fnocc.html,2,['energy'],['energy']
Energy Efficiency,TRIPLES_LOW_MEMORY¶. Do use low memory option for triples contribution? Note that this option is enabled automatically if the memory requirements of the conventional algorithm would exceed the available resources. The low memory algorithm is faster in general and has been turned on by default starting September 2020. Type: boolean; Default: true. Expert¶. CEPA_LEVEL¶. Which coupled-pair method is called? This parameter is used internally by the python driver. Changing its value won’t have any effect on the procedure. Type: string; Default: CEPA(0). COMPUTE_MP4_TRIPLES¶. Do compute MP4 triples contribution?. Type: boolean; Default: false. COMPUTE_TRIPLES¶. Do compute triples contribution?. Type: boolean; Default: true. RUN_CCSD¶. do ccsd rather than qcisd?. Type: boolean; Default: false. RUN_CEPA¶. Is this a CEPA job? This parameter is used internally by the pythond driver. Changing its value won’t have any effect on the procedure. Type: boolean; Default: false. RUN_MP2¶. do only evaluate mp2 energy?. Type: boolean; Default: false. RUN_MP3¶. do only evaluate mp3 energy?. Type: boolean; Default: false. RUN_MP4¶. do only evaluate mp4 energy?. Type: boolean; Default: false. USE_DF_INTS¶. Use 3-index integrals to generate 4-index ERI’s? This keyword is used for testing purposes only. Changing its value will have no effect on the computation. Type: boolean; Default: false. table of contents. FNOCC; General; ACTIVE_NAT_ORBS; BRUECKNER_MAXITER; CC_SCALE_OS; CC_SCALE_SS; CC_TIMINGS; CEPA_NO_SINGLES; CHOLESKY_TOLERANCE; DFCC; DF_BASIS_CC; DIIS_MAX_VECS; DIPMOM; E_CONVERGENCE; MAXITER; MP2_SCALE_OS; MP2_SCALE_SS; NAT_ORBS; OCC_PERCENTAGE; OCC_TOLERANCE; R_CONVERGENCE; SCS_CCSD; SCS_CEPA; SCS_MP2; TRIPLES_LOW_MEMORY. Expert; CEPA_LEVEL; COMPUTE_MP4_TRIPLES; COMPUTE_TRIPLES; RUN_CCSD; RUN_CEPA; RUN_MP2; RUN_MP3; RUN_MP4; USE_DF_INTS. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.9.1;  · . PSI4. Appendices; Keywords by Module; FNOCC. © Co,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/autodir_options_c/module__fnocc.html:4222,energy,energy,4222,psi4manual/1.9.x/autodir_options_c/module__fnocc.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/autodir_options_c/module__fnocc.html,2,['energy'],['energy']
Energy Efficiency,"TRON ENERGY'], energies['TWO-ELECTRON ENERGY'], 7, label + '. 2-electron energy'); pass_scf = compare_values(ref_energies['SCF TOTAL ENERGY'], energies['SCF TOTAL ENERGY'], 10, label + '. SCF total energy'); pass_mp2 = compare_values(ref_energies['MP2 CORRELATION ENERGY'], energies['MP2 CORRELATION ENERGY'], 10, label + '. MP2 correlation energy'). if (pass_1el and pass_2el and pass_scf and pass_mp2):; success(label). return True. def _energies_from_fcidump(intdump):; energies = {}; energies['NUCLEAR REPULSION ENERGY'] = intdump['enuc']; epsilon = intdump['epsilon']; Hcore = intdump['hcore']; eri = intdump['eri']. # Compute SCF energy; energies['ONE-ELECTRON ENERGY'], energies['TWO-ELECTRON ENERGY'] = _scf_energy(Hcore, eri,; np.where(epsilon < 0)[0],; intdump['uhf']); # yapf: disable; energies['SCF TOTAL ENERGY'] = energies['ONE-ELECTRON ENERGY'] + energies['TWO-ELECTRON ENERGY'] + energies['NUCLEAR REPULSION ENERGY']; # yapf: enable. # Compute MP2 energy; energies['MP2 CORRELATION ENERGY'] = _mp2_energy(eri, epsilon, intdump['uhf']). return energies. def _scf_energy(Hcore, ERI, occ_sl, unrestricted):; scf_1el_e = np.einsum('ii->', Hcore[np.ix_(occ_sl, occ_sl)]); if not unrestricted:; scf_1el_e *= 2; coulomb = np.einsum('iijj->', ERI[np.ix_(occ_sl, occ_sl, occ_sl, occ_sl)]); exchange = np.einsum('ijij->', ERI[np.ix_(occ_sl, occ_sl, occ_sl, occ_sl)]); if unrestricted:; scf_2el_e = 0.5 * (coulomb - exchange); else:; scf_2el_e = 2.0 * coulomb - exchange. return scf_1el_e, scf_2el_e. def _mp2_energy(ERI, epsilon, unrestricted):; # Occupied and virtual slices; occ_sl = np.where(epsilon < 0)[0]; vir_sl = np.where(epsilon > 0)[0]; eocc = epsilon[occ_sl]; evir = epsilon[vir_sl]; denom = 1 / (eocc.reshape(-1, 1, 1, 1) - evir.reshape(-1, 1, 1) + eocc.reshape(-1, 1) - evir); MO = ERI[np.ix_(occ_sl, vir_sl, occ_sl, vir_sl)]; if unrestricted:; mp2_e = 0.5 * np.einsum(""abrs,abrs,abrs->"", MO, MO - MO.swapaxes(1, 3), denom); else:; mp2_e = np.einsum('iajb,iajb,iajb->', MO, MO, den",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/p4util/fcidump.html:13755,energy,energy,13755,psi4manual/1.2.1/_modules/psi4/driver/p4util/fcidump.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/p4util/fcidump.html,1,['energy'],['energy']
Energy Efficiency,"TS_IO', 'SAVE'). ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, use_c1=True, **kwargs) # C1 certified; else:; if ref_wfn.molecule().schoenflies_symbol() != 'c1':; raise ValidationError("""""" FNOCC does not make use of molecular symmetry: """"""; """"""reference wavefunction must be C1.\n""""""). scf_aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_SCF"",; core.get_option(""SCF"", ""DF_BASIS_SCF""),; ""JKFIT"", core.get_global_option('BASIS'),; puream=ref_wfn.basisset().has_puream()); ref_wfn.set_basisset(""DF_BASIS_SCF"", scf_aux_basis). aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_CC"",; core.get_global_option(""DF_BASIS_CC""),; ""RIFIT"", core.get_global_option(""BASIS"")); ref_wfn.set_basisset(""DF_BASIS_CC"", aux_basis). fnocc_wfn = core.fnocc(ref_wfn). optstash.restore(); return fnocc_wfn. def run_fnocc(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a QCISD(T), CCSD(T), MP2.5, MP3, and MP4 computation. >>> energy('fno-ccsd(t)'). """"""; kwargs = p4util.kwargs_lower(kwargs); level = kwargs.get('level', 0). # stash user options:; optstash = p4util.OptionsState(; ['TRANSQT2', 'WFN'],; ['FNOCC', 'RUN_MP2'],; ['FNOCC', 'RUN_MP3'],; ['FNOCC', 'RUN_MP4'],; ['FNOCC', 'RUN_CCSD'],; ['FNOCC', 'COMPUTE_TRIPLES'],; ['FNOCC', 'COMPUTE_MP4_TRIPLES'],; ['FNOCC', 'DFCC'],; ['FNOCC', 'RUN_CEPA'],; ['FNOCC', 'USE_DF_INTS'],; ['FNOCC', 'NAT_ORBS']). core.set_local_option('FNOCC', 'DFCC', False); core.set_local_option('FNOCC', 'RUN_CEPA', False); core.set_local_option('FNOCC', 'USE_DF_INTS', False). # which method?; if name == 'ccsd':; core.set_local_option('FNOCC', 'COMPUTE_TRIPLES', False); core.set_local_option('FNOCC', 'RUN_CCSD', True); elif name == 'ccsd(t)':; core.set_local_option('FNOCC', 'COMPUTE_TRIPLES', True); core.set_local_option('FNOCC', 'RUN_CCSD', True); elif name == 'fno-ccsd':; core.set_local_option('FNOCC', 'COMPUTE_TRIPLES', False); core.set_local_option('FNOCC', 'RUN_CCSD', True); core.set_local_o",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/procrouting/proc.html:116002,energy,energy,116002,psi4manual/1.1.0/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/procrouting/proc.html,1,['energy'],['energy']
Energy Efficiency,"TYPE""). [docs] def fitGeneral(self):; """"""Function to perform a general fit of diffuse charges; to wavefunction density. """"""; psi4.print_out("" => Diffuse Charge Fitting (Determines da) <=\n\n""); self.wfn = psi4.wavefunction(); self.Da = self.wfn.Da(); self.basis = self.wfn.basisset(); parser = psi4.Gaussian94BasisSetParser(); self.ribasis = psi4.BasisSet.construct(parser, self.molecule, ""DF_BASIS_SCF""). fitter = psi4.DFChargeFitter(); fitter.setPrimary(self.basis); fitter.setAuxiliary(self.ribasis); fitter.setD(self.Da); self.da = fitter.fit(); self.da.scale(2.0). [docs] def populateExtern(self, extern):; # Electronic Part; extern.addBasis(self.ribasis, self.da); # Nuclear Part; for A in range(0, self.molecule.natom()):; extern.addCharge(self.molecule.Z(A), self.molecule.x(A), self.molecule.y(A), self.molecule.z(A)). [docs]class QMMM(object):. def __init__(self):; self.charges = []; self.diffuses = []; self.extern = psi4.ExternalPotential(). [docs] def addDiffuse(self, diffuse):; """"""Function to add a diffuse charge field *diffuse*.""""""; self.diffuses.append(diffuse). [docs] def addChargeBohr(self, Q, x, y, z):; """"""Function to add a point charge of magnitude *Q* at; position (*x*, *y*, *z*) Bohr. """"""; self.charges.append([Q, x, y, z]). [docs] def addChargeAngstrom(self, Q, x, y, z):; """"""Function to add a point charge of magnitude *Q* at; position (*x*, *y*, *z*) Angstroms. """"""; self.charges.append([Q, x / p4const.psi_bohr2angstroms, y / p4const.psi_bohr2angstroms, z / p4const.psi_bohr2angstroms]). def __str__(self):. s = ' ==> QMMM <==\n\n'. s = s + ' => Charges (a.u.) <=\n\n'; s = s + ' %11s %11s %11s %11s\n' % ('Z', 'x', 'y', 'z'); for k in range(0, len(self.charges)):; s = s + ' %11.7f %11.3E %11.3E %11.3E\n' % (self.charges[k][0], self.charges[k][1], self.charges[k][2], self.charges[k][3]); s = s + '\n'. s = s + ' => Diffuses <=\n\n'. for k in range(0, len(self.diffuses)):; s = s + str(self.diffuses[k]). return s. [docs] def populateExtern(self):; """"""Function to de",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/qmmm.html:3617,charge,charge,3617,psi4manual/4.0b5/_modules/qmmm.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qmmm.html,2,['charge'],['charge']
Energy Efficiency,"TYPE']). # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'); core.print_out("""""" SCF Algorithm Type (re)set to DF.\n""""""). if ""DF"" not in core.get_global_option('SCF_TYPE'):; raise ValidationError('DF-MP2 gradients need DF-SCF reference.'). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. core.tstart(); core.print_out('\n'); p4util.banner('DFMP2'); core.print_out('\n'). aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_MP2"",; core.get_option(""DFMP2"", ""DF_BASIS_MP2""),; ""RIFIT"", core.get_global_option('BASIS')); ref_wfn.set_basisset(""DF_BASIS_MP2"", aux_basis). dfmp2_wfn = core.dfmp2(ref_wfn); grad = dfmp2_wfn.compute_gradient(); dfmp2_wfn.set_gradient(grad). # Shove variables into global space; dfmp2_wfn.set_variable(""MP2 TOTAL GRADIENT"", grad) # P::e DFMP2; dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('MP2 TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('MP2 CORRELATION ENERGY')); for k, v in dfmp2_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); core.tstop(); return dfmp2_wfn. def run_dfmp2d_gradient(name, **kwargs):; """"""Encode MP2-D method."""""". dfmp2_wfn = run_dfmp2_gradient('mp2', **kwargs); wfn_grad = dfmp2_wfn.gradient().clone(). _, _disp_functor = build_functional_and_disp('MP2D', restricted=True); disp_grad = _disp_functor.compute_gradient(dfmp2_wfn.molecule(), dfmp2_wfn); wfn_grad.add(disp_grad); dfmp2_wfn.set_gradient(wfn_grad). dfmp2_wfn.set_variable('MP2D CORRELATION ENERGY', dfmp2_wfn.variable('MP2 CORRELATION ENERGY') + dfmp2_wfn.variable('DISPERSION CORRECTION ENERGY')); dfmp2_wfn.set_variable('MP2D TOTAL ENERGY', dfmp2_wfn.variable('MP2D CORRELATION ENERGY') + dfmp2_wfn.variable('HF TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('MP2D TOTAL ENERGY'",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:88730,ENERGY,ENERGY,88730,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,3,['ENERGY'],['ENERGY']
Energy Efficiency,Table Post-SCF Convergence for default convergence criteria for different calculation types. Type: conv double; Default: 1e-6. E_CONVERGENCE (CCEOM); CCEOM — Convergence criterion for excitation energy (change) in the Davidson algorithm for CC-EOM. See Table Post-SCF Convergence for default convergence criteria for different calculation types. Type: conv double; Default: 1e-6. E_CONVERGENCE (DCFT); DCFT — Convergence criterion for energy. See Table Post-SCF Convergence for default convergence criteria for different calculation types. Type: conv double; Default: 1e-10. E_CONVERGENCE (DETCI); DETCI — Convergence criterion for energy. See Table Post-SCF Convergence for default convergence criteria for different calculation types. Type: conv double; Default: 1e-6. E_CONVERGENCE (DFOCC); DFOCC — Convergence criterion for energy. See Table Post-SCF Convergence for default convergence criteria for different calculation types. Type: conv double; Default: 1e-6. E_CONVERGENCE (FNOCC); FNOCC — Convergence criterion for CC energy. See Table Post-SCF Convergence for default convergence criteria for different calculation types. Note that convergence is met only when E_CONVERGENCE and R_CONVERGENCE are satisfied. Type: conv double; Default: 1.0e-6. E_CONVERGENCE (MCSCF); MCSCF — Convergence criterion for energy. Type: conv double; Default: 1e-6. E_CONVERGENCE (MRCC); MRCC — Convergence criterion for energy. See Table Post-SCF Convergence for default convergence criteria for different calculation types. This becomes tol (option #16) in fort.56. Type: conv double; Default: 1e-6. E_CONVERGENCE (OCC); OCC — Convergence criterion for energy. See Table Post-SCF Convergence for default convergence criteria for different calculation types. Type: conv double; Default: 1e-6. E_CONVERGENCE (PSIMRCC); PSIMRCC — Convergence criterion for energy. See Table Post-SCF Convergence for default convergence criteria for different calculation types. Type: conv double; Default: 1e-6. E_CONVERGENCE (SAPT,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_glossary_options_c-1.html:114030,energy,energy,114030,psi4manual/1.0.0/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_glossary_options_c-1.html,8,['energy'],['energy']
Energy Efficiency,"The Hartree–Fock localized energy [Eh] of subsystems A and C implemented for F/I-SAPT. SAPT HF(2) ENERGY BC(HF)¶; The Hartree–Fock localized energy [Eh] of subsystems B and C implemented for F/I-SAPT. SAPT HF(2) ENERGY AB(HF)¶; The Hartree–Fock localized energy [Eh] of subsystems A and B implemented for F/I-SAPT. SAPT HF(2) ENERGY A(HF)¶; The Hartree–Fock localized energy [Eh] of subsystem A implemented for F/I-SAPT. SAPT HF(2) ENERGY B(HF)¶; The Hartree–Fock localized energy [Eh] of subsystem B implemented for F/I-SAPT. SAPT HF(2) ENERGY C¶; The Hartree–Fock energy [Eh] of subsystem C implemented for F/I-SAPT. SAPT HF(2) ENERGY HF¶; The FI-SAPT Hartree–Fock interaction energy [Eh] implemented for F/I-SAPT. SAPT ELST12,R ENERGY¶; An electrostatics-classified SAPT term energy [Eh] implemented for SAPT2. SAPT EXCH11(S^2) ENERGY¶. SAPT EXCH12(S^2) ENERGY¶; An exchange-classified SAPT term energy [Eh] implemented for SAPT2. SAPT IND22 ENERGY¶. SAPT EXCH-IND22 ENERGY¶; An induction-classified SAPT term energy [Eh] implemented for SAPT2. SAPT DISP21 ENERGY¶; A dispersion-classified SAPT term energy [Eh] implemented for SAPT2+. SAPT DISP22(SDQ) ENERGY¶. SAPT DISP22(T) ENERGY¶. SAPT EST.DISP22(T) ENERGY¶; Dispersion-classified MBPT-based SAPT term energy [Eh] implemented for SAPT2+. SAPT DISP2(CCD) ENERGY¶. SAPT DISP22(S)(CCD) ENERGY¶. SAPT DISP22(T)(CCD) ENERGY¶. SAPT EST.DISP22(T)(CCD) ENERGY¶; Dispersion-classified coupled-cluster-based SAPT term energy [Eh] implemented for SAPT2+. SAPT ELST13,R ENERGY¶; An electrostatics-classified SAPT term energy [Eh] implemented for SAPT2+(3). SAPT IND30,R ENERGY¶. SAPT IND-DISP30 ENERGY¶. SAPT EXCH-IND30,R ENERGY¶; A induction-classified SAPT term energy [Eh] implemented for SAPT2+3. SAPT DISP30 ENERGY¶. SAPT EXCH-DISP30 ENERGY¶. SAPT EXCH-IND-DISP30 ENERGY¶; A dispersion-classified SAPT term energy [Eh] implemented for SAPT2+3. SAPT ALPHA¶; SAPT exchange-scaling alpha. SAPT CT ENERGY¶; SAPT charge-transfer energy. SAPT HF TOTAL ENE",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/glossary_psivariables-1.html:37895,energy,energy,37895,psi4manual/1.4.0/glossary_psivariables-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/glossary_psivariables-1.html,5,['energy'],['energy']
Energy Efficiency,"The SIAO1 link partitioning algorithm is used. sapt-sf1; Tests the Psi4 SF-SAPT code. dft-jk; DFT JK on-disk test. omp2p5-grad1; OMP2.5 cc-pVDZ gradient for the H2O molecule. scf-auto-cholesky; Cholesky filter a complete basis. cc38; RHF-CC2-LR/cc-pVDZ static polarizabilities of HOF molecule. psimrcc-fd-freq1; Mk-MRCCSD single point. \(^3 \Sigma ^-\) O2 state described using the Ms = 0 component of the triplet. Uses ROHF triplet orbitals. opt5; 6-31G** UHF CH2 3B1 optimization. Uses a Z-Matrix with dummy atoms, just for demo and testing purposes. opt9; Various constrained energy minimizations of HOOH with cc-pvdz RHF. Cartesian-coordinate constrained optimizations of HOOH in internals. cc40; RHF-CC2-LR/cc-pVDZ optical rotation of H2O2. gauge = length, omega= (589 355 nm). fnocc2; Test G2 method for H2O. cbs-xtpl-wrapper; RHF aug-cc-pVQZ energy for the BH molecule, with Cartesian input. Various gradients for a strained helium dimer and water molecule. opt8; Various constrained energy minimizations of HOOH with cc-pvdz RHF. Cartesian-coordinate constrained optimizations of HOOH in Cartesians. remp-energy2; integral conventional unrestricted REMP/cc-pVDZ energies for the H2O+ molecule. results were independently verified against the initial wavels implementation. sapt6; checks that all SAPT physical components (elst, exch, indc, disp) and total IE are being computed correctly for SAPT2+3(CCD)dMP2/aug-cc-pvdz and all lesser methods thereof. fcidump; test FCIDUMP functionality for rhf/uhf. x2c2; Test of SFX2C-1e on Water cc-pVDZ-DK. In this test the Dirac equation is solved in the uncontracted cc-pVDZ-DK basis. The reference numbers are from Lan Cheng’s implementation in Cfour. props3; DF-SCF cc-pVDZ multipole moments of benzene, up to 7th order and electrostatic potentials evaluated at the nuclear coordinates. olccd-freq1; OLCCD cc-pVDZ freqs for C2H2. dfmp2-1; Density fitted MP2 cc-PVDZ/cc-pVDZ-RI computation of formic acid dimer binding energy using automatic counterpo",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/autodoc_testsuite_corepsi4.html:47509,energy,energy,47509,psi4manual/1.9.x/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/autodoc_testsuite_corepsi4.html,2,['energy'],['energy']
Energy Efficiency,"The corresponding DC and ODC methods; have similar description of the N-representability, but differ in describing the orbital relaxation:; the former methods account for the relaxation only partially, while the latter fully relax the orbitals.; Both DC-06 and DC-12 methods have similar computational cost, same is true when comparing ODC-06 and ODC-12.; Meanwhile, the DC methods are generally more efficient than their ODC analogs, due to a more expensive orbital update step; needed for the full orbital optimization. In the ODC-13 method, the third- and; fourth-order N-representability conditions are used for the density cumulant; and the correlated contribution , respectively,; and the orbitals are variationally optimized.; For most of the applications, it is recommended to use the ODC-12 method, which; provides an optimal balance between accuracy and efficiency, especially for; molecules with open-shell character. If highly accurate results are desired, a; combination of the ODC-13 method with a three-particle energy correction; [] can be used (see below).; For the detailed comparison of the quality of these methods we refer; users to our publications.; The DCFT functional can be specified by the DCFT_FUNCTIONAL option. The; default choice is the ODC-12 functional. In addition to five methods listed; above, DCFT_FUNCTIONAL option can be set to CEPA0 (coupled electron; pair approximation zero, equivalent to linearized coupled cluster doubles; method, LCCD). CEPA0 can be considered as a particular case of the DC-06 and DC-12; methods in the limit of zero non-idempotency of . This option has a limited; functionality and should only be used for test purposes. For the production-level CEPA0 code, see the; description of the OCC section of the manual. The DCFT code can also be used to; compute the energy correction that perturbatively accounts; for three-particle correlation effects, similarly to the (T) correction in coupled; cluster theory. Computation of the correction",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/dcft-1.html:5446,energy,energy,5446,psi4manual/1.0.0/dcft-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/dcft-1.html,2,['energy'],['energy']
Energy Efficiency,"The extrapolation is calculated according to [5]_:; :math:`E_{corl}^X = E_{corl}^{\infty} + \beta X^{-alpha}`. References; ----------. .. [5] Halkier, Helgaker, Jorgensen, Klopper, Koch, Olsen, & Wilson,; Chem. Phys. Lett. 286 (1998) 243-252,; DOI: 10.1016/S0009-2614(99)00179-7. Examples; --------; >>> # [1] CISD extrapolation; >>> energy('cbs', corl_wfn='cisd', corl_basis='cc-pV[DT]Z', corl_scheme='corl_xtpl_helgaker_2'). """"""; if type(valueLO) != type(valueHI):; raise ValidationError(; f""corl_xtpl_helgaker_2: Inputs must be of the same datatype! ({type(valueLO)}, {type(valueHI)})""). if alpha is None:; alpha = 3.0. if isinstance(valueLO, float):; value = (valueHI * zHI**alpha - valueLO * zLO**alpha) / (zHI**alpha - zLO**alpha); beta = (valueHI - valueLO) / (zHI**(-alpha) - zLO**(-alpha)). final = value; if verbose:; # Output string with extrapolation parameters; cbsscheme = f""""""\n\n ==> Helgaker 2-point correlated extrapolation for method: {functionname.upper()} <==\n\n""""""; cbsscheme += """""" LO-zeta (%s) Energy: % 16.12f\n"""""" % (str(zLO), valueLO); cbsscheme += """""" HI-zeta (%s) Energy: % 16.12f\n"""""" % (str(zHI), valueHI); cbsscheme += """""" Alpha (exponent) Value: % 16.12f\n"""""" % alpha; cbsscheme += f"""""" Beta (coefficient) Value: {beta: 16.12f}\n\n""""""; cbsscheme += """""" Extrapolated Energy: % 16.12f\n\n"""""" % value; # Note that in energy-only days, this used to print SCF and Correlation, not Total, Energy. name_str = ""%s/(%s,%s)"" % (functionname.upper(), _zeta_val2sym[zLO].upper(), _zeta_val2sym[zHI].upper()); cbsscheme += """""" @Extrapolated """"""; cbsscheme += name_str + ':'; cbsscheme += "" "" * (19 - len(name_str)); cbsscheme += """"""% 16.12f\n\n"""""" % final; core.print_out(cbsscheme); logger.debug(cbsscheme). return final. elif isinstance(valueLO, np.ndarray):. value = (valueHI * zHI**alpha - valueLO * zLO**alpha) / (zHI**alpha - zLO**alpha); beta = (valueHI - valueLO) / (zHI**(-alpha) - zLO**(-alpha)). if verbose > 2:; cbsscheme = f""""""\n ==> Helgaker 2-point correlated extr",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver_cbs_helper.html:19491,Energy,Energy,19491,psi4manual/1.6.x/_modules/psi4/driver/driver_cbs_helper.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver_cbs_helper.html,5,['Energy'],['Energy']
Energy Efficiency,"The next items in the `cbs_metadata` array extrapolate correlation. All of the above parameters are available, with only the `wfn` and `basis` keywords required. Other supported parameters are:. `wfn_lo`: the lower method from which the delta correction is to be calculated. By default, it is set to `wfn` from the previous field in the `cbs_metadata` array.; `basis_lo`: basis set to be used for the delta correction. By default, it is the same as the `basis` specified above. Others. Parameters; molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. Examples. >>> # [1] replicates with cbs() the simple model chemistry scf/cc-pVDZ: set basis cc-pVDZ energy('scf'); >>> energy(cbs, scf_wfn='scf', scf_basis='cc-pVDZ'). >>> # [2] replicates with cbs() the simple model chemistry mp2/jun-cc-pVDZ: set basis jun-cc-pVDZ energy('mp2'); >>> energy(cbs, corl_wfn='mp2', corl_basis='jun-cc-pVDZ'). >>> # [3] DTQ-zeta extrapolated scf reference energy; >>> energy('cbs', scf_wfn='scf', scf_basis='cc-pV[DTQ]Z', scf_scheme='scf_xtpl_helgaker_3'). >>> # [4] DT-zeta extrapolated mp2 correlation energy atop a T-zeta reference; >>> energy('cbs', corl_wfn='mp2', corl_basis='cc-pv[dt]z', corl_scheme='corl_xtpl_helgaker_2'). >>> # [5] a DT-zeta extrapolated coupled-cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference (both equivalent); >>> energy('cbs', corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z'); >>> energy('cbs', corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme='corl_xtpl_helgaker_2', delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z', delta_scheme='corl_xtpl_helgaker_2'). >>> # [6] a D-zeta ccsd(t) correction atop a DT-zeta extrapolated ccsd cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference; >>> energy('cbs', corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd', delta_basis='",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/api/psi4.driver.cbs.html:12821,energy,energy,12821,psi4manual/1.6.x/api/psi4.driver.cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/api/psi4.driver.cbs.html,6,['energy'],['energy']
Energy Efficiency,"The nuclear repulsion energy contribution [H] to the total SCF energy.; Quantity \(E_{NN}\) in Eq. (4). (3)¶\[E_{NN} = \sum_{i, j<i}^{N_{atom}}\frac{Z_i Z_j}{|\mathbf{R}_i - \mathbf{R}_j|}\]. NBODY (i, j, ..., k)@(a, b, ..., c) TOTAL ENERGY¶; The total energy [Eh] of a component of the requested N-Body energy.; The first parenthetical list over i, j, …, k enumerates; molecular fragments included in the computation in 1-indexed,; input-file order, while the second enumerates list over a, b,; …, c enumerates which fragments contribute basis functions to the; computation. For example, (1, 2)@(1, 2, 3, 4) indicates that the; fragments 1 and 2 are explicitly included in the energy computation,; with basis functions from each of fragments 1, 2, 3, & 4 included in; the basis set. Therefore, the basis functions from fragments 3 and 4; are included as ghost functions within the energy computation. OCEPA(0) TOTAL ENERGY¶. OCEPA(0) CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the orbital-optimized CEPA(0) level of theory. OMP2 TOTAL ENERGY¶. OMP2 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the orbital-optimized MP2 level of theory. OMP3 TOTAL ENERGY¶. OMP3 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the orbital-optimized MP3 level of theory. ONE-ELECTRON ENERGY¶; The one-electron energy contribution [H] to the total SCF energy.; Quantity \(E_{1e^-}\) in Eq. (4). QCISD TOTAL ENERGY¶. QCISD CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the quadratic configuration interaction singles and doubles level; of theory. QCISD(T) TOTAL ENERGY¶. QCISD(T) CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the quadratic configuration interaction singles and doubles with; perturbative triples correction level of theory. SAPT DISP ENERGY¶. SAPT ELST ENE",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/glossary_psivariables-1.html:16997,energy,energy,16997,psi4manual/1.2.1/glossary_psivariables-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/glossary_psivariables-1.html,8,['energy'],['energy']
Energy Efficiency,"The program correctly guessed; all of these options for us. We can change the default behavior through; additional keywords.; Let’s consider what we would do for an open-shell molecule, where; not all electrons are paired. For example, let’s run a computation; on methylene (CH2), whose ground electronic state has two unpaired; electrons (triplet electronic state, or a spin multiplicity ).; In this case, the default spin multiplicity (1) is not correct, so we; need to tell the program the true value (3). Like many programs, PSI4; can get the charge and multiplicity as the first two integers in the; Z-matrix. Note the line with 0 3 at the beginning of the molecule; specification below. In this example we will also specify the bond length; and bond angle as variables ( and ), whose values are given; at the end of the Z-matrix specification.; #! Sample UHF/6-31G** CH2 computation. memory 250 mb. molecule ch2 {; 0 3; C ; H 1 R; H 1 R 2 A. R = 1.075; A = 133.93; }. set basis 6-31G**; set reference uhf; energy ('scf'). This sample input can be found in; tu2-ch2-energy and as; before it can be run through the command psi4 input.dat output.dat; (actually, because psi4 by default looks for an input file named; input.dat and writes by default to a file called output.dat, in this; case one could also just type psi4). If it works, it should print; the final energy as; @UHF Final Energy: -38.92533462456894. Notice we added a new keyword, set reference uhf, to the input. For; open-shell molecules, we have a choice of unrestricted orbitals; (unrestricted Hartree–Fock, or UHF), or restricted orbitals (restricted; open-shell Hartree–Fock, or ROHF). Usually, UHF is a little easier to; converge (although it may be more susceptible to spin contamination than; ROHF). Geometry Optimization and Vibrational Frequency Analysis¶; The above examples were simple single-point energy computations; (as specified by the energy() function). Of course there are other; kinds of computations to perform",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/tutorial-1.html:3383,energy,energy,3383,psi4manual/4.0b4/tutorial-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/tutorial-1.html,4,['energy'],['energy']
Energy Efficiency,"The program correctly guessed; all of these options for us. We can change the default behavior through; additional keywords.; Let’s consider what we would do for an open-shell molecule, where; not all electrons are paired. For example, let’s run a computation; on methylene (CH2), whose ground electronic state has two unpaired; electrons (triplet electronic state, or a spin multiplicity ).; In this case, the default spin multiplicity (1) is not correct, so we; need to tell the program the true value (3). Like many programs, PSI4; can get the charge and multiplicity as the first two integers in the; Z-matrix. Note the line with 0 3 at the beginning of the molecule; specification below. In this example we will also specify the bond length; and bond angle as variables ( and ), whose values are given; at the end of the Z-matrix specification.; #! Sample UHF/6-31G** CH2 computation. memory 250 mb. molecule ch2 {; 0 3; C ; H 1 R; H 1 R 2 A. R = 1.075; A = 133.93; }. set basis 6-31G**; set reference uhf; energy ('scf'). This sample input can be found in; tu2-ch2-energy and as; before it can be run through the command psi4 input.dat output.dat; (actually, because psi4 by default looks for an input file named; input.dat and writes by default to a file called output.dat, in this; case one could also just type psi4). If it works, it should print; the final energy as; @UHF Final Energy: -38.92534160932308. Notice we added a new keyword, set reference uhf, to the input. For; open-shell molecules, we have a choice of unrestricted orbitals; (unrestricted Hartree–Fock, or UHF), or restricted orbitals (restricted; open-shell Hartree–Fock, or ROHF). Usually, UHF is a little easier to; converge (although it may be more susceptible to spin contamination than; ROHF). Geometry Optimization and Vibrational Frequency Analysis¶; The above examples were simple single-point energy computations; (as specified by the energy() function). Of course there are other; kinds of computations to perform",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/tutorial-1.html:3205,energy,energy,3205,psi4manual/4.0b2/tutorial-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/tutorial-1.html,4,['energy'],['energy']
Energy Efficiency,"The program correctly guessed; all of these options for us. We can change the default behavior through; additional keywords.; Let’s consider what we would do for an open-shell molecule, where; not all electrons are paired. For example, let’s run a computation; on methylene (CH2), whose ground electronic state has two unpaired; electrons (triplet electronic state, or a spin multiplicity ).; In this case, the default spin multiplicity (1) is not correct, so we; need to tell the program the true value (3). Like many programs, Psi4; can get the charge and multiplicity as the first two integers in the; Z-matrix. Note the line with 0 3 at the beginning of the molecule; specification below. In this example we will also specify the bond length; and bond angle as variables ( and ), whose values are given; at the end of the Z-matrix specification.; #! Sample UHF/6-31G** CH2 computation. memory 250 mb. molecule ch2 {; 0 3; C ; H 1 R; H 1 R 2 A. R = 1.075; A = 133.93; }. set basis 6-31G**; set reference uhf; energy ('scf'). This sample input can be found in; tu2-ch2-energy and as; before it can be run through the command psi4 input.dat output.dat; (actually, because psi4 by default looks for an input file named; input.dat and writes by default to a file called output.dat, in this; case one could also just type psi4). If it works, it should print; the final energy as; @UHF Final Energy: -38.92533462456894. Notice we added a new keyword, set reference uhf, to the input. For; open-shell molecules, we have a choice of unrestricted orbitals; (unrestricted Hartree–Fock, or UHF), or restricted orbitals (restricted; open-shell Hartree–Fock, or ROHF). Usually, UHF is a little easier to; converge (although it may be more susceptible to spin contamination than; ROHF). Geometry Optimization and Vibrational Frequency Analysis¶; The above examples were simple single-point energy computations; (as specified by the energy() function). Of course there are other; kinds of computations to perform",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/tutorial-1.html:4033,energy,energy,4033,psi4manual/1.0.0/tutorial-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/tutorial-1.html,2,['energy'],['energy']
Energy Efficiency,"The symmetry of the molecule is automatically lowered to account for the different basis sets. pywrap_db1; Database calculation, so no molecule section in input file. Portions of the full databases, restricted by subset keyword, are computed by sapt0 and dfmp2 methods. opt2-fd; SCF DZ allene geometry optimzation, with Cartesian input. sapt2; SAPT0 aug-cc-pVDZ computation of the benzene-methane interaction energy, using the aug-pVDZ-JKFIT DF basis for SCF, the aug-cc-pVDZ-RI DF basis for SAPT0 induction and dispersion, and the aug-pVDZ-JKFIT DF basis for SAPT0 electrostatics and induction. This example uses frozen core as well as asyncronous I/O while forming the DF integrals and CPHF coefficients. cc19; CCSD/cc-pVDZ dipole polarizability at two frequencies. plugin_libfock; LibFock test input. cc4; RHF-CCSD(T) cc-pVQZ frozen-core energy of the BH molecule, with Cartesian input. After the computation, the checkpoint file is renamed, using the PSIO handler. cc10; ROHF-CCSD cc-pVDZ energy for the state of the CN radical. cc8c; ROHF-CCSD cc-pVDZ frozen-core energy for the state of the CN radical, with Cartesian input. scf1; RHF cc-pVQZ energy for the BH molecule, with Cartesian input. cisd-h2o+-0; 6-31G** H2O+ Test CISD Energy Point. cc43; RHF-CC2-LR/STO-3G optical rotation of (S)-methyloxirane. gauge = both, omega = (589 355 nm). cc27; Single point gradient of 1-1B2 state of H2O with EOM-CCSD. cisd-sp-2; 6-31G** H2O Test CISD Energy Point. pywrap_db2; Database calculation with psi4-generated input. Should not be used as a model input file but as a canary to avoid breaking database/input parser dependencies. opt1; SCF STO-3G geometry optimzation, with Z-matrix input. dft2; DFT Functional Test. cc15; RHF-B-CCD(T)/6-31G** H2O single-point energy (fzc, MO-basis ). dft1; DFT Functional Test. cc18; RHF-CCSD-LR/cc-pVDZ static polarizability of HOF. mom; Maximum Overlap Method (MOM) Test. MOM is designed to stabilize SCF convergence and to target excited Slater determinants dir",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/autodoc_testsuite-1.html:6162,energy,energy,6162,psi4manual/4.0b2/autodoc_testsuite-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/autodoc_testsuite-1.html,4,['energy'],['energy']
Energy Efficiency,"The unscaled portion [E_h] of the named correlation energy; from same-spin or triplet doubles correlations. MP2 OPPOSITE-SPIN CORRELATION ENERGY¶. MP2.5 OPPOSITE-SPIN CORRELATION ENERGY¶. MP3 OPPOSITE-SPIN CORRELATION ENERGY¶. CEPA(0) OPPOSITE-SPIN CORRELATION ENERGY¶. CEPA(1) OPPOSITE-SPIN CORRELATION ENERGY¶. CEPA(2) OPPOSITE-SPIN CORRELATION ENERGY¶. CEPA(3) OPPOSITE-SPIN CORRELATION ENERGY¶. CISD OPPOSITE-SPIN CORRELATION ENERGY¶. QCISD OPPOSITE-SPIN CORRELATION ENERGY¶. ACPF OPPOSITE-SPIN CORRELATION ENERGY¶. AQCC OPPOSITE-SPIN CORRELATION ENERGY¶. REMP2 OPPOSITE-SPIN CORRELATION ENERGY¶. LCCD OPPOSITE-SPIN CORRELATION ENERGY¶. CCD OPPOSITE-SPIN CORRELATION ENERGY¶. LCCSD OPPOSITE-SPIN CORRELATION ENERGY¶. CCSD OPPOSITE-SPIN CORRELATION ENERGY¶. OMP2 OPPOSITE-SPIN CORRELATION ENERGY¶. OMP2.5 OPPOSITE-SPIN CORRELATION ENERGY¶. OMP3 OPPOSITE-SPIN CORRELATION ENERGY¶. OREMP2 OPPOSITE-SPIN CORRELATION ENERGY¶. OLCCD OPPOSITE-SPIN CORRELATION ENERGY¶; The unscaled portion [E_h] of the named correlation energy; from opposite-spin or singlet doubles correlations. MRPT TOTAL ENERGY¶. MP2-CCSD TOTAL ENERGY¶. MRCC TOTAL ENERGY¶; Energies [E_h] from correlated multi-reference theories. MULLIKEN CHARGES¶; Property of partial atomic charges [e] by the method of Mulliken, (nat,). NAUX (SCF)¶. NAUX (CC)¶; Convenience storage of number of functions [] in the auxiliary basis; set for named stage of the calculation. NBODY (i, j, ..., k)@(a, b, ..., c) TOTAL ENERGY¶; The total energy [E_h] of a component of the requested N-Body energy.; The first parenthetical list over i, j, …, k enumerates; molecular fragments included in the computation in 1-indexed,; input-file order, while the second enumerates list over a, b,; …, c enumerates which fragments contribute basis functions to the; computation. For example, (1, 2)@(1, 2, 3, 4) indicates that the; fragments 1 and 2 are explicitly included in the energy computation,; with basis functions from each of fragments 1, 2, 3, & 4 included ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/glossary_psivariables.html:40533,energy,energy,40533,psi4manual/1.7.x/glossary_psivariables.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/glossary_psivariables.html,4,['energy'],['energy']
Energy Efficiency,"The value of the spin quantum number \(S\) is given by this option. The default is determined by the value of the multiplicity. This is used for two things: (1) determining the phase of the redundant half of the CI vector when the \(M_s = 0\) component is used (i.e., MS0 = TRUE), and (2) making sure the guess vector has the desired value of \(\langle S^2\rangle\) (if CALC_S_SQUARED is TRUE and ICORE = 1). Type: double; Default: 0.0. S_ORTHOGONALIZATION (SCF); SCF — SO orthogonalization: symmetric or canonical?. Type: string; Possible Values: SYMMETRIC, CANONICAL; Default: SYMMETRIC. S_TOLERANCE (SCF); SCF — Minimum S matrix eigenvalue to be used before compensating for linear dependencies. Type: conv double; Default: 1e-7. SAD_CHOL_TOLERANCE (SCF); SCF (Expert) — Auxiliary basis for the SAD guess. Type: conv double; Default: 1e-7. SAD_D_CONVERGENCE (SCF); SCF — Convergence criterion for SCF density in SAD Guess. Type: conv double; Default: 1e-5. SAD_E_CONVERGENCE (SCF); SCF — Convergence criterion for SCF energy in SAD Guess. Type: conv double; Default: 1e-5. SAD_FRAC_OCC (SCF); SCF (Expert) — Auxiliary basis for the SAD guess. Type: boolean; Default: false. SAD_MAXITER (SCF); SCF (Expert) — Maximum number of SAD guess iterations. Type: integer; Default: 50. SAD_PRINT (SCF); SCF (Expert) — The amount of SAD information to print to the output. Type: integer; Default: 0. SAD_SCF_TYPE (SCF); SCF (Expert) — SCF type of SAD guess. Type: string; Possible Values: DIRECT, DF; Default: DF. SAPT (SCF); SCF (Expert) — Are going to do SAPT? If so, what part?. Type: string; Possible Values: FALSE, 2-DIMER, 2-MONOMER_A, 2-MONOMER_B, 3-TRIMER, 3-DIMER_AB, 3-DIMER_BC, 3-DIMER_AC, 3-MONOMER_A, 3-MONOMER_B, 3-MONOMER_C; Default: FALSE. SAPT0_E10 (SAPT); SAPT (Expert) — For SAPT0 only, compute only first-order electrostatics and exchange. The integrals are computed before any terms, so all integrals will be computed even if they are not needed for the requested term. Type: boolean; De",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/autodoc_glossary_options_c-1.html:200683,energy,energy,200683,psi4manual/1.1.0/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/autodoc_glossary_options_c-1.html,2,['energy'],['energy']
Energy Efficiency,"The value of the spin quantum number \(S\) is given by this option. The default is determined by the value of the multiplicity. This is used for two things: (1) determining the phase of the redundant half of the CI vector when the \(M_s = 0\) component is used (i.e., MS0 = TRUE), and (2) making sure the guess vector has the desired value of \(\langle S^2\rangle\) (if CALC_S_SQUARED is TRUE and ICORE = 1). Type: double; Default: 0.0. S_ORTHOGONALIZATION (SCF); SCF — SO orthogonalization: symmetric or canonical?. Type: string; Possible Values: SYMMETRIC, CANONICAL; Default: SYMMETRIC. S_TOLERANCE (SCF); SCF — Minimum S matrix eigenvalue to be used before compensating for linear dependencies. Type: conv double; Default: 1e-7. SAD_CHOL_TOLERANCE (SCF); SCF (Expert) — Auxiliary basis for the SAD guess. Type: conv double; Default: 1e-7. SAD_D_CONVERGENCE (SCF); SCF — Convergence criterion for SCF density in SAD Guess. Type: conv double; Default: 1e-5. SAD_E_CONVERGENCE (SCF); SCF — Convergence criterion for SCF energy in SAD Guess. Type: conv double; Default: 1e-5. SAD_FRAC_OCC (SCF); SCF (Expert) — Do force an even distribution of occupations across the last partially occupied orbital shell?. Type: boolean; Default: false. SAD_MAXITER (SCF); SCF (Expert) — Maximum number of SAD guess iterations. Type: integer; Default: 50. SAD_PRINT (SCF); SCF (Expert) — The amount of SAD information to print to the output. Type: integer; Default: 0. SAD_SCF_TYPE (SCF); SCF (Expert) — SCF type of SAD guess. Type: string; Possible Values: DIRECT, DF; Default: DF. SAPT (SCF); SCF (Expert) — Are going to do SAPT? If so, what part?. Type: string; Possible Values: FALSE, 2-DIMER, 2-MONOMER_A, 2-MONOMER_B, 3-TRIMER, 3-DIMER_AB, 3-DIMER_BC, 3-DIMER_AC, 3-MONOMER_A, 3-MONOMER_B, 3-MONOMER_C; Default: FALSE. SAPT0_E10 (SAPT); SAPT (Expert) — For SAPT0 only, compute only first-order electrostatics and exchange. The integrals are computed before any terms, so all integrals will be computed even if ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/autodoc_glossary_options_c-1.html:203279,energy,energy,203279,psi4manual/1.2.1/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/autodoc_glossary_options_c-1.html,2,['energy'],['energy']
Energy Efficiency,"Theoretical Methods: SCF to FCI ». Interface to MRCC by M. Kállay¶; Code author: Justin M. Turney and Andrew C. Simmonett; Section author: Justin M. Turney; Module: Keywords, PSI Variables, MRCC; PSI4 contains code to interface to the MRCC program of M. Kállay; and J. Gauss. The license and source code of the MRCC program must be; obtained from Mihály Kállay (http://www.mrcc.hu/). Installation¶; Follow the instructions provided with the source to build the MRCC programs.; To be used by PSI4, ensure that the program binary (dmrcc) can be; found in your PATH. If PSI4 is unable to execute the binary, an; error will be reported. Running MRCC¶; MRCC can be invoked in similar fashion as other theories provided in PSI4.; For example, if you want to obtain the CCSDT energy for water with cc-pVDZ using; MRCC simply provide the following:; molecule h2o {; O; H 1 1.0; H 1 1.0 2 104.5; }; set {; basis cc-pVDZ; }; energy('mrccsdt'). 'mrccsdt' in the call to energy() instructs PSI4 to first; perform an RHF calculation and then call MRCC to compute the CCSDT energy.; For a CCSDT(Q) energy, simply use 'mrccsdt(q)' in the call to; energy(). MRCC can be used to perform geometry optimization and; frequency calculations for electronic ground states only.; At this time, PSI4 is only able to automatically generate the proper; input file for MRCC for the methods listed in table below.; To utilize any method described in the table, you must prefix; the method name with MR. For other methods, you will be required to; use the MRCC keywords described in Appendix MRCC. Methods available in automatic interface with MRCC. CCSD; CCSD(T) [1]; CCSD(T)_L [1]. CCSDT; CCSDT(Q) [1]; CCSDT(Q)_L [1]. CCSDTQ; CCSDTQ(P) [1]; CCSDTQ(P)_L [1]. CCSDTQP; CCSDTQP(H) [1]; CCSDTQP(H)_L [1]. CCSDTQPH;  ;  . CCSDT-1a; CCSDT-1b; CCSDT-3. CCSDTQ-1a; CCSDTQ-1b; CCSDTQ-3. CCSDTQP-1a; CCSDTQP-1b; CCSDTQP-3. CCSDTQPH-1a; CCSDTQPH-1b; CCSDTQPH-3. CC2;  ;  . CC3;  ;  . CC4;  ;  . CC5;  ;  . CC6;  ;  . [1](1, 2, 3, 4, 5, 6,",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/mrcc-1.html:1090,energy,energy,1090,psi4manual/4.0b2/mrcc-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/mrcc-1.html,8,['energy'],['energy']
Energy Efficiency,"Theory¶; Code author: Robert M. Parrish and Justin M. Turney; Section author: Robert M. Parrish; Module: Keywords, PSI Variables, LIBFUNCTIONAL, LIBFOCK, LIBSCF_SOLVER; Both density functional theory and Hartree–Fock theory are controlled; through the SCF module, and the SCF Introduction; section is also relevant here. Theory¶; Generalized Kohn-Sham Density Functional Theory (KS-DFT) is one of the primary; workhorses of modern computational chemistry due to its phenomenal accuracy/cost; ratio.; Pure Kohn-Sham DFT is based on the ideas that A) the energy is a universal; functional of the one-particle electronic density and B) there exists a set of; noninteracting quasiparticles with the same density as the true set of; electrons, with the quasiparticle states determined as eigenvectors of an; effective one-body potential encapsulating the true -body quantum; effects. The former idea allows the electronic density to be dealt with instead; of the much more complicated wavefunction, while the latter allows for the; treatment of the troublesome kinetic energy term via the implicit one-body; Kohn-Sham orbitals. KS-DFT borrows much of the machinery of Hartree-Fock, as is; evident by looking at the energy expression,. Here is the noninteracting quasiparticle kinetic energy operator,; is the nucleus-electron attraction potential, ; is the total electron density matrix, and is the (potentially nonlocal) exchange, correlation, and residual; kinetic energy functional. The residual kinetic energy term is usually quite; small, and is often ignored, hence is often referred to; as simply the exchange-correlation functional (exchange and correlation, not; just exchange-type correlation).; In practice, the first few generations of KS-DFT functionals were chosen to be; local, meaning that the form of the exchange correlation energy is an integral; over all of space of a function depending only on local information in the; density, such as the density value or derivatives. The simplest",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/dft-1.html:1244,energy,energy,1244,psi4manual/4.0b2/dft-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/dft-1.html,8,['energy'],['energy']
Energy Efficiency,"This is,; however, not trivial, as the density matrix elements and; cannot be varied arbitrarily, but must satisfy some; conditions that make sure that the density matrices are N-representable, i.e.; correspond to an antisymmetric N-electron wavefunction. Unfortunately, no; simple set of necessary and sufficient N-representability conditions are known,; and some of the known conditions are not easily imposed. In addition, the lack; of separability of the density matrices may result in the loss of; size-consistency and size-extensivity. In DCFT one takes a different route and; replaces the TPDM in favor of its two-particle density cumulant:. The one-particle density matrix is separated into its idempotent part; and a correction :. The idempotent part of the OPDM corresponds to a Hartree-Fock-like density of; non-interacting electrons, while the non-idempotent correction ; depends on the density cumulant and describes the electron correlation effects.; Inserting the above two equations into the energy expression, we obtain:. where the antisymmetrized two-electron integrals and the generalized Fock operator; matrix elements were defined as follows:. Energy functional has several important properties. First,; the energy is now a function of two types of independent parameters, the; idempotent part of OPDM and the density cumulant; . As a result, the energy functional is Hermitian,; which is important for the evaluation of the molecular properties. The additive; separability of the density cumulant guarantees that all of the DCFT methods; are size-extensive and size-consistent. Furthermore, the N-representability; problem is now greatly simplified, because the idempotent part of the OPDM is; N-representable by construction. One only needs to worry about the; N-representability of the density cumulant, which is a relatively small part of; the TPDM.; In order to obtain the DCFT energy, two conditions must be satisfied:; 1) The energy must be stationary with respect to the v",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/dcft-1.html:1998,energy,energy,1998,psi4manual/4.0b4/dcft-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/dcft-1.html,4,['energy'],['energy']
Energy Efficiency,"This may result in the; occupation shifting between iterations. If the occupations are known a priori,; they may be clamped throughout the procedure by using the DOCC and; SOCC options. For instance, all good quantum chemists know that; \(C_{2v}\) water is; actually,:; molecule h2o {; 0 1; O; H 1 1.0; H 1 1.0 2 104.5; }. set {; docc [3, 0, 1, 1] # 1A1 2A1 1B1 3A1 1B2; basis cc-pvdz; }. energy('scf'). Broken Symmetry¶; For certain problems, such diradicals, allowing the spin-up and spin-down; orbitals to differ in closed-shell computations can be advantageous;; this is known as symmetry breaking. The resulting unrestricted wavefunction; will often provide superior energetics, due to the increased flexibility,; but it will suffer non-physical spin contamination from higher multiplicity states.; A convenient approach to break symmetry is to perform a UHF or UKS calculation; with the guess HOMO and LUMO orbitals mixed.; Mixing of the guess orbitals can be requested by setting the GUESS_MIX; keyword to true:; set reference uhf; set guess_mix true; energy('scf'). Orthogonalization¶; One of the first steps in the SCF procedure is the determination of an; orthogonal basis (known as the OSO basis) from the atomic orbital; basis (known as the AO basis). The Molecular Orbital basis (MO basis); is then built as a particular unitary transformation of the OSO; basis. In PSI4, the determination of the OSO basis is; accomplished via either symmetric, canonical, or partial Cholesky; orthogonalization.; Symmetric orthogonalization uses the symmetric inverse square root of; the overlap matrix for the orthogonalization matrix. Use of symmetric; orthogonalization always yields the same number of OSO functions (and; thereby MOs) as AO functions. However, this may lead to numerical; problems if the overlap matrix has small eigenvalues, which may occur; for large systems or for systems where diffuse basis sets are used.; This problem may be avoided by using canonical orthogonalization, in; ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/scf-1.html:11318,energy,energy,11318,psi4manual/1.4.0/scf-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/scf-1.html,9,['energy'],['energy']
Energy Efficiency,"Total electronic energy in Hartrees. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`CBS TOTAL ENERGY <CBSTOTALENERGY>`; * :psivar:`CBS REFERENCE ENERGY <CBSREFERENCEENERGY>`; * :psivar:`CBS CORRELATION ENERGY <CBSCORRELATIONENERGY>`; * :psivar:`CURRENT ENERGY <CURRENTENERGY>`; * :psivar:`CURRENT REFERENCE ENERGY <CURRENTREFERENCEENERGY>`; * :psivar:`CURRENT CORRELATION ENERGY <CURRENTCORRELATIONENERGY>`. .. caution:: Some features are not yet implemented. Buy a developer a coffee. - Not all methods hooked in through PSI variables, configuration interaction and arbitrary order MP in particular. - No scheme defaults for given basis zeta number, so scheme must be specified explicitly. - No way to tell function to boost fitting basis size for all calculations. - No way to extrapolate def2 family basis sets. - Need to add more extrapolation schemes. As represented in the equation below, a CBS energy method is defined in four; sequential stages (scf, corl, delta, delta2) covering treatment of the; reference total energy, the correlation energy, a delta correction to the; correlation energy, and a second delta correction. Each is activated by its; stage_wfn keyword and is only allowed if all preceding stages are active. .. include:: cbs_eqn.rst. * Energy Methods; The presence of a stage_wfn keyword is the indicator to incorporate; (and check for stage_basis and stage_scheme keywords) and compute; that stage in defining the CBS energy. The cbs() function requires, at a minimum, ``name='scf'`` and ``scf_basis``; keywords to be specified for reference-step only jobs and ``name`` and; ``corl_basis`` keywords for correlated jobs. The following energy methods have been set up for cbs(). .. hlist::; :columns: 5. * scf; * df-scf; * mp2; * df-mp2; * cc2; * ccsd; * bccd; * cc3; * ccsd(t); * cisd; * cisdt; * cisdtq; * ci\ *n*; * fci. :type name: string; :param name: ``'scf'`` || ``'ccsd'`` || etc. First argument, usually unlabeled. Indicates the computational method; for the co",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/_modules/wrappers.html:53121,energy,energy,53121,psi4manual/4.0b3/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/_modules/wrappers.html,8,['energy'],['energy']
Energy Efficiency,"Total electronic energy in Hartrees. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`CBS TOTAL ENERGY <CBSTOTALENERGY>`; * :psivar:`CBS REFERENCE ENERGY <CBSREFERENCEENERGY>`; * :psivar:`CBS CORRELATION ENERGY <CBSCORRELATIONENERGY>`; * :psivar:`CURRENT ENERGY <CURRENTENERGY>`; * :psivar:`CURRENT REFERENCE ENERGY <CURRENTREFERENCEENERGY>`; * :psivar:`CURRENT CORRELATION ENERGY <CURRENTCORRELATIONENERGY>`. .. caution:: Some features are not yet implemented. Buy a developer a coffee. - Not all methods hooked in through PSI variables, configuration interaction and arbitrary order MP in particular. - No scheme defaults for given basis zeta number, so scheme must be specified explicitly. - No way to tell function to boost fitting basis size for all calculations. - No way to extrapolate def2 family basis sets. - Need to add more extrapolation schemes. As represented in the equation below, a CBS energy method is defined in four; sequential stages (scf, corl, delta, delta2) covering treatment of the; reference total energy, the correlation energy, a delta correction to the; correlation energy, and a second delta correction. Each is activated by its; stage_wfn keyword and is only allowed if all preceding stages are active. .. include:: cbs_eqn.rst. * Energy Methods; The presence of a stage_wfn keyword is the indicator to incorporate; (and check for stage_basis and stage_scheme keywords) and compute; that stage in defining the CBS energy. The cbs() function requires, at a minimum, ``name='scf'`` and ``scf_basis``; keywords to be specified for reference-step only jobs and ``name`` and; ``corl_basis`` keywords for correlated jobs. The following energy methods have been set up for cbs(). .. hlist::; :columns: 5. * scf; * df-scf; * mp2; * df-mp2; * cc2; * ccsd; * bccd; * cc3; * ccsd(t); * fci. :type name: string; :param name: ``'scf'`` || ``'ccsd'`` || etc. First argument, usually unlabeled. Indicates the computational method; for the correlation energy, unless only referenc",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:52215,energy,energy,52215,psi4manual/4.0b2/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html,8,['energy'],['energy']
Energy Efficiency,"Total electronic energy in Hartrees. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`CBS TOTAL ENERGY <CBSTOTALENERGY>`; * :psivar:`CBS REFERENCE ENERGY <CBSREFERENCEENERGY>`; * :psivar:`CBS CORRELATION ENERGY <CBSCORRELATIONENERGY>`; * :psivar:`CURRENT ENERGY <CURRENTENERGY>`; * :psivar:`CURRENT REFERENCE ENERGY <CURRENTREFERENCEENERGY>`; * :psivar:`CURRENT CORRELATION ENERGY <CURRENTCORRELATIONENERGY>`. .. caution:: Some features are not yet implemented. Buy a developer a coffee. - Not all methods hooked in through PSI variables, configuration interaction and arbitrary order MP in particular. - No scheme defaults for given basis zeta number, so scheme must be specified explicitly. - No way to tell function to boost fitting basis size for all calculations. - No way to extrapolate def2 family basis sets. - Need to add more extrapolation schemes. As represented in the equation below, a CBS energy method is defined in four; sequential stages (scf, corl, delta, delta2) covering treatment of the; reference total energy, the correlation energy, a delta correction to the; correlation energy, and a second delta correction. Each is activated by its; stage_wfn keyword and is only allowed if all preceding stages are active. .. include:: cbs_eqn.rst. * Energy Methods; The presence of a stage_wfn keyword is the indicator to incorporate; (and check for stage_basis and stage_scheme keywords) and compute; that stage in defining the CBS energy. The cbs() function requires, at a minimum, ``name='scf'`` and ``scf_basis``; keywords to be specified for reference-step only jobs and ``name`` and; ``corl_basis`` keywords for correlated jobs. The following energy methods have been set up for cbs(). .. hlist::; :columns: 5. * scf; * mp2; * mp2.5; * mp3; * mp4(sdq); * mp4; * omp2; * omp3; * ocepa; * cepa0; * cepa(0); * cepa(1); * cepa(3); * acpf; * aqcc; * qcisd; * cc2; * ccsd; * fno-df-ccsd; * bccd; * cc3; * qcisd(t); * ccsd(t); * fno-df-ccsd(t); * bccd(t); * cisd; * cisdt; * cisdtq; *",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:53422,energy,energy,53422,psi4manual/4.0b4/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html,8,['energy'],['energy']
Energy Efficiency,"Traverse <= #; psi4.set_global_option(""DF_INTS_IO"", ""SAVE""). Ns = []; energies = []; potentials = []; convs = []; stats = []. # Run one SCF to burn things in; E, wfn= energy('scf', return_wfn=True, molecule=molecule, **kwargs). # Determine HOMO; eps_a = wfn.epsilon_a(); eps_b = wfn.epsilon_b(); if Na == Nb:; HOMO = -Nb; elif Nb == 0:; HOMO = Na; else:; E_a = eps_a[int(Na - 1)]; E_b = eps_b[int(Nb - 1)]; if E_a >= E_b:; HOMO = Na; else:; HOMO = -Nb. stats.append(""""""\t%6d %6d %6d %6d %6d %6d\n"""""" % (N, Na, Nb, charge, mult, HOMO)). if HOMO > 0:; Na = Na - 1; else:; Nb = Nb - 1; charge = charge + 1; mult = Na - Nb + 1. psi4.set_global_option(""DF_INTS_IO"", ""LOAD""); psi4.set_global_option(""FRAC_START"", frac_start); psi4.set_global_option(""FRAC_RENORMALIZE"", True). # Nuke 'em Rico!; for Nintegral in range(N, Nmin, -1):. # Nuke the current HOMO; for occ in foccs:. psi4.set_global_option(""FRAC_OCC"", [HOMO]); psi4.set_global_option(""FRAC_VAL"", [occ]). E, wfn = energy('scf', return_wfn=True, molecule=molecule, **kwargs); C = 1; if E == 0.0:; E = psi4.get_variable('SCF ITERATION ENERGY'); C = 0. if HOMO > 0:; eps = wfn.epsilon_a(); potentials.append(eps[HOMO - 1]); else:; eps = wfn.epsilon_b(); potentials.append(eps[-HOMO - 1]). Ns.append(Nintegral + occ - 1.0); energies.append(E); convs.append(C). psi4.set_global_option(""FRAC_START"", 2); psi4.set_global_option(""FRAC_LOAD"", True); psi4.set_global_option(""FRAC_DIIS"", frac_diis); psi4.set_global_option(""GUESS"", ""READ""). # Set the next charge/mult; molecule.set_molecular_charge(charge); molecule.set_multiplicity(mult). # Determine HOMO; print('DGAS: What ref should this point to?'); #ref = psi4.legacy_wavefunction(); eps_a = wfn.epsilon_a(); eps_b = wfn.epsilon_b(); if Na == Nb:; HOMO = -Nb; elif Nb == 0:; HOMO = Na; else:; E_a = eps_a[int(Na - 1)]; E_b = eps_b[int(Nb - 1)]; if E_a >= E_b:; HOMO = Na; else:; HOMO = -Nb. stats.append(""""""\t%6d %6d %6d %6d %6d %6d\n"""""" % (Nintegral-1, Na, Nb, charge, mult, HOMO)). if HOMO > 0:; Na =",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/frac.html:9195,energy,energy,9195,psi4manual/1.0.0/_modules/frac.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/frac.html,1,['energy'],['energy']
Energy Efficiency,"True) # used by frequency(). # print gradient array and its rms; wfn.gradient.print_out(); print wfn.gradient().rms(). # format output for other programs; molden(wfn, 'mycalc.molden'). # access array in another format; np.array(wfn.hessian()). # power user returns; E, wfn = psi4.energy(..., return_wfn=True); E, wfn = psi4.optimize(..., return_wfn=True); E, wfn = psi4.frequency(..., return_wfn=True); G, wfn = psi4.gradient(..., return_wfn=True) # used by optimize(); H, wfn = psi4.hessian(..., return_wfn=True) # used by frequency(). # print gradient array and its rms; wfn.gradient.print_out(); print(wfn.gradient().rms()). # format output for other programs; psi4.molden(wfn, 'mycalc.molden'). # access array in another format; np.array(wfn.hessian()). Loops¶; Python provides many control structures, any of which can be used within PSI4; input files. For example, to loop over three basis sets, the following code can; be used:. PSIthonPsiAPIbasis_sets = [""cc-pVDZ"", ""cc-pVTZ"", ""cc-pVQZ""]; for basis_set in basis_sets:; set basis = $basis_set; energy('scf'). basis_sets = [""cc-pVDZ"", ""cc-pVTZ"", ""cc-pVQZ""]; for basis_set in basis_sets:; psi4.set_options({""basis"": basis_set}); psi4.energy('scf'). The declaration of basis_sets is completely standard Python, as is the next; line, which iterates over the list. However, because the Psithon preprocessor; wraps strings in quotes by default, we have to tell it that basis_set is a; Python variable, not a string, by prefixing it with a dollar sign.; The geometry specification supports delayed initialization of variable,; which permits potential energy scans. As an example, we can scan both the; angle and bond length in water. PSIthonPsiAPImolecule h2o{; O; H 1 R; H 1 R 2 A; }. Rvals = [0.9, 1.0, 1.1]; Avals = range(102, 106, 2). set basis cc-pvdz; set scf e_convergence=11; for R in Rvals:; h2o.R = R; for A in Avals:; h2o.A = A; energy('scf'). h2o = psi4.geometry(""""""; O; H 1 R; H 1 R 2 A; """"""). Rvals = [0.9, 1.0, 1.1]; Avals = range(102,",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/psithoninput.html:12351,energy,energy,12351,psi4manual/master/psithoninput.html,https://psicode.org,https://psicode.org/psi4manual/master/psithoninput.html,1,['energy'],['energy']
Energy Efficiency,"True)). # S/R: Quit sow after writing files. Initialize skeleton wfn to receive grad for reap; if freq_mode == 'sow':; optstash.restore(); optstash_conv.restore(); if return_wfn:; return (None, None); else:; return None; elif freq_mode == 'reap':; wfn = psi4.new_wavefunction(molecule, psi4.get_global_option('BASIS')). # Assemble Hessian from gradients; # Final disp is undisp, so wfn has mol, G, H general to freq calc; H = psi4.fd_freq_1(molecule, gradients, irrep) # TODO or moleculeclone?; wfn.set_hessian(H); wfn.set_frequencies(psi4.get_frequencies()). # The last item in the list is the reference energy, return it; psi4.set_variable('CURRENT ENERGY', energies[-1]). psi4.set_parent_symmetry(''); optstash.restore(); optstash_conv.restore(). if return_wfn:; return (wfn.hessian(), wfn); else:; return wfn.hessian(). else:; psi4.print_out(""""""hessian() will perform frequency computation by finite difference of analytic energies.\n""""""). # Set method-dependent scf convergence criteria (test on procedures['energy'] since that's guaranteed); optstash.restore(); optstash_conv.restore(); optstash_conv = driver_util._set_convergence_criterion('energy', lowername, 10, 11, 10, 11, 10). # Shifting the geometry so need to copy the active molecule; moleculeclone = molecule.clone(). # Obtain list of displacements; displacements = psi4.fd_geoms_freq_0(moleculeclone, irrep); moleculeclone.fix_orientation(True); moleculeclone.reinterpret_coordentry(False). # Record undisplaced symmetry for projection of diplaced point groups; psi4.set_parent_symmetry(molecule.schoenflies_symbol()). ndisp = len(displacements). # This version is pretty dependent on the reference geometry being last (as it is now); print(' %d displacements needed.' % ndisp); energies = []. # S/R: Write instructions for sow/reap procedure to output file and reap input file; if freq_mode == 'sow':; instructionsO = """"""\n# The frequency sow/reap procedure has been selected through mode='sow'. In addition\n""""""; instructionsO += ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/driver.html:72512,energy,energy,72512,psi4manual/1.0.0/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver.html,1,['energy'],['energy']
Energy Efficiency,"Type: boolean; Default: false. CFOUR_ESTATE_CONV¶. Specifies the threshold used in converging CC-LR/EOM-CC calculations. The iterative diagonalization is continued until the RMS residual falls below with as the value specified with this keyword. Type: integer; Default: 5. CFOUR_ESTATE_MAXCYC¶. The maximum number of expansion vectors used in the solution of EOMCC equations (Default: 20, hard-coded to 4 in triples calculations). Type: integer; Default: 20. CFOUR_ESTATE_PROP¶. This keyword applies only to EOM-CC calculations and specifies whether any excited or ionized state one-electron properties are to be calculated. Proper use of this keyword requires a relatively advanced knowledge of quantum chemistry and the available options are discussed here. The options are: OFF (=0) [no properties or transition moments are calculated]; EXPECTATION (=1) [transition moments and dipole strengths are calculated along with selected one-electron properties which are evaluated as expectation values]; UNRELAXED (=2) [selected one-electron properties are calculated in an approximation that neglects relaxation of molecular orbitals]; RESPONSE (=3) [selected one-electron properties are calculated as analytic first derivatives of the energy]. Except for EOMCC calculations on two-electron systems (which are exact), properties obtained by the three approaches will not be equivalent. The default value for this keyword is slightly complicated. For TDA calculations, the default is EXPECTATION since the evaluation of transition moments involves only a negligible amount of additional computation relative to the evaluation of the excitation energies. For EOMCC, the default is OFF since evaluation of any transition moments or properties requires approximately twice the computational time. Transition moments and dipole strengths are evaluated by default for all values of ESTATE_PROP other than OFF. Type: string; Possible Values: OFF, EXPECTATION, UNRELAXED, RESPONSE; Default: No Default. CFOUR_ES",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodir_options_c/module__cfour-1.html:18661,energy,energy,18661,psi4manual/1.0.0/autodir_options_c/module__cfour-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodir_options_c/module__cfour-1.html,2,['energy'],['energy']
Energy Efficiency,"Type: boolean; Default: false. DMRG_SCF_ACTIVE_SPACE (DMRG); DMRG — Which active space to use for DMRG calculations: –> input with SCF rotations (INPUT); –> natural orbitals (NO); –> localized and ordered orbitals (LOC). Type: string; Possible Values: INPUT, NO, LOC; Default: INPUT. DMRG_SCF_DIIS_THR (DMRG); DMRG — When the update norm is smaller than this value DIIS starts. Type: double; Default: 1e-2. DMRG_SCF_GRAD_THR (DMRG); DMRG — The density RMS convergence to stop an instruction during successive DMRG instructions. Type: double; Default: 1.e-6. DMRG_SCF_MAX_ITER (DMRG); DMRG — Maximum number of DMRG iterations. Type: integer; Default: 100. DMRG_SCF_STATE_AVG (DMRG); DMRG — Whether or not to use state-averaging for roots >=2 with DMRG-SCF. Type: boolean; Default: true. DMRG_SWEEP_DVDSON_RTOL (DMRG); DMRG — The residual tolerances for the Davidson diagonalization during DMRG instructions. Type: array; Default: No Default. DMRG_SWEEP_ENERGY_CONV (DMRG); DMRG — The energy convergence to stop an instruction during successive DMRG instructions. Type: array; Default: No Default. DMRG_SWEEP_MAX_SWEEPS (DMRG); DMRG — The maximum number of sweeps to stop an instruction during successive DMRG instructions. Type: array; Default: No Default. DMRG_SWEEP_NOISE_PREFAC (DMRG); DMRG — The noise prefactors for successive DMRG instructions. Type: array; Default: No Default. DMRG_SWEEP_STATES (DMRG); DMRG — The number of reduced renormalized basis states to be retained during successive DMRG instructions. Type: array; Default: No Default. DMRG_UNITARY_WRITE (DMRG); DMRG — Whether or not to store the unitary on disk (convenient for restarting). Type: boolean; Default: true. DO_CCD_DISP (SAPT); SAPT (Expert) — Do CCD dispersion correction in SAPT2+, SAPT2+(3) or SAPT2+3?. Type: boolean; Default: false. DO_DIIS (DFOCC); DFOCC — Do apply DIIS extrapolation?. Type: boolean; Default: true. DO_DIIS (OCC); OCC — Do apply DIIS extrapolation?. Type: boolean; Default: true. DO_IND_EXCH_SINF ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/autodoc_glossary_options_c-1.html:111622,energy,energy,111622,psi4manual/1.2.1/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/autodoc_glossary_options_c-1.html,4,['energy'],['energy']
Energy Efficiency,"Type: boolean; Default: false. DMRG_SCF_ACTIVE_SPACE (DMRG); DMRG — Which active space to use for DMRG calculations: –> input with SCF rotations (INPUT); –> natural orbitals (NO); –> localized and ordered orbitals (LOC). Type: string; Possible Values: INPUT, NO, LOC; Default: INPUT. DMRG_SCF_DIIS_THR (DMRG); DMRG — When the update norm is smaller than this value DIIS starts. Type: double; Default: 1e-2. DMRG_SCF_GRAD_THR (DMRG); DMRG — The density RMS convergence to stop an instruction during successive DMRG instructions. Type: double; Default: 1.e-6. DMRG_SCF_MAX_ITER (DMRG); DMRG — Maximum number of DMRG iterations. Type: integer; Default: 100. DMRG_SCF_STATE_AVG (DMRG); DMRG — Whether or not to use state-averaging for roots >=2 with DMRG-SCF. Type: boolean; Default: true. DMRG_SWEEP_DVDSON_RTOL (DMRG); DMRG — The residual tolerances for the Davidson diagonalization during DMRG instructions. Type: array; Default: No Default. DMRG_SWEEP_ENERGY_CONV (DMRG); DMRG — The energy convergence to stop an instruction during successive DMRG instructions. Type: array; Default: No Default. DMRG_SWEEP_MAX_SWEEPS (DMRG); DMRG — The maximum number of sweeps to stop an instruction during successive DMRG instructions. Type: array; Default: No Default. DMRG_SWEEP_NOISE_PREFAC (DMRG); DMRG — The noise prefactors for successive DMRG instructions. Type: array; Default: No Default. DMRG_SWEEP_STATES (DMRG); DMRG — The number of reduced renormalized basis states to be retained during successive DMRG instructions. Type: array; Default: No Default. DMRG_UNITARY_WRITE (DMRG); DMRG — Whether or not to store the unitary on disk (convenient for restarting). Type: boolean; Default: true. DO_CCD_DISP (SAPT); SAPT (Expert) — Do CCD dispersion correction in SAPT2+, SAPT2+(3) or SAPT2+3?. Type: boolean; Default: false. DO_DIIS (DFOCC); DFOCC — Do apply DIIS extrapolation?. Type: boolean; Default: true. DO_DIIS (OCC); OCC — Do apply DIIS extrapolation?. Type: boolean; Default: true. DO_LEVEL_SHIFT (D",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/autodoc_glossary_options_c-1.html:110294,energy,energy,110294,psi4manual/1.1.0/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/autodoc_glossary_options_c-1.html,2,['energy'],['energy']
Energy Efficiency,"Type: boolean; Default: false. DMRG_SCF_ACTIVE_SPACE (DMRG); DMRG — Which active space to use for DMRG calculations: –> input with SCF rotations (INPUT); –> natural orbitals (NO); –> localized and ordered orbitals (LOC). Type: string; Possible Values: INPUT, NO, LOC; Default: INPUT. DMRG_SCF_DIIS_THR (DMRG); DMRG — When the update norm is smaller than this value DIIS starts. Type: double; Default: 1e-2. DMRG_SCF_GRAD_THR (DMRG); DMRG — The density RMS convergence to stop an instruction during successive DMRG instructions. Type: double; Default: 1.e-6. DMRG_SCF_MAX_ITER (DMRG); DMRG — Maximum number of DMRG iterations. Type: integer; Default: 100. DMRG_SCF_STATE_AVG (DMRG); DMRG — Whether or not to use state-averaging for roots >=2 with DMRG-SCF. Type: boolean; Default: true. DMRG_SWEEP_DVDSON_RTOL (DMRG); DMRG — The residual tolerances for the Davidson diagonalization during DMRG instructions. Type: array; Default: No Default. DMRG_SWEEP_ENERGY_CONV (DMRG); DMRG — The energy convergence to stop an instruction during successive DMRG instructions. Type: array; Default: No Default. DMRG_SWEEP_MAX_SWEEPS (DMRG); DMRG — The maximum number of sweeps to stop an instruction during successive DMRG instructions. Type: array; Default: No Default. DMRG_SWEEP_NOISE_PREFAC (DMRG); DMRG — The noiseprefactors for successive DMRG instructions. Type: array; Default: No Default. DMRG_SWEEP_STATES (DMRG); DMRG — The number of reduced renormalized basis states to be retained during successive DMRG instructions. Type: array; Default: No Default. DMRG_UNITARY_WRITE (DMRG); DMRG — Whether or not to store the unitary on disk (convenient for restarting). Type: boolean; Default: true. DO_CCD_DISP (SAPT); SAPT (Expert) — Do CCD dispersion correction in SAPT2+, SAPT2+(3) or SAPT2+3?. Type: boolean; Default: false. DO_DIIS (DFOCC); DFOCC — Do apply DIIS extrapolation?. Type: boolean; Default: true. DO_DIIS (OCC); OCC — Do apply DIIS extrapolation?. Type: boolean; Default: true. DO_LEVEL_SHIFT (DF",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_glossary_options_c-1.html:109340,energy,energy,109340,psi4manual/1.0.0/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_glossary_options_c-1.html,2,['energy'],['energy']
Energy Efficiency,"Type: integer; Default: 1000. MEMORY (LMP2); LMP2 —. Type: integer; Default: 2000. MIXED (DETCI); DETCI (Expert) — Do allow “mixed” RAS II/RAS III excitations into the CI space? If FALSE, then if there are any electrons in RAS III, then the number of holes in RAS I cannot exceed the given excitation level EX_LEVEL. Type: boolean; Default: true. MIXED4 (DETCI); DETCI (Expert) — Do allow “mixed” excitations involving RAS IV into the CI space. Useful to specify a split-virtual CISD[TQ] computation. If FALSE, then if there are any electrons in RAS IV, then the number of holes in RAS I cannot exceed the given excitation level EX_LEVEL. Type: boolean; Default: true. MO_MAXITER (OMP2); OMP2 —. Type: integer; Default: 50. MO_READ (MCSCF); MCSCF — Do read in from file the MOs from a previous computation?. Type: boolean; Default: true. MO_READ (OMP2); OMP2 — Do read coefficient matrices from psi files?. Type: boolean; Default: false. MO_RELAX (DCFT); DCFT — Controls whether to relax the orbitals during the energy computation or not (for debug puproses only). For practical applications only the default must be used. Type: boolean; Default: true. MO_STEP_MAX (OMP2); OMP2 —. Type: double; Default: 0.5. MO_WRITE (OMP2); OMP2 — Do write coefficient matrices to psi files?. Type: boolean; Default: false. MODE (TRANSQT); TRANSQT —. Type: string; Possible Values: TO_MO, TO_AO; Default: TO_MO. MODULE (CPHF); CPHF — What app to test?. Type: string; Possible Values: RCIS, RCPHF, RTDHF, RCPKS, RTDA, RTDDFT; Default: RCIS. MOM_OCC (SCF); SCF — The absolute indices of orbitals to excite from in MOM (+/- for alpha/beta). Type: array; Default: No Default. MOM_START (SCF); SCF — The iteration to start MOM on (or 0 for no MOM). Type: integer; Default: 0. MOM_VIR (SCF); SCF — The absolute indices of orbitals to excite to in MOM (+/- for alpha/beta). Type: array; Default: No Default. MOORDER (TRANSQT); TRANSQT —. Type: array; Default: No Default. MP2_AMPS_PRINT (CCENERGY); CCENERGY — Do print the ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/autodoc_glossary_options_c-1.html:58773,energy,energy,58773,psi4manual/4.0b2/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/autodoc_glossary_options_c-1.html,2,['energy'],['energy']
Energy Efficiency,"Type: integer; Default: 1000. PNO_CONVERGENCE¶. General convergence criteria for DLPNO methods. Type: string; Possible Values: LOOSE, NORMAL, TIGHT; Default: NORMAL. R_CONVERGENCE¶. Residual convergence criteria for local MP2 iterations. Type: conv double; Default: 1e-6. Expert Expert Options¶. F_CUT¶. Fock matrix threshold for treating ampltudes as coupled during local MP2 iterations. Type: double; Default: 1e-5. S_CUT¶. Overlap matrix threshold for removing linear dependencies. Type: double; Default: 1e-8. T_CUT_CLMO¶. Basis set coefficient threshold for including basis function (m) in domain of LMO (i). Type: double; Default: 1e-2. T_CUT_CPAO¶. Basis set coefficient threshold for including basis function (n) in domain of PAO (u). Type: double; Default: 1e-3. T_CUT_DO¶. DOI threshold for including PAO (u) in domain of LMO (i). Type: double; Default: 1e-2. T_CUT_DO_PRE¶. DOI threshold for including PAO (u) in domain of LMO (i) during pre-screening. Type: double; Default: 3e-2. T_CUT_DO_IJ¶. DOI threshold for treating LMOs (i,j) as interacting. Type: double; Default: 1e-5. T_CUT_MKN¶. Mulliken charge threshold for including aux BFs on atom (a) in domain of LMO (i). Type: double; Default: 1e-3. T_CUT_PNO¶. Occupation number threshold for removing PNOs. Type: double; Default: 1e-8. T_CUT_PRE¶. Pair energy threshold (dipole approximation) for treating LMOs (i, j) as interacting. Type: double; Default: 1e-6. table of contents. DLPNO; General Options; DF_BASIS_MP2; DLPNO_LOCAL_ORBITALS; DLPNO_MAXITER; E_CONVERGENCE; LOCAL_CONVERGENCE; LOCAL_MAXITER; PNO_CONVERGENCE; R_CONVERGENCE. Expert Expert Options; F_CUT; S_CUT; T_CUT_CLMO; T_CUT_CPAO; T_CUT_DO; T_CUT_DO_PRE; T_CUT_DO_IJ; T_CUT_MKN; T_CUT_PNO; T_CUT_PRE. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.7;  · . PSI4. Appendices; Keywords by Module; DLPNO. © Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/autodir_options_c/module__dlpno.html:1983,charge,charge,1983,psi4manual/1.7.x/autodir_options_c/module__dlpno.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/autodir_options_c/module__dlpno.html,4,"['charge', 'energy']","['charge', 'energy']"
Energy Efficiency,"Type: string; Possible Values: DF, CONV, AO; Default: CONV. Expert General Options¶. CI_NUM_THREADS¶. Number of threads for DETCI. Type: integer; Default: 1. EX_ALLOW¶. An array of length EX_LEVEL specifying whether each excitation type (S,D,T, etc.) is allowed (1 is allowed, 0 is disallowed). Used to specify non-standard CI spaces such as CIST. Type: array; Default: No Default. MIXED¶. Do allow “mixed” RAS II/RAS III excitations into the CI space? If FALSE, then if there are any electrons in RAS III, then the number of holes in RAS I cannot exceed the given excitation level EX_LEVEL. Type: boolean; Default: true. MIXED4¶. Do allow “mixed” excitations involving RAS IV into the CI space. Useful to specify a split-virtual CISD[TQ] computation. If FALSE, then if there are any electrons in RAS IV, then the number of holes in RAS I cannot exceed the given excitation level EX_LEVEL. Type: boolean; Default: true. R4S¶. Do restrict strings with \(e-\) in RAS IV? Useful to reduce the number of strings required if MIXED4=true, as in a split-virutal CISD[TQ] computation. If more than one electron is in RAS IV, then the holes in RAS I cannot exceed the number of particles in RAS III + RAS IV (i.e., EX_LEVEL , or else the string is discarded. Type: boolean; Default: false. SF_RESTRICT¶. Do eliminate determinants not valid for spin-complete spin-flip CI’s? [see J. S. Sears et al, J. Chem. Phys. 118, 9084-9094 (2003)]. Type: boolean; Default: false. SIGMA_OVERLAP¶. Do print the sigma overlap matrix? Not generally useful. Type: boolean; Default: false. WFN¶. Wavefunction type. This should be set automatically from the calling Psithon function. Type: string; Possible Values: DETCI, CI, ZAPTN, DETCAS, CASSCF, RASSCF; Default: DETCI. Expert Diagonalization Methods¶. H0_BLOCKSIZE¶. This parameter specifies the size of the H0 block of the Hamiltonian which is solved exactly. The n determinants with the lowest SCF energy are selected, and a submatrix of the Hamiltonian is formed using the",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/autodir_options_c/module__detci-1.html:12775,reduce,reduce,12775,psi4manual/1.3.2/autodir_options_c/module__detci-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/autodir_options_c/module__detci-1.html,24,['reduce'],['reduce']
Energy Efficiency,"UARTIC calculations. If STANDARD (=0) is chosen, then simply invoking xcfour will cause a complete job to be run with all second-derivative calculations being done in series. If PARALLEL (=1), then the job stops after the second-derivative calculation at the reference geometry and generates out all input geometries for the remaining calculation. These can be then processed in “parallel” (currently not recommended). Note that it is recommended to carry out all calculations with PARALLEL, even when the actual calculation is carried out in a sequential mode. Type: string; Possible Values: STANDARD, PARALLEL; Default: STANDARD. CFOUR_ANH_DERIVATIVES (CFOUR); CFOUR — Specifies whether the anharmonic force field is calculated using analytic gradients (=FIRST) or analytic Hessians (=SECOND). Type: string; Possible Values: FIRST, SECOND; Default: SECOND. CFOUR_ANH_STEPSIZE (CFOUR); CFOUR — Controls the stepsize used in anharmonic force field calculations. The value is specified in reduced normal coordinates, which are dimensionless. The actual stepsize used in the calculation is \(\times 10^6\) the integer value specified. Type: integer; Default: 50000. CFOUR_ANH_SYMMETRY (CFOUR); CFOUR — Specifies whether non-abelian symmetry is to be exploited in determining displacements for CFOUR_ANHARMONIC =VIBROT or VPT2 calculations. If set to NONABELIAN (=0), maximum advantage will be taken of symmetry and the full set of cubic force constants will be generated from a skeleton set by application of the totally symmetric projection operator. If set to ABELIAN (=1), only the operations of the abelian subgroup will be exploited. Note: It is important to point out that the symmetrization currently works only for cubic constants. Therefore, if you require quartic force constants (for frequency calculations), you must use the ABELIAN option. Moreover, the latter work for only asymmetric tops and linear molecules. Type: string; Possible Values: ABELIAN, NONABELIAN; Default: ABELIAN. CFOUR_A",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/autodoc_glossary_options_c-1.html:19398,reduce,reduced,19398,psi4manual/1.2.1/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/autodoc_glossary_options_c-1.html,6,['reduce'],['reduced']
Energy Efficiency,"UARTIC calculations. If STANDARD (=0) is chosen, then simply invoking xcfour will cause a complete job to be run with all second-derivative calculations being done in series. If PARALLEL (=1), then the job stops after the second-derivative calculation at the reference geometry and generates out all input geometries for the remaining calculation. These can be then processed in “parallel” (currently not recommended). Note that it is recommended to carry out all calculations with PARALLEL, even when the actual calculation is carried out in a sequential mode. Type: string; Possible Values: STANDARD, PARALLEL; Default: STANDARD. CFOUR_ANH_DERIVATIVES (CFOUR); CFOUR — Specifies whether the anharmonic force field is calculated using analytic gradients (=FIRST) or analytic Hessians (=SECOND). Type: string; Possible Values: FIRST, SECOND; Default: SECOND. CFOUR_ANH_STEPSIZE (CFOUR); CFOUR — Controls the stepsize used in anharmonic force field calculations. The value is specified in reduced normal coordinates, which are dimensionless. The actual stepsize used in the calculation is the integer value specified. Type: integer; Default: 50000. CFOUR_ANH_SYMMETRY (CFOUR); CFOUR — Specifies whether nonabelian symmetry is to be exploited in determining displacements for CFOUR_ANHARMONIC =VIBROT or VPT2 calculations. If set to NONABELIAN (=0), maximum advantage will be taken of symmetry and the full set of cubic force constants will be generated from a skeleton set by application of the totally symmetric projection operator. If set to ABELIAN (=1), only the operations of the abelian subgroup will be exploited. Note: It is important to point out that the symmetrization currently works only for cubic constants. Therefore, if you require quartic force constants (for frequency calculations), you must use the ABELIAN option. Moreover, the latter work for only asymmetric tops and linear molecules. Type: string; Possible Values: ABELIAN, NONABELIAN; Default: ABELIAN. CFOUR_ANHARMONIC (CFOUR)",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_glossary_options_c-1.html:19723,reduce,reduced,19723,psi4manual/1.0.0/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_glossary_options_c-1.html,2,['reduce'],['reduced']
Energy Efficiency,"UESS (DCFT); DCFT (Expert) — Whether to read the orbitals from a previous computation, or to compute an MP2 guess. Type: string; Possible Values: CC, BCC, MP2; Default: MP2. DEBUG (CPHF); CPHF — The amount of debug information printed to the output file. Type: integer; Default: 0. DEBUG (DFTSAPT); DFTSAPT — Debug level. Type: integer; Default: 0. DEBUG (GLOBALS); GLOBALS (Expert) — The amount of information to print to the output file. Type: integer; Default: 0. DELETE_AO (TRANSQT); TRANSQT — Do delete AO integral files?. Type: boolean; Default: true. DELETE_RESTR_DOCC (TRANSQT); TRANSQT — Do delete restricted doubly occupieds?. Type: boolean; Default: true. DELETE_TEI (TRANSQT2); TRANSQT2 — Boolean to delete the SO-basis two-electron integral file after the transformation. Type: boolean; Default: true. DELETE_TPDM (TRANSQT); TRANSQT — Do delete TPDM file?. Type: boolean; Default: true. DENOMINATOR_ALGORITHM (SAPT); SAPT — Denominator algorithm for PT methods. Laplace transformations are slightly more efficient. Type: string; Possible Values: LAPLACE, CHOLESKY; Default: LAPLACE. DENOMINATOR_DELTA (SAPT); SAPT — Maximum error allowed (Max error norm in Delta tensor) in the approximate energy denominators employed for most of the and evaluation. Type: double; Default: 1.0e-6. DERTYPE (GLOBALS); GLOBALS (Expert) — Derivative level. Type: string; Possible Values: NONE, FIRST, SECOND, RESPONSE; Default: NONE. DETCI_FREEZE_CORE (DETCI); DETCI — Do freeze core orbitals?. Type: boolean; Default: true. DF_BASIS_CC (FNOCC); FNOCC — Auxilliary basis for df-ccsd(t). Type: string; Possible Values: basis string; Default: No Default. DF_BASIS_ELST (DFTSAPT); DFTSAPT — The name of the electrostatic/exchange auxiliary basis set. Type: string; Possible Values: basis string; Default: No Default. DF_BASIS_ELST (SAPT); SAPT — Auxiliary basis set for SAPT Elst10 and Exch10 density fitting computations, may be important if heavier elements are involved. Defaults to DF_BASIS_SAPT. Type: str",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/autodoc_glossary_options_c-1.html:23875,efficient,efficient,23875,psi4manual/4.0b4/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/autodoc_glossary_options_c-1.html,2,['efficient'],['efficient']
Energy Efficiency,"UGC available in all Psi4 input files.; For convenience, the physical constants used within the Psi4 code (which; are obtained from the 3rd edition of the IUPAC Green; book [Cohen:GreenBook:2008]) are also automatically loaded as Psithon; variables (before ~/.psi4rc is loaded, so that the user’s ~/.psi4rc values can; override the builtins (in the input file, not in the C++ code).; The physical constants used within Psi4, which are automatically; made available within all Psi4 input files.; # @END LICENSE; #. # Do not modify this file! It is auto-generated by the document_options_and_tests; # script, from psi4topdir/include/physconst.h; psi_h = 6.62606896E-34 # The Planck constant (Js) ; psi_c = 2.99792458E8 # Speed of light (ms$^{-1}$) ; psi_kb = 1.3806504E-23 # The Boltzmann constant (JK$^{-1}$) ; psi_R = 8.314472 # Universal gas constant (JK$^{-1}$mol$^{-1}$) ; psi_bohr2angstroms = 0.52917720859 # Bohr to Angstroms conversion factor ; psi_bohr2m = 0.52917720859E-10 # Bohr to meters conversion factor ; psi_bohr2cm = 0.52917720859E-8 # Bohr to centimeters conversion factor ; psi_amu2g = 1.660538782E-24 # Atomic mass units to grams conversion factor ; psi_amu2kg = 1.660538782E-27 # Atomic mass units to kg conversion factor ; psi_au2amu = 5.485799097E-4 # Atomic units (m$@@e$) to atomic mass units conversion factor ; psi_hartree2J = 4.359744E-18 # Hartree to joule conversion factor ; psi_hartree2aJ = 4.359744 # Hartree to attojoule (10$^{-18}$J) conversion factor ; psi_cal2J = 4.184 # Calorie to joule conversion factor ; psi_dipmom_au2si = 8.47835281E-30 # Atomic units to SI units (Cm) conversion factor for dipoles ; psi_dipmom_au2debye = 2.54174623 # Atomic units to Debye conversion factor for dipoles ; psi_dipmom_debye2si = 3.335640952E-30 # Debye to SI units (Cm) conversion factor for dipoles ; psi_c_au = 137.035999679 # Speed of light in atomic units ; psi_hartree2ev = 27.21138 # Hartree to eV conversion factor ; psi_hartree2wavenumbers = 219474.6 # Hartree to cm$^",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/psithoninput-1.html:2330,meter,meters,2330,psi4manual/1.0.0/psithoninput-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/psithoninput-1.html,2,['meter'],['meters']
Energy Efficiency,"UHF computation. fnocc1; Test QCISD(T) for H2O/cc-pvdz Energy. isapt1; This test case shows an example of running and analyzing an FI-SAPT0/jun-cc-pvdz computation for 2,4-pentanediol (targeting the intramolecular hydrogen bond between the two hydroxyl groups). rasscf-sp; 6-31G** H2O Test RASSCF Energy Point will default to only singles and doubles in the active space. dfomp2-grad1; DF-OMP2 cc-pVDZ gradients for the H2O molecule. mints-benchmark; run some BLAS benchmarks. dfomp2-2; OMP2 cc-pVDZ energy for the NO molecule. fsaptd-terms; F-SAPT0/jun-cc-pvdz procedure for methane dimer. nbody-vmfc-hessian; Computation of VMFC-corrected water trimer Hessian (geometry from J. Chem. Theory Comput. 11, 2126-2136 (2015)). psimrcc-fd-freq1; Mk-MRCCSD single point. \(^3 \Sigma ^-\) O2 state described using the Ms = 0 component of the triplet. Uses ROHF triplet orbitals. cc12; Single point energies of multiple excited states with EOM-CCSD. cc16; ROHF and UHF-B-CCD(T)/cc-pVDZ \(^{3}B_1\) CH2 single-point energy (fzc, MO-basis \(\langle ab|cd \rangle\) ). dfccsdl1; DF-CCSDL cc-pVDZ energy for the H2O molecule. cc11; Frozen-core CCSD(ROHF)/cc-pVDZ on CN radical with disk-based AO algorithm. ghosts; Density fitted MP2 cc-PVDZ/cc-pVDZ-RI computation of formic acid dimer binding energy using explicit specification of ghost atoms. This is equivalent to the dfmp2_1 sample but uses both (equivalent) specifications of ghost atoms in a manual counterpoise correction. mints4; A demonstration of mixed Cartesian/ZMatrix geometry specification, using variables, for the benzene-hydronium complex. Atoms can be placed using ZMatrix coordinates, whether they belong to the same fragment or not. Note that the Cartesian specification must come before the ZMatrix entries because the former define absolute positions, while the latter are relative. cepa3; cc-pvdz H2O Test coupled-pair CISD against DETCI CISD. opt14; 6-31G(d) optimization of SF4 starting from linear bond angle that is not linear in the",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/autodoc_testsuite_corepsi4.html:42825,energy,energy,42825,psi4manual/1.7.x/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/autodoc_testsuite_corepsi4.html,2,['energy'],['energy']
Energy Efficiency,"UHF stability analysis test for BH with cc-pVDZ Test direct SCF with and without symmetry, test PK without symmetry. tu6-cp-ne2; Example potential energy surface scan and CP-correction for Ne2. ci-multi; BH single points, checking that program can run multiple instances of DETCI in a single input, without an intervening clean() call. sapt9; usapt example with empty beta. cc8b; ROHF-CCSD cc-pVDZ frozen-core energy for the \(^2\Sigma^+\) state of the CN radical, with Cartesian input. ao-dfcasscf-sp; CASSCF/6-31G** energy point. pywrap-basis; SAPT calculation on bimolecular complex where monomers are unspecified so driver auto-fragments it. Basis set and auxiliary basis sets are assigned by atom type. dfmp2-grad1; DF-MP2 cc-pVDZ gradients for the H2O molecule. dct8; DCT calculation for the NH3+ radical using the ODC-12 and ODC-13 functionals. This performs both simultaneous and QC update of the orbitals and cumulant using DIIS extrapolation. Four-virtual integrals are first handled in the MO Basis for the first two energy computations. In the next computation ao_basis=disk algorithm is used, where the transformation of integrals for four-virtual case is avoided. tdscf-3; td-wb97x excitation energies of singlet states of h2o, wfn passing. remp-energy1; integral conventional REMP/cc-pVDZ energies for the H2O molecule. results were independently verified against the initial wavels implementation. mints2; A test of the basis specification. A benzene atom is defined using a ZMatrix containing dummy atoms and various basis sets are assigned to different atoms. The symmetry of the molecule is automatically lowered to account for the different basis sets. dfomp2-1; OMP2 cc-pVDZ energy for the H2O molecule. scf-hess3; CONV SCF 6-31G analytical vs finite-difference tests Tests UHF hessian code for Ca != Cb. scf-response2; Compute the dipole polarizability for water with custom basis set. cdomp2-1; OMP2 cc-pVDZ energy for the H2O molecule. dft-psivar; HF and DFT variants single-p",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/autodoc_testsuite_corepsi4.html:18869,energy,energy,18869,psi4manual/1.7.x/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/autodoc_testsuite_corepsi4.html,2,['energy'],['energy']
Energy Efficiency,"ULT""); for command in self.commands.keys():; MDI_Register_Command(""@DEFAULT"", command). def length_conversion(self):; """""" Obtain the conversion factor between the geometry specification units and bohr. :returns: *unit_conv* Conversion factor between the geometry specification units and bohr; """"""; unit_name = self.molecule.units(); if unit_name == ""Angstrom"":; unit_conv = qcel.constants.bohr2angstroms; elif unit_name == ""Bohr"":; unit_conv = 1.0; else:; raise Exception('Unrecognized unit type: ' + str(unit_name)). return unit_conv. # Respond to the <NATOMS command; def send_natoms(self):; """""" Send the number of atoms through MDI; """"""; natom = self.molecule.natom(); MDI_Send(natom, 1, MDI_INT, self.comm); return natom. # Respond to the <COORDS command; def send_coords(self):; """""" Send the nuclear coordinates through MDI; """"""; coords = self.molecule.geometry().np.ravel(); MDI_Send(coords, len(coords), MDI_DOUBLE, self.comm); return coords. # Respond to the <CHARGES command; def send_charges(self):; """""" Send the nuclear charges through MDI. :returns: *charges* Atomic charges; """"""; natom = self.molecule.natom(); charges = [self.molecule.charge(iatom) for iatom in range(natom)]; MDI_Send(charges, natom, MDI_DOUBLE, self.comm); return charges. # Respond to the <MASSES command; def send_masses(self):; """""" Send the nuclear masses through MDI. :returns: *masses* Atomic masses; """"""; natom = self.molecule.natom(); molecule_dict = self.molecule.to_dict(); masses = molecule_dict['mass']; MDI_Send(masses, natom, MDI_DOUBLE, self.comm); return masses. # Respond to the <ELEMENTS command; def send_elements(self):; """""" Send the atomic number of each nucleus through MDI. :returns: *elements* Element of each atom; """"""; natom = self.molecule.natom(); elements = [self.molecule.true_atomic_number(iatom) for iatom in range(natom)]; MDI_Send(elements, natom, MDI_INT, self.comm); return elements. # Respond to the <ENERGY command; def send_energy(self):; """""" Send the total energy through MDI. :",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/mdi_engine.html:5094,charge,charges,5094,psi4manual/1.4.0/_modules/psi4/driver/mdi_engine.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/mdi_engine.html,15,"['CHARGE', 'charge']","['CHARGES', 'charges']"
Energy Efficiency,"UPOLE', title='H3O+ SCF'). """"""; oe = core.OEProp(wfn); if 'title' in kwargs:; oe.set_title(kwargs['title']); for prop in args:; oe.add(prop); ; # If we're doing MBIS, we want the free-atom volumes; # in order to compute volume ratios,; # but only if we're calling oeprop as the whole molecule; free_atom = kwargs.get('free_atom',False); if ""MBIS_VOLUME_RATIOS"" in prop.upper() and not free_atom:; core.print_out("" Computing free-atom volumes\n""); free_atom_volumes(wfn) . oe.compute(). [docs]def cubeprop(wfn: core.Wavefunction, **kwargs):; """"""Evaluate properties on a grid and generate cube files. .. versionadded:: 0.5; *wfn* parameter passed explicitly. :returns: None. :param wfn: set of molecule, basis, orbitals from which to generate cube files. :examples:. >>> # [1] Cube files for all orbitals; >>> E, wfn = energy('b3lyp', return_wfn=True); >>> cubeprop(wfn). >>> # [2] Cube files for density (alpha, beta, total, spin) and four orbitals; >>> # (two alpha, two beta); >>> set cubeprop_tasks ['orbitals', 'density']; >>> set cubeprop_orbitals [5, 6, -5, -6]; >>> E, wfn = energy('scf', return_wfn=True); >>> cubeprop(wfn). """"""; # By default compute the orbitals; if not core.has_global_option_changed('CUBEPROP_TASKS'):; core.set_global_option('CUBEPROP_TASKS', ['ORBITALS']). if ((core.get_global_option('INTEGRAL_PACKAGE') == 'ERD') and ('ESP' in core.get_global_option('CUBEPROP_TASKS'))):; raise ValidationError('INTEGRAL_PACKAGE ERD does not play nicely with electrostatic potential, so stopping.'). cp = core.CubeProperties(wfn); cp.compute_properties(). [docs]def set_memory(inputval: Union[str, int, float], execute: bool = True, quiet: bool = False) -> int:; """"""Reset the total memory allocation. Parameters; ----------; inputval; Memory value. An Integer or float is taken literally as bytes to be set.; A string is taken as a unit-containing value (e.g., 30 mb), which is; case-insensitive.; execute; When False, interpret *inputval* without setting in Psi4 core.; quiet; When Tru",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/util.html:3122,energy,energy,3122,psi4manual/1.7.x/_modules/psi4/driver/p4util/util.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/util.html,2,['energy'],['energy']
Energy Efficiency,"UR options list; plus notes on keyword relevance when run through Psi4. Information; at the CFOUR manual may; also be useful, as may the many samples at psi4/samples/cfour.; Set Cfour keywords just like Psi4 keywords. The names of keywords; are unchanged beyond a prepended “cfour_”. (Though be aware that common; abbreviations like CALC and REF must be fully spelled out as; CFOUR_CALC_LEVEL and CFOUR_REFERENCE when used in; Psi4.); In limited trial cases, keywords nominally directed at non-Cfour modules; are translated into their Cfour counterparts. For example, setting; REFERENCE will appropriately set CFOUR_REFERENCE. For a; list of applicable keywords, see source of; qcdb.cfour.muster_psi4options().; Consult Functionality for information on what Cfour; functionality is accessible through Psi4. Psi4 for Cfour Users¶; In the simplest use of the Psi4/Cfour interface, a Psi4 input file; can simply “wrap” a ZMAT file and execute xcfour. This is; illustrated in the following example:; cfour {; UHF-SCF energy calculation; N; H 1 R; H 1 R 2 A. R=1.008; A=105.0. *ACES2(CALC=HF,BASIS=qz2p; MULT=2,REF=UHF; OCCUPATION=3-1-1-0/3-0-1-0; SCF_CONV=12; MEMORY=20000000); }. energy('cfour'). Here, the contents of the cfour {...} block are written directly to a; ZMAT file. This is joined by a default GENBAS file; (psi4/share/basis/GENBAS). To preferentially use your own GENBAS,; place it in PATH or PSIPATH. The line calling; energy() with argument 'cfour' invokes; xcfour.; After execution of the energy('cfour') line completes, Cfour results; are read back into Psi4 format and are thereafter accessible for; further processing in the input file. See Output for; details. This storage of results in variables and arrays in memory for; the duration of the Psi4 instance (as opposed to solely in files); is the only advantage thus far incurred by the P4C4 interface. We’ll call; this mode of basic utility the “sandwich” mode.; Molecule specification in Psi4 allows Cartesians, Z-matrices, mixed",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/cfour-1.html:3107,energy,energy,3107,psi4manual/1.0.0/cfour-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/cfour-1.html,2,['energy'],['energy']
Energy Efficiency,"UR — Specifies the threshold used in converging CC-LR/EOM-CC calculations. The iterative diagonalization is continued until the RMS residual falls below \(10^{-N}\) with \(N\) as the value specified with this keyword. Type: integer; Default: 5. CFOUR_ESTATE_MAXCYC (CFOUR)¶CFOUR — The maximum number of expansion vectors used in the solution of EOMCC equations (Default: 20, hard-coded to 4 in triples calculations). Type: integer; Default: 20. CFOUR_ESTATE_PROP (CFOUR)¶CFOUR — This keyword applies only to EOM-CC calculations and specifies whether any excited or ionized state one-electron properties are to be calculated. Proper use of this keyword requires a relatively advanced knowledge of quantum chemistry and the available options are discussed here. The options are: OFF (=0) [no properties or transition moments are calculated]; EXPECTATION (=1) [transition moments and dipole strengths are calculated along with selected one-electron properties which are evaluated as expectation values]; UNRELAXED (=2) [selected one-electron properties are calculated in an approximation that neglects relaxation of molecular orbitals]; RESPONSE (=3) [selected one-electron properties are calculated as analytic first derivatives of the energy]. Except for EOMCC calculations on two-electron systems (which are exact), properties obtained by the three approaches will not be equivalent. The default value for this keyword is slightly complicated. For TDA calculations, the default is EXPECTATION since the evaluation of transition moments involves only a negligible amount of additional computation relative to the evaluation of the excitation energies. For EOMCC, the default is OFF since evaluation of any transition moments or properties requires approximately twice the computational time. Transition moments and dipole strengths are evaluated by default for all values of ESTATE_PROP other than OFF. Type: string; Possible Values: OFF, EXPECTATION, UNRELAXED, RESPONSE; Default: No Default. CFOUR_ES",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/autodoc_glossary_options_c-1.html:36424,energy,energy,36424,psi4manual/1.4.0/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodoc_glossary_options_c-1.html,9,['energy'],['energy']
Energy Efficiency,URRENT CORRELATION ENERGY; CURRENT ENERGY; CURRENT REFERENCE ENERGY; CUSTOM SCS-LCCD CORRELATION ENERGY; CUSTOM SCS-LCCD TOTAL ENERGY; CUSTOM SCS-MP2 CORRELATION ENERGY; CUSTOM SCS-MP2 TOTAL ENERGY; CUSTOM SCS-MP2.5 CORRELATION ENERGY; CUSTOM SCS-MP2.5 TOTAL ENERGY; CUSTOM SCS-MP3 CORRELATION ENERGY; CUSTOM SCS-MP3 TOTAL ENERGY; CUSTOM SCS-OLCCD CORRELATION ENERGY; CUSTOM SCS-OLCCD TOTAL ENERGY; CUSTOM SCS-OMP2 CORRELATION ENERGY; CUSTOM SCS-OMP2 TOTAL ENERGY; CUSTOM SCS-OMP3 CORRELATION ENERGY; CUSTOM SCS-OMP3 TOTAL ENERGY; CUSTOM SCS-OREMP2 CORRELATION ENERGY; CUSTOM SCS-OREMP2 TOTAL ENERGY; CUSTOM SCS-REMP2 CORRELATION ENERGY; CUSTOM SCS-REMP2 TOTAL ENERGY; LCCD CORRELATION ENERGY; LCCD DOUBLES ENERGY; LCCD OPPOSITE-SPIN CORRELATION ENERGY; LCCD SAME-SPIN CORRELATION ENERGY; LCCD SINGLES ENERGY; LCCD TOTAL ENERGY; MP2 CORRELATION ENERGY; MP2 DOUBLES ENERGY; MP2 OPPOSITE-SPIN CORRELATION ENERGY; MP2 SAME-SPIN CORRELATION ENERGY; MP2 SINGLES ENERGY; MP2 TOTAL ENERGY; MP2.5 CORRELATION ENERGY; MP2.5 DOUBLES ENERGY; MP2.5 OPPOSITE-SPIN CORRELATION ENERGY; MP2.5 SAME-SPIN CORRELATION ENERGY; MP2.5 SINGLES ENERGY; MP2.5 TOTAL ENERGY; MP3 CORRELATION ENERGY; MP3 DOUBLES ENERGY; MP3 OPPOSITE-SPIN CORRELATION ENERGY; MP3 SAME-SPIN CORRELATION ENERGY; MP3 SINGLES ENERGY; MP3 TOTAL ENERGY; OLCCD CORRELATION ENERGY; OLCCD OPPOSITE-SPIN CORRELATION ENERGY; OLCCD REFERENCE CORRECTION ENERGY; OLCCD SAME-SPIN CORRELATION ENERGY; OLCCD TOTAL ENERGY; OMP2 CORRELATION ENERGY; OMP2 OPPOSITE-SPIN CORRELATION ENERGY; OMP2 REFERENCE CORRECTION ENERGY; OMP2 SAME-SPIN CORRELATION ENERGY; OMP2 TOTAL ENERGY; OMP2.5 CORRELATION ENERGY; OMP2.5 OPPOSITE-SPIN CORRELATION ENERGY; OMP2.5 REFERENCE CORRECTION ENERGY; OMP2.5 SAME-SPIN CORRELATION ENERGY; OMP2.5 TOTAL ENERGY; OMP3 CORRELATION ENERGY; OMP3 OPPOSITE-SPIN CORRELATION ENERGY; OMP3 REFERENCE CORRECTION ENERGY; OMP3 SAME-SPIN CORRELATION ENERGY; OMP3 TOTAL ENERGY; OREMP2 CORRELATION ENERGY; OREMP2 OPPOSITE-SPIN CORRELATION ENERGY; OREMP2,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/autodir_psivariables/module__occ.html:1212,ENERGY,ENERGY,1212,psi4manual/1.7.x/autodir_psivariables/module__occ.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/autodir_psivariables/module__occ.html,4,['ENERGY'],['ENERGY']
Energy Efficiency,"US for; the energy computation. Evaluation of the analytic gradients requires the solution of the; coupled response equations. Two algorithms are available for their iterative; solution: two-step (default) and simultaneous. These algorithms are similar to those; described for the orbital and cumulant updates in the Iterative Algorithms; section and usually exhibit the similar efficiency. The choice of the algorithm can; be made using the RESPONSE_ALGORITHM option. For the DC-12 method the; analytic gradients are not yet available, one has to use numerical gradients to; perform the geometry optimizations. Minimal Input¶; Minimal input for the DCFT single-point computation looks like this:; molecule {; H; H 1 1.0; }. set basis 3-21G. energy('dcft'). The energy('dcft') call to energy() executes the DCFT module, which will first call the SCF module and perform the SCF computation with UHF reference to obtain the guess for the DCFT orbitals. After the SCF is converged, the program will perform the energy computation using the DC-06 method. By default, the two-step algorithm will be used for the solution of the equations. Note that while the default value for the option REFERENCE is RHF, this option is set to UHF before the DCFT module is executed. For the DC-06 method one can also request to perform the geometry optimization following the example below:; molecule {; H; H 1 1.0; }. set basis 3-21G. optimize('dcft'). The optimize('dcft') call will first perform all of the procedures; described above to obtain the DC-06 energy. After that the DC-06 analytic; gradients code will be executed to perform the solution of the DCFT response; equations, compute the analytic gradients of the DCFT energy and perform the; geometry optimization. Recommendations¶; Here is the list of the recommendations for the DCFT module:. For the computations of small systems (less than 150 basis; functions and high symmetry) the use of the default parameters is recommended,; including the choice of ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/dcft-1.html:10278,energy,energy,10278,psi4manual/4.0b5/dcft-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/dcft-1.html,2,['energy'],['energy']
Energy Efficiency,"Unrestricted (UHF); Restricted Open (ROHF). energy(); gradient()[3]; energy(); gradient()[3]; energy(); gradient()[3]. CV; DF; CD; CV; DF; CD; CV; DF; CD; CV; DF; CD; CV; DF; CD; CV; DF; CD. A; F; A; F; A; F; A; F; A; F; A; F; A; F; A; F; A; F; A; F; A; F; A; F; A; F; A; F; A; F; A; F; A; F; A; F. mp2[4]; MP2_TYPE. ✓̳; ✓̳. ✓̳; ✓̳. ✓̳; ✓̳. ✓̳; ✓̳. [1]; Algorithm type selection keyword below. Values to the right: conventional CV, density-fitted DF, and Cholesky-decomposed CD. [2]; Active orbital values to the right: all-electron A and frozen-core F. [3]; (1,2,3); Finite difference gradients are not marked explicitly by “∷”, but the capability can be gleaned from the energy availability. [4]; Also available for DFT references RKS/UKS. An example utilization of the code is:; molecule h2o {; 0 1; O; H 1 1.0; H 1 1.0 2 104.5; }. set basis cc-pvdz; set scf_type df; set freeze_core True. energy('mp2'). The energy('mp2') call to energy() executes; the predefined DF-MP2 procedure, first calling; the SCF module with a default RHF reference and DF algorithm for the; two-electron integrals. When the orbitals are converged, the DF-MP2 module is; launched, which forms the density-fitted \((Q|ov)\) integrals and then builds the; full \((ov|ov)\) tensor in blocks, evaluating the contributions to the MP2 energy; as it goes. A RHF-MP2 wavefunction is selected automatically due to the RHF; reference. In this example, we freeze the core, both for efficiency and; because split-valence bases like cc-pVDZ do not contain core correlation; functions. The result looks something like:; -----------------------------------------------------------; ==================> DF-MP2 Energies <====================; -----------------------------------------------------------; Reference Energy = -76.0213974638823942 [Eh]; Singles Energy = -0.0000000000000001 [Eh]; Same-Spin Energy = -0.0512503270216563 [Eh]; Opposite-Spin Energy = -0.1534098175176923 [Eh]; Correlation Energy = -0.2046601445393486 [Eh]; Total",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/dfmp2.html:3377,energy,energy,3377,psi4manual/1.7.x/dfmp2.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/dfmp2.html,8,['energy'],['energy']
Energy Efficiency,"Using the polarizable continuum model¶; The inclusion of a PCM description of the solvent into your calculation; can be achieved in two ways in PSI4, using either the PCMSolver or ddx package.; PCMSolver is based on a boundary-element discretisation [Cances:1998:309],; while ddx is based on a domain decomposition approach; [Cances:2013:054111] making it linear scaling.; For more details about ddx see the section on ddx.; Using PCMsolver is achieved instead by setting PCM true in your input file.; PSI4 understands the additional option PCM_SCF_TYPE with possible values total; (the default) or separate.; The latter forces the separate handling of nuclear and electronic electrostatic potentials and; polarization charges. It is mainly useful for debugging.; For the calculation of vertical excitation energies with PCM non-equilibrium solvation should be included with:; pcm = {; Medium {; Nonequilibrium = True; }; }. Note; At present PCM can only be used for energy calculations with SCF; wavefunctions and CC wavefunctions in the PTE approximation [Cammi:2009:164104].; All ERI algorithms (PK, OUT_OF_CORE, DIRECT, DF, CD) are supported. Note; linear response calculations (static polarisabilities, TD-SCF) are supported for RHF/UHF if available. Warning; The PCMSolver library cannot exploit molecular point group symmetry. Warning; ROHF with PCM is known not to work. See issue #999 on GitHub.; For the adventurous, a fix is available in pull request #953 on GitHub. Warning; Analytic gradients and Hessians are not available with PCM. Finite differences will be used; regardless of the dertype passed to the optimize function.; See pcmsolver/opt-fd for a sample input. The PCM model and molecular cavity are specified in a pcm section that has; to be explicitly typed in by the user. This additional section follows a syntax; that is slightly different from that of PSI4 and is fully documented; here; A typical input for a Hartree–Fock calculation with PCM would look like the following:;",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/pcmsolver.html:2512,energy,energy,2512,psi4manual/1.7.x/pcmsolver.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/pcmsolver.html,4,['energy'],['energy']
Energy Efficiency,"V. fno-aqcc; aqcc with frozen natural orbitals; CC_TYPE CONV. fno-cisd; cisd with frozen natural orbitals; CI_TYPE CONV. Basic FNOCC Keywords¶. BASIS¶. Primary basis set. Available basis sets. Type: string; Possible Values: basis string; Default: No Default. FREEZE_CORE¶. Specifies how many core orbitals to freeze in correlated computations. TRUE or 1 will default to freezing the previous noble gas shell on each atom. In case of positive charges on fragments, an additional shell may be unfrozen, to ensure there are valence electrons in each fragment. With FALSE or 0, no electrons are frozen (with the exception of electrons treated by an ECP). With -1, -2, and -3, the user might request strict freezing of the previous first/second/third noble gas shell on every atom. In this case, when there are no valence electrons, the code raises an exception. More precise control over the number of frozen orbitals can be attained by using the keywords NUM_FROZEN_DOCC (gives the total number of orbitals to freeze, program picks the lowest-energy orbitals) or FROZEN_DOCC (gives the number of orbitals to freeze per irreducible representation). Type: string; Possible Values: FALSE, TRUE, 1, 0, -1, -2, -3; Default: FALSE. R_CONVERGENCE¶. Convergence for the CC amplitudes. Note that convergence is met only when E_CONVERGENCE and R_CONVERGENCE are satisfied. Type: conv double; Default: 1.0e-7. E_CONVERGENCE¶. Convergence criterion for CC energy. See Table Post-SCF Convergence for default convergence criteria for different calculation types. Note that convergence is met only when E_CONVERGENCE and R_CONVERGENCE are satisfied. Type: conv double; Default: 1.0e-6. MAXITER¶. Maximum number of CC iterations. Type: integer; Default: 100. DIIS_MAX_VECS¶. Desired number of DIIS vectors. Type: integer; Default: 8. NAT_ORBS¶. Do use MP2 NOs to truncate virtual space for QCISD/CCSD and (T)?. Type: boolean; Default: false. OCC_TOLERANCE¶. Cutoff for occupation of MP2 virtual NOs in FNO-QCISD/CCSD(T).",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/fnocc-1.html:15760,energy,energy,15760,psi4manual/1.3.2/fnocc-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/fnocc-1.html,7,['energy'],['energy']
Energy Efficiency,"VDZ basis set. This is just a test of the code and the user need only specify guess=sad to the SCF module’s (or global) options in order to use a SAD guess. The test is first performed in C2v symmetry, and then in C1. cc51; EOM-CC3/cc-pVTZ on H2O. pywrap-checkrun-rhf; This checks that all energy methods can run with a minimal input and set symmetry. sapt4; SAPT2+(3) aug-cc-pVDZ computation of the formamide dimer interaction energy, using the aug-cc-pVDZ-JKFIT DF basis for SCF and aug-cc-pVDZ-RI for SAPT. This example uses frozen core as well as MP2 natural orbital approximations. dforemp-grad2; density fitted OO-REMP/cc-pVDZ engrad single points for the H2O+ molecule. cc43; RHF-CC2-LR/STO-3G optical rotation of (S)-methyloxirane. gauge = both, omega = (589 355 nm). mints2-bse; Similar to mints2, but using the BSE to specify the basis sets. fnocc1; Test QCISD(T) for H2O/cc-pvdz Energy. sapt0-d; Tests SAPT0-D corrections, with a variety of damping functions/parameters. cc37; CC2(UHF)/cc-pVDZ energy of H2O+. nbo; Generation of NBO file. omp2-4; SCS-OMP2 cc-pVDZ geometry optimization for the H2O molecule. dfccsd-t-grad2; DF-CCSD(T) cc-pVDZ gradient for the NH molecule. dlpnomp2-1; comparison of DF-MP2 and DLPNO-MP2. cc11; Frozen-core CCSD(ROHF)/cc-pVDZ on CN radical with disk-based AO algorithm. cubeprop-frontier; ROHF frontier orbitals of CH2(s) and CH2(t). omp3-3; OMP3 cc-pCVDZ energy with B3LYP initial guess for the NO radical. freq-isotope1; Vibrational and thermo analysis of several water isotopologs. Demonstrates Hessian reuse for different temperatures and pressures but not for different isotopologs. cc26; Single-point gradient, analytic and via finite-differences of 2-1A1 state of H2O with EOM-CCSD. dct6; DCT calculation for the triplet O2 using DC-06 and DC-12. Only two-step algorithm is tested. fsapt-d; Tests SAPT0-D corrections, with a variety of damping functions/parameters. density-screen-2; RKS Density Matrix based-Integral Screening Test for benzene. cc28;",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/autodoc_testsuite_corepsi4.html:28880,energy,energy,28880,psi4manual/1.9.x/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/autodoc_testsuite_corepsi4.html,2,['energy'],['energy']
Energy Efficiency,"VDZ energies for the H2O+ molecule. results were independently verified against the initial wavels implementation. props2; DF-SCF cc-pVDZ of benzene-hydronium ion, scanning the dissociation coordinate with Python’s built-in loop mechanism. The geometry is specified by a Z-matrix with dummy atoms, fixed parameters, updated parameters, and separate charge/multiplicity specifiers for each monomer. One-electron properties computed for dimer and one monomer. olccd-freq1; OLCCD cc-pVDZ freqs for C2H2. mp2-grad2; MP2 cc-pVDZ gradient for the NO radical. scf-guess-read1; Sample UHF/cc-pVDZ H2O computation on a doublet cation, using RHF/cc-pVDZ orbitals for the closed-shell neutral as a guess. cepa-module; routing check on lccd, lccsd, cepa(0). scf4; RHF cc-pVDZ energy for water, automatically scanning the symmetric stretch and bending coordinates using Python’s built-in loop mechanisms. The geometry is specified using a Z-matrix with variables that are updated during the potential energy surface scan, and then the same procedure is performed using polar coordinates, converted to Cartesian coordinates. dfccdl1; DF-CCDL cc-pVDZ energy for the H2O molecule. cc13b; Tests RHF CCSD(T)gradients. nbody-hessian; Computation of VMFC-corrected HF dimer Hessian. sapt-compare; SAPT0 aug-cc-pVDZ computation of the water-water interaction energy, using the three SAPT codes. sapt-exch-ind30-inf; SAPT2+3 with S^inf exch-ind30 Geometries taken from the S66x10 database, the shortest-range point (R = 0.7 R_e). pywrap-molecule; Check that C++ Molecule class and qcdb molecule class are reading molecule input strings identically. dft-dens-cut; LibXC density screening test. Tests empty, C-only, X-only and XC superfunctionals. ‘super_mix’ showcases how to use different screening values for X and C parts. SCF will fail or crash (nans) without screening!. fd-freq-gradient; SCF STO-3G finite-differences frequencies from gradients for H2O. castup2; SCF with various combinations of pk/density-fitting, ca",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/autodoc_testsuite_corepsi4.html:29341,energy,energy,29341,psi4manual/1.7.x/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/autodoc_testsuite_corepsi4.html,2,['energy'],['energy']
Energy Efficiency,"VDZ energy for the \(^2\Sigma^+\) state of the CN radical. olccd3; OLCCD cc-pVDZ energy with ROHF initial guess for the NO radical. pywrap-freq-e-sowreap; Finite difference of energies frequency, run in sow/reap mode. dfmp2-3; DF-MP2 cc-pVDZ frozen core gradient of benzene, computed at the DF-SCF cc-pVDZ geometry. cepa2; cc-pvdz H2O Test ACPF Energy/Properties. cc34; RHF-CCSD/cc-pVDZ energy of H2O partitioned into pair energy contributions. mints8; Patch of a glycine with a methyl group, to make alanine, then DF-SCF energy calculation with the cc-pVDZ basis set. psimrcc-sp1; Mk-MRCCSD single point. \(^3 \Sigma ^-\) O2 state described using the Ms = 0 component of the triplet. Uses ROHF triplet orbitals. density-screen-1; RHF Density Matrix based-Integral Screening Test for water. fnocc7; Test fnocc with linear dependencies. sapt5; SAPT0 aug-cc-pVTZ computation of the charge transfer energy of the water dimer. fsapt-ext-abc; FSAPT with external charge on trimer. isapt1; This test case shows an example of running and analyzing an FI-SAPT0/jun-cc-pvdz computation for 2,4-pentanediol (targeting the intramolecular hydrogen bond between the two hydroxyl groups). mints2; A test of the basis specification. A benzene atom is defined using a ZMatrix containing dummy atoms and various basis sets are assigned to different atoms. The symmetry of the molecule is automatically lowered to account for the different basis sets. olccd-grad1; OLCCD cc-pVDZ gradient for the H2O molecule. scf-level-shift-uhf; SCF level shift on a UHF computation. pywrap-checkrun-rhf; This checks that all energy methods can run with a minimal input and set symmetry. omp3-2; OMP3 cc-pCVDZ energy with ROHF initial guess for the NO radical. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Appendices; Test Suite and Sample Inputs; <no title>. © Copyright 2022, The Psi4 Project.; Last updated on Thursday, 19 May 2022 08:57PM.; Created using Sphinx 4.5.0.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/autodoc_testsuite_corepsi4.html:46628,energy,energy,46628,psi4manual/1.6.x/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/autodoc_testsuite_corepsi4.html,2,['energy'],['energy']
Energy Efficiency,"VDZ energy('mp2'); >>> cbs(name='mp2', corl_basis='jun-cc-pVDZ'). >>> # [3] DTQ-zeta extrapolated scf reference energy; >>> cbs(name='scf', scf_basis='cc-pV[DTQ]Z', scf_scheme=scf_xtpl_helgaker_3). >>> # [4] DT-zeta extrapolated mp2 correlation energy atop a T-zeta reference; >>> cbs(corl_wfn='mp2', corl_basis='cc-pv[dt]z', corl_scheme=corl_xtpl_helgaker_2). >>> # [5] a DT-zeta extrapolated coupled-cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference (both equivalent); >>> cbs(corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z'); >>> cbs(energy, wfn='mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z', delta_scheme=corl_xtpl_helgaker_2). >>> # [6] a D-zeta ccsd(t) correction atop a DT-zeta extrapolated ccsd cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference; >>> cbs(name='mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd', delta_basis='aug-cc-pv[dt]z', delta_scheme=corl_xtpl_helgaker_2, delta2_wfn='ccsd(t)', delta2_wfn_lesser='ccsd', delta2_basis='aug-cc-pvdz'). >>> # [7] cbs() coupled with database(); >>> TODO database('mp2', 'BASIC', subset=['h2o','nh3'], symm='on', func=cbs, corl_basis='cc-pV[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd(t)', delta_basis='sto-3g'). >>> # [8] cbs() coupled with optimize(); >>> TODO optimize('mp2', corl_basis='cc-pV[DT]Z', corl_scheme=corl_xtpl_helgaker_2, func=cbs). """"""; kwargs = p4util.kwargs_lower(kwargs); return_wfn = kwargs.pop('return_wfn', False); verbose = kwargs.pop('verbose', 0); ptype = kwargs.pop('ptype'). # Establish function to call (only energy makes sense for cbs); if ptype not in ['energy', 'gradient', 'hessian']:; raise ValidationError(""""""Wrapper complete_basis_set is unhappy to be calling function '%s' instead of 'energy'."""""" % ptype). optstash = p4util.OptionsState(; ['BASIS'],",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html:29052,energy,energy,29052,psi4manual/1.0.0/_modules/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html,2,['energy'],['energy']
Energy Efficiency,"VDZ energy('mp2'); >>> cbs(name='mp2', corl_basis='jun-cc-pVDZ'). >>> # [3] DTQ-zeta extrapolated scf reference energy; >>> cbs(name='scf', scf_basis='cc-pV[DTQ]Z', scf_scheme=scf_xtpl_helgaker_3). >>> # [4] DT-zeta extrapolated mp2 correlation energy atop a T-zeta reference; >>> cbs(corl_wfn='mp2', corl_basis='cc-pv[dt]z', corl_scheme=corl_xtpl_helgaker_2). >>> # [5] a DT-zeta extrapolated coupled-cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference (both equivalent); >>> cbs(corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z'); >>> cbs(energy, wfn='mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z', delta_scheme=corl_xtpl_helgaker_2). >>> # [6] a D-zeta ccsd(t) correction atop a DT-zeta extrapolated ccsd cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference; >>> cbs(name='mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd', delta_basis='aug-cc-pv[dt]z', delta_scheme=corl_xtpl_helgaker_2, delta2_wfn='ccsd(t)', delta2_wfn_lesser='ccsd', delta2_basis='aug-cc-pvdz'). >>> # [7] cbs() coupled with database(); >>> TODO database('mp2', 'BASIC', subset=['h2o','nh3'], symm='on', func=cbs, corl_basis='cc-pV[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd(t)', delta_basis='sto-3g'). >>> # [8] cbs() coupled with optimize(); >>> TODO optimize('mp2', corl_basis='cc-pV[DT]Z', corl_scheme=corl_xtpl_helgaker_2, func=cbs). """"""; kwargs = p4util.kwargs_lower(kwargs); return_wfn = kwargs.pop('return_wfn', False); verbose = kwargs.pop('verbose', 0); ptype = kwargs.pop('ptype'); cbs_alpha = {; 'scf': kwargs.get('cbs_scf_alpha', kwargs.get('scf_alpha', None)),; 'corl': kwargs.get('cbs_corl_alpha', kwargs.get('corl_alpha', None)),; 'delta': kwargs.get('cbs_delta_alpha', kwargs.get('delta_alpha', None)),; 'delta2': kwargs.get('cbs_delta2_alpha', kwargs.get('del",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/driver_cbs.html:37108,energy,energy,37108,psi4manual/1.2.1/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/driver_cbs.html,1,['energy'],['energy']
Energy Efficiency,"VDZ energy('mp2'); >>> cbs(name='mp2', corl_basis='jun-cc-pVDZ'). >>> # [3] DTQ-zeta extrapolated scf reference energy; >>> cbs(name='scf', scf_basis='cc-pV[DTQ]Z', scf_scheme=scf_xtpl_helgaker_3). >>> # [4] DT-zeta extrapolated mp2 correlation energy atop a T-zeta reference; >>> cbs(corl_wfn='mp2', corl_basis='cc-pv[dt]z', corl_scheme=corl_xtpl_helgaker_2). >>> # [5] a DT-zeta extrapolated coupled-cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference (both equivalent); >>> cbs(corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z'); >>> cbs(energy, wfn='mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z', delta_scheme=corl_xtpl_helgaker_2). >>> # [6] a D-zeta ccsd(t) correction atop a DT-zeta extrapolated ccsd cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference; >>> cbs(name='mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd', delta_basis='aug-cc-pv[dt]z', delta_scheme=corl_xtpl_helgaker_2, delta2_wfn='ccsd(t)', delta2_wfn_lesser='ccsd', delta2_basis='aug-cc-pvdz'). >>> # [7] cbs() coupled with database(); >>> TODO database('mp2', 'BASIC', subset=['h2o','nh3'], symm='on', func=cbs, corl_basis='cc-pV[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd(t)', delta_basis='sto-3g'). >>> # [8] cbs() coupled with optimize(); >>> TODO optimize('mp2', corl_basis='cc-pV[DT]Z', corl_scheme=corl_xtpl_helgaker_2, func=cbs). Note; Presently (May 2016), only two of the five delta possibilities are active. Also, temporarily extrapolations are performed on differences of target and scf total energies, rather than on correlation energies directly. This doesn’t affect the extrapolated values of the particular formulas defined here (though it does affect the betas, which are commented out), but it is sloppy and temporary and could affect any user-defined corl e",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/cbs-1.html:10613,energy,energy,10613,psi4manual/1.0.0/cbs-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/cbs-1.html,2,['energy'],['energy']
Energy Efficiency,"VDZ frozen core gradient of benzene, computed at the DF-SCF cc-pVDZ geometry. cdomp2-1; OMP2 cc-pVDZ energy for the H2O molecule. fsapt-diff1; This test case shows an example of running and analyzing a difference F-SAPT0/jun-cc-pvdz procedure for phenol dimer from the S22 database. cc13a; UHF-CCSD(T)/cc-pVDZ \(^{3}B_1\) CH2 geometry optimization via analytic gradients. cbs-xtpl-alpha; Extrapolated water energies. cc8c; ROHF-CCSD cc-pVDZ frozen-core energy for the \(^2\Sigma^+\) state of the CN radical, with Cartesian input. props1; RHF STO-3G dipole moment computation, performed by applying a finite electric field and numerical differentiation. cc45; RHF-EOM-CC2/cc-pVDZ lowest two states of each symmetry of H2O. soscf-large; Second-order SCF convergnece: Benzene. fnocc4; Test FNO-DF-CCSD(T) energy. tu3-h2o-opt; Optimize H2O HF/cc-pVDZ. cc9; UHF-CCSD(T) cc-pVDZ frozen-core energy for the \(^2\Sigma^+\) state of the CN radical, with Z-matrix input. mcscf3; RHF 6-31G** energy of water, using the MCSCF module and Z-matrix input. mints2; A test of the basis specification. A benzene atom is defined using a ZMatrix containing dummy atoms and various basis sets are assigned to different atoms. The symmetry of the molecule is automatically lowered to account for the different basis sets. dcft8; DCFT calculation for the NH3+ radical using the ODC-12 and ODC-13 functionals. This performs both simultaneous and QC update of the orbitals and cumulant using DIIS extrapolation. Four-virtual integrals are first handled in the MO Basis for the first two energy computations. In the next computation ao_basis=disk algorithm is used, where the transformation of integrals for four-virtual case is avoided. cc12; Single point energies of multiple excited states with EOM-CCSD. dft2; DFT Functional Test. cc8b; ROHF-CCSD cc-pVDZ frozen-core energy for the \(^2\Sigma^+\) state of the CN radical, with Cartesian input. pywrap-molecule; Check that C++ Molecule class and qcdb molecule class are rea",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/autodoc_testsuite_corepsi4-1.html:30704,energy,energy,30704,psi4manual/1.2.1/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/autodoc_testsuite_corepsi4-1.html,4,['energy'],['energy']
Energy Efficiency,"VDZ gradient for the H2O molecule. scf-ecp; Water-Argon complex with ECP present; check of energies and forces. linK-2; RKS Linear Exchange Algorithm test for benzene. sapt-dft1; SAPT(DFT) aug-cc-pVDZ interaction energy between Ne and Ar atoms. ao-dfcasscf-sp; CASSCF/6-31G** energy point. cbs-parser; mtd/basis syntax examples. dlpnomp2-3; comparison of DF-MP2 and DLPNO-MP2 with a cartesian basis set. fisapt-siao1; This test case shows an example of running the I-SAPT0/jun-cc-pVDZ computation for 2,4-pentanediol (targeting the intramolecular hydrogen bond between the two hydroxyl groups) The SIAO1 link partitioning algorithm is used. An F-SAPT partitioning follows I-SAPT. omp2-2; OMP2 cc-pVDZ energy with ROHF initial guess orbitals for the NO radical. dft-jk; DFT JK on-disk test. cubeprop-esp; RHF orbitals and density for water. cbs-delta-energy; Extrapolated energies with delta correction. dfcasscf-sp; CASSCF/6-31G** energy point. cc9; UHF-CCSD(T) cc-pVDZ frozen-core energy for the \(^2\Sigma^+\) state of the CN radical, with Z-matrix input. dfccd-grad1; DF-CCSD cc-pVDZ gradients for the H2O molecule. fsapt-d; Tests SAPT0-D corrections, with a variety of damping functions/parameters. dforemp-grad1; density fitted OO-REMP/cc-pVDZ engrad single points for the H2O molecule. scf-hess4; DF SCF 6-31G UHFl vs RHF test Tests DF UHF hessian code for Ca = Cb. dft-vv10; He Dimer VV10 functional test. notes: DFT_VV10_B/C overwrites the NL_DISPERSION_PARAMETERS tuple updated ‘bench’ reference values for new BraggSlater radii. dct-grad4; Unrestricted DF-DCT ODC-12 gradient for O2 with cc-pVTZ/cc-pVTZ-RI standard/auxiliary basis set. dfomp3-grad2; DF-OMP3 cc-pVDZ gradients for the H2O+ cation. cc12; Single point energies of multiple excited states with EOM-CCSD. fnocc1; Test QCISD(T) for H2O/cc-pvdz Energy. dfmp2-grad3; DF-MP2 cc-pVDZ gradients for the H2O molecule. scf-ecp2; Water-Argon complex with ECP present; check of RHF Hessian. explicit-am-basis; Check that basis sets can be",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/autodoc_testsuite_corepsi4.html:31841,energy,energy,31841,psi4manual/master/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/master/autodoc_testsuite_corepsi4.html,2,['energy'],['energy']
Energy Efficiency,"VDZ optical rotation calculation (both gauges) on Cartesian H2O2. fsapt-ext-abc-au; analog of fsapt-ext-abc with molecule and external potentials in Bohr. dfomp2-4; OMP2 cc-pVDZ energy for the NO molecule. fci-h2o; 6-31G H2O Test FCI Energy Point. mp2-grad1; MP2 cc-pVDZ gradient for the H2O molecule. cepa1; cc-pvdz H2O Test CEPA(1) Energy. ao-casscf-sp; CASSCF/6-31G** energy point. dft-custom-gga; DFT (LDA/GGA) test of custom implementations in: gga_superfuncs.py. cbs-xtpl-opt; Various extrapolated optimization methods for the H2 molecule. tdscf-6; td-camb3lyp with DiskDF and method/basis specification. cubeprop; RHF orbitals and density for water. omp3-2; OMP3 cc-pCVDZ energy with ROHF initial guess for the NO radical. x2c1; Test of SFX2C-1e on water uncontracted cc-pVDZ-DK The reference numbers are from Lan Cheng’s implementation in Cfour. pywrap-alias; Test parsed and exotic calls to energy() like zapt4, mp2.5, and cisd are working. cc9a; ROHF-CCSD(T) cc-pVDZ energy for the \(^2\Sigma^+\) state of the CN radical, with Z-matrix input. nbody-cp-gradient; Computation of CP-corrected water trimer gradient (geometry from J. Chem. Theory Comput. 11, 2126-2136 (2015)). cc5; RHF CCSD(T) cc-pVDZ frozen-core energy of C4NH4 Anion. extern1; External potential calculation involving a TIP3P water and a QM water. Finite different test of the gradient is performed to validate forces. scf-level-shift-uhf; SCF level shift on a UHF computation. rasci-c2-active; 6-31G* C2 Test RASCI Energy Point, testing two different ways of specifying the active space, either with the ACTIVE keyword, or with RAS1, RAS2, RESTRICTED_DOCC, and RESTRICTED_UOCC. cc8c; ROHF-CCSD cc-pVDZ frozen-core energy for the \(^2\Sigma^+\) state of the CN radical, with Cartesian input. sapt-exch-ind-inf; SAPT(DFT) aug-cc-pVDZ interaction energy between Ne and Ar atoms. dft-grad1; DF-BP86-D2 cc-pVDZ frozen core gradient of S22 HCN update ref gradient due to new BraggSlater radii. cbs-parser; mtd/basis syntax example",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/autodoc_testsuite_corepsi4.html:13992,energy,energy,13992,psi4manual/1.7.x/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/autodoc_testsuite_corepsi4.html,2,['energy'],['energy']
Energy Efficiency,"VDZ optimization example with frozen cartesian. cc27; Single point gradient of 1-1B2 state of H2O with EOM-CCSD. mpn-bh; MP(n)/aug-cc-pVDZ BH Energy Point, with n=2-19. Compare against M. L. Leininger et al., J. Chem. Phys. 112, 9213 (2000). sapt-sf1; Tests the Psi4 SF-SAPT code. cbs-delta-energy; Extrapolated energies with delta correction. omp2-5; SOS-OMP2 cc-pVDZ geometry optimization for the H2O molecule. scf-freq1; Analytic vs. finite difference DF-SCF frequency test for water. cc22; ROHF-EOM-CCSD/DZ on the lowest two states of each irrep in \(^{3}B_1\) CH2. cc14; ROHF-CCSD/cc-pVDZ \(^{3}B_1\) CH2 geometry optimization via analytic gradients. mp2-1; All-electron MP2 6-31G** geometry optimization of water. cepa1; cc-pvdz H2O Test CEPA(1) Energy. casscf-fzc-sp; CASSCF/6-31G** energy point. extern2; External potential calculation involving a TIP3P water and a QM water for DFMP2. Finite different test of the gradient is performed to validate forces. opt9; Various constrained energy minimizations of HOOH with cc-pvdz RHF. Cartesian-coordinate constrained optimizations of HOOH in internals. cc9a; ROHF-CCSD(T) cc-pVDZ energy for the \(^2\Sigma^+\) state of the CN radical, with Z-matrix input. mints1; Symmetry tests for a range of molecules. This doesn’t actually compute any energies, but serves as an example of the many ways to specify geometries in Psi4. dfmp2-grad5; Tests DF-MP2 gradient in the presence of a dipole field. pywrap-db3; Test that Python Molecule class processes geometry like psi4 Molecule class. fcidump; test FCIDUMP functionality for rhf/uhf. cc16; ROHF and UHF-B-CCD(T)/cc-pVDZ \(^{3}B_1\) CH2 single-point energy (fzc, MO-basis \(\langle ab|cd \rangle\) ). fci-h2o; 6-31G H2O Test FCI Energy Point. ocepa1; OCEPA cc-pVDZ energy for the H2O molecule. dft-custom-gga; DFT (LDA/GGA) test of custom implementations in: gga_superfuncs.py. opt-multi-dimer-c2h; Multi-fragment opt of C2h methane dimer with user-combined reference points. fd-freq-energy; SCF STO-3G",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/autodoc_testsuite_corepsi4-1.html:18243,energy,energy,18243,psi4manual/1.2.1/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/autodoc_testsuite_corepsi4-1.html,4,['energy'],['energy']
Energy Efficiency,"VDZ-RI DF basis for SAPT0 induction and dispersion, and the aug-pVDZ-JKFIT DF basis for SAPT0 electrostatics and induction. This example uses frozen core as well as asyncronous I/O while forming the DF integrals and CPHF coefficients. cc19; CCSD/cc-pVDZ dipole polarizability at two frequencies. cc4; RHF-CCSD(T) cc-pVQZ frozen-core energy of the BH molecule, with Cartesian input. After the computation, the checkpoint file is renamed, using the PSIO handler. cc10; ROHF-CCSD cc-pVDZ energy for the state of the CN radical. castup3; SCF with various combinations of pk/density-fitting, castup/no-castup, and spherical/cartesian settings. Demonstrates that puream setting is getting set by orbital basis for all df/castup parts of calc. Demonstrates that answer doesn’t depend on presence/absence of castup. Demonstrates (by comparison to castup2) that output file doesn’t depend on options (scf_type) being set global or local. This input uses local. cc8c; ROHF-CCSD cc-pVDZ frozen-core energy for the state of the CN radical, with Cartesian input. scf1; RHF cc-pVQZ energy for the BH molecule, with Cartesian input. cisd-h2o+-0; 6-31G** H2O+ Test CISD Energy Point. cc43; RHF-CC2-LR/STO-3G optical rotation of (S)-methyloxirane. gauge = both, omega = (589 355 nm). cc27; Single point gradient of 1-1B2 state of H2O with EOM-CCSD. cisd-sp-2; 6-31G** H2O Test CISD Energy Point. opt1; SCF STO-3G geometry optimzation, with Z-matrix input. dft2; DFT Functional Test. cc15; RHF-B-CCD(T)/6-31G** H2O single-point energy (fzc, MO-basis ). dft1; DFT Functional Test. cc18; RHF-CCSD-LR/cc-pVDZ static polarizability of HOF. mom; Maximum Overlap Method (MOM) Test. MOM is designed to stabilize SCF convergence and to target excited Slater determinants directly. fci-h2o-fzcv; 6-31G H2O Test FCI Energy Point. pywrap-cbs1; Various basis set extrapolation tests. fd-freq-energy; SCF STO-3G finite-difference frequencies from energies. dcft5; DCFT-06 calculation for the O2 molecule (triplet ground state). Thi",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/autodoc_testsuite-1.html:7933,energy,energy,7933,psi4manual/4.0b3/autodoc_testsuite-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodoc_testsuite-1.html,4,['energy'],['energy']
Energy Efficiency,"VDZ; set ccenergy print 3; set scf print 1; energy('ccsd'). the basis set is set to cc-pVDZ throughout, the SCF code will have a print; level of 1 and the ccenergy code, which performs coupled cluster computations,; will use a print level of 3. In this example a full CCSD computation is; performed by running the SCF code first, then the coupled cluster modules;; the energy() Python helper function ensures that this is performed correctly.; Note that the Python interpreter executes commands in the order they appear in; the input file, so if the last four commands in the above example were to read; set basis cc-pVDZ; energy('ccsd'); set ccenergy print 3; set scf print 1. the commands that set the print level would be ineffective, as they would be; processed after the CCSD computation completes. Basis Sets¶. Basis Sets; Built-In Basis Sets; Mixing Basis Sets; Decontracted Basis Sets; User-Defined Basis Sets. PSI Variables¶; To harness the power of Python, Psi4 makes the most pertinent results; of each computation available to the Python interpreter for; post-processing. To demonstrate, we can embellish the previous example of; H2 and H atom:; molecule h2 {; H; H 1 0.9; }. set basis cc-pvdz; set reference rhf; h2_energy = energy('scf'). molecule h {; H; }. set basis cc-pvdz; set reference uhf; h_energy = energy('scf'). D_e = psi_hartree2kcalmol * (2*h_energy - h2_energy); print ""De=%f"" % D_e. The energy() function returns the final result of the; computation, the requested total energy in Hartrees, which we assign to a; Python variable. The two energies are then converted to a dissociation; energy and printed to the output file using standard Python notation.; Generally, there are multiple quantities of interest. Appendix; PSI Variables by Module lists PSI variables variables set by each; module, and PSI Variables by Alpha defines them. These can be; accessed through the get_variable() function. For example, after; performing a density fitted MP2 computation, both the sp",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/psithoninput-1.html:7800,power,power,7800,psi4manual/1.0.0/psithoninput-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/psithoninput-1.html,2,['power'],['power']
Energy Efficiency,"VEL_SHIFT, and it is turned off when the DIIS error is; smaller than LEVEL_SHIFT_CUTOFF. Reasonable values for; the shift and convergence threshold are 5.0 and 1e-2,; respectively. SOSCF [Off by Default]See Second-order Convergence. ERI Algorithms¶; The key difficulty in the SCF procedure is treatment of the four-index ERI; contributions to the Fock Matrix. A number of algorithms are available in; PSI4 for these terms. The algorithm is selected by the SCF_TYPE; keyword. Most consist of a single algorithm applied to; the construction of both the Coulomb and Exchange parts; of the Fock Matrix:. PK [Default]An out-of-core, presorted algorithm using exact ERIs. Quite fast for a; zero-error algorithm if enough memory is available. Integrals are; generated only once, and symmetry is utilized to reduce number of; integrals. OUT_OF_COREAn out-of-core, unsorted algorithm using exact ERIs. Overcomes the; memory bottleneck of the current PK algorithm. Integrals are generated; only once, and symmetry is utilized to reduce number of integrals. DIRECTA threaded, sieved, integral-direct algorithm, with full permutational; symmetry. This algorithm is brand new, but seems to be reasonably fast; up to 1500 basis functions, uses zero disk (if DF pre-iterations are; turned off), and can obtain significant; speedups with negligible error loss if INTS_TOLERANCE; is set to 1.0E-8 or so. DF [Default]A density-fitted algorithm designed for computations with thousands of; basis functions. This algorithm is highly optimized, and is threaded; with a mixture of parallel BLAS and OpenMP. Note that this algorithm; should use the -JKFIT series of auxiliary bases, not the -RI or; -MP2FIT bases. The default guess for auxiliary basis set should work; for most bases, otherwise the DF_BASIS_SCF keyword can; be used to manually specify the auxiliary basis. This algorithm is; preferred unless either absolute accuracy is required; [\(\gtrsim\)CCSD(T)] or a -JKFIT auxiliary basis is unavailable; for the or",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/scf.html:26109,reduce,reduce,26109,psi4manual/1.8.x/scf.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/scf.html,3,['reduce'],['reduce']
Energy Efficiency,"VEL¶. Specifies whether or not energy derivatives are to be calculated and if so whether first or second derivatives are computed. ZERO (= 0) derivatives are not calculated, FIRST (=1) first derivatives are calculated, SECOND (=2) second derivatives are calculated. Note that this keyword usually needs not be set in any calculation since it is automatically set if the appropriate other options in the CFOUR namelist are turned on. Psi4 Interface: Keyword set from type of computation command: ZERO if energy(), FIRST if gradient() or optimize(), etc. Type: string; Possible Values: ZERO, FIRST, SECOND; Default: ZERO. CFOUR_DIFF_TYPE¶. Specifies whether orbital-relaxed (RELAXED =0) or orbital-unrelaxed (UNRELAXED =1) derivatives are computed in the CC calculation. Type: string; Possible Values: RELAXED, UNRELAXED; Default: RELAXED. CFOUR_DROPMO¶. Specifies which molecular orbitals will be dropped from the post-SCF calculation. The orbitals are numbered in ascending order from the most stable (negative energy) to the most unstable (largest positive energy). Individual orbitals must be separated with a dash, while x>y means orbitals x through y inclusive. For example, the string 1>10-55-58>64, would result in orbitals 1,2,3,4,5,6,7,8,9,10,55,58,59,60,61,62,63 and 64 being dropped. For UHF calculations, the appropriate orbitals are deleted for both spin cases. No dropped virtual MOs are currently allowed for gradient or property calculations. Psi4 Interface: The array above is specified in PSI as (white space tolerant) [1,2,3,4,5,6,7,8,9,10,55,58,59,60,61,62,63,64]. Type: array; Default: No Default. CFOUR_ECP¶. Specifies whether effective core potentials (pseudopotentials) are used (ON, =1) or not (OFF, =0). Type: boolean; Default: false. CFOUR_EIGENVECTOR¶. Specifies which eigenvector of the totally symmetric part of the block-factored Hessian is to be followed uphill in a transition state search. Eigenvectors are indexed by their eigenvalues – the lowest eigenvalue is 1, t",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/autodir_options_c/module__cfour-1.html:15081,energy,energy,15081,psi4manual/1.4.0/autodir_options_c/module__cfour-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/module__cfour-1.html,36,['energy'],['energy']
Energy Efficiency,"VTZ on H2O. opt12; SCF cc-pVDZ geometry optimzation of ketene, starting from bent structure. scf-ecp; Water-Argon complex with ECP present; check of energies and forces. molden1; Test of the superposition of atomic densities (SAD) guess, using a highly distorted water geometry with a cc-pVDZ basis set. This is just a test of the code and the user need only specify guess=sad to the SCF module’s (or global) options in order to use a SAD guess. The test is first performed in C2v symmetry, and then in C1. psimrcc-ccsd_t-3; Mk-MRCCSD(T) single point. \(^1A_1\) CH2 state described using the Ms = 0 component of the singlet. Uses RHF singlet orbitals. cc5; RHF CCSD(T) aug-cc-pvtz frozen-core energy of C4NH4 Anion. mints8; Patch of a glycine with a methyl group, to make alanine, then DF-SCF energy calculation with the cc-pVDZ basis set. psimrcc-fd-freq2; Mk-MRCCSD frequencies. \(^1A_1\) O$_3` state described using the Ms = 0 component of the singlet. Uses TCSCF orbitals. dft-grad2; DF-BP86-D2 cc-pVDZ frozen core gradient of S22 HCN. cepa0-grad2; CEPA cc-pVDZ gradient for the NO radical. tu6-cp-ne2; Example potential energy surface scan and CP-correction for Ne2. sapt7; SAPT0 open-shell computation of H2O-HO2 interaction energy First with cc-pVDZ and density fitted integrals with UHF Then with 6-31g and direct integrals, except for dispersion that is computed with cc-pVDZ-ri density fitting with UHF. mints-benchmark; run some BLAS benchmarks. scf-bs; UHF and broken-symmetry UHF energy for molecular hydrogen. fci-tdm; He2+ FCI/cc-pVDZ Transition Dipole Moment. omp2p5-grad2; OMP2.5 cc-pVDZ gradient for the NO radical. fci-h2o-fzcv; 6-31G H2O Test FCI Energy Point. sapt-dft2; SAPT(DFT) aug-cc-pVDZ computation for the water dimer interaction energy. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Appendices. © Copyright 2018, The Psi4 Project.; Last updated on Wednesday, 25 July 2018 04:21AM.; Created using Sphinx 1.7.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/testsuite-1.html:39718,energy,energy,39718,psi4manual/1.2.1/testsuite-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/testsuite-1.html,8,['energy'],['energy']
Energy Efficiency,"VWN3 (RPA) LSDA Functional. s_x; Slater LSDA Exchange. vwn3rpa_c; VWN3 (RPA) LSDA Correlation. vwn3_c; VWN3 LSDA Correlation. vwn5rpa_c; VWN5 (RPA) LSDA Correlation. vwn5_c; VWN5 LSDA Correlation. dldf; Dispersionless Hybrid Meta-GGA XC Functional. dldf+d; Dispersionless Hybrid Meta-GGA XC Functional w/ Podeszwa and Szalewicz Dispersion Correction. dldf+d09; Dispersionless Hybrid Meta-GGA XC Functional w/ Podeszwa and Szalewicz Dispersion Correction. Warning; Optimizations where the molecule is specified in Z-matrix format; with dummy atoms will result in the geometry being converted to a Cartesian representation. Parameters:; name (string) – 'scf' || 'df-mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; energy(). func (function) – gradient || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. mode (string) – 'continuous' || 'sow' || 'reap'; For a finite difference of energies optimization, indicates whether; the calculations required to complete the; optimization are to be run in one file ('continuous') or are to be; farmed out in an embarrassingly parallel fashion; ('sow'/'reap'). For the latter, run an initial job with; 'sow' and follow instructions in its output file. dertype (dertype) – 'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. Examples :. >>> # [1] Analytic scf optimization; >>> optimize('scf'). >>> # [2] Finite difference mp5 optimization; >>> opt('mp5'). >>> # [3] Forced finite difference ccsd optimization; >>> optimize('ccsd",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/opt-1.html:6786,energy,energy,6786,psi4manual/4.0b5/opt-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/opt-1.html,2,['energy'],['energy']
Energy Efficiency,"ValidationError(f""psi4.core.set_variable: Target variable '{key}' already a scalar variable!""); else:; core.set_array_variable(key, val); elif isinstance(val, np.ndarray):; if core.has_scalar_variable(key):; raise ValidationError(f""psi4.core.set_variable: Target variable '{key}' already a scalar variable!""); else:; core.set_array_variable(key, core.Matrix.from_array(_qcvar_reshape_set(key, val))); else:; if core.has_array_variable(key):; raise ValidationError(f""psi4.core.set_variable: Target variable '{key}' already an array variable!""); else:; core.set_scalar_variable(key, val). # TODO _qcvar_warnings(key). def _core_wavefunction_set_variable(self: core.Wavefunction, key: str, val: Union[core.Matrix, np.ndarray, float]) -> None:; """"""Sets scalar or array :ref:`QCVariable <sec:appendices:qcvars>` *key* to *val* on *self*. Parameters; ----------; self; Wavefunction instance.; key; Case-insensitive key to instance's double or :class:`~psi4.core.Matrix`; storage maps. - If ``CURRENT ENERGY``, syncs with ``self.energy_``.; - If ``CURRENT GRADIENT``, syncs with ``gradient_``.; - If ``CURRENT HESSIAN``, syncs with ``self.hessian_``.; val; Scalar or array to be stored in `key`. If :class:`~numpy.ndarray` and; data `key` does not naturally fit in 2D Matrix (often charge and; multipole QCVariables), it will be reshaped, as all; :class:`~numpy.ndarray` are stored as :class:`~psi4.core.Matrix`. Raises; ------; ~psi4.driver.ValidationError; If `val` is a scalar but `key` already exists as an array variable. Or; if `val` is an array but `key` already exists as a scalar variable. """"""; if isinstance(val, core.Matrix):; if self.has_scalar_variable(key):; raise ValidationError(""psi4.core.Wavefunction.set_variable: Target variable '{key}' already a scalar variable!""); else:; self.set_array_variable(key, val); elif isinstance(val, np.ndarray):; if self.has_scalar_variable(key):; raise ValidationError(""psi4.core.Wavefunction.set_variable: Target variable '{key}' already a scalar variabl",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/p4util/python_helpers.html:40021,ENERGY,ENERGY,40021,psi4manual/1.9.x/_modules/psi4/driver/p4util/python_helpers.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/p4util/python_helpers.html,2,['ENERGY'],['ENERGY']
Energy Efficiency,"Various constrained energy minimizations of HOOH with cc-pvdz RHF. For “fixed” coordinates, the final value is provided by the user. mints1; Symmetry tests for a range of molecules. This doesn’t actually compute any energies, but serves as an example of the many ways to specify geometries in Psi4. dct11; Restricted DF-DCT ODC-12 energies with linearly dependent basis functions. cc49; EOM-CC3(UHF) on CH radical with user-specified basis and properties for particular root. density-screen-2; RKS Density Matrix based-Integral Screening Test for benzene. opt3; SCF cc-pVDZ geometry optimzation, with Z-matrix input. pywrap-all; Intercalls among python wrappers- database, cbs, optimize, energy, etc. Though each call below functions individually, running them all in sequence or mixing up the sequence is aspirational at present. Also aspirational is using the intended types of gradients. nbody-multi-level-2; many-body different levels of theory on each body of helium tetramer. cc37; CC2(UHF)/cc-pVDZ energy of H2O+. dfccdl1; DF-CCDL cc-pVDZ energy for the H2O molecule. opt8; Various constrained energy minimizations of HOOH with cc-pvdz RHF. Cartesian-coordinate constrained optimizations of HOOH in Cartesians. castup1; Test of SAD/Cast-up (mainly not dying due to file weirdness). dfscf-bz2; Benzene Dimer DF-HF/cc-pVDZ. ddd-deriv; Sample HF/cc-pVDZ H2O computation all derivatives. scf-property; UFH and B3LYP cc-pVQZ properties for the CH2 molecule. dft-pruning; Tests all grid pruning options available and screening of small weights. Check against grid size. cisd-h2o+-0; 6-31G** H2O+ Test CISD Energy Point. dft-smoke; DFT Functional Smoke Test. dct-grad3; Restricted DF-DCT ODC-12 gradient for ethylene with cc-pVDZ/cc-pVDZ-RI standard/auxiliary basis set. fsapt-d; Tests SAPT0-D corrections, with a variety of damping functions/parameters. mbis-4; MBIS calculation on NaCl. lccd-grad1; LCCD cc-pVDZ gradient for the H2O molecule. cc21; ROHF-EOM-CCSD/DZ analytic gradient lowest \(^{2}A_",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/autodoc_testsuite_corepsi4.html:38471,energy,energy,38471,psi4manual/1.8.x/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/autodoc_testsuite_corepsi4.html,2,['energy'],['energy']
Energy Efficiency,"Vector) → None; docstring. same_a_b_dens(self: psi4.core.Wavefunction) → bool¶; Returns true if the alpha and beta densities are the same. same_a_b_orbs(self: psi4.core.Wavefunction) → bool¶; Returns true if the alpha and beta orbitals are the same. scalar_variable(self: psi4.core.Wavefunction, arg0: str) → float¶; Returns the requested (case-insensitive) double QC variable. scalar_variables(self: psi4.core.Wavefunction) → Dict[str, float]¶; Returns the dictionary of all double QC variables. semicanonical_orbs(self: psi4.core.CIWavefunction) → None; docstring. set_array(key, val)¶. set_array_variable(self: psi4.core.Wavefunction, arg0: str, arg1: psi4.core.Matrix) → None¶; Sets the requested (case-insensitive) Matrix QC variable. set_basisset(self: psi4.core.Wavefunction, arg0: str, arg1: psi4.core.BasisSet) → None¶; Sets the requested auxiliary basis. set_ci_guess(self: psi4.core.CIWavefunction, arg0: str) → None; docstring. set_energy(self: psi4.core.Wavefunction, arg0: float) → None¶; Sets the Wavefunction’s energy. set_external_potential(self: psi4.core.Wavefunction, arg0: psi4.core.ExternalPotential) → None¶; Sets the requested external potential. set_frequencies(val)¶. set_gradient(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix) → None¶; Sets the Wavefunction’s gradient. set_hessian(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix) → None¶; Sets the Wavefunction’s Hessian. set_legacy_frequencies(self: psi4.core.Wavefunction, arg0: psi4.core.Vector) → None¶; Sets the frequencies of the Hessian. set_name(self: psi4.core.Wavefunction, arg0: str) → None¶; Sets the level of theory this wavefunction corresponds to. set_orbitals(self: psi4.core.CIWavefunction, arg0: str, arg1: psi4.core.Matrix) → None; docstring. set_print(self: psi4.core.Wavefunction, arg0: int) → None¶; Sets the print level of the Wavefunction. set_reference_wavefunction(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; docstring. set_scalar_variable(self: psi4.core.Wave",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/api/psi4.core.ciwavefunction.html:15655,energy,energy,15655,psi4manual/1.3.2/api/psi4.core.ciwavefunction.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/api/psi4.core.ciwavefunction.html,1,['energy'],['energy']
Energy Efficiency,"WERNER, AOBASIS; Default: WERNER. LOCAL_METHOD (CCLAMBDA); CCLAMBDA —. Type: string; Default: WERNER. LOCAL_METHOD (CCRESPONSE); CCRESPONSE —. Type: string; Default: WERNER. LOCAL_METHOD (CCSORT); CCSORT —. Type: string; Default: WERNER. LOCAL_METHOD (CIS); CIS —. Type: string; Possible Values: AOBASIS, WERNER; Default: WERNER. LOCAL_PAIRDEF (CCENERGY); CCENERGY —. Type: string; Possible Values: BP, RESPONSE; Default: BP. LOCAL_PAIRDEF (CCLAMBDA); CCLAMBDA —. Type: string; Default: No Default. LOCAL_PAIRDEF (CCRESPONSE); CCRESPONSE —. Type: string; Default: NONE. LOCAL_PAIRDEF (CCSORT); CCSORT —. Type: string; Default: BP. LOCAL_PRECONDITIONER (CCEOM); CCEOM —. Type: string; Possible Values: HBAR, FOCK; Default: HBAR. LOCAL_WEAKP (CCENERGY); CCENERGY — Desired treatment of “weak pairs” in the local-CCSD method. A value of NEGLECT ignores weak pairs entirely. A value of NONE treats weak pairs in the same manner as strong pairs. A value of MP2 uses second-order perturbation theory to correct the local-CCSD energy computed with weak pairs ignored. Type: string; Possible Values: NONE, NEGLECT, MP2; Default: NONE. LOCAL_WEAKP (CCEOM); CCEOM —. Type: string; Possible Values: NONE, MP2, NEGLECT; Default: NONE. LOCAL_WEAKP (CCLAMBDA); CCLAMBDA —. Type: string; Default: NONE. LOCAL_WEAKP (CCRESPONSE); CCRESPONSE —. Type: string; Default: NONE. LOCAL_WEAKP (CCSORT); CCSORT —. Type: string; Default: NONE. LOCAL_WEAKP (CIS); CIS —. Type: string; Possible Values: MP2, NEGLECT, NONE; Default: MP2. LOCK_OCC (DCFT); DCFT — Controls whether to force the occupation to be that of the SCF guess. For practical applications only the default must be used. Type: boolean; Default: true. LOCK_SINGLET (PSIMRCC); PSIMRCC — Do lock onto a singlet root?. Type: boolean; Default: false. LSE (DETCI); DETCI — Do use least-squares extrapolation in iterative solution of CI vector?. Type: boolean; Default: false. LSE_COLLAPSE (DETCI); DETCI — Number of iterations between least-squares extrapolations. T",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/autodoc_glossary_options_c-1.html:53871,energy,energy,53871,psi4manual/4.0b2/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/autodoc_glossary_options_c-1.html,2,['energy'],['energy']
Energy Efficiency,"WN frequencies, compared to finite difference values. cc55; EOM-CCSD/6-31g excited state transition data for water with two excited states per irrep. dct5; DC-06 calculation for the O2 molecule (triplet ground state). This performs geometry optimization using two-step and simultaneous solution of the response equations for the analytic gradient. fnocc1; Test QCISD(T) for H2O/cc-pvdz Energy. ao-dfcasscf-sp; CASSCF/6-31G** energy point. opt5; 6-31G** UHF CH2 3B1 optimization. Uses a Z-Matrix with dummy atoms, just for demo and testing purposes. cc-module; check that CC is returning the same values btwn CC*, FNOCC, and DFOCC modules. tu4-h2o-freq; Optimization followed by frequencies H2O HF/cc-pVDZ. dct10; The multiple guesses for DCT amplitudes for ODC-12. pubchem2; Superficial test of PubChem interface. dfmp2-grad3; DF-MP2 cc-pVDZ gradients for the H2O molecule. cc26; Single-point gradient, analytic and via finite-differences of 2-1A1 state of H2O with EOM-CCSD. dfomp2-2; OMP2 cc-pVDZ energy for the NO molecule. fnocc5; Test FNO-DF-CCSD(T) energy. cc29; CCSD/cc-pVDZ optical rotation calculation (both gauges) on Cartesian H2O2. props2; DF-SCF cc-pVDZ of benzene-hydronium ion, scanning the dissociation coordinate with Python’s built-in loop mechanism. The geometry is specified by a Z-matrix with dummy atoms, fixed parameters, updated parameters, and separate charge/multiplicity specifiers for each monomer. One-electron properties computed for dimer and one monomer. cc12; Single point energies of multiple excited states with EOM-CCSD. rasci-c2-active; 6-31G* C2 Test RASCI Energy Point, testing two different ways of specifying the active space, either with the ACTIVE keyword, or with RAS1, RAS2, RESTRICTED_DOCC, and RESTRICTED_UOCC. dfccsd-grad1; DF-CCSD cc-pVDZ gradients for the H2O molecule. cc7; Tests CCENERGY’s CCSD gradient in the presence of a dipole field. cc25; Single point gradient of 1-2B2 state of H2O+ with EOM-CCSD. opt-freeze-coords; SCF/cc-pVDZ optimization ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/autodoc_testsuite_corepsi4-1.html:17019,energy,energy,17019,psi4manual/1.5.0/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/autodoc_testsuite_corepsi4-1.html,4,['energy'],['energy']
Energy Efficiency,"WN3 (RPA) LSDA Functional. s_x; Slater LSDA Exchange. vwn3rpa_c; VWN3 (RPA) LSDA Correlation. vwn3_c; VWN3 LSDA Correlation. vwn5rpa_c; VWN5 (RPA) LSDA Correlation. vwn5_c; VWN5 LSDA Correlation. dldf; Dispersionless Hybrid Meta-GGA XC Functional. dldf+d; Dispersionless Hybrid Meta-GGA XC Functional w/ Podeszwa and Szalewicz Dispersion Correction. dldf+d09; Dispersionless Hybrid Meta-GGA XC Functional w/ Podeszwa and Szalewicz Dispersion Correction. Warning; Optimizations where the molecule is specified in Z-matrix format ; with dummy atoms will result in the geometry being converted to a Cartesian representation. Parameters:; name (string) – 'scf' || 'df-mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; energy(). func (function) – gradient || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. mode (string) – 'continuous' || 'sow' || 'reap'; For a finite difference of energies optimization, indicates whether; the calculations required to complete the; optimization are to be run in one file ('continuous') or are to be; farmed out in an embarrassingly parallel fashion; ('sow'/'reap'). For the latter, run an initial job with; 'sow' and follow instructions in its output file. dertype (dertype) – 'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. Examples :. >>> # [1] Analytic scf optimization; >>> optimize('scf'). >>> # [2] Finite difference mp5 optimization; >>> opt('mp5'). >>> # [3] Forced finite difference ccsd optimization; >>> optimize('ccsd",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/opt-1.html:6787,energy,energy,6787,psi4manual/4.0b4/opt-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/opt-1.html,2,['energy'],['energy']
Energy Efficiency,"Wavefunction) – . Examples. >>> # [1] Moments with specific label; >>> E, wfn = energy('hf', return_wfn=True); >>> oeprop(wfn, 'DIPOLE', 'QUADRUPOLE', title='H3O+ SCF'). PSI4 is capable of computing a number of one-electron properties; summarized in the table below. Current one-electron property capabilities of PSI4¶. Feature; Keyword; Notes. Electric dipole moment; DIPOLE. Electric quadrupole moment; QUADRUPOLE; Raw (traced) moments and traceless multipoles. All moments up order N; MULTIPOLE(N); Only raw (traced) moments. Sets global variables e.g. “DIPOLE X”, “32-POLE XYYZZ”. Electrostatic potential, at nuclei; ESP_AT_NUCLEI; Sets global variables “ESP AT CENTER n”, n = 1 to natoms. Electrostatic potential, on grid; GRID_ESP; Generates V at each point in grid_esp.dat. See Properties evaluated on a grid. Electric field, on grid; GRID_FIELD; Generates {Ex,Ey,Ez} at each point grid_field.dat. See Properties evaluated on a grid. Molecular orbital extents; MO_EXTENTS. Mulliken atomic charges; MULLIKEN_CHARGES. Löwdin atomic charges; LOWDIN_CHARGES. Wiberg bond indices; WIBERG_LOWDIN_INDICES; Uses (Löwdin) symmetrically orthogonalized orbitals. Mayer bond indices; MAYER_INDICES. Natural orbital occupations; NO_OCCUPATIONS. Stockholder Atomic Multipoles; MBIS_CHARGES; Generates atomic charges, dipoles, etc. See Minimal Basis Iterative Stockholder. There are two ways the computation of one-electron properties can be requested.; Firstly, the properties can be evaluated from the last; computed one-particle density, using the following syntax:; oeprop(""MO_EXTENTS"", ""MULTIPOLE(4)"", title = ""hello!""). Note that it is the user’s responsibility to ensure that the relaxed density; matrix is computed using the method of interest, which may require setting; additional keywords (see the method’s manual section for details). The named; argument, title, is completely optional and is prepended to any; globals variables set during the computation. The unnamed arguments are the; propertie",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/oeprop-1.html:1678,charge,charges,1678,psi4manual/1.4.0/oeprop-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/oeprop-1.html,4,['charge'],['charges']
Energy Efficiency,"Wavefunction)arg1) -> Matrix :; | docstring; | ; | Cb(...); | Cb( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | Da(...); | Da( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | Db(...); | Db( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | Fa(...); | Fa( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | Fb(...); | Fb( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | add_postiteration_callback(...); | add_postiteration_callback( (Wavefunction)arg1, (object)arg2) -> None :; | docstring; | ; | add_preiteration_callback(...); | add_preiteration_callback( (Wavefunction)arg1, (object)arg2) -> None :; | docstring; | ; | alpha_orbital_space(...); | alpha_orbital_space( (Wavefunction)arg1, (str)arg2, (str)arg3, (str)arg4) -> OrbitalSpace :; | docstring; | ; | basisset(...); | basisset( (Wavefunction)arg1) -> BasisSet :; | docstring; | ; | beta_orbital_space(...); | beta_orbital_space( (Wavefunction)arg1, (str)arg2, (str)arg3, (str)arg4) -> OrbitalSpace :; | docstring; | ; | energy(...); | energy( (Wavefunction)arg1) -> float :; | docstring; | ; | epsilon_a(...); | epsilon_a( (Wavefunction)arg1) -> Vector :; | docstring; | ; | epsilon_b(...); | epsilon_b( (Wavefunction)arg1) -> Vector :; | docstring; | ; | frequencies(...); | frequencies( (Wavefunction)arg1) -> Vector :; | docstring; | ; | gradient(...); | gradient( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | molecule(...); | molecule( (Wavefunction)arg1) -> Molecule :; | docstring; | ; | nirrep(...); | nirrep( (Wavefunction)arg1) -> int :; | docstring; | ; | nmo(...); | nmo( (Wavefunction)arg1) -> int :; | docstring; | ; | nso(...); | nso( (Wavefunction)arg1) -> int :; | docstring; | ; | sobasisset(...); | sobasisset( (Wavefunction)arg1) -> SOBasisSet :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __init__ = <built-in function __init__>; | Raises an ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/psimod-1.html:83267,energy,energy,83267,psi4manual/4.0b2/psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psimod-1.html,2,['energy'],['energy']
Energy Efficiency,"Wavefunction, arg0: psi4.core.Vector) → None¶; Sets the frequencies of the Hessian. set_module(self: psi4.core.Wavefunction, module: str) → None¶; Sets name of the last/highest level of theory module (internal or external) touching the wavefunction. set_name(self: psi4.core.Wavefunction, arg0: str) → None¶; Sets the level of theory this wavefunction corresponds to. set_potential_variable(self: psi4.core.Wavefunction, arg0: str, arg1: psi4.core.ExternalPotential) → None¶; Sets the requested (case-insensitive) ExternalPotential QC variable. (This function is provisional and might be removed in the future.). set_print(self: psi4.core.Wavefunction, arg0: int) → None¶; Sets the print level of the Wavefunction. set_reference_wavefunction(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; docstring. set_scalar_variable(self: psi4.core.Wavefunction, arg0: str, arg1: float) → None¶; Sets the requested (case-insensitive) double QC variable. Syncs with Wavefunction.energy_ if CURRENT ENERGY. set_variable(key, val)¶; Sets scalar or array QCVariable key to val on cls. Return type; None. Parameters. cls (psi4.core.Wavefunction) – ; key (str) – ; val (Union[psi4.core.Matrix, numpy.ndarray, float]) – . shallow_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; Copies the pointers to the internal data. sobasisset(self: psi4.core.Wavefunction) → psi4.core.SOBasisSet¶; Returns the symmetry orbitals basis. soccpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of singly occupied orbitals per irrep. to_file(filename=None)¶; Converts a Wavefunction object to a base class. Parameters. wfn (Wavefunction) – A Wavefunction or inherited class; filename (Optional[str]) – An optional filename to write the data to. Returns; A dictionary and NumPy representation of the Wavefunction. Return type; dict. total_index(self: psi4.core.CCWavefunction, i: int, h: int) → int¶; Map an index (i) within irrep (h) to its energy-sorted index amo",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/api/psi4.core.CCWavefunction.html:24693,ENERGY,ENERGY,24693,psi4manual/1.6.x/api/psi4.core.CCWavefunction.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/api/psi4.core.CCWavefunction.html,1,['ENERGY'],['ENERGY']
Energy Efficiency,"Wavefunction, arg0: psi4.core.Vector) → None¶; Sets the frequencies of the Hessian. set_module(self: psi4.core.Wavefunction, module: str) → None¶; Sets name of the last/highest level of theory module (internal or external) touching the wavefunction. set_name(self: psi4.core.Wavefunction, arg0: str) → None¶; Sets the level of theory this wavefunction corresponds to. set_potential_variable(self: psi4.core.Wavefunction, arg0: str, arg1: psi4.core.ExternalPotential) → None¶; Sets the requested (case-insensitive) ExternalPotential QC variable. (This function is provisional and might be removed in the future.). set_print(self: psi4.core.Wavefunction, arg0: int) → None¶; Sets the print level of the Wavefunction. set_reference_wavefunction(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; docstring. set_scalar_variable(self: psi4.core.Wavefunction, arg0: str, arg1: float) → None¶; Sets the requested (case-insensitive) double QC variable. Syncs with Wavefunction.energy_ if CURRENT ENERGY. set_variable(key, val)¶; Sets scalar or array QCVariable key to val on cls. Return type; None. Parameters. cls (psi4.core.Wavefunction) – ; key (str) – ; val (Union[psi4.core.Matrix, numpy.ndarray, float]) – . shallow_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; Copies the pointers to the internal data. sobasisset(self: psi4.core.Wavefunction) → psi4.core.SOBasisSet¶; Returns the symmetry orbitals basis. soccpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of singly occupied orbitals per irrep. to_file(filename=None)¶; Converts a Wavefunction object to a base class. Parameters. wfn (Wavefunction) – A Wavefunction or inherited class; filename (Optional[str]) – An optional filename to write the data to. Returns; A dictionary and NumPy representation of the Wavefunction. Return type; dict. variable(key)¶; Return copy of scalar or array QCVariable key from self psi4.core.Wavefunction. Returns; Scalar variables are return",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/api/psi4.core.wavefunction.html:22143,ENERGY,ENERGY,22143,psi4manual/1.4.0/api/psi4.core.wavefunction.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/api/psi4.core.wavefunction.html,6,['ENERGY'],['ENERGY']
Energy Efficiency,"Webbook. Alternatively, one can estimate the; ionization potential of molecule by computing the energy difference between; the molecule as given, and the molecule after one electron has been removed; (e.g., the energy difference between a neutral molecule and its cation).; The values of GRAC shifts should be given in Hartree. For the example above,; the GRAC shift value of both molecules are calculated to be 0.1307 (using experimental; IP from CCCBDB), and the user would specify them using the following keywords:; set globals {; sapt_dft_grac_shift_a 0.1307; sapt_dft_grac_shift_b 0.1307; }. A complete, minimal example of a SAPT(DFT) computation is given below.; molecule {; 0 1; O -1.551007 -0.114520 0.000000; H -1.934259 0.762503 0.000000; H -0.599677 0.040712 0.000000; --; 0 1; O 1.350625 0.111469 0.000000; H 1.680398 -0.373741 -0.758561; H 1.680398 -0.373741 0.758561. units angstrom; }. set {; basis aug-cc-pVDZ; sapt_dft_grac_shift_a 0.1307; sapt_dft_grac_shift_b 0.1307; }. energy('sapt(dft)'). As already mentioned above, the SAPT0 module for open-shell cases can also; use exact integrals for all terms except for dispersion. In practice,; density fitting is considerably faster and introduces negligible errors, thus; it is the preferred method for open-shell cases as well.; Below, you can find a minimum example of open-shell SAPT0 computation.; molecule {; 0 1; O 0.000000 0.000000 6.000000; H 0.000000 1.431500 4.890600; H 0.000000 -1.431500 4.890600; --; 0 2; O 0.000000 0.000000 0.000000; O 0.000000 2.503900 0.000000; H 0.000000 -0.424700 -1.839500; units bohr; symmetry c1; no_reorient; no_com; }. set {; reference uhf; scf_type df; basis aug-cc-pVDZ; }. energy('sapt0'). REFERENCE needs to be UHF or ROHF for the open-shell computation to proceed. Advanced example¶; Open-shell computations can be difficult to converge in certain cases, thus you may; want to have more control over the SCF procedure. You have the option of; doing the driver job in the input file, by per",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/sapt.html:14176,energy,energy,14176,psi4manual/1.7.x/sapt.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/sapt.html,4,['energy'],['energy']
Energy Efficiency,"What follows is a very basic description of the practical differences in; the equations that define each of the coupled-pair methods implemented in; Psi4. We begin with the CISD wave function. (3); where we have chosen the intermediate normalization, . The CISD correlation energy is given by. (4); and the amplitudes can be determined by the solution to the coupled set of; eqations:. (5); The CISD method is not size-extensive, but this problem can be overcome by; making very simple modifications to the amplitude equations. We replace; the correlation energy, , with generalized shifts for the; doubles and singles equations, and :. (6); These shifts approximate the effects of triple and quadruple excitations.; The values for and used in several; coupled-pair methods are given in Table CEPA Shifts. Note that these shifts are defined in a spin-free; formalism for closed-shell references only. method. cisd. cepa(0); 0; 0. cepa(1). cepa(3). acpf. aqcc. The pair correlation energy, , is simply a partial; sum of the correlation energy. In a spin-free formalism, the pair energy; is given by. (7); Methods whose shifts ( and ) do not; explicitly depend on orbitals or (CISD, CEPA(0), ACPF,; and AQCC) have solutions that render the energy stationary with respect; variations in the amplitudes. This convenient property allows density; matrices and 1-electron properties to be evaluated without any additional; effort. Note, however, that 1-electron properties are currently; unavailable when coupling these stationary CEPA-like methods with frozen; natural orbitals. Density-fitted coupled cluster¶; Density fitting (DF) [or the resolution of the identity (RI)] and Cholesky; decomposition (CD) techniques are popular in quantum chemistry to avoid; the computation and storage of the 4-index electron repulsion integral; (ERI) tensor and even to reduce the computational scaling of some terms.; DF/CD-CCSD(T) computations are available in Psi4, with or without the; use of FNOs, through the FNOC",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/fnocc-1.html:7687,energy,energy,7687,psi4manual/1.0.0/fnocc-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/fnocc-1.html,4,['energy'],['energy']
Energy Efficiency,"Windows, through the Ubuntu shell). If using the PSI4 binary, gCP has already been installed alongside. If using PSI4 built from source, and anaconda or miniconda has; already been installed (instructions at Quick Installation),; the gcp executable can be obtained through conda install gcp. To remove a conda installation, conda remove gcp. Source. If using PSI4 built from source and you want to build gCP from; from source also, follow the instructions provided with the source; (essentially, download the freely available tarball, unpack the source,; edit the Makefile to select a Fortran compiler, and run make). To be used by PSI4, the program binary (gcp) must be; found in your PSIPATH or PATH (in that order). If; PSI4 is unable to execute the binary, an error will be reported.; To preferentially use a particular gcp compilation, simply adjust its; position in the path environment variables. Running gCP¶; At present there is a limited interface to gCP that is used; only to implement the “HF-3c” [Sure:2013:1672] and “PBEh-3c”; [Grimme:2015:054107] methods (both energy and gradient). The DFTD3 executable must also be available for these methods to; run. Unlike every other method in PSI4, if a basis set has not been; set, these will default to their intended basis sets: MINIX for HF-3c; and def2-mSVP for PBEh-3c. If a basis has previously been set, but you; want to use the default basis, use the slash syntax to “empty” the basis; option for the scope of the current calculation, energy(""hf3c/"").; A few practical examples:. HF-3c single point with default minix basis; 1energy('hf3c'). PBEh-3c optimization with default def2-mSVP basis; 1optimize('pbeh3c'). HF-3c with non-standard basis; 1; 2set basis cc-pvdz; energy('hf3c'). PBEh-3c with default basis after basis set; 1; 2set basis cc-pvdz; energy('pbeh3c/'). If only BSSE/basis set corrections (rather than total energies) are of; interest, the gcp program can be run independently of the scf; through the python function run",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/gcp-1.html:1411,energy,energy,1411,psi4manual/1.1.0/gcp-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/gcp-1.html,2,['energy'],['energy']
Energy Efficiency,"Writer(wfn); fw.write(filename). [docs]def molden(wfn, filename, density_a=None, density_b=None):; """"""Function to write wavefunction information in *wfn* to *filename* in; molden format. Will write natural orbitals from *density* (MO basis) if supplied. .. versionadded:: 0.5; *wfn* parameter passed explicitly. :returns: None. :type wfn: :ref:`Wavefunction<sec:psimod_Wavefunction>`; :param wfn: set of molecule, basis, orbitals from which to generate cube files. :type filename: string; :param filename: destination file name for MOLDEN file. :type density_a: psi4.Matrix; :param density_a: density in the MO basis to build alpha NO's from (optional). :type density_b: psi4.Matrix; :param density_b: density in the MO basis to build beta NO's from, assumes restricted if not supplied (optional). :examples:. >>> # [1] Molden file for DFT calculation; >>> E, wfn = energy('b3lyp', return_wfn=True); >>> molden(wfn, 'mycalc.molden'). >>> # [2] Molden file for CI/MCSCF computation using NO roots; >>> E, wfn = energy('ci', return_wfn=True); >>> molden(wfn, 'no_root1.molden', density_a=wfn.opdm(0, 0, ""A"", True)). """"""; if density_a:; nmopi = wfn.nmopi(); nsopi = wfn.nsopi(). NO_Ra = psi4.Matrix(""NO Alpha Rotation Matrix"", nmopi, nmopi); NO_occa = psi4.Vector(nmopi); density_a.diagonalize(NO_Ra, NO_occa, psi4.DiagonalizeOrder.Descending); NO_Ca = psi4.Matrix(""Ca Natural Orbitals"", nsopi, nmopi); NO_Ca.gemm(False, False, 1.0, wfn.Ca(), NO_Ra, 0). if density_b:; NO_Rb = psi4.Matrix(""NO Beta Rotation Matrix"", nmopi, nmopi); NO_occa = psi4.Vector(nmopi); density_b.diagonalize(NO_Ra, NO_occa, psi4.DiagonalizeOrder.Descending); NO_Cb = psi4.Matrix(""Cb Natural Orbitals"", nsopi, nmopi); NO_Cb.gemm(False, False, 1.0, wfn.Cb(), NO_Rb, 0). else:; NO_occb = NO_occa; NO_Cb = NO_Ca; ; mw = psi4.MoldenWriter(wfn); mw.writeNO(filename, NO_Ca, NO_Cb, NO_occa, NO_occb). else:; try:; occa = wfn.occupation_a(); occb = wfn.occupation_a(); except AttributeError:; psi4.print_out(""\n!Molden warning: This wav",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/driver.html:87314,energy,energy,87314,psi4manual/1.0.0/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver.html,1,['energy'],['energy']
Energy Efficiency,"Writer; Extracts information from a wavefunction object, and writes it to an FCHK file. FDDS_Dispersion; docstring. FISAPT; A Fragment-SAPT Wavefunction. FittedSlaterCorrelationFactor; docstring. FittingMetric; docstring. FragmentType; Fragment activation status. Functional; docstring. GaussianShell; Class containing information about basis functions. GaussianType; 0 if Cartesian, 1 if Pure. GeometryUnits; The units used to define the geometry. HF; docstring. IO; docstring. IOManager; PSIOManager is a class designed to be used as a static object to track all PSIO operations in a given PSI4 computation. IntVector; Class handling vectors with integer values. IntegralFactory; Computes integrals. IntegralTransform; IntegralTransform transforms one- and two-electron integrals within general spaces. IrreducibleRepresentation; An irreducible representation of the point group. JK; docstring. KineticInt; Computes kinetic integrals. LaplaceDenominator; Computer class for a Laplace factorization of the four-index energy denominator in MP2 and coupled-cluster. LibXCFunctional; docstring. Localizer; Class containing orbital localization procedures. MOSpace; Defines orbital spaces in which to transform integrals. MOWriter; Writes the MOs. Matrix; Class for creating and manipulating matrices. MatrixFactory; Creates Matrix objects. MemDFJK; docstring. MintsHelper; Computes integrals. MoldenWriter; Writes wavefunction information in molden format. MolecularGrid; docstring. Molecule; Class to store the elements, coordinates, fragmentation pattern, basis sets, charge, multiplicity, etc. MultipoleInt; Computes arbitrary-order multipole integrals. MultipoleSymmetry; docstring. NBOWriter; The Natural Bond Orbital Writer. NablaInt; Computes nabla integrals. NumIntHelper; Computes numerical integrals using a DFT grid. OEProp; docstring. OneBodyAOInt; Basis class for all one-electron integrals. OneBodySOInt. Options; docstring. OrbitalSpace; Contains information about the orbitals. OverlapI",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/psi4api.html:13024,energy,energy,13024,psi4manual/1.7.x/psi4api.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/psi4api.html,1,['energy'],['energy']
Energy Efficiency,"Writer; Extracts information from a wavefunction object, and writes it to an FCHK file. FDDS_Dispersion; docstring. FISAPT; A Fragment-SAPT Wavefunction. FittedSlaterCorrelationFactor; docstring. FittingMetric; docstring. FragmentType; Fragment activation status. Functional; docstring. GaussianShell; Class containing information about basis functions. GaussianType; 0 if Cartesian, 1 if Pure. GeometryUnits; The units used to define the geometry. HF; docstring. IO; docstring. IOManager; PSIOManager is a class designed to be used as a static object to track all PSIO operations in a given PSI4 computation. IntVector; Class handling vectors with integer values. IntegralFactory; Computes integrals. IntegralTransform; IntegralTransform transforms one- and two-electron integrals within general spaces. IrreducibleRepresentation; An irreducible representation of the point group. JK; docstring. KineticInt; Computes kinetic integrals. LaplaceDenominator; Computer class for a Laplace factorization of the four-index energy denominator in MP2 and coupled-cluster. LibXCFunctional; docstring. Localizer; Class containing orbital localization procedures. MOSpace; Defines orbital spaces in which to transform integrals. MOWriter; Writes the MOs. Matrix; Class for creating and manipulating matrices. MatrixFactory; Creates Matrix objects. MemDFJK; docstring. MintsHelper; Computes integrals. MoldenWriter; Writes wavefunction information in molden format. MolecularGrid; docstring. Molecule; Class to store the elements, coordinates, fragmentation pattern, basis sets, charge, multiplicity, etc. MultipoleInt; Computes arbitrary-order multipole integrals. MultipoleSymmetry; docstring. NablaInt; Computes nabla integrals. NumIntHelper; Computes numerical integrals using a DFT grid. OEProp; docstring. OneBodyAOInt; Basis class for all one-electron integrals. OneBodySOInt. Options; docstring. OrbitalSpace; Contains information about the orbitals. OverlapInt; Computes overlap integrals. PMLocalizer;",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/psi4api.html:13016,energy,energy,13016,psi4manual/1.8.x/psi4api.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/psi4api.html,2,['energy'],['energy']
Energy Efficiency,"X grid. -1 fully converges the SCF on the final grid if possible, ending early if MAXITER total SCF iterations are reached (failure). 0 disables the final COSX grid entirely. n runs up to n iterations on the final COSX grid, ending early if SCF convergence is reached (success) or if MAXITER total SCF iterations are reached (failure). Type: integer; Default: 1. COSX_RADIAL_POINTS_FINAL¶. Number of radial points in final COSX grid. Type: integer; Default: 35. COSX_RADIAL_POINTS_INITIAL¶. Number of radial points in initial COSX grid. Type: integer; Default: 25. COSX_SPHERICAL_POINTS_FINAL¶. Number of spherical points in final COSX grid. Type: integer; Default: 110. COSX_SPHERICAL_POINTS_INITIAL¶. Number of spherical points in initial COSX grid. Type: integer; Default: 50. SAD Guess Algorithm¶. SAD_D_CONVERGENCE¶. Convergence criterion for SCF density in the SAD guess, analogous to D_CONVERGENCE. Type: conv double; Default: 1e-5. SAD_E_CONVERGENCE¶. Convergence criterion for SCF energy in the SAD guess, analogous to E_CONVERGENCE. Type: conv double; Default: 1e-5. DFT¶. DFT_ALPHA¶. The DFT Exact-exchange parameter. Type: double; Default: 0.0. DFT_ALPHA_C¶. The DFT Correlation hybrid parameter. Type: double; Default: 0.0. DFT_BASIS_TOLERANCE¶. DFT basis cutoff. Type: conv double; Default: 1.0e-12. DFT_BS_RADIUS_ALPHA¶. Factor for effective BS radius in radial grid. Type: double; Default: 1.0. DFT_DISPERSION_PARAMETERS¶. Parameters defining the dispersion correction. See Table -D Functionals for default values and Table Dispersion Corrections for the order in which parameters are to be specified in this array option. Unused for functionals constructed by user. Type: array; Default: No Default. DFT_GRAC_ALPHA¶. The gradient regularized asymptotic correction alpha value. Type: double; Default: 0.5. DFT_GRAC_BETA¶. The gradient regularized asymptotic correction beta value. Type: double; Default: 40.0. DFT_GRAC_SHIFT¶. The gradient regularized asymptotic correction shift value",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/autodir_options_c/module__scf.html:13613,energy,energy,13613,psi4manual/1.9.x/autodir_options_c/module__scf.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/autodir_options_c/module__scf.html,2,['energy'],['energy']
Energy Efficiency,"X.set_alpha(1.0 / (1.0 - 0.678792)). X.set_parameter('B97_gamma', 0.004); X.set_parameter('B97_a0', 2.51767E-1); X.set_parameter('B97_a1', 1.57375E0); X.set_parameter('B97_a2', -5.26624E0); X.set_parameter('B97_a3', 6.74313E0). C = build_functional('B_C'); C.set_name('wB97X_C'). C.set_parameter('B97_os_gamma', 0.006); C.set_parameter('B97_os_a0', 5.53261E-1); C.set_parameter('B97_os_a1', -1.16626E0); C.set_parameter('B97_os_a2', 6.84409E0); C.set_parameter('B97_os_a3', -8.90640E0). C.set_parameter('B97_ss_gamma', 0.2); C.set_parameter('B97_ss_a0', 1.15698E0); C.set_parameter('B97_ss_a1', -3.31669E0); C.set_parameter('B97_ss_a2', 6.27265E0); C.set_parameter('B97_ss_a3', -4.51464E0). sup.add_x_functional(X); sup.add_c_functional(C). # Set GKS up after adding functionals; sup.set_x_omega(0.3); sup.set_c_omega(0.0); sup.set_x_alpha(0.678792); sup.set_c_alpha(1.0); sup.set_c_os_alpha(0.477992); sup.set_c_ss_alpha(0.581569). # => End User-Customization <= #. # Call this last; sup.allocate(); return sup. [docs]def build_pbe0_2_superfunctional(name, npoints, deriv):. # Call this first; sup = PsiMod.SuperFunctional.blank(); sup.set_max_points(npoints); sup.set_deriv(deriv). # => User-Customization <= #. # No spaces, keep it short and according to convention; sup.set_name('PBE0-2'); # Tab in, trailing newlines; sup.set_description(' PBE0-2 Double Hydrid Exchange-Correlation Functional\n'); # Tab in, trailing newlines; sup.set_citation(' J. Chai, Chem. Phys. Lett., 538, 121-125, 2012\n'). # Add member functionals; X = build_functional('PBE_X'); X.set_alpha(1.0); sup.add_x_functional(X); C = build_functional('PBE_C'); C.set_alpha(0.5); sup.add_c_functional(C). # Set GKS up after adding functionals; sup.set_x_omega(0.0); sup.set_c_omega(0.0); sup.set_x_alpha(0.793701); sup.set_c_alpha(0.5). # => End User-Customization <= #. # Call this last; sup.allocate(); return sup. [docs]def build_dsd_blyp_superfunctional(name, npoints, deriv):. # Call this first; sup = PsiMod.SuperFunctional",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/_modules/functional.html:64870,allocate,allocate,64870,psi4manual/4.0b3/_modules/functional.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/_modules/functional.html,4,['allocate'],['allocate']
Energy Efficiency,"X.set_alpha(1.0 / (1.0 - 0.678792)). X.set_parameter('B97_gamma', 0.004); X.set_parameter('B97_a0', 2.51767E-1); X.set_parameter('B97_a1', 1.57375E0); X.set_parameter('B97_a2', -5.26624E0); X.set_parameter('B97_a3', 6.74313E0). C = build_functional('B_C'); C.set_name('wB97X_C'). C.set_parameter('B97_os_gamma', 0.006); C.set_parameter('B97_os_a0', 5.53261E-1); C.set_parameter('B97_os_a1', -1.16626E0); C.set_parameter('B97_os_a2', 6.84409E0); C.set_parameter('B97_os_a3', -8.90640E0). C.set_parameter('B97_ss_gamma', 0.2); C.set_parameter('B97_ss_a0', 1.15698E0); C.set_parameter('B97_ss_a1', -3.31669E0); C.set_parameter('B97_ss_a2', 6.27265E0); C.set_parameter('B97_ss_a3', -4.51464E0). sup.add_x_functional(X); sup.add_c_functional(C). # Set GKS up after adding functionals; sup.set_x_omega(0.3); sup.set_c_omega(0.0); sup.set_x_alpha(0.678792); sup.set_c_alpha(1.0); sup.set_c_os_alpha(0.477992); sup.set_c_ss_alpha(0.581569). # => End User-Customization <= #. # Call this last; sup.allocate(); return sup. [docs]def build_pbe0_2_superfunctional(name, npoints, deriv):. # Call this first; sup = psi4.SuperFunctional.blank(); sup.set_max_points(npoints); sup.set_deriv(deriv). # => User-Customization <= #. # No spaces, keep it short and according to convention; sup.set_name('PBE0-2'); # Tab in, trailing newlines; sup.set_description(' PBE0-2 Double Hydrid Exchange-Correlation Functional\n'); # Tab in, trailing newlines; sup.set_citation(' J. Chai, Chem. Phys. Lett., 538, 121-125, 2012\n'). # Add member functionals; X = build_functional('PBE_X'); X.set_alpha(1.0); sup.add_x_functional(X); C = build_functional('PBE_C'); C.set_alpha(0.5); sup.add_c_functional(C). # Set GKS up after adding functionals; sup.set_x_omega(0.0); sup.set_c_omega(0.0); sup.set_x_alpha(0.793701); sup.set_c_alpha(0.5). # => End User-Customization <= #. # Call this last; sup.allocate(); return sup. [docs]def build_dsd_blyp_superfunctional(name, npoints, deriv):. # Call this first; sup = psi4.SuperFunctional.bla",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/functional.html:73900,allocate,allocate,73900,psi4manual/4.0b5/_modules/functional.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/functional.html,2,['allocate'],['allocate']
Energy Efficiency,"X.set_alpha(1.0 / (1.0 - 0.678792)). X.set_parameter('B97_gamma', 0.004); X.set_parameter('B97_a0', 2.51767E-1); X.set_parameter('B97_a1', 1.57375E0); X.set_parameter('B97_a2', -5.26624E0); X.set_parameter('B97_a3', 6.74313E0). C = build_functional('B_C'); C.set_name('wB97X_C'). C.set_parameter('B97_os_gamma', 0.006); C.set_parameter('B97_os_a0', 5.53261E-1); C.set_parameter('B97_os_a1', -1.16626E0); C.set_parameter('B97_os_a2', 6.84409E0); C.set_parameter('B97_os_a3', -8.90640E0). C.set_parameter('B97_ss_gamma', 0.2); C.set_parameter('B97_ss_a0', 1.15698E0); C.set_parameter('B97_ss_a1', -3.31669E0); C.set_parameter('B97_ss_a2', 6.27265E0); C.set_parameter('B97_ss_a3', -4.51464E0). sup.add_x_functional(X); sup.add_c_functional(C). # Set GKS up after adding functionals; sup.set_x_omega(0.3); sup.set_c_omega(0.0); sup.set_x_alpha(0.678792); sup.set_c_alpha(1.0); sup.set_c_os_alpha(0.477992); sup.set_c_ss_alpha(0.581569). # => End User-Customization <= #. # Call this last; sup.allocate(); return sup. [docs]def build_pbe0_2_superfunctional(name, npoints, deriv):. # Call this first; sup = psi4.SuperFunctional.blank(); sup.set_max_points(npoints); sup.set_deriv(deriv). # => User-Customization <= #. # No spaces, keep it short and according to convention; sup.set_name('PBE0-2'); # Tab in, trailing newlines; sup.set_description(' PBE0-2 Double Hydrid Exchange-Correlation Functional\n'); # Tab in, trailing newlines; sup.set_citation(' J. Chai, Chem. Phys. Lett., 538, 121-125, 2012\n'). # Add member functionals; X = build_functional('PBE_X'); X.set_alpha(1.0); sup.add_x_functional(X); C = build_functional('PBE_C'); C.set_alpha(1.0); sup.add_c_functional(C). # Set GKS up after adding functionals; sup.set_x_omega(0.0); sup.set_c_omega(0.0); sup.set_x_alpha(0.793701); sup.set_c_alpha(0.5). # => End User-Customization <= #. # Call this last; sup.allocate(); return sup. [docs]def build_dsd_blyp_superfunctional(name, npoints, deriv):. # Call this first; sup = psi4.SuperFunctional.bla",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/procedures/functional.html:82232,allocate,allocate,82232,psi4manual/1.0.0/_modules/procedures/functional.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/procedures/functional.html,1,['allocate'],['allocate']
Energy Efficiency,"XTERN', Chrgfield.extern). First a QMMM object is created, then three separate particles are added to this; object before the SCF code is told about its existence on the last line. The; calls to addCharge take the atomic charge, x coordinate, y coordinate, and; z coordinate in that order. The atomic charge is specified in atomic units,; and the coordinates always use the same units as the geometry specification in; the regular QM region. Additional MM molecules may be specified by adding; extra calls to addCharge to describe the full MM region.; To run a computation in a constant dipole field, the PERTURB_H,; PERTURB_WITH and PERTURB_DIPOLE keywords can be used. As an; example, to add a dipole field of magnitude 0.05 a.u. in the y direction and; 0.1 a.u. in the z direction, we can use the following keywords:; 1; 2; 3set perturb_h true; set perturb_with dipole; set perturb_dipole [ 0, 0.05, 0.1 ]. Note that if any specified fields do not fall along a symmetry axis, the; symmetry of the calculation should be reduced accordingly; if in doubt run the; calculation in C1 symmetry. For examples of SCF and MP2 calculations in an; external field, see scf7 and dfmp2-grad5. Convergence and Algorithm Defaults¶. SCF algorithm and convergence criteria defaults by calculation type [1]¶. Ab Initio Method; Calculation Type; E_CONVERGENCE; D_CONVERGENCE; SCF_TYPE. SCF of HF or DFT; energy; 6; 6; DF. optimization; 8; 8. frequency [7]; 8; 8. SCF of post-HF; energy; 8; 8; PK [3]. optimization; 10; 10. frequency [7]; 10; 10. CC property [2]; 10; 10. Post-SCF convergence criteria defaults by calculation type [4]¶. Ab Initio Method; Calculation Type; E_CONVERGENCE [5]; R_CONVERGENCE [6]. post-HF of post-HF; energy; 6;  . optimization; 8;  . frequency [7]; 8;  . CC property [2]; 8;  . Footnotes. [1]Note that this table applies only the SCF module,; not to the final convergence criteria for post-HF methods or to methods; that use an alternate starting point, like MCSCF. SAPT computations, to",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/scf-1.html:32894,reduce,reduced,32894,psi4manual/1.1.0/scf-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/scf-1.html,6,['reduce'],['reduced']
Energy Efficiency,"XXX¶. mtd HEXADECAPOLE XXXY¶. mtd HEXADECAPOLE ZZZZ¶; The 15 components of the named method hexadecapole [Debye Ang^3].; Deprecated in favor of mtd HEXADECAPOLE. mtd 32-POLE¶; Redundant 32-pole array [e a0^5] for the named method, (3, 3, 3, 3, 3). mtd 32-POLE XXXXX¶. mtd 32-POLE XXXXY¶. mtd 32-POLE ZZZZZ¶; The 21 components of the named method 32-pole [Debye Ang^4].; Deprecated in favor of mtd 32-POLE. mtd 64-POLE¶; Redundant 64-pole array [e a0^6] for the named method, (3, 3, 3, 3, 3, 3). mtd 64-POLE XXXXXX¶. mtd 64-POLE XXXXXY¶. mtd 64-POLE ZZZZZZ¶; The 28 components of the named method 64-pole [Debye Ang^5].; Deprecated in favor of mtd 64-POLE. mtd 128-POLE¶; Redundant 128-pole array [e a0^7] for the named method, (3, 3, 3, 3, 3, 3, 3). mtd 128-POLE XXXXXXX¶. mtd 128-POLE XXXXXXY¶. mtd 128-POLE ZZZZZZZ¶; The 36 components of the named method 128-pole [Debye Ang^6].; Deprecated in favor of mtd 128-POLE. MP2 TOTAL ENERGY¶. MP2 CORRELATION ENERGY¶; The total electronic energy [Eh] and correlation energy component [Eh]; for the MP2 level of theory. MP2 TOTAL GRADIENT¶. The total electronic gradient [E_h/a0] of the MP2 level of theory, ({nat}, 3).¶. MP2 DIPOLE GRADIENT¶; The derivative of the MP2 level of theory dipole [E_h a0/u] = [(e a0/a0)^2/u] with respect to nuclear perturbations; as a degree-of-freedom by dipole component array, (3 * {nat}, 3). MP2 TOTAL HESSIAN¶; The total electronic second derivative [Eh/a0/a0] for the MP2 level of theory, (3 * {nat}, 3 * {nat}). MP2.5 TOTAL ENERGY¶. MP2.5 CORRELATION ENERGY¶; The total electronic energy [Eh] and correlation energy component [Eh]; for the MP2.5 level of theory. MP3 TOTAL ENERGY¶. MP3 CORRELATION ENERGY¶; The total electronic energy [Eh] and correlation energy component [Eh]; for the MP3 level of theory. MP4(T) CORRECTION ENERGY¶; The MP4 triples component [Eh]. Quantity is second right-hand term in; Eq. (2). MP4(SDQ) TOTAL ENERGY¶. MP4(SDQ) CORRELATION ENERGY¶; The total electronic energy [Eh] and correlation ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/glossary_psivariables-1.html:27669,energy,energy,27669,psi4manual/1.4.0/glossary_psivariables-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/glossary_psivariables-1.html,8,['energy'],['energy']
Energy Efficiency,"Y or; SAPT EXCH-DISP20 ENERGY resulting from; from same-spin or triplet doubles correlations. SAPT HF(2) ENERGY ABC(HF)¶; The total Hartree–Fock energy [E_h] of the supersystem implemented for F/I-SAPT. SAPT HF(2) ENERGY AC(0)¶; The Hartree–Fock energy [E_h] of subsystems A and C implemented for F/I-SAPT. SAPT HF(2) ENERGY BC(0)¶; The Hartree–Fock energy [E_h] of subsystems B and C implemented for F/I-SAPT. SAPT HF(2) ENERGY A(0)¶; The Hartree–Fock energy [E_h] of subsystem A implemented for F/I-SAPT. SAPT HF(2) ENERGY B(0)¶; The Hartree–Fock energy [E_h] of subsystem B implemented for F/I-SAPT. SAPT HF(2) ENERGY AC(HF)¶; The Hartree–Fock localized energy [E_h] of subsystems A and C implemented for F/I-SAPT. SAPT HF(2) ENERGY BC(HF)¶; The Hartree–Fock localized energy [E_h] of subsystems B and C implemented for F/I-SAPT. SAPT HF(2) ENERGY AB(HF)¶; The Hartree–Fock localized energy [E_h] of subsystems A and B implemented for F/I-SAPT. SAPT HF(2) ENERGY A(HF)¶; The Hartree–Fock localized energy [E_h] of subsystem A implemented for F/I-SAPT. SAPT HF(2) ENERGY B(HF)¶; The Hartree–Fock localized energy [E_h] of subsystem B implemented for F/I-SAPT. SAPT HF(2) ENERGY C¶; The Hartree–Fock energy [E_h] of subsystem C implemented for F/I-SAPT. SAPT HF(2) ENERGY HF¶; The FI-SAPT Hartree–Fock interaction energy [E_h] implemented for F/I-SAPT. SAPT ELST12,R ENERGY¶; An electrostatics-classified SAPT term energy [E_h] implemented for SAPT2. SAPT EXCH11(S^2) ENERGY¶. SAPT EXCH12(S^2) ENERGY¶; An exchange-classified SAPT term energy [E_h] implemented for SAPT2. SAPT IND22 ENERGY¶. SAPT EXCH-IND22 ENERGY¶; An induction-classified SAPT term energy [E_h] implemented for SAPT2. SAPT DISP21 ENERGY¶; A dispersion-classified SAPT term energy [E_h] implemented for SAPT2+. SAPT DISP22(SDQ) ENERGY¶. SAPT DISP22(T) ENERGY¶. SAPT EST.DISP22(T) ENERGY¶; Dispersion-classified MBPT-based SAPT term energy [E_h] implemented for SAPT2+. SAPT DISP2(CCD) ENERGY¶. SAPT DISP22(S)(CCD) ENERGY¶. SAPT DISP",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/glossary_psivariables.html:47611,energy,energy,47611,psi4manual/1.7.x/glossary_psivariables.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/glossary_psivariables.html,4,['energy'],['energy']
Energy Efficiency,"Y"",cemp3); elif ( lowername == 'mp4(sdq)'):; emp4sdq = PsiMod.get_variable(""MP4(SDQ) TOTAL ENERGY""); cemp4sdq = PsiMod.get_variable(""MP4(SDQ) CORRELATION ENERGY""); PsiMod.set_variable(""CURRENT ENERGY"",emp4sdq); PsiMod.set_variable(""CURRENT CORRELATION ENERGY"",cemp4sdq); elif ( lowername == 'fno-mp4(sdq)'):; emp4sdq = PsiMod.get_variable(""MP4(SDQ) TOTAL ENERGY""); cemp4sdq = PsiMod.get_variable(""MP4(SDQ) CORRELATION ENERGY""); PsiMod.set_variable(""CURRENT ENERGY"",emp4sdq); PsiMod.set_variable(""CURRENT CORRELATION ENERGY"",cemp4sdq); elif ( lowername == 'fno-mp4'):; emp4 = PsiMod.get_variable(""MP4 TOTAL ENERGY""); cemp4 = PsiMod.get_variable(""MP4 CORRELATION ENERGY""); PsiMod.set_variable(""CURRENT ENERGY"",emp4); PsiMod.set_variable(""CURRENT CORRELATION ENERGY"",cemp4); elif (lowername == 'fnocc-mp') and (level == 4):; emp4 = PsiMod.get_variable(""MP4 TOTAL ENERGY""); cemp4 = PsiMod.get_variable(""MP4 CORRELATION ENERGY""); PsiMod.set_variable(""CURRENT ENERGY"",emp4); PsiMod.set_variable(""CURRENT CORRELATION ENERGY"",cemp4). # restore symmetry for fno-cc; if (PsiMod.get_option('FNOCC','NAT_ORBS')):; molecule.reset_point_group(user_pg); molecule.update_geometry(). # restore options; optstash.restore(). return PsiMod.get_variable(""CURRENT ENERGY""). [docs]def run_cepa(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a cepa-like calculation. >>> energy('cepa(1)'). """"""; lowername = name.lower(); uppername = name.upper(); kwargs = kwargs_lower(kwargs). # save user options; optstash = OptionsState(; ['TRANSQT2', 'WFN'],; ['FNOCC', 'NAT_ORBS'],; ['FNOCC', 'RUN_CEPA'],; ['FNOCC', 'CEPA_NO_SINGLES']). PsiMod.set_local_option('FNOCC','RUN_CEPA', True). # what type of cepa?; cepa_level = uppername; if (lowername == 'cepa(2)'):; raise ValidationError(""Error: %s not implemented\n"" % lowername); if (lowername == 'dci'):; cepa_level = 'CISD'; if (lowername == 'sdci'):; cepa_level = 'CISD'. if (lowername == 'fno-cepa(0)'):; cepa_level = 'CEPA(0)'; PsiMod.set_local_option('FN",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/_modules/proc.html:75862,ENERGY,ENERGY,75862,psi4manual/4.0b4/_modules/proc.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/proc.html,1,['ENERGY'],['ENERGY']
Energy Efficiency,"Y'))); ERGT[rgt] = 7.0; else:; ERGT[rgt] = call_function_in_1st_argument(func, **kwargs); #print ERGT[rgt]; psi4.print_variables(); exec(actives); for envv in db_tabulate:; VRGT[rgt][envv.upper()] = psi4.get_variable(envv); psi4.set_global_option(""REFERENCE"", user_reference); psi4.clean(). elif (db_mode.lower() == 'sow'):; freagent = open('%s.in' % (rgt), 'w'); freagent.write('# This is a psi4 input file auto-generated from the database() wrapper.\n\n'); freagent.write(banners); freagent.write(p4util.format_molecule_for_input(GEOS[rgt])). freagent.write(commands); freagent.write('''\npickle_kw = (""""""'''); pickle.dump(kwargs, freagent); freagent.write('''"""""")\n'''); freagent.write(""""""\nkwargs = pickle.loads(pickle_kw)\n""""""); freagent.write(""""""electronic_energy = %s(**kwargs)\n\n"""""" % (func.__name__)); freagent.write(""""""psi4.print_variables()\n""""""); freagent.write(""""""psi4.print_out('\\nDATABASE RESULT: computation %d for reagent %s """"""; % (os.getpid(), rgt)); freagent.write(""""""yields electronic energy %20.12f\\n' % (electronic_energy))\n\n""""""); freagent.write(""""""psi4.set_variable('NATOM', molecule.natom())\n""""""); for envv in db_tabulate:; freagent.write(""""""psi4.print_out('DATABASE RESULT: computation %d for reagent %s """"""; % (os.getpid(), rgt)); freagent.write(""""""yields variable value %20.12f for variable %s\\n' % (psi4.get_variable(""""""); freagent.write(""""""'%s'), '%s'))\n"""""" % (envv.upper(), envv.upper())); freagent.close(). elif (db_mode.lower() == 'reap'):; ERGT[rgt] = 0.0; for envv in db_tabulate:; VRGT[rgt][envv.upper()] = 0.0; exec(banners); exec(actives); try:; freagent = open('%s.out' % (rgt), 'r'); except IOError:; psi4.print_out('Warning: Output file \'%s.out\' not found.\n' % (rgt)); psi4.print_out(' Database summary will have 0.0 and **** in its place.\n'); else:; while 1:; line = freagent.readline(); if not line:; if ERGT[rgt] == 0.0:; psi4.print_out('Warning: Output file \'%s.out\' has no DATABASE RESULT line.\n' % (rgt)); psi4.print_out(' Database summar",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:45404,energy,energy,45404,psi4manual/4.0b5/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html,2,['energy'],['energy']
Energy Efficiency,"Y', findif_meta_dict[""reference""][""energy""]); wfn.set_variable('CURRENT ENERGY', findif_meta_dict[""reference""][""energy""]). core.set_global_option(""PARENT_SYMMETRY"", """"); optstash.restore(); optstash_conv.restore(). else:; core.print_out(""""""hessian() will perform frequency computation by finite difference of analytic energies.\n""""""). # Set method-dependent scf convergence criteria (test on procedures['energy'] since that's guaranteed); optstash.restore(); optstash_conv.restore(); optstash_conv = driver_util._set_convergence_criterion('energy', lowername, 10, 11, 10, 11, 10). # Obtain list of displacements; findif_meta_dict = driver_findif.hessian_from_energies_geometries(molecule, irrep). # Record undisplaced symmetry for projection of diplaced point groups; core.set_global_option(""PARENT_SYMMETRY"", molecule.schoenflies_symbol()). ndisp = len(findif_meta_dict[""displacements""]) + 1. print(' %d displacements needed.' % ndisp). wfn = _process_displacement(energy, lowername, molecule, findif_meta_dict[""reference""], 1, ndisp,; **kwargs); var_dict = core.variables(). for n, displacement in enumerate(findif_meta_dict[""displacements""].values(), start=2):; _process_displacement(; energy, lowername, molecule, displacement, n, ndisp, write_orbitals=False, **kwargs). # Reset variables; for key, val in var_dict.items():; core.set_variable(key, val). # Assemble Hessian from energies; H = driver_findif.assemble_hessian_from_energies(findif_meta_dict, irrep); wfn.set_hessian(core.Matrix.from_array(H)); wfn.set_gradient(G0). # Explicitly set the current energy..; core.set_variable('CURRENT ENERGY', findif_meta_dict[""reference""][""energy""]); wfn.set_variable('CURRENT ENERGY', findif_meta_dict[""reference""][""energy""]). core.set_global_option(""PARENT_SYMMETRY"", """"); optstash.restore(); optstash_conv.restore(). _hessian_write(wfn). if return_wfn:; return (wfn.hessian(), wfn); else:; return wfn.hessian(). [docs]def frequency(name, **kwargs):; r""""""Function to compute harmonic vibrational freq",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:80925,energy,energy,80925,psi4manual/1.4.0/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html,2,['energy'],['energy']
Energy Efficiency,"Y', findif_meta_dict[""reference""][""energy""]); wfn.set_variable('CURRENT ENERGY', findif_meta_dict[""reference""][""energy""]). core.set_global_option(""PARENT_SYMMETRY"", """"); optstash.restore(); optstash_conv.restore(). else:; core.print_out(""""""hessian() will perform frequency computation by finite difference of analytic energies.\n""""""). # Set method-dependent scf convergence criteria (test on procedures['energy'] since that's guaranteed); optstash.restore(); optstash_conv.restore(); optstash_conv = driver_util._set_convergence_criterion('energy', lowername, 10, 11, 10, 11, 10). # Obtain list of displacements; findif_meta_dict = driver_findif.hessian_from_energies_geometries(molecule, irrep). # Record undisplaced symmetry for projection of diplaced point groups; core.set_global_option(""PARENT_SYMMETRY"", molecule.schoenflies_symbol()). ndisp = len(findif_meta_dict[""displacements""]) + 1. print(' %d displacements needed.' % ndisp). wfn = _process_displacement(energy, lowername, molecule, findif_meta_dict[""reference""], 1, ndisp,; **kwargs); var_dict = core.variables(). for n, displacement in enumerate(findif_meta_dict[""displacements""].values(), start=2):; _process_displacement(; energy, lowername, molecule, displacement, n, ndisp, write_orbitals=False, **kwargs). # Reset variables; for key, val in var_dict.items():; core.set_variable(key, val). # Assemble Hessian from energies; H = driver_findif.assemble_hessian_from_energies(findif_meta_dict, irrep); wfn.set_hessian(core.Matrix.from_array(H)); wfn.set_gradient(G0). # Explicitly set the current energy..; if isinstance(lowername, str) and lowername in procedures['energy']:; # this correctly filters out cbs fn and ""hf/cc-pvtz""; # it probably incorrectly filters out mp5, but reconsider in DDD; core.set_variable(f""CURRENT HESSIAN"", H); core.set_variable(f""{lowername.upper()} TOTAL HESSIAN"", H); core.set_variable(f""{lowername.upper()} TOTAL GRADIENT"", G0); wfn.set_variable(f""{lowername.upper()} TOTAL HESSIAN"", H); wfn.set_variable",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/_modules/psi4/driver/driver.html:81622,energy,energy,81622,psi4manual/1.5.0/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/_modules/psi4/driver/driver.html,2,['energy'],['energy']
Energy Efficiency,"Y. If the method is neither a; double-hybrid, nor dispersion corrected, this quantity is equal to; DFT FUNCTIONAL TOTAL ENERGY. DFT XC ENERGY¶; The functional energy contribution [H] to the total SCF energy (DFT only).; Quantity in Eqs. (3) and (1). DISPERSION CORRECTION ENERGY¶; The dispersion correction [H] appended to an underlying functional; when a DFT-D method is requested. Quantity ; in Eqs. (3) and (1). DOUBLE-HYBRID CORRECTION ENERGY¶; The scaled MP2 correlation energy correction [H] appended to an; underlying functional when a DH-DFT method is requested.; Quantity in Eq. (1). FCI TOTAL ENERGY¶. FCI CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the full configuration interaction level of theory. HF TOTAL ENERGY¶; The total electronic energy [H] for the Hartree–Fock method, without; any dispersion correction; the first three (or four, since; ) terms in Eq. (3). Quantity ; in Eq. (3). LCC2 (+LMP2) TOTAL ENERGY¶; The total electronic energy [H] for the local CC2 level of theory. LCCSD (+LMP2) TOTAL ENERGY¶; The total electronic energy [H] for the local CCSD level of theory. MP2 TOTAL ENERGY¶. MP2 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the MP2 level of theory. MP2.5 TOTAL ENERGY¶. MP2.5 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the MP2.5 level of theory. MP3 TOTAL ENERGY¶. MP3 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the MP3 level of theory. MPn TOTAL ENERGY¶. MPn CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the labeled Möller–Plesset perturbation theory level.; n is MP perturbation order. NUCLEAR REPULSION ENERGY¶; The nuclear repulsion energy contribution [H] to the total SCF energy.; Quantity in Eq. (3). (2). ONE-ELECTRON ENERGY¶; The one-electron energy contribution [H] to the total SCF energy.; Quant",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/glossary_psivariables-1.html:11653,energy,energy,11653,psi4manual/4.0b3/glossary_psivariables-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/glossary_psivariables-1.html,2,['energy'],['energy']
Energy Efficiency,"Y. If the method is neither a; double-hybrid, nor dispersion corrected, this quantity is equal to; DFT FUNCTIONAL TOTAL ENERGY. DFT XC ENERGY¶; The functional energy contribution [H] to the total SCF energy (DFT only).; Quantity in Eqs. (4) and (1). DISPERSION CORRECTION ENERGY¶; The dispersion correction [H] appended to an underlying functional; when a DFT-D method is requested. Quantity ; in Eqs. (4) and (1). DOUBLE-HYBRID CORRECTION ENERGY¶; The scaled MP2 correlation energy correction [H] appended to an; underlying functional when a DH-DFT method is requested.; Quantity in Eq. (1). FCI TOTAL ENERGY¶. FCI CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the full configuration interaction level of theory. HF TOTAL ENERGY¶; The total electronic energy [H] for the Hartree–Fock method, without; any dispersion correction; the first three (or four, since; ) terms in Eq. (4). Quantity ; in Eq. (4). LCC2 (+LMP2) TOTAL ENERGY¶; The total electronic energy [H] for the local CC2 level of theory. LCCSD (+LMP2) TOTAL ENERGY¶; The total electronic energy [H] for the local CCSD level of theory. MP2 TOTAL ENERGY¶. MP2 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the MP2 level of theory. MP2.5 TOTAL ENERGY¶. MP2.5 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the MP2.5 level of theory. MP3 TOTAL ENERGY¶. MP3 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the MP3 level of theory. MP4(SDQ) TOTAL ENERGY¶. MP4(SDQ) CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the MP4 singles, doubles, quadruples level of theory. Quantity; MP4(SDQ) CORRELATION ENERGY is; first right-hand term in Eq. (2). MP4 TOTAL ENERGY¶. MP4 CORRELATION ENERGY¶. MP4(SDTQ) TOTAL ENERGY¶. MP4(SDTQ) CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy compone",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/glossary_psivariables-1.html:11847,energy,energy,11847,psi4manual/1.0.0/glossary_psivariables-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/glossary_psivariables-1.html,6,['energy'],['energy']
Energy Efficiency,"Y. PROPERTY (CCSORT); CCSORT — The response property desired. The unique acceptable values is POLARIZABILITY for dipole-polarizabilitie. Type: string; Default: POLARIZABILITY. PSIMRCC (TRANSQT); TRANSQT — Do specific arrangements for PSIMRCC?. Type: boolean; Default: false. PT_ENERGY (PSIMRCC); PSIMRCC — The type of perturbation theory computation to perform. Type: string; Possible Values: SECOND_ORDER, SCS_SECOND_ORDER, PSEUDO_SECOND_ORDER, SCS_PSEUDO_SECOND_ORDER; Default: SECOND_ORDER. PUREAM (GLOBALS); GLOBALS — Do use pure angular momentum basis functions? If not explicitly set, the default comes from the basis set. Type: boolean; Default: true. QC_COUPLING (DCFT); DCFT — Controls whether to include the coupling terms in the DCFT electronic Hessian (for ALOGRITHM = QC only). Type: boolean; Default: true. QRHF (TRANSQT); TRANSQT — Do form quasi RHF (QRHF) orbitals?. Type: boolean; Default: false. R4S (DETCI); DETCI (Expert) — Do restrict strings with in RAS IV? Useful to reduce the number of strings required if MIXED4=true, as in a split-virutal CISD[TQ] computation. If more than one electron is in RAS IV, then the holes in RAS I cannot exceed the number of particles in RAS III + RAS IV (i.e., EX_LEVEL), or else the string is discarded. Type: boolean; Default: false. R_CONVERGENCE (CCENERGY); CCENERGY — Convergence criterion for T2 amplitudes (RMS change). Type: conv double; Default: 1e-5. R_CONVERGENCE (CCEOM); CCEOM — Convergence criterion for norm of the residual vector in the Davidson algorithm for CC-EOM. Type: conv double; Default: 1e-6. R_CONVERGENCE (CCLAMBDA); CCLAMBDA — Convergence criterion for wavefunction (change) in CC lambda-amplitude equations. Type: conv double; Default: 1e-7. R_CONVERGENCE (CCRESPONSE); CCRESPONSE — Convergence criterion for wavefunction (change) in perturbed CC equations. Type: conv double; Default: 1e-7. R_CONVERGENCE (DCFT); DCFT — Convergence criterion for the RMS of the residual vector in the density cumulant updates, as w",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/autodoc_glossary_options_c-1.html:100819,reduce,reduce,100819,psi4manual/4.0b5/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodoc_glossary_options_c-1.html,2,['reduce'],['reduce']
Energy Efficiency,Y; ABB (T) CORRECTION ENERGY; BBB (T) CORRECTION ENERGY; BRUECKNER CONVERGED; CC ALPHA-ALPHA PAIR ENERGIES (array); CC ALPHA-BETA PAIR ENERGIES (array); CC CORRELATION ENERGY; CC D1 DIAGNOSTIC; CC D2 DIAGNOSTIC; CC NEW D1 DIAGNOSTIC; CC SINGLET PAIR ENERGIES (array); CC T1 DIAGNOSTIC; CC TOTAL ENERGY; CC TRIPLET PAIR ENERGIES (array); CC2 ALPHA-ALPHA PAIR ENERGIES; CC2 ALPHA-BETA PAIR ENERGIES; CC2 CORRELATION ENERGY; CC2 DIPOLE POLARIZABILITY @ xNM; CC2 DIPOLE POLARIZABILITY TENSOR @ xNM; CC2 QUADRUPOLE POLARIZABILITY TENSOR @ xNM; CC2 ROTATION (LEN) ORIGIN-DEPENDENCE @ xNM; CC2 SINGLET PAIR ENERGIES; CC2 SPECIFIC ROTATION (LEN) @ xNM; CC2 SPECIFIC ROTATION (MVG) @ xNM; CC2 SPECIFIC ROTATION (VEL) @ xNM; CC2 TOTAL ENERGY; CC2 TRIPLET PAIR ENERGIES; CC3 ALPHA-ALPHA PAIR ENERGIES; CC3 ALPHA-BETA PAIR ENERGIES; CC3 CORRELATION ENERGY; CC3 SINGLET PAIR ENERGIES; CC3 TOTAL ENERGY; CC3 TRIPLET PAIR ENERGIES; CCSD ALPHA-ALPHA PAIR ENERGIES; CCSD ALPHA-BETA PAIR ENERGIES; CCSD CORRELATION ENERGY; CCSD DIPOLE POLARIZABILITY @ xNM; CCSD DIPOLE POLARIZABILITY TENSOR @ xNM; CCSD DOUBLES ENERGY; CCSD ITERATIONS; CCSD OPPOSITE-SPIN CORRELATION ENERGY; CCSD QUADRUPOLE POLARIZABILITY TENSOR @ xNM; CCSD ROTATION (LEN) ORIGIN-DEPENDENCE @ xNM; CCSD SAME-SPIN CORRELATION ENERGY; CCSD SINGLES ENERGY; CCSD SINGLET PAIR ENERGIES; CCSD SPECIFIC ROTATION (LEN) @ xNM; CCSD SPECIFIC ROTATION (MVG) @ xNM; CCSD SPECIFIC ROTATION (VEL) @ xNM; CCSD TOTAL ENERGY; CCSD TRIPLET PAIR ENERGIES; CCSD(T) CORRELATION ENERGY; CCSD(T) TOTAL ENERGY; CCname ROOT m (IN h) -> ROOT n (IN i) EINSTEIN A (LEN); CCname ROOT m (IN h) -> ROOT n (IN i) EINSTEIN B (LEN); CCname ROOT m (IN h) -> ROOT n (IN i) OSCILLATOR STRENGTH (LEN); CCname ROOT m (IN h) -> ROOT n (IN i) ROTATORY STRENGTH (LEN); CCname ROOT m (IN h) -> ROOT n (IN i) ROTATORY STRENGTH (VEL); CCname ROOT m (h) -> ROOT n (i) EINSTEIN A (LEN); CCname ROOT m (h) -> ROOT n (i) EINSTEIN B (LEN); CCname ROOT m (h) -> ROOT n (i) OSCILLATOR STRENGTH (LEN); CCn,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/autodir_psivariables/module__ccenergy.html:1375,ENERGY,ENERGY,1375,psi4manual/1.6.x/autodir_psivariables/module__ccenergy.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/autodir_psivariables/module__ccenergy.html,1,['ENERGY'],['ENERGY']
Energy Efficiency,Y; ACPF TOTAL ENERGY; AQCC CORRELATION ENERGY; AQCC OPPOSITE-SPIN CORRELATION ENERGY; AQCC SAME-SPIN CORRELATION ENERGY; AQCC TOTAL ENERGY; CC ALPHA-ALPHA PAIR ENERGIES (array); CC ALPHA-BETA PAIR ENERGIES (array); CC D1 DIAGNOSTIC; CC SINGLET PAIR ENERGIES (array); CC T1 DIAGNOSTIC; CC TRIPLET PAIR ENERGIES (array); CCSD ALPHA-ALPHA PAIR ENERGIES (array); CCSD ALPHA-BETA PAIR ENERGIES (array); CCSD CORRELATION ENERGY; CCSD DOUBLES ENERGY; CCSD ITERATIONS; CCSD OPPOSITE-SPIN CORRELATION ENERGY; CCSD SAME-SPIN CORRELATION ENERGY; CCSD SINGLES ENERGY; CCSD SINGLET PAIR ENERGIES (array); CCSD TOTAL ENERGY; CCSD TRIPLET PAIR ENERGIES (array); CCSD(T) CORRELATION ENERGY; CCSD(T) TOTAL ENERGY; CEPA(0) CORRELATION ENERGY; CEPA(0) DOUBLES ENERGY; CEPA(0) OPPOSITE-SPIN CORRELATION ENERGY; CEPA(0) SAME-SPIN CORRELATION ENERGY; CEPA(0) SINGLES ENERGY; CEPA(0) TOTAL ENERGY; CEPA(1) CORRELATION ENERGY; CEPA(1) OPPOSITE-SPIN CORRELATION ENERGY; CEPA(1) SAME-SPIN CORRELATION ENERGY; CEPA(1) TOTAL ENERGY; CEPA(2) CORRELATION ENERGY; CEPA(2) OPPOSITE-SPIN CORRELATION ENERGY; CEPA(2) SAME-SPIN CORRELATION ENERGY; CEPA(2) TOTAL ENERGY; CEPA(3) CORRELATION ENERGY; CEPA(3) OPPOSITE-SPIN CORRELATION ENERGY; CEPA(3) SAME-SPIN CORRELATION ENERGY; CEPA(3) TOTAL ENERGY; CISD CORRELATION ENERGY; CISD OPPOSITE-SPIN CORRELATION ENERGY; CISD SAME-SPIN CORRELATION ENERGY; CISD TOTAL ENERGY; CURRENT CORRELATION ENERGY; CURRENT ENERGY; LCCD CORRELATION ENERGY; LCCD DOUBLES ENERGY; LCCD OPPOSITE-SPIN CORRELATION ENERGY; LCCD SAME-SPIN CORRELATION ENERGY; LCCD SINGLES ENERGY; LCCD TOTAL ENERGY; LCCSD CORRELATION ENERGY; LCCSD DOUBLES ENERGY; LCCSD OPPOSITE-SPIN CORRELATION ENERGY; LCCSD SAME-SPIN CORRELATION ENERGY; LCCSD SINGLES ENERGY; LCCSD TOTAL ENERGY; MP2 ALPHA-ALPHA PAIR ENERGIES (array); MP2 ALPHA-BETA PAIR ENERGIES (array); MP2 CORRELATION ENERGY; MP2 DOUBLES ENERGY; MP2 OPPOSITE-SPIN CORRELATION ENERGY; MP2 SAME-SPIN CORRELATION ENERGY; MP2 SINGLES ENERGY; MP2 SINGLET PAIR ENERGIES (array); ,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/autodir_psivariables/module__fnocc.html:1246,ENERGY,ENERGY,1246,psi4manual/1.6.x/autodir_psivariables/module__fnocc.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/autodir_psivariables/module__fnocc.html,1,['ENERGY'],['ENERGY']
Energy Efficiency,Y; AQCC DOUBLES ENERGY; AQCC OPPOSITE-SPIN CORRELATION ENERGY; AQCC SAME-SPIN CORRELATION ENERGY; AQCC SINGLES ENERGY; AQCC TOTAL ENERGY; CC ALPHA-ALPHA PAIR ENERGIES (array); CC ALPHA-BETA PAIR ENERGIES (array); CC D1 DIAGNOSTIC; CC SINGLET PAIR ENERGIES (array); CC T1 DIAGNOSTIC; CC TRIPLET PAIR ENERGIES (array); CCSD ALPHA-ALPHA PAIR ENERGIES (array); CCSD ALPHA-BETA PAIR ENERGIES (array); CCSD CORRELATION ENERGY; CCSD DOUBLES ENERGY; CCSD ITERATIONS; CCSD OPPOSITE-SPIN CORRELATION ENERGY; CCSD SAME-SPIN CORRELATION ENERGY; CCSD SINGLES ENERGY; CCSD SINGLET PAIR ENERGIES (array); CCSD TOTAL ENERGY; CCSD TRIPLET PAIR ENERGIES (array); CCSD(T) CORRELATION ENERGY; CCSD(T) TOTAL ENERGY; CEPA(0) CORRELATION ENERGY; CEPA(0) DOUBLES ENERGY; CEPA(0) OPPOSITE-SPIN CORRELATION ENERGY; CEPA(0) SAME-SPIN CORRELATION ENERGY; CEPA(0) SINGLES ENERGY; CEPA(0) TOTAL ENERGY; CEPA(1) CORRELATION ENERGY; CEPA(1) DOUBLES ENERGY; CEPA(1) OPPOSITE-SPIN CORRELATION ENERGY; CEPA(1) SAME-SPIN CORRELATION ENERGY; CEPA(1) SINGLES ENERGY; CEPA(1) TOTAL ENERGY; CEPA(2) CORRELATION ENERGY; CEPA(2) DOUBLES ENERGY; CEPA(2) OPPOSITE-SPIN CORRELATION ENERGY; CEPA(2) SAME-SPIN CORRELATION ENERGY; CEPA(2) SINGLES ENERGY; CEPA(2) TOTAL ENERGY; CEPA(3) CORRELATION ENERGY; CEPA(3) DOUBLES ENERGY; CEPA(3) OPPOSITE-SPIN CORRELATION ENERGY; CEPA(3) SAME-SPIN CORRELATION ENERGY; CEPA(3) SINGLES ENERGY; CEPA(3) TOTAL ENERGY; CISD CORRELATION ENERGY; CISD OPPOSITE-SPIN CORRELATION ENERGY; CISD SAME-SPIN CORRELATION ENERGY; CISD TOTAL ENERGY; CURRENT CORRELATION ENERGY; CURRENT ENERGY; LCCD CORRELATION ENERGY; LCCD DOUBLES ENERGY; LCCD OPPOSITE-SPIN CORRELATION ENERGY; LCCD SAME-SPIN CORRELATION ENERGY; LCCD SINGLES ENERGY; LCCD TOTAL ENERGY; LCCSD CORRELATION ENERGY; LCCSD DOUBLES ENERGY; LCCSD OPPOSITE-SPIN CORRELATION ENERGY; LCCSD SAME-SPIN CORRELATION ENERGY; LCCSD SINGLES ENERGY; LCCSD TOTAL ENERGY; MP2 ALPHA-ALPHA PAIR ENERGIES (array); MP2 ALPHA-BETA PAIR ENERGIES (array); MP2 CORRELATION ENERGY; MP2 D,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/autodir_psivariables/module__fnocc.html:1332,ENERGY,ENERGY,1332,psi4manual/1.7.x/autodir_psivariables/module__fnocc.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/autodir_psivariables/module__fnocc.html,4,['ENERGY'],['ENERGY']
Energy Efficiency,"Y; CEPA(2) TOTAL ENERGY; CEPA(3) CORRELATION ENERGY; CEPA(3) DOUBLES ENERGY; CEPA(3) OPPOSITE-SPIN CORRELATION ENERGY; CEPA(3) SAME-SPIN CORRELATION ENERGY; CEPA(3) SINGLES ENERGY; CEPA(3) TOTAL ENERGY; CISD CORRELATION ENERGY; CISD OPPOSITE-SPIN CORRELATION ENERGY; CISD SAME-SPIN CORRELATION ENERGY; CISD TOTAL ENERGY; CURRENT CORRELATION ENERGY; CURRENT ENERGY; LCCD CORRELATION ENERGY; LCCD DOUBLES ENERGY; LCCD OPPOSITE-SPIN CORRELATION ENERGY; LCCD SAME-SPIN CORRELATION ENERGY; LCCD SINGLES ENERGY; LCCD TOTAL ENERGY; LCCSD CORRELATION ENERGY; LCCSD DOUBLES ENERGY; LCCSD OPPOSITE-SPIN CORRELATION ENERGY; LCCSD SAME-SPIN CORRELATION ENERGY; LCCSD SINGLES ENERGY; LCCSD TOTAL ENERGY; MP2 ALPHA-ALPHA PAIR ENERGIES (array); MP2 ALPHA-BETA PAIR ENERGIES (array); MP2 CORRELATION ENERGY; MP2 DOUBLES ENERGY; MP2 OPPOSITE-SPIN CORRELATION ENERGY; MP2 SAME-SPIN CORRELATION ENERGY; MP2 SINGLES ENERGY; MP2 SINGLET PAIR ENERGIES (array); MP2 TOTAL ENERGY; MP2 TRIPLET PAIR ENERGIES (array); MP2.5 CORRELATION ENERGY; MP2.5 DOUBLES ENERGY; MP2.5 OPPOSITE-SPIN CORRELATION ENERGY; MP2.5 SAME-SPIN CORRELATION ENERGY; MP2.5 SINGLES ENERGY; MP2.5 TOTAL ENERGY; MP3 CORRELATION ENERGY; MP3 DOUBLES ENERGY; MP3 OPPOSITE-SPIN CORRELATION ENERGY; MP3 SAME-SPIN CORRELATION ENERGY; MP3 SINGLES ENERGY; MP3 TOTAL ENERGY; MP4 CORRELATION ENERGY; MP4 TOTAL ENERGY; MP4(SDQ) CORRELATION ENERGY; MP4(SDQ) TOTAL ENERGY; MP4(SDTQ) CORRELATION ENERGY; MP4(SDTQ) TOTAL ENERGY; MP4(T) CORRECTION ENERGY; NAUX (CC); NAUX (SCF); QCISD CORRELATION ENERGY; QCISD OPPOSITE-SPIN CORRELATION ENERGY; QCISD SAME-SPIN CORRELATION ENERGY; QCISD TOTAL ENERGY; QCISD(T) CORRECTION ENERGY; QCISD(T) CORRELATION ENERGY; QCISD(T) TOTAL ENERGY; SCF TOTAL ENERGY. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.7;  · . PSI4. Appendices; PSI Variables by Module; FNOCC. © Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/autodir_psivariables/module__fnocc.html:2549,ENERGY,ENERGY,2549,psi4manual/1.7.x/autodir_psivariables/module__fnocc.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/autodir_psivariables/module__fnocc.html,27,['ENERGY'],['ENERGY']
Energy Efficiency,Y; CURRENT ENERGY; CURRENT REFERENCE ENERGY; CUSTOM SCS-LCCD CORRELATION ENERGY; CUSTOM SCS-LCCD TOTAL ENERGY; CUSTOM SCS-MP2 CORRELATION ENERGY; CUSTOM SCS-MP2 TOTAL ENERGY; CUSTOM SCS-MP2.5 CORRELATION ENERGY; CUSTOM SCS-MP2.5 TOTAL ENERGY; CUSTOM SCS-MP3 CORRELATION ENERGY; CUSTOM SCS-MP3 TOTAL ENERGY; CUSTOM SCS-OLCCD CORRELATION ENERGY; CUSTOM SCS-OLCCD TOTAL ENERGY; CUSTOM SCS-OMP2 CORRELATION ENERGY; CUSTOM SCS-OMP2 TOTAL ENERGY; CUSTOM SCS-OMP3 CORRELATION ENERGY; CUSTOM SCS-OMP3 TOTAL ENERGY; CUSTOM SCS-OREMP2 CORRELATION ENERGY; CUSTOM SCS-OREMP2 TOTAL ENERGY; CUSTOM SCS-REMP2 CORRELATION ENERGY; CUSTOM SCS-REMP2 TOTAL ENERGY; LCCD CORRELATION ENERGY; LCCD DOUBLES ENERGY; LCCD OPPOSITE-SPIN CORRELATION ENERGY; LCCD SAME-SPIN CORRELATION ENERGY; LCCD SINGLES ENERGY; LCCD TOTAL ENERGY; MP2 CORRELATION ENERGY; MP2 DOUBLES ENERGY; MP2 OPPOSITE-SPIN CORRELATION ENERGY; MP2 SAME-SPIN CORRELATION ENERGY; MP2 SINGLES ENERGY; MP2 TOTAL ENERGY; MP2.5 CORRELATION ENERGY; MP2.5 DOUBLES ENERGY; MP2.5 OPPOSITE-SPIN CORRELATION ENERGY; MP2.5 SAME-SPIN CORRELATION ENERGY; MP2.5 SINGLES ENERGY; MP2.5 TOTAL ENERGY; MP3 CORRELATION ENERGY; MP3 DOUBLES ENERGY; MP3 OPPOSITE-SPIN CORRELATION ENERGY; MP3 SAME-SPIN CORRELATION ENERGY; MP3 SINGLES ENERGY; MP3 TOTAL ENERGY; OLCCD CORRELATION ENERGY; OLCCD OPPOSITE-SPIN CORRELATION ENERGY; OLCCD REFERENCE CORRECTION ENERGY; OLCCD SAME-SPIN CORRELATION ENERGY; OLCCD TOTAL ENERGY; OMP2 CORRELATION ENERGY; OMP2 OPPOSITE-SPIN CORRELATION ENERGY; OMP2 REFERENCE CORRECTION ENERGY; OMP2 SAME-SPIN CORRELATION ENERGY; OMP2 TOTAL ENERGY; OMP2.5 CORRELATION ENERGY; OMP2.5 OPPOSITE-SPIN CORRELATION ENERGY; OMP2.5 REFERENCE CORRECTION ENERGY; OMP2.5 SAME-SPIN CORRELATION ENERGY; OMP2.5 TOTAL ENERGY; OMP3 CORRELATION ENERGY; OMP3 OPPOSITE-SPIN CORRELATION ENERGY; OMP3 REFERENCE CORRECTION ENERGY; OMP3 SAME-SPIN CORRELATION ENERGY; OMP3 TOTAL ENERGY; OREMP2 CORRELATION ENERGY; OREMP2 OPPOSITE-SPIN CORRELATION ENERGY; OREMP2 REFERENCE CORRECTION EN,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/autodir_psivariables/module__occ.html:1234,ENERGY,ENERGY,1234,psi4manual/1.7.x/autodir_psivariables/module__occ.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/autodir_psivariables/module__occ.html,4,['ENERGY'],['ENERGY']
Energy Efficiency,"Y; LCCD SAME-SPIN CORRELATION ENERGY; LCCD SINGLES ENERGY; LCCD TOTAL ENERGY; MP2 CORRELATION ENERGY; MP2 DOUBLES ENERGY; MP2 OPPOSITE-SPIN CORRELATION ENERGY; MP2 SAME-SPIN CORRELATION ENERGY; MP2 SINGLES ENERGY; MP2 TOTAL ENERGY; MP2.5 CORRELATION ENERGY; MP2.5 DOUBLES ENERGY; MP2.5 OPPOSITE-SPIN CORRELATION ENERGY; MP2.5 SAME-SPIN CORRELATION ENERGY; MP2.5 SINGLES ENERGY; MP2.5 TOTAL ENERGY; MP3 CORRELATION ENERGY; MP3 DOUBLES ENERGY; MP3 OPPOSITE-SPIN CORRELATION ENERGY; MP3 SAME-SPIN CORRELATION ENERGY; MP3 SINGLES ENERGY; MP3 TOTAL ENERGY; NAUX (SCF); OLCCD CORRELATION ENERGY; OLCCD OPPOSITE-SPIN CORRELATION ENERGY; OLCCD REFERENCE CORRECTION ENERGY; OLCCD SAME-SPIN CORRELATION ENERGY; OLCCD TOTAL ENERGY; OMP2 CORRELATION ENERGY; OMP2 OPPOSITE-SPIN CORRELATION ENERGY; OMP2 REFERENCE CORRECTION ENERGY; OMP2 SAME-SPIN CORRELATION ENERGY; OMP2 TOTAL ENERGY; OMP2.5 CORRELATION ENERGY; OMP2.5 OPPOSITE-SPIN CORRELATION ENERGY; OMP2.5 REFERENCE CORRECTION ENERGY; OMP2.5 SAME-SPIN CORRELATION ENERGY; OMP2.5 TOTAL ENERGY; OMP3 CORRELATION ENERGY; OMP3 OPPOSITE-SPIN CORRELATION ENERGY; OMP3 REFERENCE CORRECTION ENERGY; OMP3 SAME-SPIN CORRELATION ENERGY; OMP3 TOTAL ENERGY; OREMP2 CORRELATION ENERGY; OREMP2 REFERENCE CORRECTION ENERGY; OREMP2 TOTAL ENERGY; REMP2 CORRELATION ENERGY; REMP2 DOUBLES ENERGY; REMP2 OPPOSITE-SPIN CORRELATION ENERGY; REMP2 SAME-SPIN CORRELATION ENERGY; REMP2 SINGLES ENERGY; REMP2 TOTAL ENERGY; SCF TOTAL ENERGY; SCS(N)-MP2 CORRELATION ENERGY; SCS(N)-MP2 TOTAL ENERGY; SCS(N)-OMP2 CORRELATION ENERGY; SCS(N)-OMP2 TOTAL ENERGY; SCS-MP2 CORRELATION ENERGY; SCS-MP2 TOTAL ENERGY; SCS-OMP2 CORRELATION ENERGY; SCS-OMP2 TOTAL ENERGY; SOS-MP2 CORRELATION ENERGY; SOS-MP2 TOTAL ENERGY; SOS-OMP2 CORRELATION ENERGY; SOS-OMP2 TOTAL ENERGY. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; PSI Variables by Module; DFOCC. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 No",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/autodir_psivariables/module__dfocc.html:1718,ENERGY,ENERGY,1718,psi4manual/master/autodir_psivariables/module__dfocc.html,https://psicode.org,https://psicode.org/psi4manual/master/autodir_psivariables/module__dfocc.html,1,['ENERGY'],['ENERGY']
Energy Efficiency,"Y; LCCD SAME-SPIN CORRELATION ENERGY; LCCD SINGLES ENERGY; LCCD TOTAL ENERGY; MP2 CORRELATION ENERGY; MP2 DOUBLES ENERGY; MP2 OPPOSITE-SPIN CORRELATION ENERGY; MP2 SAME-SPIN CORRELATION ENERGY; MP2 SINGLES ENERGY; MP2 TOTAL ENERGY; MP2.5 CORRELATION ENERGY; MP2.5 DOUBLES ENERGY; MP2.5 OPPOSITE-SPIN CORRELATION ENERGY; MP2.5 SAME-SPIN CORRELATION ENERGY; MP2.5 SINGLES ENERGY; MP2.5 TOTAL ENERGY; MP3 CORRELATION ENERGY; MP3 DOUBLES ENERGY; MP3 OPPOSITE-SPIN CORRELATION ENERGY; MP3 SAME-SPIN CORRELATION ENERGY; MP3 SINGLES ENERGY; MP3 TOTAL ENERGY; NAUX (SCF); OLCCD CORRELATION ENERGY; OLCCD OPPOSITE-SPIN CORRELATION ENERGY; OLCCD REFERENCE CORRECTION ENERGY; OLCCD SAME-SPIN CORRELATION ENERGY; OLCCD TOTAL ENERGY; OMP2 CORRELATION ENERGY; OMP2 OPPOSITE-SPIN CORRELATION ENERGY; OMP2 REFERENCE CORRECTION ENERGY; OMP2 SAME-SPIN CORRELATION ENERGY; OMP2 TOTAL ENERGY; OMP2.5 CORRELATION ENERGY; OMP2.5 OPPOSITE-SPIN CORRELATION ENERGY; OMP2.5 REFERENCE CORRECTION ENERGY; OMP2.5 SAME-SPIN CORRELATION ENERGY; OMP2.5 TOTAL ENERGY; OMP3 CORRELATION ENERGY; OMP3 OPPOSITE-SPIN CORRELATION ENERGY; OMP3 REFERENCE CORRECTION ENERGY; OMP3 SAME-SPIN CORRELATION ENERGY; OMP3 TOTAL ENERGY; OREMP2 CORRELATION ENERGY; OREMP2 REFERENCE CORRECTION ENERGY; OREMP2 TOTAL ENERGY; REMP2 CORRELATION ENERGY; REMP2 DOUBLES ENERGY; REMP2 OPPOSITE-SPIN CORRELATION ENERGY; REMP2 SAME-SPIN CORRELATION ENERGY; REMP2 SINGLES ENERGY; REMP2 TOTAL ENERGY; SCF TOTAL ENERGY; SCS(N)-MP2 CORRELATION ENERGY; SCS(N)-MP2 TOTAL ENERGY; SCS(N)-OMP2 CORRELATION ENERGY; SCS(N)-OMP2 TOTAL ENERGY; SCS-MP2 CORRELATION ENERGY; SCS-MP2 TOTAL ENERGY; SCS-OMP2 CORRELATION ENERGY; SCS-OMP2 TOTAL ENERGY; SOS-MP2 CORRELATION ENERGY; SOS-MP2 TOTAL ENERGY; SOS-OMP2 CORRELATION ENERGY; SOS-OMP2 TOTAL ENERGY. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.7;  · . PSI4. Appendices; PSI Variables by Module; DFOCC. © Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 202",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/autodir_psivariables/module__dfocc.html:1709,ENERGY,ENERGY,1709,psi4manual/1.7.x/autodir_psivariables/module__dfocc.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/autodir_psivariables/module__dfocc.html,1,['ENERGY'],['ENERGY']
Energy Efficiency,"Y; LCCD SAME-SPIN CORRELATION ENERGY; LCCD SINGLES ENERGY; LCCD TOTAL ENERGY; MP2 CORRELATION ENERGY; MP2 DOUBLES ENERGY; MP2 OPPOSITE-SPIN CORRELATION ENERGY; MP2 SAME-SPIN CORRELATION ENERGY; MP2 SINGLES ENERGY; MP2 TOTAL ENERGY; MP2.5 CORRELATION ENERGY; MP2.5 DOUBLES ENERGY; MP2.5 OPPOSITE-SPIN CORRELATION ENERGY; MP2.5 SAME-SPIN CORRELATION ENERGY; MP2.5 SINGLES ENERGY; MP2.5 TOTAL ENERGY; MP3 CORRELATION ENERGY; MP3 DOUBLES ENERGY; MP3 OPPOSITE-SPIN CORRELATION ENERGY; MP3 SAME-SPIN CORRELATION ENERGY; MP3 SINGLES ENERGY; MP3 TOTAL ENERGY; NAUX (SCF); OLCCD CORRELATION ENERGY; OLCCD OPPOSITE-SPIN CORRELATION ENERGY; OLCCD REFERENCE CORRECTION ENERGY; OLCCD SAME-SPIN CORRELATION ENERGY; OLCCD TOTAL ENERGY; OMP2 CORRELATION ENERGY; OMP2 OPPOSITE-SPIN CORRELATION ENERGY; OMP2 REFERENCE CORRECTION ENERGY; OMP2 SAME-SPIN CORRELATION ENERGY; OMP2 TOTAL ENERGY; OMP2.5 CORRELATION ENERGY; OMP2.5 OPPOSITE-SPIN CORRELATION ENERGY; OMP2.5 REFERENCE CORRECTION ENERGY; OMP2.5 SAME-SPIN CORRELATION ENERGY; OMP2.5 TOTAL ENERGY; OMP3 CORRELATION ENERGY; OMP3 OPPOSITE-SPIN CORRELATION ENERGY; OMP3 REFERENCE CORRECTION ENERGY; OMP3 SAME-SPIN CORRELATION ENERGY; OMP3 TOTAL ENERGY; OREMP2 CORRELATION ENERGY; OREMP2 REFERENCE CORRECTION ENERGY; OREMP2 TOTAL ENERGY; REMP2 CORRELATION ENERGY; REMP2 DOUBLES ENERGY; REMP2 OPPOSITE-SPIN CORRELATION ENERGY; REMP2 SAME-SPIN CORRELATION ENERGY; REMP2 SINGLES ENERGY; REMP2 TOTAL ENERGY; SCF TOTAL ENERGY; SCS(N)-MP2 CORRELATION ENERGY; SCS(N)-MP2 TOTAL ENERGY; SCS(N)-OMP2 CORRELATION ENERGY; SCS(N)-OMP2 TOTAL ENERGY; SCS-MP2 CORRELATION ENERGY; SCS-MP2 TOTAL ENERGY; SCS-OMP2 CORRELATION ENERGY; SCS-OMP2 TOTAL ENERGY; SOS-MP2 CORRELATION ENERGY; SOS-MP2 TOTAL ENERGY; SOS-OMP2 CORRELATION ENERGY; SOS-OMP2 TOTAL ENERGY. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. Appendices; PSI Variables by Module; DFOCC. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/autodir_psivariables/module__dfocc.html:1711,ENERGY,ENERGY,1711,psi4manual/1.8.x/autodir_psivariables/module__dfocc.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/autodir_psivariables/module__dfocc.html,1,['ENERGY'],['ENERGY']
Energy Efficiency,"Y; LCCD SAME-SPIN CORRELATION ENERGY; LCCD SINGLES ENERGY; LCCD TOTAL ENERGY; MP2 CORRELATION ENERGY; MP2 DOUBLES ENERGY; MP2 OPPOSITE-SPIN CORRELATION ENERGY; MP2 SAME-SPIN CORRELATION ENERGY; MP2 SINGLES ENERGY; MP2 TOTAL ENERGY; MP2.5 CORRELATION ENERGY; MP2.5 DOUBLES ENERGY; MP2.5 OPPOSITE-SPIN CORRELATION ENERGY; MP2.5 SAME-SPIN CORRELATION ENERGY; MP2.5 SINGLES ENERGY; MP2.5 TOTAL ENERGY; MP3 CORRELATION ENERGY; MP3 DOUBLES ENERGY; MP3 OPPOSITE-SPIN CORRELATION ENERGY; MP3 SAME-SPIN CORRELATION ENERGY; MP3 SINGLES ENERGY; MP3 TOTAL ENERGY; NAUX (SCF); OLCCD CORRELATION ENERGY; OLCCD OPPOSITE-SPIN CORRELATION ENERGY; OLCCD REFERENCE CORRECTION ENERGY; OLCCD SAME-SPIN CORRELATION ENERGY; OLCCD TOTAL ENERGY; OMP2 CORRELATION ENERGY; OMP2 OPPOSITE-SPIN CORRELATION ENERGY; OMP2 REFERENCE CORRECTION ENERGY; OMP2 SAME-SPIN CORRELATION ENERGY; OMP2 TOTAL ENERGY; OMP2.5 CORRELATION ENERGY; OMP2.5 OPPOSITE-SPIN CORRELATION ENERGY; OMP2.5 REFERENCE CORRECTION ENERGY; OMP2.5 SAME-SPIN CORRELATION ENERGY; OMP2.5 TOTAL ENERGY; OMP3 CORRELATION ENERGY; OMP3 OPPOSITE-SPIN CORRELATION ENERGY; OMP3 REFERENCE CORRECTION ENERGY; OMP3 SAME-SPIN CORRELATION ENERGY; OMP3 TOTAL ENERGY; OREMP2 CORRELATION ENERGY; OREMP2 REFERENCE CORRECTION ENERGY; OREMP2 TOTAL ENERGY; REMP2 CORRELATION ENERGY; REMP2 DOUBLES ENERGY; REMP2 OPPOSITE-SPIN CORRELATION ENERGY; REMP2 SAME-SPIN CORRELATION ENERGY; REMP2 SINGLES ENERGY; REMP2 TOTAL ENERGY; SCF TOTAL ENERGY; SCS(N)-MP2 CORRELATION ENERGY; SCS(N)-MP2 TOTAL ENERGY; SCS(N)-OMP2 CORRELATION ENERGY; SCS(N)-OMP2 TOTAL ENERGY; SCS-MP2 CORRELATION ENERGY; SCS-MP2 TOTAL ENERGY; SCS-OMP2 CORRELATION ENERGY; SCS-OMP2 TOTAL ENERGY; SOS-MP2 CORRELATION ENERGY; SOS-MP2 TOTAL ENERGY; SOS-OMP2 CORRELATION ENERGY; SOS-OMP2 TOTAL ENERGY. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.9.1;  · . PSI4. Appendices; PSI Variables by Module; DFOCC. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/autodir_psivariables/module__dfocc.html:1711,ENERGY,ENERGY,1711,psi4manual/1.9.x/autodir_psivariables/module__dfocc.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/autodir_psivariables/module__dfocc.html,1,['ENERGY'],['ENERGY']
Energy Efficiency,"YPE: MP_TYPE,; CI_TYPE, CC_TYPE, which can have values CONV,; DF, and CD. These are all global keywords, as their values are; shared among modules rather than (or in addition to) being used internally; by the module). We’re sticking with SCF_TYPE and; MP2_TYPE defaulting to DF, while everything higher defaults; to CONV. In psi4/psi4/driver/driver.py, a managed method calls a; “select” function rather than a “run” function.; procedures = {; 'energy': {; 'scf' : run_scf,; 'mp3' : select_mp3,; 'dct' : run_dct,. Then in psi4/psi4/driver/procrouting/proc.py, the select function runs through; reference (always outer loop) and type (inner loop) to specify the proc; function to call for any able, non-default module (e.g., mtd_type ==; 'DETCI' ) or able, default module (e.g., mtd_typd == ['', 'FNOCC'] ).; Don’t worry about ‘else’ statements as anything that falls through will be; caught and a readable error generated.; def select_mp3(name, **kwargs):; """"""Function selecting the algorithm for a MP3 energy call; and directing to specified or best-performance default modules. """"""; reference = psi4.get_option('SCF', 'REFERENCE'); mtd_type = psi4.get_global_option('MP_TYPE'); module = psi4.get_global_option('QC_MODULE'); # Considering only [df]occ/fnocc/detci. func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module == 'DETCI':; func = run_detci; elif module == 'FNOCC':; func = run_fnocc; elif module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc; elif reference == 'UHF':; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc; elif reference == 'ROHF':; if mtd_type == 'CONV':; if module in ['DETCI']:; func = run_detci. if func is None:; raise ManagedMethodError(['select_mp3', name, 'MP_TYPE', mtd_typ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/proc_py-1.html:5069,energy,energy,5069,psi4manual/1.4.0/proc_py-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/proc_py-1.html,5,['energy'],['energy']
Energy Efficiency,"You can run it if you wish.; Once PSI4 is in your path (see the; User Configuration; section of the installation instructions), you can run this computation by typing; 1>>> psi4 input.dat output.dat. If everything goes well, the computation should complete and should report; a final restricted Hartree–Fock energy in a section like this:; 1; 2; 3Energy converged. @RHF Final Energy: -76.02663273410671. By default, the energy should be converged to about \(1.0 \times 10^{-6}\), so agreement; is only expected for about the first 6 digits after the decimal. If the; computation does not complete, there is probably a problem with the; compilation or installation of the program (see the installation; instructions in Sec. Compiling and Installing from Source).; This very simple input is sufficient to run the requested information.; Notice that we didn’t tell the program some otherwise useful information; like the charge on the molecule (0, it’s neutral), the spin multiplicity; (1 for a closed-shell molecule with all electrons paired), or the reference; wavefunction to use (restricted Hartree–Fock, or RHF, is usually; appropriate for a closed-shell molecule). The program correctly guessed; all of these options for us. We can change the default behavior through; additional keywords.; Let’s consider what we would do for an open-shell molecule, where; not all electrons are paired. For example, let’s run a computation; on methylene (CH2), whose ground electronic state has two unpaired; electrons (triplet electronic state, or a spin multiplicity \(2S+1 = 3\)).; In this case, the default spin multiplicity (1) is not correct, so we; need to tell the program the true value (3). Like many programs, PSI4; can get the charge and multiplicity as the first two integers in the; Z-matrix. Note the line with 0 3 at the beginning of the molecule; specification below. In this example we will also specify the bond length; and bond angle as variables (\(R\) and \(A\)), whose values are given; at",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/tutorial-1.html:3370,charge,charge,3370,psi4manual/1.1.0/tutorial-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/tutorial-1.html,4,['charge'],['charge']
Energy Efficiency,"Y¶. CCSDT TOTAL ENERGY¶. CCSDT CORRELATION ENERGY¶. CCSDTQ TOTAL ENERGY¶. CCSDTQ CORRELATION ENERGY¶. CCn TOTAL ENERGY¶. CCn CORRELATION ENERGY¶; The total electronic energy [Eh] and correlation energy component [Eh]; for the requested full coupled-cluster (CCSD, CCSDT, up to CCn); level of theory. CCSD(T) TOTAL ENERGY¶. CCSD(T) CORRELATION ENERGY¶. CCSD(AT) TOTAL ENERGY¶. CCSD(AT) CORRELATION ENERGY¶. A-CCSD(T) TOTAL ENERGY¶. A-CCSD(T) CORRELATION ENERGY¶. CCSDT(Q) TOTAL ENERGY¶. CCSDT(Q) CORRELATION ENERGY¶. CC(n-1)(n) TOTAL ENERGY¶. CC(n-1)(n) CORRELATION ENERGY¶; The total electronic energy [Eh] and correlation energy component [Eh]; for the perturbatively corrected coupled-cluster (CCSD(T), A-CCSD(T) = CCSD(AT), CCSDT(Q),; up to CC(n-1)(n) level of theory. CCSDT-1a TOTAL ENERGY¶. CCSDT-1a CORRELATION ENERGY¶. CCSDTQ-1a TOTAL ENERGY¶. CCSDTQ-1a CORRELATION ENERGY¶. CCn-1a TOTAL ENERGY¶. CCn-1a CORRELATION ENERGY¶; The total electronic energy [Eh] and correlation energy component [Eh]; for the approximate coupled-cluster (CCSD(T)-1a, CCSDT(Q)-1a,; up to CCn-1a) level of theory. CCSDT-1b TOTAL ENERGY¶. CCSDT-1b CORRELATION ENERGY¶. CCSDTQ-1b TOTAL ENERGY¶. CCSDTQ-1b CORRELATION ENERGY¶. CCn-1b TOTAL ENERGY¶. CCn-1b CORRELATION ENERGY¶; The total electronic energy [Eh] and correlation energy component [Eh]; for the approximate coupled-cluster (CCSD(T)-1b, CCSDT(Q)-1b,; up to CCn-1b) level of theory. CCSDT-3 TOTAL ENERGY¶. CCSDT-3 CORRELATION ENERGY¶. CCSDTQ-3 TOTAL ENERGY¶. CCSDTQ-3 CORRELATION ENERGY¶. CCn-3 TOTAL ENERGY¶. CCn-3 CORRELATION ENERGY¶; The total electronic energy [Eh] and correlation energy component [Eh]; for the approximate coupled-cluster (CCSD(T)-3, CCSDT(Q)-3,; up to CCn-3) level of theory. CCSD(T)_L TOTAL ENERGY¶. CCSD(T)_L CORRELATION ENERGY¶. CCSDT(Q)_L TOTAL ENERGY¶. CCSDT(Q)_L CORRELATION ENERGY¶. CC(n-1)(n)_L TOTAL ENERGY¶. CC(n-1)(n)_L CORRELATION ENERGY¶; The total electronic energy [Eh] and correlation energy component [Eh]; for the app",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/glossary_psivariables-1.html:7026,energy,energy,7026,psi4manual/1.5.0/glossary_psivariables-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/glossary_psivariables-1.html,6,['energy'],['energy']
Energy Efficiency,"Y¶; The energy contribution [Eh] from the polarizable continuum model for solvation. PE ENERGY¶; The energy contribution [Eh] from the polarizable embedding model for solvation. QCISD TOTAL ENERGY¶. QCISD CORRELATION ENERGY¶; The total electronic energy [Eh] and correlation energy component [Eh]; for the quadratic configuration interaction singles and doubles level; of theory. QCISD(T) TOTAL ENERGY¶. QCISD(T) CORRELATION ENERGY¶; The total electronic energy [Eh] and correlation energy component [Eh]; for the quadratic configuration interaction singles and doubles with; perturbative triples correction level of theory. SAPT DISP ENERGY¶. SAPT ELST ENERGY¶. SAPT EXCH ENERGY¶. SAPT IND ENERGY¶; Respectively, the dispersion, electrostatics, exchange, and induction; components of the total electronic interaction energy [Eh] for the; requested SAPT level of theory. The sum of these four components yields; SAPT TOTAL ENERGY. SAPT TOTAL ENERGY¶. SAPT ENERGY¶; The total electronic interaction energy [Eh] for the requested SAPT; level of theory. SAPT ELST10,R ENERGY¶; An electrostatics-classified SAPT term energy [Eh] implemented for SAPT0. SAPT ELST EXTERN-EXTERN ENERGY¶; Electrostatic interaction [Eh] between the point charges in fragments; A and B in F/I-SAPT. SAPT EXCH10 ENERGY¶; An exchange-classified SAPT term energy [Eh] implemented for SAPT0. SAPT EXCH10(S^2) ENERGY¶; An exchange-classified SAPT term energy [Eh] implemented for SAPT0. SAPT IND20,R ENERGY¶. SAPT EXCH-IND20,R ENERGY¶. SAPT IND20,U ENERGY¶. SAPT EXCH-IND20,U ENERGY¶; An induction-classified SAPT term energy [Eh] implemented for SAPT0. SAPT DISP20 ENERGY¶. SAPT EXCH-DISP20 ENERGY¶; A dispersion-classified SAPT term energy [Eh] implemented for SAPT0. SAPT EXCH-DISP20(S^INF) ENERGY¶; A dispersion-classified SAPT term energy [Eh] implemented for SAPT0. See Higher-Order Exchange Terms without Single-Exchange Approximation. SAPT SAME-SPIN DISP20 ENERGY¶. SAPT SAME-SPIN EXCH-DISP20 ENERGY¶; The portion of SAPT D",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/glossary_psivariables.html:42762,energy,energy,42762,psi4manual/1.6.x/glossary_psivariables.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/glossary_psivariables.html,1,['energy'],['energy']
Energy Efficiency,"Y¶; The energy contribution [Eh] from the polarizable continuum model for solvation. PE ENERGY¶; The energy contribution [Eh] from the polarizable embedding model for solvation. QCISD TOTAL ENERGY¶. QCISD CORRELATION ENERGY¶; The total electronic energy [Eh] and correlation energy component [Eh]; for the quadratic configuration interaction singles and doubles level; of theory. QCISD(T) TOTAL ENERGY¶. QCISD(T) CORRELATION ENERGY¶; The total electronic energy [Eh] and correlation energy component [Eh]; for the quadratic configuration interaction singles and doubles with; perturbative triples correction level of theory. SAPT DISP ENERGY¶. SAPT ELST ENERGY¶. SAPT EXCH ENERGY¶. SAPT IND ENERGY¶; Respectively, the dispersion, electrostatics, exchange, and induction; components of the total electronic interaction energy [Eh] for the; requested SAPT level of theory. The sum of these four components yields; SAPT TOTAL ENERGY. SAPT TOTAL ENERGY¶. SAPT ENERGY¶; The total electronic interaction energy [Eh] for the requested SAPT; level of theory. SAPT ELST10,R ENERGY¶; An electrostatics-classified SAPT term energy [Eh] implemented for SAPT0. SAPT ELST EXTERN-EXTERN ENERGY¶; Electrostatic interaction [Eh] between the point charges in fragments; A and B in F/I-SAPT. SAPT EXCH10 ENERGY¶; An exchange-classified SAPT term energy [Eh] implemented for SAPT0. SAPT EXCH10(S^2) ENERGY¶; An exchange-classified SAPT term energy [Eh] implemented for SAPT0. SAPT IND20,R ENERGY¶. SAPT EXCH-IND20,R ENERGY¶. SAPT IND20,U ENERGY¶. SAPT EXCH-IND20,U ENERGY¶; An induction-classified SAPT term energy [Eh] implemented for SAPT0. SAPT DISP20 ENERGY¶. SAPT EXCH-DISP20 ENERGY¶; A dispersion-classified SAPT term energy [Eh] implemented for SAPT0. SAPT EXCH-DISP20(S^INF) ENERGY¶; A dispersion-classified SAPT term energy [Eh] implemented for SAPT0. See Second-Order Exchange Terms without Single-Exchange Approximation. SAPT SAME-SPIN DISP20 ENERGY¶. SAPT SAME-SPIN EXCH-DISP20 ENERGY¶; The portion of SAPT D",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/glossary_psivariables-1.html:35244,energy,energy,35244,psi4manual/1.4.0/glossary_psivariables-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/glossary_psivariables-1.html,4,['energy'],['energy']
Energy Efficiency,"Y¶; The nuclear repulsion energy contribution [Eh] to the total SCF energy.; Quantity \(E_{NN}\) in Eq. (4). (3)¶\[E_{NN} = \sum_{i, j<i}^{N_{atom}}\frac{Z_i Z_j}{|\mathbf{R}_i - \mathbf{R}_j|}\]. OCEPA(0) TOTAL ENERGY¶. OCEPA(0) CORRELATION ENERGY¶; The total electronic energy [Eh] and correlation energy component [Eh]; for the orbital-optimized CEPA(0) level of theory. OLCCD TOTAL ENERGY¶. OLCCD CORRELATION ENERGY¶; The total electronic energy [Eh] and correlation energy component [Eh]; for the orbital-optimized linearized coupled cluster doubles level of theory. OLCCD REFERENCE CORRECTION ENERGY¶; The additional correction to the SCF reference energy [Eh]; for the orbital-optimized linearized coupled cluster doubles level of theory. OMP2 TOTAL ENERGY¶. OMP2 CORRELATION ENERGY¶; The total electronic energy [Eh] and correlation energy component [Eh]; for the orbital-optimized MP2 level of theory. OMP2.5 TOTAL ENERGY¶. OMP2.5 CORRELATION ENERGY¶; The total electronic energy [Eh] and correlation energy component [Eh]; for the orbital-optimized MP2.5 level of theory. OMP3 TOTAL ENERGY¶. OMP3 CORRELATION ENERGY¶; The total electronic energy [Eh] and correlation energy component [Eh]; for the orbital-optimized MP3 level of theory. ONE-ELECTRON ENERGY¶; The one-electron energy contribution [Eh] to the total SCF energy.; Quantity \(E_{1e^-}\) in Eq. (4). PCM POLARIZATION ENERGY¶; The energy contribution [Eh] from the polarizable continuum model for solvation. PE ENERGY¶; The energy contribution [Eh] from the polarizable embedding model for solvation. QCISD TOTAL ENERGY¶. QCISD CORRELATION ENERGY¶; The total electronic energy [Eh] and correlation energy component [Eh]; for the quadratic configuration interaction singles and doubles level; of theory. QCISD(T) TOTAL ENERGY¶. QCISD(T) CORRELATION ENERGY¶; The total electronic energy [Eh] and correlation energy component [Eh]; for the quadratic configuration interaction singles and doubles with; perturbative triples correction ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/glossary_psivariables-1.html:33835,energy,energy,33835,psi4manual/1.4.0/glossary_psivariables-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/glossary_psivariables-1.html,10,['energy'],['energy']
Energy Efficiency,Y¶; The total electronic energy [E_h] and correlation energy component [E_h]; for the orbital-optimized MP2.5 level of theory. OMP2.5 REFERENCE CORRECTION ENERGY¶; The difference [E_h] between the single-determinant energy of the final and; initial orbitals for the orbital-optimized MP2.5 level of theory. OMP3 TOTAL ENERGY¶. OMP3 CORRELATION ENERGY¶; The total electronic energy [E_h] and correlation energy component [E_h]; for the orbital-optimized MP3 level of theory. OMP3 REFERENCE CORRECTION ENERGY¶; The difference [E_h] between the single-determinant energy of the final and; initial orbitals for the orbital-optimized MP3 level of theory. OREMP2 TOTAL ENERGY¶. OREMP2 CORRELATION ENERGY¶; The total electronic energy [E_h] and correlation energy component [E_h]; for the orbital-optimized retaining-the-excitation-degree Møller–Plesset; hybrid perturbation theory level. OREMP2 REFERENCE CORRECTION ENERGY¶; The difference [E_h] between the single-determinant energy of the final and; initial orbitals for the orbital-optimized retaining-the-excitation-degree; Møller–Plesset hybrid perturbation theory level. ONE-ELECTRON ENERGY¶; The one-electron energy contribution [E_h] to the total SCF energy.; Quantity \(E_{1e^-}\) in Eq. (4). PCM POLARIZATION ENERGY¶; The energy contribution [E_h] from the polarizable continuum model for solvation. DD SOLVATION ENERGY¶; The energy contribution [Eh] from continuum solvation models based on a; domain-decomposition ansatz. PE ENERGY¶; The energy contribution [E_h] from the polarizable embedding model for solvation. QCISD TOTAL ENERGY¶. QCISD CORRELATION ENERGY¶; The total electronic energy [E_h] and correlation energy component [E_h]; for the quadratic configuration interaction singles and doubles level; of theory. QCISD(T) TOTAL ENERGY¶. QCISD(T) CORRELATION ENERGY¶; The total electronic energy [E_h] and correlation energy component [E_h]; for the quadratic configuration interaction singles and doubles with; perturbative triples correc,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/glossary_psivariables.html:43822,energy,energy,43822,psi4manual/1.7.x/glossary_psivariables.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/glossary_psivariables.html,4,['energy'],['energy']
Energy Efficiency,"Y¶; The total electronic energy [Eh] for the requested DFT method,; \(E_{\text{DFT}}\) in Eq. (1). \begin{align*}; E_{\text{DFT}} & = E_{NN} + E_{1e^-} + E_{2e^-} + E_{xc} + E_{\text{-D}} + E_{\text{DH}} \\; & = E_{\text{FCTL}} + E_{\text{-D}} + E_{\text{DH}} \\; & = E_{\text{SCF}} + E_{\text{DH}}; \end{align*}Unless the method is a DFT double-hybrid, this quantity is equal to; SCF TOTAL ENERGY. If the method is neither a; double-hybrid, nor dispersion corrected, this quantity is equal to; DFT FUNCTIONAL TOTAL ENERGY. DFT TOTAL GRADIENT¶; The total electronic gradient [E_h/a0] of the requested DFT method, ({nat}, 3). DFT DIPOLE GRADIENT¶; The derivative of the requested DFT method dipole [E_h a0/u] = [(e a0/a0)^2/u] with respect to nuclear perturbations; as a degree-of-freedom by dipole component array, (3 * {nat}, 3). DFT TOTAL HESSIAN¶; The total electronic second derivative [Eh/a0/a0] for the requested DFT method, (3 * {nat}, 3 * {nat}). DFT XC ENERGY¶; The functional energy contribution [Eh] to the total SCF energy (DFT only).; Quantity \(E_{xc}\) in Eqs. (4) and (1). DFT VV10 ENERGY¶; The VV10 nonlocal contribution [Eh] to the total SCF energy (DFT only).; Included in DFT FUNCTIONAL TOTAL ENERGY. DISPERSION CORRECTION ENERGY¶. fctl DISPERSION CORRECTION ENERGY¶; The dispersion correction [Eh] appended to an underlying functional; when a DFT-D method is requested. Quantity \(E_{\text{-D}}\); in Eqs. (4) and (1).; When dispersion parameters are untweaked for a functional and dispersion; level, labeled QCVariable also defined. DOUBLE-HYBRID CORRECTION ENERGY¶; The scaled MP2 correlation energy correction [Eh] appended to an; underlying functional when a DH-DFT method is requested.; Quantity \(E_{\text{DH}}\) in Eq. (1). DMA DISTRIBUTED MULTIPOLES¶; Distributed multipoles in units given by GDMA_MULTIPOLE_UNITS; with the row index corresponding to the site and the column index; referencing the multipole component. Both indices are zero based,; and the Qlm components",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/glossary_psivariables-1.html:20436,energy,energy,20436,psi4manual/1.4.0/glossary_psivariables-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/glossary_psivariables-1.html,10,['energy'],['energy']
Energy Efficiency,"Z H2O Computation. psi4.set_memory('500 MB'). h2o = psi4.geometry(""""""; O; H 1 0.96; H 1 0.96 2 104.5; """"""). psi4.energy('scf/cc-pvdz'). [3]:. -76.02663273488399. If everything goes well, the computation should complete and should report a final restricted Hartree-Fock energy in the output file output.dat in a section like this:; Energy converged. @DF-RHF Final Energy: -76.02663273486682. By default, the energy should be converged to about \(1.0\times 10^{-6}\), so agreement is only expected for about the first 6 digits after the decimal. If the computation does not complete, there is probably a problem with the compilation or installation of the program (see the installation instructions in the main Psi4 manual section Compiling and Installing from Source.; This very simple input is sufficient to run the requested information. Notice we didn’t tell the program some otherwise useful information like the charge of the molecule (0, it’s neutral), the spin multiplicity (1 for a closed-shell molecule with all electrons paired), or the reference wavefunction to use (restricted Hartree-Fock, or RHF, is usually appropriate for a closed-shell molecule). The program correctly guessed all of these options for us. We can change the default behavior through; additional keywords.; Let’s consider what we would do for an open-shell molecule, where not all the electrons are paired. For example, let’s run a computation on methylene (\(\text{CH}_2\)), whose ground electronic state has two unpaired electrons (triplet electronic state, or a spin multiplicity \(2S + 1 = 3\)). In this case, the default spin multiplicity (1) is not correct, so we need to tell the program the true value (3). Like many programs, Psi4 can get the charge and multiplicity as the first two; integers in the Z-matrix (note the line with 0 3 at the beginning of the molecule specification below). In this example, we will also specify the bond length and bond angle as variables (\(R\) and \(A\)), whose values are fir",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/psiapi.html:4246,charge,charge,4246,psi4manual/1.9.x/psiapi.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/psiapi.html,2,['charge'],['charge']
Energy Efficiency,"Z The reference numbers are from Lan Cheng’s implementation in Cfour. ci-multi; BH single points, checking that program can run multiple instances of DETCI in a single input, without an intervening clean() call. mints-helper; A general test of the MintsHelper function. mcscf2; TCSCF cc-pVDZ energy of asymmetrically displaced ozone, with Z-matrix input. sapt9; usapt example with empty beta. dfmp2-1; Density fitted MP2 cc-PVDZ/cc-pVDZ-RI computation of formic acid dimer binding energy using automatic counterpoise correction. Monomers are specified using Cartesian coordinates. matrix1; An example of using BLAS and LAPACK calls directly from the Psi input file, demonstrating matrix multiplication, eigendecomposition, Cholesky decomposition and LU decomposition. These operations are performed on vectors and matrices provided from the Psi library. tu6-cp-ne2; Example potential energy surface scan and CP-correction for Ne2. sapt1; SAPT0 cc-pVDZ computation of the ethene-ethyne interaction energy, using the cc-pVDZ-JKFIT RI basis for SCF and cc-pVDZ-RI for SAPT. Monomer geometries are specified using Cartesian coordinates. mcscf3; RHF 6-31G** energy of water, using the MCSCF module and Z-matrix input. fci-dipole; 6-31G H2O Test FCI Energy Point. dct-grad2; RHF-ODC-12 analytic gradient computations for H2O use AO_BASIS=DISK and AO_BASIS=NONE, respectively. RHF-ODC-06 analytic gradient computations for H2O use AO_BASIS=DISK and AO_BASIS=NONE, respectively. cc43; RHF-CC2-LR/STO-3G optical rotation of (S)-methyloxirane. gauge = both, omega = (589 355 nm). olccd-grad1; OLCCD cc-pVDZ gradient for the H2O molecule. tu5-sapt; Example SAPT computation for ethene*ethine (i.e., ethylene*acetylene), test case 16 from the S22 database. cc24; Single point gradient of 1-2B1 state of H2O+ with EOM-CCSD. psimrcc-fd-freq2; Mk-MRCCSD frequencies. \(^1A_1\) O$_3` state described using the Ms = 0 component of the singlet. Uses TCSCF orbitals. cc1; RHF-CCSD 6-31G** all-electron optimization of t",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/autodoc_testsuite_corepsi4.html:43846,energy,energy,43846,psi4manual/1.8.x/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/autodoc_testsuite_corepsi4.html,2,['energy'],['energy']
Energy Efficiency,"Z \(^{3}B_1\) CH2 geometry optimization via analytic gradients. mp2-1; All-electron MP2 6-31G** geometry optimization of water. cepa1; cc-pvdz H2O Test CEPA(1) Energy. casscf-fzc-sp; CASSCF/6-31G** energy point. extern2; External potential calculation involving a TIP3P water and a QM water for DFMP2. Finite different test of the gradient is performed to validate forces. opt9; Various constrained energy minimizations of HOOH with cc-pvdz RHF. Cartesian-coordinate constrained optimizations of HOOH in internals. cc9a; ROHF-CCSD(T) cc-pVDZ energy for the \(^2\Sigma^+\) state of the CN radical, with Z-matrix input. mints1; Symmetry tests for a range of molecules. This doesn’t actually compute any energies, but serves as an example of the many ways to specify geometries in Psi4. dfmp2-grad5; Tests DF-MP2 gradient in the presence of a dipole field. pywrap-db3; Test that Python Molecule class processes geometry like psi4 Molecule class. cc16; ROHF and UHF-B-CCD(T)/cc-pVDZ \(^{3}B_1\) CH2 single-point energy (fzc, MO-basis \(\langle ab|cd \rangle\) ). fci-h2o; 6-31G H2O Test FCI Energy Point. ocepa1; OCEPA cc-pVDZ energy for the H2O molecule. opt-multi-dimer-c2h; Multi-fragment opt of C2h methane dimer with user-combined reference points. fd-freq-energy; SCF STO-3G finite-difference frequencies from energies. cc30; CCSD/sto-3g optical rotation calculation (length gauge only) at two frequencies on methyloxirane. numpy-array-interface; Numpy interface testing. ghosts; Density fitted MP2 cc-PVDZ/cc-pVDZ-RI computation of formic acid dimer binding energy using explicit specification of ghost atoms. This is equivalent to the dfmp2_1 sample but uses both (equivalent) specifications of ghost atoms in a manual counterpoise correction. sapt3; SAPT2+3(CCD) aug-cc-pVDZ computation of the water dimer interaction energy, using the aug-cc-pVDZ-JKFIT DF basis for SCF and aug-cc-pVDZ-RI for SAPT. mints4; A demonstration of mixed Cartesian/ZMatrix geometry specification, using variables, for",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/testsuite-1.html:17374,energy,energy,17374,psi4manual/1.1.0/testsuite-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/testsuite-1.html,4,['energy'],['energy']
Energy Efficiency,"Z computation of formic acid dimer binding energy using automatic counterpoise correction. Monomers are specified using Cartesian coordinates. cfour/sp-rhf-scf; single-point HF/qz2p on water. cfour/sp-rohf-ccsdt; single-point CCSDT/qz2p on NH2. cfour/sp-rohf-mp2-sc; single-point MP2/qz2p on NH2. cfour/sp-rohf-mp4-sc; single-point MP4/qz2p on NH2. cfour/psi-ghost-grad; MP2 optimization of dimers with one momomer ghosted. Gradients after three opt cycles are compared with those from psi4. cfour/psi-mp4; MP4 energy components. Checks that computed identically between cfour and psi4. cfour/sp-rohf-scf; single-point HF/qz2p on NH2. cfour/opt-rhf-scf; optimization HF/svp on water. cfour/psi-uhf-scsmp2; UHF MP2 energy components. Checks that computed identically between cfour and psi4. cfour/sp-rhf-ccsd; single point CCSD/qz2p on water. cfour/kw-2; testing best practices options, part ii. cfour/sp-rhf-ccsd_t_-ao-ecc; single-point CCSD(T)/qc2p on water with ecc, aobasis. cfour/psi-uhf-mp3; UHF MP3 energy components. Checks that converted identically between cfour and psi4. cfour/mp2-1; All-electron MP2 6-31G** geometry optimization of water. cfour/kw-1; testing best practices options, part i. cfour/sp-rohf-ccsd_t_; single-point CCSD(T)/qz2p on NH2. cfour/kw-5; Basis set spherical/Cartesian with basis and cfour_spherical. cfour/sp-rohf-ccsd_t_-ao-ecc; single-point CCSD(T)/qz2p on NH2 with ecc, aobasis. cfour/sp-uhf-ccsdt; single-point CCSDT/qz2p on NH2. cfour/sp-rohf-ccsd; single-point CCSD/qz2p on NH2. cfour/psi-rohf-scsmp2; ROHF MP2 energy components. Checks that computed identically between cfour and psi4. cfour/psi-rhf-scsmp2; MP2 energy components. Checks that computed identically between cfour and psi4. cfour/sp-rhf-ccsd_t_-fc; single-point CCSD(T)/qz2p on water with ecc, aobasis, and frozen-core. cfour/puream; Basis set spherical/Cartesian behavior in cfour. cfour/sp-uhf-ccsd_t_-ao; single-point CCSD(T)/qz2p on NH2 with aobasis. cfour/psi-a24-grad; geometry after thre",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/autodoc_testsuite_cfour-1.html:3396,energy,energy,3396,psi4manual/1.4.0/autodoc_testsuite_cfour-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodoc_testsuite_cfour-1.html,2,['energy'],['energy']
Energy Efficiency,"Z computation of the benzene-methane interaction energy, using the aug-pVDZ-JKFIT DF basis for SCF, the aug-cc-pVDZ-RI DF basis for SAPT0 induction and dispersion, and the aug-pVDZ-JKFIT DF basis for SAPT0 electrostatics and induction. This example uses frozen core as well as asyncronous I/O while forming the DF integrals and CPHF coefficients. fsapt-d; Tests SAPT0-D corrections, with a variety of damping functions/parameters. matrix1; An example of using BLAS and LAPACK calls directly from the Psi input file, demonstrating matrix multiplication, eigendecomposition, Cholesky decomposition and LU decomposition. These operations are performed on vectors and matrices provided from the Psi library. omp2-3; OMP2 cc-pVDZ energy for the NO radical. cc21; ROHF-EOM-CCSD/DZ analytic gradient lowest \(^{2}A_1\) excited state of H2O+ (B1 excitation). opt1-fd; SCF STO-3G geometry optimzation, with Z-matrix input, by finite-differences. casscf-semi; CASSCF/6-31G** energy point. Check energy with frozen core/virtual orbs. after semicanonicalization. opt12; SCF cc-pVDZ geometry optimzation of ketene, starting from bent structure. scf-coverage; Lithium test for coverage. cc27; Single point gradient of 1-1B2 state of H2O with EOM-CCSD. omp2p5-1; OMP2.5 cc-pVDZ energy for the H2O molecule. dft1-alt; DFT Functional Test. x2c-perturb-h; Test SFX2C-1e with a static electric field on He aug-cc-pVTZ. dfcasscf-fzc-sp; CASSCF/6-31G** energy point. nbody-intermediates; HF/cc-pVDZ many body energies of an arbitrary noble gas trimer complex Size vs cost tradeoff is rough here. fd-freq-gradient-large; SCF DZ finite difference frequencies by gradients for C4NH4. dft-jk; DFT JK on-disk test. dct1; DC-06, DC-12, ODC-06 and ODC-12 calculation for the He dimer. This performs a simultaneous update of the orbitals and cumulant, using DIIS extrapolation. Four-virtual integrals are handled in the MO Basis. dft-b2plyp; Double-hybrid density functional B2PYLP. Reproduces portion of Table I in S. Grimme’s J",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/autodoc_testsuite_corepsi4.html:8373,energy,energy,8373,psi4manual/1.7.x/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/autodoc_testsuite_corepsi4.html,2,['energy'],['energy']
Energy Efficiency,"Z energy for the H2O molecule. cc3; cc3: RHF-CCSD/6-31G** H2O geometry optimization and vibrational frequency analysis by finite-differences of gradients. scf-bz2; Benzene Dimer Out-of-Core HF/cc-pVDZ. cc51; EOM-CC3/cc-pVTZ on H2O. fci-h2o-2; 6-31G H2O Test FCI Energy Point. mp2-grad2; MP2 cc-pVDZ gradient for the NO radical. cc31; CCSD/sto-3g optical rotation calculation (both gauges) at two frequencies on methyloxirane. psimrcc-ccsd_t-1; Mk-MRCCSD(T) single point. CH2 state described using the Ms = 0 component of the singlet. Uses RHF singlet orbitals. cc11; Frozen-core CCSD(ROHF)/cc-pVDZ on CN radical with disk-based AO algorithm. pywrap-checkrun-rhf; This checks that all energy methods can run with a minimal input and set symmetry. fd-freq-energy-large; SCF DZ finite difference frequencies by energies for C4NH4. cc33; CC3(UHF)/cc-pVDZ H2O geom from Olsen et al., JCP 104, 8007 (1996). dft-grad; DF-BP86-D2 cc-pVDZ frozen core gradient of S22 HCN. tu6-cp-ne2; Example potential energy surface scan and CP-correction for Ne2. cc30; CCSD/sto-3g optical rotation calculation (length gauge only) at two frequencies on methyloxirane. omp3-3; OMP3 cc-pVDZ energy with B3LYP initial guess for the NO radical. sapt3; SAPT2+3(CCD) aug-cc-pVDZ computation of the water dimer interaction energy, using the aug-cc-pVDZ-JKFIT DF basis for SCF and aug-cc-pVDZ-RI for SAPT. scf5; Test of all different algorithms and reference types for SCF, on singlet and triplet O2, using the cc-pVTZ basis set. pywrap-opt-sowreap; Finite difference optimization, run in sow/reap mode. cc8a; ROHF-CCSD(T) cc-pVDZ frozen-core energy for the state of the CN radical, with Cartesian input. opt1-fd; SCF STO-3G geometry optimzation, with Z-matrix input, by finite-differences. dft-dldf; Dispersionless density functional (dlDF+D) internal match to Psi4 Extensive testing has been done to match supplemental info of Szalewicz et. al., Phys. Rev. Lett., 103, 263201 (2009) and Szalewicz et. al., J. Phys. Chem. Lett., 1, ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/autodoc_testsuite-1.html:17397,energy,energy,17397,psi4manual/4.0b4/autodoc_testsuite-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/autodoc_testsuite-1.html,8,['energy'],['energy']
Energy Efficiency,"Z energy of H2O. pywrap-align-chiral; testing aligner on enantiomers based on Table 1 of 10.1021/ci100219f aka J Chem Inf Model 2010 50(12) 2129-2140. dft-grad-meta; meta-GGA gradients of water and ssh molecules reference gradients updated due to new BraggSlater radii. mints1; Symmetry tests for a range of molecules. This doesn’t actually compute any energies, but serves as an example of the many ways to specify geometries in Psi4. dforemp-grad2; density fitted OO-REMP/cc-pVDZ engrad single points for the H2O+ molecule. olccd1; OLCCD cc-pVDZ energy for the H2O molecule. mp2-h; check that methods can act on single atom. fnocc3; Test FNO-QCISD(T) computation. dft-custom-dhdf; DSD-PBEP86 S22 Ammonia test. dfremp-2; density fitted REMP/cc-pVDZ energies for the CH3 radical. fnocc4; Test FNO-DF-CCSD(T) energy. mp2p5-grad2; MP2.5 cc-pVDZ gradient for the NO radical. cdremp-1; Cholesky decomposed REMP/cc-pVDZ energies for the CO2 molecule. cc52; CCSD Response for H2O2. cdomp2-2; OMP2 cc-pVDZ energy for the NO molecule. omp2p5-grad1; OMP2.5 cc-pVDZ gradient for the H2O molecule. dct3; DC-06 calculation for the He dimer. This performs a simultaneous update of the orbitals and cumulant, using DIIS extrapolation. Four-virtual integrals are handled in the AO Basis, using integrals stored on disk. omp3-5; SOS-OMP3 cc-pVDZ geometry optimization for the H2O molecule. fnocc2; Test G2 method for H2O. dlpnomp2-2; comparison of DF-MP2 and DLPNO-MP2 with a CBS extrapolation. scf-cholesky-basis; incremental Cholesky filtered SCF. matrix2; An example of using BLAS and LAPACK calls directly from the Psi input file, demonstrating. mpn-bh; MP(n)/aug-cc-pVDZ BH Energy Point, with n=2-19. Compare against M. L. Leininger et al., J. Chem. Phys. 112, 9213 (2000). ddd-deriv; Sample HF/cc-pVDZ H2O computation all derivatives. cc51; EOM-CC3/cc-pVTZ on H2O. dfomp2p5-grad1; DF-OMP2.5 cc-pVDZ gradients for the H2O molecule. molden1; Test of the superposition of atomic densities (SAD) guess, using a high",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/autodoc_testsuite_corepsi4.html:37298,energy,energy,37298,psi4manual/1.7.x/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/autodoc_testsuite_corepsi4.html,2,['energy'],['energy']
Energy Efficiency,"Z of benzene-hydronium ion, scanning the dissociation coordinate with Python’s built-in loop mechanism. The geometry is specified by a Z-matrix with dummy atoms, fixed parameters, updated parameters, and separate charge/multiplicity specifiers for each monomer. One-electron properties computed for dimer and one monomer. dlpnomp2-2; comparison of DF-MP2 and DLPNO-MP2 with a CBS extrapolation. cepa-module; routing check on lccd, lccsd, cepa(0). dfccsd-t-grad1; DF-CCSD(T) cc-pVDZ gradients for the H2O molecule. olccd2; OLCCD cc-pVDZ energy with B3LYP initial guess for the NO radical. ao-casscf-sp; CASSCF/6-31G** energy point. cisd-h2o+-0; 6-31G** H2O+ Test CISD Energy Point. dfmp2-freq1; DF-MP2 frequency by difference of energies for H2O. scf4; RHF cc-pVDZ energy for water, automatically scanning the symmetric stretch and bending coordinates using Python’s built-in loop mechanisms. The geometry is specified using a Z-matrix with variables that are updated during the potential energy surface scan, and then the same procedure is performed using polar coordinates, converted to Cartesian coordinates. cc33; CC3(UHF)/cc-pVDZ H2O \(R_e\) geom from Olsen et al., JCP 104, 8007 (1996). dct-grad2; RHF-ODC-12 analytic gradient computations for H2O use AO_BASIS=DISK and AO_BASIS=NONE, respectively. RHF-ODC-06 analytic gradient computations for H2O use AO_BASIS=DISK and AO_BASIS=NONE, respectively. lccd-grad1; LCCD cc-pVDZ gradient for the H2O molecule. sapt-exch-ind-inf; SAPT(DFT) aug-cc-pVDZ interaction energy between Ne and Ar atoms. dct2; DC-06 calculation for the He dimer. This performs a two-step update of the orbitals and cumulant, using DIIS extrapolation. Four-virtual integrals are handled in the MO Basis. dct3; DC-06 calculation for the He dimer. This performs a simultaneous update of the orbitals and cumulant, using DIIS extrapolation. Four-virtual integrals are handled in the AO Basis, using integrals stored on disk. dfccsdt1; DF-CCSD(T) cc-pVDZ energy for the H2O molecul",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/autodoc_testsuite_corepsi4.html:39062,energy,energy,39062,psi4manual/1.9.x/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/autodoc_testsuite_corepsi4.html,2,['energy'],['energy']
Energy Efficiency,"Z, PCV6Z, AUG-PVDZ, AUG-PVTZ, AUG-PVTZ, AUG-PVQZ, AUG-PV5Z, AUG-PV6Z, D-AUG-PVDZ, D-AUG-PVTZ, D-AUG-PVQZ, D-AUG-PV5Z, D-AUG-PV6Z, cc-pVDZ, cc-pVTZ, cc-pVQZ, cc-pV5Z, cc-pV6Z, cc-pCVDZ, cc-pCVTZ, cc-pCVQZ, cc-pCV5Z, cc-pCV6Z, PWCVDZ, PWCVTZ, PWCVQZ, PWCV5Z, PWCV6Z, PwCVDZ, PwCVTZ, PwCVQZ, PwCV5Z, PwCV6Z, svp, dzp, tzp, tzp2p, qz2p, pz3d2f, 13s9p4d3f, WMR, ANO0, ANO1, ANO2, EVEN_TEMPERED, SPECIAL; Default: SPECIAL. CFOUR_BRUCK_CONV¶. experimental use. Type: integer; Default: 4. CFOUR_BRUECKNER¶. Specifies whether Brueckner orbitals are to be determined for the specified CC method. OFF(=0) Brueckner orbitals are not to be determined, ON (=1) they are to be determined. Type: boolean; Default: false. CFOUR_CACHE_RECS¶. The number of records held in the i/o cache used by the post-SCF programs. The maximum number of records which can be held is 100. Type: integer; Default: 10. CFOUR_CALC_LEVEL¶. Defines the level of calculation to be performed. Psi4 Interface: Keyword set from argument of computation command: CCSD if energy('c4-ccsd'), etc. See Energy (CFOUR) and Gradient (CFOUR). for all available. Type: string; Possible Values: SCF, HF, MBPT(2), MP2, MBPT(3), MP3, SDQ-MBPT(4), SDQ-MP4, MBPT(4), MP4, CCD, CCSD, CCSD(T), CCSDT-1, CCSDT-1b, CCSDT-2, CCSDT-3, CCSDT-4, CCSDT, CC2, CC3, QCISD, QCISD(T), CID, CISD, UCC(4), B-CCD; Default: SCF. CFOUR_CC_CONV¶. Specifies the convergence criterion for the CC amplitude equations. The amplitudes are considered to be converged when the maximum of all (absolute) changes in the amplitudes is less than , where is the value associated with the keyword. Type: integer; Default: 7. CFOUR_CC_EXPORDER¶. Specifies the maximum number of expansion vectors used in the iterative subspace to enhance convergence in the solution of the CC equations. Type: integer; Default: 5. CFOUR_CC_EXTRAPOLATION¶. Specifies the type of convergence acceleration used to solve the CC equations. RLE (=0) uses the RLE methods of Purvis and Bartlett, DIIS (=1) uses the ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodir_options_c/module__cfour-1.html:8359,energy,energy,8359,psi4manual/1.0.0/autodir_options_c/module__cfour-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodir_options_c/module__cfour-1.html,2,['energy'],['energy']
Energy Efficiency,"Z, PCV6Z, AUG-PVDZ, AUG-PVTZ, AUG-PVTZ, AUG-PVQZ, AUG-PV5Z, AUG-PV6Z, D-AUG-PVDZ, D-AUG-PVTZ, D-AUG-PVQZ, D-AUG-PV5Z, D-AUG-PV6Z, cc-pVDZ, cc-pVTZ, cc-pVQZ, cc-pV5Z, cc-pV6Z, cc-pCVDZ, cc-pCVTZ, cc-pCVQZ, cc-pCV5Z, cc-pCV6Z, PWCVDZ, PWCVTZ, PWCVQZ, PWCV5Z, PWCV6Z, PwCVDZ, PwCVTZ, PwCVQZ, PwCV5Z, PwCV6Z, svp, dzp, tzp, tzp2p, qz2p, pz3d2f, 13s9p4d3f, WMR, ANO0, ANO1, ANO2, EVEN_TEMPERED, SPECIAL; Default: SPECIAL. CFOUR_BRUCK_CONV¶. experimental use. Type: integer; Default: 4. CFOUR_BRUECKNER¶. Specifies whether Brueckner orbitals are to be determined for the specified CC method. OFF(=0) Brueckner orbitals are not to be determined, ON (=1) they are to be determined. Type: boolean; Default: false. CFOUR_CACHE_RECS¶. The number of records held in the i/o cache used by the post-SCF programs. The maximum number of records which can be held is 100. Type: integer; Default: 10. CFOUR_CALC_LEVEL¶. Defines the level of calculation to be performed. Psi4 Interface: Keyword set from argument of computation command: CCSD if energy('c4-ccsd'), etc. See Energy (CFOUR) and Gradient (CFOUR). for all available. Type: string; Possible Values: SCF, HF, MBPT(2), MP2, MBPT(3), MP3, SDQ-MBPT(4), SDQ-MP4, MBPT(4), MP4, CCD, CCSD, CCSD(T), CCSDT-1, CCSDT-1b, CCSDT-2, CCSDT-3, CCSDT-4, CCSDT, CC2, CC3, QCISD, QCISD(T), CID, CISD, UCC(4), B-CCD; Default: SCF. CFOUR_CC_CONV¶. Specifies the convergence criterion for the CC amplitude equations. The amplitudes are considered to be converged when the maximum of all (absolute) changes in the amplitudes is less than \(10^N\), where \(N\) is the value associated with the keyword. Type: integer; Default: 7. CFOUR_CC_EXPORDER¶. Specifies the maximum number of expansion vectors used in the iterative subspace to enhance convergence in the solution of the CC equations. Type: integer; Default: 5. CFOUR_CC_EXTRAPOLATION¶. Specifies the type of convergence acceleration used to solve the CC equations. RLE (=0) uses the RLE methods of Purvis and Bartlett, DIIS ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/autodir_options_c/module__cfour-1.html:8457,energy,energy,8457,psi4manual/1.1.0/autodir_options_c/module__cfour-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/autodir_options_c/module__cfour-1.html,4,['energy'],['energy']
Energy Efficiency,"Z, fileAtom, el2mass[fileAtom]). else:; raise ValidationError(""Molecule::init_with_xyz: Malformed atom information line %d."" % (i + 3)); except IndexError:; raise ValidationError(""Molecule::init_with_xyz: Expected atom in file at line %d.\n%s"" % (i + 3, text[i + 2])). # We need to make 1 fragment with all atoms; instance.fragments.append([0, fileNatom - 1]); instance.fragment_types.append('Real'); instance.fragment_charges.append(0); instance.fragment_multiplicities.append(1); # Set the units to bohr since we did the conversion above, if needed.; instance.PYunits = 'Bohr'; instance.input_units_to_au = 1.0. instance.update_geometry(); return instance. [docs] def clone(self):; """"""Returns new, independent Molecule object. >>> dimer = H2OH2O.clone(). """"""; return copy.deepcopy(self). # <<< Methods for Printing >>>. [docs] def print_out(self):; """"""Print the molecule.; (method name in libmints is print). >>> H2OH2O.print_out(); Geometry (in Angstrom), charge = -2, multiplicity = 3:; Center X Y Z; ------------ ----------------- ----------------- -----------------; O -1.551007000000 -0.114520000000 0.000000000000; H -1.934259000000 0.762503000000 0.000000000000; H -0.599677000000 0.040712000000 0.000000000000; O 1.350625000000 0.111469000000 0.000000000000; H 1.680398000000 -0.373741000000 -0.758561000000; H 1.680398000000 -0.373741000000 0.758561000000. """"""; text = """"; if self.natom():; if self.pg:; text += """""" Molecular point group: %s\n"""""" % (self.pg.symbol()); if self.full_pg:; text += """""" Full point group: %s\n\n"""""" % (self.get_full_point_group()); text += """""" Geometry (in %s), charge = %d, multiplicity = %d:\n\n"""""" % \; ('Angstrom' if self.units() == 'Angstrom' else 'Bohr', self.molecular_charge(), self.multiplicity()); text += """""" Center X Y Z \n""""""; text += """""" ------------ ----------------- ----------------- -----------------\n"""""". for i in range(self.natom()):; geom = self.atoms[i].compute(); text += """""" %8s%4s """""" % (self.symbol(i), """" if self.Z(i) else ""(Gh)""); f",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html:25688,charge,charge,25688,psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html,1,['charge'],['charge']
Energy Efficiency,"Z-JKFIT DF basis for SCF and aug-cc-pVDZ-RI for SAPT. olccd1; OLCCD cc-pVDZ energy for the H2O molecule. cc42; RHF-CC2-LR/STO-3G optical rotation of (S)-methyloxirane. gauge = length, omega = (589 355 nm). cepa2; cc-pvdz H2O Test ACPF Energy/Properties. cc48; reproduces dipole moments in J.F. Stanton’s “biorthogonal” JCP paper. sapt7; SAPT0 open-shell computation of H2O-HO2 interaction energy First with cc-pVDZ and density fitted integrals with UHF Then with 6-31g and direct integrals, except for dispersion that is computed with cc-pVDZ-ri density fitting with UHF. dfomp2-4; OMP2 cc-pVDZ energy for the NO molecule. dft-omega; Test omega is setable updated wb97x_20,wb97x_03 to account for new BraggSlater radii. matrix2; An example of using BLAS and LAPACK calls directly from the Psi input file, demonstrating. extern2; External potential calculation involving a TIP3P water and a QM water for DFMP2. Finite different test of the gradient is performed to validate forces. casscf-sp; CASSCF/6-31G** energy point. dft-grad-lr3; wB97X-D test for a large UKS molecule update ref gradient due to new BraggSlater radii. nbody-intermediates; HF/cc-pVDZ many body energies of an arbitrary noble gas trimer complex Size vs cost tradeoff is rough here. cc44; Test case for some of the PSI4 out-of-core codes. The code is given only 2.0 MB of memory, which is insufficient to hold either the A1 or B2 blocks of an ovvv quantity in-core, but is sufficient to hold at least two copies of an oovv quantity in-core. oremp-grad1; integral conventional OO-REMP/cc-pVDZ engrad single points for the H2O molecule. pywrap-molecule; Check that C++ Molecule class and qcdb molecule class are reading molecule input strings identically. fci-tdm-2; BH-H2+ FCI/cc-pVDZ Transition Dipole Moment. rasci-h2o; RASCI/6-31G** H2O Energy Point. casscf-sa-sp; Example of state-averaged CASSCF for the C2 molecule see C. D. Sherrill and P. Piecuch, J. Chem. Phys. 122, 124104 (2005). props3; DF-SCF cc-pVDZ multipole moments ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/autodoc_testsuite_corepsi4.html:7208,energy,energy,7208,psi4manual/1.8.x/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/autodoc_testsuite_corepsi4.html,2,['energy'],['energy']
Energy Efficiency,"Z; energy('ccsd'); set ccenergy print 3; set scf print 1. the commands that set the print level would be ineffective, as they would be; processed after the CCSD computation completes. Basis Sets¶. Basis Sets; Built-In Basis Sets; Mixing Basis Sets; Decontracted Basis Sets; User-Defined Basis Sets. PSI Variables¶; To harness the power of Python, Psi4 makes the most pertinent results; of each computation available to the Python interpreter for; post-processing. To demonstrate, we can embellish the previous example of; H2 and H atom:; molecule h2 {; H; H 1 0.9; }. set basis cc-pvdz; set reference rhf; h2_energy = energy('scf'). molecule h {; H; }. set basis cc-pvdz; set reference uhf; h_energy = energy('scf'). D_e = psi_hartree2kcalmol * (2*h_energy - h2_energy); print ""De=%f"" % D_e. The energy() function returns the final result of the; computation, the requested total energy in Hartrees, which we assign to a; Python variable. The two energies are then converted to a dissociation; energy and printed to the output file using standard Python notation.; Generally, there are multiple quantities of interest. Appendix; PSI Variables by Module lists PSI variables variables set by each; module, and PSI Variables by Alpha defines them. These can be; accessed through the get_variable() function. For example, after; performing a density fitted MP2 computation, both the spin component; scaled energy and the unscaled MP2 energy are made available:; e_mp2 = get_variable('MP2 TOTAL ENERGY'); e_scs_mp2 = get_variable('SCS-MP2 TOTAL ENERGY'). Each module and the Python driver set PSI variables over the course of a; calculation. The values for all can be printed in the output file with; the input file command print_variables(). Note that PSI variables; are cleared at the start of each energy(), etc. in an input; file by clean_variables().; So if you run in a single input file a STO-3G FCI followed by a; aug-cc-pVQZ SCF followed by a print_variables() command, the; last will include SCF ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/psithoninput-1.html:8464,energy,energy,8464,psi4manual/1.0.0/psithoninput-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/psithoninput-1.html,2,['energy'],['energy']
Energy Efficiency,"ZMatrix coordinates, whether they belong to the same fragment or not. Note that the Cartesian specification must come before the ZMatrix entries because the former define absolute positions, while the latter are relative. opt6; Various constrained energy minimizations of HOOH with cc-pvdz RHF Internal-coordinate constraints in internal-coordinate optimizations. mints-helper; A general test of the MintsHelper function. dfcasscf-sa-sp; Example of state-averaged CASSCF for the C2 molecule. ci-property; CI/MCSCF cc-pvDZ properties for Potassium nitrate (rocket fuel!). scf-upcast-custom-basis; test scf castup with custom basis sets. dct10; The multiple guesses for DCT amplitudes for ODC-12. sapt5; SAPT0 aug-cc-pVTZ computation of the charge transfer energy of the water dimer. cc34; RHF-CCSD/cc-pVDZ energy of H2O partitioned into pair energy contributions. dft-grad1; DF-BP86-D2 cc-pVDZ frozen core gradient of S22 HCN update ref gradient due to new BraggSlater radii. sapt-ecp; sapt0 of charged system in ECP basis set. cc15; RHF-B-CCD(T)/6-31G** H2O single-point energy (fzc, MO-basis \(\langle ab|cd \rangle\)). scf-freq1; Analytic vs. finite difference DF-SCF frequency test for water. cbs-xtpl-alpha; Extrapolated water energies. sapt3; SAPT2+3(CCD) aug-cc-pVDZ+midbond computation of the water dimer interaction energy, using the aug-cc-pVDZ-JKFIT DF basis for SCF and aug-cc-pVDZ-RI for SAPT. fci-tdm; He2+ FCI/cc-pVDZ Transition Dipole Moment. tu5-sapt; Example SAPT computation for ethene*ethine (i.e., ethylene*acetylene), test case 16 from the S22 database. dfmp2-3; DF-MP2 cc-pVDZ frozen core gradient of benzene, computed at the DF-SCF cc-pVDZ geometry. dct8; DCT calculation for the NH3+ radical using the ODC-12 and ODC-13 functionals. This performs both simultaneous and QC update of the orbitals and cumulant using DIIS extrapolation. Four-virtual integrals are first handled in the MO Basis for the first two energy computations. In the next computation ao_basis=disk algorith",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/autodoc_testsuite_corepsi4.html:21831,charge,charged,21831,psi4manual/1.9.x/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/autodoc_testsuite_corepsi4.html,2,['charge'],['charged']
Energy Efficiency,"ZP level of theory. x2c3; Test of SFX2C-1e on Water uncontracted cc-pVDZ The reference numbers are from Lan Cheng’s implementation in Cfour. sapt7; SAPT0 open-shell computation of H2O-HO2 interaction energy First with cc-pVDZ and density fitted integrals with UHF Then with 6-31g and direct integrals, except for dispersion that is computed with cc-pVDZ-ri density fitting with UHF. x2c1; Test of SFX2C-1e on water uncontracted cc-pVDZ-DK The reference numbers are from Lan Cheng’s implementation in Cfour. mp2-grad2; MP2 cc-pVDZ gradient for the NO radical. scf7; Tests SCF gradient in the presence of a dipole field. dft-dldf; Dispersionless density functional (dlDF+D) internal match to Psi4 Extensive testing has been done to match supplemental info of Szalewicz et. al., Phys. Rev. Lett., 103, 263201 (2009) and Szalewicz et. al., J. Phys. Chem. Lett., 1, 550-555 (2010). cc9a; ROHF-CCSD(T) cc-pVDZ energy for the \(^2\Sigma^+\) state of the CN radical, with Z-matrix input. ao-casscf-sp; CASSCF/6-31G** energy point. castup1; Test of SAD/Cast-up (mainly not dying due to file weirdness). dfcasscf-sp; CASSCF/6-31G** energy point. cc18; RHF-CCSD-LR/cc-pVDZ static polarizability of HOF. cc6; Frozen-core CCSD(T)/cc-pVDZ on C4H4N anion with disk ao algorithm. pywrap-all; Intercalls among python wrappers- database, cbs, optimize, energy, etc. Though each call below functions individually, running them all in sequence or mixing up the sequence is aspirational at present. Also aspirational is using the intended types of gradients. omp2p5-grad2; OMP2.5 cc-pVDZ gradient for the NO radical. sapt6; checks that all SAPT physical components (elst, exch, indc, disp) and total IE are being computed correctly for SAPT2+3(CCD)dMP2/aug-cc-pvdz and all lesser methods thereof. omp2-3; OMP2 cc-pVDZ energy for the NO radical. mcscf1; ROHF 6-31G** energy of the \(^{3}B_1\) state of CH2, with Z-matrix input. The occupations are specified explicitly. cc29; CCSD/cc-pVDZ optical rotation calculation (both",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/autodoc_testsuite_corepsi4-1.html:12951,energy,energy,12951,psi4manual/1.4.0/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodoc_testsuite_corepsi4-1.html,4,['energy'],['energy']
Energy Efficiency,"ZSET[0], 0.0]))}. return NEED. elif (mode == 'evaluate'):. # Extract required energies and zeta integers from array; eHI = NEED['HI']['f_energy']; eLO = NEED['LO']['f_energy']; zHI = NEED['HI']['f_zeta']; zLO = NEED['LO']['f_zeta']. # LAB TODO add ability to pass alternate parameter values in. # Return extrapolated energy; alpha = 1.63; beta = (eHI - eLO) / (math.exp(-1 * alpha * zLO) * (math.exp(-1 * alpha) - 1)); energypiece = eHI - beta * math.exp(-1 * alpha * zHI). # Output string with extrapolation parameters; cbsscheme = ''; cbsscheme += """"""\n ==> %s <==\n\n"""""" % (functionname); cbsscheme += """""" LO-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(zLO), eLO); cbsscheme += """""" HI-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(zHI), eHI); cbsscheme += """""" Extrapolated Correlation Energy: %16.8f\n"""""" % (energypiece); cbsscheme += """""" Alpha (exponent) Value: %16.8f\n"""""" % (alpha); cbsscheme += """""" Beta (coefficient) Value: %16.8f\n"""""" % (beta); PsiMod.print_out(cbsscheme). return energypiece. [docs]def validate_scheme_args(functionname, **largs):; r""""""Function called by each extrapolation scheme in :py:func:`~wrappers.complete_basis_set`.; Checks that all the input arguments are present and suitable so that; the scheme function can focus on defining the extrapolation. """"""; mode = ''; NEED = []; wfnname = ''; BSET = []; ZSET = []. # Mode where function fills out a form NEED with the computations needed to fulfill its call; if (largs['mode'].lower() == 'requisition'):; mode = largs['mode'].lower(). if 'wfnname' in largs:; wfnname = largs['wfnname']; else:; raise ValidationError('Call to \'%s\' has keyword \'wfnname\' missing.' % (functionname)). if re.match(r'scf_.*$', functionname) and (wfnname != 'scf'):; raise ValidationError('Call to \'%s\' is intended for scf portion of calculation.' % (functionname)); if re.match(r'corl_.*$', functionname) and (wfnname == 'scf'):; raise ValidationError('Call to \'%s\' is not intended for scf portion of calculation.' % (functi",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:84400,energy,energypiece,84400,psi4manual/4.0b2/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html,6,['energy'],['energypiece']
Energy Efficiency,"[""params""]; is easily editable for this purpose. See Advanced Functional Use and Manipulation. 12; [Caldeweyher:2019:154122]. A few practical examples:. DFT-D2 single point with default parameters (dftd3 not called); energy('bp86-d'). DFT-D3BJ optimization with default parameters; optimize('pbe-d3bj'). DFT-D2 optimization with custom s6 parameter; set dft_dispersion_parameters [1.20]; optimize('b3lyp-d2'). DFT-D3ZERO single point (b3lyp) with custom s8 parameter (reset all four values); set dft_dispersion_parameters [1.0, 2.0, 1.261, 14.0]; energy('b3lyp-d3'). DFT-D2 single point with dftd3 instead of PSI4‘s libdisp; energy('pbe-d2', engine='dftd3'). If only dispersion corrections (rather than total energies) are of; interest, the dispersion programs can be run independently of the scf; through the python function run_dftd3() or run_dftd4(). (These functions; call QCEngine, which is the same PSI4 + dftd3/dftd4 interface that is called during an scf job.); This “D-only” route is much faster than running a DFT-D energy.; Note that in a DFT+D energy or gradient calculation, user-specified; dispersion parameters override any information provided about the; functional. The same holds true for a dftd3 “D-only” calculation. But; in a dftd4 “D-only” calculation, functional information overrides; any user-specified dispersion parameters. Some set-up:; molecule nene {; Ne; Ne 1 2.0; }. nene.update_geometry(). The same four dispersion corrections/gradients as the section above:; >>> print nene.run_dftd3('bp86', 'd', dertype=0); -7.735e-05. >>> E, G = nene.run_dftd3('pbe', 'd3bj'); >>> print G; [[0.0, 0.0, -1.1809087569358e-05], [0.0, 0.0, 1.1809087569358e-05]]. >>> E, G = nene.run_dftd3('b3lyp', 'd2', {'s6': 1.20}); >>> print E; -8.84e-05. >>> E, G = nene.run_dftd3(dashlvl='d3', dashparam={'s8': 2.0, 'alpha6': 14.0, 'sr6': 1.261, 's6': 1.0}); >>> print E; -0.00024762. qcdb.Molecule.run_dftd3(self, func=None, dashlvl=None, dashparam=None, dertype=None, verbose=1)¶; Compute disp",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/dftd3-1.html:9609,energy,energy,9609,psi4manual/1.5.0/dftd3-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/dftd3-1.html,3,['energy'],['energy']
Energy Efficiency,"['d_coef']; for lvl in stage['d_need'].values():; required.append((lvl['f_wfn'], lvl['f_basis'], lvl['f_options'])). tables += headfmt.format('', 'Method', '/', 'Basis', 'Rqd', 'Energy [Eh]', 'Variable'); tables += delimit; for job in TROVE:; star = ''; for mc in required:; if (job['f_wfn'], job['f_basis'], job['f_options']) == mc:; star = '*'; tables += linefmt.format('', job['f_wfn'], '/', job['f_basis'] + "" + options"" * bool(job['f_options']), star,; job['f_energy'], VARH[job['f_wfn']][job['f_wfn']]); tables += delimit. tables += blckfmt.format('Stages'); tables += delimit; tables += headfmt.format('Stage', 'Method', '/', 'Basis', 'Wt', 'Energy [Eh]', 'Scheme'); tables += delimit; for stage in GRAND_NEED:; tables += linefmt.format(stage['d_stage'], stage['d_wfn'], '/', stage['d_basis'], stage['d_coef'],; stage['d_energy'], stage['d_scheme']); tables += delimit. tables += blckfmt.format('CBS'); tables += delimit; tables += headfmt.format('Stage', 'Method', '/', 'Basis', '', 'Energy [Eh]', 'Scheme'); tables += delimit; tables += linefmt.format(GRAND_NEED[0]['d_stage'], GRAND_NEED[0]['d_wfn'], '/', GRAND_NEED[0]['d_basis'], '',; GRAND_NEED[0]['d_energy'], GRAND_NEED[0]['d_scheme']). if len(metadata) > 1:; dc = 1; for delta in metadata[1:]:; mtdstr = GRAND_NEED[dc]['d_wfn']; if dc != 1:; mtdstr += ' - ' + GRAND_NEED[dc + 1]['d_wfn']; tables += linefmt.format(GRAND_NEED[dc]['d_stage'], mtdstr, '/', GRAND_NEED[dc]['d_basis'], '',; GRAND_NEED[dc]['d_energy'] - GRAND_NEED[dc + 1]['d_energy'],; GRAND_NEED[dc]['d_scheme']); dc += 2. tables += linefmt.format('total', 'CBS', '', '', '', finalenergy, ''); tables += delimit. return tables. [docs]; class CompositeComputer(BaseComputer):. molecule: Any; basis: str = ""(auto)""; method: str = ""(auto)""; driver: DriverEnum; keywords: Dict[str, Any] = {}; metadata: Any; metameta: Dict[str, Any] = {}. verbose: int = 1. # List of model chemistries with extrapolation scheme applied. Can reconstruct CBS. Keys are d_fields. Formerly GRAND_N",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html:52168,Energy,Energy,52168,psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html,3,['Energy'],['Energy']
Energy Efficiency,"['d_coef']; for lvl in stage['d_need'].values():; required.append((lvl['f_wfn'], lvl['f_basis'], lvl['f_options'])). tables += headfmt.format('', 'Method', '/', 'Basis', 'Rqd', 'Energy [Eh]', 'Variable'); tables += delimit; for job in TROVE:; star = ''; for mc in required:; if (job['f_wfn'], job['f_basis'], job['f_options']) == mc:; star = '*'; tables += linefmt.format('', job['f_wfn'], '/', job['f_basis'] + "" + options"" * bool(job['f_options']), star,; job['f_energy'], VARH[job['f_wfn']][job['f_wfn']]); tables += delimit. tables += blckfmt.format('Stages'); tables += delimit; tables += headfmt.format('Stage', 'Method', '/', 'Basis', 'Wt', 'Energy [Eh]', 'Scheme'); tables += delimit; for stage in GRAND_NEED:; tables += linefmt.format(stage['d_stage'], stage['d_wfn'], '/', stage['d_basis'], stage['d_coef'],; stage['d_energy'], stage['d_scheme']); tables += delimit. tables += blckfmt.format('CBS'); tables += delimit; tables += headfmt.format('Stage', 'Method', '/', 'Basis', '', 'Energy [Eh]', 'Scheme'); tables += delimit; tables += linefmt.format(GRAND_NEED[0]['d_stage'], GRAND_NEED[0]['d_wfn'], '/', GRAND_NEED[0]['d_basis'], '',; GRAND_NEED[0]['d_energy'], GRAND_NEED[0]['d_scheme']). if len(metadata) > 1:; dc = 1; for delta in metadata[1:]:; mtdstr = GRAND_NEED[dc]['d_wfn']; if dc != 1:; mtdstr += ' - ' + GRAND_NEED[dc + 1]['d_wfn']; tables += linefmt.format(GRAND_NEED[dc]['d_stage'], mtdstr, '/', GRAND_NEED[dc]['d_basis'], '',; GRAND_NEED[dc]['d_energy'] - GRAND_NEED[dc + 1]['d_energy'],; GRAND_NEED[dc]['d_scheme']); dc += 2. tables += linefmt.format('total', 'CBS', '', '', '', finalenergy, ''); tables += delimit. return tables. [docs]class CompositeComputer(BaseComputer):. molecule: Any; basis: str = ""(auto)""; method: str = ""(auto)""; driver: DriverEnum; keywords: Dict[str, Any] = {}; metadata: Any; metameta: Dict[str, Any] = {}. verbose: int = 1. # List of model chemistries with extrapolation scheme applied. Can reconstruct CBS. Keys are d_fields. Formerly GRAND_NEE",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver_cbs.html:51993,Energy,Energy,51993,psi4manual/1.7.x/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver_cbs.html,1,['Energy'],['Energy']
Energy Efficiency,"['d_coef']; for lvl in stage['d_need'].values():; required.append((lvl['f_wfn'], lvl['f_basis'], lvl['f_options'])). tables += headfmt.format('', 'Method', '/', 'Basis', 'Rqd', 'Energy [Eh]', 'Variable'); tables += delimit; for job in TROVE:; star = ''; for mc in required:; if (job['f_wfn'], job['f_basis'], job['f_options']) == mc:; star = '*'; tables += linefmt.format('', job['f_wfn'], '/', job['f_basis'] + "" + options"" * bool(job['f_options']), star,; job['f_energy'], VARH[job['f_wfn']][job['f_wfn']]); tables += delimit. tables += blckfmt.format('Stages'); tables += delimit; tables += headfmt.format('Stage', 'Method', '/', 'Basis', 'Wt', 'Energy [Eh]', 'Scheme'); tables += delimit; for stage in GRAND_NEED:; tables += linefmt.format(stage['d_stage'], stage['d_wfn'], '/', stage['d_basis'], stage['d_coef'],; stage['d_energy'], stage['d_scheme']); tables += delimit. tables += blckfmt.format('CBS'); tables += delimit; tables += headfmt.format('Stage', 'Method', '/', 'Basis', '', 'Energy [Eh]', 'Scheme'); tables += delimit; tables += linefmt.format(GRAND_NEED[0]['d_stage'], GRAND_NEED[0]['d_wfn'], '/', GRAND_NEED[0]['d_basis'], '',; GRAND_NEED[0]['d_energy'], GRAND_NEED[0]['d_scheme']). if len(metadata) > 1:; dc = 1; for delta in metadata[1:]:; mtdstr = GRAND_NEED[dc]['d_wfn']; if dc != 1:; mtdstr += ' - ' + GRAND_NEED[dc + 1]['d_wfn']; tables += linefmt.format(GRAND_NEED[dc]['d_stage'], mtdstr, '/', GRAND_NEED[dc]['d_basis'], '',; GRAND_NEED[dc]['d_energy'] - GRAND_NEED[dc + 1]['d_energy'],; GRAND_NEED[dc]['d_scheme']); dc += 2. tables += linefmt.format('total', 'CBS', '', '', '', finalenergy, ''); tables += delimit. return tables. class CompositeComputer(BaseComputer):. molecule: Any; basis: str = ""(auto)""; method: str = ""(auto)""; driver: DriverEnum; keywords: Dict[str, Any] = {}; metadata: Any; metameta: Dict[str, Any] = {}. verbose: int = 1. # List of model chemistries with extrapolation scheme applied. Can reconstruct CBS. Keys are d_fields. Formerly GRAND_NEED.; cb",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver_cbs.html:51794,Energy,Energy,51794,psi4manual/1.6.x/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver_cbs.html,1,['Energy'],['Energy']
Energy Efficiency,"['molecule'] = val['molecule'].to_schema(dtype=2). nbody_model = AtomicResult(; **{; 'driver': self.driver,; 'model': {; 'method': self.method,; 'basis': self.basis,; },; 'molecule': self.molecule.to_schema(dtype=2),; 'properties': properties,; 'provenance': p4util.provenance_stamp(__name__),; 'extras': {; 'qcvars': qcvars,; 'component_results': component_results,; },; 'return_result': ret_ptype,; 'success': True,; }). return nbody_model. [docs] def get_psi_results(self, return_wfn: bool = False) -> EnergyGradientHessianWfnReturn:; """"""Called by driver to assemble results into ManyBody-flavored QCSchema,; then reshape and return them in the customary Psi4 driver interface: ``(e/g/h, wfn)``. Parameters; ----------; return_wfn; Whether to additionally return the dummy :py:class:`~psi4.core.Wavefunction`; calculation result as the second element of a tuple. Contents are:. - supersystem molecule; - dummy basis, def2-svp; - e/g/h member data; - QCVariables. Returns; -------; ret; Energy, gradient, or Hessian according to self.driver.; wfn; Wavefunction described above when *return_wfn* specified. """"""; nbody_model = self.get_results(); ret = nbody_model.return_result. wfn = core.Wavefunction.build(self.molecule, ""def2-svp"", quiet=True). # TODO all besides nbody may be better candidates for extras than qcvars. energy/gradient/hessian_body_dict in particular are too simple for qcvars (e.g., ""2""); dicts = [; #""energies"", # retired; #""ptype"", # retired; ""intermediates"",; ""intermediates_energy"", #""intermediates2"",; ""intermediates_gradient"", #""intermediates_ptype"",; ""intermediates_hessian"", #""intermediates_ptype"",; ""energy_body_dict"",; ""gradient_body_dict"", # ptype_body_dict; ""hessian_body_dict"", # ptype_body_dict; ""nbody"",; ""cp_energy_body_dict"",; ""nocp_energy_body_dict"",; ""vmfc_energy_body_dict"",; ""cp_gradient_body_dict"",; ""nocp_gradient_body_dict"",; ""vmfc_gradient_body_dict"",; ""cp_hessian_body_dict"",; ""nocp_hessian_body_dict"",; ""vmfc_hessian_body_dict"",; ]. for qcv, val in nbo",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver_nbody.html:91155,Energy,Energy,91155,psi4manual/1.6.x/_modules/psi4/driver/driver_nbody.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver_nbody.html,2,['Energy'],['Energy']
Energy Efficiency,"['ptype'], cp_compute_list[n],; fragment_slice_dict, fragment_size_dict, cp_ptype_by_level[n]); _sum_cluster_ptype_data(metadata['ptype'], component_results['ptype'], nocp_compute_list[n],; fragment_slice_dict, fragment_size_dict, nocp_ptype_by_level[n]); _sum_cluster_ptype_data(; metadata['ptype'],; component_results['ptype'],; vmfc_level_list[n],; fragment_slice_dict,; fragment_size_dict,; vmfc_ptype_by_level[n],; vmfc=True,; n=n). # Add extracted monomers back.; for i, j in enumerate(cp_monomers_in_monomer_basis):; cp_compute_list[1].add(j). if metadata['ptype'] != 'energy':; # Extract ptype data for monomers in monomer basis for CP total data; cp_monomer_ptype = np.zeros(arr_shape); _sum_cluster_ptype_data(metadata['ptype'], component_results['ptype'], cp_monomers_in_monomer_basis,; fragment_slice_dict, fragment_size_dict, cp_monomer_ptype). # Compute cp energy and ptype; if 'cp' in metadata['bsse_type_list']:; for n in nbody_range:; if n == metadata['max_frag']:; cp_energy_body_dict[n] = cp_energy_by_level[n] - bsse; if metadata['ptype'] != 'energy':; cp_ptype_body_dict[n][:] = cp_ptype_by_level[n] - bsse_ptype; continue. for k in range(1, n + 1):; take_nk = nCr(metadata['max_frag'] - k - 1, n - k); sign = ((-1)**(n - k)); value = cp_energy_by_level[k]; cp_energy_body_dict[n] += take_nk * sign * value. if metadata['ptype'] != 'energy':; value = cp_ptype_by_level[k]; cp_ptype_body_dict[n] += take_nk * sign * value. if n == 1:; bsse = cp_energy_body_dict[n] - cp_monomer_energies; cp_energy_body_dict[n] = cp_monomer_energies; if metadata['ptype'] != 'energy':; bsse_ptype = cp_ptype_body_dict[n] - cp_monomer_ptype; cp_ptype_body_dict[n] = cp_monomer_ptype.copy(). else:; cp_energy_body_dict[n] -= bsse; if metadata['ptype'] != 'energy':; cp_ptype_body_dict[n] -= bsse_ptype. cp_interaction_energy = cp_energy_body_dict[metadata['max_nbody']] - cp_energy_body_dict[1]; nbody_dict['Counterpoise Corrected Interaction Energy'] = cp_interaction_energy. for n in nbody_range[1:",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver_nbody.html:24044,energy,energy,24044,psi4manual/1.3.2/_modules/psi4/driver/driver_nbody.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver_nbody.html,2,['energy'],['energy']
Energy Efficiency,"['scheme'] = kwargs.pop('corl_scheme'); stage['stage'] = ""corl""; stage['treatment'] = ""corl""; metadata.append(stage). # ""method/basis"" syntax only allows for one delta correction; # via ""method/basis+D:delta/basis"". Maximum length of method_list is 2.; if len(method_list) == 2:; stage = {}; stage['wfn'] = method_list[1]; stage['basis'] = basis_list[1]; if 'delta_scheme' in kwargs:; stage['scheme'] = kwargs.pop('delta_scheme'); stage['stage'] = ""delta1""; stage['treatment'] = ""corl""; metadata.append(stage). cbs_kwargs[""cbs_metadata""] = metadata. return cbs_kwargs. def _build_cbs_compute(metameta: Dict[str, Any], metadata: CBSMetadata):; label = metameta['label']; ptype = metameta['ptype']; verbose = metameta['verbose']. # Build string of title banner; instructions = ""\n"" + p4util.banner(f"" CBS Setup{':' + label if label else ''} "", strNotOutfile=True) + ""\n"". # Call schemes for each portion of total energy to 'place orders' for calculations needed; d_fields = [; 'd_stage', 'd_scheme', 'd_basis', 'd_wfn', 'd_alpha', 'd_need', 'd_coef', 'd_energy', 'd_gradient', 'd_hessian', 'd_dipole', 'd_dipder'; ]; GRAND_NEED = []. NEED = _expand_scheme_orders(metadata[0][""scheme""], metadata[0][""basis""][0], metadata[0][""basis""][1],; metadata[0][""wfn""], metadata[0][""options""]); GRAND_NEED.append(; dict(; zip(d_fields, [; 'scf', metadata[0][""scheme""],; _contract_bracketed_basis(metadata[0][""basis""][0]), metadata[0][""wfn""], metadata[0][""alpha""], NEED, +1,; 0.0, None, None, None, None; ]))); if len(metadata) > 1:; for delta in metadata[1:]:; NEED = _expand_scheme_orders(delta[""scheme""], delta[""basis""][0], delta[""basis""][1], delta[""wfn""],; delta[""options""]); GRAND_NEED.append(; dict(; zip(d_fields, [; delta[""stage""], delta[""scheme""],; _contract_bracketed_basis(delta[""basis""][0]), delta[""wfn""], delta[""alpha""], NEED, +1, 0.0,; None, None, None, None; ]))); NEED = _expand_scheme_orders(delta[""scheme""], delta[""basis_lo""][0], delta[""basis_lo""][1], delta[""wfn_lo""],; delta[""options_lo""]); GRAND_",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver_cbs.html:42888,energy,energy,42888,psi4manual/1.6.x/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver_cbs.html,10,['energy'],['energy']
Energy Efficiency,"[(e a0/a0)^2/u] with respect to nuclear perturbations; as a degree-of-freedom by dipole component array, (3 * {nat}, 3). SCF TOTAL HESSIAN¶; The total electronic second derivative [E_h/a0/a0] for the SCF stage, (3 * {nat}, 3 * {nat}). SCF STABILITY EIGENVALUES¶; Array of eigenvalues from UHF or ROHF stability analysis. SCS-CCSD TOTAL ENERGY¶. SCS-CCSD CORRELATION ENERGY¶; The total electronic energy [E_h] and correlation energy component [E_h]; for the CCSD-like method formed by reweighting CCSD DOUBLES ENERGY; by 1.27 opposite-spin and 1.13 same-spin contributions, with; any singles carried along. SCS-MP2 TOTAL ENERGY¶. SCS-MP2 CORRELATION ENERGY¶; The total electronic energy [E_h] and correlation energy component [E_h]; for the MP2-like method formed by reweighting MP2 DOUBLES ENERGY; by 6/5 opposite-spin and 1/3 same-spin contributions, with; any singles carried along. SCS-MP2-VDW TOTAL ENERGY¶. SCS-MP2-VDW CORRELATION ENERGY¶; The total electronic energy [E_h] and correlation energy component [E_h]; for the MP2-like method formed by reweighting MP2 DOUBLES ENERGY; by 1.28 opposite-spin and 0.50 same-spin contributions, with; any singles carried along. DOI: 10.1080/00268970802641242. SCS(N)-MP2 TOTAL ENERGY¶. SCS(N)-MP2 CORRELATION ENERGY¶; The total electronic energy [E_h] and correlation energy component [E_h]; for the MP2-like method formed by reweighting MP2 DOUBLES ENERGY; by 0 opposite-spin and 1.76 same-spin contributions, with; any singles carried along. doi: 10.1021/ct6002737. SCS(N)-OMP2 CORRELATION ENERGY¶. SCS(N)-OMP2 TOTAL ENERGY¶. SCSN-OMP2 CORRELATION ENERGY¶. SCSN-OMP2 TOTAL ENERGY¶; Two spellings of a discontinued QCVariable that may still appear; because the code is frozen pending an update. SCS-OMP2 TOTAL ENERGY¶. SCS-OMP2 CORRELATION ENERGY¶; The total electronic energy [E_h] and correlation energy component [E_h]; for the OMP2-like method formed by reweighting OMP2 DOUBLES ENERGY; by 6/5 opposite-spin and 1/3 same-spin contributions, with; any",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/glossary_psivariables.html:54898,energy,energy,54898,psi4manual/1.7.x/glossary_psivariables.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/glossary_psivariables.html,8,['energy'],['energy']
Energy Efficiency,"[0]), str(pair[1]))); ghost = list(set(pair[1]) - set(pair[0])). current_mol = molecule.extract_subsets(list(pair[0]), ghost); ptype_dict[pair] = func(method_string, molecule=current_mol, **kwargs); energies_dict[pair] = psi4.get_variable(""CURRENT ENERGY""); psi4.print_out(""\n N-Body: Complex Energy (fragments = %s, basis = %s: %20.14f)\n"" % ; (str(pair[0]), str(pair[1]), energies_dict[pair])); ; # Flip this off for now, needs more testing; #if 'cp' in bsse_type_list and (len(bsse_type_list) == 1):; # psi4.set_global_option('DF_INTS_IO', 'LOAD'). psi4.clean(). # Final dictionaries; cp_energy_by_level = {n: 0.0 for n in nbody_range}; nocp_energy_by_level = {n: 0.0 for n in nbody_range}. cp_energy_body_dict = {n: 0.0 for n in nbody_range}; nocp_energy_body_dict = {n: 0.0 for n in nbody_range}; vmfc_energy_body_dict = {n: 0.0 for n in nbody_range}. # Build out ptype dictionaries if needed; if ptype != 'energy':; if ptype == 'gradient':; arr_shape = (molecule_total_atoms, 3); elif ptype == 'hessian':; arr_shape = (molecule_total_atoms * 3, molecule_total_atoms * 3); else:; raise KeyError(""N-Body: ptype '%s' not recognized"" % ptype). cp_ptype_by_level = {n: np.zeros(arr_shape) for n in nbody_range}; nocp_ptype_by_level = {n: np.zeros(arr_shape) for n in nbody_range}; vmfc_ptype_by_level = {n: np.zeros(arr_shape) for n in nbody_range}. cp_ptype_body_dict = {n: np.zeros(arr_shape) for n in nbody_range}; nocp_ptype_body_dict = {n: np.zeros(arr_shape) for n in nbody_range}; vmfc_ptype_body_dict = {n: np.zeros(arr_shape) for n in nbody_range}; else:; cp_ptype_by_level, cp_ptype_body_dict = None, None; nocp_ptype_by_level, nocp_ptype_body_dict = None, None; vmfc_ptype_body_dict = None. # Sum up all of the levels; for n in nbody_range:. # Energy; cp_energy_by_level[n] = sum(energies_dict[v] for v in cp_compute_list[n]); nocp_energy_by_level[n] = sum(energies_dict[v] for v in nocp_compute_list[n]). # Special vmfc case; if n > 1:; vmfc_energy_body_dict[n] = vmfc_energy_body_dict[n ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/driver_nbody.html:10559,energy,energy,10559,psi4manual/1.0.0/_modules/driver_nbody.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver_nbody.html,1,['energy'],['energy']
Energy Efficiency,"[1][:zetaindx]; post = basisarray[1][zetaindx + 1:]. return """".join([pre, ""["", *ZSET, ""]"", post]). def return_energy_components():; """"""Define some quantum chemical knowledge, namely what methods are subsumed in others."""""". # yapf: disable; VARH = {}; VARH['scf'] = {; 'scf': 'SCF TOTAL ENERGY'}; VARH['hf'] = {; 'hf': 'HF TOTAL ENERGY'}; VARH['mp2'] = {; 'hf': 'HF TOTAL ENERGY',; 'mp2': 'MP2 TOTAL ENERGY'}; VARH['dlpno-mp2'] = {; 'hf': 'HF TOTAL ENERGY',; 'dlpno-mp2': 'MP2 TOTAL ENERGY'}; VARH['mp2d'] = {; 'hf': 'HF TOTAL ENERGY',; 'mp2d': 'MP2D TOTAL ENERGY'}; VARH['mp2.5'] = {; 'hf': 'HF TOTAL ENERGY',; 'mp2': 'MP2 TOTAL ENERGY',; 'mp2.5': 'MP2.5 TOTAL ENERGY',; 'mp3': 'MP3 TOTAL ENERGY'}; VARH['mp3'] = {; 'hf': 'HF TOTAL ENERGY',; 'mp2': 'MP2 TOTAL ENERGY',; 'mp2.5': 'MP2.5 TOTAL ENERGY',; 'mp3': 'MP3 TOTAL ENERGY'}; VARH['mp4(sdq)'] = {; 'hf': 'HF TOTAL ENERGY',; 'mp2': 'MP2 TOTAL ENERGY',; 'mp2.5': 'MP2.5 TOTAL ENERGY',; 'mp3': 'MP3 TOTAL ENERGY',; 'mp4(sdq)': 'MP4(SDQ) TOTAL ENERGY'}; VARH['mp4'] = {; 'hf': 'HF TOTAL ENERGY',; 'mp2': 'MP2 TOTAL ENERGY',; 'mp2.5': 'MP2.5 TOTAL ENERGY',; 'mp3': 'MP3 TOTAL ENERGY',; 'mp4(sdq)': 'MP4(SDQ) TOTAL ENERGY',; 'mp4': 'MP4 TOTAL ENERGY'}; VARH['omp2'] = {; 'hf': 'HF TOTAL ENERGY',; 'mp2': 'MP2 TOTAL ENERGY',; 'omp2': 'OMP2 TOTAL ENERGY'}; VARH['omp2.5'] = {; 'hf': 'HF TOTAL ENERGY',; 'mp2': 'MP2 TOTAL ENERGY',; 'mp2.5': 'MP2.5 TOTAL ENERGY',; 'omp2.5': 'OMP2.5 TOTAL ENERGY'}; VARH['omp3'] = {; 'hf': 'HF TOTAL ENERGY',; 'mp2': 'MP2 TOTAL ENERGY',; 'mp3': 'MP3 TOTAL ENERGY',; 'omp3': 'OMP3 TOTAL ENERGY'}; VARH['olccd'] = {; 'hf': 'HF TOTAL ENERGY',; 'mp2': 'MP2 TOTAL ENERGY',; 'olccd': 'OLCCD TOTAL ENERGY'}; VARH['lccd'] = {; 'hf': 'HF TOTAL ENERGY',; 'mp2': 'MP2 TOTAL ENERGY',; 'lccd': 'LCCD TOTAL ENERGY'}; VARH['lccsd'] = {; 'hf': 'HF TOTAL ENERGY',; 'mp2': 'MP2 TOTAL ENERGY',; 'lccsd': 'LCCSD TOTAL ENERGY'}; VARH['cepa(0)'] = {; 'hf': 'HF TOTAL ENERGY',; 'mp2': 'MP2 TOTAL ENERGY',; 'cepa(0)': 'CEPA(0) TOTAL ENERGY'}; VARH",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver_cbs.html:11787,ENERGY,ENERGY,11787,psi4manual/1.6.x/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver_cbs.html,5,['ENERGY'],['ENERGY']
Energy Efficiency,"[1][:zetaindx]; post = basisarray[1][zetaindx + 1:]. return """".join([pre, ""["", *ZSET, ""]"", post]). def return_energy_components():; """"""Define some quantum chemical knowledge, namely what methods are subsumed in others."""""". # yapf: disable; VARH = {}; VARH['scf'] = {; 'scf': 'SCF TOTAL ENERGY'}; VARH['hf'] = {; 'hf': 'HF TOTAL ENERGY'}; VARH['mp2'] = {; 'hf': 'HF TOTAL ENERGY',; 'mp2': 'MP2 TOTAL ENERGY'}; VARH['dlpno-mp2'] = {; 'hf': 'HF TOTAL ENERGY',; 'dlpno-mp2': 'MP2 TOTAL ENERGY'}; VARH['mp2d'] = {; 'hf': 'HF TOTAL ENERGY',; 'mp2d': 'MP2D TOTAL ENERGY'}; VARH['mp2.5'] = {; 'hf': 'HF TOTAL ENERGY',; 'mp2': 'MP2 TOTAL ENERGY',; 'mp2.5': 'MP2.5 TOTAL ENERGY',; 'mp3': 'MP3 TOTAL ENERGY'}; VARH['mp3'] = {; 'hf': 'HF TOTAL ENERGY',; 'mp2': 'MP2 TOTAL ENERGY',; 'mp2.5': 'MP2.5 TOTAL ENERGY',; 'mp3': 'MP3 TOTAL ENERGY'}; VARH['mp4(sdq)'] = {; 'hf': 'HF TOTAL ENERGY',; 'mp2': 'MP2 TOTAL ENERGY',; 'mp2.5': 'MP2.5 TOTAL ENERGY',; 'mp3': 'MP3 TOTAL ENERGY',; 'mp4(sdq)': 'MP4(SDQ) TOTAL ENERGY'}; VARH['mp4'] = {; 'hf': 'HF TOTAL ENERGY',; 'mp2': 'MP2 TOTAL ENERGY',; 'mp2.5': 'MP2.5 TOTAL ENERGY',; 'mp3': 'MP3 TOTAL ENERGY',; 'mp4(sdq)': 'MP4(SDQ) TOTAL ENERGY',; 'mp4': 'MP4 TOTAL ENERGY'}; VARH['omp2'] = {; 'hf': 'HF TOTAL ENERGY',; 'mp2': 'MP2 TOTAL ENERGY',; 'omp2': 'OMP2 TOTAL ENERGY'}; VARH['omp2.5'] = {; 'hf': 'HF TOTAL ENERGY',; 'mp2': 'MP2 TOTAL ENERGY',; 'mp2.5': 'MP2.5 TOTAL ENERGY',; 'omp2.5': 'OMP2.5 TOTAL ENERGY'}; VARH['omp3'] = {; 'hf': 'HF TOTAL ENERGY',; 'mp2': 'MP2 TOTAL ENERGY',; 'mp3': 'MP3 TOTAL ENERGY',; 'omp3': 'OMP3 TOTAL ENERGY'}; VARH['olccd'] = {; 'hf': 'HF TOTAL ENERGY',; 'mp2': 'MP2 TOTAL ENERGY',; 'olccd': 'OLCCD TOTAL ENERGY'}; VARH['oremp2'] = {; 'hf': 'HF TOTAL ENERGY',; 'mp2': 'MP2 TOTAL ENERGY',; 'oremp2': 'OREMP2 TOTAL ENERGY'}; VARH['lccd'] = {; 'hf': 'HF TOTAL ENERGY',; 'mp2': 'MP2 TOTAL ENERGY',; 'lccd': 'LCCD TOTAL ENERGY'}; VARH['remp2'] = {; 'hf': 'HF TOTAL ENERGY',; 'mp2': 'MP2 TOTAL ENERGY',; 'remp2': 'REMP2 TOTAL ENERGY'}; VARH['l",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver_cbs.html:11838,ENERGY,ENERGY,11838,psi4manual/1.7.x/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver_cbs.html,20,['ENERGY'],['ENERGY']
Energy Efficiency,"[5]_:; :math:`E_{corl}^X = E_{corl}^{\infty} + \beta X^{-alpha}`. References; ----------. .. [5] Halkier, Helgaker, Jorgensen, Klopper, Koch, Olsen, & Wilson,; Chem. Phys. Lett. 286 (1998) 243-252,; DOI: 10.1016/S0009-2614(99)00179-7. """"""; if type(valueLO) != type(valueHI):; raise ValidationError(; ""corl_xtpl_helgaker_2: Inputs must be of the same datatype! (%s, %s)"" % (type(valueLO), type(valueHI))). if alpha is None:; alpha = 3.0. if isinstance(valueLO, float):; value = (valueHI * zHI**alpha - valueLO * zLO**alpha) / (zHI**alpha - zLO**alpha); beta = (valueHI - valueLO) / (zHI**(-alpha) - zLO**(-alpha)). # final = valueSCF + value; final = value; if verbose:; # Output string with extrapolation parameters; cbsscheme = """"""\n\n ==> Helgaker 2-point correlated extrapolation for method: %s <==\n\n"""""" % (; functionname.upper()); # cbsscheme += """""" HI-zeta (%1s) SCF Energy: % 16.12f\n"""""" % (str(zHI), valueSCF); cbsscheme += """""" LO-zeta (%s) Energy: % 16.12f\n"""""" % (str(zLO), valueLO); cbsscheme += """""" HI-zeta (%s) Energy: % 16.12f\n"""""" % (str(zHI), valueHI); cbsscheme += """""" Alpha (exponent) Value: % 16.12f\n"""""" % alpha; cbsscheme += """""" Extrapolated Energy: % 16.12f\n\n"""""" % value; #cbsscheme += """""" LO-zeta (%s) Correlation Energy: % 16.12f\n"""""" % (str(zLO), valueLO); #cbsscheme += """""" HI-zeta (%s) Correlation Energy: % 16.12f\n"""""" % (str(zHI), valueHI); #cbsscheme += """""" Beta (coefficient) Value: % 16.12f\n"""""" % beta; #cbsscheme += """""" Extrapolated Correlation Energy: % 16.12f\n\n"""""" % value. name_str = ""%s/(%s,%s)"" % (functionname.upper(), _zeta_val2sym[zLO].upper(), _zeta_val2sym[zHI].upper()); cbsscheme += """""" @Extrapolated """"""; cbsscheme += name_str + ':'; cbsscheme += "" "" * (19 - len(name_str)); cbsscheme += """"""% 16.12f\n\n"""""" % final; core.print_out(cbsscheme). return final. elif isinstance(valueLO, (core.Matrix, core.Vector)):. beta = valueHI.clone(); beta.subtract(valueLO); beta.scale(1 / (zHI**(-alpha) - zLO**(-alpha))); beta.name = 'Helgaker Corl (%s, %s) beta",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html:21472,Energy,Energy,21472,psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html,2,['Energy'],['Energy']
Energy Efficiency,"[E_h] between the single-determinant energy of the final and; initial orbitals for the orbital-optimized MP3 level of theory. OREMP2 TOTAL ENERGY¶. OREMP2 CORRELATION ENERGY¶; The total electronic energy [E_h] and correlation energy component [E_h]; for the orbital-optimized retaining-the-excitation-degree Møller–Plesset; hybrid perturbation theory level. OREMP2 REFERENCE CORRECTION ENERGY¶; The difference [E_h] between the single-determinant energy of the final and; initial orbitals for the orbital-optimized retaining-the-excitation-degree; Møller–Plesset hybrid perturbation theory level. ONE-ELECTRON ENERGY¶; The one-electron energy contribution [E_h] to the total SCF energy.; Quantity \(E_{1e^-}\) in Eq. (4). PCM POLARIZATION ENERGY¶; The energy contribution [E_h] from the polarizable continuum model for solvation. DD SOLVATION ENERGY¶; The energy contribution [Eh] from continuum solvation models based on a; domain-decomposition ansatz. PE ENERGY¶; The energy contribution [E_h] from the polarizable embedding model for solvation. QCISD TOTAL ENERGY¶. QCISD CORRELATION ENERGY¶; The total electronic energy [E_h] and correlation energy component [E_h]; for the quadratic configuration interaction singles and doubles level; of theory. QCISD(T) TOTAL ENERGY¶. QCISD(T) CORRELATION ENERGY¶; The total electronic energy [E_h] and correlation energy component [E_h]; for the quadratic configuration interaction singles and doubles with; perturbative triples correction level of theory. QCISD(T) CORRECTION ENERGY¶; The quadratic configuration interaction singles and doubles perturbative; triples correction [E_h]. REMP2 TOTAL ENERGY¶. REMP2 CORRELATION ENERGY¶; The total electronic energy [E_h] and correlation energy component [E_h]; for the retaining-the-excitation-degree Møller–Plesset hybrid perturbation; theory level. SAPT DISP ENERGY¶. SAPT ELST ENERGY¶. SAPT EXCH ENERGY¶. SAPT IND ENERGY¶; Respectively, the dispersion, electrostatics, exchange, and induction; components of ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/glossary_psivariables.html:44345,energy,energy,44345,psi4manual/1.7.x/glossary_psivariables.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/glossary_psivariables.html,4,['energy'],['energy']
Energy Efficiency,"[Eh]. Not unique because oribital spaces vary. DMRG-CASPT2 TOTAL ENERGY¶; The total DMRG plus CASPT2 total electonic energy [Eh] . Not unique because orbital spaces vary. EFP DISP ENERGY¶. EFP ELST ENERGY¶. EFP EXCH ENERGY¶. EFP IND ENERGY¶; Respectively, the dispersion, electrostatics, exchange, and induction; components of the total electronic interaction energy [Eh] for EFP/EFP; computations. The sum of these four components yields; EFP TOTAL ENERGY. EFP TOTAL ENERGY¶; The total electronic interaction energy [Eh] for EFP/EFP computations. EFP TORQUE¶; The torque, not gradient for EFP/EFP computations. ENTHALPY¶; Total enthalpy H [Eh] at given temperature. ENTHALPY CORRECTION¶; Sum of electronic, translational, rotational, and vibrational corrections [Eh] to the enthalpy at given temperature. ESP AT CENTER n¶; Property of electrostatic potential [Eh / e] at location, usually atom center, n. FCI TOTAL ENERGY¶. FCI CORRELATION ENERGY¶; The total electronic energy [Eh] and correlation energy component [Eh]; for the full configuration interaction level of theory. GIBBS FREE ENERGY¶; Total Gibbs free energy [Eh], free enthalpy at given temperature. GIBBS FREE ENERGY CORRECTION¶; Sum of electronic, translational, rotational, and vibrational corrections [Eh] to the free enthalpy at given temperature. GRID ELECTRONS TOTAL¶. GRID ELECTRONS ALPHA¶. GRID ELECTRONS BETA¶; The number of electrons integrated by the xc quadrature grid. HF TOTAL ENERGY¶; The total electronic energy [Eh] for the Hartree–Fock method, without; any dispersion correction; the first three (or four, since; \(E_{xc} = 0\)) terms in Eq. (4). Quantity \(E_{\text{HF}}\); in Eq. (4). HF TOTAL GRADIENT¶; The total electronic gradient [E_h/a0] of the Hartree–Fock method, ({nat}, 3). HF DIPOLE GRADIENT¶; The derivative of the Hartree–Fock method dipole [E_h a0/u] = [(e a0/a0)^2/u] with respect to nuclear perturbations; as a degree-of-freedom by dipole component array, (3 * {nat}, 3). HF TOTAL HESSIAN¶; The total",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/glossary_psivariables-1.html:22717,energy,energy,22717,psi4manual/1.4.0/glossary_psivariables-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/glossary_psivariables-1.html,10,['energy'],['energy']
Energy Efficiency,"[Eh]. Notes; -----; :psivar:`DISPERSION CORRECTION ENERGY`; Disp always set. Overridden in SCF finalization, but that only changes for ""-3C"" methods.; :psivar:`fctl DISPERSION CORRECTION ENERGY`; Set if :py:attr:`fctldash` nonempty. """"""; if self.engine in [""s-dftd3"", 'dftd3', 'mp2d', ""dftd4""]:; resi = AtomicInput(; **{; 'driver': 'energy',; 'model': {; 'method': self.fctldash,; 'basis': '(auto)',; },; 'keywords': {; 'level_hint': self.dashlevel,; 'params_tweaks': self.dashparams,; 'dashcoeff_supplement': self.dashcoeff_supplement,; 'pair_resolved': self.save_pairwise_disp,; 'apply_qcengine_aliases': True, # for s-dftd3; 'verbose': 1,; },; 'molecule': molecule.to_schema(dtype=2),; 'provenance': p4util.provenance_stamp(__name__),; }); jobrec = qcng.compute(; resi,; self.engine,; raise_error=True,; task_config={""scratch_directory"": core.IOManager.shared_object().get_default_path(), ""ncores"": core.get_num_threads()}). dashd_part = float(jobrec.extras['qcvars']['DISPERSION CORRECTION ENERGY']); if wfn is not None:; for k, qca in jobrec.extras['qcvars'].items():; if (""CURRENT"" not in k) and (""PAIRWISE"" not in k):; wfn.set_variable(k, float(qca) if isinstance(qca, str) else qca). # Pass along the pairwise dispersion decomposition if we need it; if self.save_pairwise_disp is True:; wfn.set_variable(""PAIRWISE DISPERSION CORRECTION ANALYSIS"",; jobrec.extras['qcvars'][""2-BODY PAIRWISE DISPERSION CORRECTION ANALYSIS""]). if self.fctldash in ['hf3c', 'pbeh3c', 'r2scan3c', 'b973c']:; jobrec = qcng.compute(; resi,; self.gcp_engine,; raise_error=True,; task_config={""scratch_directory"": core.IOManager.shared_object().get_default_path(), ""ncores"": core.get_num_threads()}); gcp_part = jobrec.return_result; dashd_part += gcp_part. return dashd_part. else:; ene = self.disp.compute_energy(molecule); core.set_variable('DISPERSION CORRECTION ENERGY', ene); if self.fctldash:; core.set_variable(f""{self.fctldash} DISPERSION CORRECTION ENERGY"", ene); return ene. [docs]; def compute_gradient(self",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/procrouting/empirical_dispersion.html:10330,ENERGY,ENERGY,10330,psi4manual/1.9.x/_modules/psi4/driver/procrouting/empirical_dispersion.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/procrouting/empirical_dispersion.html,2,['ENERGY'],['ENERGY']
Energy Efficiency,"[Eh]. Notes; -----; :psivar:`DISPERSION CORRECTION ENERGY`; Disp always set. Overridden in SCF finalization, but that only changes for ""-3C"" methods.; :psivar:`fctl DISPERSION CORRECTION ENERGY`; Set if :py:attr:`fctldash` nonempty. """"""; if self.engine in [""s-dftd3"", 'dftd3', 'mp2d', ""dftd4""]:; resi = AtomicInput(; **{; 'driver': 'energy',; 'model': {; 'method': self.fctldash,; 'basis': '(auto)',; },; 'keywords': {; 'level_hint': self.dashlevel,; 'params_tweaks': self.dashparams,; 'dashcoeff_supplement': self.dashcoeff_supplement,; 'pair_resolved': self.save_pairwise_disp,; 'apply_qcengine_aliases': True, # for s-dftd3; 'verbose': 1,; },; 'molecule': molecule.to_schema(dtype=2),; 'provenance': p4util.provenance_stamp(__name__),; }); jobrec = qcng.compute(; resi,; self.engine,; raise_error=True,; task_config={""scratch_directory"": core.IOManager.shared_object().get_default_path(), ""ncores"": core.get_num_threads()}). dashd_part = float(jobrec.extras['qcvars']['DISPERSION CORRECTION ENERGY']); if wfn is not None:; for k, qca in jobrec.extras['qcvars'].items():; if (""CURRENT"" not in k) and (""PAIRWISE"" not in k):; wfn.set_variable(k, float(qca) if isinstance(qca, str) else qca). # Pass along the pairwise dispersion decomposition if we need it; if self.save_pairwise_disp is True:; wfn.set_variable(""PAIRWISE DISPERSION CORRECTION ANALYSIS"",; jobrec.extras['qcvars'][""2-BODY PAIRWISE DISPERSION CORRECTION ANALYSIS""]). if self.fctldash in ['hf3c', 'pbeh3c']:; jobrec = qcng.compute(; resi,; self.gcp_engine,; raise_error=True,; task_config={""scratch_directory"": core.IOManager.shared_object().get_default_path(), ""ncores"": core.get_num_threads()}); gcp_part = jobrec.return_result; dashd_part += gcp_part. return dashd_part. else:; ene = self.disp.compute_energy(molecule); core.set_variable('DISPERSION CORRECTION ENERGY', ene); if self.fctldash:; core.set_variable(f""{self.fctldash} DISPERSION CORRECTION ENERGY"", ene); return ene. [docs] def compute_gradient(self,; molecule: core.Mole",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/empirical_dispersion.html:9879,ENERGY,ENERGY,9879,psi4manual/1.7.x/_modules/psi4/driver/procrouting/empirical_dispersion.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/empirical_dispersion.html,1,['ENERGY'],['ENERGY']
Energy Efficiency,"[Eh]. Notes; -----; :psivar:`DISPERSION CORRECTION ENERGY`; Disp always set. Overridden in SCF finalization, but that only changes for ""-3C"" methods.; :psivar:`fctl DISPERSION CORRECTION ENERGY`; Set if :py:attr:`fctldash` nonempty. """"""; if self.engine in [""s-dftd3"", 'dftd3', 'mp2d', ""dftd4""]:; resi = AtomicInput(; **{; 'driver': 'energy',; 'model': {; 'method': self.fctldash,; 'basis': '(auto)',; },; 'keywords': {; 'level_hint': self.dashlevel,; 'params_tweaks': self.dashparams,; 'dashcoeff_supplement': self.dashcoeff_supplement,; 'pair_resolved': self.save_pairwise_disp,; 'apply_qcengine_aliases': True, # for s-dftd3; 'verbose': 1,; },; 'molecule': molecule.to_schema(dtype=2),; 'provenance': p4util.provenance_stamp(__name__),; }); jobrec = qcng.compute(; resi,; self.engine,; raise_error=True,; task_config={""scratch_directory"": core.IOManager.shared_object().get_default_path(), ""ncores"": core.get_num_threads()}). dashd_part = float(jobrec.extras['qcvars']['DISPERSION CORRECTION ENERGY']); if wfn is not None:; for k, qca in jobrec.extras['qcvars'].items():; if (""CURRENT"" not in k) and (""PAIRWISE"" not in k):; wfn.set_variable(k, float(qca) if isinstance(qca, str) else qca). # Pass along the pairwise dispersion decomposition if we need it; if self.save_pairwise_disp is True:; wfn.set_variable(""PAIRWISE DISPERSION CORRECTION ANALYSIS"",; jobrec.extras['qcvars'][""2-BODY PAIRWISE DISPERSION CORRECTION ANALYSIS""]). if self.fctldash in ['hf3c', 'pbeh3c']:; jobrec = qcng.compute(; resi,; self.gcp_engine,; raise_error=True,; task_config={""scratch_directory"": core.IOManager.shared_object().get_default_path(), ""ncores"": core.get_num_threads()}); gcp_part = jobrec.return_result; dashd_part += gcp_part. return dashd_part. else:; ene = self.disp.compute_energy(molecule); core.set_variable('DISPERSION CORRECTION ENERGY', ene); if self.fctldash:; core.set_variable(f""{self.fctldash} DISPERSION CORRECTION ENERGY"", ene); return ene. [docs]; def compute_gradient(self,; molecule: core.Mol",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/empirical_dispersion.html:10390,ENERGY,ENERGY,10390,psi4manual/1.8.x/_modules/psi4/driver/procrouting/empirical_dispersion.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/empirical_dispersion.html,1,['ENERGY'],['ENERGY']
Energy Efficiency,"[Tuple[int], Tuple[int]]. [docs]def nbody():; """"""; Computes the nbody interaction energy, gradient, or Hessian depending on input.; This is a generalized universal function for computing interaction and total quantities. :returns: *return type of func* |w--w| The data. :returns: (*float*, :py:class:`~psi4.core.Wavefunction`) |w--w| data and wavefunction with energy/gradient/hessian set appropriately when **return_wfn** specified. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :type return_wfn: :ref:`boolean <op_py_boolean>`; :param return_wfn: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return the :py:class:`~psi4.core.Wavefunction`; calculation result as the second element of a tuple. :type bsse_type: str or list; :param bsse_type: ``'cp'`` || ``['nocp', 'vmfc']`` || |dl| ``None`` |dr| || etc. Type of BSSE correction to compute: CP for counterpoise correction, NoCP; for plain supramolecular interaction energy, or VMFC for Valiron-Mayer; Function Counterpoise correction. If a list is provided, the first string in; the list determines which interaction or total energies/gradients/Hessians are; returned by this function. By default, many-body treatments are inactive. :type max_nbody: int; :param max_nbody: ``3`` || etc. Maximum n-body to compute, cannot exceed the number of fragments in the molecule. :type return_total_data: :ref:`boolean <op_py_boolean>`; :param return_total_data: ``'on'`` || |dl| ``'off'`` |dr|. If True returns the total data (energy/gradient/Hessian) of the system,; otherwise returns interaction data. Default is ``'off'`` for energies,; ``'on'`` for gradients and Hessians. Note that the calculation of total; counterpoise corrected energies implies the calculation of the energies of; monomers in the monomer basis, hence specifying ``return_total_data = True``; may carry out more computations than ``return_total_data = False``.; For gradients and ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver_nbody.html:8930,energy,energy,8930,psi4manual/1.6.x/_modules/psi4/driver/driver_nbody.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver_nbody.html,2,['energy'],['energy']
Energy Efficiency,"[at],; width=prewidth - 8,; presp=presp); for vib in row:; if vib is None:; break; text += (""""""{:^{width}.{prec}f}"""""" * 3).format(*(vibinfo[normco].data[:, vib].reshape(nat, 3)[at]),; width=int(width / 3),; prec=ncprec); text += """"""{:{colsp}}"""""".format('', colsp=colsp); text += '\n'; else:; for at in range(nat):; for xyz in range(3):; text += """"""{:{presp}}{:5d} {} {:{width}}"""""".format('',; at + 1,; 'XYZ' [xyz],; atom_lbl[at],; width=prewidth - 14,; presp=presp); for vib in row:; if vib is None:; break; text += """"""{:^{width}.{prec}f}"""""".format((vibinfo[normco].data[3 * at + xyz, vib]),; width=width,; prec=ncprec); text += """"""{:{colsp}}"""""".format('', colsp=colsp); text += '\n'. return text. [docs]def thermo(vibinfo, T: float, P: float, multiplicity: int, molecular_mass: float, E0: float, sigma: int, rot_const: np.ndarray, rotor_type: str = None) -> Tuple[Dict[str, Datum], str]:; """"""Perform thermochemical analysis from vibrational output. Parameters; ----------; E0; Electronic energy [Eh] at well bottom at 0 [K], :psivar:`CURRENT ENERGY`.; molecular_mass; Mass in [u] of molecule under analysis.; multiplicity; Spin multiplicity of molecule under analysis.; rot_const; (3,) rotational constants in [cm^-1] of molecule under analysis.; sigma; The rotational or external symmetry number determined from the point group.; rotor_type; The rotor type for rotational stat mech purposes: RT_ATOM, RT_LINEAR, other.; T; Temperature in [K]. Psi default 298.15. Note that 273.15 is IUPAC STP.; P; Pressure in [Pa]. Psi default 101325. Note that 100000 is IUPAC STP. Returns; -------; dict, str; First is every thermochemistry component in atomic units along with input conditions.; Second is formatted presentation of analysis. """"""; sm = collections.defaultdict(float). # conditions; therminfo = {}; therminfo['E0'] = Datum('E0', 'Eh', E0); therminfo['B'] = Datum('rotational constants', 'cm^-1', rot_const); therminfo['sigma'] = Datum('external symmetry number', '', sigma); therminfo['T'] = Datu",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/qcdb/vib.html:30898,energy,energy,30898,psi4manual/1.4.0/_modules/psi4/driver/qcdb/vib.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/qcdb/vib.html,12,"['ENERGY', 'energy']","['ENERGY', 'energy']"
Energy Efficiency,"[beta4] » ; Psithon Functions: Invoking a Calculation ». Notes on Options¶. Note; The Python options referred to in the Psithon Functions: Invoking a Calculation section below; are placed as arguments to a Python; function (like energy()), not in set blocks or commands. Note; All PSI4 keyword names and values are insensitive to case, both; those that are placed in set blocks and as Python function arguments.; The one exception is documented for the subset option in the database(); function, where case structure must match the database file. Note; Boolean options can be specified by yes, on, true, or 1; for affirmative and no, off, false, or 0 for negative,; all insensitive to case. Note; The derivative level type for optimize() and frequency() functions can be specified by energy, none, or 0 for 0th derivative, gradient, first, or 1 for 1st derivative, and hessian, second, or 2 for 2nd derivative. For finite difference, as opposed to analytic, derivatives, the POINTS option can be increased to 5 for greater accuracy at increased cost. Note; Function option for the Psithon function called by the current function;; the default is usually energy(). See Sec. Function Intercalls; for a fuller description. Note that the value of the keyword is a Python object; and so is not wrapped in quotes like a string. Note; The molecule to be acted upon by the current function; the default is the; nearest preceeding molecule declared in a molecule name {...} block. Note; that the value of this keyword (name in the example) is a Python object and; so is not wrapped in quotes like a string. Previous topic; Psithon Functions: Invoking a Calculation; Next topic; Energy; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » ; Psithon Functions: Invoking a Calculation ». © Copyright 2013, The Psi4 Project.; Last updated on Apr 05, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/notes_py-1.html:1274,energy,energy,1274,psi4manual/4.0b4/notes_py-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/notes_py-1.html,2,['energy'],['energy']
Energy Efficiency,"[beta5] » ; Psithon Functions: Invoking a Calculation ». Notes on Options¶. Note; The Python options referred to in the Psithon Functions: Invoking a Calculation section below; are placed as arguments to a Python; function (like energy()), not in set blocks or commands. Note; All PSI4 keyword names and values are insensitive to case, both; those that are placed in set blocks and as Python function arguments.; The one exception is documented for the subset option in the database(); function, where case structure must match the database file. Note; Boolean options can be specified by yes, on, true, or 1; for affirmative and no, off, false, or 0 for negative,; all insensitive to case. Note; The derivative level type for optimize() and frequency() functions can be specified by energy, none, or 0 for 0th derivative, gradient, first, or 1 for 1st derivative, and hessian, second, or 2 for 2nd derivative. For finite difference, as opposed to analytic, derivatives, the POINTS option can be increased to 5 for greater accuracy at increased cost. Note; Function option for the Psithon function called by the current function;; the default is usually energy(). See Sec. Function Intercalls; for a fuller description. Note that the value of the keyword is a Python object; and so is not wrapped in quotes like a string. Note; The molecule to be acted upon by the current function; the default is the; nearest preceeding molecule declared in a molecule name {...} block. Note; that the value of this keyword (name in the example) is a Python object and; so is not wrapped in quotes like a string. Previous topic; Psithon Functions: Invoking a Calculation; Next topic; Energy; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta5] » ; Psithon Functions: Invoking a Calculation ». © Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/notes_py-1.html:1274,energy,energy,1274,psi4manual/4.0b5/notes_py-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/notes_py-1.html,2,['energy'],['energy']
Energy Efficiency,"[d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). """"""; kwargs = p4util.kwargs_lower(kwargs). # Bounce to MDI if mdi kwarg; use_mdi = kwargs.pop('mdi', False); if use_mdi:; return mdi_run(name, **kwargs). core.print_out(""\nScratch directory: %s\n"" % core.IOManager.shared_object().get_default_path()). # Bounce to CP if bsse kwarg; if kwargs.get('bsse_type', None) is not None:; return driver_nbody.nbody_gufunc(energy, name, ptype='energy', **kwargs). # Bounce if name is function; if hasattr(name, '__call__'):; return name(energy, kwargs.pop('label', 'custom function'), ptype='energy', **kwargs). # Allow specification of methods to arbitrary order; lowername = name.lower(); lowername, level = driver_util.parse_arbitrary_order(lowername); if level:; kwargs['level'] = level. # Bounce to CBS if ""method/basis"" name; if ""/"" in lowername:; return driver_cbs._cbs_gufunc(energy, name, ptype='energy', **kwargs). _filter_renamed_methods(""energy"", lowername). # Commit to procedures['energy'] call hereafter; return_wfn = kwargs.pop('return_wfn', False); core.clean_variables(). # Make sure the molecule the user provided is the active one; molecule = kwargs.pop('molecule', core.get_active_molecule()); molecule.update_geometry(). #for precallback in hooks['energy']['pre']:; # precallback(lowername, **kwargs). optstash = driver_util._set_convergence_criterion('energy', lowername, 6, 8, 6, 8, 6); optstash2 = p4util.OptionsState(['SCF', 'GUESS']). # Before invoking the procedure, we rename any file that should be read.; # This is a workaround to do restarts with the current PSI4 capabilities; # before actual, clean restarts are put in there; # Restartfile is always converted to a single-element list if; # it contains a single string; # DGAS Note: This is hacked together at this point and should be revamped.; if 'restart_file' in kwargs:; restartfile = kwargs['restart_file'] # Option still available for procedure-specific action; if not isinstance(restartfile, (list, tuple)):; rest",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:34802,energy,energy,34802,psi4manual/1.4.0/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html,4,['energy'],['energy']
Energy Efficiency,"[db_rxn]:; core.print_out(' reagent {} contributes by {:.4f} to reaction {}\n'.format(rgt, RXNM[db_rxn][rgt], db_rxn)); core.print_out('\n'); for envv in db_tabulate:; VRGT[rgt][envv.upper()] = core.variable(envv); core.set_global_option(""REFERENCE"", user_reference); core.clean(); #core.opt_clean(); core.clean_variables(). # Reap all the necessary reaction computations; core.print_out(""\n""); p4util.banner((""Database %s Results"" % (db_name))); core.print_out(""\n""). maxactv = []; for rxn in HRXN:; maxactv.append(len(ACTV[dbse + '-' + str(rxn)])); maxrgt = max(maxactv); table_delimit = '-' * (62 + 20 * maxrgt); tables = ''. # find any reactions that are incomplete; FAIL = collections.defaultdict(int); for rxn in HRXN:; db_rxn = dbse + '-' + str(rxn); for i in range(len(ACTV[db_rxn])):; if abs(ERGT[ACTV[db_rxn][i]]) < 1.0e-12:; if not allowoptexceeded:; FAIL[rxn] = 1. # tabulate requested process::environment variables; tables += """""" For each VARIABLE requested by tabulate, a 'Reaction Value' will be formed from\n""""""; tables += """""" 'Reagent' values according to weightings 'Wt', as for the REQUESTED ENERGY below.\n""""""; tables += """""" Depending on the nature of the variable, this may or may not make any physical sense.\n""""""; for rxn in HRXN:; db_rxn = dbse + '-' + str(rxn); VRXN[db_rxn] = {}. for envv in db_tabulate:; envv = envv.upper(); tables += """"""\n ==> %s <==\n\n"""""" % (envv.title()); tables += _tblhead(maxrgt, table_delimit, 2). for rxn in HRXN:; db_rxn = dbse + '-' + str(rxn). if FAIL[rxn]:; tables += """"""\n%23s %8s %8s %8s %8s"""""" % (db_rxn, '', '****', '', ''); for i in range(len(ACTV[db_rxn])):; tables += """""" %16.8f %2.0f"""""" % (VRGT[ACTV[db_rxn][i]][envv], RXNM[db_rxn][ACTV[db_rxn][i]]). else:; VRXN[db_rxn][envv] = 0.0; for i in range(len(ACTV[db_rxn])):; VRXN[db_rxn][envv] += VRGT[ACTV[db_rxn][i]][envv] * RXNM[db_rxn][ACTV[db_rxn][i]]. tables += """"""\n%23s %16.8f """""" % (db_rxn, VRXN[db_rxn][envv]); for i in range(len(ACTV[db_rxn])):; tables += """""" %16.8f %2.0f"""""" % ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html:18191,ENERGY,ENERGY,18191,psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html,7,['ENERGY'],['ENERGY']
Energy Efficiency,"[docs]; def compute(self, client: Optional[""qcportal.FractalClient""] = None):; """"""Run each job in task list.""""""; instructions = ""\n"" + p4util.banner(f"" FiniteDifference Computations"", strNotOutfile=True) + ""\n""; logger.debug(instructions); core.print_out(instructions). with p4util.hold_options_state():; for t in self.task_list.values():; t.compute(client=client). def _prepare_results(self, client: Optional[""qcportal.FractalClient""] = None):; results_list = {k: v.get_results(client=client) for k, v in self.task_list.items()}. # load AtomicComputer results into findifrec[reference]; reference = self.findifrec[""reference""]; task = results_list[""reference""]; response = task.return_result; reference[""module""] = getattr(task.provenance, ""module"", None). if task.driver == 'energy':; reference['energy'] = response. elif task.driver == 'gradient':; reference['gradient'] = response; reference['energy'] = task.extras['qcvars']['CURRENT ENERGY']. elif task.driver == 'hessian':; reference['hessian'] = response; reference['energy'] = task.extras['qcvars']['CURRENT ENERGY']; if 'CURRENT GRADIENT' in task.extras['qcvars']:; reference['gradient'] = task.extras['qcvars']['CURRENT GRADIENT']. dipole_available = False; if 'CURRENT DIPOLE' in task.extras['qcvars']:; reference['dipole'] = task.extras['qcvars']['CURRENT DIPOLE']; dipole_available = True. # load AtomicComputer results into findifrec[displacements]; for label, displacement in self.findifrec[""displacements""].items():; task = results_list[label]; response = task.return_result. if task.driver == 'energy':; displacement['energy'] = response. elif task.driver == 'gradient':; displacement['gradient'] = response; displacement['energy'] = task.extras['qcvars']['CURRENT ENERGY']. elif task.driver == 'hessian':; displacement['hessian'] = response; displacement['energy'] = task.extras['qcvars']['CURRENT ENERGY']; if 'CURRENT GRADIENT' in task.extras['qcvars']:; displacement['gradient'] = task.extras['qcvars']['CURRENT GRADIENT']. if '",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html:47346,energy,energy,47346,psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html,6,['energy'],['energy']
Energy Efficiency,"[docs]def build_m05_2x_superfunctional(name, npoints, deriv):. # Call this first; sup = psi4.SuperFunctional.blank(); sup.set_max_points(npoints); sup.set_deriv(deriv). # => User-Customization <= #. # No spaces, keep it short and according to convention; sup.set_name('M05-2X'); # Tab in, trailing newlines; sup.set_description(' Heavily Parameterized Hybrid Meta-GGA XC Functional\n'); # Tab in, trailing newlines; sup.set_citation(' Zhao et. al., J. Chem. Theory Comput., 2, 364, 2006\n'). # Add member functionals; X = build_functional('M_X'); X.set_name('M05_2X_X'); X.set_alpha(1.0). # LSDA Exchange type is Slater, no parameters. # GGA Exchange type is PBE, special parameters because Truhlar is lazy; C1 = 3.36116E-3; C2 = 4.49267E-3; K0 = 3.0 / 2.0 * math.pow(3.0 / (math.pi * 4.0), 1.0 / 3.0); k0 = math.pow(6.0 * math.pi * math.pi, 1.0 / 3.0); kp = C1 / (C2 * K0); mu = 4.0 * k0 * k0 * kp * C2; X.set_parameter('PBE_kp', kp); X.set_parameter('PBE_mu', mu). # Meta Exchange type is insane mess of w power series expansion; X.set_parameter('Meta_a0', 1.0); X.set_parameter('Meta_a1', -0.56833); X.set_parameter('Meta_a2', -1.30057); X.set_parameter('Meta_a3', 5.50070); X.set_parameter('Meta_a4', 9.06402); X.set_parameter('Meta_a5', -32.21075); X.set_parameter('Meta_a6', -23.73298); X.set_parameter('Meta_a7', 70.22996); X.set_parameter('Meta_a8', 29.88614); X.set_parameter('Meta_a9', -60.25778); X.set_parameter('Meta_a10', -13.22205); X.set_parameter('Meta_a11', 15.23694). C = build_functional('M_C'); C.set_name('M05_2X_C'). # LSDA Correlation type is PW92, no parameters. # GGA Correlation type is B97; C.set_parameter('B97_os_gamma', 0.0031 * 2.0); C.set_parameter('B97_os_a0', 1.00000); C.set_parameter('B97_os_a1', 1.09297); C.set_parameter('B97_os_a2', -3.79171); C.set_parameter('B97_os_a3', 2.82810); C.set_parameter('B97_os_a4', -10.58909). C.set_parameter('B97_ss_gamma', 0.06); C.set_parameter('B97_ss_a0', 1.00000); C.set_parameter('B97_ss_a1', -3.05430); C.set_parameter('B",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/functional.html:65060,power,power,65060,psi4manual/4.0b5/_modules/functional.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/functional.html,3,['power'],['power']
Energy Efficiency,"[dt]z', delta_scheme=corl_xtpl_helgaker_2, delta2_wfn='ccsd(t)', delta2_wfn_lesser='ccsd', delta2_basis='aug-cc-pvdz'). 1; 2>>> # [7] cbs() coupled with database(); >>> TODO database('mp2', 'BASIC', subset=['h2o','nh3'], symm='on', func=cbs, corl_basis='cc-pV[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd(t)', delta_basis='sto-3g'). 1; 2>>> # [8] cbs() coupled with optimize(); >>> TODO optimize('mp2', corl_basis='cc-pV[DT]Z', corl_scheme=corl_xtpl_helgaker_2, func=cbs). Note; Presently (May 2016), only two of the five delta possibilities are active. Also, temporarily extrapolations are performed on differences of target and scf total energies, rather than on correlation energies directly. This doesn’t affect the extrapolated values of the particular formulas defined here (though it does affect the betas, which are commented out), but it is sloppy and temporary and could affect any user-defined corl extrapolations. Output¶; At the beginning of a cbs() job is printed a listing of the individual; energy calculations which will be performed. The output snippet below is; from the example job [2] above. It shows first each model chemistry needed; to compute the aggregate model chemistry requested through cbs(). Then,; since, for example, an energy('ccsd(t)') yields CCSD(T), CCSD, MP2,; and SCF energy values, the wrapper condenses this task list into the second; list of minimum number of calculations which will actually be run.; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13Naive listing of computations required.; scf / aug-cc-pvqz for SCF TOTAL ENERGY; mp2 / aug-cc-pvtz for MP2 CORRELATION ENERGY; mp2 / aug-cc-pvqz for MP2 CORRELATION ENERGY; ccsd(t) / aug-cc-pvdz for CCSD(T) CORRELATION ENERGY; ccsd(t) / aug-cc-pvtz for CCSD(T) CORRELATION ENERGY; mp2 / aug-cc-pvdz for MP2 CORRELATION ENERGY; mp2 / aug-cc-pvtz for MP2 CORRELATION ENERGY. Enlightened listing of computations required.; mp2 / aug-cc-pvqz for MP2 CORRELATION ENERGY; ccsd(t) / aug-cc-pvdz for CCSD(T) COR",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/cbs-1.html:12909,energy,energy,12909,psi4manual/1.2.1/cbs-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/cbs-1.html,4,['energy'],['energy']
Energy Efficiency,"[manual]. sapt2+3(ccd)dmp2; SAPT2+3 with CC-based dispersion and MP2 correction [manual]. sapt0-ct; 0th-order SAPT plus charge transfer (CT) calculation [manual]. sapt2-ct; SAPT2 plus CT [manual]. sapt2+-ct; SAPT2+ plus CT [manual]. sapt2+(3)-ct; SAPT2+(3) plus CT [manual]. sapt2+3-ct; SAPT2+3 plus CT [manual]. sapt2+(ccd)-ct; SAPT2+(CCD) plus CT [manual]. sapt2+(3)(ccd)-ct; SAPT2+(3)(CCD) plus CT [manual]. sapt2+3(ccd)-ct; SAPT2+3(CCD) plus CT [manual]. adc; 2nd-order algebraic diagrammatic construction (ADC) [manual]. eom-cc2; EOM-CC2 [manual]. eom-ccsd; equation of motion (EOM) CCSD [manual]. eom-cc3; EOM-CC3 [manual]. Examples:. >>> # [1] Coupled-cluster singles and doubles calculation with psi code; >>> energy('ccsd'). >>> # [2] Charge-transfer SAPT calculation with scf projection from small into; >>> # requested basis, with specified projection fitting basis; >>> set basis_guess true; >>> set df_basis_guess jun-cc-pVDZ-JKFIT; >>> energy('sapt0-ct'). >>> # [3] Arbitrary-order MPn calculation; >>> energy('mp7'). >>> # [4] Converge scf as singlet, then run detci as triplet upon singlet reference; >>> # Note that the integral transformation is not done automatically when detci is run in a separate step.; >>> molecule H2 {\n0 1\nH\nH 1 0.74\n}; >>> set basis cc-pVDZ; >>> set reference rohf; >>> scf_e, scf_wfn = energy('scf', return_wfn=True); >>> H2.set_multiplicity(3); >>> core.MintsHelper(scf_wfn.basisset()).integrals(); >>> energy('detci', ref_wfn=scf_wfn). >>> # [5] Run two CI calculations, keeping the integrals generated in the first one.; >>> molecule ne {\nNe\n}; >>> set basis cc-pVDZ; >>> cisd_e, cisd_wfn = energy('cisd', return_wfn=True); >>> energy('fci', ref_wfn=cisd_wfn). >>> # [6] Can automatically perform complete basis set extrapolations; >>> energy(""CCSD/cc-pV[DT]Z""). >>> # [7] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for mo",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/energy-1.html:7604,energy,energy,7604,psi4manual/1.3.2/energy-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/energy-1.html,2,['energy'],['energy']
Energy Efficiency,"[mode, NEED, wfnname, BSET, ZSET] = validate_scheme_args(functionname, **largs). if (mode == 'requisition'):. # Impose restrictions on zeta sequence; if (len(ZSET) == 0):; raise ValidationError('Call to \'%s\' not valid with \'%s\' basis sets.' % (functionname, len(ZSET))). # Return array that logs the requisite jobs; if (wfnname == 'scf'):; portion = 'tot'; else:; portion = 'corl'; NEED = {'HI': dict(zip(f_fields, [wfnname, portion, BSET[len(ZSET) - 1], ZSET[len(ZSET) - 1], 0.0]))}. return NEED. elif (mode == 'evaluate'):. # Extract required energies and zeta integers from array; # Compute extrapolated energy; energypiece = NEED['HI']['f_energy']. # Output string with extrapolation parameters; cbsscheme = ''; cbsscheme += """"""\n ==> %s <==\n\n"""""" % (functionname); if (NEED['HI']['f_wfn'] == 'scf'):; cbsscheme += """""" HI-zeta (%s) Total Energy: %16.8f\n"""""" % (str(NEED['HI']['f_zeta']), energypiece); else:; cbsscheme += """""" HI-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(NEED['HI']['f_zeta']), energypiece); psi4.print_out(cbsscheme). return energypiece. # Solution equation in LaTeX: $E_{corl}^{\infty} = \frac{E_{corl}^{X} X^3 - E_{corl}^{X-1} (X-1)^3}{X^3 - (X-1)^3}$; # Solution equation in LaTeX: $\beta = \frac{E_{corl}^{X} - E_{corl}^{X-1}}{X^{-3} - (X-1)^{-3}}$; [docs]def corl_xtpl_helgaker_2(**largs):; r""""""Extrapolation scheme for correlation energies with two adjacent zeta-level bases.; Used by :py:func:`~wrappers.complete_basis_set`. .. math:: E_{corl}^X = E_{corl}^{\infty} + \beta X^{-3}. """"""; energypiece = 0.0; functionname = sys._getframe().f_code.co_name; f_fields = ['f_wfn', 'f_portion', 'f_basis', 'f_zeta', 'f_energy']; [mode, NEED, wfnname, BSET, ZSET] = validate_scheme_args(functionname, **largs). if (mode == 'requisition'):. # Impose restrictions on zeta sequence; if (len(ZSET) != 2):; raise ValidationError('Call to \'%s\' not valid with \'%s\' basis sets.' % (functionname, len(ZSET))). # Return array that logs the requisite jobs; NEED = {'HI': dict(z",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:94355,energy,energypiece,94355,psi4manual/4.0b5/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html,2,['energy'],['energypiece']
Energy Efficiency,"[n]; continue. for k in range(1, n + 1):; take_nk = nCr(metadata['max_frag'] - k - 1, n - k); sign = ((-1)**(n - k)); value = nocp_energy_by_level[k]; nocp_energy_body_dict[n] += take_nk * sign * value. if metadata['ptype'] != 'energy':; value = nocp_ptype_by_level[k]; nocp_ptype_body_dict[n] += take_nk * sign * value. _print_nbody_energy(nocp_energy_body_dict, ""Non-Counterpoise Corrected (NoCP)"", metadata['embedding_charges']); nocp_interaction_energy = nocp_energy_body_dict[metadata['max_nbody']] - nocp_energy_body_dict[1]; nbody_dict['Non-Counterpoise Corrected Total Energy'] = nocp_energy_body_dict[metadata['max_nbody']]; nbody_dict['Non-Counterpoise Corrected Interaction Energy'] = nocp_interaction_energy. for n in nbody_range[1:]:; var_key = 'NOCP-CORRECTED %d-BODY INTERACTION ENERGY' % n; nbody_dict[var_key] = nocp_energy_body_dict[n] - nocp_energy_body_dict[1]. # Compute vmfc ptype; if 'vmfc' in metadata['bsse_type_list']:; if metadata['ptype'] != 'energy':; for n in nbody_range:; if n > 1:; vmfc_ptype_body_dict[n] = vmfc_ptype_by_level[n - 1]; vmfc_ptype_body_dict[n] += vmfc_ptype_by_level[n]. _print_nbody_energy(vmfc_energy_body_dict, ""Valiron-Mayer Function Couterpoise (VMFC)"",; metadata['embedding_charges']); vmfc_interaction_energy = vmfc_energy_body_dict[metadata['max_nbody']] - vmfc_energy_body_dict[1]; nbody_dict['Valiron-Mayer Function Couterpoise Total Energy'] = vmfc_energy_body_dict[metadata['max_nbody']]; nbody_dict['Valiron-Mayer Function Couterpoise Interaction Energy'] = vmfc_interaction_energy. for n in nbody_range[1:]:; var_key = 'VMFC-CORRECTED %d-BODY INTERACTION ENERGY' % n; nbody_dict[var_key] = vmfc_energy_body_dict[n] - vmfc_energy_body_dict[1]. # Returns; results = {}; results['nbody'] = nbody_dict; for b in ['cp', 'nocp', 'vmfc']:; if monomer_energies != 0.0:; results['%s_energy_body_dict' % b] = eval('%s_energy_body_dict' % b); results['%s_energy_body_dict' % b] = {str(i) + b: j for i, j in results['%s_energy_body_dict' % b].items(",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_nbody.html:28084,energy,energy,28084,psi4manual/1.4.0/_modules/psi4/driver/driver_nbody.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_nbody.html,4,['energy'],['energy']
Energy Efficiency,"[source]¶; Function to returns a LIST of all subclusters of the molecule mol of; real size cluster_size. If cluster_size = 0, returns all possible; combinations of cluster size. extract_clusters(mol, ghost=True, cluster_size=0)[source]¶; Function to return all subclusters of the molecule mol of; real size cluster_size and all other atoms ghosted if ghost; equals true, all other atoms discarded if ghost is false. If; cluster_size = 0, returns all possible combinations of cluster size. geometry(geom, name='default')[source]¶; Function to create a molecule object of name name; from the geometry in string geom. new_get_attr(self, name)[source]¶; Function to redefine __getattr__ method of molecule class. new_set_attr(self, name, value)[source]¶; Function to redefine __setattr__ method of molecule class. p4regex¶. proc¶. run_adc(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; an algebraic diagrammatic construction calculation. Caution; Get rid of active molecule lines- should be handled in energy. run_bccd(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; a Brueckner CCD calculation. run_bccd_t(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; a Brueckner CCD(T) calculation. run_cc_gradient(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; a CCSD and CCSD(T) gradient calculation. run_cc_property(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; all CC property calculations. run_ccenergy(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; a CCSD, CC2, and CC3 calculation. run_cepa(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; a cepa-like calculation.; >>> energy('cepa(1)'). run_cepa0(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; a CEPA (LCCD) computation. run_cepa0_gradient(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/autodoc_driver-1.html:5685,energy,energy,5685,psi4manual/4.0b5/autodoc_driver-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodoc_driver-1.html,2,['energy'],['energy']
Energy Efficiency,"[str, Union[AtomicComputer, CompositeComputer, FiniteDifferenceComputer]]]) – A set of tasks to process instead of self.task_list. Used in multilevel processing to pass a subset of; self.task_list filtered to only one modelchem level.; client (Optional[FractalClient]) – QCFractal client if using QCArchive for distributed compute. Returns; When the ManyBodyComputer specifies a single model chemistry level (see self.nbodies_per_mc_level), the; return is a dictionary, nbody_results, described in the table below. Many of the items are actually filled; by successive calls to assemble_nbody_components(). When multiple model chemistry levels are specified, this; function diverts its return to driver_nbody_multilevel.prepare_results() wherein each mc level calls this; function again and collects separate nbody_results dictionaries and processes them into a final return that; is a small subset of the table below. Return type; nbody_results. ptype_size = (1,)/(nat, 3)/(3 * nat, 3 * nat)e/g/h := energy or gradient or Hessian; rtd := return_total_data. item; size; present / zeroed; contents / interpretation. ret_ptype; ptype_size; always. interaction data requested: IE or total (depending on return_total_data) e/g/h (depending on driver)with cp/nocp/vmfc treatment (depending on 1st of bsse_type). ret_energy; 1; always; interaction energy: IE or total (depending on return_total_data) w/ cp/nocp/vmfc treat. (dep. on 1st of bsse_type). ret_gradient; (nat, 3); when driver is g/h; interaction gradient: IE or total (depending on return_total_data) w/ cp/nocp/vmfc treat. (dep. on 1st of bsse_type. ret_hessian; (nat * 3, nat * 3); when driver is h; interaction Hessian: IE or total (depending on return_total_data) w/ cp/nocp/vmfc treat. (dep. on 1st of bsse_type). nbody; >=1; always; energy n-body QCVariables to be set.   CP-CORRECTED TOTAL ENERGY THROUGH 1-BODY;   1; when cp in bsse_type; MBE sum of subsystems of 1-body. summed are total energies with cp treatment.   CP-CORRECTED TOTAL ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/nbody.html:9719,energy,energy,9719,psi4manual/1.6.x/nbody.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/nbody.html,1,['energy'],['energy']
Energy Efficiency,"\' not valid with \'%s\' basis sets.' % (functionname, len(ZSET))). # Return array that logs the requisite jobs; NEED = {'HI': dict(zip(f_fields, [wfnname, 'corl', BSET[1], ZSET[1], 0.0])),; 'LO': dict(zip(f_fields, [wfnname, 'corl', BSET[0], ZSET[0], 0.0]))}. return NEED. elif (mode == 'evaluate'):. # Extract required energies and zeta integers from array; eHI = NEED['HI']['f_energy']; zHI = NEED['HI']['f_zeta']; eLO = NEED['LO']['f_energy']; zLO = NEED['LO']['f_zeta']. # Compute extrapolated energy; energypiece = (eHI * zHI ** 3 - eLO * zLO ** 3) / (zHI ** 3 - zLO ** 3); beta = (eHI - eLO) / (zHI ** (-3) - zLO ** (-3)). # Output string with extrapolation parameters; cbsscheme = ''; cbsscheme += """"""\n ==> %s <==\n\n"""""" % (functionname); cbsscheme += """""" LO-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(zLO), eLO); cbsscheme += """""" HI-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(zHI), eHI); cbsscheme += """""" Extrapolated Correlation Energy: %16.8f\n"""""" % (energypiece); cbsscheme += """""" Beta (coefficient) Value: %16.8f\n"""""" % (beta); PsiMod.print_out(cbsscheme). return energypiece. [docs]def scf_xtpl_helgaker_3(**largs):; r""""""Extrapolation scheme for reference energies with three adjacent zeta-level bases.; Used by :py:func:`~wrappers.complete_basis_set`. .. math:: E_{total}^X = E_{total}^{\infty} + \beta e^{-\alpha X}. """"""; energypiece = 0.0; functionname = sys._getframe().f_code.co_name; f_fields = ['f_wfn', 'f_portion', 'f_basis', 'f_zeta', 'f_energy']; [mode, NEED, wfnname, BSET, ZSET] = validate_scheme_args(functionname, **largs). if (mode == 'requisition'):. # Impose restrictions on zeta sequence; if (len(ZSET) != 3):; raise ValidationError('Call to \'%s\' not valid with \'%s\' basis sets.' % (functionname, len(ZSET))). # Return array that logs the requisite jobs; NEED = {'HI': dict(zip(f_fields, [wfnname, 'tot', BSET[2], ZSET[2], 0.0])),; 'MD': dict(zip(f_fields, [wfnname, 'tot', BSET[1], ZSET[1], 0.0])),; 'LO': dict(zip(f_fields, [wfnname, 'tot', BSET[0]",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:80407,energy,energypiece,80407,psi4manual/4.0b2/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html,6,['energy'],['energypiece']
Energy Efficiency,"\' not valid with \'%s\' basis sets.' % (functionname, len(ZSET))). # Return array that logs the requisite jobs; NEED = {'HI': dict(zip(f_fields, [wfnname, 'corl', BSET[1], ZSET[1], 0.0])),; 'LO': dict(zip(f_fields, [wfnname, 'corl', BSET[0], ZSET[0], 0.0]))}. return NEED. elif (mode == 'evaluate'):. # Extract required energies and zeta integers from array; eHI = NEED['HI']['f_energy']; zHI = NEED['HI']['f_zeta']; eLO = NEED['LO']['f_energy']; zLO = NEED['LO']['f_zeta']. # Compute extrapolated energy; energypiece = (eHI * zHI ** 3 - eLO * zLO ** 3) / (zHI ** 3 - zLO ** 3); beta = (eHI - eLO) / (zHI ** (-3) - zLO ** (-3)). # Output string with extrapolation parameters; cbsscheme = ''; cbsscheme += """"""\n ==> %s <==\n\n"""""" % (functionname); cbsscheme += """""" LO-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(zLO), eLO); cbsscheme += """""" HI-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(zHI), eHI); cbsscheme += """""" Extrapolated Correlation Energy: %16.8f\n"""""" % (energypiece); cbsscheme += """""" Beta (coefficient) Value: %16.8f\n"""""" % (beta); psi4.print_out(cbsscheme). return energypiece. [docs]def scf_xtpl_helgaker_3(**largs):; r""""""Extrapolation scheme for reference energies with three adjacent zeta-level bases.; Used by :py:func:`~wrappers.complete_basis_set`. .. math:: E_{total}^X = E_{total}^{\infty} + \beta e^{-\alpha X}. """"""; energypiece = 0.0; functionname = sys._getframe().f_code.co_name; f_fields = ['f_wfn', 'f_portion', 'f_basis', 'f_zeta', 'f_energy']; [mode, NEED, wfnname, BSET, ZSET] = validate_scheme_args(functionname, **largs). if (mode == 'requisition'):. # Impose restrictions on zeta sequence; if (len(ZSET) != 3):; raise ValidationError('Call to \'%s\' not valid with \'%s\' basis sets.' % (functionname, len(ZSET))). # Return array that logs the requisite jobs; NEED = {'HI': dict(zip(f_fields, [wfnname, 'tot', BSET[2], ZSET[2], 0.0])),; 'MD': dict(zip(f_fields, [wfnname, 'tot', BSET[1], ZSET[1], 0.0])),; 'LO': dict(zip(f_fields, [wfnname, 'tot', BSET[0], ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:96188,energy,energypiece,96188,psi4manual/4.0b5/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html,2,['energy'],['energypiece']
Energy Efficiency,"\(T_2\):. (2)¶\[\begin{split}\langle \Psi_0 | (H - E) (1 + T_1 + T_2)|\Psi_0\rangle = 0, \\; \langle \Psi_i^a | (H - E) (1 + T_1 + T_2 + T_1T_2)|\Psi_0\rangle = 0, \\; \langle \Psi_{ij}^{ab} | (H - E) (1 + T_1 + T_2 + \frac{1}{2}T_2^2)|\Psi_0\rangle = 0. \\\end{split}\]; QCISD is slightly cheaper that CCSD computationally, but it retains the; \({\cal{O}}(o^2v^4)\) complexity of the original equations. Just as in; the familiar CCSD(T) method, the effects of connected triple excitations; may be included noniteratively to yield the QCISD(T) method. Both the; QCISD(T) and CCSD(T) methods are implemented for closed-shell references; in the FNOCC module. Many-body perturbation theory¶; QCI and CC methods are closely related to perturbation theory, and the; MP2, MP3, and MP4(SDQ) correlation energies can be obtained as a free; by-product of a CCSD or QCISD computation. The following is an; example of the results for a computation run with the call; energy('fno-qcisd') to energy():; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19; 20; 21; 22; 23; 24; 25; 26; 27; 28; 29; 30QCISD iterations converged!. OS MP2 FNO correction: -0.000819116338; SS MP2 FNO correction: -0.000092278158; MP2 FNO correction: -0.000911394496. OS MP2 correlation energy: -0.166478414245; SS MP2 correlation energy: -0.056669079827; MP2 correlation energy: -0.223147494072; * MP2 total energy: -76.258836941658. OS MP2.5 correlation energy: -0.171225850256; SS MP2.5 correlation energy: -0.054028401038; MP2.5 correlation energy: -0.225254251294; * MP2.5 total energy: -76.260943698880. OS MP3 correlation energy: -0.175973286267; SS MP3 correlation energy: -0.051387722248; MP3 correlation energy: -0.227361008515; * MP3 total energy: -76.263050456101. OS MP4(SDQ) correlation energy: -0.180324322304; SS MP4(SDQ) correlation energy: -0.048798468084; MP4(SDQ) correlation energy: -0.230995119324; * MP4(SDQ) total energy: -76.266684566910. OS QCISD correlation energy: -0.181578117924; SS QCISD corre",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/fnocc-1.html:5179,energy,energy,5179,psi4manual/1.1.0/fnocc-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/fnocc-1.html,12,['energy'],['energy']
Energy Efficiency,"\(^1A_1\) CH2 state described using the Ms = 0 component of the singlet. Uses RHF singlet orbitals. cc54; CCSD dipole with user-specified basis set. opt1-fd; SCF STO-3G geometry optimzation, with Z-matrix input, by finite-differences. sapt-dft-api; SAPT(DFT) aug-cc-pVDZ interaction energy between Ne and Ar atoms. cbs-xtpl-wrapper; RHF aug-cc-pVQZ energy for the BH molecule, with Cartesian input. Various gradients for a strained helium dimer and water molecule. scf-coverage; Lithium test for coverage. sad1; Test of the superposition of atomic densities (SAD) guess, using a highly distorted water geometry with a cc-pVDZ basis set. This is just a test of the code and the user need only specify guess=sad to the SCF module’s (or global) options in order to use a SAD guess. The test is first performed in C2v symmetry, and then in C1. cc1; RHF-CCSD 6-31G** all-electron optimization of the H2O molecule. dft-grac; Gradient regularized asymptotic correction (GRAC) test. cdomp2-1; OMP2 cc-pVDZ energy for the H2O molecule. tdscf-1; td-uhf test on triplet states of methylene (rpa). dfccd1; DF-CCD cc-pVDZ energy for the H2O molecule. soscf-large; Second-order SCF convergnece: Benzene. opt-irc-2; Compute the IRC for HCN <-> NCH interconversion at the RHF/DZP level of theory. x2c3; Test of SFX2C-1e on Water uncontracted cc-pVDZ The reference numbers are from Lan Cheng’s implementation in Cfour. sapt7; SAPT0 open-shell computation of H2O-HO2 interaction energy First with cc-pVDZ and density fitted integrals with UHF Then with 6-31g and direct integrals, except for dispersion that is computed with cc-pVDZ-ri density fitting with UHF. x2c1; Test of SFX2C-1e on water uncontracted cc-pVDZ-DK The reference numbers are from Lan Cheng’s implementation in Cfour. mp2-grad2; MP2 cc-pVDZ gradient for the NO radical. scf7; Tests SCF gradient in the presence of a dipole field. dft-dldf; Dispersionless density functional (dlDF+D) internal match to Psi4 Extensive testing has been done to match sup",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/autodoc_testsuite_corepsi4-1.html:11679,energy,energy,11679,psi4manual/1.4.0/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodoc_testsuite_corepsi4-1.html,4,['energy'],['energy']
Energy Efficiency,"\(^2\Sigma^+\) state of the CN radical, with Cartesian input. dft-b3lyp; Check flavors of B3LYP (b3lyp3/b3lyp5) against other programs. opt-multi-frozen-dimer-c2h; Frozen-fragment opt of C2h methane dimer with user-combined reference points. dfmp2-fc; Kr–Kr nocp energies with all-electron basis set to check frozen core. opt8; Various constrained energy minimizations of HOOH with cc-pvdz RHF. Cartesian-coordinate constrained optimizations of HOOH in Cartesians. dfmp2-grad1; DF-MP2 cc-pVDZ gradients for the H2O molecule. scf3; File retention, docc, socc, and bond distances specified explicitly. options1; check all variety of options parsing. nbody-vmfc-gradient; Computation of VMFC-corrected water trimer gradient (geometry from J. Chem. Theory Comput. 11, 2126-2136 (2015)). mom; Maximum Overlap Method (MOM) Test. MOM is designed to stabilize SCF convergence and to target excited Slater determinants directly. scf-bz2; Benzene Dimer Out-of-Core HF/cc-pVDZ. scf1; RHF cc-pVQZ energy for the BH molecule, with Cartesian input. dft-dens-cut; LibXC density screening test. Tests empty, C-only, X-only and XC superfunctionals. ‘super_mix’ showcases how to use different screening values for X and C parts. SCF will fail or crash (nans) without screening!. freq-isotope1; Vibrational and thermo analysis of several water isotopologs. Demonstrates Hessian reuse for different temperatures and pressures but not for different isotopologs. pywrap-cbs1; Various basis set extrapolation tests. mp3-grad2; MP3 cc-pVDZ gradient for the NO radical. mp2-grad1; MP2 cc-pVDZ gradient for the H2O molecule. dft-grad-lr3; wB97X-D test for a large UKS molecule update ref gradient due to new BraggSlater radii. dfomp2p5-grad1; DF-OMP2.5 cc-pVDZ gradients for the H2O molecule. lccd-grad1; LCCD cc-pVDZ gradient for the H2O molecule. freq-masses; check nonphysical masses possible. dfep2-1; Compute three IP and 2 EA’s for the PH3 molecule. scf-cholesky-basis; incremental Cholesky filtered SCF. rasci-h2o; RASC",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/autodoc_testsuite_corepsi4-1.html:1876,energy,energy,1876,psi4manual/1.4.0/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodoc_testsuite_corepsi4-1.html,4,['energy'],['energy']
Energy Efficiency,"\(e-\) in RAS IV? Useful to reduce the number of strings required if MIXED4=true, as in a split-virutal CISD[TQ] computation. If more than one electron is in RAS IV, then the holes in RAS I cannot exceed the number of particles in RAS III + RAS IV (i.e., EX_LEVEL , or else the string is discarded. Type: boolean; Default: false. SF_RESTRICT¶. Do eliminate determinants not valid for spin-complete spin-flip CI’s? [see J. S. Sears et al, J. Chem. Phys. 118, 9084-9094 (2003)]. Type: boolean; Default: false. SIGMA_OVERLAP¶. Do print the sigma overlap matrix? Not generally useful. Type: boolean; Default: false. WFN¶. Wavefunction type. This should be set automatically from the calling Psithon function. Type: string; Possible Values: DETCI, CI, ZAPTN, DETCAS, CASSCF, RASSCF; Default: DETCI. Expert Diagonalization Methods¶. H0_BLOCKSIZE¶. This parameter specifies the size of the H0 block of the Hamiltonian which is solved exactly. The n determinants with the lowest SCF energy are selected, and a submatrix of the Hamiltonian is formed using these determinants. This submatrix is used to accelerate convergence of the CI iterations in the OLSEN and MITRUSHENKOV iteration schemes, and also to find a good starting guess for the SEM method if GUESS_VECTOR is H0_BLOCK. Defaults to 1000. Note that the program may change the given size for Ms=0 cases MS0 is TRUE) if it determines that the H0 block includes only one member of a pair of determinants related by time reversal symmetry. For very small block sizes, this could conceivably eliminate the entire H0 block; the program should print warnings if this occurs. Type: integer; Default: 1000. H0_BLOCK_COUPLING¶. Do use coupling block in preconditioner?. Type: boolean; Default: false. H0_BLOCK_COUPLING_SIZE¶. Parameters which specifies the size of the coupling block within the generalized davidson preconditioner. Type: integer; Default: 0. H0_GUESS_SIZE¶. size of H0 block for initial guess. Type: integer; Default: 1000. HD_AVG¶. How to av",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/autodir_options_c/module__detci-1.html:13722,energy,energy,13722,psi4manual/1.3.2/autodir_options_c/module__detci-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/autodir_options_c/module__detci-1.html,24,['energy'],['energy']
Energy Efficiency,"\). \begin{align*}; E_{\text{SCF}} & = E_{NN} + E_{1e^-} + E_{2e^-} + E_{xc} + E_{\text{-D}} \\; & = E_{\text{FCTL/HF}} + E_{\text{-D}}; \end{align*}Unless the method includes a dispersion correction, this quantity is; equal to HF TOTAL ENERGY (for HF) or; DFT FUNCTIONAL TOTAL ENERGY (for; DFT). Unless the method is a DFT double-hybrid, this quantity is equal; to DFT TOTAL ENERGY. SCF TOTAL GRADIENT¶; The total electronic gradient [E_h/a0] of the SCF stage of the calculation, ({nat}, 3). SCF DIPOLE GRADIENT¶; The derivative of the SCF stage dipole [E_h a0/u] = [(e a0/a0)^2/u] with respect to nuclear perturbations; as a degree-of-freedom by dipole component array, (3 * {nat}, 3). SCF TOTAL HESSIAN¶; The total electronic second derivative [E_h/a0/a0] for the SCF stage, (3 * {nat}, 3 * {nat}). SCF STABILITY EIGENVALUES¶; Array of eigenvalues from UHF or ROHF stability analysis. SCS-CCSD TOTAL ENERGY¶. SCS-CCSD CORRELATION ENERGY¶; The total electronic energy [E_h] and correlation energy component [E_h]; for the CCSD-like method formed by reweighting CCSD DOUBLES ENERGY; by 1.27 opposite-spin and 1.13 same-spin contributions, with; any singles carried along. SCS-MP2 TOTAL ENERGY¶. SCS-MP2 CORRELATION ENERGY¶; The total electronic energy [E_h] and correlation energy component [E_h]; for the MP2-like method formed by reweighting MP2 DOUBLES ENERGY; by 6/5 opposite-spin and 1/3 same-spin contributions, with; any singles carried along. SCS-MP2-VDW TOTAL ENERGY¶. SCS-MP2-VDW CORRELATION ENERGY¶; The total electronic energy [E_h] and correlation energy component [E_h]; for the MP2-like method formed by reweighting MP2 DOUBLES ENERGY; by 1.28 opposite-spin and 0.50 same-spin contributions, with; any singles carried along. DOI: 10.1080/00268970802641242. SCS(N)-MP2 TOTAL ENERGY¶. SCS(N)-MP2 CORRELATION ENERGY¶; The total electronic energy [E_h] and correlation energy component [E_h]; for the MP2-like method formed by reweighting MP2 DOUBLES ENERGY; by 0 opposite-spin and 1.76 s",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/glossary_psivariables.html:54328,energy,energy,54328,psi4manual/1.7.x/glossary_psivariables.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/glossary_psivariables.html,8,['energy'],['energy']
Energy Efficiency,"\)]; [\(s_6\)]. Footnotes. [1]Note that there are functionals with these extensions (e.g., wB97X-D) that,; not being Grimme corrections, won’t follow this table exactly. [2][Grimme:2004:1463]. [3][Grimme:2006:1787]. [4][Grimme:2010:154104]. [5][Grimme:2011:1456]. [6](1, 2) [Smith:2016:2197]. [7][Hujo:2011:3866]. [8][Chai:2010:6615]. [9][Pernal:2009:263201]. [10][Podeszwa:2010:550]. [11]Keyword not used for user-defined functionals where the dft_dict[""dispersion""][""params""]; is easily editable for this purpose. See Advanced Functional Use and Manipulation. A few practical examples:. DFT-D2 single point with default parameters (dftd3 not called); 1energy('bp86-d'). DFT-D3BJ optimization with default parameters; 1optimize('pbe-d3bj'). DFT-D2 optimization with custom s6 parameter; 1; 2set dft_dispersion_parameters [1.20]; optimize('b3lyp-d2'). DFT-D3ZERO single point (b3lyp) with custom s8 parameter (reset all four values); 1; 2set dft_dispersion_parameters [1.0, 2.0, 1.261, 14.0]; energy('b3lyp-d3'). DFT-D2 single point with dftd3 instead of PSI4’s libdisp; 1energy('pbe-d2', engine='dftd3'). If only dispersion corrections (rather than total energies) are of; interest, the dftd3 program can be run independently of the scf; through the python function run_dftd3(). (This function; is the same PSI4/dftd3 interface that is called during an scf job.); This route is much faster than running a DFT-D energy. Some set-up:; 1; 2; 3; 4; 5; 6molecule nene {; Ne; Ne 1 2.0; }. nene.update_geometry(). The same four dispersion corrections/gradients as the section above:; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14>>> print nene.run_dftd3('bp86', 'd', dertype=0); -7.735e-05. >>> E, G = nene.run_dftd3('pbe', 'd3bj'); >>> print G; [[0.0, 0.0, -1.1809087569358e-05], [0.0, 0.0, 1.1809087569358e-05]]. >>> E, G = nene.run_dftd3('b3lyp', 'd2', {'s6': 1.20}); >>> print E; -8.84e-05. >>> E, G = nene.run_dftd3(dashlvl='d3', dashparam={'s8': 2.0, 'alpha6': 14.0, 'sr6': 1.261, 's6': 1.0}); >>> pri",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/dftd3-1.html:7671,energy,energy,7671,psi4manual/1.3.2/dftd3-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/dftd3-1.html,2,['energy'],['energy']
Energy Efficiency,"\; Decimal(2) / Decimal(3); psivar['CCSD-F12A OPPOSITE-SPIN CORRELATION ENERGY'] = Decimal(mobj.group(2)) - \; psivar['CCSD-F12A SAME-SPIN CORRELATION ENERGY']; psivar['CCSD-F12A TOTAL ENERGY'] = Decimal(mobj.group(2)) + psivar['HF-CABS TOTAL ENERGY']; psivar['(T)-F12AB CORRECTION ENERGY'] = mobj.group(3); psivar['CCSD(T)-F12A CORRELATION ENERGY'] = Decimal(mobj.group(2)) + Decimal(mobj.group(3)); psivar['CCSD(T)-F12A TOTAL ENERGY'] = psivar['CCSD(T)-F12A CORRELATION ENERGY'] + psivar['HF-CABS TOTAL ENERGY']; psivar['(T*)-F12AB CORRECTION ENERGY'] = Decimal(mobj.group(3)) * \; psivar['MP2-F12 CORRELATION ENERGY'] / psivar['MP2 CORRELATION ENERGY']; psivar['CCSD(T*)-F12A CORRELATION ENERGY'] = Decimal(mobj.group(2)) + psivar['(T*)-F12AB CORRECTION ENERGY']; psivar['CCSD(T*)-F12A TOTAL ENERGY'] = psivar['CCSD(T*)-F12A CORRELATION ENERGY'] + psivar['HF-CABS TOTAL ENERGY']. mobj = re.search(; r'^\s*' + r'CCSD-F12b triplet pair energy\s+' + NUMBER + '\s*' +; r'^\s*' + r'CCSD-F12b correlation energy\s+' + NUMBER + '\s*' +; r'^\s*' + r'Triples \(T\) contribution\s+' + NUMBER + '\s*$',; outtext, re.MULTILINE); if mobj:; #print('matched ccsd(t)-f12b'); psivar['CCSD-F12B CORRELATION ENERGY'] = mobj.group(2); psivar['CCSD-F12B SAME-SPIN CORRELATION ENERGY'] = Decimal(mobj.group(1)) * \; Decimal(2) / Decimal(3); psivar['CCSD-F12B OPPOSITE-SPIN CORRELATION ENERGY'] = Decimal(mobj.group(2)) - \; psivar['CCSD-F12B SAME-SPIN CORRELATION ENERGY']; psivar['CCSD-F12B TOTAL ENERGY'] = Decimal(mobj.group(2)) + psivar['HF-CABS TOTAL ENERGY']; psivar['(T)-F12AB CORRECTION ENERGY'] = mobj.group(3); psivar['CCSD(T)-F12B CORRELATION ENERGY'] = Decimal(mobj.group(2)) + Decimal(mobj.group(3)); psivar['CCSD(T)-F12B TOTAL ENERGY'] = psivar['CCSD(T)-F12B CORRELATION ENERGY'] + psivar['HF-CABS TOTAL ENERGY']; psivar['(T*)-F12AB CORRECTION ENERGY'] = Decimal(mobj.group(3)) * \; psivar['MP2-F12 CORRELATION ENERGY'] / psivar['MP2 CORRELATION ENERGY']; psivar['CCSD(T*)-F12B CORRELATION ENERGY'] = Decim",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/molpro2.html:9010,energy,energy,9010,psi4manual/1.0.0/_modules/qcdb/molpro2.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/molpro2.html,2,['energy'],['energy']
Energy Efficiency,"\; Decimal(2) / Decimal(3); psivar['CCSD-F12B OPPOSITE-SPIN CORRELATION ENERGY'] = Decimal(mobj.group(2)) - \; psivar['CCSD-F12B SAME-SPIN CORRELATION ENERGY']; psivar['CCSD-F12B TOTAL ENERGY'] = Decimal(mobj.group(2)) + psivar['HF-CABS TOTAL ENERGY']; psivar['(T)-F12AB CORRECTION ENERGY'] = mobj.group(3); psivar['CCSD(T)-F12B CORRELATION ENERGY'] = Decimal(mobj.group(2)) + Decimal(mobj.group(3)); psivar['CCSD(T)-F12B TOTAL ENERGY'] = psivar['CCSD(T)-F12B CORRELATION ENERGY'] + psivar['HF-CABS TOTAL ENERGY']; psivar['(T*)-F12AB CORRECTION ENERGY'] = Decimal(mobj.group(3)) * \; psivar['MP2-F12 CORRELATION ENERGY'] / psivar['MP2 CORRELATION ENERGY']; psivar['CCSD(T*)-F12B CORRELATION ENERGY'] = Decimal(mobj.group(2)) + psivar['(T*)-F12AB CORRECTION ENERGY']; psivar['CCSD(T*)-F12B TOTAL ENERGY'] = psivar['CCSD(T*)-F12B CORRELATION ENERGY'] + psivar['HF-CABS TOTAL ENERGY']. mobj = re.search(; r'^\s*' + r'CCSD-F12c triplet pair energy\s+' + NUMBER + '\s*' +; r'^\s*' + r'CCSD-F12c correlation energy\s+' + NUMBER + '\s*' +; r'^\s*' + r'Triples \(T\) contribution\s+' + NUMBER + '\s*$',; outtext, re.MULTILINE); if mobj:; #print('matched ccsd(t)-f12c'); psivar['CCSD-F12C CORRELATION ENERGY'] = mobj.group(2); psivar['CCSD-F12C SAME-SPIN CORRELATION ENERGY'] = Decimal(mobj.group(1)) * \; Decimal(2) / Decimal(3); psivar['CCSD-F12C OPPOSITE-SPIN CORRELATION ENERGY'] = Decimal(mobj.group(2)) - \; psivar['CCSD-F12C SAME-SPIN CORRELATION ENERGY']; psivar['CCSD-F12C TOTAL ENERGY'] = Decimal(mobj.group(2)) + psivar['HF-CABS TOTAL ENERGY']; psivar['(T)-F12C CORRECTION ENERGY'] = mobj.group(3); psivar['CCSD(T)-F12C CORRELATION ENERGY'] = Decimal(mobj.group(2)) + Decimal(mobj.group(3)); psivar['CCSD(T)-F12C TOTAL ENERGY'] = psivar['CCSD(T)-F12C CORRELATION ENERGY'] + psivar['HF-CABS TOTAL ENERGY']; psivar['(T*)-F12C CORRECTION ENERGY'] = Decimal(mobj.group(3)) * \; psivar['MP2-F12 CORRELATION ENERGY'] / psivar['MP2 CORRELATION ENERGY']; psivar['CCSD(T*)-F12C CORRELATION ENERGY'] = Decimal",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/molpro2.html:10304,energy,energy,10304,psi4manual/1.0.0/_modules/qcdb/molpro2.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/molpro2.html,2,['energy'],['energy']
Energy Efficiency,"\]. db_name DATABASE MEAN SIGNED DEVIATION¶; The mean deviation [kcal mol-1] of the requested method name; from the stored reference values for the requested reactions in; database db_name. If no reference is available, this will be a large; and nonsensical value. \[\frac{1}{n}\sum_{rxn}^{n}{\textsf{\textsl{name}}_{rxn}-\text{REF}_{rxn}}\]. db_name DATABASE ROOT-MEAN-SQUARE DEVIATION¶; The rms deviation [kcal mol-1] of the requested method name; from the stored reference values for the requested reactions in; database db_name. If no reference is available, this will be a large; and nonsensical value. \[\sqrt{\frac{1}{n}\sum_{rxn}^{n}{(\textsf{\textsl{name}}_{rxn}-\text{REF}_{rxn})^2}}\]. DCT LAMBDA ENERGY¶; An energy term in density cumulant theory [E_h]. This term is the; 2-electron cumulant’s contribution contribution to the reduced; density matrix energy expression. Not recommended for interpretative; use except by reduced density matrix specialists. DCT SCF ENERGY¶; An energy term in density cumulant theory [E_h]. This term is the; 1-electron reduced density matrix (1RDM) contribution to the reduced; density matrix energy expression, plus the contribution of the; antisymmetrized product of 1RDMs. Not recommended for interpretative; use except by reduced density matrix specialists. DCT THREE-PARTICLE ENERGY¶; The three-particle correlation energy correction [E_h] in density cumulant; theory, akin to (T) CORRECTION ENERGY in coupled-cluster. DCT TOTAL ENERGY¶; Total energy [E_h] in density cumulant theory. Sum of DCT SCF ENERGY,; DCT LAMBDA ENERGY, and DCT THREE-PARTICLE ENERGY when present. DETCI AVG DVEC NORM¶; A measure of configuration interaction convergence. DFT FUNCTIONAL TOTAL ENERGY¶; The total electronic energy [E_h] for the underlying functional of the; requested DFT method, without any dispersion correction; the first four; terms in Eq. (4) or (1). Quantity; \(E_{\text{FCTL}}\) in Eqs. (4) and (1).; Unless the method includes a dispersion correction, t",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/glossary_psivariables.html:27296,energy,energy,27296,psi4manual/1.7.x/glossary_psivariables.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/glossary_psivariables.html,4,['energy'],['energy']
Energy Efficiency,"\]; The idempotent part of \(\boldsymbol{\gamma_1}\) corresponds to a mean-field Hartree–Fock-like density,; while the non-idempotent correction \(\boldsymbol{\tau}\); depends on the density cumulant and describes the electron correlation effects.; Inserting the above two equations into the energy expression, we obtain:. \[E_{DCT} = \frac{1}{2} \left( h_p^q + f_p^q \right) \gamma_q^p + \frac{1}{4} \bar{g}_{pq}^{rs} \lambda_{rs}^{pq}\]; where the antisymmetrized two-electron integrals and the generalized Fock operator; matrix elements were defined as follows:. \[\bar{g}_{pq}^{rs} = g_{pq}^{rs} - g_{pq}^{sr}\]. \[f_p^q = h_p^q + \bar{g}_{pr}^{qs} \gamma_{s}^{r}\]; Energy functional \(E_{DCT}\) has several important properties. First,; the energy is now a function of two sets of independent parameters, the; idempotent part of \(\boldsymbol{\gamma_1}\) (\(\boldsymbol{\kappa}\)) and the density cumulant; (\(\boldsymbol{\lambda_2}\)). As a result, the energy functional is Hermitian,; which is important for the evaluation of the molecular properties. The additive; separability of the density cumulant guarantees that all of the DCT methods; are size-extensive and size-consistent. Furthermore, the N-representability; problem is now greatly simplified, because the idempotent part of \(\boldsymbol{\gamma_1}\) is; N-representable by construction. One only needs to worry about the; N-representability of the density cumulant, which is a relatively small part of; \(\boldsymbol{\gamma_2}\).; In order to obtain the DCT energy, two conditions must be satisfied:. The energy must be stationary with respect to a set of orbitals. This can be done by; diagonalizing the generalized Fock operator (as in the DC-06 and DC-12 methods, see below),; which introduces partial orbital relaxation, or by fully relaxing the orbitals and minimizing the entire energy expression; (as in the ODC-06 and ODC-12 methods).; The energy must be stationary with respect to the variation of the density; cumulant \(",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/dct-1.html:3087,energy,energy,3087,psi4manual/1.4.0/dct-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/dct-1.html,9,['energy'],['energy']
Energy Efficiency,"\frac{1}{n}\sum_{rxn}^{n}{| \textsf{\textsl{name}}_{rxn}-\text{REF}_{rxn} | }\]. db_name DATABASE MEAN SIGNED DEVIATION¶; The mean deviation [kcal mol-1] of the requested method name; from the stored reference values for the requested reactions in; database db_name. If no reference is available, this will be a large; and nonsensical value. \[\frac{1}{n}\sum_{rxn}^{n}{\textsf{\textsl{name}}_{rxn}-\text{REF}_{rxn}}\]. db_name DATABASE ROOT-MEAN-SQUARE DEVIATION¶; The rms deviation [kcal mol-1] of the requested method name; from the stored reference values for the requested reactions in; database db_name. If no reference is available, this will be a large; and nonsensical value. \[\sqrt{\frac{1}{n}\sum_{rxn}^{n}{(\textsf{\textsl{name}}_{rxn}-\text{REF}_{rxn})^2}}\]. DCT LAMBDA ENERGY¶; An energy term in density cumulant theory [Eh]. This term is the; 2-electron cumulant’s contribution contribution to the reduced; density matrix energy expression. Not recommended for interpretative; use except by reduced density matrix specialists. DCT SCF ENERGY¶; An energy term in density cumulant theory [Eh]. This term is the; 1-electron reduced density matrix (1RDM) contribution to the reduced; density matrix energy expression, plus the contribution of the; antisymmetrized product of 1RDMs. Not recommended for interpretative; use except by reduced density matrix specialists. DCT THREE-PARTICLE ENERGY¶; The three-particle correlation energy correction [Eh] in density cumulant; theory, akin to (T) CORRECTION ENERGY in coupled-cluster. DCT TOTAL ENERGY¶; Total energy [Eh] in density cumulant theory. Sum of DCT SCF ENERGY,; DCT LAMBDA ENERGY, and DCT THREE-PARTICLE ENERGY when present. DETCI AVG DVEC NORM¶; A measure of configuration interaction convergence. DFT FUNCTIONAL TOTAL ENERGY¶; The total electronic energy [Eh] for the underlying functional of the; requested DFT method, without any dispersion correction; the first four; terms in Eq. (4) or (1). Quantity; \(E_{\text{FCTL}}\) in ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/glossary_psivariables-1.html:18327,reduce,reduced,18327,psi4manual/1.4.0/glossary_psivariables-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/glossary_psivariables-1.html,5,['reduce'],['reduced']
Energy Efficiency,"\n""""""; """""" 'mp2_type' must be set to 'DF'.\n""""""). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, use_c1=True, **kwargs) # C1 certified; elif ref_wfn.molecule().schoenflies_symbol() != 'c1':; raise ValidationError("""""" DLPNO-MP2 does not make use of molecular symmetry: """"""; """"""reference wavefunction must be C1.\n""""""). if core.get_global_option('REFERENCE') != ""RHF"":; raise ValidationError(""DLPNO-MP2 is not available for %s references."",; core.get_global_option('REFERENCE')). core.tstart(); core.print_out('\n'); p4util.banner('DLPNO-MP2'); core.print_out('\n'). aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_MP2"",; core.get_option(""DLPNO"", ""DF_BASIS_MP2""),; ""RIFIT"", core.get_global_option('BASIS')); ref_wfn.set_basisset(""DF_BASIS_MP2"", aux_basis). dlpnomp2_wfn = core.dlpno(ref_wfn); dlpnomp2_wfn.compute_energy(). if name == 'scs-dlpno-mp2':; dlpnomp2_wfn.set_variable('CURRENT ENERGY', dlpnomp2_wfn.variable('SCS-MP2 TOTAL ENERGY')); dlpnomp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dlpnomp2_wfn.variable('SCS-MP2 CORRELATION ENERGY')). elif name == 'dlpno-mp2':; dlpnomp2_wfn.set_variable('CURRENT ENERGY', dlpnomp2_wfn.variable('MP2 TOTAL ENERGY')); dlpnomp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dlpnomp2_wfn.variable('MP2 CORRELATION ENERGY')). # Shove variables into global space; for k, v in dlpnomp2_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); core.tstop(); return dlpnomp2_wfn. def run_dmrgscf(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; an DMRG calculation. """"""; optstash = p4util.OptionsState(; ['SCF_TYPE'],; ['DMRG', 'DMRG_CASPT2_CALC']). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs). # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(core.get_global_opt",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/_modules/psi4/driver/procrouting/proc.html:131930,ENERGY,ENERGY,131930,psi4manual/1.5.0/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/_modules/psi4/driver/procrouting/proc.html,6,['ENERGY'],['ENERGY']
Energy Efficiency,"\n""); self.Da = self.wfn.Da(); self.basis = self.wfn.basisset(); parser = core.Gaussian94BasisSetParser(); self.ribasis = core.BasisSet.construct(parser, self.molecule, ""DF_BASIS_SCF""). fitter = core.DFChargeFitter(); fitter.setPrimary(self.basis); fitter.setAuxiliary(self.ribasis); fitter.setD(self.Da); self.da = fitter.fit(); self.da.scale(2.0). def populateExtern(self, extern):; # Electronic Part; extern.addBasis(self.ribasis, self.da); # Nuclear Part; for A in range(0, self.molecule.natom()):; extern.addCharge(self.molecule.Z(A), self.molecule.x(A), self.molecule.y(A), self.molecule.z(A)). [docs]class QMMM(object):. def __init__(self):; self.charges = []; self.diffuses = []; self.extern = core.ExternalPotential(). [docs] def addDiffuse(self, diffuse):; """"""Function to add a diffuse charge field *diffuse*.""""""; self.diffuses.append(diffuse). [docs] def addChargeBohr(self, Q, x, y, z):; """"""Function to add a point charge of magnitude *Q* at; position (*x*, *y*, *z*) Bohr. """"""; self.charges.append([Q, x, y, z]). [docs] def addChargeAngstrom(self, Q, x, y, z):; """"""Function to add a point charge of magnitude *Q* at; position (*x*, *y*, *z*) Angstroms. """"""; self.charges.append([Q, x / constants.bohr2angstroms, y / constants.bohr2angstroms, z / constants.bohr2angstroms]). def __str__(self):. s = ' ==> QMMM <==\n\n'. s = s + ' => Charges (a.u.) <=\n\n'; s = s + ' %11s %11s %11s %11s\n' % ('Z', 'x', 'y', 'z'); for k in range(0, len(self.charges)):; s = s + ' %11.7f %11.3E %11.3E %11.3E\n' % (self.charges[k][0], self.charges[k][1], self.charges[k][2], self.charges[k][3]); s = s + '\n'. s = s + ' => Diffuses <=\n\n'. for k in range(0, len(self.diffuses)):; s = s + str(self.diffuses[k]). return s. [docs] def populateExtern(self):; """"""Function to define a charge field external to the; molecule through point and diffuse charges. """"""; # Charges; for charge in self.charges:; self.extern.addCharge(charge[0], charge[1], charge[2], charge[3]); # Diffuses; for diffuse in self.diffuses",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/qmmm.html:3838,charge,charges,3838,psi4manual/1.3.2/_modules/psi4/driver/qmmm.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/qmmm.html,7,['charge'],['charges']
Energy Efficiency,"\n' % e_delta_g2); psi4.print_out(' E(2DF): %20.12lf\n' % e_2df); psi4.print_out(' E(+): %20.12lf\n' % e_plus); psi4.print_out(' E(G1 HLC): %20.12lf\n' % hlc1); psi4.print_out(' E(G2 HLC): %20.12lf\n' % hlc); psi4.print_out(' E(ZPE): %20.12lf\n' % zpe); psi4.print_out('\n'); psi4.print_out(' ==> 0 Kelvin Results <==\n'); psi4.print_out('\n'); eg2_0k = eg2 + zpe + hlc; psi4.print_out(' G1: %20.12lf\n' % (eqci + e_plus + e_2df + hlc1 + zpe)); psi4.print_out(' G2(MP2): %20.12lf\n' % eg2_mp2_0k); psi4.print_out(' G2: %20.12lf\n' % eg2_0k). psi4.set_variable(""G1 TOTAL ENERGY"",eqci + e_plus + e_2df + hlc1 + zpe); psi4.set_variable(""G2 TOTAL ENERGY"",eg2_0k); psi4.set_variable(""G2(MP2) TOTAL ENERGY"",eg2_mp2_0k). psi4.print_out('\n'); T = psi4.get_global_option('T'); psi4.print_out(' ==> %3.0lf Kelvin Results <==\n'% T); psi4.print_out('\n'). internal_energy = eg2_mp2_0k + du - zpe / 0.8929; enthalpy = eg2_mp2_0k + dh - zpe / 0.8929; gibbs = eg2_mp2_0k + dg - zpe / 0.8929. psi4.print_out(' G2(MP2) energy: %20.12lf\n' % internal_energy ); psi4.print_out(' G2(MP2) enthalpy: %20.12lf\n' % enthalpy); psi4.print_out(' G2(MP2) free energy: %20.12lf\n' % gibbs); psi4.print_out('\n'). psi4.set_variable(""G2(MP2) INTERNAL ENERGY"",internal_energy); psi4.set_variable(""G2(MP2) ENTHALPY"",enthalpy); psi4.set_variable(""G2(MP2) FREE ENERGY"",gibbs). internal_energy = eg2_0k + du - zpe / 0.8929; enthalpy = eg2_0k + dh - zpe / 0.8929; gibbs = eg2_0k + dg - zpe / 0.8929. psi4.print_out(' G2 energy: %20.12lf\n' % internal_energy ); psi4.print_out(' G2 enthalpy: %20.12lf\n' % enthalpy); psi4.print_out(' G2 free energy: %20.12lf\n' % gibbs). psi4.set_variable(""CURRENT ENERGY"",eg2_0k). psi4.set_variable(""G2 INTERNAL ENERGY"",internal_energy); psi4.set_variable(""G2 ENTHALPY"",enthalpy); psi4.set_variable(""G2 FREE ENERGY"",gibbs). psi4.clean(). optstash.restore(). # return 0K g2 results; return eg2_0k. # aliases for g2; driver.procedures['energy']['gaussian-2'] = run_gaussian_2; driver.procedures['energy",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/gaussian_n.html:5486,energy,energy,5486,psi4manual/1.0.0/_modules/gaussian_n.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/gaussian_n.html,1,['energy'],['energy']
Energy Efficiency,"\n' % e_delta_g2); psi4.print_out(' E(2DF): %20.12lf\n' % e_2df); psi4.print_out(' E(+): %20.12lf\n' % e_plus); psi4.print_out(' E(G1 HLC): %20.12lf\n' % hlc1); psi4.print_out(' E(G2 HLC): %20.12lf\n' % hlc); psi4.print_out(' E(ZPE): %20.12lf\n' % zpe); psi4.print_out('\n'); psi4.print_out(' ==> 0 Kelvin Results <==\n'); psi4.print_out('\n'); eg2_0k = eg2 + zpe + hlc; psi4.print_out(' G1: %20.12lf\n' % (eqci + e_plus + e_2df + hlc1 + zpe)); psi4.print_out(' G2(MP2): %20.12lf\n' % eg2_mp2_0k); psi4.print_out(' G2: %20.12lf\n' % eg2_0k). psi4.set_variable(""G1 TOTAL ENERGY"",eqci + e_plus + e_2df + hlc1 + zpe); psi4.set_variable(""G2 TOTAL ENERGY"",eg2_0k); psi4.set_variable(""G2(MP2) TOTAL ENERGY"",eg2_mp2_0k). psi4.print_out('\n'); T = psi4.get_global_option('T'); psi4.print_out(' ==> %3.0lf Kelvin Results <==\n'% T); psi4.print_out('\n'). internal_energy = eg2_mp2_0k + du - zpe / 0.8929; enthalpy = eg2_mp2_0k + dh - zpe / 0.8929; gibbs = eg2_mp2_0k + dg - zpe / 0.8929. psi4.print_out(' G2(MP2) energy: %20.12lf\n' % internal_energy ); psi4.print_out(' G2(MP2) enthalpy: %20.12lf\n' % enthalpy); psi4.print_out(' G2(MP2) free energy: %20.12lf\n' % gibbs); psi4.print_out('\n'). psi4.set_variable(""G2(MP2) INTERNAL ENERGY"",internal_energy); psi4.set_variable(""G2(MP2) ENTHALPY"",enthalpy); psi4.set_variable(""G2(MP2) FREE ENERGY"",gibbs). internal_energy = eg2_0k + du - zpe / 0.8929; enthalpy = eg2_0k + dh - zpe / 0.8929; gibbs = eg2_0k + dg - zpe / 0.8929. psi4.print_out(' G2 energy: %20.12lf\n' % internal_energy ); psi4.print_out(' G2 enthalpy: %20.12lf\n' % enthalpy); psi4.print_out(' G2 free energy: %20.12lf\n' % gibbs). psi4.set_variable(""CURRENT ENERGY"",eg2_0k). psi4.set_variable(""G2 INTERNAL ENERGY"",internal_energy); psi4.set_variable(""G2 ENTHALPY"",enthalpy); psi4.set_variable(""G2 FREE ENERGY"",gibbs). psi4.clean(). optstash.restore(). # return 0K g2 results; return eg2_0k. # aliases for g2; procedures['energy']['gaussian-2'] = run_gaussian_2; procedures['energy']['g2'] = run",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/gaussian_n.html:5224,energy,energy,5224,psi4manual/4.0b5/_modules/gaussian_n.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/gaussian_n.html,2,['energy'],['energy']
Energy Efficiency,"\n'); psi4.print_out(' SAPT Charge Transfer Analysis\n'); psi4.print_out(' -----------------------------------------------------------------------------\n'); line1 = ' SAPT Induction (Dimer Basis) %10.4lf mH %10.4lf kcal mol^-1\n' % (CTd * 1000.0, CTd * p4const.psi_hartree2kcalmol); line2 = ' SAPT Induction (Monomer Basis) %10.4lf mH %10.4lf kcal mol^-1\n' % (CTm * 1000.0, CTm * p4const.psi_hartree2kcalmol); line3 = ' SAPT Charge Transfer %10.4lf mH %10.4lf kcal mol^-1\n\n' % (CT * 1000.0, CT * p4const.psi_hartree2kcalmol); psi4.print_out(line1); psi4.print_out(line2); psi4.print_out(line3); psi4.set_variable('SAPT CT ENERGY', CT). molecule.reset_point_group(user_pg); molecule.update_geometry(). optstash.restore(); return e_sapt. [docs]def run_mrcc(name, **kwargs):; """"""Function that prepares environment and input files; for a calculation calling Kallay's MRCC code. """"""; # TODO: Check to see if we really need to run the SCF code.; scf_helper(name, **kwargs); vscf = psi4.get_variable('SCF TOTAL ENERGY'). # The parse_arbitrary_order method provides us the following information; # We require that level be provided. level is a dictionary; # of settings to be passed to psi4.mrcc; if not('level' in kwargs):; raise ValidationError('level parameter was not provided.'). level = kwargs['level']. # Fullname is the string we need to search for in iface; fullname = level['fullname']. # User can provide 'keep' to the method.; # When provided, do not delete the MRCC scratch directory.; keep = False; if 'keep' in kwargs:; keep = kwargs['keep']. # Save current directory location; current_directory = os.getcwd(). # Need to move to the scratch directory, perferrably into a separate directory in that location; psi_io = psi4.IOManager.shared_object(); os.chdir(psi_io.get_default_path()). # Make new directory specifically for mrcc; mrcc_tmpdir = 'mrcc_' + str(os.getpid()); if 'path' in kwargs:; mrcc_tmpdir = kwargs['path']. # Check to see if directory already exists, if not, create.; if os",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/proc.html:59455,ENERGY,ENERGY,59455,psi4manual/4.0b5/_modules/proc.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/proc.html,1,['ENERGY'],['ENERGY']
Energy Efficiency,"\n', end=""""); sys.stdout.flush(). # Load in displacement into the active molecule (xyz coordinates only); molecule.set_geometry(displacement). # Perform the gradient calculation; func(lowername, **kwargs). # Save the gradient; G = psi4.get_gradient(); gradients.append(G). # clean may be necessary when changing irreps of displacements; psi4.clean(). psi4.fd_freq_1(gradients, irrep). print(' Computation complete.'). # Clear the ""parent"" symmetry now; psi4.set_parent_symmetry(""""). # TODO: These need to be restored to the user specified setting; psi4.get_active_molecule().fix_orientation(False); # But not this one, it always goes back to True; psi4.get_active_molecule().reinterpret_coordentry(True). optstash.restore(); # TODO: add return statement of hessian matrix; # TODO: set current energy to un-displaced energy. else:; # If not, perform finite difference of energies; print('Performing finite difference calculations by energies'). # Set method-dependent scf convergence criteria (test on procedures['energy'] since that's guaranteed); optstash.restore(); if not psi4.has_option_changed('SCF', 'E_CONVERGENCE'):; if procedures['energy'][lowername] == run_scf or procedures['energy'][lowername] == run_dft:; psi4.set_local_option('SCF', 'E_CONVERGENCE', 10); else:; psi4.set_local_option('SCF', 'E_CONVERGENCE', 11); if not psi4.has_option_changed('SCF', 'D_CONVERGENCE'):; if procedures['energy'][lowername] == run_scf or procedures['energy'][lowername] == run_dft:; psi4.set_local_option('SCF', 'D_CONVERGENCE', 10); else:; psi4.set_local_option('SCF', 'D_CONVERGENCE', 11). # Set post-scf convergence criteria (global will cover all correlated modules); if not psi4.has_global_option_changed('E_CONVERGENCE'):; if not procedures['energy'][lowername] == run_scf and not procedures['energy'][lowername] == run_dft:; psi4.set_global_option('E_CONVERGENCE', 10). # Obtain list of displacements; displacements = psi4.fd_geoms_freq_0(irrep); molecule.fix_orientation(True); molecule.reinterpr",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/driver.html:64642,energy,energy,64642,psi4manual/4.0b5/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/driver.html,2,['energy'],['energy']
Energy Efficiency,"\nSET,SPIN=$spin\ndummy"";; # foreach $at (@monoAreal) { print $handle "",$at""; }; # print $handle ""\n{df-hf,basis=jkfit,locorb=0; start,atdens; save,\$gb}\n"";; # print $handle ""{df-ks,lhf,df_basis=dflhf,basis_coul=jkfitb,basis_exch=jkfitb; dftfac,1.0; start,\$gb; save,\$cb}\n"";; # print $handle ""eehfb=energy; sapt; monomerB\n\n"";; #; # $spin = $cgmp{MLPsyst} - 1;; # print $handle ""SET,CHARGE=$cgmp{CHGsyst}\nSET,SPIN=$spin\n"";; # print $handle ""{sapt,SAPT_LEVEL=3; intermol,ca=\$ca,cb=\$cb,icpks=0,fitlevel=3,nlexfac=0.0,cfac=0.0\n"";; # print $handle ""dfit,basis_coul=jkfit,basis_exch=jkfit,cfit_scf=3}\n"";; # print $handle ""eedisp=E2disp\n\n"";; #; # ],; }. #'dft-sapt-shift': [; #; # # this is written in an inflexible way (fixed basis, functional) so that it is computed; # # only once, then used when writing DFT-SAPT inputs, which we'll be more flexible with; #; # print $handle ""basis={\n"";; # print $handle ""set,orbital; default,aug-cc-pVQZ\n"";; # print $handle ""set,jkfit; default,avqz/jkfit\n"";; # print $handle ""set,dflhf; default,avqz/jkfit\n"";; # print $handle ""}\n"";; #; # if ($handle eq ""M1OUT"") { $charge = $cgmp{CHGmol1}; $spin = $cgmp{MLPmol1} - 1; }; # elsif ($handle eq ""M2OUT"") { $charge = $cgmp{CHGmol2}; $spin = $cgmp{MLPmol2} - 1; }; #; # print $handle ""\ngdirect\n"";; # print $handle ""{df-ks,pbex,pw91c,lhf; dftfac,0.75,1.0,0.25}\n"";; # print $handle ""basis=tzvpp\n"";; # print $handle ""{ks,pbe0; orbprint,0}\n"";; # print $handle ""eeneut=energy\n"";; # $charge += 1;; # $spin += 1;; # print $handle ""SET,CHARGE=$charge\nSET,SPIN=$spin\n"";; # print $handle ""{ks,pbe0}\n"";; # print $handle ""eecat=energy\n"";; # print $handle ""eeie=eecat-eeneut\n"";; # print $handle ""show[1,20f20.12],ee*,ce*,te*\n"";; # print $handle ""show[1,60f20.12],_E*\n"";; # ]; #'dft-sapt': [; #; # if ( ($asyA eq '') || ($asyB eq '') ) {; # print ""ERROR: asymptotic correction not defined for one or more monomers in index $system.\n"";; # close(DIOUT);; # unlink(""$pathDIOUT"");; # }; #; # print $handle ""gdire",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/molpro.html:7620,charge,charge,7620,psi4manual/1.0.0/_modules/qcdb/molpro.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/molpro.html,2,['charge'],['charge']
Energy Efficiency,"\n\n"""""" % (; functionname.upper()); cbsscheme += """""" LO-zeta (%s) Energy: % 16.12f\n"""""" % (str(zLO), valueLO); cbsscheme += """""" HI-zeta (%s) Energy: % 16.12f\n"""""" % (str(zHI), valueHI); cbsscheme += """""" Alpha (exponent) Value: % 16.12f\n"""""" % (alpha); cbsscheme += """""" Beta (coefficient) Value: % 16.12f\n\n"""""" % (beta). name_str = ""%s/(%s,%s)"" % (functionname.upper(), _zeta_val2sym[zLO].upper(), _zeta_val2sym[zHI].upper()); cbsscheme += """""" @Extrapolated """"""; cbsscheme += name_str + ':'; cbsscheme += "" "" * (18 - len(name_str)); cbsscheme += """"""% 16.12f\n\n"""""" % value; core.print_out(cbsscheme). return value. elif isinstance(valueLO, (core.Matrix, core.Vector)):; beta = valueHI.clone(); beta.name = 'Truhlar SCF (%s, %s) beta' % (zLO, zHI); beta.subtract(valueLO); beta.scale(beta_division); beta.scale(beta_mult). value = valueHI.clone(); value.subtract(beta); value.name = 'Truhlar SCF (%s, %s) data' % (zLO, zHI). if verbose > 2:; core.print_out(""""""\n ==> Truhlar 2-point power from SCF extrapolation for method: %s <==\n\n"""""" %; (functionname.upper())); core.print_out("""""" LO-zeta (%s)"""""" % str(zLO)); core.print_out("""""" LO-zeta Data""""""); valueLO.print_out(); core.print_out("""""" HI-zeta (%s)"""""" % str(zHI)); core.print_out("""""" HI-zeta Data""""""); valueHI.print_out(); core.print_out("""""" Extrapolated Data:\n""""""); value.print_out(); core.print_out("""""" Alpha (exponent) Value: %16.8f\n"""""" % (alpha)); core.print_out("""""" Beta Data:\n""""""); beta.print_out(). return value. else:; raise ValidationError(""scf_xtpl_truhlar_2: datatype is not recognized '%s'."" % type(valueLO)). [docs]def scf_xtpl_karton_2(functionname: str, zLO: int, valueLO: float, zHI: int, valueHI: float, verbose: bool = True, alpha: float = None):; r""""""Extrapolation scheme using root-power form for reference energies with two adjacent; zeta-level bases. Used by :py:func:`~psi4.cbs`. Parameters; ----------; functionname; Name of the CBS component.; zLO; Lower zeta level.; valueLO; Lower value used for extrapolation.; zHI;",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html:12864,power,power,12864,psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html,4,['power'],['power']
Energy Efficiency,"\n\n"""""" % value; core.print_out(cbsscheme); logger.debug(cbsscheme). return value. elif isinstance(valueLO, np.ndarray):. beta = (valueHI - valueLO) * beta_division; value = valueHI - beta * beta_mult. if verbose > 2:; cbsscheme = f""""""\n ==> Truhlar 2-point power SCF extrapolation for method: {functionname.upper()} <==\n""""""; cbsscheme += f""""""\n LO-zeta ({zLO}) Data\n""""""; cbsscheme += nppp(valueLO); cbsscheme += f""""""\n HI-zeta ({zHI}) Data\n""""""; cbsscheme += nppp(valueHI). cbsscheme += f""""""\n Alpha (exponent) Value: {alpha:16.8f}""""""; cbsscheme += f""""""\n Beta Data\n""""""; cbsscheme += nppp(beta); cbsscheme += f""""""\n Extrapolated Data\n""""""; cbsscheme += nppp(value); cbsscheme += ""\n""; core.print_out(cbsscheme); logger.debug(cbsscheme). return value. else:; raise ValidationError(f""scf_xtpl_truhlar_2: datatype is not recognized '{type(valueLO)}'.""). [docs]def scf_xtpl_karton_2(functionname: str, zLO: int, valueLO: Extrapolatable, zHI: int, valueHI: Extrapolatable, verbose: int = 1, alpha: Optional[float] = None) -> Extrapolatable:; r""""""Extrapolation scheme using root-power form for reference energies with two adjacent; zeta-level bases. Used by :py:func:`~psi4.cbs`. Parameters; ----------; functionname; Name of the CBS component (e.g., 'HF') used in summary printing.; zLO; Zeta number of the smaller basis set in 2-point extrapolation.; valueLO; Energy, gradient, or Hessian value at the smaller basis set in 2-point; extrapolation.; zHI; Zeta number of the larger basis set in 2-point extrapolation; Must be `zLO + 1`.; valueHI; Energy, gradient, or Hessian value at the larger basis set in 2-point; extrapolation.; verbose; Controls volume of printing.; alpha; Overrides the default :math:`\alpha = 6.3`. Returns; -------; float or ndarray; Eponymous function applied to input zetas and values; type from `valueLO`. Notes; -----; The extrapolation is calculated according to [3]_:; :math:`E_{total}^X = E_{total}^{\infty} + \beta e^{-\alpha\sqrt{X}}, \alpha = 6.3`. References; -------",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver_cbs_helper.html:10048,power,power,10048,psi4manual/1.6.x/_modules/psi4/driver/driver_cbs_helper.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver_cbs_helper.html,2,['power'],['power']
Energy Efficiency,"\n\n"""""" % value; core.print_out(cbsscheme); logger.debug(cbsscheme). return value. elif isinstance(valueLO, np.ndarray):. beta = (valueHI - valueLO) * beta_division; value = valueHI - beta * beta_mult. if verbose > 2:; cbsscheme = f""""""\n ==> Truhlar 2-point power SCF extrapolation for method: {functionname.upper()} <==\n""""""; cbsscheme += f""""""\n LO-zeta ({zLO}) Data\n""""""; cbsscheme += nppp(valueLO); cbsscheme += f""""""\n HI-zeta ({zHI}) Data\n""""""; cbsscheme += nppp(valueHI). cbsscheme += f""""""\n Alpha (exponent) Value: {alpha:16.8f}""""""; cbsscheme += f""""""\n Beta Data\n""""""; cbsscheme += nppp(beta); cbsscheme += f""""""\n Extrapolated Data\n""""""; cbsscheme += nppp(value); cbsscheme += ""\n""; core.print_out(cbsscheme); logger.debug(cbsscheme). return value. else:; raise ValidationError(f""scf_xtpl_truhlar_2: datatype is not recognized '{type(valueLO)}'.""). [docs]def scf_xtpl_karton_2(functionname: str, zLO: int, valueLO: Extrapolatable, zHI: int, valueHI: Extrapolatable, verbose: int = 1, alpha: Optional[float] = None) -> Extrapolatable:; r""""""Extrapolation scheme using root-power form for reference energies with two adjacent; zeta-level bases. Used by :py:func:`~psi4.driver.cbs`. Parameters; ----------; functionname; Name of the CBS component (e.g., 'HF') used in summary printing.; zLO; Zeta number of the smaller basis set in 2-point extrapolation.; valueLO; Energy, gradient, or Hessian value at the smaller basis set in 2-point; extrapolation.; zHI; Zeta number of the larger basis set in 2-point extrapolation; Must be `zLO + 1`.; valueHI; Energy, gradient, or Hessian value at the larger basis set in 2-point; extrapolation.; verbose; Controls volume of printing.; alpha; Overrides the default :math:`\alpha = 6.3`. Returns; -------; float or ~numpy.ndarray; Eponymous function applied to input zetas and values; type from `valueLO`. Notes; -----; The extrapolation is calculated according to [3]_:; :math:`E_{total}^X = E_{total}^{\infty} + \beta e^{-\alpha\sqrt{X}}, \alpha = 6.3`. Refer",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver_cbs_helper.html:10090,power,power,10090,psi4manual/1.7.x/_modules/psi4/driver/driver_cbs_helper.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver_cbs_helper.html,2,['power'],['power']
Energy Efficiency,"\right) \ \mathrm{d} ^3 r_1\]. \[-\frac{1}{2} \sum_{i,j}; \delta_{\sigma_{i} \sigma_{j}} \alpha \iint_{\mathrm{R}^6} \phi_{i}^1 \phi_{j}^1; \frac{1}{r_{12}} \phi_{i}^2 \phi_{j}^2 \ \mathrm{d}^3 r_1 \ \mathrm{d}^3 r_2\]. \[-\frac{1}{2} \sum_{i,j}; \delta_{\sigma_{i} \sigma_{j}} (1-\alpha)\iint_{\mathrm{R}^6} \phi_{i}^1 \phi_{j}^1; \frac{\mathrm{erf}(\omega r_{12})}{r_{12}} \phi_{i}^2 \phi_{j}^2 \ \mathrm{d}^3 r_1 \ \mathrm{d}^3 r_2\]; For LRC functionals, the choice of range-separation parameter \(\omega\) has; been the subject of considerable activity since the inception of LRC; functionals. Some authors advocate a static range-separation parameter; determined by optimization over a test set of chemical systems. However, a more; physically-motivated and often more accurate approach is the idea of “gap; fitting” or “optimal tuning” or simply “tuning.” The most popular tuned-LRC; approach is IP-fitting, in which the \(\omega\) is varied until the; Koopman’s IP (the opposite of the HOMO energy) matches the true IP (the; difference between \(N-1\)-electron and \(N\)-electron total; energies), within the LRC functional ansatz. This guarantees the asymptotics of; the exchange potential,. \[\lim_{r\rightarrow\infty} v_{\mathrm{x}}^{\mathrm{tuned-LRC}} (r) = -; \frac{1}{r} + I_{\mathrm{IP}} +; \epsilon_{\mathrm{HOMO}}\]; Note that LRC functionals with default \(\omega\) only capture the; \(-1/r\) dependence,. \[\lim_{r\rightarrow\infty} v_{\mathrm{x}}^{\mathrm{LRC}} (r) = -; \frac{1}{r},\]; hybrid functionals only capture part of the \(-1/r\) dependence,. \[\lim_{r\rightarrow\infty} v_{\mathrm{x}}^{\mathrm{Hybrid}} (r) = -; \frac{\alpha}{r},\]; and local functionals decay exponentially, resulting in completely incorrect; asymptotics,. \[\lim_{r\rightarrow\infty} v_{\mathrm{x}}^{\mathrm{Local}} (r) = 0\]; IP-tuned LRC functionals effectively pin the chemical potential at \(N\); electrons to the correct value determined by the ionization potential. This; often cleans up the M",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/dft-1.html:10652,energy,energy,10652,psi4manual/1.2.1/dft-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/dft-1.html,15,['energy'],['energy']
Energy Efficiency,"\s*'; #r'^\s+' + r'E2ind\s+' + NUMBER + r'\s+\(\s*' + NUMBER + r')\s+' + NUMBER + r'\s+' + NUMBER + '\s*'; #r'^\s+' + r'E2ind-exch\s+' + NUMBER + r'\s+\(\s*' + NUMBER + r')\s+' + NUMBER + r'\s+' + NUMBER + '\s*'; #r'^\s+' + r'E2disp\(unc\)\s+' + NUMBER + r'\s+\(\s*' + NUMBER + r')\s+' + NUMBER + r'\s+' + NUMBER + '\s*'; # r'^\s+' + r'E2disp\s+' + NUMBER + r'\s+\(\s*' + NUMBER + r'\)\s+' + NUMBER + r'\s+' + NUMBER + '\s*',; r'^\s+' + r'E2disp\s+' + NUMBER + r'.*$',; #r'^\s+' + r'E2disp-exch\(unc\)\s+' + NUMBER + r'\s+\(\s*' + NUMBER + r')\s+' + NUMBER + r'\s+' + NUMBER + '\s*'; #r'^\s+' + r'E2disp-exc\s+' + NUMBER + r'\s+\(\s*' + NUMBER + r')\s+' + NUMBER + r'\s+' + NUMBER + '\s*'; outtext, re.MULTILINE); if mobj:; #print('matched sapt-like'); psivar['MP2C DISP20 ENERGY'] = Decimal(mobj.group(1)) / Decimal(1000). # <<< Process SCF-F12 >>>. mobj = re.search(; r'^\s+' + r'CABS-singles contribution of\s+' + NUMBER + r'\s+patched into reference energy.\s*' +; r'^\s+' + r'New reference energy\s+' + NUMBER + r'\s*$',; outtext, re.MULTILINE); if mobj:; #print('matched scff12'); psivar['SCF TOTAL ENERGY'] = Decimal(mobj.group(2)) - Decimal(mobj.group(1)); psivar['HF-CABS TOTAL ENERGY'] = mobj.group(2). # <<< Process MP2-F12 >>>. # DF-MP2-F12 correlation energies:; # --------------------------------; # Approx. Singlet Triplet Ecorr Total Energy; # DF-MP2 -0.261035854033 -0.140514056591 -0.401549910624 -112.843952380305; # DF-MP2-F12/3*C(DX,FIX) -0.367224875485 -0.163178266500 -0.530403141984 -112.972805611666; # DF-MP2-F12/3*C(FIX) -0.358294348708 -0.164988061549 -0.523282410258 -112.965684879939; # DF-MP2-F12/3C(FIX) -0.357375628783 -0.165176490386 -0.522552119169 -112.964954588851; #; # DF-MP2-F12 correlation energies:; # ================================; # Approx. Singlet Triplet Ecorr Total Energy; # DF-MP2 -0.357960885582 -0.185676627667 -0.543637513249 -132.841755020796; # DF-MP2-F12/3*C(DX,FIX) -0.381816069559 -0.188149510095 -0.569965579654 -132.868083087202; # DF-MP2",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/molpro2.html:4268,energy,energy,4268,psi4manual/1.0.0/_modules/qcdb/molpro2.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/molpro2.html,1,['energy'],['energy']
Energy Efficiency,"\s+' + NUMBER + r'\s+' + NUMBER + r'\s*' +; r'^\s+' + r'DF-MP2-F12/3C\(FIX\)\s+' + NUMBER + r'\s+' + NUMBER + r'\s+' + NUMBER + r'\s+' + NUMBER + r'\s*$',; outtext, re.MULTILINE); if mobj:; #print('matched mp2f12'); psivar['MP2 CORRELATION ENERGY'] = mobj.group(3); psivar['MP2 SAME-SPIN CORRELATION ENERGY'] = Decimal(mobj.group(2)) * \; Decimal(2) / Decimal(3); psivar['MP2 OPPOSITE-SPIN CORRELATION ENERGY'] = Decimal(mobj.group(3)) - \; psivar['MP2 SAME-SPIN CORRELATION ENERGY']; psivar['MP2 TOTAL ENERGY'] = mobj.group(4); psivar['MP2-F12 CORRELATION ENERGY'] = mobj.group(15); psivar['MP2-F12 SAME-SPIN CORRELATION ENERGY'] = Decimal(mobj.group(14)) * \; Decimal(2) / Decimal(3); psivar['MP2-F12 OPPOSITE-SPIN CORRELATION ENERGY'] = Decimal(mobj.group(15)) - \; psivar['MP2-F12 SAME-SPIN CORRELATION ENERGY']; psivar['MP2-F12 TOTAL ENERGY'] = mobj.group(16). # <<< Process CC >>>. mobj = re.search(; r'^\s*' + r'CCSD triplet pair energy\s+' + NUMBER + '\s*' +; r'^\s*' + r'CCSD correlation energy\s+' + NUMBER + '\s*' +; r'^\s*' + r'Triples \(T\) contribution\s+' + NUMBER + '\s*$',; outtext, re.MULTILINE); if mobj:; #print('matched ccsd(t)'); psivar['CCSD CORRELATION ENERGY'] = mobj.group(2); psivar['CCSD SAME-SPIN CORRELATION ENERGY'] = Decimal(mobj.group(1)) * \; Decimal(2) / Decimal(3); psivar['CCSD OPPOSITE-SPIN CORRELATION ENERGY'] = Decimal(mobj.group(2)) - \; psivar['CCSD SAME-SPIN CORRELATION ENERGY']; psivar['CCSD TOTAL ENERGY'] = Decimal(mobj.group(2)) + psivar['HF TOTAL ENERGY']; psivar['(T) CORRECTION ENERGY'] = mobj.group(3); psivar['CCSD(T) CORRELATION ENERGY'] = Decimal(mobj.group(2)) + Decimal(mobj.group(3)); psivar['CCSD(T) TOTAL ENERGY'] = psivar['CCSD(T) CORRELATION ENERGY'] + psivar['HF TOTAL ENERGY']. # <<< Process CC-F12 >>>. mobj = re.search(; r'^\s*' + r'CCSD-F12a triplet pair energy\s+' + NUMBER + '\s*' +; r'^\s*' + r'CCSD-F12a correlation energy\s+' + NUMBER + '\s*' +; r'^\s*' + r'Triples \(T\) contribution\s+' + NUMBER + '\s*$',; outtext, re.MULTILI",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/molpro2.html:6830,energy,energy,6830,psi4manual/1.0.0/_modules/qcdb/molpro2.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/molpro2.html,2,['energy'],['energy']
Energy Efficiency,"\s+[-+]?\d+\.\d+\s+[-+]?\d+\.\d+\s+[-+]?\d+\.\d+\s*\n)+)' +; r'\n\n' +; r'\s+' + 'Molecular gradient norm',; outtext, re.MULTILINE); if mobj:; print('matched molgrad'); atoms = []; psivar_grad = []; for line in mobj.group(1).splitlines():; lline = line.split(); atoms.append(lline[0]); #psivar_gradient.append([Decimal(lline[-3]), Decimal(lline[-2]), Decimal(lline[-1])]); psivar_grad.append([float(lline[-3]), float(lline[-2]), float(lline[-1])]). # Process geometry; mobj = re.search(; # r'\s+(?:-+)\s*' +; # r'^\s+' + r'Z-matrix Atomic Coordinates (in bohr)' + r'\s*' +; r'^\s+' + r'Symbol Number X Y Z' + r'\s*' +; r'^\s+(?:-+)\s*' +; r'((?:\s+[A-Z]+\s+[0-9]+\s+[-+]?\d+\.\d+\s+[-+]?\d+\.\d+\s+[-+]?\d+\.\d+\s*\n)+)' +; r'^\s+(?:-+)\s*',; outtext, re.MULTILINE); if mobj:; print('matched geom'); molxyz = '%d bohr\n\n' % len(mobj.group(1).splitlines()); for line in mobj.group(1).splitlines():; lline = line.split(); molxyz += '%s %16s %16s %16s\n' % (lline[0], lline[-3], lline[-2], lline[-1]); # Rather a dinky Molecule as no ghost, charge, or multiplicity; psivar_coord = Molecule.init_with_xyz(molxyz, no_com=True, no_reorient=True, contentsNotFilename=True). # Process atom geometry; mobj = re.search(; r'^\s+' + r'@GETXYZ-I, 1 atoms read from ZMAT.' + r'\s*' +; r'^\s+' + r'[0-9]+\s+([A-Z]+)\s+[0-9]+\s+' + NUMBER + r'\s*',; outtext, re.MULTILINE); if mobj:; print('matched atom'); # Dinky Molecule; molxyz = '1 bohr\n\n%s 0.0 0.0 0.0\n' % (mobj.group(1)); psivar_coord = Molecule.init_with_xyz(molxyz, no_com=True, no_reorient=True, contentsNotFilename=True). # Process error codes; mobj = re.search(; r'^\s*' + r'--executable ' + r'(\w+)' + r' finished with status' + r'\s+' + r'([1-9][0-9]*)',; outtext, re.MULTILINE); if mobj:; print('matched error'); psivar['CFOUR ERROR CODE'] = mobj.group(2). # Process CURRENT energies (TODO: needs better way); if 'SCF TOTAL ENERGY' in psivar:; psivar['CURRENT REFERENCE ENERGY'] = psivar['SCF TOTAL ENERGY']; psivar['CURRENT ENERGY'] = psivar['SCF",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/cfour.html:17313,charge,charge,17313,psi4manual/1.0.0/_modules/qcdb/cfour.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/cfour.html,1,['charge'],['charge']
Energy Efficiency,"\t%5.1f%20.10f"" % (point[0], point[1]). Dealing with problematic optimizations¶; Although optking is continuously improved with robustness in mind, some; attempted optimizations will inevitably fail to converge to the desired minima.; For difficult cases, the following suggestions are made. As for any optimizer, computing the Hessian and limiting the step size will; successfully converge a higher percentage of cases. The default settings have; been chosen because they perform efficiently for common, representative test sets.; More restrictive, cautious steps are sometimes necessary.; DYNAMIC_LEVEL allows optking to change the method of optimization; toward algorithms that, while often less efficient, may help to converge difficult; cases. If this is initially set to 1, then optking, as poor steps are detected,; will increase the level through several forms of more robust and cautious algorithms.; The changes will reduce the trust radius, allow backward steps (partial line; searching), add cartesian coordinates, switch to cartesian coordinates, and take; steepest-descent steps.; The developers have found the OPT_COORDINATES set to “BOTH” which; includes both the redundant internal coordinate set, as well as cartesian coordinates,; works well for systems with long ‘arms’ or floppy portions of a molecule poorly; described by local internals. Direct manipulation of the optmization coordinates¶. Generate the internal coordinates and then stop:; 1; 2set intcos_generate_exit true; optimize('scf'). The coordinates may then be found in the “intco” file. In this case, the file contains:; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10F 1 3; R 1 2; R 1 3; B 2 1 3; C 1; 1 1.000000; C 1; 2 1.000000; C 1; 3 1.000000. The first line indicates a fragment containing atoms 1-3. The following lines define; two distance coordinates (bonds) and one bend coordinate. This file can be modified, and if present,; is used in subsequent optimizations. The lines below the simple internal coordinates; specify line",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/optking-1.html:8932,reduce,reduce,8932,psi4manual/1.1.0/optking-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/optking-1.html,6,['reduce'],['reduce']
Energy Efficiency,"\t%5.1f%20.10f"" % (point[0], point[1]). Dealing with problematic optimizations¶; Although optking is continuously improved with robustness in mind, some; attempted optimizations will inevitably fail to converge to the desired minima.; For difficult cases, the following suggestions are made. As for any optimizer, computing the Hessian and limiting the step size will; successfully converge a higher percentage of cases. The default settings have; been chosen because they perform efficiently for common, representative test sets.; More restrictive, cautious steps are sometimes necessary.; DYNAMIC_LEVEL allows optking to change the method of optimization; toward algorithms that, while often less efficient, may help to converge difficult; cases. If this is initially set to 1, then optking, as poor steps are detected,; will increase the level through several forms of more robust and cautious algorithms.; The changes will reduce the trust radius, allow backward steps (partial line; searching), add cartesian coordinates, switch to cartesian coordinates, and take; steepest-descent steps.; The developers have found the OPT_COORDINATES set to “BOTH” which; includes both the redundant internal coordinate set, as well as cartesian coordinates,; works well for systems with long ‘arms’ or floppy portions of a molecule poorly; described by local internals. Direct manipulation of the optmization coordinates¶. Generate the internal coordinates and then stop:; set intcos_generate_exit true; optimize('scf'). The coordinates may then be found in the “intco” file. In this case, the file contains:; F 1 3; R 1 2; R 1 3; B 2 1 3; C 1; 1 1.000000; C 1; 2 1.000000; C 1; 3 1.000000. The first line indicates a fragment containing atoms 1-3. The following lines define; two distance coordinates (bonds) and one bend coordinate. This file can be modified, and if present,; is used in subsequent optimizations. The lines below the simple internal coordinates; specify linear combinations of coordinates. I",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/optking-1.html:8640,reduce,reduce,8640,psi4manual/1.4.0/optking-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/optking-1.html,7,['reduce'],['reduce']
Energy Efficiency,"\text{aug-cc-pV[DT]Z}}\right) - \mathcal{F}_{\text{corl_xtpl_helgaker_2}} \left(E_{\text{corl},\; \text{MP2}}^{\text{aug-cc-pV[DT]Z}}\right)\]. Energy MethodsThe presence of a stage_wfn keyword is the indicator to incorporate; (and check for stage_basis and stage_scheme keywords) and compute; that stage in defining the CBS energy.; The cbs() function requires, at a minimum, name='scf' and scf_basis; keywords to be specified for reference-step only jobs and name and; corl_basis keywords for correlated jobs.; The following energy methods have been set up for cbs(). scf; hf; mp2; mp2.5; mp3; mp4(sdq); mp4; mpn. omp2; omp2.5; omp3; olccd; lccd; lccsd; cepa(0); cepa(1). cepa(3); acpf; aqcc; qcisd; cc2; ccsd; fno-ccsd; bccd. cc3; qcisd(t); ccsd(t); fno-ccsd(t); bccd(t); cisd; cisdt. cisdtq; cin; fci; mrccsd; mrccsd(t); mrccsdt; mrccsdt(q). Parameters. name (str) – 'scf' || 'ccsd' || etc.; First argument, usually unlabeled. Indicates the computational method; for the correlation energy, unless only reference step to be performed,; in which case should be 'scf'. Overruled if stage_wfn keywords supplied. scf_wfn (str) – \(\Rightarrow\) 'scf' \(\Leftarrow\) || 'c4-scf' || etc.; Indicates the energy method for which the reference energy is to be; obtained. Generally unnecessary, as ‘scf’ is the scf in PSI4 but; can be used to direct lone scf components to run in PSI4 or Cfour; in a mixed-program composite method. corl_wfn (str) – 'mp2' || 'ccsd(t)' || etc.; Indicates the energy method for which the correlation energy is to be; obtained. Can also be specified with name or as the unlabeled; first argument to the function. delta_wfn (str) – 'ccsd' || 'ccsd(t)' || etc.; Indicates the (superior) energy method for which a delta correction; to the correlation energy is to be obtained. delta_wfn_lesser (str) – \(\Rightarrow\) corl_wfn \(\Leftarrow\) || 'mp2' || etc.; Indicates the inferior energy method for which a delta correction; to the correlation energy is to be obtained. delta2_",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/api/psi4.driver.cbs-1.html:5123,energy,energy,5123,psi4manual/1.4.0/api/psi4.driver.cbs-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/api/psi4.driver.cbs-1.html,15,['energy'],['energy']
Energy Efficiency,"\vec r_1) \nabla \phi_{\nu} (\vec r_1)\]; GGA functionals are essentially the same cost as LSDA functionals and are often; considerably more accurate.; Another local variant which has gained some popularity (though perhaps not as; much as GGA functionals) is the meta approximation, in which information about; the second derivative of the density is incorporated. The most canonical variant; of these functionals rely on the spin kinetic energy density \(\tau_\alpha\); and \(\tau_\beta\),. \[\tau_\sigma(\vec r_1) = \sum_{i} \left | \nabla \psi_i^{\sigma} (\vec r_1) \right | ^2; = \sum_{i} \left | C_{\mu i}^{\sigma} \nabla \phi_{\mu} (\vec r_1) \right |; ^2 = D_{\mu\nu}^{\sigma} \nabla \phi_{\mu} (\vec r_1) \cdot \nabla; \phi_{\nu} (\vec r_1)\]; A generic local meta-GGA functional may then be written as,. \[E_{\mathrm{xc}}^{\mathrm{DFA}} = \int_{\mathbb{R}^3} f_{\mathrm{xc}}; \left(; \rho_{\alpha} (\vec r_1),; \rho_{\beta} (\vec r_1),; \gamma_{\alpha\alpha} (\vec r_1),; \gamma_{\alpha\beta} (\vec r_1),; \gamma_{\beta\beta} (\vec r_1),; \tau_{\alpha} (\vec r_1),; \tau_{\beta} (\vec r_1); \right) \ \mathrm{d} ^3 r_1\]; The potential corresponding to this energy functional is,. \[ \begin{align}\begin{aligned}V_{\mu\nu}^{\mathrm{xc},\alpha} =\\\int_{\mathbb{R}^3}; \left(\frac{\partial f}{\rho_\alpha}\right); \phi_{\mu}; \phi_{\nu}; \ \mathrm{d} ^3 r_1\end{aligned}\end{align} \]. \[+; \int_{\mathbb{R}^3}; \left(2 \frac{\partial f}{\gamma_{\alpha\alpha}} \nabla \rho_\alpha + \frac{\partial; f}{\gamma_{\alpha\beta}}\nabla \rho_\beta \right); \nabla\left(\phi_{\mu}; \phi_{\nu}\right); \ \mathrm{d} ^3 r_1\]. \[+; \int_{\mathbb{R}^3}; \left(\frac{\partial f}{\tau_\alpha}\right); \nabla \phi_{\mu}; \nabla \phi_{\nu}; \ \mathrm{d} ^3 r_1\]; This potential is used to build the Kohn–Sham matrix,. \[F_{\mu\mu}^{\alpha} = H_{\mu\nu} + J_{\mu\nu} +; V_{\mu\nu}^{\mathrm{xc},\alpha}\]; which is diagonalized to form the Kohn–Sham orbitals in the same manner as in; Hartree–Fock.; In practice",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/dft-1.html:4923,energy,energy,4923,psi4manual/1.2.1/dft-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/dft-1.html,15,['energy'],['energy']
Energy Efficiency,"] # list of lattice charges; self.lattice_field = psi4.QMMMbohr() # Psi4 chargefield. # MPI variables; self.mpi_world = None; self.world_rank = 0. # Flag for if a lattice of point charges has been set; self.set_lattice = False. # Get correct intra-code MPI communicator; if use_mpi4py:; self.mpi_world = MDI_MPI_get_world_comm(); self.world_rank = self.mpi_world.Get_rank(). # Psi4 does not currently support multiple MPI ranks; if self.mpi_world.Get_size() != 1:; MPI.COMM_WORLD.Abort(). # Accept a communicator to the driver code; self.comm = MDI_Accept_Communicator(). # Ensure that the molecule is using c1 symmetry; self.molecule.reset_point_group('c1'); self.molecule.fix_orientation(True); self.molecule.fix_com(True); self.molecule.reinterpret_coordentry(False); self.molecule.update_geometry(). # Flag to stop listening for MDI commands; self.stop_listening = False. # Dictionary of all supported MDI commands; self.commands = {; ""<NATOMS"": self.send_natoms,; ""<COORDS"": self.send_coords,; ""<CHARGES"": self.send_charges,; ""<ELEMENTS"": self.send_elements,; ""<MASSES"": self.send_masses,; ""<ENERGY"": self.send_energy,; ""<FORCES"": self.send_forces,; "">COORDS"": self.recv_coords,; "">NLATTICE"": self.recv_nlattice,; "">CLATTICE"": self.recv_clattice,; "">LATTICE"": self.recv_lattice,; "">MASSES"": self.recv_masses,; ""SCF"": self.run_scf,; ""<DIMENSIONS"": self.send_dimensions,; ""<TOTCHARGE"": self.send_total_charge,; "">TOTCHARGE"": self.recv_total_charge,; ""<ELEC_MULT"": self.send_multiplicity,; "">ELEC_MULT"": self.recv_multiplicity,; ""EXIT"": self.exit; }. # Register all the supported commands; MDI_Register_Node(""@DEFAULT""); for command in self.commands.keys():; MDI_Register_Command(""@DEFAULT"", command). def length_conversion(self):; """""" Obtain the conversion factor between the geometry specification units and bohr. :returns: *unit_conv* Conversion factor between the geometry specification units and bohr; """"""; unit_name = self.molecule.units(); if unit_name == ""Angstrom"":; # beware if MDI and psi",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/mdi_engine.html:3890,CHARGE,CHARGES,3890,psi4manual/1.9.x/_modules/psi4/driver/mdi_engine.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/mdi_engine.html,2,['CHARGE'],['CHARGES']
Energy Efficiency,"] # list of lattice charges; self.lattice_field = psi4.QMMMbohr() # Psi4 chargefield. # MPI variables; self.mpi_world = None; self.world_rank = 0. # Flag for if a lattice of point charges has been set; self.set_lattice = False. # Get correct intra-code MPI communicator; if use_mpi4py:; self.mpi_world = MDI_MPI_get_world_comm(); self.world_rank = self.mpi_world.Get_rank(). # Psi4 does not currently support multiple MPI ranks; if self.mpi_world.Get_size() != 1:; MPI.COMM_WORLD.Abort(). # Accept a communicator to the driver code; self.comm = MDI_Accept_Communicator(). # Ensure that the molecule is using c1 symmetry; self.molecule.reset_point_group('c1'); self.molecule.fix_orientation(True); self.molecule.fix_com(True); self.molecule.reinterpret_coordentry(False); self.molecule.update_geometry(). # Flag to stop listening for MDI commands; self.stop_listening = False. # Dictionary of all supported MDI commands; self.commands = {; ""<NATOMS"": self.send_natoms,; ""<COORDS"": self.send_coords,; ""<CHARGES"": self.send_charges,; ""<ELEMENTS"": self.send_elements,; ""<MASSES"": self.send_masses,; ""<ENERGY"": self.send_energy,; ""<FORCES"": self.send_forces,; "">COORDS"": self.recv_coords,; "">NLATTICE"": self.recv_nlattice,; "">CLATTICE"": self.recv_clattice,; "">LATTICE"": self.recv_lattice,; "">MASSES"": self.recv_masses,; ""SCF"": self.run_scf,; ""<DIMENSIONS"": self.send_dimensions,; ""<TOTCHARGE"": self.send_total_charge,; "">TOTCHARGE"": self.recv_total_charge,; ""<ELEC_MULT"": self.send_multiplicity,; "">ELEC_MULT"": self.recv_multiplicity,; ""EXIT"": self.exit; }. # Register all the supported commands; MDI_Register_Node(""@DEFAULT""); for command in self.commands.keys():; MDI_Register_Command(""@DEFAULT"", command). def length_conversion(self):; """""" Obtain the conversion factor between the geometry specification units and bohr. :returns: *unit_conv* Conversion factor between the geometry specification units and bohr; """"""; unit_name = self.molecule.units(); if unit_name == ""Angstrom"":; unit_conv = qcel.consta",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/mdi_engine.html:3452,CHARGE,CHARGES,3452,psi4manual/1.6.x/_modules/psi4/driver/mdi_engine.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/mdi_engine.html,3,['CHARGE'],['CHARGES']
Energy Efficiency,"] . Not unique because orbital spaces vary. EFP DISP ENERGY¶. EFP ELST ENERGY¶. EFP EXCH ENERGY¶. EFP IND ENERGY¶; Respectively, the dispersion, electrostatics, exchange, and induction; components of the total electronic interaction energy [E_h] for EFP/EFP; computations. The sum of these four components yields; EFP TOTAL ENERGY. EFP TOTAL ENERGY¶; The total electronic interaction energy [E_h] for EFP/EFP computations. EFP TORQUE¶; The torque, not gradient for EFP/EFP computations. ENTHALPY¶; Total enthalpy H [E_h] at given temperature. ENTHALPY CORRECTION¶; Sum of electronic, translational, rotational, and vibrational corrections [E_h] to the enthalpy at given temperature. ESP AT CENTER n¶; Property of electrostatic potential [E_h / e] at location, usually atom center, n. FCI TOTAL ENERGY¶. FCI CORRELATION ENERGY¶; The total electronic energy [E_h] and correlation energy component [E_h]; for the full configuration interaction level of theory. GIBBS FREE ENERGY¶; Total Gibbs free energy [E_h], free enthalpy at given temperature. GIBBS FREE ENERGY CORRECTION¶; Sum of electronic, translational, rotational, and vibrational corrections [E_h] to the free enthalpy at given temperature. GRID ELECTRONS TOTAL¶. GRID ELECTRONS ALPHA¶. GRID ELECTRONS BETA¶; The number of electrons integrated by the xc quadrature grid. HF TOTAL ENERGY¶; The total electronic energy [E_h] for the Hartree–Fock method, without; any dispersion correction; the first three (or four, since; \(E_{xc} = 0\)) terms in Eq. (4). Quantity \(E_{\text{HF}}\); in Eq. (4). HF KINETIC ENERGY¶; The total kinetic energy [E_h] of the Hartree–Fock method. HF POTENTIAL ENERGY¶; The total potential energy [E_h] of the Hartree–Fock method. HF VIRIAL RATIO¶; The virial ratio of the Hartree–Fock method. Only defined for a fully quantum mechanical computation, i.e., not QM/MM. HF TOTAL GRADIENT¶; The total electronic gradient [E_h/a0] of the Hartree–Fock method, ({nat}, 3). HF DIPOLE GRADIENT¶; The derivative of the Hartree",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/glossary_psivariables.html:31793,energy,energy,31793,psi4manual/1.7.x/glossary_psivariables.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/glossary_psivariables.html,4,['energy'],['energy']
Energy Efficiency,"] = 0.0; else:; ERGT[rgt] = func(molecule=molecule, **kwargs); core.print_variables(); exec(actives); for envv in db_tabulate:; VRGT[rgt][envv.upper()] = core.variable(envv); core.set_global_option(""REFERENCE"", user_reference); core.clean(); #core.opt_clean(); core.clean_variables(). elif db_mode == 'sow':; with open('%s.in' % (rgt), 'w') as freagent:; freagent.write('# This is a psi4 input file auto-generated from the database() wrapper.\n\n'); freagent.write(banners); freagent.write(p4util.format_molecule_for_input(GEOS[rgt], 'dbmol')). freagent.write(commands); freagent.write('''\npickle_kw = (""""""'''); pickle.dump(kwargs, freagent); freagent.write('''"""""")\n'''); freagent.write(""""""\nkwargs = pickle.loads(pickle_kw)\n""""""); freagent.write(""""""electronic_energy = %s(**kwargs)\n\n"""""" % (func.__name__)); freagent.write(""""""core.print_variables()\n""""""); freagent.write(""""""core.print_out('\\nDATABASE RESULT: computation %d for reagent %s """"""; % (os.getpid(), rgt)); freagent.write(""""""yields electronic energy %20.12f\\n' % (electronic_energy))\n\n""""""); freagent.write(""""""core.set_variable('NATOM', dbmol.natom())\n""""""); for envv in db_tabulate:; freagent.write(""""""core.print_out('DATABASE RESULT: computation %d for reagent %s """"""; % (os.getpid(), rgt)); freagent.write(""""""yields variable value %20.12f for variable %s\\n' % (core.variable(""""""); freagent.write(""""""'%s'), '%s'))\n"""""" % (envv.upper(), envv.upper())). elif db_mode == 'reap':; ERGT[rgt] = 0.0; for envv in db_tabulate:; VRGT[rgt][envv.upper()] = 0.0; exec(banners); exec(actives); try:; freagent = open('%s.out' % (rgt), 'r'); except IOError:; core.print_out('Warning: Output file \'%s.out\' not found.\n' % (rgt)); core.print_out(' Database summary will have 0.0 and **** in its place.\n'); else:; while 1:; line = freagent.readline(); if not line:; if ERGT[rgt] == 0.0:; core.print_out('Warning: Output file \'%s.out\' has no DATABASE RESULT line.\n' % (rgt)); core.print_out(' Database summary will have 0.0 and **** in its pla",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/wrapper_database.html:22341,energy,energy,22341,psi4manual/1.3.2/_modules/psi4/driver/wrapper_database.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/wrapper_database.html,1,['energy'],['energy']
Energy Efficiency,"] = 0.0; for envv in db_tabulate:; VRGT[rgt][envv.upper()] = 0.0; exec(banners); exec(actives); try:; freagent = open('%s.out' % (rgt), 'r'); except IOError:; PsiMod.print_out('Warning: Output file \'%s.out\' not found.\n' % (rgt)); PsiMod.print_out(' Database summary will have 0.0 and **** in its place.\n'); else:; while 1:; line = freagent.readline(); if not line:; if ERGT[rgt] == 0.0:; PsiMod.print_out('Warning: Output file \'%s.out\' has no DATABASE RESULT line.\n' % (rgt)); PsiMod.print_out(' Database summary will have 0.0 and **** in its place.\n'); break; s = line.split(); if (len(s) != 0) and (s[0:3] == ['DATABASE', 'RESULT:', 'computation']):; if int(s[3]) != db_linkage:; raise ValidationError('Output file \'%s.out\' has linkage %s incompatible with master.in linkage %s.'; % (rgt, str(s[3]), str(db_linkage))); if s[6] != rgt:; raise ValidationError('Output file \'%s.out\' has nominal affiliation %s incompatible with reagent %s.'; % (rgt, s[6], rgt)); if (s[8:10] == ['electronic', 'energy']):; ERGT[rgt] = float(s[10]); PsiMod.print_out('DATABASE RESULT: electronic energy = %20.12f\n' % (ERGT[rgt])); elif (s[8:10] == ['variable', 'value']):; for envv in db_tabulate:; envv = envv.upper(); if (s[13:] == envv.split()):; VRGT[rgt][envv] = float(s[10]); PsiMod.print_out('DATABASE RESULT: variable %s value = %20.12f\n' % (envv, VRGT[rgt][envv])); freagent.close(). # end sow after writing files; if (db_mode.lower() == 'sow'):; return 0.0. # Reap all the necessary reaction computations; PsiMod.print_out(""\n""); banner((""Database %s Results"" % (db_name))); PsiMod.print_out(""\n""). maxactv = []; for rxn in HRXN:; maxactv.append(len(ACTV[dbse + '-' + str(rxn)])); maxrgt = max(maxactv); table_delimit = '-' * (54 + 20 * maxrgt); tables = ''. # find any reactions that are incomplete; FAIL = defaultdict(int); for rxn in HRXN:; db_rxn = dbse + '-' + str(rxn); for i in range(len(ACTV[db_rxn])):; if abs(ERGT[ACTV[db_rxn][i]]) < 1.0e-12:; FAIL[rxn] = 1. # tabulate requested proce",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/_modules/wrappers.html:46035,energy,energy,46035,psi4manual/4.0b3/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/_modules/wrappers.html,4,['energy'],['energy']
Energy Efficiency,"] = energy; func = kwargs['cbs_func']; if not func:; raise ValidationError('Function \'%s\' does not exist to be called by wrapper complete_basis_set.' % (func.__name__)); if not(func is energy):; raise ValidationError('Wrapper complete_basis_set is unhappy to be calling function \'%s\' instead of \'energy\'.' % (func.__name__)). # Define some quantum chemical knowledge, namely what methods are subsumed in others; VARH = {}; VARH['scf'] = { 'scftot': 'SCF TOTAL ENERGY'}; VARH['oldmp2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'oldmp2corl': 'MP2 CORRELATION ENERGY'}; VARH['mp2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY'}; VARH['mp2.5'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY'}; VARH['mp3'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY'}; VARH['mp4(sdq)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY'}; VARH['mp4'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY',; 'mp4corl': 'MP4(SDTQ) CORRELATION ENERGY'}; VARH['omp2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'omp2corl': 'OMP2 CORRELATION ENERGY'}; VARH['omp3'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'omp3corl': 'OMP3 CORRELATION ENERGY'}; VARH['ocepa'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ocepacorl': 'OCEPA(0) CORRELATION ENERGY'}; VARH['cepa0'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa0corl': 'CEPA(0) CORRELATION",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:64803,ENERGY,ENERGY,64803,psi4manual/4.0b5/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html,4,['ENERGY'],['ENERGY']
Energy Efficiency,"] = nocp_by_level[nb]; continue. for k in range(1, nb + 1):; take_nk = math.comb(metadata['nfragments'] - k - 1, nb - k); sign = ((-1)**(nb - k)); nocp_body_dict[nb] += take_nk * sign * nocp_by_level[k]. if ptype == ""energy"":; if not metadata[""quiet""]:; _print_nbody_energy(nocp_body_dict, ""Non-Counterpoise Corrected (NoCP)"", metadata[""nfragments""], metadata['embedding_charges']). nbody_dict['NOCP-CORRECTED TOTAL ENERGY'] = nocp_body_dict[metadata['max_nbody']]; nbody_dict['NOCP-CORRECTED INTERACTION ENERGY'] = nocp_body_dict[metadata['max_nbody']] - nocp_body_dict[1]. for nb in nbodies[1:]:; nbody_dict[f""NOCP-CORRECTED INTERACTION ENERGY THROUGH {nb}-BODY""] = nocp_body_dict[nb] - nocp_body_dict[1]; nbody_dict[f""NOCP-CORRECTED {nb}-BODY CONTRIBUTION TO ENERGY""] = nocp_body_dict[nb] - nocp_body_dict[nb-1]; for nb in nbodies:; nbody_dict[f""NOCP-CORRECTED TOTAL ENERGY THROUGH {nb}-BODY""] = nocp_body_dict[nb]. # Compute vmfc; if 'vmfc' in metadata['bsse_type']:; for nb in nbodies:; if ptype == ""energy"":; for k in range(1, nb + 1):; vmfc_body_dict[nb] += vmfc_by_level[k]. else:; if nb > 1:; vmfc_body_dict[nb] = vmfc_by_level[nb - 1]; vmfc_body_dict[nb] += vmfc_by_level[nb]. if ptype == ""energy"":; if not metadata[""quiet""]:; _print_nbody_energy(vmfc_body_dict, ""Valiron-Mayer Function Counterpoise (VMFC)"", metadata[""nfragments""], metadata['embedding_charges']). vmfc_interaction_energy = vmfc_body_dict[metadata['max_nbody']] - vmfc_body_dict[1]; nbody_dict['VMFC-CORRECTED TOTAL ENERGY'] = vmfc_body_dict[metadata['max_nbody']]; nbody_dict['VMFC-CORRECTED INTERACTION ENERGY'] = vmfc_interaction_energy. for nb in nbodies[1:]:; nbody_dict[f""VMFC-CORRECTED INTERACTION ENERGY THROUGH {nb}-BODY""] = vmfc_body_dict[nb] - vmfc_body_dict[1]; nbody_dict[f""VMFC-CORRECTED {nb}-BODY CONTRIBUTION TO ENERGY""] = vmfc_body_dict[nb] - vmfc_body_dict[nb-1]; for nb in nbodies:; nbody_dict[f""VMFC-CORRECTED TOTAL ENERGY THROUGH {nb}-BODY""] = vmfc_body_dict[nb]. # Collect specific and generalized ret",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver_nbody.html:28869,energy,energy,28869,psi4manual/1.6.x/_modules/psi4/driver/driver_nbody.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver_nbody.html,10,['energy'],['energy']
Energy Efficiency,"] = {; 'hf': 'HF TOTAL ENERGY',; 'mp2': 'MP2 TOTAL ENERGY',; 'mrccsdt': 'CCSDT TOTAL ENERGY'}; VARH['mrccsdt(q)'] = {; 'hf': 'HF TOTAL ENERGY',; 'mp2': 'MP2 TOTAL ENERGY',; 'mrccsdt': 'CCSDT TOTAL ENERGY',; 'mrccsdt(q)': 'CCSDT(Q) TOTAL ENERGY'}. for cilevel in range(2, 99):; VARH['ci%s' % (str(cilevel))] = {; 'hf': 'HF TOTAL ENERGY',; 'ci%s' % (str(cilevel)): 'CI TOTAL ENERGY'}. for mplevel in range(5, 99):; VARH['mp%s' % (str(mplevel))] = {; 'hf': 'HF TOTAL ENERGY',; 'mp%s' % (str(mplevel)): 'MP%s TOTAL ENERGY' % (str(mplevel))}; for mplevel2 in range(2, mplevel):; VARH['mp%s' % (str(mplevel))]['mp%s' % (str(mplevel2))] = \; 'MP%s TOTAL ENERGY' % (str(mplevel2)). # Integrate CFOUR methods; VARH.update(cfour_psivar_list()); return VARH; # yapf: enable. VARH = return_energy_components(). [docs]def _get_default_xtpl(nbasis, xtpl_type):; """""" A helper function to determine default extrapolation type. Parameters; ----------; nbasis : int; Number of basis sets; xtpl_type : {'scf', 'corl'}; Extrapolation type: 'scf' for the total energy, 'corl' for just the; correlation component. Returns; -------; function; Extrapolation function to be used.; """""". if nbasis == 1 and xtpl_type in [""scf"", ""corl""]:; return xtpl_highest_1; elif xtpl_type == ""scf"":; if nbasis == 2:; return scf_xtpl_helgaker_2; elif nbasis == 3:; return scf_xtpl_helgaker_3; else:; raise ValidationError(""Wrong number of basis sets supplied to scf_xtpl: %d"" % nbasis); elif xtpl_type == ""corl"":; if nbasis == 2:; return corl_xtpl_helgaker_2; else:; raise ValidationError(""Wrong number of basis sets supplied to corl_xtpl: %d"" % nbasis); else:; raise ValidationError(""Stage treatment must be 'corl' or 'scf', not '%s'"" % xtpl_type). def _validate_cbs_inputs(cbs_metadata, molecule):; """""" A helper function which validates the ``cbs_metadata`` format,; expands basis sets, and provides sensible defaults for optional arguments. Parameters; ----------; cbs_metadata : list; List of dicts containing CBS stage keywords.; molecul",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver_cbs.html:28164,energy,energy,28164,psi4manual/1.3.2/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver_cbs.html,1,['energy'],['energy']
Energy Efficiency,"] = {; 'hf': 'HF TOTAL ENERGY',; 'mp2': 'MP2 TOTAL ENERGY'}; VARH['dlpno-mp2'] = {; 'hf': 'HF TOTAL ENERGY',; 'dlpno-mp2': 'MP2 TOTAL ENERGY'}; VARH['mp2d'] = {; 'hf': 'HF TOTAL ENERGY',; 'mp2d': 'MP2D TOTAL ENERGY'}; VARH['mp2.5'] = {; 'hf': 'HF TOTAL ENERGY',; 'mp2': 'MP2 TOTAL ENERGY',; 'mp2.5': 'MP2.5 TOTAL ENERGY',; 'mp3': 'MP3 TOTAL ENERGY'}; VARH['mp3'] = {; 'hf': 'HF TOTAL ENERGY',; 'mp2': 'MP2 TOTAL ENERGY',; 'mp2.5': 'MP2.5 TOTAL ENERGY',; 'mp3': 'MP3 TOTAL ENERGY'}; VARH['mp4(sdq)'] = {; 'hf': 'HF TOTAL ENERGY',; 'mp2': 'MP2 TOTAL ENERGY',; 'mp2.5': 'MP2.5 TOTAL ENERGY',; 'mp3': 'MP3 TOTAL ENERGY',; 'mp4(sdq)': 'MP4(SDQ) TOTAL ENERGY'}; VARH['mp4'] = {; 'hf': 'HF TOTAL ENERGY',; 'mp2': 'MP2 TOTAL ENERGY',; 'mp2.5': 'MP2.5 TOTAL ENERGY',; 'mp3': 'MP3 TOTAL ENERGY',; 'mp4(sdq)': 'MP4(SDQ) TOTAL ENERGY',; 'mp4': 'MP4 TOTAL ENERGY'}; VARH['omp2'] = {; 'hf': 'HF TOTAL ENERGY',; 'mp2': 'MP2 TOTAL ENERGY',; 'omp2': 'OMP2 TOTAL ENERGY'}; VARH['omp2.5'] = {; 'hf': 'HF TOTAL ENERGY',; 'mp2': 'MP2 TOTAL ENERGY',; 'mp2.5': 'MP2.5 TOTAL ENERGY',; 'omp2.5': 'OMP2.5 TOTAL ENERGY'}; VARH['omp3'] = {; 'hf': 'HF TOTAL ENERGY',; 'mp2': 'MP2 TOTAL ENERGY',; 'mp3': 'MP3 TOTAL ENERGY',; 'omp3': 'OMP3 TOTAL ENERGY'}; VARH['olccd'] = {; 'hf': 'HF TOTAL ENERGY',; 'mp2': 'MP2 TOTAL ENERGY',; 'olccd': 'OLCCD TOTAL ENERGY'}; VARH['lccd'] = {; 'hf': 'HF TOTAL ENERGY',; 'mp2': 'MP2 TOTAL ENERGY',; 'lccd': 'LCCD TOTAL ENERGY'}; VARH['lccsd'] = {; 'hf': 'HF TOTAL ENERGY',; 'mp2': 'MP2 TOTAL ENERGY',; 'lccsd': 'LCCSD TOTAL ENERGY'}; VARH['cepa(0)'] = {; 'hf': 'HF TOTAL ENERGY',; 'mp2': 'MP2 TOTAL ENERGY',; 'cepa(0)': 'CEPA(0) TOTAL ENERGY'}; VARH['cepa(1)'] = {; 'hf': 'HF TOTAL ENERGY',; 'mp2': 'MP2 TOTAL ENERGY',; 'cepa(1)': 'CEPA(1) TOTAL ENERGY'}; VARH['cepa(3)'] = {; 'hf': 'HF TOTAL ENERGY',; 'mp2': 'MP2 TOTAL ENERGY',; 'cepa(3)': 'CEPA(3) TOTAL ENERGY'}; VARH['acpf'] = {; 'hf': 'HF TOTAL ENERGY',; 'mp2': 'MP2 TOTAL ENERGY',; 'acpf': 'ACPF TOTAL ENERGY'}; VARH['aqcc'] = {; 'hf': 'HF ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/_modules/psi4/driver/driver_cbs.html:24548,ENERGY,ENERGY,24548,psi4manual/1.5.0/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/_modules/psi4/driver/driver_cbs.html,4,['ENERGY'],['ENERGY']
Energy Efficiency,"] = {; 'hf': 'HF TOTAL ENERGY',; 'mp2': 'MP2 TOTAL ENERGY'}; VARH['dlpno-mp2'] = {; 'hf': 'HF TOTAL ENERGY',; 'dlpno-mp2': 'MP2 TOTAL ENERGY'}; VARH['mp2d'] = {; 'hf': 'HF TOTAL ENERGY',; 'mp2d': 'MP2D TOTAL ENERGY'}; VARH['mp2.5'] = {; 'hf': 'HF TOTAL ENERGY',; 'mp2': 'MP2 TOTAL ENERGY',; 'mp2.5': 'MP2.5 TOTAL ENERGY',; 'mp3': 'MP3 TOTAL ENERGY'}; VARH['mp3'] = {; 'hf': 'HF TOTAL ENERGY',; 'mp2': 'MP2 TOTAL ENERGY',; 'mp2.5': 'MP2.5 TOTAL ENERGY',; 'mp3': 'MP3 TOTAL ENERGY'}; VARH['mp4(sdq)'] = {; 'hf': 'HF TOTAL ENERGY',; 'mp2': 'MP2 TOTAL ENERGY',; 'mp2.5': 'MP2.5 TOTAL ENERGY',; 'mp3': 'MP3 TOTAL ENERGY',; 'mp4(sdq)': 'MP4(SDQ) TOTAL ENERGY'}; VARH['mp4'] = {; 'hf': 'HF TOTAL ENERGY',; 'mp2': 'MP2 TOTAL ENERGY',; 'mp2.5': 'MP2.5 TOTAL ENERGY',; 'mp3': 'MP3 TOTAL ENERGY',; 'mp4(sdq)': 'MP4(SDQ) TOTAL ENERGY',; 'mp4': 'MP4 TOTAL ENERGY'}; VARH['omp2'] = {; 'hf': 'HF TOTAL ENERGY',; 'mp2': 'MP2 TOTAL ENERGY',; 'omp2': 'OMP2 TOTAL ENERGY'}; VARH['omp2.5'] = {; 'hf': 'HF TOTAL ENERGY',; 'mp2': 'MP2 TOTAL ENERGY',; 'mp2.5': 'MP2.5 TOTAL ENERGY',; 'omp2.5': 'OMP2.5 TOTAL ENERGY'}; VARH['omp3'] = {; 'hf': 'HF TOTAL ENERGY',; 'mp2': 'MP2 TOTAL ENERGY',; 'mp3': 'MP3 TOTAL ENERGY',; 'omp3': 'OMP3 TOTAL ENERGY'}; VARH['olccd'] = {; 'hf': 'HF TOTAL ENERGY',; 'mp2': 'MP2 TOTAL ENERGY',; 'olccd': 'OLCCD TOTAL ENERGY'}; VARH['oremp2'] = {; 'hf': 'HF TOTAL ENERGY',; 'mp2': 'MP2 TOTAL ENERGY',; 'oremp2': 'OREMP2 TOTAL ENERGY'}; VARH['lccd'] = {; 'hf': 'HF TOTAL ENERGY',; 'mp2': 'MP2 TOTAL ENERGY',; 'lccd': 'LCCD TOTAL ENERGY'}; VARH['remp2'] = {; 'hf': 'HF TOTAL ENERGY',; 'mp2': 'MP2 TOTAL ENERGY',; 'remp2': 'REMP2 TOTAL ENERGY'}; VARH['lccsd'] = {; 'hf': 'HF TOTAL ENERGY',; 'mp2': 'MP2 TOTAL ENERGY',; 'lccsd': 'LCCSD TOTAL ENERGY'}; VARH['cepa(0)'] = {; 'hf': 'HF TOTAL ENERGY',; 'mp2': 'MP2 TOTAL ENERGY',; 'cepa(0)': 'CEPA(0) TOTAL ENERGY'}; VARH['cepa(1)'] = {; 'hf': 'HF TOTAL ENERGY',; 'mp2': 'MP2 TOTAL ENERGY',; 'cepa(1)': 'CEPA(1) TOTAL ENERGY'}; VARH['cepa(3)'] = {; 'hf': '",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver_cbs.html:12249,ENERGY,ENERGY,12249,psi4manual/1.7.x/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver_cbs.html,8,['ENERGY'],['ENERGY']
Energy Efficiency,"] Analytic hf optimization; >>> optimize('hf'). 1; 2; 3; 4>>> # [2] Finite difference mp5 optimization with gradient; >>> # printed to output file; >>> e, wfn = opt('mp5', return_wfn='yes'); >>> wfn.gradient().print_out(). 1; 2; 3>>> # [3] Forced finite difference hf optimization run in; >>> # embarrassingly parallel fashion; >>> optimize('hf', dertype='energy', mode='sow'). 1; 2>>> # [4] Can automatically perform complete basis set extrapolations; >>> optimize('MP2/cc-pV([D,T]+d)Z'). 1; 2; 3; 4>>> # [5] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> optimize(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). 1; 2; 3; 4; 5; 6; 7; 8>>> # [6] Get info like geometry, gradient, energy back after an; >>> # optimization fails. Note that the energy and gradient; >>> # correspond to the last optimization cycle, whereas the; >>> # geometry (by default) is the anticipated *next* optimization step.; >>> try:; >>> optimize('hf/cc-pvtz'); >>> except psi4.OptimizationConvergenceError as ex:; >>> next_geom_coords_as_numpy_array = np.asarray(ex.wfn.molecule().geometry()). psi4.gradient(name[, molecule, return_wfn, func, dertype])[source]¶; Function complementary to :py:func:~driver.optimize(). Carries out one gradient pass,; deciding analytic or finite difference. Returns:Matrix – Total electronic gradient in Hartrees/Bohr. Returns:(Matrix, Wavefunction) – gradient and wavefunction when return_wfn specified. Examples:. 1; 2; 3; 4; 5; 6>>> # [1] Single-point dft gradient getting the gradient; >>> # in file, core.Matrix, and np.array forms; >>> set gradient_write on; >>> G, wfn = gradient('b3lyp-d', return_wfn=True); >>> wfn.gradient().print_out(); >>> np.array(G). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Psithon Functions: Invoking a Calcu",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/opt-1.html:5186,energy,energy,5186,psi4manual/1.2.1/opt-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/opt-1.html,2,['energy'],['energy']
Energy Efficiency,"] Frequency calculation for b2 modes through finite difference of gradients; >>> frequencies('scf', dertype=1, irrep=4). """"""; lowername = name.lower(); kwargs = kwargs_lower(kwargs); dertype = 2. optstash = OptionsState(; ['SCF', 'E_CONVERGENCE'],; ['SCF', 'D_CONVERGENCE'],; ['E_CONVERGENCE']). # Order of precedence:; # 1. Default for wavefunction; # 2. Value obtained from kwargs, if user changed it; # 3. If user provides a custom 'func' use that. # Allow specification of methods to arbitrary order; lowername, level = parse_arbitrary_order(lowername); if level:; kwargs['level'] = level. # 1. set the default to that of the provided name; if lowername in procedures['hessian']:; dertype = 2; elif lowername in procedures['gradient']:; dertype = 1; func = gradient; elif lowername in procedures['energy']:; dertype = 0; func = energy. # 2. Check if the user passes dertype into this function; if 'dertype' in kwargs:; freq_dertype = kwargs['dertype']. if der0th.match(str(freq_dertype)):; dertype = 0; func = energy; elif der1st.match(str(freq_dertype)):; dertype = 1; func = gradient; elif der2nd.match(str(freq_dertype)):; dertype = 2; else:; raise ValidationError('Requested derivative level \'dertype\' %s not valid for helper function frequency.' % (freq_dertype)). # 3. if the user provides a custom function THAT takes precedence; if ('freq_func' in kwargs) or ('func' in kwargs):; if ('func' in kwargs):; kwargs['freq_func'] = kwargs['func']; del kwargs['func']; dertype = 0; func = kwargs['freq_func']. # Summary validation; if (dertype == 2) and (lowername in procedures['hessian']):; pass; elif (dertype == 1) and (func is gradient) and (lowername in procedures['gradient']):; pass; elif (dertype == 1) and not(func is gradient):; pass; elif (dertype == 0) and (func is energy) and (lowername in procedures['energy']):; pass; elif (dertype == 0) and not(func is energy):; pass; else:; raise ValidationError('Requested method \'name\' %s and derivative level \'dertype\' %s are not avai",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/_modules/driver.html:60308,energy,energy,60308,psi4manual/4.0b4/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/driver.html,2,['energy'],['energy']
Energy Efficiency,"] and correlation energy component [H]; for the orbital-optimized MP3 level of theory. ONE-ELECTRON ENERGY¶; The one-electron energy contribution [H] to the total SCF energy.; Quantity in Eq. (4). QCISD TOTAL ENERGY¶. QCISD CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the quadratic configuration interaction singles and doubles level; of theory. QCISD(T) TOTAL ENERGY¶. QCISD(T) CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the quadratic configuration interaction singles and doubles with; perturbative triples correction level of theory. SAPT DISP ENERGY¶. SAPT ELST ENERGY¶. SAPT EXCH ENERGY¶. SAPT IND ENERGY¶; Respectively, the dispersion, electrostatics, exchange, and induction; components of the total electronic interaction energy [H] for the the; requested SAPT level of theory. The sum of these four components yields; SAPT TOTAL ENERGY. SAPT TOTAL ENERGY¶; The total electronic interaction energy [H] for the requested SAPT; level of theory. SAPT0 TOTAL ENERGY¶. SSAPT0 TOTAL ENERGY¶. SAPT2 TOTAL ENERGY¶. SAPT2+ TOTAL ENERGY¶. SAPT2+(3) TOTAL ENERGY¶. SAPT2+3 TOTAL ENERGY¶; The total electronic interaction energy [H] for the labeled SAPT level; of theory. SAPT2+(CCD) TOTAL ENERGY¶. SAPT2+(3)(CCD) TOTAL ENERGY¶. SAPT2+3(CCD) TOTAL ENERGY¶; The total electronic interaction energy [H] for the labeled SAPT level; of theory that incorporates coupled-cluster dispersion. SAPT2+DMP2 TOTAL ENERGY¶. SAPT2+(3)DMP2 TOTAL ENERGY¶. SAPT2+3DMP2 TOTAL ENERGY¶. SAPT2+(CCD)DMP2 TOTAL ENERGY¶. SAPT2+(3)(CCD)DMP2 TOTAL ENERGY¶. SAPT2+3(CCD)DMP2 TOTAL ENERGY¶; The total electronic interaction energy [H] for the labeled SAPT level; of theory that incorporates MP2 induction correction. SCF DIPOLE X¶. SCF DIPOLE Y¶. SCF DIPOLE Z¶; The three components of the SCF dipole [Debye]. SCF QUADRUPOLE XX¶. SCF QUADRUPOLE XY¶. SCF QUADRUPOLE XZ¶. SCF QUADRUPOLE YY¶. SCF QUADRUPOLE YZ¶. SCF QUADRUPOLE ZZ¶;",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/glossary_psivariables-1.html:14728,energy,energy,14728,psi4manual/1.0.0/glossary_psivariables-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/glossary_psivariables-1.html,2,['energy'],['energy']
Energy Efficiency,"] documentation. Navigation. index. modules |. next |. previous |; PSI4 [beta2] » ; Customization: Adding Simple Extensions ». Note; No recompile of the PSI program is necessary for changes made to; files in $PSIDATADIR, including those described below. Creating a Database¶; A necessary consideration in constructing a database is the distinction; between reagents and reactions. A reagent is a single molecular system; (may be a dimer) whose geometry you are possession of and whose electronic; energy may be of interest. A reaction is a combination of one or more; reagent energies whose value you are interested in and a reference value; for which you may or may not be in possession of. A few examples follow.; In a database of interaction energies, the reagents are dimers and their; component monomers (usually derived from the dimer geometry), and the; reactions are the dimer less monomers energies. In a database of barrier; heights, the reagents are reactants, products, and transition-state; structures, and the reactions are the transition-states less; minimum-energy structures. Possibly you may have a collection of; structures to simply be acted upon in parallel, in which case the; structures are both the reagents and the reactions. The role of the; database.py file is to collect arrays and dictionaries that define the; geometries of reagents (GEOS), their combination into reactions (RXNM &; ACTV), available reference values for reactions (BIND), and brief comments; for reagents and reactions (TAGL). The journey from reagent geometries to; functional database.py file is largely automated, in a process described; below. Prepare geometry files; Assemble xyz files for all intended reagent systems in a directory.; Follow the rules below for best results. The filename for each xyz; file should be the name of the system. lowercase or MixedCase is; preferable (according to Sherrill lab convention). Avoid dashes and; dots in the name as python won’t allow them. If you’re dete",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/quickadddatabase-1.html:1110,energy,energy,1110,psi4manual/4.0b2/quickadddatabase-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/quickadddatabase-1.html,2,['energy'],['energy']
Energy Efficiency,] uncertainty=0.000 000 024 e-25. inverse_meter_kelvin_relationship; 0.0143877736; inverse meter-kelvin relationship [K] uncertainty=0.000 000 83 e-2. inverse_meter_kilogram_relationship; 2.210219057E-42; inverse meter-kilogram relationship [kg] uncertainty=0.000 000 027 e-42. inverse_of_conductance_quantum; 12906.4037278; inverse of conductance quantum [ohm] uncertainty=0.000 0029. Josephson_constant; 4.835978525E+14; Josephson constant [Hz V^{-1}] uncertainty=0.0030 e9. joule_atomic_mass_unit_relationship; 6700535363; joule-atomic mass unit relationship [u] uncertainty=0.000 000 082 e9. joule_electron_volt_relationship; 6.241509126E+18; joule-electron volt relationship [eV] uncertainty=0.000 000 038 e18. joule_hartree_relationship; 2.293712317E+17; joule-hartree relationship [E_h] uncertainty=0.000 000 028 e17. joule_hertz_relationship; 1.509190205E+33; joule-hertz relationship [Hz] uncertainty=0.000 000 019 e33. joule_inverse_meter_relationship; 5.034116651E+24; joule-inverse meter relationship [m^{-1}] uncertainty=0.000 000 062 e24. joule_kelvin_relationship; 7.2429731E+22; joule-kelvin relationship [K] uncertainty=0.000 0042 e22. joule_kilogram_relationship; 1.112650056E-17; joule-kilogram relationship [kg] uncertainty=(exact). kelvin_atomic_mass_unit_relationship; 9.2510842E-14; kelvin-atomic mass unit relationship [u] uncertainty=0.000 0053 e-14. kelvin_electron_volt_relationship; 0.000086173303; kelvin-electron volt relationship [eV] uncertainty=0.000 0050 e-5. kelvin_hartree_relationship; 0.0000031668105; kelvin-hartree relationship [E_h] uncertainty=0.000 0018 e-6. kelvin_hertz_relationship; 2.0836612E+10; kelvin-hertz relationship [Hz] uncertainty=0.000 0012 e10. kelvin_inverse_meter_relationship; 69.503457; kelvin-inverse meter relationship [m^{-1}] uncertainty=0.000 040. kelvin_joule_relationship; 1.38064852E-23; kelvin-joule relationship [J] uncertainty=0.000 000 79 e-23. kelvin_kilogram_relationship; 1.53617865E-40; kelvin-kilogram relationship [kg] un,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/autodoc_physconst-1.html:18334,joule,joule-inverse,18334,psi4manual/1.3.2/autodoc_physconst-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/autodoc_physconst-1.html,22,"['joule', 'meter']","['joule-inverse', 'meter']"
Energy Efficiency,"] » ; Interfaces: Enhancing Psi4 Capabilities ». Interface to CFOUR by J. Stanton and J. Gauss¶; Code author: Lori A. Burns; Section author: Lori A. Burns; Module: Keywords, PSI Variables, Samples; Psi4 contains code to interface to the Cfour quantum chemistry suite of; John F. Stanton (U. Texas, Austin) and Jürgen Gauss (U. Mainz),; which is available after a license agreement from; http://www.cfour.de/. Installation¶; Follow the instructions provided with the Cfour download to install the; executable or to build the source. To by used by Psi4, the program; binary (xcfour) must be found in your PATH or; PSIPATH. The GENBAS file containing basis sets in Cfour; format is not necessary for this interface, but if you prefer to access; basis sets the “Cfour way” using a custom GENBAS file (the distributed; one is included with the interface), it, too, must be in PATH or; PSIPATH. If Psi4 is unable to execute the binary, an error; will be reported. Caution; The p4c4 interface hasn’t been fully adapted for the new March 2014 version. Cfour for Psi4 Users¶. Set memory as usual; Set molecule as usual; Set basis set as usual (Cfour only cares about orbital basis, no fitting; bases); Set the task as usual, indicating Cfour as the intended code by; prepending “c4-” to the method argument. So energy('scf') becomes; energy('c4-scf') and optimize('ccsd(t)') becomes; optimize('c4-ccsd(t)'). Find available methods for; energy() at Energy (CFOUR); and for optimize() at Gradient (CFOUR).; Generally, the p4c4 interface will handle best practices for path of; execution: vcc/ecc, derivative type, etc. The user is still; responsible for setting convergence, frozen core, guess, diis, etc.; For the moment, so-called “best-practices” keywords are summarized at; Best Practices.; For the type of computation intended, find appropriate options at; Keywords. These keyword summaries contain the same; information as the proper CFOUR options list; plus notes on keyword relevance when run through Ps",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/cfour-1.html:1166,adapt,adapted,1166,psi4manual/1.0.0/cfour-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/cfour-1.html,2,['adapt'],['adapted']
Energy Efficiency,"]). occs.append(occ); energies.append(E); convs.append(C). PsiMod.set_global_option(""FRAC_START"", 2); PsiMod.set_global_option(""FRAC_LOAD"", True); PsiMod.set_global_option(""GUESS"", ""READ""); PsiMod.set_global_option(""FRAC_DIIS"", frac_diis); PsiMod.set_global_option(""DF_INTS_IO"", ""LOAD""). # => Run the neutral next <= #. mol.set_molecular_charge(charge0); mol.set_multiplicity(mult0). # Burn the neutral in with hf, if requested <= #. if (not continuous_guess):; PsiMod.set_global_option(""GUESS"", old_guess); if (hf_guess):; PsiMod.set_global_option(""FRAC_START"", 0); PsiMod.set_global_option(""REFERENCE"",""UHF""); energy('scf'); PsiMod.set_global_option(""REFERENCE"",""UKS""); PsiMod.set_global_option(""GUESS"", ""READ""); PsiMod.set_global_option(""FRAC_LOAD"", False). PsiMod.set_global_option(""FRAC_START"", frac_start); PsiMod.set_global_option(""FRAC_RENORMALIZE"", True). for occ in HOMO_occs:; ; PsiMod.set_global_option(""FRAC_OCC"", [HOMO]); PsiMod.set_global_option(""FRAC_VAL"", [occ]) . E = energy('scf'); C = 1; if (E == 0.0):; E = PsiMod.get_variable('SCF ITERATION ENERGY'); C = 0. if (LUMO > 0):; ref = PsiMod.reference_wavefunction(); eps = ref.epsilon_a(); potentials.append(eps[int(HOMO)-1]); else:; ref = PsiMod.reference_wavefunction(); eps = ref.epsilon_b(); potentials.append(eps[-int(HOMO)-1]). occs.append(occ - 1.0); energies.append(E); convs.append(C). PsiMod.set_global_option(""FRAC_START"", 2); PsiMod.set_global_option(""FRAC_LOAD"", True); PsiMod.set_global_option(""GUESS"", ""READ""); PsiMod.set_global_option(""FRAC_DIIS"", frac_diis); PsiMod.set_global_option(""DF_INTS_IO"", ""LOAD""). PsiMod.set_global_option(""DF_INTS_IO"", old_df_ints_io). # => Print the results out <= #; E = {}; PsiMod.print_out('\n ==> Fractional Occupation Traverse Results <==\n\n'); PsiMod.print_out('\t%-11s %-24s %-24s %11s\n' %('N', 'Energy', 'HOMO Energy', 'Converged')); for k in range(len(occs)):; PsiMod.print_out('\t%11.3E %24.16E %24.16E %11d\n' % (occs[k], energies[k], potentials[k], convs[k])); E[occs[k]] =",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/_modules/frac.html:4911,energy,energy,4911,psi4manual/4.0b2/_modules/frac.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/frac.html,4,['energy'],['energy']
Energy Efficiency,"]). occs.append(occ); energies.append(E); convs.append(C). PsiMod.set_global_option(""FRAC_START"", 2); PsiMod.set_global_option(""FRAC_LOAD"", True); PsiMod.set_global_option(""GUESS"", ""READ""); PsiMod.set_global_option(""FRAC_DIIS"", frac_diis); PsiMod.set_global_option(""DF_INTS_IO"", ""LOAD""). # => Run the neutral next <= #. mol.set_molecular_charge(charge0); mol.set_multiplicity(mult0). # Burn the neutral in with hf, if requested <= #. if (not continuous_guess):; PsiMod.set_global_option(""GUESS"", old_guess); if (hf_guess):; PsiMod.set_global_option(""FRAC_START"", 0); PsiMod.set_global_option(""REFERENCE"",""UHF""); energy('scf'); PsiMod.set_global_option(""REFERENCE"",""UKS""); PsiMod.set_global_option(""GUESS"", ""READ""); PsiMod.set_global_option(""FRAC_LOAD"", False). PsiMod.set_global_option(""FRAC_START"", frac_start); PsiMod.set_global_option(""FRAC_RENORMALIZE"", True). for occ in HOMO_occs:; ; PsiMod.set_global_option(""FRAC_OCC"", [HOMO]); PsiMod.set_global_option(""FRAC_VAL"", [occ]) . E = energy('scf'); C = 1; if (E == 0.0):; E = PsiMod.get_variable('SCF ITERATION ENERGY'); C = 0. if (LUMO > 0):; ref = PsiMod.wavefunction(); eps = ref.epsilon_a(); potentials.append(eps[int(HOMO)-1]); else:; ref = PsiMod.wavefunction(); eps = ref.epsilon_b(); potentials.append(eps[-int(HOMO)-1]). occs.append(occ - 1.0); energies.append(E); convs.append(C). PsiMod.set_global_option(""FRAC_START"", 2); PsiMod.set_global_option(""FRAC_LOAD"", True); PsiMod.set_global_option(""GUESS"", ""READ""); PsiMod.set_global_option(""FRAC_DIIS"", frac_diis); PsiMod.set_global_option(""DF_INTS_IO"", ""LOAD""). PsiMod.set_global_option(""DF_INTS_IO"", old_df_ints_io). # => Print the results out <= #; E = {}; PsiMod.print_out('\n ==> Fractional Occupation Traverse Results <==\n\n'); PsiMod.print_out('\t%-11s %-24s %-24s %11s\n' %('N', 'Energy', 'HOMO Energy', 'Converged')); for k in range(len(occs)):; PsiMod.print_out('\t%11.3E %24.16E %24.16E %11d\n' % (occs[k], energies[k], potentials[k], convs[k])); E[occs[k]] = energies[k]. PsiMod",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/_modules/frac.html:4888,energy,energy,4888,psi4manual/4.0b4/_modules/frac.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/frac.html,2,['energy'],['energy']
Energy Efficiency,"], GRAND_NEED[4]['d_scheme'].__name__); tables += """""" %6s %20s %1s %-27s %2s %16.8f %-s\n"""""" % ('total', 'CBS', '', '', '', finalenergy, ''); tables += table_delimit. #print tables; PsiMod.print_out(tables). # Restore molecule and options; #PsiMod.set_local_option('SCF', ""WFN"", user_wfn) # TODO refuses to set global option WFN - rejects SCF as option; PsiMod.set_global_option('BASIS', user_basis). PsiMod.set_global_option('WFN', user_wfn); if not b_user_wfn:; PsiMod.revoke_global_option_changed('WFN'). PsiMod.set_global_option('WRITER_FILE_LABEL', user_writer_file_label). PsiMod.set_variable('CBS REFERENCE ENERGY', GRAND_NEED[0]['d_energy']); PsiMod.set_variable('CBS CORRELATION ENERGY', finalenergy - GRAND_NEED[0]['d_energy']); PsiMod.set_variable('CBS TOTAL ENERGY', finalenergy); PsiMod.set_variable('CURRENT REFERENCE ENERGY', GRAND_NEED[0]['d_energy']); PsiMod.set_variable('CURRENT CORRELATION ENERGY', finalenergy - GRAND_NEED[0]['d_energy']); PsiMod.set_variable('CURRENT ENERGY', finalenergy); return finalenergy. # Transform and validate basis sets from 'cc-pV[Q5]Z' into [cc-pVQZ, cc-pV5Z] and [4, 5]; [docs]def validate_bracketed_basis(basisstring):; r""""""Function to transform and validate basis sets for cbs(). A basis set with no; paired square brackets is passed through with zeta level 0 (e.g., '6-31+G(d,p)'; is returned as [6-31+G(d,p)] and [0]). A basis set with square brackets is; checked for sensible sequence and Dunning-ness and returned as separate basis; sets (e.g., 'cc-pV[Q5]Z' is returned as [cc-pVQZ, cc-pV5Z] and [4, 5]). Note; that this function has no communication with the basis set library to check; if the basis actually exists. Used by :py:func:`~wrappers.complete_basis_set`. """"""; ZETA = ['d', 't', 'q', '5', '6']; BSET = []; ZSET = []; if re.match(r'.*cc-.*\[.*\].*z$', basisstring, flags=re.IGNORECASE):; basispattern = re.compile(r'^(.*)\[(.*)\](.*)$'); basisname = basispattern.match(basisstring); for b in basisname.group(2):; if b not in ZETA:; ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:79503,ENERGY,ENERGY,79503,psi4manual/4.0b4/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html,1,['ENERGY'],['ENERGY']
Energy Efficiency,"]. # By default, re-guess at each N ; continuous_guess = False; if kwargs.has_key('continuous_guess'):; continuous_guess = kwargs['continuous_guess']. # By default, drop the files to the molecule's name; root = mol.name(); if kwargs.has_key('filename'):; root = kwargs['filename']; traverse_filename = root + '.traverse.dat'; # => Traverse <= #; occs = []; energies = []; potentials = []; convs = []. # => Run the neutral for its orbitals, if requested <= #. old_df_ints_io = PsiMod.get_global_option(""DF_INTS_IO""); PsiMod.set_global_option(""DF_INTS_IO"", ""SAVE""). old_guess = PsiMod.get_global_option(""GUESS""); if (neutral_guess):; if (hf_guess):; PsiMod.set_global_option(""REFERENCE"",""UHF""); energy('scf'); PsiMod.set_global_option(""GUESS"", ""READ""); PsiMod.set_global_option(""DF_INTS_IO"", ""LOAD""). # => Run the anion first <= #. mol.set_molecular_charge(chargem); mol.set_multiplicity(multm); ; # => Burn the anion in with hf, if requested <= #; if (hf_guess):; PsiMod.set_global_option(""REFERENCE"",""UHF""); energy('scf'); PsiMod.set_global_option(""REFERENCE"",""UKS""); PsiMod.set_global_option(""GUESS"", ""READ""); PsiMod.set_global_option(""DF_INTS_IO"", ""SAVE""). PsiMod.set_global_option(""FRAC_START"", frac_start); PsiMod.set_global_option(""FRAC_RENORMALIZE"", True); PsiMod.set_global_option(""FRAC_LOAD"", False). for occ in LUMO_occs:; ; PsiMod.set_global_option(""FRAC_OCC"", [LUMO]); PsiMod.set_global_option(""FRAC_VAL"", [occ]) . E = energy('scf'); C = 1; if (E == 0.0):; E = PsiMod.get_variable('SCF ITERATION ENERGY'); C = 0. if (LUMO > 0):; ref = PsiMod.reference_wavefunction(); eps = ref.epsilon_a(); potentials.append(eps[int(LUMO)-1]); else:; ref = PsiMod.reference_wavefunction(); eps = ref.epsilon_b(); potentials.append(eps[-int(LUMO)-1]). occs.append(occ); energies.append(E); convs.append(C). PsiMod.set_global_option(""FRAC_START"", 2); PsiMod.set_global_option(""FRAC_LOAD"", True); PsiMod.set_global_option(""GUESS"", ""READ""); PsiMod.set_global_option(""FRAC_DIIS"", frac_diis); PsiMod.set_global_",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/_modules/frac.html:3191,energy,energy,3191,psi4manual/4.0b2/_modules/frac.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/frac.html,4,['energy'],['energy']
Energy Efficiency,"]. # By default, re-guess at each N ; continuous_guess = False; if kwargs.has_key('continuous_guess'):; continuous_guess = kwargs['continuous_guess']. # By default, drop the files to the molecule's name; root = mol.name(); if kwargs.has_key('filename'):; root = kwargs['filename']; traverse_filename = root + '.traverse.dat'; # => Traverse <= #; occs = []; energies = []; potentials = []; convs = []. # => Run the neutral for its orbitals, if requested <= #. old_df_ints_io = PsiMod.get_global_option(""DF_INTS_IO""); PsiMod.set_global_option(""DF_INTS_IO"", ""SAVE""). old_guess = PsiMod.get_global_option(""GUESS""); if (neutral_guess):; if (hf_guess):; PsiMod.set_global_option(""REFERENCE"",""UHF""); energy('scf'); PsiMod.set_global_option(""GUESS"", ""READ""); PsiMod.set_global_option(""DF_INTS_IO"", ""LOAD""). # => Run the anion first <= #. mol.set_molecular_charge(chargem); mol.set_multiplicity(multm); ; # => Burn the anion in with hf, if requested <= #; if (hf_guess):; PsiMod.set_global_option(""REFERENCE"",""UHF""); energy('scf'); PsiMod.set_global_option(""REFERENCE"",""UKS""); PsiMod.set_global_option(""GUESS"", ""READ""); PsiMod.set_global_option(""DF_INTS_IO"", ""SAVE""). PsiMod.set_global_option(""FRAC_START"", frac_start); PsiMod.set_global_option(""FRAC_RENORMALIZE"", True); PsiMod.set_global_option(""FRAC_LOAD"", False). for occ in LUMO_occs:; ; PsiMod.set_global_option(""FRAC_OCC"", [LUMO]); PsiMod.set_global_option(""FRAC_VAL"", [occ]) . E = energy('scf'); C = 1; if (E == 0.0):; E = PsiMod.get_variable('SCF ITERATION ENERGY'); C = 0. if (LUMO > 0):; ref = PsiMod.wavefunction(); eps = ref.epsilon_a(); potentials.append(eps[int(LUMO)-1]); else:; ref = PsiMod.wavefunction(); eps = ref.epsilon_b(); potentials.append(eps[-int(LUMO)-1]). occs.append(occ); energies.append(E); convs.append(C). PsiMod.set_global_option(""FRAC_START"", 2); PsiMod.set_global_option(""FRAC_LOAD"", True); PsiMod.set_global_option(""GUESS"", ""READ""); PsiMod.set_global_option(""FRAC_DIIS"", frac_diis); PsiMod.set_global_option(""DF_INTS_IO"",",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/_modules/frac.html:3188,energy,energy,3188,psi4manual/4.0b4/_modules/frac.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/frac.html,2,['energy'],['energy']
Energy Efficiency,"]. # handle atom markers; elif atom.match(line):; entries = re.split(r'\s+|\s*,\s*', line.strip()); atomLabel = entries[0]. # handle ghost atoms; ghostAtom = False; if ghost.match(atomLabel):; # We don't know whether the @C or Gh(C) notation matched. Do a quick check.; atomLabel = ghost.match(atomLabel).group(2) if not ghost.match(atomLabel).group(1) \; else ghost.match(atomLabel).group(1); ghostAtom = True. # Save the actual atom symbol (H1 => H); atomSym = re.split('(\d+)', atomLabel)[0].upper(). # Check that the atom symbol is valid; if not atomSym in el2z:; raise ValidationError('Illegal atom symbol in geometry specification: %s' % (atomSym)). zVal = el2z[atomSym]; charge = float(zVal); if ghostAtom:; zVal = 0; charge = 0.0. # handle cartesians; if len(entries) == 4:; tempfrag.append(iatom); xval = self.get_coord_value(entries[1]); yval = self.get_coord_value(entries[2]); zval = self.get_coord_value(entries[3]); self.full_atoms.append(CartesianEntry(iatom, zVal, charge, \; el2masses[atomSym], atomSym, atomLabel, \; xval, yval, zval)). # handle first line of Zmat; elif len(entries) == 1:; tempfrag.append(iatom); self.full_atoms.append(ZMatrixEntry(iatom, zVal, charge, \; el2masses[atomSym], atomSym, atomLabel)). # handle second line of Zmat; elif len(entries) == 3:; tempfrag.append(iatom). rTo = self.get_anchor_atom(entries[1], line); if rTo >= iatom:; raise ValidationError(""Error on geometry input line %s. Atom %s has not been defined yet.\n"" % (line, entries[1])); rval = self.get_coord_value(entries[2]). if self.full_atoms[rTo].symbol() == 'X':; rval.set_fixed(True). self.full_atoms.append(ZMatrixEntry(iatom, zVal, charge, \; el2masses[atomSym], atomSym, atomLabel, \; self.full_atoms[rTo], rval)). # handle third line of Zmat; elif len(entries) == 5:; tempfrag.append(iatom). rTo = self.get_anchor_atom(entries[1], line); if rTo >= iatom:; raise ValidationError(""Error on geometry input line %s. Atom %s has not been defined yet.\n"" % (line, entries[1])); aTo = self",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/_modules/qcdb/libmintsmolecule.html:17069,charge,charge,17069,psi4manual/4.0b3/_modules/qcdb/libmintsmolecule.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/_modules/qcdb/libmintsmolecule.html,4,['charge'],['charge']
Energy Efficiency,"]. # handle atom markers; elif atom.match(line):; entries = re.split(r'\s+|\s*,\s*', line.strip()); atomLabel = entries[0]. # handle ghost atoms; ghostAtom = False; if ghost.match(atomLabel):; # We don't know whether the @C or Gh(C) notation matched. Do a quick check.; atomLabel = ghost.match(atomLabel).group(2) if not ghost.match(atomLabel).group(1) \; else ghost.match(atomLabel).group(1); ghostAtom = True. # Save the actual atom symbol (H1 => H); atomSym = re.split('(\d+)', atomLabel)[0].upper(). # Check that the atom symbol is valid; if not atomSym in el2z:; raise ValidationError('Illegal atom symbol in geometry specification: %s' % (atomSym)). zVal = el2z[atomSym]; charge = float(zVal); if ghostAtom:; zVal = 0; charge = 0.0. # handle cartesians; if len(entries) == 4:; tempfrag.append(iatom); xval = self.get_coord_value(entries[1]); yval = self.get_coord_value(entries[2]); zval = self.get_coord_value(entries[3]); self.full_atoms.append(CartesianEntry(iatom, zVal, charge, \; el2masses[atomSym], atomSym, atomLabel, \; xval, yval, zval)). # handle first line of Zmat; elif len(entries) == 1:; zmatrix = True; tempfrag.append(iatom); self.full_atoms.append(ZMatrixEntry(iatom, zVal, charge, \; el2masses[atomSym], atomSym, atomLabel)). # handle second line of Zmat; elif len(entries) == 3:; zmatrix = True; tempfrag.append(iatom). rTo = self.get_anchor_atom(entries[1], line); if rTo >= iatom:; raise ValidationError(""Error on geometry input line %s. Atom %s has not been defined yet.\n"" % (line, entries[1])); rval = self.get_coord_value(entries[2]). if self.full_atoms[rTo].symbol() == 'X':; rval.set_fixed(True). self.full_atoms.append(ZMatrixEntry(iatom, zVal, charge, \; el2masses[atomSym], atomSym, atomLabel, \; self.full_atoms[rTo], rval)). # handle third line of Zmat; elif len(entries) == 5:; zmatrix = True; tempfrag.append(iatom). rTo = self.get_anchor_atom(entries[1], line); if rTo >= iatom:; raise ValidationError(""Error on geometry input line %s. Atom %s has not been d",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html:18308,charge,charge,18308,psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html,2,['charge'],['charge']
Energy Efficiency,"]. * convert result to psi4.core.Matrix (non-energy). _cbs_schema_to_wfn(); --------------------; * build wfn from cbs mol and basis (always def2-svp) and module (if present); * push qcvars to P::e and wfn. * return e/g/h and wfn. """""". import copy; import logging; import re; import sys; from typing import TYPE_CHECKING, Any, Callable, Dict, List, Optional, Tuple, Union. import numpy as np. try:; from pydantic.v1 import Field, validator; except ImportError:; from pydantic import Field, validator. from qcelemental.models import AtomicResult, DriverEnum. from psi4 import core. from . import driver_util, p4util, qcdb; from .constants import pp; from .driver_cbs_helper import ( # lgtm[py/unused-import]; composite_procedures,; register_composite_function,; register_xtpl_function,; xtpl_procedures,; ); from .driver_util import UpgradeHelper; from .p4util.exceptions import ValidationError; from .procrouting.interface_cfour import cfour_psivar_list; from .task_base import AtomicComputer, BaseComputer, EnergyGradientHessianWfnReturn. if TYPE_CHECKING:; import qcportal. logger = logging.getLogger(__name__). zeta_values = 'dtq5678'; _zeta_val2sym = {k + 2: v for k, v in enumerate(zeta_values)}; _zeta_sym2val = {v: k for k, v in _zeta_val2sym.items()}; _addlremark = {'energy': '', 'gradient': ', GRADIENT', 'hessian': ', HESSIAN'}; _f_fields = ['f_wfn', 'f_basis', 'f_zeta', 'f_options', 'f_energy', 'f_gradient', 'f_hessian', 'f_dipole', 'f_dipder']; _lmh_labels = {; 1: ['HI'],; 2: ['LO', 'HI'],; 3: ['LO', 'MD', 'HI'],; 4: ['LO', 'MD', 'M2', 'HI'],; 5: ['LO', 'MD', 'M2', 'M3', 'HI']; }; CBSMetadata = List[Dict[str, Any]]. # remove in 1.8; # these get input files to the point where they raise an UpgradeHelper; def xtpl_highest_1():; pass. def scf_xtpl_helgaker_2():; pass. def scf_xtpl_truhlar_2():; pass. def scf_xtpl_karton_2():; pass. def scf_xtpl_helgaker_3():; pass. def corl_xtpl_helgaker_2():; pass. def _expand_bracketed_basis(basisstring: str, molecule: Union[""qcdb.Molecule"", ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/driver_cbs.html:5552,Energy,EnergyGradientHessianWfnReturn,5552,psi4manual/1.9.x/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/driver_cbs.html,2,['Energy'],['EnergyGradientHessianWfnReturn']
Energy Efficiency,"]. Parameters; include_deprecated_keys (bool) – . write_molden(filename=None, do_virtual=None, use_natural=False)¶; Function to write wavefunction information in wfn to filename in; molden format. Will write natural orbitals from density (MO basis) if supplied.; Warning! Most post-SCF Wavefunctions do not build the density as this is often; much more costly than the energy. In addition, the Wavefunction density attributes; (Da and Db) return the SO density and must be transformed to the MO basis; to use with this function. New in version 0.5: wfn parameter passed explicitly. Returns; None. Parameters. filename (string) – destination file name for MOLDEN file (optional); do_virtual (bool) – do write all the MOs to the MOLDEN file (true) or discard the unoccupied MOs, not valid for NO’s (false) (optional); use_natural (bool) – write natural orbitals determined from density on wavefunction. Examples. Molden file with the Kohn-Sham orbitals of a DFT calculation.; >>> E, wfn = energy('b3lyp', return_wfn=True); >>> wfn.molden('mycalc.molden'). Molden file with the natural orbitals of a CCSD computation. For correlated methods, an energy call will not compute the density.; “properties” or “gradient” must be called.; >>> E, wfn = properties('ccsd', return_wfn=True); >>> wfn.molden('ccsd_no.molden', use_natural=True). To supply a custom density matrix, manually set the Da and Db of the wavefunction.; This is used, for example, to write natural orbitals coming from a root computed; by a CIWavefunction computation, e.g., detci, fci, casscf.`; The first two arguments of get_opdm can be set to n, n where n => 0 selects the root to; write out, provided these roots were computed, see NUM_ROOTS. The; third argument controls the spin (""A"", ""B"" or ""SUM"") and the final; boolean option determines whether inactive orbitals are included.; >>> E, wfn = energy('detci', return_wfn=True); >>> wfn.Da() = wfn.get_opdm(0, 0, ""A"", True); >>> wfn.Db() = wfn.get_opdm(0, 0, ""B"", True); >>> molden(wf",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/api/psi4.core.ccwavefunction.html:26193,energy,energy,26193,psi4manual/1.4.0/api/psi4.core.ccwavefunction.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/api/psi4.core.ccwavefunction.html,49,['energy'],['energy']
Energy Efficiency,"]. \[f_{damp} = a_1 \sqrt{\frac{C_8^{ij}}{C_6^{ij}}} + a_2\]; All parameters characterizing the dispersion correction are taken from; http://toc.uni-muenster.de/DFTD3/; or else from the literature. Running DFTD3¶; A number of a posteriori dispersion corrections are available in; PSI4. While most are computed within PSI4‘s codebase (-D1, -D2,; -CHG, -DAS2009, -DAS2010), the -D3 correction and its variants are; available only through the DFTD3 program. Once installed, the; dftd3/PSI4 interface is transparent, and all corrections are; interfaced exactly alike.; Dispersion corrections are built into DFT functionals, so appending an a; posteriori correction to a computation is as simple as; energy('b2plyp-d') vs. energy('b2plyp'). For example, the; following input file computes (with much redundant work) for water a; B3LYP, a B3LYP-D2, and a B3LYP-D3 (zero-damping) energy.; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11molecule h2o {; O; H 1 1.0; H 1 1.0 2 104.5; }; set {; basis cc-pVDZ; }; energy('b3lyp'); energy('b3lyp-d'); energy('b3lyp-d3'). Consult the table -D Functionals to see for each; functional what corrections are available and what default parameters; define them. The dispersion correction is available after a calculation in; the PSI variable DISPERSION CORRECTION ENERGY.; By default, the output from the dftd3; program is suppressed; to see it in the output file, set print > 2. Variants of S. Grimme’s -D correction¶. Extension [1]; Variant and Computing Program; DFT_DISPERSION_PARAMETERS. -D; alias to -D2P4;  . -D1; -D1 [2] within PSI4;  . -D2; alias to -D2P4;  . -D2P4; -D2 [3] within PSI4; [\(s_6\)]. -D2GR; -D2 [3] through dftd3; [\(s_6\), \(\alpha_6\)]. -D3; alias to -D3ZERO;  . -D3ZERO; -D3 [4] w/ original zero-damping through dftd3; [\(s_6\), \(s_8\), \(s_{r,6}\), \(\alpha_6\)]. -D3BJ; -D3 [5] w/ newer Becke-Johnson rational damping through dftd3; [\(s_6\), \(s_8\), \(a_1\), \(a_2\)]. -D3M; alias to -D3MZERO;  . -D3MZERO; -D3 [6] w/ reparameterized and more flexible ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/dftd3-1.html:4977,energy,energy,4977,psi4manual/1.1.0/dftd3-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/dftd3-1.html,6,['energy'],['energy']
Energy Efficiency,"]. \[f_{damp} = a_1 \sqrt{\frac{C_8^{ij}}{C_6^{ij}}} + a_2\]; All parameters characterizing the dispersion correction are taken from; http://toc.uni-muenster.de/DFTD3/; or else from the literature. Running DFTD3¶; A number of a posteriori dispersion corrections are available in; PSI4. While most are computed within PSI4’s codebase (-D1, -D2,; -CHG, -DAS2009, -DAS2010), the -D3 correction and its variants are; available only through the DFTD3 program. Once installed, the; dftd3/PSI4 interface is transparent, and all corrections are; interfaced exactly alike.; Dispersion corrections are built into DFT functionals, so appending an a; posteriori correction to a computation is as simple as; energy('b2plyp-d') vs. energy('b2plyp'). For example, the; following input file computes (with much redundant work) for water a; B3LYP, a B3LYP-D2, and a B3LYP-D3 (zero-damping) energy.; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11molecule h2o {; O; H 1 1.0; H 1 1.0 2 104.5; }; set {; basis cc-pVDZ; }; energy('b3lyp'); energy('b3lyp-d'); energy('b3lyp-d3'). Consult the table -D Functionals to see for each; functional what corrections are available and what default parameters; define them. The dispersion correction is available after a calculation in; the PSI variable DISPERSION CORRECTION ENERGY.; By default, the output from the dftd3; program is suppressed; to see it in the output file, set print > 2. Variants of S. Grimme’s -D correction¶. Extension [1]; Variant and Computing Program; DFT_DISPERSION_PARAMETERS. -D; alias to -D2P4;  . -D1; -D1 [2] within PSI4;  . -D2; alias to -D2P4;  . -D2P4; -D2 [3] within PSI4; [\(s_6\)]. -D2GR; -D2 [3] through dftd3; [\(s_6\), \(\alpha_6\)]. -D3; alias to -D3ZERO;  . -D3ZERO; -D3 [4] w/ original zero-damping through dftd3; [\(s_6\), \(s_8\), \(s_{r,6}\), \(\alpha_6\)]. -D3BJ; -D3 [5] w/ newer Becke-Johnson rational damping through dftd3; [\(s_6\), \(s_8\), \(a_1\), \(a_2\)]. -D3M; alias to -D3MZERO;  . -D3MZERO; -D3 [6] w/ reparameterized and more flexible ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/dftd3-1.html:5140,energy,energy,5140,psi4manual/1.2.1/dftd3-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/dftd3-1.html,6,['energy'],['energy']
Energy Efficiency,"]. sapt2+(3)dmp2; SAPT including perturbative triples and MP2 correction [manual]. sapt2+3dmp2; SAPT including all 3rd-order terms and MP2 correction [manual]. sapt2+(ccd)dmp2; SAPT2+ with CC-based dispersion and MP2 correction [manual]. sapt2+(3)(ccd)dmp2; SAPT2+(3) with CC-based dispersion and MP2 correction [manual]. sapt2+3(ccd)dmp2; SAPT2+3 with CC-based dispersion and MP2 correction [manual]. sapt0-ct; 0th-order SAPT plus charge transfer (CT) calculation [manual]. sapt2-ct; SAPT2 plus CT [manual]. sapt2+-ct; SAPT2+ plus CT [manual]. sapt2+(3)-ct; SAPT2+(3) plus CT [manual]. sapt2+3-ct; SAPT2+3 plus CT [manual]. sapt2+(ccd)-ct; SAPT2+(CCD) plus CT [manual]. sapt2+(3)(ccd)-ct; SAPT2+(3)(CCD) plus CT [manual]. sapt2+3(ccd)-ct; SAPT2+3(CCD) plus CT [manual]. adc; 2nd-order algebraic diagrammatic construction (ADC) [manual]. eom-cc2; EOM-CC2 [manual]. eom-ccsd; equation of motion (EOM) CCSD [manual]. eom-cc3; EOM-CC3 [manual]. Examples:. 1; 2>>> # [1] Coupled-cluster singles and doubles calculation with psi code; >>> energy('ccsd'). 1; 2; 3; 4; 5>>> # [2] Charge-transfer SAPT calculation with scf projection from small into; >>> # requested basis, with specified projection fitting basis; >>> set basis_guess true; >>> set df_basis_guess jun-cc-pVDZ-JKFIT; >>> energy('sapt0-ct'). 1; 2>>> # [3] Arbitrary-order MPn calculation; >>> energy('mp7'). 1; 2; 3; 4; 5; 6; 7; 8; 9>>> # [4] Converge scf as singlet, then run detci as triplet upon singlet reference; >>> # Note that the integral transformation is not done automatically when detci is run in a separate step.; >>> molecule H2 {\n0 1\nH\nH 1 0.74\n}; >>> set basis cc-pVDZ; >>> set reference rohf; >>> scf_e, scf_wfn = energy('scf', return_wfn=True); >>> H2.set_multiplicity(3); >>> core.MintsHelper(scf_wfn.basisset()).integrals(); >>> energy('detci', ref_wfn=scf_wfn). 1; 2; 3; 4; 5>>> # [5] Run two CI calculations, keeping the integrals generated in the first one.; >>> molecule ne {\nNe\n}; >>> set basis cc-pVDZ; >>> cisd_",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/energy.html:7307,energy,energy,7307,psi4manual/1.1.0/energy.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/energy.html,4,['energy'],['energy']
Energy Efficiency,"]:; dertype = 1; if procedures['gradient'][method_name].__name__.startswith('select_'):; try:; procedures['gradient'][method_name](method_name, probe=True); except ManagedMethodError:; dertype = 0; elif method_name in procedures['energy']:; dertype = 0; else:; # Quick sanity check. Only *should* be able to be None or int, but hey, kids today...; if not isinstance(user_dertype, int):; raise ValidationError(""_find_derivative_type: user_dertype should only be None or int!""); dertype = user_dertype. if (core.get_global_option('INTEGRAL_PACKAGE') == 'ERD') and (dertype != 0):; raise ValidationError('INTEGRAL_PACKAGE ERD does not play nicely with derivatives, so stopping.'). # Summary validation; if (dertype == 2) and (method_name in procedures['hessian']):; pass; elif (dertype == 1) and (method_name in procedures['gradient']):; pass; elif (dertype == 0) and (method_name in procedures['energy']):; pass; else:; alternatives = ''; alt_method_name = p4util.text.find_approximate_string_matches(method_name, procedures['energy'].keys(), 2); if len(alt_method_name) > 0:; alternatives = """""" Did you mean? %s"""""" % (' '.join(alt_method_name)). raise ValidationError(""""""Derivative method 'name' %s and derivative level 'dertype' %s are not available.%s""""""; % (method_name, str(dertype), alternatives)). return dertype. [docs]def energy(name, **kwargs):; r""""""Function to compute the single-point electronic energy. :returns: *float* |w--w| Total electronic energy in Hartrees. SAPT & EFP return interaction energy. :returns: (*float*, :py:class:`~psi4.core.Wavefunction`) |w--w| energy and wavefunction when **return_wfn** specified. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`CURRENT ENERGY <CURRENTENERGY>`; * :psivar:`CURRENT REFERENCE ENERGY <CURRENTREFERENCEENERGY>`; * :psivar:`CURRENT CORRELATION ENERGY <CURRENTCORRELATIONENERGY>`. :type name: string; :param name: ``'scf'`` || ``'mp2'`` || ``'ci5'`` || etc. First argument, usually unlabeled. Indicates the computational method; to ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/driver.html:3520,energy,energy,3520,psi4manual/1.1.0/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/driver.html,1,['energy'],['energy']
Energy Efficiency,"]; A translation of this ungainly equation to example [5] below is as; follows. In words, this is a double- and triple-zeta 2-point; Helgaker-extrapolated CCSD(T) coupled-cluster correlation correction; appended to a triple- and quadruple-zeta 2-point; Helgaker-extrapolated MP2 correlation energy appended to a SCF/aug-cc-pVQZ; reference energy. \[E_{\text{total}}^{\text{CBS}} = \mathcal{F}_{\text{highest_1}} \left(E_{\text{total},\; \text{SCF}}^{\text{aug-cc-pVQZ}}\right) \; + \mathcal{F}_{\text{corl_xtpl_helgaker_2}} \left(E_{\text{corl},\; \text{MP2}}^{\text{aug-cc-pV[TQ]Z}}\right) \; + \delta_{\text{MP2}}^{\text{CCSD(T)}}\]. \[\delta_{\text{MP2}}^{\text{CCSD(T)}} \; = \mathcal{F}_{\text{corl_xtpl_helgaker_2}} \left(E_{\text{corl},\; \text{CCSD(T)}}^{\text{aug-cc-pV[DT]Z}}\right) - \mathcal{F}_{\text{corl_xtpl_helgaker_2}} \left(E_{\text{corl},\; \text{MP2}}^{\text{aug-cc-pV[DT]Z}}\right)\]. Energy MethodsThe presence of a stage_wfn keyword is the indicator to incorporate; (and check for stage_basis and stage_scheme keywords) and compute; that stage in defining the CBS energy.; The cbs() function requires, at a minimum, name='scf' and scf_basis; keywords to be specified for reference-step only jobs and name and; corl_basis keywords for correlated jobs.; The following energy methods have been set up for cbs(). scf; hf; mp2; mp2.5; mp3; mp4(sdq); mp4; mpn. omp2; omp2.5; omp3; olccd; lccd; lccsd; cepa(0); cepa(1). cepa(3); acpf; aqcc; qcisd; cc2; ccsd; fno-ccsd; bccd. cc3; qcisd(t); ccsd(t); fno-ccsd(t); bccd(t); cisd; cisdt. cisdtq; cin; fci; mrccsd; mrccsd(t); mrccsdt; mrccsdt(q). Parameters. name (str) – 'scf' || 'ccsd' || etc.; First argument, usually unlabeled. Indicates the computational method; for the correlation energy, unless only reference step to be performed,; in which case should be 'scf'. Overruled if stage_wfn keywords supplied. scf_wfn (str) – \(\Rightarrow\) 'scf' \(\Leftarrow\) || 'c4-scf' || etc.; Indicates the energy method for which the reference",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/api/psi4.driver.cbs-1.html:4461,energy,energy,4461,psi4manual/1.4.0/api/psi4.driver.cbs-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/api/psi4.driver.cbs-1.html,20,"['Energy', 'energy']","['Energy', 'energy']"
Energy Efficiency,"]; A translation of this ungainly equation to example [5] below is as; follows. In words, this is a double- and triple-zeta 2-point; Helgaker-extrapolated CCSD(T) coupled-cluster correlation correction; appended to a triple- and quadruple-zeta 2-point; Helgaker-extrapolated MP2 correlation energy appended to a SCF/aug-cc-pVQZ; reference energy. \[E_{\text{total}}^{\text{CBS}} = \mathcal{F}_{\text{highest_1}} \left(E_{\text{total},\; \text{SCF}}^{\text{aug-cc-pVQZ}}\right) \; + \mathcal{F}_{\text{corl_xtpl_helgaker_2}} \left(E_{\text{corl},\; \text{MP2}}^{\text{aug-cc-pV[TQ]Z}}\right) \; + \delta_{\text{MP2}}^{\text{CCSD(T)}}\]. \[\delta_{\text{MP2}}^{\text{CCSD(T)}} \; = \mathcal{F}_{\text{corl_xtpl_helgaker_2}} \left(E_{\text{corl},\; \text{CCSD(T)}}^{\text{aug-cc-pV[DT]Z}}\right) - \mathcal{F}_{\text{corl_xtpl_helgaker_2}} \left(E_{\text{corl},\; \text{MP2}}^{\text{aug-cc-pV[DT]Z}}\right)\]. Energy MethodsThe presence of a stage_wfn keyword is the indicator to incorporate; (and check for stage_basis and stage_scheme keywords) and compute; that stage in defining the CBS energy.; The cbs() function requires, at a minimum, name='scf' and scf_basis; keywords to be specified for reference-step only jobs and name and; corl_basis keywords for correlated jobs.; The following energy methods have been set up for cbs(). scf; hf; mp2; mp2.5; mp3; mp4(sdq); mp4; mpn. omp2; omp2.5; omp3; olccd; lccd; lccsd; cepa(0); cepa(1). cepa(3); acpf; aqcc; qcisd; cc2; ccsd; fno-ccsd; bccd. cc3; qcisd(t); ccsd(t); fno-ccsd(t); bccd(t); cisd; cisdt. cisdtq; cin; fci; mrccsd; mrccsd(t); mrccsdt; mrccsdt(q). Parameters:. name (str) – 'scf' || 'ccsd' || etc.; First argument, usually unlabeled. Indicates the computational method; for the correlation energy, unless only reference step to be performed,; in which case should be 'scf'. Overruled if stage_wfn keywords supplied. scf_wfn (str) – \(\Rightarrow\) 'scf' \(\Leftarrow\) || 'c4-scf' || etc.; Indicates the energy method for which the referenc",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/api/psi4.driver.cbs.html:4464,energy,energy,4464,psi4manual/1.7.x/api/psi4.driver.cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.driver.cbs.html,16,"['Energy', 'energy']","['Energy', 'energy']"
Energy Efficiency,"]; E0s = []; E1s = []; kIPs = []; IPs = []; types = []. # Right endpoint; core.set_local_option('SCF', 'DFT_OMEGA', omega_r). # Neutral; if read:; core.set_local_option(""SCF"", ""GUESS"", ""READ""); p4util.copy_file_to_scratch(read180, 'psi', 'ot', 180). molecule.set_molecular_charge(charge0); molecule.set_multiplicity(mult0); E0r, wfn = driver.energy('scf', dft_functional=name, return_wfn=True, molecule=molecule,; banner='IP Fitting SCF: Neutral, Right Endpoint', **kwargs); eps_a = wfn.epsilon_a(); eps_b = wfn.epsilon_b(); if Nb == 0:; E_HOMO = eps_a.np[int(Na - 1)]; else:; E_a = eps_a.np[int(Na - 1)]; E_b = eps_b.np[int(Nb - 1)]; E_HOMO = max(E_a, E_b); E_HOMOr = E_HOMO; core.IO.change_file_namespace(180, ""ot"", ""neutral""). # Cation; if read:; core.set_local_option(""SCF"", ""GUESS"", ""READ""); p4util.copy_file_to_scratch(read180, 'psi', 'ot', 180). molecule.set_molecular_charge(charge1); molecule.set_multiplicity(mult1); E1r = driver.energy('scf', dft_functional=name, molecule=molecule,; banner='IP Fitting SCF: Cation, Right Endpoint', **kwargs); core.IO.change_file_namespace(180, ""ot"", ""cation""). IPr = E1r - E0r; kIPr = -E_HOMOr; delta_r = IPr - kIPr. if IPr > kIPr:; raise ValidationError(""""""\n***IP Fitting Error: Right Omega limit should have kIP > IP: {} !> {}"""""".format(kIPr, IPr)). omegas.append(omega_r); types.append('Right Limit'); E0s.append(E0r); E1s.append(E1r); IPs.append(IPr); kIPs.append(kIPr). # Use previous orbitals from here out; core.set_local_option(""SCF"", ""GUESS"", ""READ""). # Left endpoint; core.set_local_option('SCF', 'DFT_OMEGA', omega_l). # Neutral; core.IO.change_file_namespace(180, ""neutral"", ""ot""); molecule.set_molecular_charge(charge0); molecule.set_multiplicity(mult0); core.set_global_option(""DOCC"", [Nb]); core.set_global_option(""SOCC"", [Na - Nb]); E0l, wfn = driver.energy('scf', dft_functional=name, return_wfn=True, molecule=molecule,; banner='IP Fitting SCF: Neutral, Left Endpoint', **kwargs); eps_a = wfn.epsilon_a(); eps_b = wfn.epsilon_b(); if N",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/frac.html:18480,energy,energy,18480,psi4manual/1.7.x/_modules/psi4/driver/frac.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/frac.html,8,['energy'],['energy']
Energy Efficiency,"]; cp_ptype_body_dict[n] += take_nk * sign * value. _print_nbody_energy(cp_energy_body_dict, ""Counterpoise Corrected (CP)""); cp_interaction_energy = cp_energy_body_dict[max_nbody] - cp_energy_body_dict[1]; core.set_variable('Counterpoise Corrected Total Energy', cp_energy_body_dict[max_nbody]); core.set_variable('Counterpoise Corrected Interaction Energy', cp_interaction_energy). for n in nbody_range[1:]:; var_key = 'CP-CORRECTED %d-BODY INTERACTION ENERGY' % n; core.set_variable(var_key, cp_energy_body_dict[n] - cp_energy_body_dict[1]). # Compute nocp energy and ptype; if do_nocp:; for n in nbody_range:; if n == max_frag:; nocp_energy_body_dict[n] = nocp_energy_by_level[n]; if ptype != 'energy':; nocp_ptype_body_dict[n][:] = nocp_ptype_by_level[n]; continue. for k in range(1, n + 1):; take_nk = nCr(max_frag - k - 1, n - k); sign = ((-1) ** (n - k)); value = nocp_energy_by_level[k]; nocp_energy_body_dict[n] += take_nk * sign * value. if ptype != 'energy':; value = nocp_ptype_by_level[k]; nocp_ptype_body_dict[n] += take_nk * sign * value. _print_nbody_energy(nocp_energy_body_dict, ""Non-Counterpoise Corrected (NoCP)""); nocp_interaction_energy = nocp_energy_body_dict[max_nbody] - nocp_energy_body_dict[1]; core.set_variable('Non-Counterpoise Corrected Total Energy', nocp_energy_body_dict[max_nbody]); core.set_variable('Non-Counterpoise Corrected Interaction Energy', nocp_interaction_energy). for n in nbody_range[1:]:; var_key = 'NOCP-CORRECTED %d-BODY INTERACTION ENERGY' % n; core.set_variable(var_key, nocp_energy_body_dict[n] - nocp_energy_body_dict[1]). # Compute vmfc energy and ptype; if do_vmfc:; _print_nbody_energy(vmfc_energy_body_dict, ""Valiron-Mayer Function Couterpoise (VMFC)""); vmfc_interaction_energy = vmfc_energy_body_dict[max_nbody] - vmfc_energy_body_dict[1]; core.set_variable('Valiron-Mayer Function Couterpoise Total Energy', vmfc_energy_body_dict[max_nbody]); core.set_variable('Valiron-Mayer Function Couterpoise Interaction Energy', vmfc_interaction_ener",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/driver_nbody.html:13665,energy,energy,13665,psi4manual/1.1.0/_modules/psi4/driver/driver_nbody.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/driver_nbody.html,1,['energy'],['energy']
Energy Efficiency,"]; cp_ptype_body_dict[n] += take_nk * sign * value. _print_nbody_energy(cp_energy_body_dict, ""Counterpoise Corrected (CP)""); cp_interaction_energy = cp_energy_body_dict[max_nbody] - cp_energy_body_dict[1]; psi4.set_variable('Counterpoise Corrected Total Energy', cp_energy_body_dict[max_nbody]); psi4.set_variable('Counterpoise Corrected Interaction Energy', cp_interaction_energy). for n in nbody_range[1:]:; var_key = 'CP-CORRECTED %d-BODY INTERACTION ENERGY' % n; psi4.set_variable(var_key, cp_energy_body_dict[n] - cp_energy_body_dict[1]). # Compute nocp energy and ptype; if do_nocp:; for n in nbody_range:; if n == max_frag:; nocp_energy_body_dict[n] = nocp_energy_by_level[n]; if ptype != 'energy':; nocp_ptype_body_dict[n][:] = nocp_ptype_by_level[n]; continue. for k in range(1, n + 1):; take_nk = nCr(max_frag - k - 1, n - k); sign = ((-1) ** (n - k)); value = nocp_energy_by_level[k]; nocp_energy_body_dict[n] += take_nk * sign * value. if ptype != 'energy':; value = nocp_ptype_by_level[k]; nocp_ptype_body_dict[n] += take_nk * sign * value. _print_nbody_energy(nocp_energy_body_dict, ""Non-Counterpoise Corrected (NoCP)""); nocp_interaction_energy = nocp_energy_body_dict[max_nbody] - nocp_energy_body_dict[1]; psi4.set_variable('Non-Counterpoise Corrected Total Energy', nocp_energy_body_dict[max_nbody]); psi4.set_variable('Non-Counterpoise Corrected Interaction Energy', nocp_interaction_energy). for n in nbody_range[1:]:; var_key = 'NOCP-CORRECTED %d-BODY INTERACTION ENERGY' % n; psi4.set_variable(var_key, nocp_energy_body_dict[n] - nocp_energy_body_dict[1]). # Compute vmfc energy and ptype; if do_vmfc:; _print_nbody_energy(vmfc_energy_body_dict, ""Valiron-Mayer Function Couterpoise (VMFC)""); vmfc_interaction_energy = vmfc_energy_body_dict[max_nbody] - vmfc_energy_body_dict[1]; psi4.set_variable('Valiron-Mayer Function Couterpoise Total Energy', vmfc_energy_body_dict[max_nbody]); psi4.set_variable('Valiron-Mayer Function Couterpoise Interaction Energy', vmfc_interaction_ener",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/driver_nbody.html:13602,energy,energy,13602,psi4manual/1.0.0/_modules/driver_nbody.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver_nbody.html,1,['energy'],['energy']
Energy Efficiency,"]; def fcidump(wfn: core.Wavefunction, fname: str = 'INTDUMP', oe_ints: Optional[List] = None):; """"""Save integrals to file in FCIDUMP format as defined in Comp. Phys. Commun. 54 75 (1989),; https://doi.org/10.1016/0010-4655(89)90033-7 .; Additional one-electron integrals, including orbital energies, can also be saved.; This latter format can be used with the HANDE QMC code but is not standard. Parameters; ----------; wfn; Set of molecule, basis, orbitals from which to generate FCIDUMP file.; fname; Name of the integrals file, defaults to INTDUMP.; oe_ints; List of additional one-electron integrals to save to file. So far only; EIGENVALUES is a valid option. Raises; ------; ValidationError; When SCF wavefunction is not RHF. Examples; --------. >>> # [1] Save one- and two-electron integrals to standard FCIDUMP format; >>> E, wfn = energy('scf', return_wfn=True); >>> fcidump(wfn). >>> # [2] Save orbital energies, one- and two-electron integrals.; >>> E, wfn = energy('scf', return_wfn=True); >>> fcidump(wfn, oe_ints=['EIGENVALUES']). """"""; # Get some options; reference = core.get_option('SCF', 'REFERENCE'); ints_tolerance = core.get_global_option('INTS_TOLERANCE'); # Some sanity checks; if reference not in ['RHF', 'UHF']:; raise ValidationError('FCIDUMP not implemented for {} references\n'.format(reference)); if oe_ints is None:; oe_ints = []. molecule = wfn.molecule(); docc = wfn.doccpi(); frzcpi = wfn.frzcpi(); frzvpi = wfn.frzvpi(); active_docc = docc - frzcpi; active_socc = wfn.soccpi(); active_mopi = wfn.nmopi() - frzcpi - frzvpi. nbf = active_mopi.sum() if wfn.same_a_b_orbs() else 2 * active_mopi.sum(); nirrep = wfn.nirrep(); nelectron = 2 * active_docc.sum() + active_socc.sum(); irrep_map = _irrep_map(wfn). wfn_irrep = 0; for h, n_socc in enumerate(active_socc):; if n_socc % 2 == 1:; wfn_irrep ^= h. core.print_out('Writing integrals in FCIDUMP format to ' + fname + '\n'); # Generate FCIDUMP header; header = '&FCI\n'; header += 'NORB={:d},\n'.format(nbf); header += ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/fcidump.html:2640,energy,energy,2640,psi4manual/1.8.x/_modules/psi4/driver/p4util/fcidump.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/fcidump.html,6,['energy'],['energy']
Energy Efficiency,"]Z', corl_scheme=corl_xtpl_helgaker_2, func=cbs). Note; As of October 2018, only two explicit `deltaN_[wfn,basis,scheme]` sets of options are active; if more delta functions are required, use the `cbs_metadata` interface. Also, temporarily extrapolations are performed on differences of target and scf total energies, rather than on correlation energies directly. This doesn’t affect the extrapolated values of the particular formulas defined here (though it does affect the betas, which are commented out), but it is sloppy and temporary and could affect any user-defined corl extrapolations. Output¶; At the beginning of a cbs() job is printed a listing of the individual; energy calculations which will be performed. The output snippet below is; from the example job [2] above. It shows first each model chemistry needed; to compute the aggregate model chemistry requested through cbs(). Then,; since, for example, an energy('ccsd(t)') yields CCSD(T), CCSD, MP2,; and SCF energy values, the wrapper condenses this task list into the second; list of minimum number of calculations which will actually be run.; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13Naive listing of computations required.; scf / aug-cc-pvqz for SCF TOTAL ENERGY; mp2 / aug-cc-pvtz for MP2 CORRELATION ENERGY; mp2 / aug-cc-pvqz for MP2 CORRELATION ENERGY; ccsd(t) / aug-cc-pvdz for CCSD(T) CORRELATION ENERGY; ccsd(t) / aug-cc-pvtz for CCSD(T) CORRELATION ENERGY; mp2 / aug-cc-pvdz for MP2 CORRELATION ENERGY; mp2 / aug-cc-pvtz for MP2 CORRELATION ENERGY. Enlightened listing of computations required.; mp2 / aug-cc-pvqz for MP2 CORRELATION ENERGY; ccsd(t) / aug-cc-pvdz for CCSD(T) CORRELATION ENERGY; ccsd(t) / aug-cc-pvtz for CCSD(T) CORRELATION ENERGY. At the end of a cbs() job is printed a summary section like the one below. First,; in the components section, are listed the results for each model chemistry available, whether; required for the cbs job (*) or not. Next, in the stages section, are listed the results for; e",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/cbs-1.html:11058,energy,energy,11058,psi4manual/1.3.2/cbs-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/cbs-1.html,4,['energy'],['energy']
Energy Efficiency,"]Z', corl_scheme=corl_xtpl_helgaker_2, func=cbs). Note; As of October 2018, only two explicit `deltaN_[wfn,basis,scheme]` sets of options are active; if more delta functions are required, use the `cbs_metadata` interface. Also, temporarily extrapolations are performed on differences of target and scf total energies, rather than on correlation energies directly. This doesn’t affect the extrapolated values of the particular formulas defined here (though it does affect the betas, which are commented out), but it is sloppy and temporary and could affect any user-defined corl extrapolations. Output¶; At the beginning of a cbs() job is printed a listing of the individual; energy calculations which will be performed. The output snippet below is; from the example job [2] above. It shows first each model chemistry needed; to compute the aggregate model chemistry requested through cbs(). Then,; since, for example, an energy('ccsd(t)') yields CCSD(T), CCSD, MP2,; and SCF energy values, the wrapper condenses this task list into the second; list of minimum number of calculations which will actually be run.; Naive listing of computations required.; scf / aug-cc-pvqz for SCF TOTAL ENERGY; mp2 / aug-cc-pvtz for MP2 CORRELATION ENERGY; mp2 / aug-cc-pvqz for MP2 CORRELATION ENERGY; ccsd(t) / aug-cc-pvdz for CCSD(T) CORRELATION ENERGY; ccsd(t) / aug-cc-pvtz for CCSD(T) CORRELATION ENERGY; mp2 / aug-cc-pvdz for MP2 CORRELATION ENERGY; mp2 / aug-cc-pvtz for MP2 CORRELATION ENERGY. Enlightened listing of computations required.; mp2 / aug-cc-pvqz for MP2 CORRELATION ENERGY; ccsd(t) / aug-cc-pvdz for CCSD(T) CORRELATION ENERGY; ccsd(t) / aug-cc-pvtz for CCSD(T) CORRELATION ENERGY. At the end of a cbs() job is printed a summary section like the one below. First,; in the components section, are listed the results for each model chemistry available, whether; required for the cbs job (*) or not. Next, in the stages section, are listed the results for; each extrapolation. The energies of this s",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/cbs-1.html:17070,energy,energy,17070,psi4manual/1.4.0/cbs-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/cbs-1.html,8,['energy'],['energy']
Energy Efficiency,"]['DISPERSION CORRECTION GRADIENT']. [docs]; def run_dftd4(self, func: Optional[str] = None, dashlvl: Optional[str] = None, dashparam: Optional[Dict] = None, dertype: Union[int, str, None] = None, verbose: int = 1):; """"""Compute dispersion correction via Grimme's DFTD4 program. Parameters; ----------; func; Name of functional (func only, func & disp, or disp only) for; which to compute dispersion (e.g., blyp, BLYP-D2, blyp-d3bj,; blyp-d3(bj), hf+d). Unlike run_dftd3, ``func`` overwrites any; parameter initialized via `dashparam`.; dashlvl; Name of dispersion correction to be applied (e.g., d, D2,; d3(bj), das2010). Must be key in `dashcoeff` or ""alias"" or; ""formal"" to run.; dashparam; Values for the same keys as `dashcoeff[dashlvl]['default']`; used to provide custom values. Unlike run_dftd3, will not have; effect if `func` given. Must provide all parameters.; Extra parameters will error.; dertype; Maximum derivative level at which to run DFTD3. For large; molecules, energy-only calculations can be significantly more; efficient. Influences return values, see below.; verbose; Amount of printing. Returns; -------; energy : float; When `dertype=0`, energy [Eh].; gradient : ndarray; When `dertype=1`, (nat, 3) gradient [Eh/a0].; (energy, gradient) : tuple of float and ndarray; When `dertype=None`, both energy [Eh] and (nat, 3) gradient [Eh/a0]. Notes; -----; This function wraps the QCEngine dftd4 harness which wraps the internal DFTD4 Python API.; As such, the upstream convention of `func` trumping `dashparam` holds, rather than the; :py:func:`run_dftd3` behavior of `dashparam` extending or overriding `func`. """"""; import qcengine as qcng. if dertype is None:; derint, derdriver = -1, 'gradient'; else:; derint, derdriver = parse_dertype(dertype, max_derivative=1). resinp = {; 'molecule': self.to_schema(dtype=2),; 'driver': derdriver,; 'model': {; 'method': func,; 'basis': '(auto)',; },; 'keywords': {; 'verbose': verbose,; },; }; if dashlvl:; resinp['keywords']['level_hint'] ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qcdb/molecule.html:43225,energy,energy-only,43225,psi4manual/1.8.x/_modules/psi4/driver/qcdb/molecule.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qcdb/molecule.html,12,"['efficient', 'energy']","['efficient', 'energy-only']"
Energy Efficiency,"]['value']. if 'DAMPING_PERCENTAGE' in opt['SCF']:; options['CFOUR']['CFOUR_SCF_DAMPING']['value'] = \; int(10 * opt['SCF']['DAMPING_PERCENTAGE']['value']). for item in options['CFOUR']:; options['CFOUR'][item]['clobber'] = False; return text, options. # Philosophy break:; # Specification options; # Massaging options. # * No program's defaults should be tampered with w/o provokation. # want all defaults applied to all programs, so p4 scf_conv is 5 and c4 scf_conv is 5; # want separate regimes, so conv 6 covers all the p4 parts and cfour_conv = 8 covers the c4 parts; # want mixture, so basis gets applied to c4 but others don't; # first case, when options specified explicitly. # [scf][d_convergence] [cfour][cfour_scf_conv] what happens?; # 8 from opt() 7 by default; # 6 from set {...} 7 by default 6 (guideline that psi4 format converts when clear); # 8 from opt() 5 from set {...} 5 (local trumps); # 6 from set {...} 5 from set {...} 5 (local trumps); #; # energy(name) [cfour][cfour_calc_level]; # c4-scf SCF by default; # c4-scf CCSD from set {...}. [docs]def muster_modelchem(name, dertype):; """"""Transform calculation method *name* and derivative level *dertype*; into options for cfour. While deliberately requested pieces,; generally |cfour__cfour_deriv_level| and |cfour__cfour_calc_level|,; are set to complain if contradicted ('clobber' set to True), other; 'recommended' settings, like |cfour__cfour_cc_program|, can be; countermanded by keywords in input file ('clobber' set to False).; Occasionally, want these pieces to actually overcome keywords in; input file ('superclobber' set to True). """"""; text = ''; lowername = name.lower(); options = defaultdict(lambda: defaultdict(dict)). if dertype == 0:; if lowername == 'cfour':; pass # permit clean operation of sandwich mode; else:; options['CFOUR']['CFOUR_DERIV_LEVEL']['value'] = 'ZERO'; elif dertype == 1:; options['CFOUR']['CFOUR_DERIV_LEVEL']['value'] = 'FIRST'; elif dertype == 2:; options['CFOUR']['CFOUR_DERIV_LEVEL']['v",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/cfour.html:29976,energy,energy,29976,psi4manual/1.0.0/_modules/qcdb/cfour.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/cfour.html,1,['energy'],['energy']
Energy Efficiency,"]def build_m05_2x_superfunctional(name, npoints, deriv):. # Call this first; sup = PsiMod.SuperFunctional.blank(); sup.set_max_points(npoints); sup.set_deriv(deriv). # => User-Customization <= #. # No spaces, keep it short and according to convention; sup.set_name('M05-2X'); # Tab in, trailing newlines; sup.set_description(' Heavily Parameterized Hybrid Meta-GGA XC Functional\n'); # Tab in, trailing newlines; sup.set_citation(' Zhao et. al., J. Chem. Theory Comput., 2, 364, 2006\n'). # Add member functionals; X = build_functional('M_X'); X.set_name('M05_2X_X'); X.set_alpha(1.0). # LSDA Exchange type is Slater, no parameters. # GGA Exchange type is PBE, special parameters because Truhlar is lazy; C1 = 3.36116E-3;; C2 = 4.49267E-3;; K0 = 3.0/2.0 * math.pow(3.0 / (math.pi * 4.0), 1.0/3.0);; k0 = math.pow(6.0 * math.pi * math.pi, 1.0/3.0) ;; kp = C1 / (C2 * K0);; mu = 4.0 * k0 * k0 * kp * C2;; X.set_parameter('PBE_kp', kp);; X.set_parameter('PBE_mu', mu);. # Meta Exchange type is insane mess of w power series expansion; X.set_parameter('Meta_a0' , 1.0); X.set_parameter('Meta_a1' ,-0.56833); X.set_parameter('Meta_a2' ,-1.30057); X.set_parameter('Meta_a3' , 5.50070); X.set_parameter('Meta_a4' , 9.06402); X.set_parameter('Meta_a5' ,-32.21075); X.set_parameter('Meta_a6' ,-23.73298); X.set_parameter('Meta_a7' , 70.22996); X.set_parameter('Meta_a8' , 29.88614); X.set_parameter('Meta_a9' ,-60.25778); X.set_parameter('Meta_a10',-13.22205); X.set_parameter('Meta_a11', 15.23694). C = build_functional('M_C'); C.set_name('M05_2X_C'). # LSDA Correlation type is PW92, no parameters. # GGA Correlation type is B97; C.set_parameter('B97_os_gamma', 0.0031 * 2.0); C.set_parameter('B97_os_a0', 1.00000); C.set_parameter('B97_os_a1', 1.09297); C.set_parameter('B97_os_a2',-3.79171); C.set_parameter('B97_os_a3', 2.82810); C.set_parameter('B97_os_a4',-10.58909). C.set_parameter('B97_ss_gamma', 0.06); C.set_parameter('B97_ss_a0', 1.00000); C.set_parameter('B97_ss_a1',-3.05430); C.set_parameter('",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/_modules/functional.html:56566,power,power,56566,psi4manual/4.0b3/_modules/functional.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/_modules/functional.html,2,['power'],['power']
Energy Efficiency,"]z' || '6-31G*' || etc.; Indicates the sequence of basis sets employed for the correlation energy. delta_basis (basis string) – 'cc-pV[TQ]Z' || 'jun-cc-pv[tq5]z' || '6-31G*' || etc.; Indicates the sequence of basis sets employed for the delta correction; to the correlation energy. delta2_basis (basis string) – 'cc-pV[TQ]Z' || 'jun-cc-pv[tq5]z' || '6-31G*' || etc.; Indicates the sequence of basis sets employed for the second delta correction; to the correlation energy. SchemesTransformations of the energy through basis set extrapolation for each; stage of the CBS definition. A complaint is generated if number of basis; sets in stage_basis does not exactly satisfy requirements of stage_scheme.; An exception is the default, 'xtpl_highest_1', which uses the best basis; set available. See Extrapolation Schemes for all available schemes. Parameters. scf_scheme (string) – \(\Rightarrow\) 'xtpl_highest_1' \(\Leftarrow\) || 'scf_xtpl_helgaker_3' || etc.; Indicates the basis set extrapolation scheme to be applied to the reference energy.; Defaults to scf_xtpl_helgaker_3() if three valid basis sets; present in psi4.driver.driver_cbs.scf_basis, scf_xtpl_helgaker_2() if two valid basis; sets present in scf_basis, and xtpl_highest_1() otherwise. xtpl_highest_1(); scf_xtpl_helgaker_3(); scf_xtpl_helgaker_2(); scf_xtpl_truhlar_2(); scf_xtpl_karton_2(). corl_scheme (string) – \(\Rightarrow\) 'xtpl_highest_1' \(\Leftarrow\) || 'corl_xtpl_helgaker_2' || etc.; Indicates the basis set extrapolation scheme to be applied to the correlation energy.; Defaults to corl_xtpl_helgaker_2() if two valid basis sets; present in corl_basis and xtpl_highest_1() otherwise. xtpl_highest_1(); corl_xtpl_helgaker_2(). delta_scheme (string) – \(\Rightarrow\) 'xtpl_highest_1' \(\Leftarrow\) || 'corl_xtpl_helgaker_2' || etc.; Indicates the basis set extrapolation scheme to be applied to the delta correction; to the correlation energy.; Defaults to corl_xtpl_helgaker_2() if two valid basis sets; present in del",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/api/psi4.driver.cbs.html:7991,energy,energy,7991,psi4manual/1.6.x/api/psi4.driver.cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/api/psi4.driver.cbs.html,3,['energy'],['energy']
Energy Efficiency,"]¶; Class to store the elements, coordinates, fragmentation pattern,; charge, multiplicity of a molecule. Largely replicates psi4’s libmints; Molecule class, developed by Justin M. Turney and Andy M. Simmonett; with incremental improvements by other psi4 developers. Major; differences from the C++ class are: no basisset handling, no symmetry,; no pubchem, no efp, no discarding dummies. This class translated so; that databases can function independently of psi4.; >>> H2OH2O = qcdb.Molecule(""""""; 0 1; O1 -1.551007 -0.114520 0.000000; H1 -1.934259 0.762503 0.000000; H2 -0.599677 0.040712 0.000000; --; 0 1; X 0.000000 0.000000 0.000000; O2 1.350625 0.111469 0.000000; H3 1.680398 -0.373741 -0.758561; H4 1.680398 -0.373741 0.758561; no_com; no_reorient; units angstrom; """"""). >>> H2O = qcdb.Molecule.init_with_xyz('h2o.xyz'). FullPointGroupList = ['ATOM', 'C_inf_v', 'D_inf_h', 'C1', 'Cs', 'Ci', 'Cn', 'Cnv', 'Cnh', 'Sn', 'Dn', 'Dnd', 'Dnh', 'Td', 'Oh', 'Ih']¶. Z(atom)[source]¶; Nuclear charge of atom (0-indexed); >>> print H2OH2O.Z(4); 1. activate_all_fragments()[source]¶; Sets all fragments in the molecule to be active. add_atom(Z, x, y, z, label='', mass=0.0, charge=0.0, lineno=-1)[source]¶; Add an atom to the molecule; Z atomic number; x cartesian coordinate; y cartesian coordinate; z cartesian coordinate; symb atomic symbol to use; mass mass to use if non standard; charge charge to use if non standard; lineno line number when taken from a string. atom_at_position(b, tol=0.05)[source]¶; Tests to see of an atom is at the passed position b in Bohr with a tolerance tol.; >>> print H2OH2O.atom_at_position([1.35*(1.0/psi_bohr2angstroms), 0.10*(1.0/psi_bohr2angstroms), 0.0*(1.0/psi_bohr2angstroms)]); 3. atom_entry(atom)[source]¶; Returns the CoordEntry for an atom. atom_to_unique(iatom)[source]¶; Converts an atom number to the number of its generating unique atom.; The return value is in [0, nunique). atom_to_unique_offset(iatom)[source]¶; Converts an atom number to the offset o",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_driver-1.html:74959,charge,charge,74959,psi4manual/1.0.0/autodoc_driver-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_driver-1.html,2,['charge'],['charge']
Energy Efficiency,"]¶; Class to store the elements, coordinates, fragmentation pattern,; charge, multiplicity of a molecule. Largely replicates psi4’s libmints; Molecule class, developed by Justin M. Turney and Andy M. Simmonett; with incremental improvements by other psi4 developers. Major; differences from the C++ class are: no basisset handling, no symmetry,; no pubchem, no efp, no discarding dummies. This class translated so; that databases can function independently of psi4.; >>> H2OH2O = qcdb.Molecule(""""""; 0 1; O1 -1.551007 -0.114520 0.000000; H1 -1.934259 0.762503 0.000000; H2 -0.599677 0.040712 0.000000; --; 0 1; X 0.000000 0.000000 0.000000; O2 1.350625 0.111469 0.000000; H3 1.680398 -0.373741 -0.758561; H4 1.680398 -0.373741 0.758561; no_com; no_reorient; units angstrom; """"""). >>> H2O = qcdb.Molecule.init_with_xyz('h2o.xyz'). FullPointGroupList = ['ATOM', 'C_inf_v', 'D_inf_h', 'C1', 'Cs', 'Ci', 'Cn', 'Cnv', 'Cnh', 'Sn', 'Dn', 'Dnd', 'Dnh', 'Td', 'Oh', 'Ih']¶. Z(atom)[source]¶; Nuclear charge of atom (0-indexed); >>> print H2OH2O.Z(4); 1. activate_all_fragments()[source]¶; Sets all fragments in the molecule to be active. add_atom(Z, x, y, z, label='', mass=0.0, charge=0.0, lineno=-1)[source]¶; Add an atom to the molecule; Z atomic number; x cartesian coordinate; y cartesian coordinate; z cartesian coordinate; symb atomic symbol to use; mass mass to use if non standard; charge charge to use if non standard; lineno line number when taken from a string. atom_at_position(b, tol=0.05)[source]¶; Tests to see of an atom is at the passed position b in Bohr with a tolerance tol.; >>> print H2OH2O.atom_at_position([1.35*(1.0/psi_bohr2angstroms), 0.10*(1.0/psi_bohr2angstroms), 0.0*(1.0/psi_bohr2angstroms)]); 3. atom_entry(atom)[source]¶; Returns the CoordEntry for an atom. atom_to_unique(iatom)[source]¶; NYI Converts an atom number to the number of its generating unique atom.; The return value is in [0, nunique). atom_to_unique_offset(iatom)[source]¶; NYI Converts an atom number to the ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/autodoc_driver-1.html:44118,charge,charge,44118,psi4manual/4.0b5/autodoc_driver-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodoc_driver-1.html,2,['charge'],['charge']
Energy Efficiency,"]¶; Function to return validated Cotton ordering index from string or integer; irreducible representation irrep. physconst¶; # Do not modify this file! It is auto-generated by the document_options_and_tests; # script, from psi4topdir/include/physconst.h; psi_h = 6.62606896E-34 # The Planck constant (Js) ; psi_c = 2.99792458E8 # Speed of light (ms$^{-1}$) ; psi_kb = 1.3806504E-23 # The Boltzmann constant (JK$^{-1}$) ; psi_R = 8.314472 # Universal gas constant (JK$^{-1}$mol$^{-1}$) ; psi_bohr2angstroms = 0.52917720859 # Bohr to Angstroms conversion factor ; psi_bohr2m = 0.52917720859E-10 # Bohr to meters conversion factor ; psi_bohr2cm = 0.52917720859E-8 # Bohr to centimeters conversion factor ; psi_amu2g = 1.660538782E-24 # Atomic mass units to grams conversion factor ; psi_amu2kg = 1.660538782E-27 # Atomic mass units to kg conversion factor ; psi_au2amu = 5.485799097E-4 # Atomic units (m$@@e$) to atomic mass units conversion factor ; psi_hartree2J = 4.359744E-18 # Hartree to joule conversion factor ; psi_hartree2aJ = 4.359744 # Hartree to attojoule (10$^{-18}$J) conversion factor ; psi_cal2J = 4.184 # Calorie to joule conversion factor ; psi_dipmom_au2si = 8.47835281E-30 # Atomic units to SI units (Cm) conversion factor for dipoles ; psi_dipmom_au2debye = 2.54174623 # Atomic units to Debye conversion factor for dipoles ; psi_dipmom_debye2si = 3.335640952E-30 # Debye to SI units (Cm) conversion factor for dipoles ; psi_c_au = 137.035999679 # Speed of light in atomic units ; psi_hartree2ev = 27.21138 # Hartree to eV conversion factor ; psi_hartree2wavenumbers = 219474.6 # Hartree to cm$^{-1}$ conversion factor ; psi_hartree2kcalmol = 627.5095 # Hartree to kcal mol$^{-1}$ conversion factor ; psi_hartree2MHz = 6.579684E9 # Hartree to MHz conversion factor ; psi_kcalmol2wavenumbers = 349.7551 # kcal mol$^{-1}$ to cm$^{-1}$ conversion factor ; psi_e0 = 8.854187817E-12 # Vacuum permittivity (Fm$^{-1}$) ; psi_na = 6.02214179E23 # Avagadro's number ; psi_me = 9.10938215E-31 #",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/autodoc_driver-1.html:10385,joule,joule,10385,psi4manual/4.0b2/autodoc_driver-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/autodoc_driver-1.html,2,['joule'],['joule']
Energy Efficiency,"]¶; Gives the number of functions for an angular momentum based on pu.; #define INT_NFUNC(pu,am) ((pu)?INT_NPURE(am):INT_NCART(am)). INT_NPURE(am)[source]¶; Gives the number of spherical functions for an angular momentum.; #define INT_NPURE(am) (2*(am)+1). class ShellInfo(am, c, e, pure, nc, center, start, pt='Normalized')[source]¶; This class has the same behavior as GaussianShell, but implements everything using; slower data structures, which are easier to construct. These are used to build the; basis set, which builds more efficient pointer-based GaussianShell objects.; @param e An array of exponent values.; @param am Angular momentum.; @param pure Pure spherical harmonics, or Cartesian.; @param c An array of contraction coefficients.; @param nc The atomic center that this shell is located on. Must map; back to the correct atom in the owning BasisSet molecule. Used; in integral derivatives for indexing.; @param center The x, y, z position of the shell. This is passed to; reduce the number of calls to the molecule.; @param start The starting index of the first function this shell; provides. Used to provide starting positions in matrices.; @param pt Is the shell already normalized?. AMCHAR()[source]¶; The character symbol for the angular momentum of the given contraction (upper case). am()[source]¶; The angular momentum of the given contraction. amchar()[source]¶; The character symbol for the angular momentum of the given contraction. center()[source]¶; Returns the center of the Molecule this shell is on. coef(pi)[source]¶; Return coefficient of pi’th primitive. coefs()[source]¶; Return coefficient of pi’th primitive and ci’th contraction. contraction_normalization()[source]¶; Normalizes an entire contraction set. Applies the normalization to the coefficients; * @param gs The contraction set to normalize. copy(nc=None, c=None)[source]¶; Make a copy of the ShellInfo. erd_coef(pi)[source]¶; Return ERD normalized coefficient of pi’th primitive. erd_normalize_shell()[so",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_driver-1.html:100106,reduce,reduce,100106,psi4manual/1.0.0/autodoc_driver-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_driver-1.html,2,['reduce'],['reduce']
Energy Efficiency,"]¶; Makes a copy of the molecule, returning a new molecule with; only certain fragment atoms present as either ghost or real atoms; reals: The list or int of fragments (1-indexed) that should be present in the molecule as real atoms.; ghosts: The list or int of fragments (1-indexed) that should be present in the molecule as ghosts.; (method name in libmints is extract_subsets. This is different; in qcdb because the psi4 input parser tries to process lines with; that term, giving rise to Boost:Python type conlicts.) See usage; at extract_fragments(). extract_subsets(reals, ghosts=[])[source]¶; Wrapper for extract_fragments().; See note there. This function can be used as long as not; in psi4 input file. Use extract_fragments directly, then.; >>> H2OH2O.extract_subsets(2) # monomer B, unCP-corrected; >>> H2OH2O.extract_subsets(2,1) # monomer B, CP-corrected; >>> obj.extract_subsets(1,[2,3]) # monomer A, CP-corrected if obj is tri-molecular complex. fZ(atom)[source]¶; Nuclear charge of atom (includes dummies); >>> print H2OH2O.fZ(4); 8. fcharge(atom)[source]¶; Returns charge of atom (0-indexed, includes dummies).; Related to SAD guess in libmints version.; >>> print H2OH2O.fcharge(4); 8.0. find_highest_point_group(tol=1e-08)[source]¶; Find the highest D2h point group from Jet and Ed’s code: c1; ci c2 cs d2 c2v c2h d2h. Ignore the user-specified subgroup in; this case. find_point_group(tol=1e-08)[source]¶; Find computational molecular point group, user can override; this with the “symmetry” keyword. Result is highest D2h subgroup; attendant on molecule and allowed by the user. fix_orientation(_fix=True)[source]¶; Fix the orientation at its current frame; (method name in libmints is set_orientation_fixed). flabel(atom)[source]¶; Returns the original label of the atom (0-indexed) as given in; the input file (C2, H4) (includes dummies); >>> print H2OH2O.flabel(4); O2. fmass(atom)[source]¶; Returns mass of atom (0-indexed, includes dummies); >>> print H2OH2O.fmass(4); 15.99",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_driver-1.html:78756,charge,charge,78756,psi4manual/1.0.0/autodoc_driver-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_driver-1.html,2,['charge'],['charge']
Energy Efficiency,"]¶; Makes a copy of the molecule, returning a new molecule with; only certain fragment atoms present as either ghost or real atoms; reals: The list or int of fragments (1-indexed) that should be present in the molecule as real atoms.; ghosts: The list or int of fragments (1-indexed) that should be present in the molecule as ghosts.; (method name in libmints is extract_subsets. This is different; in qcdb because the psi4 input parser tries to process lines with; that term, giving rise to Boost:Python type conlicts.) See usage; at extract_fragments(). extract_subsets(reals, ghosts=[])[source]¶; Wrapper for extract_fragments().; See note there. This function can be used as long as not; in psi4 input file. Use extract_fragments directly, then.; >>> H2OH2O.extract_subsets(2) # monomer B, unCP-corrected; >>> H2OH2O.extract_subsets(2,1) # monomer B, CP-corrected; >>> obj.extract_subsets(1,[2,3]) # monomer A, CP-corrected if obj is tri-molecular complex. fZ(atom)[source]¶; Nuclear charge of atom (includes dummies); >>> print H2OH2O.fZ(4); 8. fcharge(atom)[source]¶; Returns charge of atom (0-indexed, includes dummies).; Related to SAD guess in libmints version.; >>> print H2OH2O.fcharge(4); 8.0. find_highest_point_group(tol=1e-08)[source]¶; NYI Find highest molecular point group. find_point_group(tol=1e-08)[source]¶; NYI Find computational molecular point group,; user can override this with the “symmetry” keyword. fix_orientation(_fix=True)[source]¶; Fix the orientation at its current frame; (method name in libmints is set_orientation_fixed). flabel(atom)[source]¶; Returns the original label of the atom (0-indexed) as given in; the input file (C2, H4) (includes dummies); >>> print H2OH2O.flabel(4); O2. fmass(atom)[source]¶; Returns mass of atom (0-indexed, includes dummies); >>> print H2OH2O.fmass(4); 15.9949146196. form_symmetry_information(tol=1e-08)[source]¶; NYI Initialize molecular specific symmetry information.; Uses the point group object obtain by calling point_group",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/autodoc_driver-1.html:43875,charge,charge,43875,psi4manual/4.0b3/autodoc_driver-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodoc_driver-1.html,6,['charge'],['charge']
Energy Efficiency,"^+\) state of the CN radical, with Z-matrix input. scf-hess4; DF SCF 6-31G UHFl vs RHF test Tests DF UHF hessian code for Ca = Cb. sapt7; SAPT0 open-shell computation of H2O-HO2 interaction energy First with cc-pVDZ and density fitted integrals with UHF Then with 6-31g and direct integrals, except for dispersion that is computed with cc-pVDZ-ri density fitting with UHF. opt-irc-2; Compute the IRC for HCN <-> NCH interconversion at the RHF/DZP level of theory. sapt-exch-disp-inf; SAPT0 with S^inf exch-disp20. dct-grad3; Restricted DF-DCT ODC-12 gradient for ethylene with cc-pVDZ/cc-pVDZ-RI standard/auxiliary basis set. fsapt1; This test case shows an example of running and analyzing a standard F-SAPT0/jun-cc-pvdz procedure for phenol dimer from the S22 database. dft-custom; DFT custom functional test. dfep2-1; Compute three IP and 2 EA’s for the PH3 molecule. cc30; CCSD/sto-3g optical rotation calculation (length gauge only) at two frequencies on methyloxirane. dfccd1; DF-CCD cc-pVDZ energy for the H2O molecule. sad1; Test of the superposition of atomic densities (SAD) guess, using a highly distorted water geometry with a cc-pVDZ basis set. This is just a test of the code and the user need only specify guess=sad to the SCF module’s (or global) options in order to use a SAD guess. The test is first performed in C2v symmetry, and then in C1. cc47; EOM-CCSD/cc-pVDZ on H2O2 with two excited states in each irrep. scf-bs; UHF and broken-symmetry UHF energy for molecular hydrogen. dft-grad-lr3; wB97X-D test for a large UKS molecule update ref gradient due to new BraggSlater radii. dft-grad1; DF-BP86-D2 cc-pVDZ frozen core gradient of S22 HCN update ref gradient due to new BraggSlater radii. mbis-5; MBIS calculation on ZnO. lccd-grad1; LCCD cc-pVDZ gradient for the H2O molecule. omp2-2; OMP2 cc-pVDZ energy with ROHF initial guess orbitals for the NO radical. dfomp2-grad2; OMP2 cc-pVDZ energy for the NO molecule. ci-property; CI/MCSCF cc-pvDZ properties for Potassium nitrate ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/autodoc_testsuite_corepsi4-1.html:31945,energy,energy,31945,psi4manual/1.5.0/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/autodoc_testsuite_corepsi4-1.html,4,['energy'],['energy']
Energy Efficiency,"^{(0)} | \Psi_{0}^{(1)} \rangle - \langle \Psi_{0}^{(1)} | \hat{H}^{(0)} - E_{0}^{(0)} | \Psi_{0}^{(1)} \rangle = \min_{| \Psi_{0}^{(1)} \rangle}.\]; Determining the optimal \(| \Psi_{0}^{(1)} \rangle\) entails iteratively; minimizing the following residual [Pulay:1986:357]:. (2)¶\[R_{ij}^{ab} = (ia|jb) + (\epsilon_a + \epsilon_b - f_{ii} - f_{jj})t_{ij}^{ab} - \sum_{k \ne j} f_{ik} \sum_{c,d} S_{ac}t_{kj}^{c,d}S_{db} - \sum_{k \ne i} f_{kj} \sum_{cd} S_{ac}t_{ik}^{cd}S_{db}\]; where i, j, and k are (not necessarily canonical) occupied orbitals, a,; b, c, and d are virtual orbitals, \(f_{ij}\) are fock matrix elements,; \(S_{ab}\) are orbital overlaps, and finally \(t_{ij}^{ab}\) are the MP2; amplitudes to be solved for. Virtual orbitals may be different for each pair; of occupied orbitals. For a given occupied orbital pair ij, all virtuals are; orthogonal and canonical, but virtuals belonging to different pair domains; may not be orthogonal.; The following expression is used to evaluate the energy of a given set of amplitudes:. (3)¶\[\begin{split}E^{(2)} &= \sum_{i,j} e_{ij}, \\; e_{ij} &= \sum_{a, b}((ia|jb) + R_{ij}^{ab})(2t_{ij}^{ab} - t_{ij}^{ba}).\end{split}\]; The error in \(E^{(2)}\) scales quadratically with the error in the amplitudes.; No local approximations have been made so far, and this iterative approach can; be used to exactly determine \(E^{(2)}\) with \({\cal O}(N^5)\) cost.; In DLPNO-MP2, the first local approximation is to screen distant, non-interacting; orbital pairs ij. Orbital pairs are screened if below both an overlap criteria:. (4)¶\[DOI_{ij} \equiv \sqrt{\int d\mathbf{r} | \chi_{i}(\mathbf{r}) | ^{2} | \chi_{j}(\mathbf{r}) | ^{2}},\]; and a pair energy estimate:. (5)¶\[e_{ij}^{approx} = -\frac{4}{R^{6}} \sum_{a_{i} \in [i],b_{j} \in [j]} \frac{ (2 \langle i | \mathbf{r} | a_{i} \rangle \langle j | \mathbf{r} | b_{j} \rangle)^{2}}{\epsilon_{a_{i}} + \epsilon_{b_{j}} - f_{ii} - f_{jj}},\]; in which small domains of virtual orbitals are use",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/dlpnomp2-1.html:4170,energy,energy,4170,psi4manual/1.5.0/dlpnomp2-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/dlpnomp2-1.html,7,['energy'],['energy']
Energy Efficiency,"^{\infty} + \beta e^{-\alpha X}, \alpha = 1.63`. References; ----------. .. [1] Halkier, Helgaker, Jorgensen, Klopper, & Olsen, Chem. Phys. Lett. 302 (1999) 437-446,; DOI: 10.1016/S0009-2614(99)00179-7. Examples; --------; >>> # [1] Hartree-Fock extrapolation; >>> psi4.energy('cbs', scf_wfn='hf', scf_basis='cc-pV[DT]Z', scf_scheme='scf_xtpl_helgaker_2'). """""". if type(valueLO) != type(valueHI):; raise ValidationError(; f""scf_xtpl_helgaker_2: Inputs must be of the same datatype! ({type(valueLO)}, {type(valueHI)})""). if alpha is None:; alpha = 1.63. beta_division = 1 / (math.exp(-1 * alpha * zLO) * (math.exp(-1 * alpha) - 1)); beta_mult = math.exp(-1 * alpha * zHI). if isinstance(valueLO, float):; beta = (valueHI - valueLO) * beta_division; value = valueHI - beta * beta_mult. if verbose:; # Output string with extrapolation parameters; cbsscheme = ''; cbsscheme += """"""\n ==> Helgaker 2-point exponential SCF extrapolation for method: %s <==\n\n"""""" % (; functionname.upper()); cbsscheme += """""" LO-zeta (%s) Energy: % 16.12f\n"""""" % (str(zLO), valueLO); cbsscheme += """""" HI-zeta (%s) Energy: % 16.12f\n"""""" % (str(zHI), valueHI); cbsscheme += """""" Alpha (exponent) Value: % 16.12f\n"""""" % (alpha); cbsscheme += """""" Beta (coefficient) Value: % 16.12f\n\n"""""" % (beta). name_str = ""%s/(%s,%s)"" % (functionname.upper(), _zeta_val2sym[zLO].upper(), _zeta_val2sym[zHI].upper()); cbsscheme += """""" @Extrapolated """"""; cbsscheme += name_str + ':'; cbsscheme += "" "" * (18 - len(name_str)); cbsscheme += """"""% 16.12f\n\n"""""" % value; core.print_out(cbsscheme); logger.debug(cbsscheme). return value. elif isinstance(valueLO, np.ndarray):. beta = (valueHI - valueLO) * beta_division; value = valueHI - beta * beta_mult. if verbose > 2:; cbsscheme = f""""""\n ==> Helgaker 2-point exponential SCF extrapolation for method: {functionname.upper()} <==\n""""""; cbsscheme += f""""""\n LO-zeta ({zLO}) Data\n""""""; cbsscheme += nppp(valueLO); cbsscheme += f""""""\n HI-zeta ({zHI}) Data\n""""""; cbsscheme += nppp(valueHI). cbsscheme +=",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver_cbs_helper.html:5271,Energy,Energy,5271,psi4manual/1.6.x/_modules/psi4/driver/driver_cbs_helper.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver_cbs_helper.html,5,['Energy'],['Energy']
Energy Efficiency,"^{\infty} + \beta e^{-\alpha\sqrt{X}}, \alpha = 6.3`. References; ----------. .. [3] Karton, Martin, Theor. Chem. Acc. 115 (2006) 330-333,; DOI: 10.1007/s00214-005-0028-6. """""". if type(valueLO) != type(valueHI):; raise ValidationError(; f""scf_xtpl_karton_2: Inputs must be of the same datatype! ({type(valueLO)}, {type(valueHI)})""). if alpha is None:; alpha = 6.30. # prior to April 2022, this wrong expression was used; # beta_division = 1 / (math.exp(-1 * alpha) * (math.exp(math.sqrt(zHI)) - math.exp(math.sqrt(zLO)))); beta_division = 1 / (math.exp(-1 * alpha * math.sqrt(zHI)) - math.exp(-1 * alpha * math.sqrt(zLO))); beta_mult = math.exp(-1 * alpha * math.sqrt(zHI)). if isinstance(valueLO, float):; beta = (valueHI - valueLO) * beta_division; value = valueHI - beta * beta_mult. if verbose:; # Output string with extrapolation parameters; cbsscheme = ''; cbsscheme += """"""\n ==> Karton 2-point power form SCF extrapolation for method: %s <==\n\n"""""" % (; functionname.upper()); cbsscheme += """""" LO-zeta (%s) Energy: % 16.12f\n"""""" % (str(zLO), valueLO); cbsscheme += """""" HI-zeta (%s) Energy: % 16.12f\n"""""" % (str(zHI), valueHI); cbsscheme += """""" Alpha (exponent) Value: % 16.12f\n"""""" % (alpha); cbsscheme += """""" Beta (coefficient) Value: % 16.12f\n\n"""""" % (beta). name_str = ""%s/(%s,%s)"" % (functionname.upper(), _zeta_val2sym[zLO].upper(), _zeta_val2sym[zHI].upper()); cbsscheme += """""" @Extrapolated """"""; cbsscheme += name_str + ':'; cbsscheme += "" "" * (18 - len(name_str)); cbsscheme += """"""% 16.12f\n\n"""""" % value; core.print_out(cbsscheme); logger.debug(cbsscheme). return value. elif isinstance(valueLO, np.ndarray):. beta = (valueHI - valueLO) * beta_division; value = valueHI - beta * beta_mult. if verbose > 2:; cbsscheme = f""""""\n ==> Karton 2-point power SCF extrapolation for method: {functionname.upper()} <==\n""""""; cbsscheme += f""""""\n LO-zeta ({zLO}) Data\n""""""; cbsscheme += nppp(valueLO); cbsscheme += f""""""\n HI-zeta ({zHI}) Data\n""""""; cbsscheme += nppp(valueHI). cbsscheme += f""""""\n ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver_cbs_helper.html:11913,Energy,Energy,11913,psi4manual/1.6.x/_modules/psi4/driver/driver_cbs_helper.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver_cbs_helper.html,5,['Energy'],['Energy']
Energy Efficiency,"^{\kappa}\) defined as. \[\begin{split}\hat{H}^{\kappa} &= e^{-\hat{K}} \hat{H} e^{\hat{K}} \\; \hat{f}_{N}^{\kappa} &= e^{-\hat{K}} \hat{f}_{N}^{d} e^{\hat{K}} \\; \hat{W}_{N}^{\kappa} &= e^{-\hat{K}} \hat{W}_{N} e^{\hat{K}}\end{split}\]; where \(\hat{f}_{N}\), and \(\hat{W}_{N}\) are the one- and two-electron components of normal-ordered Hamiltonian. Then,; first and second derivatives of the energy with respect to the \({\bf \kappa}\) parameter at \({\bf \kappa} = 0\). \[w_{pq} = \frac{\partial \widetilde{E}}{\partial \kappa_{pq}}\]. \[A_{pq,rs} = \frac{\partial^2 \widetilde{E}}{\partial \kappa_{pq} \partial \kappa_{rs}}\]; Then the energy can be expanded up to second-order as follows. \[\widetilde{E}^{(2)}({\bf \kappa}) = \widetilde{E}^{(0)} + {\bf \kappa^{\dagger} w} + \frac{1}{2}~{\bf \kappa^{\dagger} A \kappa}\]; where \({\bf w}\) is the MO gradient vector, \({\bf \kappa}\) is the MO rotation vector,; and \({\bf A}\) is the MO Hessian matrix. Therefore, minimizing the energy with respect to \({\bf \kappa}\); yields. \[{\bf \kappa} = -{\bf A^{-1}w}\]; This final equation corresponds to the usual Newton-Raphson step. OREMP. The REMP hybrid perturbation theory is a constrained mixture of the Møller–Plesset perturbation theory and the; Retaining the Excitation degree perturbation theory([Fink:2006:RE], [Behnle:2019:REMP]).; The mixing ratio is determined by the parameter :math’:A:. \[\widehat{H}^{(0)}_\text{REMP} = (1-A)\widehat{H}^{(0)}_\text{RE} + A\widehat{H}^{(0)}_\text{MP}\]; Technically, the second order of RE corresponds to LCCD for RHF and UHF references. REMP2 and its orbital-optimized variant OREMP2; are thus straightforward to implement in a (O)LCCD program by appropriate scaling of residual vector contributions and density matrices. OMP2 [Bozkaya:2011:omp2] and [Bozkaya:2013:omp2grad]; OMP3 [Bozkaya:2011:omp3] , [Bozkaya:2013:omp3], and [Bozkaya:2013:omp3grad]; OMP2.5 [Bozkaya:2011:omp3]; OLCCD [Bozkaya:2013:ocepa]; LCCD [Bozkaya:2013:ocepa]; OREMP2 [B",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/occ.html:8150,energy,energy,8150,psi4manual/1.7.x/occ.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/occ.html,4,['energy'],['energy']
Energy Efficiency,"^{\kappa}\) defined as. \[\begin{split}\hat{H}^{\kappa} &= e^{-\hat{K}} \hat{H} e^{\hat{K}} \\; \hat{f}_{N}^{\kappa} &= e^{-\hat{K}} \hat{f}_{N}^{d} e^{\hat{K}} \\; \hat{W}_{N}^{\kappa} &= e^{-\hat{K}} \hat{W}_{N} e^{\hat{K}}\end{split}\]; where \(\hat{f}_{N}\), and \(\hat{W}_{N}\) are the one- and two-electron components of normal-ordered Hamiltonian. Then,; first and second derivatives of the energy with respect to the \({\bf \kappa}\) parameter at \({\bf \kappa} = 0\). \[w_{pq} = \frac{\partial \widetilde{E}}{\partial \kappa_{pq}}\]. \[A_{pq,rs} = \frac{\partial^2 \widetilde{E}}{\partial \kappa_{pq} \partial \kappa_{rs}}\]; Then the energy can be expanded up to second-order as follows. \[\widetilde{E}^{(2)}({\bf \kappa}) = \widetilde{E}^{(0)} + {\bf \kappa^{\dagger} w} + \frac{1}{2}~{\bf \kappa^{\dagger} A \kappa}\]; where \({\bf w}\) is the MO gradient vector, \({\bf \kappa}\) is the MO rotation vector,; and \({\bf A}\) is the MO Hessian matrix. Therefore, minimizing the energy with respect to \({\bf \kappa}\); yields. \[{\bf \kappa} = -{\bf A^{-1}w}\]; This final equation corresponds to the usual Newton-Raphson step.; Publications resulting from the use of the orbital-optimized code should cite the following publications:. OMP2 [Bozkaya:2011:omp2] and [Bozkaya:2013:omp2grad]; OMP3 [Bozkaya:2011:omp3] , [Bozkaya:2013:omp3], and [Bozkaya:2013:omp3grad]; OMP2.5 [Bozkaya:2011:omp3]; OLCCD [Bozkaya:2013:ocepa]; LCCD [Bozkaya:2013:ocepa]. Convergence Problems¶; For problematic open-shell systems, we recommend to use the ROHF or DFT orbitals as an initial guess for orbital-optimized methods. Both ROHF and; DFT orbitals may provide better initial guesses than UHF orbitals, hence convergence may be significantly speeded up with ROHF or DFT orbitals.; In order to use ROHF orbitals, simply set reference rohf. For DFT orbitals, set reference uks and set dft_functional b3lyp. Of; course users can use any DFT functional available in PSI4. Methods¶; The orbital-optimized MPn a",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/occ-1.html:8069,energy,energy,8069,psi4manual/1.1.0/occ-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/occ-1.html,11,['energy'],['energy']
Energy Efficiency,"_ = core.Wavefunction.build(wfn.molecule(), core.get_global_option('BASIS')); wfn_.deep_copy(wfn); refwfn = wfn.reference_wavefunction(); wfn_.set_reference_wavefunction(refwfn) # refwfn not deep_copied; wfn_.Ca().copy(refwfn.Ca()); wfn_.Cb().copy(refwfn.Cb()); wfn_.epsilon_a().copy(refwfn.epsilon_a()); wfn_.epsilon_b().copy(refwfn.epsilon_b()); fw = core.FCHKWriter(wfn_); else:; fw = core.FCHKWriter(wfn). if module_ in ['DCT', 'DFOCC']:; core.print_out(""""""FCHKWriter: Caution! For orbital-optimized correlated methods; the 'Orbital Energy' field contains ambiguous data. \n""""""). # At this point we don't know the method name, so we try to search for it.; # idea: get the method from the variable matching closely the 'current energy'; # for varlist, wfn is long-term and to allow from-file wfns. core is b/c some modules not storing in wfn yet; varlist = {**wfn.scalar_variables(), **core.scalar_variables()}; current = varlist['CURRENT ENERGY']. # delete problematic entries; for key in ['CURRENT ENERGY', 'CURRENT REFERENCE ENERGY']:; varlist.pop(key, None). # find closest matching energy; for (key, val) in varlist.items():; if (np.isclose(val, current, 1e-12)):; method = key.split()[0]; break. # The 'official' list of labels for compatibility.; # OMP2,MP2.5,OCCD, etc get reduced to MP2,CC.; allowed_labels = {; ""HF"": "" SCF Density"",; ""SCF"": "" SCF Density"",; ""DFT"": "" SCF Density"",; ""MP2"": "" MP2 Density"",; ""MP3"": "" MP3 Density"",; ""MP4"": "" MP4 Density"",; ""CI"": "" CI Density"",; ""CC"": "" CC Density"",; }; # assign label from method name; fchk_label = f"" {method} Density""; if strict_label:; in_list = False; for key in allowed_labels:; if key in method:; if key is not method:; core.print_out(f""FCHKWriter: !WARNING! method '{method}'' renamed to label '{key}'.\n""); fchk_label = allowed_labels[key]; in_list = True; if not in_list:; core.print_out(f""FCHKWriter: !WARNING! {method} is not recognized. Using non-standard label.\n""); core.print_out(f""FCHKWriter: Writing {filename} with label '",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver.html:90084,ENERGY,ENERGY,90084,psi4manual/1.6.x/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver.html,10,['ENERGY'],['ENERGY']
Energy Efficiency,"_). _zeta_val2sym = {k + 2: v for k, v in enumerate('dtq5678')}; Extrapolatable = Union[float, core.Matrix, core.Vector]. [docs]; def xtpl_highest_1(functionname: str, zHI: int, valueHI: Extrapolatable, verbose: int = 1, **kwargs) -> Extrapolatable:; r""""""Scheme for total or correlation energies with a single basis or the highest; zeta-level among an array of bases. Used by :py:func:`~psi4.driver.cbs`. Parameters; ----------; functionname; Name of the CBS component (e.g., 'mp2') used in summary printing.; zHI; Zeta-level, only used for printing.; valueHI; Energy, gradient, or Hessian value at the basis set.; verbose; Controls volume of printing. Returns; -------; float or ~numpy.ndarray; Returns :math:`E_{total}^{\infty}` which is equal to valueHI.; Eponymous function applied to input zetas and values; type from `valueHI`. Notes; -----; .. math:: E_{total}^X = E_{total}^{\infty}. Examples; --------; >>> # [1] Fancy way to get HF/cc-pCVQZ; >>> psi4.energy('cbs', scf_wfn='hf', scf_basis='cc-pcvqz', scf_scheme='xtpl_highest_1'). """"""; if isinstance(valueHI, float):. if verbose:; # Output string with extrapolation parameters; cbsscheme = ''; cbsscheme += f""""""\n ==> {functionname.upper()} <==\n\n""""""; cbsscheme += f"""""" HI-zeta ({zHI}) Energy: {valueHI: 16.12f}\n"""""". core.print_out(cbsscheme); logger.debug(cbsscheme). return valueHI. elif isinstance(valueHI, np.ndarray):. if verbose > 2:; cbsscheme = f""""""\n ==> {functionname.upper()} <==\n\n""""""; cbsscheme += f"""""" HI-zeta ({zHI}) Data\n""""""; cbsscheme += nppp(valueHI); core.print_out(cbsscheme); logger.debug(cbsscheme). return valueHI. [docs]; def scf_xtpl_helgaker_2(functionname: str, zLO: int, valueLO: Extrapolatable, zHI: int, valueHI: Extrapolatable, verbose: int = 1, alpha: Optional[float] = None) -> Extrapolatable:; r""""""Extrapolation scheme using exponential form for reference energies with two adjacent; zeta-level bases. Used by :py:func:`~psi4.driver.cbs`. Parameters; ----------; functionname; Name of the CBS component ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs_helper.html:2530,energy,energy,2530,psi4manual/1.8.x/_modules/psi4/driver/driver_cbs_helper.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs_helper.html,6,['energy'],['energy']
Energy Efficiency,"_1(arg0: psi::Molecule, arg1: list, arg2: int) → psi::Matrix¶; Performs a finite difference frequency computation, from gradients, for a given irrep. psi4.core.fd_geoms_1_0(arg0: psi::Molecule) → List[psi::Matrix]¶; Gets list of displacements needed for a finite difference gradient computation, from energy points. psi4.core.fd_geoms_freq_0(arg0: psi::Molecule, arg1: int) → List[psi::Matrix]¶; Gets list of displacements needed for a finite difference frequency computation, from energy points, for a given irrep. psi4.core.fd_geoms_freq_1(arg0: psi::Molecule, arg1: int) → List[psi::Matrix]¶; Gets list of displacements needed fof a finite difference frequency computation, from gradients, for a given irrep. psi4.core.finalize() → None¶. psi4.core.fisapt(arg0: psi::Wavefunction) → float¶; Runs the functional-group intramolecular symmetry adapted perturbation theory code. psi4.core.flush_outfile() → None¶; Flushes the output file. psi4.core.fnocc(arg0: psi::Wavefunction) → psi::Wavefunction¶; Runs the fno-ccsd(t)/qcisd(t)/mp4/cepa energy code. psi4.core.get_active_efp() → psi4.core.EFP¶; Returns the currently active EFP object. psi4.core.get_active_molecule() → psi::Molecule¶; Returns the currently active molecule object. psi4.core.get_array_variable(arg0: str) → psi::Matrix¶; Returns one of the PSI variables set internally by the modules or python driver (see manual for full listing of variables available). psi4.core.get_array_variables() → Dict[str, psi::Matrix]¶; Returns dictionary of the PSI variables set internally by the modules or python driver. psi4.core.get_atomic_point_charges() → psi::Vector¶; Returns the most recently computed atomic point charges, as a double * object. psi4.core.get_efp_torque() → psi::Matrix¶; Returns the most recently computed gradient for the EFP portion, as a Nefp by 6 Matrix object. psi4.core.get_environment(arg0: str) → str¶; Get enviromental vairable. psi4.core.get_frequencies() → psi::Vector¶; Returns the most recently computed frequen",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/psi4api-1.html:148910,energy,energy,148910,psi4manual/1.1.0/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/psi4api-1.html,2,['energy'],['energy']
Energy Efficiency,"_1); \phi_\nu (\vec r_1)\]; The most popular variants are Generalized Gradient Approximation (GGA); functionals which use the norm of the density gradient; \(\gamma_{\alpha\alpha}\), \(\gamma_{\alpha\beta}\) or; \(\gamma_{\beta\beta}\) to build an inhomogeneity; parameter. \[\gamma_{\alpha\alpha} (\vec r_1) = \nabla \rho_{\alpha} (\vec r_1) \cdot \nabla; \rho_{\alpha} (\vec r_1)\]. \[\gamma_{\alpha\beta} (\vec r_1) = \nabla \rho_{\alpha} (\vec r_1) \cdot \nabla; \rho_{\beta} (\vec r_1)\]; where,. \[\nabla \rho_{\sigma} (\vec r_1) = 2 D_{\mu\nu}^{\sigma} \phi_{\mu}; (\vec r_1) \nabla \phi_{\nu} (\vec r_1)\]; GGA functionals are essentially the same cost as LSDA functionals and are often; considerably more accurate.; Another local variant which has gained some popularity (though perhaps not as; much as GGA functionals) is the meta approximation, in which information about; the second derivative of the density is incorporated. The most canonical variant; of these functionals rely on the spin kinetic energy density \(\tau_\alpha\); and \(\tau_\beta\),. \[\tau_\sigma(\vec r_1) = \sum_{i} \left | \nabla \psi_i^{\sigma} (\vec r_1) \right | ^2; = \sum_{i} \left | C_{\mu i}^{\sigma} \nabla \phi_{\mu} (\vec r_1) \right |; ^2 = D_{\mu\nu}^{\sigma} \nabla \phi_{\mu} (\vec r_1) \cdot \nabla; \phi_{\nu} (\vec r_1)\]; A generic local meta-GGA functional may then be written as,. \[E_{\mathrm{xc}}^{\mathrm{DFA}} = \int_{\mathbb{R}^3} f_{\mathrm{xc}}; \left(; \rho_{\alpha} (\vec r_1),; \rho_{\beta} (\vec r_1),; \gamma_{\alpha\alpha} (\vec r_1),; \gamma_{\alpha\beta} (\vec r_1),; \gamma_{\beta\beta} (\vec r_1),; \tau_{\alpha} (\vec r_1),; \tau_{\beta} (\vec r_1); \right) \ \mathrm{d} ^3 r_1\]; The potential corresponding to this energy functional is,. \[ \begin{align}\begin{aligned}V_{\mu\nu}^{\mathrm{xc},\alpha} =\\\int_{\mathbb{R}^3}; \left(\frac{\partial f}{\rho_\alpha}\right); \phi_{\mu}; \phi_{\nu}; \ \mathrm{d} ^3 r_1\end{aligned}\end{align} \]. \[+; \int_{\mathbb{R}^3}; \left(2 ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/dft-1.html:4195,energy,energy,4195,psi4manual/1.2.1/dft-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/dft-1.html,15,['energy'],['energy']
Energy Efficiency,"_2. :type delta2_scheme: function; :param delta2_scheme: |dl| ``xtpl_highest_1`` |dr| || ``corl_xtpl_helgaker_2`` || etc. Indicates the basis set extrapolation scheme to be applied to the second delta correction; to the correlation energy.; Defaults to :py:func:`~corl_xtpl_helgaker_2` if two valid basis sets; present in ``delta2_basis`` and :py:func:`~xtpl_highest_1` otherwise. .. hlist::; :columns: 1. * xtpl_highest_1; * corl_xtpl_helgaker_2. :type delta3_scheme: function; :param delta3_scheme: |dl| ``xtpl_highest_1`` |dr| || ``corl_xtpl_helgaker_2`` || etc. Indicates the basis set extrapolation scheme to be applied to the third delta correction; to the correlation energy.; Defaults to :py:func:`~corl_xtpl_helgaker_2` if two valid basis sets; present in ``delta3_basis`` and :py:func:`~xtpl_highest_1` otherwise. :type delta4_scheme: function; :param delta4_scheme: |dl| ``xtpl_highest_1`` |dr| || ``corl_xtpl_helgaker_2`` || etc. Indicates the basis set extrapolation scheme to be applied to the fourth delta correction; to the correlation energy.; Defaults to :py:func:`~corl_xtpl_helgaker_2` if two valid basis sets; present in ``delta4_basis`` and :py:func:`~xtpl_highest_1` otherwise. :type delta5_scheme: function; :param delta5_scheme: |dl| ``xtpl_highest_1`` |dr| || ``corl_xtpl_helgaker_2`` || etc. Indicates the basis set extrapolation scheme to be applied to the fifth delta correction; to the correlation energy.; Defaults to :py:func:`~corl_xtpl_helgaker_2` if two valid basis sets; present in ``delta5_basis`` and :py:func:`~xtpl_highest_1` otherwise. :type scf_alpha: float. Overrides the default \alpha parameter used in the listed SCF extrapolation procedures.; Has no effect on others, including :py:func:`~xtpl_highest_1` and :py:func:`~scf_xtpl_helgaker_3`. .. hlist::; :columns: 1. * :py:func:`scf_xtpl_helgaker_2`; * :py:func:`scf_xtpl_truhlar_2`; * :py:func:`scf_xtpl_karton_2`. :type corl_alpha: float. Overrides the default \alpha parameter used in the listed :py:",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/driver_cbs.html:34285,energy,energy,34285,psi4manual/1.2.1/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/driver_cbs.html,1,['energy'],['energy']
Energy Efficiency,"_2^2)|\Psi_0\rangle = 0. \\\end{split}\]; QCISD is slightly cheaper that CCSD computationally, but it retains the; \({\cal{O}}(o^2v^4)\) complexity of the original equations. Just as in; the familiar CCSD(T) method, the effects of connected triple excitations; may be included noniteratively to yield the QCISD(T) method. Both the; QCISD(T) and CCSD(T) methods are implemented for closed-shell references; in the FNOCC module. Many-body perturbation theory¶; QCI and CC methods are closely related to perturbation theory, and the; MP2, MP3, and MP4(SDQ) correlation energies can be obtained as a free; by-product of a CCSD or QCISD computation. The following is an; example of the results for a computation run with the call; energy('fno-qcisd') to energy():; QCISD iterations converged!. OS MP2 FNO correction: -0.000819116338; SS MP2 FNO correction: -0.000092278158; MP2 FNO correction: -0.000911394496. OS MP2 correlation energy: -0.166478414245; SS MP2 correlation energy: -0.056669079827; MP2 correlation energy: -0.223147494072; * MP2 total energy: -76.258836941658. OS MP2.5 correlation energy: -0.171225850256; SS MP2.5 correlation energy: -0.054028401038; MP2.5 correlation energy: -0.225254251294; * MP2.5 total energy: -76.260943698880. OS MP3 correlation energy: -0.175973286267; SS MP3 correlation energy: -0.051387722248; MP3 correlation energy: -0.227361008515; * MP3 total energy: -76.263050456101. OS MP4(SDQ) correlation energy: -0.180324322304; SS MP4(SDQ) correlation energy: -0.048798468084; MP4(SDQ) correlation energy: -0.230995119324; * MP4(SDQ) total energy: -76.266684566910. OS QCISD correlation energy: -0.181578117924; SS QCISD correlation energy: -0.049853548145; QCISD correlation energy: -0.231431666069; * QCISD total energy: -76.267121113654. The first set of energies printed corresponds to the second-order FNO; correction mentioned previously. Results for many-body perturbation; theory through partial fourth order are then provided.; The notation MP4(SDQ) indica",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/fnocc-1.html:5531,energy,energy,5531,psi4manual/1.4.0/fnocc-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/fnocc-1.html,9,['energy'],['energy']
Energy Efficiency,"_ALPHA to a value. For example,; set exch_scale_alpha 1.0. will set and scale exchange energies with .; Instead of this straightforward scaling, SAPT0 energies benefit from a slightly modified; recipe that involves an empirically adjusted exponent .; To distinguish it from its unscaled counterpart, this energy is denoted sSAPT0 (see [Parker:2014:094106]). (8); where is computed without any scaling. Please note that; sSAPT0 is thus not the same as requesting exch_scale_alpha 3.0. A First Example¶; The following is the simplest possible input that will perform all; available SAPT computations (normally, you would pick one of these methods).; molecule water_dimer {; 0 1; O -1.551007 -0.114520 0.000000; H -1.934259 0.762503 0.000000; H -0.599677 0.040712 0.000000; --; 0 1; O 1.350625 0.111469 0.000000; H 1.680398 -0.373741 -0.758561; H 1.680398 -0.373741 0.758561. units angstrom; no_reorient; symmetry c1; }. set globals {; basis aug-cc-pvdz; }. energy('sapt0'); energy('sapt2'); energy('sapt2+'); energy('sapt2+(3)'); energy('sapt2+3'). The SAPT module uses the standard Psi4 partitioning of the dimer; into monomers. SAPT does not use spatial symmetry and needs the geometry; of the system to remain fixed throughout monomer and dimer calculations.; These requirements are imposed whenever a SAPT calculation is requested; but can also be set explicitly with the no_reorient and symmetry; c1 molecule keywords, as in the example above. A final note is that the; SAPT module is only capable of performing SAPT computations for; interactions between closed-shell singlets.; The example input shown above would not be used in practice.; To exploit the efficiency of the density-fitted SAPT implementation in; Psi4, the SCF computations should also be performed with density-fitted; (DF) integrals.; set globals {; basis aug-cc-pvdz; df_basis_scf aug-cc-pvdz-jkfit; df_basis_sapt aug-cc-pvdz-ri; guess sad; scf_type df; }. set sapt {; print 1; }. These options will perform the SAPT computatio",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/sapt-1.html:6105,energy,energy,6105,psi4manual/1.0.0/sapt-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/sapt-1.html,10,['energy'],['energy']
Energy Efficiency,_CONV (CFOUR). CFOUR_SCF_DAMPING (CFOUR). CFOUR_SCF_EXPORDER (CFOUR). CFOUR_SCF_EXPSTART (CFOUR). CFOUR_SCF_EXTRAPOLATION (CFOUR). CFOUR_SCF_MAXCYC (CFOUR). CFOUR_SD_FIELD (CFOUR). CFOUR_SPHERICAL (CFOUR). CFOUR_SPIN_FLIP (CFOUR). CFOUR_SPIN_ORBIT (CFOUR). CFOUR_SPIN_SCAL (CFOUR). CFOUR_SPINROTATION (CFOUR). CFOUR_SUBGROUP (CFOUR). CFOUR_SYM_CHECK (CFOUR). CFOUR_SYMMETRY (CFOUR). CFOUR_T3_EXTRAPOL (CFOUR). CFOUR_TAMP_SUM (CFOUR). CFOUR_THERMOCHEMISTRY (CFOUR). CFOUR_TRANS_INV (CFOUR). CFOUR_TREAT_PERT (CFOUR). CFOUR_UIJ_THRESHOLD (CFOUR). CFOUR_UNITS (CFOUR). CFOUR_UPDATE_HESSIAN (CFOUR). CFOUR_VIBRATION (CFOUR). CFOUR_VTRAN (CFOUR). CFOUR_XFIELD (CFOUR). CFOUR_XFORM_TOL (CFOUR). CFOUR_YFIELD (CFOUR). CFOUR_ZFIELD (CFOUR). cg_solver() in module psi4.driver.p4util. chain_dot() psi4.core.Matrix method. change_file_namespace() psi4.core.IO static method. char_table() psi4.core.PointGroup method. character() psi4.core.IrreducibleRepresentation method. CharacterTable class in psi4.core. charge. ; molecule. charge() psi4.core.Molecule method. check_phases() psi4.core.HF method. CheMPS2. CHOLESKY (DFOCC). cholesky_factorize() psi4.core.Matrix method. CHOLESKY_TOLERANCE (DFOCC). (FNOCC). (SCF). CI. arbitrary-order coupled-cluster theory. arbitrary-order perturbation theory. basic-keywords. multi-configurational self-consistent-field. spin multiplicities of higher roots. theory. CI CORRELATION ENERGY. CI DIPOLE. CI QUADRUPOLE. CI ROOT n -> ROOT m DIPOLE. CI ROOT n -> ROOT m QUADRUPOLE. CI ROOT n CORRELATION ENERGY. CI ROOT n DIPOLE. CI ROOT n QUADRUPOLE. CI ROOT n TOTAL ENERGY. CI STATE-AVERAGED CORRELATION ENERGY. CI STATE-AVERAGED TOTAL ENERGY. CI TOTAL ENERGY. CI_DIIS (MCSCF). CI_FILE_START (DETCI). CI_MAXITER (DETCI). ci_nat_orbs() psi4.core.CIWavefunction method. CI_NUM_THREADS (DETCI). CI_TYPE (GLOBALS). CIBLKS_PRINT (DETCI). CIn CORRELATION ENERGY. CIn TOTAL ENERGY. CISD CORRELATION ENERGY. CISD DIPOLE. CISD DOUBLES ENERGY. CISD OPPOSITE-SPIN CORRELATION ENERGY. CISD ,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/genindex.html:23746,charge,charge,23746,psi4manual/1.7.x/genindex.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/genindex.html,2,['charge'],['charge']
Energy Efficiency,"_HOMO;; psi4.IO.change_file_namespace(180,""ot"",""neutral""). # Cation; if (read):; psi4.set_global_option(""GUESS"", ""READ""); p4util.copy_file_to_scratch(read180, 'psi', 'ot', 180). mol.set_molecular_charge(charge1); mol.set_multiplicity(mult1); psi4.print_out('\n\t==> IP Fitting SCF: Cation, Right Endpoint <==\n'); E1r = energy('scf'); psi4.IO.change_file_namespace(180,""ot"",""cation""). IPr = E1r - E0r;; kIPr = -E_HOMOr;; delta_r = IPr - kIPr;. if (IPr > kIPr):; psi4.print_out('\n***IP Fitting Error: Right Omega limit should have kIP > IP'); sys.exit(1). omegas.append(omega_r); types.append('Right Limit'); E0s.append(E0r); E1s.append(E1r); IPs.append(IPr); kIPs.append(kIPr). # Use previous orbitals from here out; psi4.set_global_option(""GUESS"",""READ""). # Left endpoint; psi4.set_global_option('DFT_OMEGA',omega_l). # Neutral; psi4.IO.change_file_namespace(180,""neutral"",""ot""); mol.set_molecular_charge(charge0); mol.set_multiplicity(mult0); psi4.print_out('\n\t==> IP Fitting SCF: Neutral, Left Endpoint <==\n'); E0l = energy('scf'); ref = psi4.wavefunction(); eps_a = ref.epsilon_a(); eps_b = ref.epsilon_b(); E_HOMO = 0.0;; if (Nb == 0):; E_HOMO = eps_a[int(Na-1)]; else:; E_a = eps_a[int(Na - 1)]; E_b = eps_b[int(Nb - 1)]; if (E_a >= E_b):; E_HOMO = E_a;; else:; E_HOMO = E_b;; E_HOMOl = E_HOMO;; psi4.IO.change_file_namespace(180,""ot"",""neutral""). # Cation; psi4.IO.change_file_namespace(180,""cation"",""ot""); mol.set_molecular_charge(charge1); mol.set_multiplicity(mult1); psi4.print_out('\n\t==> IP Fitting SCF: Cation, Left Endpoint <==\n'); E1l = energy('scf'); psi4.IO.change_file_namespace(180,""ot"",""cation""). IPl = E1l - E0l;; kIPl = -E_HOMOl;; delta_l = IPl - kIPl;. if (IPl < kIPl):; psi4.print_out('\n***IP Fitting Error: Left Omega limit should have kIP < IP'); sys.exit(1). omegas.append(omega_l); types.append('Left Limit'); E0s.append(E0l); E1s.append(E1l); IPs.append(IPl); kIPs.append(kIPl). converged = False; repeat_l = 0;; repeat_r = 0;; step = 0;; while True:. step = step +",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/frac.html:14834,energy,energy,14834,psi4manual/4.0b5/_modules/frac.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/frac.html,2,['energy'],['energy']
Energy Efficiency,"_INTS_IO', ri_ints_io); psioh.set_specific_retention(97, False); PsiMod.clean(); activate(molecule). if bsse == 'on' or bsse == 'both':; return energies_n_full[Ns[0]]; else:; return energies_n_mon[Ns[0]]. ## Aliases ##; nbody = n_body. #####################; ## End of n_body ##; #####################. ###################; ## Start of cp ##; ###################. [docs]def cp(name, **kwargs):; r""""""The cp function computes counterpoise-corrected two-body interaction energies; for complexes composed of arbitrary numbers of monomers. :aliases: counterpoise_correct(), counterpoise_correction(). :returns: (*float*) Counterpoise-corrected interaction energy in Hartrees. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`CP-CORRECTED 2-BODY INTERACTION ENERGY <CP-CORRECTED2-BODYINTERACTIONENERGY>`; * :psivar:`UNCP-CORRECTED 2-BODY INTERACTION ENERGY <UNCP-CORRECTED2-BODYINTERACTIONENERGY>`. .. caution:: Some features are not yet implemented. Buy a developer a coffee. - No values of func besides energy have been tested. - Table print-out needs improving. Add some PSI variables. :type name: string; :param name: ``'scf'`` || ``'ccsd(t)'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the molecule. May be any valid argument to; :py:func:`~driver.energy`; however, SAPT is not appropriate. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``energy`` |dr| || ``optimize`` || ``cbs``. Indicates the type of calculation to be performed on the molecule; and each of its monomers. The default performs a single-point; ``energy('name')``, while ``optimize`` perfoms a geometry optimization; on each system, and ``cbs`` performs a compound single-point energy.; If a nested series of python functions is intended; (see :ref:`sec:intercalls`), use keyword ``cp_func`` instead of ``func``. :type check_bsse: :ref:`boolean <op_py_boolean>`; :param check_bsse: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether to additionally compute un-",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/_modules/wrappers.html:16914,energy,energy,16914,psi4manual/4.0b3/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/_modules/wrappers.html,4,['energy'],['energy']
Energy Efficiency,"_INTS_IO', ri_ints_io); psioh.set_specific_retention(97, False); PsiMod.clean(); activate(molecule). if bsse == 'on' or bsse == 'both':; return energies_n_full[Ns[0]]; else:; return energies_n_mon[Ns[0]]. ## Aliases ##; nbody = n_body. #####################; ## End of n_body ##; #####################. ###################; ## Start of cp ##; ###################. [docs]def cp(name, **kwargs):; r""""""The cp function computes counterpoise-corrected two-body interaction energies; for complexes composed of arbitrary numbers of monomers. :aliases: counterpoise_correct(), counterpoise_correction(). :returns: (*float*) Counterpoise-corrected interaction energy in kcal/mol. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`CP-CORRECTED 2-BODY INTERACTION ENERGY <CP-CORRECTED2-BODYINTERACTIONENERGY>`; * :psivar:`UNCP-CORRECTED 2-BODY INTERACTION ENERGY <UNCP-CORRECTED2-BODYINTERACTIONENERGY>`. .. caution:: Some features are not yet implemented. Buy a developer a coffee. - No values of func besides energy have been tested. - Table print-out needs improving. Add some PSI variables. :type name: string; :param name: ``'scf'`` || ``'ccsd(t)'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the molecule. May be any valid argument to; :py:func:`~driver.energy`; however, SAPT is not appropriate. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``energy`` |dr| || ``optimize`` || ``cbs``. Indicates the type of calculation to be performed on the molecule; and each of its monomers. The default performs a single-point; ``energy('name')``, while ``optimize`` perfoms a geometry optimization; on each system, and ``cbs`` performs a compound single-point energy.; If a nested series of python functions is intended; (see :ref:`sec:intercalls`), use keyword ``cp_func`` instead of ``func``. :type check_bsse: :ref:`boolean <op_py_boolean>`; :param check_bsse: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether to additionally compute un-",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:16907,energy,energy,16907,psi4manual/4.0b2/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html,2,['energy'],['energy']
Energy Efficiency,"_OCCUPATION. Specifies the orbital occupancy of the reference function in terms of the occupation numbers of the orbitals and their irreducible representations. The occupancy is specified by either NIRREP or 2*NIRREP integers specifying the number of occupied orbitals of each symmetry type, where NIRREP is the number of irreducible representations in the computational point group. If there are no orbitals of a particular symmetry type a zero must be entered. If the reference function is for an open-shell system, two strings of NIRREP occupation numbers separated by a slash are input for the \(\alpha\) and \(\beta\) sets of orbitals. An example of the use of the OCCUPATION keyword for the water molecule would be OCCUPATION=3-1-1-0. For the \(^2A_1\) water cation, an open-shell system, the keyword would be specified by OCCUPATION=3-1-1-0/2-1-1-0. It should be noted that the xvmol integral program orders the irreducible representations in a strange way, which most users do not perceive to be a logical order. Hence, it is usually advisable initially to run just a single point integral and HF-SCF calculation in order to determine the number and ordering of the irreducible representations. The occupation keyword may be omitted, in which case an initial orbital occupancy is determined by diagonalization of the core Hamiltonian. In many cases, HF-SCF calculations run with the core Hamiltonian guess will usually converge to the lowest energy HF-SCF solution, but this should not be blindly assumed. (Default: The occupation is given by the core Hamiltonian initial guess). Psi4 Interface: The arrays above are specified in PSI as (white space tolerant) [3,1,1,0] and [[3,1,1,0],[3,0,1,0]]. Type: array; Default: No Default. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Appendices; Keywords by Module; CFOUR. © Copyright 2018, The Psi4 Project.; Last updated on Wednesday, 25 July 2018 04:21AM.; Created using Sphinx 1.7.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/autodir_options_c/cfour__cfour_occupation-1.html:1579,energy,energy,1579,psi4manual/1.2.1/autodir_options_c/cfour__cfour_occupation-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/autodir_options_c/cfour__cfour_occupation-1.html,2,['energy'],['energy']
Energy Efficiency,"_OMP_NUM_THREADS'):; lenv['OMP_NUM_THREADS'] = str(core.get_option('MRCC', 'MRCC_OMP_NUM_THREADS')). # Call dmrcc, directing all screen output to the output file; external_exe = 'dmrcc'; try:; retcode = subprocess.Popen([external_exe], bufsize=0, stdout=subprocess.PIPE, env=lenv); except OSError as e:; sys.stderr.write('Program %s not found in path or execution failed: %s\n' % (external_exe, e.strerror)); core.print_out('Program %s not found in path or execution failed: %s\n' % (external_exe, e.strerror)); message = (""Program %s not found in path or execution failed: %s\n"" % (external_exe, e.strerror)); raise ValidationError(message). c4out = ''; while True:; data = retcode.stdout.readline(); if not data:; break; core.print_out(data.decode('utf-8')); c4out += data.decode('utf-8'). # Scan iface file and grab the file energy.; ene = 0.0; for line in open('iface'):; fields = line.split(); m = fields[1]; try:; ene = float(fields[5]); if m == ""MP(2)"":; m = ""MP2""; core.set_variable(m + ' TOTAL ENERGY', ene); core.set_variable(m + ' CORRELATION ENERGY', ene - vscf); except ValueError:; continue. # The last 'ene' in iface is the one the user requested.; core.set_variable('CURRENT ENERGY', ene); core.set_variable('CURRENT CORRELATION ENERGY', ene - vscf). # Load the iface file; iface = open('iface', 'r'); iface_contents = iface.read(). # Delete mrcc tempdir; os.chdir('..'); try:; # Delete unless we're told not to; if (keep is False and not('path' in kwargs)):; shutil.rmtree(mrcc_tmpdir); except OSError as e:; print('Unable to remove MRCC temporary directory %s' % e, file=sys.stderr); exit(1). # Return to submission directory; os.chdir(current_directory). # If we're told to keep the files or the user provided a path, do nothing.; if keep or ('path' in kwargs):; core.print_out('\nMRCC scratch files have been kept.\n'); core.print_out('They can be found in ' + mrcc_tmpdir). # Dump iface contents to output; core.print_out('\n'); p4util.banner('Full results from MRCC'); core.print",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:159614,ENERGY,ENERGY,159614,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,1,['ENERGY'],['ENERGY']
Energy Efficiency,"_ORBS') == False and PsiMod.get_option('FNOCC','RUN_MP2') == False:; PsiMod.set_local_option('TRANSQT2', 'WFN', 'CCSD'); PsiMod.transqt2(). # run ccsd; PsiMod.fnocc(). # set current correlation energy and total energy. only need to treat mpn here.; if (lowername == 'fnocc-mp') and (level == 3):; emp3 = PsiMod.get_variable(""MP3 TOTAL ENERGY""); cemp3 = PsiMod.get_variable(""MP3 CORRELATION ENERGY""); PsiMod.set_variable(""CURRENT ENERGY"",emp3); PsiMod.set_variable(""CURRENT CORRELATION ENERGY"",cemp3); elif ( lowername == 'fno-mp3' ):; emp3 = PsiMod.get_variable(""MP3 TOTAL ENERGY""); cemp3 = PsiMod.get_variable(""MP3 CORRELATION ENERGY""); PsiMod.set_variable(""CURRENT ENERGY"",emp3); PsiMod.set_variable(""CURRENT CORRELATION ENERGY"",cemp3); elif ( lowername == 'mp4(sdq)'):; emp4sdq = PsiMod.get_variable(""MP4(SDQ) TOTAL ENERGY""); cemp4sdq = PsiMod.get_variable(""MP4(SDQ) CORRELATION ENERGY""); PsiMod.set_variable(""CURRENT ENERGY"",emp4sdq); PsiMod.set_variable(""CURRENT CORRELATION ENERGY"",cemp4sdq); elif ( lowername == 'fno-mp4(sdq)'):; emp4sdq = PsiMod.get_variable(""MP4(SDQ) TOTAL ENERGY""); cemp4sdq = PsiMod.get_variable(""MP4(SDQ) CORRELATION ENERGY""); PsiMod.set_variable(""CURRENT ENERGY"",emp4sdq); PsiMod.set_variable(""CURRENT CORRELATION ENERGY"",cemp4sdq); elif ( lowername == 'fno-mp4'):; emp4 = PsiMod.get_variable(""MP4 TOTAL ENERGY""); cemp4 = PsiMod.get_variable(""MP4 CORRELATION ENERGY""); PsiMod.set_variable(""CURRENT ENERGY"",emp4); PsiMod.set_variable(""CURRENT CORRELATION ENERGY"",cemp4); elif (lowername == 'fnocc-mp') and (level == 4):; emp4 = PsiMod.get_variable(""MP4 TOTAL ENERGY""); cemp4 = PsiMod.get_variable(""MP4 CORRELATION ENERGY""); PsiMod.set_variable(""CURRENT ENERGY"",emp4); PsiMod.set_variable(""CURRENT CORRELATION ENERGY"",cemp4). # restore symmetry for fno-cc; if (PsiMod.get_option('FNOCC','NAT_ORBS')):; molecule.reset_point_group(user_pg); molecule.update_geometry(). # restore options; optstash.restore(). return PsiMod.get_variable(""CURRENT ENERGY""). [docs]def run_cepa(n",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/_modules/proc.html:75104,ENERGY,ENERGY,75104,psi4manual/4.0b4/_modules/proc.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/proc.html,1,['ENERGY'],['ENERGY']
Energy Efficiency,"_POINTS¶. Number of colatitude grid points for sphereical potential integration. Type: integer; Default: 360. THICKNESS¶. Thickness (bohr) of a hard-sphere external potential. Type: double; Default: 20.0. DFSCF Algorithm¶. DF_BUMP_R0¶. Bump function min radius. Type: double; Default: 0.0. DF_BUMP_R1¶. Bump function max radius. Type: double; Default: 0.0. DF_DOMAINS¶. FastDF geometric fitting domain selection algorithm. Type: string; Possible Values: DIATOMIC, SPHERES; Default: DIATOMIC. DF_INTS_NUM_THREADS¶. Number of threads for integrals (may be turned down if memory is an issue). 0 is blank. Type: integer; Default: 0. DF_METRIC¶. FastDF Fitting Metric. Type: string; Possible Values: COULOMB, EWALD, OVERLAP; Default: COULOMB. DF_THETA¶. FastDF SR Ewald metric range separation parameter. Type: double; Default: 1.0. SAD Guess Algorithm¶. SAD_D_CONVERGENCE¶. Convergence criterion for SCF density in SAD Guess. Type: conv double; Default: 1e-5. SAD_E_CONVERGENCE¶. Convergence criterion for SCF energy in SAD Guess. Type: conv double; Default: 1e-5. DFT¶. DFT_ALPHA¶. The DFT Exact-exchange parameter. Type: double; Default: 0.0. DFT_ALPHA_C¶. The DFT Correlation hybrid parameter. Type: double; Default: 0.0. DFT_BASIS_TOLERANCE¶. DFT basis cutoff. Type: conv double; Default: 1.0e-12. DFT_BS_RADIUS_ALPHA¶. Factor for effective BS radius in radial grid. Type: double; Default: 1.0. DFT_CUSTOM_FUNCTIONAL¶. A custom DFT functional object (built by Python or NULL/None). Type: python; Default: No Default. DFT_DISPERSION_PARAMETERS¶. Parameters defining the dispersion correction. See Table -D Functionals for default values and Table Dispersion Corrections for the order in which parameters are to be specified in this array option. Type: array; Default: No Default. DFT_FUNCTIONAL¶. The DFT combined functional name, e.g. B3LYP, or GEN to use a python reference to a custom functional specified by DFT_CUSTOM_FUNCTIONAL. Type: string; Default: No Default. DFT_NUCLEAR_SCHEME¶. Nuclear Sch",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodir_options_c/module__scf-1.html:9538,energy,energy,9538,psi4manual/1.0.0/autodir_options_c/module__scf-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodir_options_c/module__scf-1.html,2,['energy'],['energy']
Energy Efficiency,"_POINTS¶. Number of colatitude grid points for sphereical potential integration. Type: integer; Default: 360. THICKNESS¶. Thickness (bohr) of a hard-sphere external potential. Type: double; Default: 20.0. DFSCF Algorithm¶. DF_BUMP_R0¶. Bump function min radius. Type: double; Default: 0.0. DF_BUMP_R1¶. Bump function max radius. Type: double; Default: 0.0. DF_DOMAINS¶. FastDF geometric fitting domain selection algorithm. Type: string; Possible Values: DIATOMIC, SPHERES; Default: DIATOMIC. DF_INTS_NUM_THREADS¶. Number of threads for integrals (may be turned down if memory is an issue). 0 is blank. Type: integer; Default: 0. DF_METRIC¶. FastDF Fitting Metric. Type: string; Possible Values: COULOMB, EWALD, OVERLAP; Default: COULOMB. DF_THETA¶. FastDF SR Ewald metric range separation parameter. Type: double; Default: 1.0. SAD Guess Algorithm¶. SAD_D_CONVERGENCE¶. Convergence criterion for SCF density in SAD Guess. Type: conv double; Default: 1e-5. SAD_E_CONVERGENCE¶. Convergence criterion for SCF energy in SAD Guess. Type: conv double; Default: 1e-5. DFT¶. DFT_ALPHA¶. The DFT Exact-exchange parameter. Type: double; Default: 0.0. DFT_BASIS_TOLERANCE¶. DFT basis cutoff. Type: conv double; Default: 1.0e-12. DFT_BS_RADIUS_ALPHA¶. Factor for effective BS radius in radial grid. Type: double; Default: 1.0. DFT_CUSTOM_FUNCTIONAL¶. A custom DFT functional object (built by Python or NULL/None). Type: python; Default: No Default. DFT_DISPERSION_PARAMETERS¶. Parameters defining the dispersion correction. See Table -D Functionals for default values and Table Dispersion Corrections for the order in which parameters are to be specified in this array option. Type: array; Default: No Default. DFT_FUNCTIONAL¶. The DFT combined functional name, e.g. B3LYP, or GEN to use a python reference to a custom functional specified by DFT_CUSTOM_FUNCTIONAL. Type: string; Default: No Default. DFT_NUCLEAR_SCHEME¶. Nuclear Scheme. Type: string; Possible Values: TREUTLER, BECKE, NAIVE, STRATMANN; Default: ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/autodir_options_c/module__scf-1.html:7983,energy,energy,7983,psi4manual/4.0b5/autodir_options_c/module__scf-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/module__scf-1.html,4,['energy'],['energy']
Energy Efficiency,"_ROOT¶. Do turn on root following for CC3. Type: boolean; Default: false. CC_NUM_THREADS¶. Number of threads. Type: integer; Default: 1. COLLAPSE_WITH_LAST¶. Do collapse with last vector?. Type: boolean; Default: true. COMPLEX_TOLERANCE¶. Complex tolerance applied in CCEOM computations. Type: conv double; Default: 1e-12. EOM_GUESS¶. Specifies a set of single-excitation guess vectors for the EOM-CC procedure. If EOM_GUESS = SINGLES, the guess will be taken from the singles-singles block of the similarity-transformed Hamiltonian, Hbar. If EOM_GUESS = DISK, guess vectors from a previous computation will be read from disk. If EOM_GUESS = INPUT, guess vectors will be specified in user input. The latter method is not currently available. Type: string; Possible Values: SINGLES, DISK, INPUT; Default: SINGLES. EOM_REFERENCE¶. Reference wavefunction type for EOM computations. Type: string; Possible Values: RHF, ROHF, UHF; Default: RHF. E_CONVERGENCE¶. Convergence criterion for excitation energy (change) in the Davidson algorithm for CC-EOM. See Table Post-SCF Convergence for default convergence criteria for different calculation types. Type: conv double; Default: 1e-6. FULL_MATRIX¶. Do use full effective Hamiltonian matrix?. Type: boolean; Default: false. LOCAL¶. Do simulate the effects of local correlation techniques?. Type: boolean; Default: false. LOCAL_CUTOFF¶. Value (always between one and zero) for the Broughton-Pulay completeness check used to contruct orbital domains for local-CC calculations. See J. Broughton and P. Pulay, J. Comp. Chem. 14, 736-740 (1993) and C. Hampel and H.-J. Werner, J. Chem. Phys. 104, 6286-6297 (1996). Type: double; Default: 0.02. LOCAL_DO_SINGLES¶. Type: boolean; Default: true. LOCAL_FILTER_SINGLES¶. Do apply local filtering to singles amplitudes?. Type: boolean; Default: true. LOCAL_GHOST¶. Permit ghost atoms to hold projected atomic orbitals to include in the virtual space in local-EOM-CCSD calculations. Type: integer; Default: -1. LOCAL_METH",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/autodir_options_c/module__cceom-1.html:1967,energy,energy,1967,psi4manual/1.3.2/autodir_options_c/module__cceom-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/autodir_options_c/module__cceom-1.html,12,['energy'],['energy']
Energy Efficiency,"_ROOT¶. Do turn on root following for CC3. Type: boolean; Default: false. CC_NUM_THREADS¶. Number of threads. Type: integer; Default: 1. COLLAPSE_WITH_LAST¶. Do collapse with last vector?. Type: boolean; Default: true. COMPLEX_TOLERANCE¶. Complex tolerance applied in CCEOM computations. Type: conv double; Default: 1e-12. EOM_GUESS¶. Specifies a set of single-excitation guess vectors for the EOM-CC procedure. If EOM_GUESS = SINGLES, the guess will be taken from the singles-singles block of the similarity-transformed Hamiltonian, Hbar. If EOM_GUESS = DISK, guess vectors from a previous computation will be read from disk. If EOM_GUESS = INPUT, guess vectors will be specified in user input. The latter method is not currently available. Type: string; Possible Values: SINGLES, DISK, INPUT; Default: SINGLES. EOM_REFERENCE¶. Reference wavefunction type for EOM computations. Type: string; Possible Values: RHF, ROHF, UHF; Default: RHF. E_CONVERGENCE¶. Convergence criterion for excitation energy (change) in the Davidson algorithm for CC-EOM. See Table Post-SCF Convergence for default convergence criteria for different calculation types. Type: conv double; Default: 1e-8. FULL_MATRIX¶. Do use full effective Hamiltonian matrix?. Type: boolean; Default: false. LOCAL¶. Do simulate the effects of local correlation techniques?. Type: boolean; Default: false. LOCAL_CUTOFF¶. Value (always between one and zero) for the Broughton-Pulay completeness check used to contruct orbital domains for local-CC calculations. See J. Broughton and P. Pulay, J. Comp. Chem. 14, 736-740 (1993) and C. Hampel and H.-J. Werner, J. Chem. Phys. 104, 6286-6297 (1996). Type: double; Default: 0.02. LOCAL_DO_SINGLES¶. Type: boolean; Default: true. LOCAL_FILTER_SINGLES¶. Do apply local filtering to singles amplitudes?. Type: boolean; Default: true. LOCAL_GHOST¶. Permit ghost atoms to hold projected atomic orbitals to include in the virtual space in local-EOM-CCSD calculations. Type: integer; Default: -1. LOCAL_METH",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/autodir_options_c/module__cceom-1.html:1973,energy,energy,1973,psi4manual/4.0b4/autodir_options_c/module__cceom-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/autodir_options_c/module__cceom-1.html,4,['energy'],['energy']
Energy Efficiency,"_ROOT¶. Do turn on root following for CC3. Type: boolean; Default: false. CC_NUM_THREADS¶. Number of threads. Type: integer; Default: 1. COLLAPSE_WITH_LAST¶. Do collapse with last vector?. Type: boolean; Default: true. COMPLEX_TOLERANCE¶. Complex tolerance applied in CCEOM computations. Type: conv double; Default: 1e-12. EOM_GUESS¶. Specifies a set of single-excitation guess vectors for the EOM-CC procedure. If EOM_GUESS = SINGLES, the guess will be taken from the singles-singles block of the similarity-transformed Hamiltonian, Hbar. If EOM_GUESS = DISK, guess vectors from a previous computation will be read from disk. If EOM_GUESS = INPUT, guess vectors will be specified in user input. The latter method is not currently available. Type: string; Possible Values: SINGLES, DISK, INPUT; Default: SINGLES. EOM_REFERENCE¶. Reference wavefunction type for EOM computations. Type: string; Possible Values: RHF, ROHF, UHF; Default: RHF. E_CONVERGENCE¶. Convergence criterion for excitation energy (change) in the Davidson algorithm for CC-EOM. Type: conv double; Default: 1e-8. FULL_MATRIX¶. Do use full effective Hamiltonian matrix?. Type: boolean; Default: false. LOCAL¶. Do simulate the effects of local correlation techniques?. Type: boolean; Default: false. LOCAL_CUTOFF¶. Value (always between one and zero) for the Broughton-Pulay completeness check used to contruct orbital domains for local-CC calculations. See J. Broughton and P. Pulay, J. Comp. Chem. 14, 736-740 (1993) and C. Hampel and H.-J. Werner, J. Chem. Phys. 104, 6286-6297 (1996). Type: double; Default: 0.02. LOCAL_DO_SINGLES¶. Type: boolean; Default: true. LOCAL_FILTER_SINGLES¶. Do apply local filtering to singles amplitudes?. Type: boolean; Default: true. LOCAL_GHOST¶. Permit ghost atoms to hold projected atomic orbitals to include in the virtual space in local-EOM-CCSD calculations. Type: integer; Default: -1. LOCAL_METHOD¶. Type of local-CCSD scheme to be simulated. WERNER selects the method developed by H.-J. Wern",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/autodir_options_c/module__cceom-1.html:1973,energy,energy,1973,psi4manual/4.0b3/autodir_options_c/module__cceom-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/module__cceom-1.html,4,['energy'],['energy']
Energy Efficiency,"_SCALE¶. Do F-SAPT induction scaling? (ratio of HF induction to F-SAPT induction). Type: boolean; Default: true. FISAPT_FSSAPT_FILEPATH¶. Filepath to drop sSAPT0 exchange-scaling F-SAPT data within input file directory. Type: string; Default: s-fsapt/. FISAPT_LINK_ASSIGNMENT¶. Where do sigma links go (to C or to AB)?. Type: string; Possible Values: C, AB; Default: C. FISAPT_LINK_SELECTION¶. Specification algorithm for link bonds in ISAPT. Type: string; Possible Values: AUTOMATIC, MANUAL; Default: AUTOMATIC. FISAPT_MANUAL_LINKS¶. Manual link bond specification [[Atom1, Atom2], …]. Type: array; Default: No Default. FISAPT_PLOT_FILEPATH¶. Filepath to drop scalar data within input file directory. Type: string; Default: plot/. INTS_TOLERANCE¶. Schwarz screening threshold. Mininum absolute value below which TEI are neglected. Type: conv double; Default: 0.0. LOCAL_CONVERGENCE¶. Relative convergence in orbital localization. Type: conv double; Default: 1.0e-12. LOCAL_IBO_POWER¶. IBO localization metric power. Type: integer; Default: 4. LOCAL_IBO_STARS¶. IBO Centers for Pi Degeneracy. Type: array; Default: No Default. LOCAL_IBO_STARS_COMPLETENESS¶. IBO Charge metric for classification as Pi. Type: double; Default: 0.90. LOCAL_IBO_USE_STARS¶. IBO Stars procedure. Type: boolean; Default: false. LOCAL_MAXITER¶. Maximum iterations in localization. Type: integer; Default: 1000. MAXITER¶. Maximum number of iterations for CPHF. Type: integer; Default: 50. SSAPT0_SCALE¶. Do sSAPT0 exchange-scaling with F-SAPT. Type: boolean; Default: false. Expert¶. CUBIC_BASIS_TOLERANCE¶. CubicScalarGrid basis cutoff. Type: conv double; Default: 1.0e-12. CUBIC_BLOCK_MAX_POINTS¶. CubicScalarGrid maximum number of grid points per evaluation block. Type: integer; Default: 1000. FISAPT_MEM_SAFETY_FACTOR¶. Memory safety factor for heavy FISAPT operations. Type: double; Default: 0.9. LOCAL_IBO_CONDITION¶. Condition number to use in IBO metric inversions. Type: double; Default: 1.0e-7. LOCAL_USE_GHOSTS¶. U",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/autodir_options_c/module__fisapt-1.html:2187,power,power,2187,psi4manual/1.3.2/autodir_options_c/module__fisapt-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/autodir_options_c/module__fisapt-1.html,14,['power'],['power']
Energy Efficiency,"_THREADS') == True:; lenv['OMP_NUM_THREADS'] = str(core.get_option('MRCC', 'MRCC_OMP_NUM_THREADS')). # Call dmrcc, directing all screen output to the output file; external_exe = 'dmrcc'; try:; retcode = subprocess.Popen([external_exe], bufsize=0, stdout=subprocess.PIPE, env=lenv); except OSError as e:; sys.stderr.write('Program %s not found in path or execution failed: %s\n' % (external_exe, e.strerror)); core.print_out('Program %s not found in path or execution failed: %s\n' % (external_exe, e.strerror)); message = (""Program %s not found in path or execution failed: %s\n"" % (external_exe, e.strerror)); raise ValidationError(message). c4out = ''; while True:; data = retcode.stdout.readline(); if not data:; break; core.print_out(data.decode('utf-8')); c4out += data.decode('utf-8'). # Scan iface file and grab the file energy.; ene = 0.0; for line in open('iface'):; fields = line.split(); m = fields[1]; try:; ene = float(fields[5]); if m == ""MP(2)"":; m = ""MP2""; core.set_variable(m + ' TOTAL ENERGY', ene); core.set_variable(m + ' CORRELATION ENERGY', ene - vscf); except ValueError:; continue. # The last 'ene' in iface is the one the user requested.; core.set_variable('CURRENT ENERGY', ene); core.set_variable('CURRENT CORRELATION ENERGY', ene - vscf). # Load the iface file; iface = open('iface', 'r'); iface_contents = iface.read(). # Delete mrcc tempdir; os.chdir('..'); try:; # Delete unless we're told not to; if (keep is False and not('path' in kwargs)):; shutil.rmtree(mrcc_tmpdir); except OSError as e:; print('Unable to remove MRCC temporary directory %s' % e, file=sys.stderr); exit(1). # Return to submission directory; os.chdir(current_directory). # If we're told to keep the files or the user provided a path, do nothing.; if (keep != False or ('path' in kwargs)):; core.print_out('\nMRCC scratch files have been kept.\n'); core.print_out('They can be found in ' + mrcc_tmpdir). # Dump iface contents to output; core.print_out('\n'); p4util.banner('Full results from MRCC');",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html:150987,ENERGY,ENERGY,150987,psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,2,['ENERGY'],['ENERGY']
Energy Efficiency,"_THREADS')). # Call dmrcc, directing all screen output to the output file; external_exe = 'dmrcc'; try:; retcode = subprocess.Popen([external_exe], bufsize=0, stdout=subprocess.PIPE, env=lenv); except OSError as e:; sys.stderr.write('Program %s not found in path or execution failed: %s\n' % (external_exe, e.strerror)); core.print_out('Program %s not found in path or execution failed: %s\n' % (external_exe, e.strerror)); message = (""Program %s not found in path or execution failed: %s\n"" % (external_exe, e.strerror)); raise ValidationError(message). c4out = ''; while True:; data = retcode.stdout.readline(); if not data:; break; core.print_out(data.decode('utf-8')); c4out += data.decode('utf-8'). # Scan iface file and grab the file energy.; ene = 0.0; for line in open('iface'):; fields = line.split(); m = fields[1]; try:; ene = float(fields[5]); if m == ""MP(2)"":; m = ""MP2""; elif m == ""CCSD[T]"":; m = ""CCSD+T(CCSD)""; elif m == ""CCSD(T)_L"":; m = ""A-CCSD(T)""; ref_wfn.set_variable(m + ' TOTAL ENERGY', ene); ref_wfn.set_variable(m + ' CORRELATION ENERGY', ene - vscf); except ValueError:; continue. # The last 'ene' in iface is the one the user requested.; ref_wfn.set_variable('CURRENT ENERGY', ene); ref_wfn.set_variable('CURRENT CORRELATION ENERGY', ene - vscf). for subm in [""MP2"", ""CCSD""]:; if ref_wfn.has_variable(f""{subm} TOTAL ENERGY"") and core.get_option(""SCF"", ""REFERENCE"") in [""RHF"", ""UHF""]:; ref_wfn.set_variable(f""{subm} SINGLES ENERGY"", 0.0); ref_wfn.set_variable(f""{subm} DOUBLES ENERGY"", ref_wfn.variable(f""{subm} CORRELATION ENERGY"")). if ref_wfn.has_variable(""CCSD(T) CORRELATION ENERGY"") and ref_wfn.has_variable(""CCSD CORRELATION ENERGY""):; ref_wfn.set_variable(""(T) CORRECTION ENERGY"", ref_wfn.variable(""CCSD(T) CORRELATION ENERGY"") - ref_wfn.variable(""CCSD CORRELATION ENERGY"")). if ref_wfn.has_variable(""A-CCSD(T) CORRELATION ENERGY"") and ref_wfn.has_variable(""CCSD CORRELATION ENERGY""):; ref_wfn.set_variable(""A-(T) CORRECTION ENERGY"", ref_wfn.variable(""A-CCSD(T) CORR",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:164475,ENERGY,ENERGY,164475,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,4,['ENERGY'],['ENERGY']
Energy Efficiency,"_TRIPLETS (CPHF); CPHF — Do triplet states? Default true. Type: boolean; Default: true. DOCC (GLOBALS); GLOBALS — An array containing the number of doubly-occupied orbitals per irrep (in Cotton order). Type: array; Default: No Default. DOCC (MCSCF); MCSCF — The number of doubly occupied orbitals, per irrep. Type: array; Default: No Default. DYNAMIC_LEVEL (OPTKING); OPTKING — Starting level for dynamic optimization (0=nondynamic, higher=>more conservative). Type: integer; Default: 0. E3_SCALE (DFOCC); DFOCC — CEPA opposite-spin scaling value from SCS-CCSD. Type: double; Default: 0.25. E3_SCALE (OCC); OCC — Scaling value for 3rd order energy correction (S. Grimme, Vol. 24, pp. 1529, J. Comput. Chem.). Type: double; Default: 0.25. E_CONVERGENCE (CCENERGY); CCENERGY — Convergence criterion for energy. See Table Post-SCF Convergence for default convergence criteria for different calculation types. Type: conv double; Default: 1e-6. E_CONVERGENCE (CCEOM); CCEOM — Convergence criterion for excitation energy (change) in the Davidson algorithm for CC-EOM. See Table Post-SCF Convergence for default convergence criteria for different calculation types. Type: conv double; Default: 1e-6. E_CONVERGENCE (DCFT); DCFT — Convergence criterion for energy. See Table Post-SCF Convergence for default convergence criteria for different calculation types. Type: conv double; Default: 1e-10. E_CONVERGENCE (DETCI); DETCI — Convergence criterion for energy. See Table Post-SCF Convergence for default convergence criteria for different calculation types. Type: conv double; Default: 1e-6. E_CONVERGENCE (DFOCC); DFOCC — Convergence criterion for energy. See Table Post-SCF Convergence for default convergence criteria for different calculation types. Type: conv double; Default: 1e-6. E_CONVERGENCE (FNOCC); FNOCC — Convergence criterion for CC energy. See Table Post-SCF Convergence for default convergence criteria for different calculation types. Note that convergence is met only when E_CONVERGENCE an",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_glossary_options_c-1.html:113198,energy,energy,113198,psi4manual/1.0.0/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_glossary_options_c-1.html,8,['energy'],['energy']
Energy Efficiency,"_TYPE (DCFT); DCFT — Controls the type of the quadratically-convergent algorithm (effective for ALGORITHM = QC). If set to TWOSTEP the Newton-Raphson equations are only solved for the orbital updates, the cumulant is updated using the standard Jacobi algorithm. If set to SIMULTANEOUS both cumulant and orbitals are updated in a single Newton-Raphson step. Type: string; Possible Values: TWOSTEP, SIMULTANEOUS; Default: SIMULTANEOUS. QCHF (DFOCC); DFOCC — Do perform a QCHF computation?. Type: boolean; Default: false. QCHF (SCF); SCF — Do perform a QCHF computation?. Type: boolean; Default: false. QMEFP (EFP); EFP (Expert) — Do turn on QM/EFP terms?. Type: boolean; Default: false. QMEFP_ELST (EFP); EFP — Do include electrostatics energy term in QM/EFP computation?. Type: boolean; Default: true. QMEFP_POL (EFP); EFP — Do include polarization energy term in EFP computation?. Type: boolean; Default: true. R4S (DETCI); DETCI (Expert) — Do restrict strings with \(e-\) in RAS IV? Useful to reduce the number of strings required if MIXED4=true, as in a split-virutal CISD[TQ] computation. If more than one electron is in RAS IV, then the holes in RAS I cannot exceed the number of particles in RAS III + RAS IV (i.e., EX_LEVEL), or else the string is discarded. Type: boolean; Default: false. R_CONVERGENCE (CCENERGY); CCENERGY — Convergence criterion for wavefunction (change) in CC amplitude equations. Type: conv double; Default: 1e-7. R_CONVERGENCE (CCEOM); CCEOM — Convergence criterion for norm of the residual vector in the Davidson algorithm for CC-EOM. Type: conv double; Default: 1e-6. R_CONVERGENCE (CCLAMBDA); CCLAMBDA — Convergence criterion for wavefunction (change) in CC lambda-amplitude equations. Type: conv double; Default: 1e-7. R_CONVERGENCE (CCRESPONSE); CCRESPONSE — Convergence criterion for wavefunction (change) in perturbed CC equations. Type: conv double; Default: 1e-7. R_CONVERGENCE (DCFT); DCFT — Convergence criterion for the RMS of the residual vector in density cu",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/autodoc_glossary_options_c-1.html:188280,reduce,reduce,188280,psi4manual/1.1.0/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/autodoc_glossary_options_c-1.html,2,['reduce'],['reduce']
Energy Efficiency,"_VECS to the required order in the; wavefunction.; By default, the requested n-th order energy is saved as the current; energy to the process environment. ZAPTN works essentially the same; way for an ROHF reference. Arbitrary Order Coupled-Cluster Theory¶; This DETCI-based version of this feature is not yet released. However,; the current version of the code does include an interface to; Kallay’s MRCC code.; The DETCI module is also capable of computing arbitrary-order; coupled-cluster energies, using an approach similar to that of Hirata; and Bartlett [Hirata:2000:216], or of Olsen [Olsen:2000:7140].; Notably, the approach in DETCI also allows arbitrary-order; active space coupled-cluster procedures. The general algorithm; for doing this in DETCI is inefficient compared to optimized; lower-order coupled-cluster codes and should not be used for CCSD,; where the CCENERGY module is much more efficient. For higher-order; CC (like CCSDT and beyond), the code is also not as efficient as the; MRCC code by Kállay, to which PSI4 can interface (see Section; Interface to MRCC by M. Kállay); however, it may allow certain truncations of the model; space that might not be available presently in MRCC. For very small; systems, the code can be useful for testing of, for example, CCSDTQ or; its active-space CCSDtq analog [Piecuch:1999:6103].; To perform arbitrary-order coupled-cluster, set the DETCI; option CC to TRUE, and set; CC_EX_LEVEL (note: not EX_LEVEL); to the desired coupled-cluster excitation level, and invoke; energy('detci'). Various other DETCI options have a similar; option for coupled-cluster, usually named beginning with CC. The full; list of options is given in Appendix DETCI. Table Of Contents. CI: Configuration Interaction; Basic DETCI Keywords; REFERENCE; R_CONVERGENCE; EX_LEVEL; FCI; FROZEN_DOCC; FROZEN_UOCC; MAXITER; NUM_ROOTS; ICORE; DIAG_METHOD; OPDM; TDM; DIPMOM; MPN. Arbitrary Order Perturbation Theory; Arbitrary Order Coupled-Cluster Theory. Previous topic;",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/detci-1.html:10612,efficient,efficient,10612,psi4manual/4.0b3/detci-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/detci-1.html,6,['efficient'],['efficient']
Energy Efficiency,"_VECS to the required order in the; wavefunction.; By default, the requested n-th order energy is saved as the current; energy to the process environment. ZAPTN works essentially the same; way for an ROHF reference. Arbitrary Order Coupled-Cluster Theory¶; This DETCI-based version of this feature is not yet released. However,; the current version of the code does include an interface to; Kallay’s MRCC code.; The DETCI module is also capable of computing arbitrary-order; coupled-cluster energies, using an approach similar to that of Hirata; and Bartlett [Hirata:2000:216], or of Olsen [Olsen:2000:7140].; Notably, the approach in DETCI also allows arbitrary-order; active space coupled-cluster procedures. The general algorithm; for doing this in DETCI is inefficient compared to optimized; lower-order coupled-cluster codes and should not be used for CCSD,; where the CCENERGY module is much more efficient. For higher-order; CC (like CCSDT and beyond), the code is also not as efficient as the; MRCC code by Kállay, to which PSI4 can interface (see Section; Interface to MRCC by M. Kállay); however, it may allow certain truncations of the model; space that might not be available presently in MRCC. For very small; systems, the code can be useful for testing of, for example, CCSDTQ or; its active-space CCSDtq analog [Piecuch:1999:6103].; To perform arbitrary-order coupled-cluster, set the DETCI; option CC to TRUE, and set; CC_EX_LEVEL (note: not EX_LEVEL); to the desired coupled-cluster excitation level, and invoke; energy('detci'). Various other DETCI options have a similar; option for coupled-cluster, usually named beginning with CC. The full; list of options is given in Appendix DETCI. Table Of Contents. Configuration Interaction; Basic DETCI Keywords; REFERENCE; R_CONVERGENCE; EX_LEVEL; FCI; FROZEN_DOCC; FROZEN_UOCC; MAXITER; NUM_ROOTS; ICORE; DIAG_METHOD; OPDM; TDM; DIPMOM; MPN. Arbitrary Order Perturbation Theory; Arbitrary Order Coupled-Cluster Theory. Previous topic; Int",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/detci-1.html:10589,efficient,efficient,10589,psi4manual/4.0b2/detci-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/detci-1.html,2,['efficient'],['efficient']
Energy Efficiency,"_VECS to the required order in the; wavefunction.; By default, the requested n-th order energy is saved as the current; energy to the process environment. ZAPTN works essentially the same; way for an ROHF reference. Arbitrary Order Coupled-Cluster Theory¶; This DETCI-based version of this feature is not yet released. However,; the current version of the code does include an interface to; Kallay’s MRCC code.; The DETCI module is also capable of computing arbitrary-order; coupled-cluster energies, using an approach similar to that of Hirata; and Bartlett [Hirata:2000:216], or of Olsen [Olsen:2000:7140].; Notably, the approach in DETCI also allows arbitrary-order; active space coupled-cluster procedures. The general algorithm; for doing this in DETCI is inefficient compared to optimized; lower-order coupled-cluster codes and should not be used for CCSD,; where the CCENERGY module is much more efficient. For higher-order; CC (like CCSDT and beyond), the code is also not as efficient as the; MRCC code by Kállay, to which PSI4 can interface (see Section; Interface to MRCC by M. Kállay); however, it may allow certain truncations of the model; space that might not be available presently in MRCC. For very small; systems, the code can be useful for testing of, for example, CCSDTQ or; its active-space CCSDtq analog [Piecuch:1999:6103].; To perform arbitrary-order coupled-cluster, set the DETCI; option CC to TRUE, and set; CC_EX_LEVEL (note: not EX_LEVEL); to the desired coupled-cluster excitation level, and invoke; energy('detci'). Various other DETCI options have a similar; option for coupled-cluster, usually named beginning with CC. The full; list of options is given in Appendix DETCI. table of contents. CI: Configuration Interaction; Basic DETCI Keywords; REFERENCE; R_CONVERGENCE; EX_LEVEL; FCI; FROZEN_DOCC; RESTRICTED_DOCC; RESTRICTED_UOCC; FROZEN_UOCC; CI_MAXITER; NUM_ROOTS; ICORE; DIAG_METHOD; OPDM; TDM; DIPMOM; MPN. Arbitrary Order Perturbation Theory; Arbitrary Order Co",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/detci-1.html:12306,efficient,efficient,12306,psi4manual/1.2.1/detci-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/detci-1.html,6,['efficient'],['efficient']
Energy Efficiency,"_VECS to the required order in the; wavefunction.; By default, the requested n-th order energy is saved as the current; energy to the process environment. ZAPTN works essentially the same; way for an ROHF reference. Arbitrary Order Coupled-Cluster Theory¶; This DETCI-based version of this feature is not yet released. However,; the current version of the code does include an interface to; Kallay’s MRCC code.; The DETCI module is also capable of computing arbitrary-order; coupled-cluster energies, using an approach similar to that of Hirata; and Bartlett [Hirata:2000:216], or of Olsen [Olsen:2000:7140].; Notably, the approach in DETCI also allows arbitrary-order; active space coupled-cluster procedures. The general algorithm; for doing this in DETCI is inefficient compared to optimized; lower-order coupled-cluster codes and should not be used for CCSD,; where the CCENERGY module is much more efficient. For higher-order; CC (like CCSDT and beyond), the code is also not as efficient as the; MRCC code by Kállay, to which PSI4 can interface (see Section; Interface to MRCC by M. Kállay); however, it may allow certain truncations of the model; space that might not be available presently in MRCC. For very small; systems, the code can be useful for testing of, for example, CCSDTQ or; its active-space CCSDtq analog [Piecuch:1999:6103].; To perform arbitrary-order coupled-cluster, set the DETCI; option CC to TRUE, and set; CC_EX_LEVEL (note: not EX_LEVEL); to the desired coupled-cluster excitation level, and invoke; energy('detci'). Various other DETCI options have a similar; option for coupled-cluster, usually named beginning with CC. The full; list of options is given in Appendix DETCI. table of contents. CI: Configuration Interaction; Basic DETCI Keywords; REFERENCE; R_CONVERGENCE; EX_LEVEL; FCI; FROZEN_DOCC; RESTRICTED_DOCC; RESTRICTED_UOCC; FROZEN_UOCC; CI_MAXITER; NUM_ROOTS; ICORE; DIAG_METHOD; OPDM; TDM; DIPMOM; MPN. Spin Multiplicities of Higher Roots; Arbitrary Order Pe",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/detci-1.html:14852,efficient,efficient,14852,psi4manual/1.4.0/detci-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/detci-1.html,9,['efficient'],['efficient']
Energy Efficiency,"_VECS to the required order in the; wavefunction.; By default, the requested n-th order energy is saved as the current; energy to the process environment. ZAPTN works essentially the same; way for an ROHF reference. Arbitrary Order Coupled-Cluster Theory¶; This DETCI-based version of this feature is not yet released. However,; the current version of the code does include an interface to; Kallay’s MRCC code.; The DETCI module is also capable of computing arbitrary-order; coupled-cluster energies, using an approach similar to that of Hirata; and Bartlett [Hirata:2000:216], or of Olsen [Olsen:2000:7140].; Notably, the approach in DETCI also allows arbitrary-order; active space coupled-cluster procedures. The general algorithm; for doing this in DETCI is inefficient compared to optimized; lower-order coupled-cluster codes and should not be used for CCSD,; where the CCENERGY module is much more efficient. For higher-order; CC (like CCSDT and beyond), the code is also not as efficient as the; MRCC code by Kállay, to which Psi4 can interface (see Section; Interface to MRCC by M. Kállay); however, it may allow certain truncations of the model; space that might not be available presently in MRCC. For very small; systems, the code can be useful for testing of, for example, CCSDTQ or; its active-space CCSDtq analog [Piecuch:1999:6103].; To perform arbitrary-order coupled-cluster, set the DETCI; option CC to TRUE, and set; CC_EX_LEVEL (note: not EX_LEVEL); to the desired coupled-cluster excitation level, and invoke; energy('detci'). Various other DETCI options have a similar; option for coupled-cluster, usually named beginning with CC. The full; list of options is given in Appendix DETCI. Table Of Contents. CI: Configuration Interaction; Basic DETCI Keywords; REFERENCE; R_CONVERGENCE; EX_LEVEL; FCI; FROZEN_DOCC; RESTRICTED_DOCC; RESTRICTED_UOCC; FROZEN_UOCC; CI_MAXITER; NUM_ROOTS; ICORE; DIAG_METHOD; OPDM; TDM; DIPMOM; MPN. Arbitrary Order Perturbation Theory; Arbitrary Order Co",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/detci-1.html:11099,efficient,efficient,11099,psi4manual/1.0.0/detci-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/detci-1.html,2,['efficient'],['efficient']
Energy Efficiency,"__ method of molecule class. p4regex¶. proc¶. run_adc(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; an algebraic diagrammatic construction calculation. Caution; Get rid of active molecule lines- should be handled in energy. run_bccd(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; a Brueckner CCD calculation. run_bccd_t(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; a Brueckner CCD(T) calculation. run_cc_gradient(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; a CCSD and CCSD(T) gradient calculation. run_cc_property(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; all CC property calculations. run_ccenergy(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; a CCSD, CC2, and CC3 calculation. run_cepa(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; a cepa-like calculation.; >>> energy('cepa(1)'). run_cepa0(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; a CEPA (LCCD) computation. run_cepa0_gradient(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; a CEPA(0) gradient calculation. run_dcft(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; a density cumulant functional theory calculation. run_dcft_gradient(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; DCFT gradient calculation. run_detci(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; a configuration interaction calculation, namely FCI,; CIn, MPn, and ZAPTn. run_dfmp2(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; a density-fitted MP2 calculation. run_dfmp2_gradient(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; a DFMP2 gradient calculation. run_dfmp2_property(name, **kwargs)[source]¶; Function encoding sequence",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/autodoc_driver-1.html:6431,energy,energy,6431,psi4manual/4.0b5/autodoc_driver-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodoc_driver-1.html,2,['energy'],['energy']
Energy Efficiency,"_a().get(h, inp_data[i]), inp_data[i]]; ret_eps.append(tmp). ret_eps.sort(key=lambda x: x[3]). h2ev = constants.hartree2ev; irrep_labels = dfep2_wfn.molecule().irrep_labels(). core.print_out("" ==> Results <==\n\n""); core.print_out("" %8s %12s %12s %8s\n"" % (""Orbital"", ""Koopmans (eV)"", ""EP2 (eV)"", ""EP2 PS"")); core.print_out("" ----------------------------------------------\n""); for irrep, ep2, ep2_ps, kt, pos in ret_eps:; label = str(pos + 1) + irrep_labels[irrep]; core.print_out("" %8s % 12.3f % 12.3f % 6.3f\n"" % (label, (kt * h2ev), (ep2 * h2ev), ep2_ps)); core.set_variable(""EP2 "" + label.upper() + "" ENERGY"", ep2); core.print_out("" ----------------------------------------------\n\n""). # Figure out the IP and EA; sorted_vals = np.array([x[1] for x in ret_eps]); ip_vals = sorted_vals[sorted_vals < 0]; ea_vals = sorted_vals[sorted_vals > 0]. ip_value = None; ea_value = None; if len(ip_vals):; core.set_variable(""EP2 IONIZATION POTENTIAL"", ip_vals[-1]); core.set_variable(""CURRENT ENERGY"", ip_vals[-1]); if len(ea_vals):; core.set_variable(""EP2 ELECTRON AFFINITY"", ea_vals[0]); if core.variable(""EP2 IONIZATION POTENTIAL"") == 0.0:; core.set_variable(""CURRENT ENERGY"", ea_vals[0]). core.print_out("" EP2 has completed successfully!\n\n""). core.tstop(); return dfep2_wfn. def run_dlpnomp2(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a DLPNO-MP2 calculation. """"""; optstash = p4util.OptionsState(; ['DF_BASIS_MP2'],; ['SCF_TYPE']). # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'); core.print_out("""""" SCF Algorithm Type (re)set to DF.\n""""""). # DLPNO-MP2 is only DF; if core.get_global_option('MP2_TYPE') != ""DF"":; raise ValidationError("""""" DLPNO-MP2 is only implemented with density fitting.\n""""""; """""" 'mp2_type' must be set to 'DF'.\n""""""). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, use_c1=Tru",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/_modules/psi4/driver/procrouting/proc.html:130125,ENERGY,ENERGY,130125,psi4manual/1.5.0/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/_modules/psi4/driver/procrouting/proc.html,6,['ENERGY'],['ENERGY']
Energy Efficiency,"_a().get(h, inp_data[i]), inp_data[i]]; ret_eps.append(tmp). ret_eps.sort(key=lambda x: x[3]). h2ev = constants.hartree2ev; irrep_labels = dfep2_wfn.molecule().irrep_labels(). core.print_out("" ==> Results <==\n\n""); core.print_out("" %8s %12s %12s %8s\n"" % (""Orbital"", ""Koopmans (eV)"", ""EP2 (eV)"", ""EP2 PS"")); core.print_out("" ----------------------------------------------\n""); for irrep, ep2, ep2_ps, kt, pos in ret_eps:; label = str(pos + 1) + irrep_labels[irrep]; core.print_out("" %8s % 12.3f % 12.3f % 6.3f\n"" % (label, (kt * h2ev), (ep2 * h2ev), ep2_ps)); core.set_variable(""EP2 "" + label.upper() + "" ENERGY"", ep2); core.print_out("" ----------------------------------------------\n\n""). # Figure out the IP and EA; sorted_vals = np.array([x[1] for x in ret_eps]); ip_vals = sorted_vals[sorted_vals < 0]; ea_vals = sorted_vals[sorted_vals > 0]. ip_value = None; ea_value = None; if len(ip_vals):; core.set_variable(""EP2 IONIZATION POTENTIAL"", ip_vals[-1]); core.set_variable(""CURRENT ENERGY"", ip_vals[-1]); if len(ea_vals):; core.set_variable(""EP2 ELECTRON AFFINITY"", ea_vals[0]); if core.variable(""EP2 IONIZATION POTENTIAL"") == 0.0:; core.set_variable(""CURRENT ENERGY"", ea_vals[0]). core.print_out("" EP2 has completed successfully!\n\n""). core.tstop(); return dfep2_wfn. def run_dmrgscf(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; an DMRG calculation. """"""; optstash = p4util.OptionsState(; ['SCF_TYPE'],; ['DMRG', 'DMRG_CASPT2_CALC']). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs). # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn). if 'CASPT2' in name.upper():; core.set_local_option(""DMRG"", ""DMRG_CASPT2_CALC"", True). dmrg_wfn = core.dmrg(ref_wfn); optstash.restore(). # Shove variables into global space; for k, v in dmrg_wfn.variables().items():; core.set_variable(k, v). return",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html:129830,ENERGY,ENERGY,129830,psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,1,['ENERGY'],['ENERGY']
Energy Efficiency,"_alpha()); core.set_local_option('DFMP2', 'MP2_SS_SCALE', dfun.c_ss_alpha()); dfmp2_wfn = core.dfmp2(scf_wfn); dfmp2_wfn.compute_energy(). vdh = dfun.c_alpha() * core.get_variable('SCS-MP2 CORRELATION ENERGY'). else:; dfmp2_wfn = core.dfmp2(scf_wfn); dfmp2_wfn.compute_energy(); vdh = dfun.c_alpha() * core.get_variable('MP2 CORRELATION ENERGY'). # TODO: delete these variables, since they don't mean what they look to mean?; # 'MP2 TOTAL ENERGY',; # 'MP2 CORRELATION ENERGY',; # 'MP2 SAME-SPIN CORRELATION ENERGY']. core.set_variable('DOUBLE-HYBRID CORRECTION ENERGY', vdh); returnvalue += vdh; core.set_variable('DFT TOTAL ENERGY', returnvalue); core.set_variable('CURRENT ENERGY', returnvalue); core.print_out('\n\n'); core.print_out(' %s Energy Summary\n' % (name.upper())); core.print_out(' -------------------------\n'); core.print_out(' DFT Reference Energy = %22.16lf\n' % (returnvalue - vdh)); core.print_out(' Scaled MP2 Correlation = %22.16lf\n' % (vdh)); core.print_out(' @Final double-hybrid DFT total energy = %22.16lf\n\n' % (returnvalue)); core.tstop(). optstash.restore(); return scf_wfn. def run_dft_gradient(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a density-functional-theory gradient calculation. """"""; optstash = p4util.OptionsState(; ['SCF', 'DFT_FUNCTIONAL'],; ['SCF', 'REFERENCE'],; ['SCF', 'SCF_TYPE']). # Alter default algorithm; if not core.has_option_changed('SCF', 'SCF_TYPE'):; core.set_local_option('SCF', 'SCF_TYPE', 'DF'). core.set_local_option('SCF', 'DFT_FUNCTIONAL', name.upper()). user_ref = core.get_option('SCF', 'REFERENCE'); if (user_ref == 'RHF'):; core.set_local_option('SCF', 'REFERENCE', 'RKS'); elif (user_ref == 'UHF'):; core.set_local_option('SCF', 'REFERENCE', 'UKS'); elif (user_ref == 'ROHF'):; raise ValidationError('ROHF reference for DFT is not available.'); elif (user_ref == 'CUHF'):; raise ValidationError('CUHF reference for DFT is not available.'). wfn = run_scf_gradient(name, **kwargs). optstash.restore(); ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/procrouting/proc.html:85204,energy,energy,85204,psi4manual/1.1.0/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/procrouting/proc.html,1,['energy'],['energy']
Energy Efficiency,"_alpha()); psi4.set_local_option('DFMP2', 'MP2_SS_SCALE', dfun.c_ss_alpha()); dfmp2_wfn = psi4.dfmp2(scf_wfn); dfmp2_wfn.compute_energy(). vdh = dfun.c_alpha() * psi4.get_variable('SCS-MP2 CORRELATION ENERGY'). else:; dfmp2_wfn = psi4.dfmp2(scf_wfn); dfmp2_wfn.compute_energy(); vdh = dfun.c_alpha() * psi4.get_variable('MP2 CORRELATION ENERGY'). # TODO: delete these variables, since they don't mean what they look to mean?; # 'MP2 TOTAL ENERGY',; # 'MP2 CORRELATION ENERGY',; # 'MP2 SAME-SPIN CORRELATION ENERGY']. psi4.set_variable('DOUBLE-HYBRID CORRECTION ENERGY', vdh); returnvalue += vdh; psi4.set_variable('DFT TOTAL ENERGY', returnvalue); psi4.set_variable('CURRENT ENERGY', returnvalue); psi4.print_out('\n\n'); psi4.print_out(' %s Energy Summary\n' % (name.upper())); psi4.print_out(' -------------------------\n'); psi4.print_out(' DFT Reference Energy = %22.16lf\n' % (returnvalue - vdh)); psi4.print_out(' Scaled MP2 Correlation = %22.16lf\n' % (vdh)); psi4.print_out(' @Final double-hybrid DFT total energy = %22.16lf\n\n' % (returnvalue)). optstash.restore(); return scf_wfn. [docs]def run_dft_gradient(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a density-functional-theory gradient calculation. """"""; optstash = p4util.OptionsState(; ['SCF', 'DFT_FUNCTIONAL'],; ['SCF', 'REFERENCE'],; ['SCF', 'SCF_TYPE']). # Alter default algorithm; if not psi4.has_option_changed('SCF', 'SCF_TYPE'):; psi4.set_local_option('SCF', 'SCF_TYPE', 'DF'). psi4.set_local_option('SCF', 'DFT_FUNCTIONAL', name.upper()). user_ref = psi4.get_option('SCF', 'REFERENCE'); if (user_ref == 'RHF'):; psi4.set_local_option('SCF', 'REFERENCE', 'RKS'); elif (user_ref == 'UHF'):; psi4.set_local_option('SCF', 'REFERENCE', 'UKS'); elif (user_ref == 'ROHF'):; raise ValidationError('ROHF reference for DFT is not available.'); elif (user_ref == 'CUHF'):; raise ValidationError('CUHF reference for DFT is not available.'). wfn = run_scf_gradient(name, **kwargs). optstash.restore(); return w",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html:72127,energy,energy,72127,psi4manual/1.0.0/_modules/procedures/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html,1,['energy'],['energy']
Energy Efficiency,_already_presorted() (psi4.core.IntegralTransform method). set_title() (psi4.core.OEProp method). set_tpdm_already_presorted() (psi4.core.IntegralTransform method). set_tpdm_presorted() (psi4.core.Deriv method). set_tweak() (psi4.core.LibXCFunctional method). set_units() (psi4.core.Molecule method). set_variable() (in module psi4.core). (psi4.core.Molecule method). (psi4.core.Wavefunction method). set_view() (psi4.driver.p4util.InPsight method). set_vv10_b() (psi4.core.SuperFunctional method). set_vv10_c() (psi4.core.SuperFunctional method). set_wcombine() (psi4.core.JK method). set_write_dpd_so_tpdm() (psi4.core.IntegralTransform method). set_x_alpha() (psi4.core.SuperFunctional method). set_x_beta() (psi4.core.SuperFunctional method). set_x_omega() (psi4.core.SuperFunctional method). set_xclib_description() (psi4.core.SuperFunctional method). setName() (psi4.core.ExternalPotential method). setting. ; keywords anharmonicity(). keywords cbs(). keywords cp. keywords database(). keywords energy(). keywords frequency(). keywords general. keywords molecule. keywords optimize(). keywords properties(). keywords vmfc. SF_RESTRICT (DETCI). shallow_copy() (psi4.core.Wavefunction method). shape (psi4.core.Matrix attribute). (psi4.core.Vector attribute). shared_object() (psi4.core.IO static method). (psi4.core.IOManager static method). shell() (psi4.core.BasisSet method). shell_extents() (psi4.core.BasisExtents method). shell_on_center() (psi4.core.BasisSet method). shell_significant() (psi4.core.ERISieve method). (psi4.core.TwoBodyAOInt method). (psi4.core.TwoElectronInt method). shell_to_ao_function() (psi4.core.BasisSet method). shell_to_basis_function() (psi4.core.BasisSet method). shell_to_center() (psi4.core.BasisSet method). ShellInfo (class in psi4.core). shells_iterator() (psi4.core.IntegralFactory method). shells_local_to_global() (psi4.core.BlockOPoints method). sherrill_gold_standard() (in module psi4.driver.aliases). shift() (psi4.core.CIVector method). sigma() (ps,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/genindex.html:117760,energy,energy,117760,psi4manual/1.9.x/genindex.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/genindex.html,1,['energy'],['energy']
Energy Efficiency,_already_presorted() (psi4.core.IntegralTransform method). set_title() (psi4.core.OEProp method). set_tpdm_already_presorted() (psi4.core.IntegralTransform method). set_tpdm_presorted() (psi4.core.Deriv method). set_tweak() (psi4.core.LibXCFunctional method). set_units() (psi4.core.Molecule method). set_variable() (in module psi4.core). (psi4.core.Molecule method). (psi4.core.Wavefunction method). set_view() (psi4.driver.p4util.InPsight method). set_vv10_b() (psi4.core.SuperFunctional method). set_vv10_c() (psi4.core.SuperFunctional method). set_wcombine() (psi4.core.JK method). set_write_dpd_so_tpdm() (psi4.core.IntegralTransform method). set_x_alpha() (psi4.core.SuperFunctional method). set_x_beta() (psi4.core.SuperFunctional method). set_x_omega() (psi4.core.SuperFunctional method). set_xclib_description() (psi4.core.SuperFunctional method). setName() (psi4.core.ExternalPotential method). setting. ; keywords anharmonicity(). keywords cbs(). keywords cp. keywords database(). keywords energy(). keywords frequency(). keywords general. keywords molecule. keywords optimize(). keywords properties(). keywords vmfc. SF_RESTRICT (DETCI). shallow_copy() (psi4.core.Wavefunction method). shape (psi4.core.Matrix attribute). (psi4.core.Vector attribute). shared_object() (psi4.core.IO static method). (psi4.core.IOManager static method). shell() (psi4.core.BasisSet method). shell_extents() (psi4.core.BasisExtents method). shell_on_center() (psi4.core.BasisSet method). shell_significant() (psi4.core.TwoBodyAOInt method). (psi4.core.TwoElectronInt method). shell_to_ao_function() (psi4.core.BasisSet method). shell_to_basis_function() (psi4.core.BasisSet method). shell_to_center() (psi4.core.BasisSet method). ShellInfo (class in psi4.core). shells_iterator() (psi4.core.IntegralFactory method). shells_local_to_global() (psi4.core.BlockOPoints method). sherrill_gold_standard() (in module psi4.driver.aliases). shift() (psi4.core.CIVector method). sigma() (psi4.core.CIWavefunction method,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/genindex.html:118720,energy,energy,118720,psi4manual/master/genindex.html,https://psicode.org,https://psicode.org/psi4manual/master/genindex.html,1,['energy'],['energy']
Energy Efficiency,"_au(self); Returns unit conversion to [a0] for geometry. irrep_labels(self); Returns Irreducible Representation symmetry labels. is_variable(self, arg0); Checks if variable arg2 is in the list, returns true if it is, and returns false if not. label(self, arg0); Gets the original label of the atom as given in the input file (C2, H4). mass(self, atom); Returns mass of atom (0-indexed). mass_number(self, arg0); Mass number (A) of atom if known, else -1. molecular_charge(self); Gets the molecular charge. move_to_com(self); Moves molecule to center of mass. multiplicity(self); Gets the multiplicity (defined as 2Ms + 1). nallatom(self); Number of real and dummy atoms. name(self); Gets molecule name. natom(self); Number of real atoms. nfragments(self); Gets the number of fragments in the molecule. nuclear_dipole(*args, **kwargs); Overloaded function. nuclear_repulsion_energy(self, dipole_field, …); Computes nuclear repulsion energy. nuclear_repulsion_energy_deriv1(self, arg0); Returns first derivative of nuclear repulsion energy as a matrix (natom, 3). nuclear_repulsion_energy_deriv2(self); Returns second derivative of nuclear repulsion energy as a matrix (natom X 3, natom X 3). orientation_fixed(self); Get whether or not orientation is fixed. point_group(self); Returns the current point group object. print_bond_angles(self); Print the bond angle geometrical parameters. print_cluster(self); Prints the molecule in Cartesians in input units adding fragment separators. print_distances(self); Print the interatomic distance geometrical parameters. print_in_input_format(self); Prints the molecule as Cartesian or ZMatrix entries, just as inputted. print_out(self); Prints the molecule in Cartesians in input units to output file. print_out_in_angstrom(self); Prints the molecule in Cartesians in Angstroms to output file. print_out_in_bohr(self); Prints the molecule in Cartesians in Bohr to output file. print_out_of_planes(self); Print the out-of-plane angle geometrical parameters to",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/api/psi4.core.molecule.html:4597,energy,energy,4597,psi4manual/1.2.1/api/psi4.core.molecule.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/api/psi4.core.molecule.html,1,['energy'],['energy']
Energy Efficiency,"_aux_basis). if core.get_global_option(""RELATIVISTIC"") in [""X2C"", ""DKH""]:; rel_bas = core.BasisSet.build(ref_wfn.molecule(), ""BASIS_RELATIVISTIC"",; core.get_option(""SCF"", ""BASIS_RELATIVISTIC""),; ""DECON"", core.get_global_option('BASIS'),; puream=ref_wfn.basisset().has_puream()); ref_wfn.set_basisset('BASIS_RELATIVISTIC',rel_bas). fnocc_wfn = core.fnocc(ref_wfn). # set current correlation energy and total energy. only need to treat mpn here.; if name in [""mp3"", ""fno-mp3""]:; fnocc_wfn.set_variable(""CURRENT ENERGY"", fnocc_wfn.variable(""MP3 TOTAL ENERGY"")); fnocc_wfn.set_variable(""CURRENT CORRELATION ENERGY"", fnocc_wfn.variable(""MP3 CORRELATION ENERGY"")); elif name in [""mp4(sdq)"", ""fno-mp4(sdq)""]:; fnocc_wfn.set_variable(""CURRENT ENERGY"", fnocc_wfn.variable(""MP4(SDQ) TOTAL ENERGY"")); fnocc_wfn.set_variable(""CURRENT CORRELATION ENERGY"", fnocc_wfn.variable(""MP4(SDQ) CORRELATION ENERGY"")); elif name in [""mp4"", ""fno-mp4""]:; fnocc_wfn.set_variable(""CURRENT ENERGY"", fnocc_wfn.variable(""MP4 TOTAL ENERGY"")); fnocc_wfn.set_variable(""CURRENT CORRELATION ENERGY"", fnocc_wfn.variable(""MP4 CORRELATION ENERGY"")). # Shove variables into global space; for k, v in fnocc_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); return fnocc_wfn. def run_cepa(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a cepa-like calculation. >>> energy('cepa(1)'). """"""; kwargs = p4util.kwargs_lower(kwargs). # save user options; optstash = p4util.OptionsState(; ['TRANSQT2', 'WFN'],; ['FNOCC', 'NAT_ORBS'],; ['FNOCC', 'RUN_CEPA'],; ['FNOCC', 'USE_DF_INTS'],; ['FNOCC', 'CEPA_NO_SINGLES']). core.set_local_option('FNOCC', 'RUN_CEPA', True); core.set_local_option('FNOCC', 'USE_DF_INTS', False). # what type of cepa?; if name in ['lccd', 'fno-lccd']:; cepa_level = 'cepa(0)'; core.set_local_option('FNOCC', 'CEPA_NO_SINGLES', True); elif name in ['cepa(0)', 'fno-cepa(0)', 'lccsd', 'fno-lccsd']:; cepa_level = 'cepa(0)'; core.set_local_option('FNOCC', 'CEPA_NO_SINGLES', False); ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html:160466,ENERGY,ENERGY,160466,psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,3,['ENERGY'],['ENERGY']
Energy Efficiency,"_basis']); and (mc['f_options'] == mce['f_options'])):; mce['f_energy'] = mc['f_energy']; mce['f_gradient'] = mc['f_gradient']; mce['f_hessian'] = mc['f_hessian']; mce['f_dipole'] = mc['f_dipole']; mce['f_dipder'] = mc['f_dipder']. # logger.debug(""MC\n"" + pp.pformat(mc)). cbs_results, self.cbsrec = _assemble_cbs_components(self.metameta, self.trove, self.cbsrec). instructions = _summary_table(self.metadata, self.trove, self.cbsrec); core.print_out(instructions); logger.info(instructions). # logger.debug('CBS_RESULTS\n' + pp.pformat(cbs_results)); # logger.debug('GRAND_NEED\n' + pp.pformat(self.cbsrec)). cbs_results[""module""] = modules; return cbs_results. [docs] def get_results(self, client: Optional[""qcportal.FractalClient""] = None) -> AtomicResult:; """"""Return results as Composite-flavored QCSchema."""""". assembled_results = self._prepare_results(client=client); E0 = assembled_results[""energy""]. # load QCVariables & properties; qcvars = {; 'CBS NUMBER': len(self.compute_list),; 'NUCLEAR REPULSION ENERGY': self.molecule.nuclear_repulsion_energy(),; }. properties = {; ""calcinfo_natom"": self.molecule.natom(),; ""nuclear_repulsion_energy"": self.molecule.nuclear_repulsion_energy(),; ""return_energy"": E0,; }. for qcv in ['CBS', 'CURRENT']:; qcvars[qcv + ' REFERENCE ENERGY'] = self.cbsrec[0]['d_energy']; qcvars[qcv + ' CORRELATION ENERGY'] = E0 - self.cbsrec[0]['d_energy']; qcvars[qcv + ('' if qcv == 'CURRENT' else ' TOTAL') + ' ENERGY'] = E0. for idelta in range(int(len(self.cbsrec) / 2)):; if idelta == 0:; continue; dc = idelta * 2 + 1; qcvars[f""CBS {self.cbsrec[dc]['d_stage'].upper()} TOTAL ENERGY""] = self.cbsrec[dc][""d_energy""] - self.cbsrec[dc + 1][""d_energy""]. G0 = assembled_results[""gradient""]; if G0 is not None:; qcvars[""CURRENT GRADIENT""] = G0; qcvars[""CBS TOTAL GRADIENT""] = G0; properties[""return_gradient""] = G0. H0 = assembled_results[""hessian""]; if H0 is not None:; qcvars[""CURRENT HESSIAN""] = H0; qcvars[""CBS TOTAL HESSIAN""] = H0; properties[""return_hessian""] = H0. ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver_cbs.html:58769,ENERGY,ENERGY,58769,psi4manual/1.7.x/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver_cbs.html,1,['ENERGY'],['ENERGY']
Energy Efficiency,"_basis_sapt aug-cc-pvdz-ri; guess sad; scf_type df; }. set sapt {; print 1; }. These options will perform the SAPT computation with DF-HF and a; superposition-of-atomic-densities guess. This is the preferred method of; running the SAPT module.; As already mentioned above, the SAPT0 module for open-shell cases can also; use exact integrals for all terms except for dispersion. In practice,; density fitting is considerably faster and introduces negligible errors, thus; it is the preferred method for open-shell cases as well.; Below, you can find a minimum example of open-shell SAPT0 computation.; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19; 20; 21; 22; 23molecule {; 0 1; O 0.000000 0.000000 6.000000; H 0.000000 1.431500 4.890600; H 0.000000 -1.431500 4.890600; --; 0 2; O 0.000000 0.000000 0.000000; O 0.000000 2.503900 0.000000; H 0.000000 -0.424700 -1.839500; units bohr; symmetry c1; no_reorient; no_com; }. set {; reference uhf; scf_type df; basis cc-pVDZ; }. energy('sapt0'). REFERENCE needs to be UHF or ROHF for the open-shell computation to proceed. Advanced example¶; Open-shell computations can be difficult to converge in certain cases, thus you may; want to have more control over the SCF procedure. You have the option of; doing the driver job in the input file, by performing the dimer and monomer computations; yourself. In the example below, we do a stability analysis for the open-shell monomer only; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19; 20; 21; 22; 23; 24; 25; 26; 27; 28; 29; 30; 31; 32; 33; 34; 35; 36; 37; 38; 39; 40; 41; 42; 43; 44; 45; 46; 47; 48; 49; 50; 51; 52; 53; 54; 55; 56; 57; 58; 59molecule {; 0 2; O 0.000000 0.000000 0.000000; O 0.000000 2.503900 0.000000; H 0.000000 -0.424700 -1.839500; --; 0 1; O 0.000000 0.000000 6.000000; H 0.000000 1.431500 4.890600; H 0.000000 -1.431500 4.890600; units bohr; symmetry c1; no_reorient; no_com; }. dimer = psi4.get_active_molecule(). set {; reference uhf; scf_type df; ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/sapt-1.html:10839,energy,energy,10839,psi4manual/1.2.1/sapt-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/sapt-1.html,4,['energy'],['energy']
Energy Efficiency,"_basis_sapt aug-cc-pvdz-ri; guess sad; scf_type df; }. set sapt {; print 1; }. These options will perform the SAPT computation with DF-HF and a; superposition-of-atomic-densities guess. This is the preferred method of; running the SAPT module.; As already mentioned above, the SAPT0 module for open-shell cases can also; use exact integrals for all terms except for dispersion. In practice,; density fitting is considerably faster and introduces negligible errors, thus; it is the preferred method for open-shell cases as well.; Below, you can find a minimum example of open-shell SAPT0 computation.; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19; 20; 21; 22; 23molecule {; 0 1; O 0.000000 0.000000 6.000000; H 0.000000 1.431500 4.890600; H 0.000000 -1.431500 4.890600; --; 0 2; O 0.000000 0.000000 0.000000; O 0.000000 2.503900 0.000000; H 0.000000 -0.424700 -1.839500; units bohr; symmetry c1; no_reorient; no_com; }. set {; reference uhf; scf_type df; basis cc-pVDZ; }. energy('sapt0'). REFERENCE needs to be UHF or ROHF for the open-shell computation to proceed. Advanced example¶; Open-shell computations can be difficult to converge in certain cases, thus you may; want to have more control over the SCF procedure. You have the option of; doing the driver job in the input file, by performing the dimer and monomer computations; yourself. In the example below, we do a stability analysis for the open-shell monomer only; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19; 20; 21; 22; 23; 24; 25; 26; 27; 28; 29; 30; 31; 32; 33; 34; 35; 36; 37; 38; 39; 40; 41; 42; 43; 44; 45; 46; 47; 48; 49; 50; 51; 52; 53molecule {; 0 2; O 0.000000 0.000000 0.000000; O 0.000000 2.503900 0.000000; H 0.000000 -0.424700 -1.839500; --; 0 1; O 0.000000 0.000000 6.000000; H 0.000000 1.431500 4.890600; H 0.000000 -1.431500 4.890600; units bohr; symmetry c1; no_reorient; no_com; }. dimer = psi4.get_active_molecule(). set {; reference uhf; scf_type df; basis cc-pVDZ; df_basis_",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/sapt-1.html:10815,energy,energy,10815,psi4manual/1.1.0/sapt-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/sapt-1.html,2,['energy'],['energy']
Energy Efficiency,"_basis_scf basis is not set, pick a sensible one.; if PsiMod.get_global_option('DF_BASIS_SCF') == '':; jkbasis = corresponding_jkfit(PsiMod.get_global_option('BASIS')); if jkbasis:; PsiMod.set_global_option('DF_BASIS_SCF', jkbasis); PsiMod.print_out('\nNo DF_BASIS_SCF auxiliary basis selected, defaulting to %s\n\n' % (jkbasis)); else:; raise ValidationError('Keyword DF_BASIS_SCF is required.'). run_scf('RHF', **kwargs). PsiMod.print_out('\n'); banner('DFMP2'); PsiMod.print_out('\n'). # if the df_basis_mp2 basis is not set, pick a sensible one.; if PsiMod.get_global_option('DF_BASIS_MP2') == '':; ribasis = corresponding_rifit(PsiMod.get_global_option('BASIS')); if ribasis:; PsiMod.set_global_option('DF_BASIS_MP2', ribasis); PsiMod.print_out('No DF_BASIS_MP2 auxiliary basis selected, defaulting to %s\n' % (ribasis)); else:; raise ValidationError('Keyword DF_BASIS_MP2 is required.'). PsiMod.dfmp2grad(); e_dfmp2 = PsiMod.get_variable('DF-MP2 ENERGY'); e_scs_dfmp2 = PsiMod.get_variable('SCS-DF-MP2 ENERGY'). optstash.restore(). if (name.upper() == 'SCS-DFMP2') or (name.upper() == 'SCS-DF-MP2'):; return e_scs_dfmp2; elif (name.upper() == 'DF-MP2') or (name.upper() == 'DFMP2'):; return e_dfmp2. [docs]def run_ccenergy(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a CCSD, CC2, and CC3 calculation. """"""; lowername = name.lower(). optstash = OptionsState(; ['TRANSQT2', 'WFN'],; ['CCSORT', 'WFN'],; ['CCENERGY', 'WFN']). if (lowername == 'ccsd'):; PsiMod.set_local_option('TRANSQT2', 'WFN', 'CCSD'); PsiMod.set_local_option('CCSORT', 'WFN', 'CCSD'); PsiMod.set_local_option('CCENERGY', 'WFN', 'CCSD'); elif (lowername == 'ccsd(t)'):; PsiMod.set_local_option('TRANSQT2', 'WFN', 'CCSD_T'); PsiMod.set_local_option('CCSORT', 'WFN', 'CCSD_T'); PsiMod.set_local_option('CCENERGY', 'WFN', 'CCSD_T'); elif (lowername == 'cc2'):; PsiMod.set_local_option('TRANSQT2', 'WFN', 'CC2'); PsiMod.set_local_option('CCSORT', 'WFN', 'CC2'); PsiMod.set_local_option('CCENERGY', 'WFN',",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/_modules/proc.html:12161,ENERGY,ENERGY,12161,psi4manual/4.0b3/_modules/proc.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/_modules/proc.html,1,['ENERGY'],['ENERGY']
Energy Efficiency,"_basisset(""DF_BASIS_ELST"", aux_basis). core.print_out('\n'); p4util.banner(name.upper()); core.print_out('\n'); e_sapt = core.sapt(dimer_wfn, monomerA_wfn, monomerB_wfn); dimer_wfn.set_module(""sapt""). from psi4.driver.qcdb.psivardefs import sapt_psivars; p4util.expand_psivars(sapt_psivars()); optstash.restore(). # Get the SAPT name right if doing empirical dispersion; if do_empirical_disp:; sapt_name = ""sapt0""; else:; sapt_name = name. # Make sure we got induction, otherwise replace it with uncoupled induction; which_ind = 'IND'; target_ind = 'IND'; if not core.has_variable(' '.join((sapt_name.upper(), which_ind, 'ENERGY'))):; which_ind = 'IND,U'. for term in ['ELST', 'EXCH', 'DISP', 'TOTAL']:; core.set_variable(' '.join(['SAPT', term, 'ENERGY']),; core.variable(' '.join([sapt_name.upper(), term, 'ENERGY']))); # Special induction case; core.set_variable(' '.join(['SAPT', target_ind, 'ENERGY']),; core.variable(' '.join([sapt_name.upper(), which_ind, 'ENERGY']))); core.set_variable('CURRENT ENERGY', core.variable('SAPT TOTAL ENERGY')). # Empirical dispersion; if do_empirical_disp:; proc_util.sapt_empirical_dispersion(name, dimer_wfn). return dimer_wfn. def run_sapt_ct(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a charge-transfer SAPT calcuation of any level. """"""; optstash = p4util.OptionsState(; ['SCF_TYPE']). if 'ref_wfn' in kwargs:; core.print_out('\nWarning! Argument ref_wfn is not valid for sapt computations\n'). # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'). # Get the molecule of interest; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; sapt_dimer = kwargs.pop('molecule', core.get_active_molecule()); else:; core.print_out('Warning! SAPT argument ""ref_wfn"" is only able to use molecule information.'); sapt_dimer = ref_wfn.molecule(). sapt_dimer, monomerA, monomerB = proc_util.prepare_sapt_molecule(sapt_dimer, ""dimer""); monomerAm = sapt_dimer.extract_su",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html:139152,ENERGY,ENERGY,139152,psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,7,['ENERGY'],['ENERGY']
Energy Efficiency,"_body_dict); nbody_range.sort(); for n in nbody_range:; delta_e = (energy_body_dict[n] - previous_e); delta_e_kcal = delta_e * constants.hartree2kcalmol; int_e_kcal = (energy_body_dict[n] - energy_body_dict[1]) * constants.hartree2kcalmol; core.print_out("""""" %4s %20.12f %20.12f %20.12f\n"""""" %; (n, energy_body_dict[n], int_e_kcal, delta_e_kcal)); previous_e = energy_body_dict[n]; core.print_out(""\n""). [docs]def nbody_gufunc(func, method_string, **kwargs):; """"""; Computes the nbody interaction energy, gradient, or Hessian depending on input.; This is a generalized univeral function for computing interaction quantities. :returns: *return type of func* |w--w| The interaction data. :returns: (*float*, :py:class:`~psi4.core.Wavefunction`) |w--w| interaction data and wavefunction with energy/gradient/hessian set appropriately when **return_wfn** specified. :type func: function; :param func: ``energy`` || etc. Python function that accepts method_string and a molecule. Returns a; energy, gradient, or Hessian as requested. :type method_string: string; :param method_string: ``'scf'`` || ``'mp2'`` || ``'ci5'`` || etc. First argument, lowercase and usually unlabeled. Indicates the computational; method to be passed to func. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :type return_wfn: :ref:`boolean <op_py_boolean>`; :param return_wfn: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return the :py:class:`~psi4.core.Wavefunction`; calculation result as the second element of a tuple. :type bsse_type: string or list; :param bsse_type: ``'cp'`` || ``['nocp', 'vmfc']`` || |dl| ``None`` |dr| || etc. Type of BSSE correction to compute: CP, NoCP, or VMFC. The first in this; list is returned by this function. By default, this function is not called. :type max_nbody: int; :param max_nbody: ``3`` || etc. Maximum n-body to compute, cannot exceed the number of fragments in the moleucle. :typ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/driver_nbody.html:4109,energy,energy,4109,psi4manual/1.1.0/_modules/psi4/driver/driver_nbody.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/driver_nbody.html,2,['energy'],['energy']
Energy Efficiency,"_bsse[Ns[k + 1]]; PsiMod.print_out(' %6s %24.16E %24.16E\n' % (n, E, physconst.psi_hartree2kcalmol * E)); PsiMod.print_out('\n'). # Put everything back the way it was; PsiMod.set_global_option('DF_INTS_IO', ri_ints_io); psioh.set_specific_retention(97, False); PsiMod.clean(); activate(molecule). if bsse == 'on' or bsse == 'both':; return energies_n_full[Ns[0]]; else:; return energies_n_mon[Ns[0]]. ## Aliases ##; nbody = n_body. #####################; ## End of n_body ##; #####################. ###################; ## Start of cp ##; ###################. [docs]def cp(name, **kwargs):; r""""""The cp function computes counterpoise-corrected two-body interaction energies; for complexes composed of arbitrary numbers of monomers. :aliases: counterpoise_correct(), counterpoise_correction(). :returns: (*float*) Counterpoise-corrected interaction energy in Hartrees. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`CP-CORRECTED 2-BODY INTERACTION ENERGY <CP-CORRECTED2-BODYINTERACTIONENERGY>`; * :psivar:`UNCP-CORRECTED 2-BODY INTERACTION ENERGY <UNCP-CORRECTED2-BODYINTERACTIONENERGY>`. .. caution:: Some features are not yet implemented. Buy a developer a coffee. - No values of func besides energy have been tested. - Table print-out needs improving. Add some PSI variables. :type name: string; :param name: ``'scf'`` || ``'ccsd(t)'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the molecule. May be any valid argument to; :py:func:`~driver.energy`; however, SAPT is not appropriate. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``energy`` |dr| || ``optimize`` || ``cbs``. Indicates the type of calculation to be performed on the molecule; and each of its monomers. The default performs a single-point; ``energy('name')``, while ``optimize`` perfoms a geometry optimization; on each system, and ``cbs`` performs a compound single-point energy.; If a nested series of python functions is intended; (see :ref:`sec:intercall",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/_modules/wrappers.html:16667,ENERGY,ENERGY,16667,psi4manual/4.0b3/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/_modules/wrappers.html,4,['ENERGY'],['ENERGY']
Energy Efficiency,"_bsse[Ns[k + 1]]; PsiMod.print_out(' %6s %24.16E %24.16E\n' % (n, E, physconst.psi_hartree2kcalmol * E)); PsiMod.print_out('\n'). # Put everything back the way it was; PsiMod.set_global_option('DF_INTS_IO', ri_ints_io); psioh.set_specific_retention(97, False); PsiMod.clean(); activate(molecule). if bsse == 'on' or bsse == 'both':; return energies_n_full[Ns[0]]; else:; return energies_n_mon[Ns[0]]. ## Aliases ##; nbody = n_body. #####################; ## End of n_body ##; #####################. ###################; ## Start of cp ##; ###################. [docs]def cp(name, **kwargs):; r""""""The cp function computes counterpoise-corrected two-body interaction energies; for complexes composed of arbitrary numbers of monomers. :aliases: counterpoise_correct(), counterpoise_correction(). :returns: (*float*) Counterpoise-corrected interaction energy in kcal/mol. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`CP-CORRECTED 2-BODY INTERACTION ENERGY <CP-CORRECTED2-BODYINTERACTIONENERGY>`; * :psivar:`UNCP-CORRECTED 2-BODY INTERACTION ENERGY <UNCP-CORRECTED2-BODYINTERACTIONENERGY>`. .. caution:: Some features are not yet implemented. Buy a developer a coffee. - No values of func besides energy have been tested. - Table print-out needs improving. Add some PSI variables. :type name: string; :param name: ``'scf'`` || ``'ccsd(t)'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the molecule. May be any valid argument to; :py:func:`~driver.energy`; however, SAPT is not appropriate. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``energy`` |dr| || ``optimize`` || ``cbs``. Indicates the type of calculation to be performed on the molecule; and each of its monomers. The default performs a single-point; ``energy('name')``, while ``optimize`` perfoms a geometry optimization; on each system, and ``cbs`` performs a compound single-point energy.; If a nested series of python functions is intended; (see :ref:`sec:intercall",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:16660,ENERGY,ENERGY,16660,psi4manual/4.0b2/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html,2,['ENERGY'],['ENERGY']
Energy Efficiency,"_by_level[nb] = _sum_cluster_ptype_data(; ptype,; component_results,; cp_compute_list[nb],; fragment_slice_dict,; fragment_size_dict,; mc_level_lbl=mc_level_lbl,; ); nocp_by_level[nb] = _sum_cluster_ptype_data(; ptype,; component_results,; nocp_compute_list[nb],; fragment_slice_dict,; fragment_size_dict,; mc_level_lbl=mc_level_lbl,; ); if nb in compute_dict[""vmfc_levels""]:; vmfc_by_level[nb] = _sum_cluster_ptype_data(; ptype,; component_results,; compute_dict[""vmfc_levels""][nb],; fragment_slice_dict,; fragment_size_dict,; vmfc=True,; nb=nb,; mc_level_lbl=mc_level_lbl,; ). def labeler(item) -> str:; return str(mc_level_lbl) + ""_"" + str(item). # Extract data for monomers in monomer basis for CP total data; if 1 in nbodies:; monomers_in_monomer_basis = [v for v in compute_dict[""nocp""][1] if len(v[1]) == 1]. if ptype == ""energy"":; monomer_energy_list = [component_results[labeler(m)] for m in monomers_in_monomer_basis]; monomer_sum = sum(monomer_energy_list); else:; monomer_sum = _sum_cluster_ptype_data(; ptype,; component_results,; monomers_in_monomer_basis,; fragment_slice_dict,; fragment_size_dict,; mc_level_lbl=mc_level_lbl,; ); else:; monomer_sum = shaped_zero(ptype). nbody_dict = {}. # Compute cp; if 'cp' in metadata['bsse_type']:; for nb in range(1, nbodies[-1] + 1):; if nb == metadata['nfragments']:; if ptype == ""energy"":; cp_body_dict[nb] = cp_by_level[nb] - bsse; else:; cp_body_dict[nb][:] = cp_by_level[nb] - bsse; continue. for k in range(1, nb + 1):; take_nk = math.comb(metadata['nfragments'] - k - 1, nb - k); sign = ((-1)**(nb - k)); cp_body_dict[nb] += take_nk * sign * cp_by_level[k]. if nb == 1:; bsse = cp_body_dict[nb] - monomer_sum; if ptype == ""energy"":; cp_body_dict[nb] = monomer_sum; else:; cp_body_dict[nb] = monomer_sum.copy(); else:; cp_body_dict[nb] -= bsse. if ptype == ""energy"":; if not metadata[""quiet""]:; _print_nbody_energy(cp_body_dict, ""Counterpoise Corrected (CP)"", metadata[""nfragments""], metadata['embedding_charges']). if monomer_sum != 0.0:;",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver_nbody.html:25966,energy,energy,25966,psi4manual/1.6.x/_modules/psi4/driver/driver_nbody.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver_nbody.html,10,['energy'],['energy']
Energy Efficiency,"_c_functional(build_functional('PW91_C')). # Set GKS up after adding functionals; sup.set_x_omega(0.0); sup.set_c_omega(0.0); sup.set_x_alpha(0.0); sup.set_c_alpha(0.0). # => End User-Customization <= #. # Call this last; sup.allocate(); return sup. [docs]def build_bp86_superfunctional(name, npoints, deriv):. # Call this first; sup = PsiMod.SuperFunctional.blank(); sup.set_max_points(npoints); sup.set_deriv(deriv). # => User-Customization <= #. # No spaces, keep it short and according to convention; sup.set_name('BP86'); # Tab in, trailing newlines; sup.set_description(' BP86 GGA Exchange-Correlation Functional\n'); # Tab in, trailing newlines; sup.set_citation(' Null\n'). # Add member functionals; sup.add_x_functional(build_functional('B88_X')); sup.add_c_functional(build_functional('P86_C')). # Set GKS up after adding functionals; sup.set_x_omega(0.0); sup.set_c_omega(0.0); sup.set_x_alpha(0.0); sup.set_c_alpha(0.0). # => End User-Customization <= #. # Call this last; sup.allocate(); return sup. [docs]def build_ft97_superfunctional(name, npoints, deriv):. # Call this first; sup = PsiMod.SuperFunctional.blank(); sup.set_max_points(npoints); sup.set_deriv(deriv). # => User-Customization <= #. # No spaces, keep it short and according to convention; sup.set_name('FT97'); # Tab in, trailing newlines; sup.set_description(' FT97 GGA Exchange-Correlation Functional\n'); # Tab in, trailing newlines; sup.set_citation(' M. Filatov and W. Theil, Int. J. Quant. Chem., 62, 603-616, 1997\n'). # Add member functionals; sup.add_x_functional(build_functional('FT97B_X')); sup.add_c_functional(build_functional('FT97_C')). # Set GKS up after adding functionals; sup.set_x_omega(0.0); sup.set_c_omega(0.0); sup.set_x_alpha(0.0); sup.set_c_alpha(0.0). # => End User-Customization <= #. # Call this last; sup.allocate(); return sup. [docs]def build_pbe_superfunctional(name, npoints, deriv):. # Call this first; sup = PsiMod.SuperFunctional.blank(); sup.set_max_points(npoints); sup.set_deriv(de",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/_modules/functional.html:23094,allocate,allocate,23094,psi4manual/4.0b2/_modules/functional.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/functional.html,6,['allocate'],['allocate']
Energy Efficiency,"_cc_gradient,; 'mp2' : run_mp2_gradient,; 'eom-ccsd' : run_eom_cc_gradient,; 'dcft' : run_dcft_gradient; # Upon adding a method to this list, add it to the docstring in optimize() below; },; 'hessian' : {; # Upon adding a method to this list, add it to the docstring in frequency() below; },; 'property' : {; 'scf' : run_scf_property,; 'cc2' : run_cc_property,; 'ccsd' : run_cc_property,; 'eom-cc2' : run_cc_property,; 'eom-ccsd' : run_cc_property,; 'eom_cc2' : run_cc_property,; 'eom_ccsd' : run_cc_property; # Upon adding a method to this list, add it to the docstring in property() below; }}. # Integrate DFT with driver routines; for ssuper in superfunctional_list():; procedures['energy'][ssuper.name().lower()] = run_dft. for ssuper in superfunctional_list():; procedures['gradient'][ssuper.name().lower()] = run_dft_gradient. [docs]def energy(name, **kwargs):; r""""""Function to compute the single-point electronic energy. :returns: (*float*) Total electronic energy in Hartrees. SAPT returns interaction energy. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`CURRENT ENERGY <CURRENTENERGY>`; * :psivar:`CURRENT REFERENCE ENERGY <CURRENTREFERENCEENERGY>`; * :psivar:`CURRENT CORRELATION ENERGY <CURRENTCORRELATIONENERGY>`. .. comment In this table immediately below, place methods that should only be called by ; .. comment developers at present. This table won't show up in the manual.; .. comment; .. comment .. _`table:energy_devel`:; .. comment ; .. comment +-------------------------+---------------------------------------------------------------------------------------+; .. comment | name | calls method |; .. comment +=========================+=======================================================================================+; .. comment | df-cc | coupled cluster with density fitting |; .. comment +-------------------------+---------------------------------------------------------------------------------------+; .. comment | mp2c | coupled MP2 (MP2C) |; .. comment +----",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/_modules/driver.html:3253,energy,energy,3253,psi4manual/4.0b2/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/driver.html,2,['energy'],['energy']
Energy Efficiency,"_corl and do_delta and do_delta2 and not do_delta3 and not do_delta4 and not do_delta5:; pass; elif do_scf and do_corl and do_delta and do_delta2 and do_delta3 and not do_delta4 and not do_delta5:; pass; elif do_scf and do_corl and do_delta and do_delta2 and do_delta3 and do_delta4 and not do_delta5:; pass; elif do_scf and do_corl and do_delta and do_delta2 and do_delta3 and do_delta4 and do_delta5:; pass; else:; raise ValidationError('Requested scf (%s) + corl (%s) + delta (%s) + delta2 (%s) + delta3 (%s) + delta4 (%s) + delta5 (%s) not valid. These steps are cummulative.' %; (do_scf, do_corl, do_delta, do_delta2, do_delta3, do_delta4, do_delta5)). # Establish list of valid basis sets for correlation energy; if do_corl:; if 'corl_basis' in kwargs:; BSTC, ZETC = validate_bracketed_basis(kwargs['corl_basis'].lower()); else:; raise ValidationError('CORL basis sets through keyword \'%s\' are required.' % ('corl_basis')). # Establish list of valid basis sets for scf energy; if 'scf_basis' in kwargs:; BSTR, ZETR = validate_bracketed_basis(kwargs['scf_basis'].lower()); else:; if do_corl:; BSTR = BSTC[:]; ZETR = ZETC[:]; else:; raise ValidationError('SCF basis sets through keyword \'%s\' are required. Or perhaps you forgot the \'%s\'.' % ('scf_basis', 'corl_wfn')). # Establish list of valid basis sets for delta correction energy; if do_delta:; if 'delta_basis' in kwargs:; BSTD, ZETD = validate_bracketed_basis(kwargs['delta_basis'].lower()); else:; raise ValidationError('DELTA basis sets through keyword \'%s\' are required.' % ('delta_basis')). # Establish list of valid basis sets for second delta correction energy; if do_delta2:; if 'delta2_basis' in kwargs:; BSTD2, ZETD2 = validate_bracketed_basis(kwargs['delta2_basis'].lower()); else:; raise ValidationError('DELTA2 basis sets through keyword \'%s\' are required.' % ('delta2_basis')). # Establish list of valid basis sets for third delta correction energy; if do_delta3:; if 'delta3_basis' in kwargs:; BSTD3, ZETD3 = validate",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:75565,energy,energy,75565,psi4manual/4.0b5/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html,2,['energy'],['energy']
Energy Efficiency,"_counts=True); for irrep, cnt in zip(*ea_info):; irrep = int(irrep); ep2_input[irrep].extend(range(nalphapi[irrep], nalphapi[irrep] + cnt)). # Compute; ret = dfep2_wfn.compute(ep2_input). # Resort it...; ret_eps = []; for h in range(dfep2_wfn.nirrep()):; ep2_data = ret[h]; inp_data = ep2_input[h]. for i in range(len(ep2_data)):; tmp = [h, ep2_data[i][0], ep2_data[i][1], dfep2_wfn.epsilon_a().get(h, inp_data[i]), inp_data[i]]; ret_eps.append(tmp). ret_eps.sort(key=lambda x: x[3]). h2ev = constants.hartree2ev; irrep_labels = dfep2_wfn.molecule().irrep_labels(). core.print_out("" ==> Results <==\n\n""); core.print_out("" %8s %12s %12s %8s\n"" % (""Orbital"", ""Koopmans (eV)"", ""EP2 (eV)"", ""EP2 PS"")); core.print_out("" ----------------------------------------------\n""); for irrep, ep2, ep2_ps, kt, pos in ret_eps:; label = str(pos + 1) + irrep_labels[irrep]; core.print_out("" %8s % 12.3f % 12.3f % 6.3f\n"" % (label, (kt * h2ev), (ep2 * h2ev), ep2_ps)); core.set_variable(""EP2 "" + label.upper() + "" ENERGY"", ep2); core.print_out("" ----------------------------------------------\n\n""). # Figure out the IP and EA; sorted_vals = np.array([x[1] for x in ret_eps]); ip_vals = sorted_vals[sorted_vals < 0]; ea_vals = sorted_vals[sorted_vals > 0]. ip_value = None; ea_value = None; if len(ip_vals):; core.set_variable(""EP2 IONIZATION POTENTIAL"", ip_vals[-1]); core.set_variable(""CURRENT ENERGY"", ip_vals[-1]); if len(ea_vals):; core.set_variable(""EP2 ELECTRON AFFINITY"", ea_vals[0]); if core.variable(""EP2 IONIZATION POTENTIAL"") == 0.0:; core.set_variable(""CURRENT ENERGY"", ea_vals[0]). core.print_out("" EP2 has completed successfully!\n\n""). core.tstop(); return dfep2_wfn. def run_dlpnomp2(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a DLPNO-MP2 calculation. """"""; optstash = p4util.OptionsState(; ['DF_BASIS_MP2'],; ['SCF_TYPE']). # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'); core.print_out("""""" SCF Alg",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/_modules/psi4/driver/procrouting/proc.html:129743,ENERGY,ENERGY,129743,psi4manual/1.5.0/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/_modules/psi4/driver/procrouting/proc.html,6,['ENERGY'],['ENERGY']
Energy Efficiency,"_counts=True); for irrep, cnt in zip(*ea_info):; irrep = int(irrep); ep2_input[irrep].extend(range(nalphapi[irrep], nalphapi[irrep] + cnt)). # Compute; ret = dfep2_wfn.compute(ep2_input). # Resort it...; ret_eps = []; for h in range(dfep2_wfn.nirrep()):; ep2_data = ret[h]; inp_data = ep2_input[h]. for i in range(len(ep2_data)):; tmp = [h, ep2_data[i][0], ep2_data[i][1], dfep2_wfn.epsilon_a().get(h, inp_data[i]), inp_data[i]]; ret_eps.append(tmp). ret_eps.sort(key=lambda x: x[3]). h2ev = constants.hartree2ev; irrep_labels = dfep2_wfn.molecule().irrep_labels(). core.print_out("" ==> Results <==\n\n""); core.print_out("" %8s %12s %12s %8s\n"" % (""Orbital"", ""Koopmans (eV)"", ""EP2 (eV)"", ""EP2 PS"")); core.print_out("" ----------------------------------------------\n""); for irrep, ep2, ep2_ps, kt, pos in ret_eps:; label = str(pos + 1) + irrep_labels[irrep]; core.print_out("" %8s % 12.3f % 12.3f % 6.3f\n"" % (label, (kt * h2ev), (ep2 * h2ev), ep2_ps)); core.set_variable(""EP2 "" + label.upper() + "" ENERGY"", ep2); core.print_out("" ----------------------------------------------\n\n""). # Figure out the IP and EA; sorted_vals = np.array([x[1] for x in ret_eps]); ip_vals = sorted_vals[sorted_vals < 0]; ea_vals = sorted_vals[sorted_vals > 0]. ip_value = None; ea_value = None; if len(ip_vals):; core.set_variable(""EP2 IONIZATION POTENTIAL"", ip_vals[-1]); core.set_variable(""CURRENT ENERGY"", ip_vals[-1]); if len(ea_vals):; core.set_variable(""EP2 ELECTRON AFFINITY"", ea_vals[0]); if core.variable(""EP2 IONIZATION POTENTIAL"") == 0.0:; core.set_variable(""CURRENT ENERGY"", ea_vals[0]). core.print_out("" EP2 has completed successfully!\n\n""). core.tstop(); return dfep2_wfn. def run_dmrgscf(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; an DMRG calculation. """"""; optstash = p4util.OptionsState(; ['SCF_TYPE'],; ['DMRG', 'DMRG_CASPT2_CALC']). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html:129448,ENERGY,ENERGY,129448,psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,1,['ENERGY'],['ENERGY']
Energy Efficiency,"_df: :ref:`boolean <op_py_boolean>` or string; .. comment :param cast_up_df: ``'on'`` || |dl| ``'off'`` |dr| || ``'cc-pVDZ-RI'`` || ``'aug-cc-pVDZ-JKFIT'`` || etc. .. comment Indicates whether, when *cast_up* is active, to run the preliminary; .. comment scf in density-fitted mode or what fitting basis to employ (when; .. comment available for all elements, cc-pVDZ-RI is the default). .. comment .. deprecated:: Sept-2012; .. comment Use option |scf__df_basis_guess| instead. :type bypass_scf: :ref:`boolean <op_py_boolean>`; :param bypass_scf: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether, for *name* values built atop of scf calculations,; the scf step is skipped. Suitable when special steps are taken to get; the scf to converge in an explicit preceeding scf step. :examples:. >>> # [1] Coupled-cluster singles and doubles calculation with psi code; >>> energy('ccsd'). >>> # [2] Charge-transfer SAPT calculation with scf projection from small into; >>> # requested basis, with specified projection fitting basis; >>> set basis_guess true; >>> set df_basis_guess jun-cc-pVDZ-JKFIT; >>> energy('sapt0-ct'). >>> # [3] Arbitrary-order MPn calculation; >>> energy('mp4'). >>> # [4] Converge scf as singlet, then run detci as triplet upon singlet reference; >>> molecule H2 {\\n0 1\\nH\\nH 1 0.74\\n}; >>> energy('scf'); >>> H2.set_multiplicity(3); >>> energy('detci', bypass_scf=True). """"""; lowername = name.lower(); kwargs = kwargs_lower(kwargs). optstash = OptionsState(; ['SCF', 'E_CONVERGENCE'],; ['SCF', 'D_CONVERGENCE'],; ['E_CONVERGENCE']). # Make sure the molecule the user provided is the active one; if 'molecule' in kwargs:; activate(kwargs['molecule']); del kwargs['molecule']; molecule = PsiMod.get_active_molecule(); molecule.update_geometry(). # Allow specification of methods to arbitrary order; lowername, level = parse_arbitrary_order(lowername); if level:; kwargs['level'] = level. try:; # Set method-dependent scf convergence criteria; if not PsiMod.has_option_changed('S",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/_modules/driver.html:28501,energy,energy,28501,psi4manual/4.0b4/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/driver.html,3,"['Charge', 'energy']","['Charge-transfer', 'energy']"
Energy Efficiency,"_df: :ref:`boolean <op_py_boolean>` or string; .. comment :param cast_up_df: ``'on'`` || |dl| ``'off'`` |dr| || ``'cc-pVDZ-RI'`` || ``'aug-cc-pVDZ-JKFIT'`` || etc. .. comment Indicates whether, when *cast_up* is active, to run the preliminary; .. comment scf in density-fitted mode or what fitting basis to employ (when; .. comment available for all elements, cc-pVDZ-RI is the default). .. comment .. deprecated:: Sept-2012; .. comment Use option |scf__df_basis_guess| instead. :type bypass_scf: :ref:`boolean <op_py_boolean>`; :param bypass_scf: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether, for *name* values built atop of scf calculations,; the scf step is skipped. Suitable when special steps are taken to get; the scf to converge in an explicit preceeding scf step. :examples:. >>> # [1] Coupled-cluster singles and doubles calculation with psi code; >>> energy('ccsd'). >>> # [2] Charge-transfer SAPT calculation with scf projection from small into; >>> # requested basis, with specified projection fitting basis; >>> set basis_guess true; >>> set df_basis_guess jun-cc-pVDZ-JKFIT; >>> energy('sapt0-ct'). >>> # [3] Arbitrary-order MPn calculation; >>> energy('mp4'). >>> # [4] Converge scf as singlet, then run detci as triplet upon singlet reference; >>> molecule H2 {\\n0 1\\nH\\nH 1 0.74\\n}; >>> energy('scf'); >>> H2.set_multiplicity(3); >>> energy('detci', bypass_scf=True). """"""; lowername = name.lower(); kwargs = p4util.kwargs_lower(kwargs). optstash = p4util.OptionsState(; ['SCF', 'E_CONVERGENCE'],; ['SCF', 'D_CONVERGENCE'],; ['E_CONVERGENCE']). # Make sure the molecule the user provided is the active one; if 'molecule' in kwargs:; activate(kwargs['molecule']); del kwargs['molecule']; molecule = psi4.get_active_molecule(); molecule.update_geometry(). # Allow specification of methods to arbitrary order; lowername, level = parse_arbitrary_order(lowername); if level:; kwargs['level'] = level. try:; # Set method-dependent scf convergence criteria; if not psi4.has_option_",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/driver.html:29334,energy,energy,29334,psi4manual/4.0b5/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/driver.html,3,"['Charge', 'energy']","['Charge-transfer', 'energy']"
Energy Efficiency,"_dict[1]; if monomer_energies != 0.0:; nbody_dict['Counterpoise Corrected Total Energy'] = cp_energy_body_dict[metadata['max_nbody']]; nbody_dict['Counterpoise Corrected Interaction Energy'] = cp_interaction_energy. # Compute nocp energy and ptype; if 'nocp' in metadata['bsse_type_list']:; for n in nbody_range:; if n == metadata['max_frag']:; nocp_energy_body_dict[n] = nocp_energy_by_level[n]; if metadata['ptype'] != 'energy':; nocp_ptype_body_dict[n][:] = nocp_ptype_by_level[n]; continue. for k in range(1, n + 1):; take_nk = nCr(metadata['max_frag'] - k - 1, n - k); sign = ((-1)**(n - k)); value = nocp_energy_by_level[k]; nocp_energy_body_dict[n] += take_nk * sign * value. if metadata['ptype'] != 'energy':; value = nocp_ptype_by_level[k]; nocp_ptype_body_dict[n] += take_nk * sign * value. _print_nbody_energy(nocp_energy_body_dict, ""Non-Counterpoise Corrected (NoCP)"", metadata['embedding_charges']); nocp_interaction_energy = nocp_energy_body_dict[metadata['max_nbody']] - nocp_energy_body_dict[1]; nbody_dict['Non-Counterpoise Corrected Total Energy'] = nocp_energy_body_dict[metadata['max_nbody']]; nbody_dict['Non-Counterpoise Corrected Interaction Energy'] = nocp_interaction_energy. for n in nbody_range[1:]:; var_key = 'NOCP-CORRECTED %d-BODY INTERACTION ENERGY' % n; nbody_dict[var_key] = nocp_energy_body_dict[n] - nocp_energy_body_dict[1]. # Compute vmfc ptype; if 'vmfc' in metadata['bsse_type_list']:; if metadata['ptype'] != 'energy':; for n in nbody_range:; if n > 1:; vmfc_ptype_body_dict[n] = vmfc_ptype_by_level[n - 1]; vmfc_ptype_body_dict[n] += vmfc_ptype_by_level[n]. _print_nbody_energy(vmfc_energy_body_dict, ""Valiron-Mayer Function Couterpoise (VMFC)"",; metadata['embedding_charges']); vmfc_interaction_energy = vmfc_energy_body_dict[metadata['max_nbody']] - vmfc_energy_body_dict[1]; nbody_dict['Valiron-Mayer Function Couterpoise Total Energy'] = vmfc_energy_body_dict[metadata['max_nbody']]; nbody_dict['Valiron-Mayer Function Couterpoise Interaction Energy'] = ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_nbody.html:27690,Energy,Energy,27690,psi4manual/1.4.0/_modules/psi4/driver/driver_nbody.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_nbody.html,4,['Energy'],['Energy']
Energy Efficiency,"_dispersion.py; ""params"": {}, parameters for the dispersion correction; ""nlc"": False (optional) logical switch to turn off nlc (e.g. VV10) correction defined by LibXC; ""citation"": """", special reference for the dispersion correction parameters, appended to output. One can also use the dft_functional keyword argument to use the; orbitals generated by DFT for correlated wavefunction methods:; # MP2 with a PBE0 reference computation. molecule h2o {; 0 1; O; H 1 1.0; H 1 1.0 2 104.5; }. set {; basis 6-31G; dft_spherical_points 302; dft_radial_points 99; reference rks; }. mp2_dft = energy(""MP2"", dft_functional=""PBE0""). Note that this would only update the generic Psi variables (e.g., “CURRENT ENERGY”) and not the MP2 or DFT variables.; Psi4 also supports easy customization and manipulation of DFT functionals. The values of alpha and omega can be adjusted with the DFT_ALPHA; and DFT_OMEGA keywords. For example, for LRC functionals, one can control the fraction of long-range Hartree-Fock and short-range DFA by changing DFT_OMEGA:; molecule ch2 {; 0 3; C; H 1 R; H 1 R 2 A. R = 1.075; A = 133.93; }. set reference uhf; set guess gwh; set basis cc-pvdz; set e_convergence 8. # Override the default value of omega; set dft_omega 2.0. E = energy('wb97x'). # Revoke the change for later computations if needed; revoke_global_option_changed('DFT_OMEGA'). This feature would be useful after finishing the IP fitting procedure, for example. table of contents. DFT: Density Functional Theory; Theory; Minimal Input; Spin/Symmetry Treatment; Functional Selection; Grid Selection; ERI Algorithms; IP Fitting; Fractional Particle Curves; Dispersion Corrections; Recommendations; Advanced Functional Use and Manipulation. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Theoretical Methods: SCF to FCI; DFT: Density Functional Theory. © Copyright 2022, The Psi4 Project.; Last updated on Thursday, 19 May 2022 08:57PM.; Created using Sphinx 4.5.0.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/dft.html:33688,energy,energy,33688,psi4manual/1.6.x/dft.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/dft.html,1,['energy'],['energy']
Energy Efficiency,_electron_mag_mom_ratio; 0.00104066882; neutron-electron mag. mom. ratio [] uncertainty=0.000 000 25 e-3. neutron_electron_mass_ratio; 1838.68366158; neutron-electron mass ratio [] uncertainty=0.000 000 90. neutron_g_factor; -3.82608545; neutron g factor [] uncertainty=0.000 000 90. neutron_gyromag_ratio; 183247172; neutron gyromag. ratio [s^{-1} T^{-1}] uncertainty=0.000 000 43 e8. neutron_gyromag_ratio_over_2_pi; 29.1646933; neutron gyromag. ratio over 2 pi [MHz T^{-1}] uncertainty=0.000 0069. neutron_mag_mom; -9.6623650E-27; neutron mag. mom. [J T^{-1}] uncertainty=0.000 000 23 e-26. neutron_mag_mom_to_Bohr_magneton_ratio; -0.00104187563; neutron mag. mom. to Bohr magneton ratio [] uncertainty=0.000 000 25 e-3. neutron_mag_mom_to_nuclear_magneton_ratio; -1.91304273; neutron mag. mom. to nuclear magneton ratio [] uncertainty=0.000 000 45. neutron_mass; 1.674927471E-27; neutron mass [kg] uncertainty=0.000 000 021 e-27. neutron_mass_energy_equivalent; 1.505349739E-10; neutron mass energy equivalent [J] uncertainty=0.000 000 019 e-10. neutron_mass_energy_equivalent_in_MeV; 939.5654133; neutron mass energy equivalent in MeV [MeV] uncertainty=0.000 0058. neutron_mass_in_u; 1.00866491588; neutron mass in u [u] uncertainty=0.000 000 000 49. neutron_molar_mass; 0.00100866491588; neutron molar mass [kg mol^{-1}] uncertainty=0.000 000 000 49 e-3. neutron_muon_mass_ratio; 8.89248408; neutron-muon mass ratio [] uncertainty=0.000 000 20. neutron_proton_mag_mom_ratio; -0.68497934; neutron-proton mag. mom. ratio [] uncertainty=0.000 000 16. neutron_proton_mass_difference; 2.30557377E-30; neutron-proton mass difference [] uncertainty=0.000 000 85 e-30. neutron_proton_mass_difference_energy_equivalent; 2.07214637E-13; neutron-proton mass difference energy equivalent [] uncertainty=0.000 000 76 e-13. neutron_proton_mass_difference_energy_equivalent_in_MeV; 1.29333205; neutron-proton mass difference energy equivalent in MeV [] uncertainty=0.000 000 48. neutron_proton_mass_difference,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/autodoc_physconst-1.html:25666,energy,energy,25666,psi4manual/1.3.2/autodoc_physconst-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/autodoc_physconst-1.html,11,['energy'],['energy']
Energy Efficiency,"_eqn.rst. * Energy Methods; The presence of a stage_wfn keyword is the indicator to incorporate; (and check for stage_basis and stage_scheme keywords) and compute; that stage in defining the CBS energy. The cbs() function requires, at a minimum, ``name='scf'`` and ``scf_basis``; keywords to be specified for reference-step only jobs and ``name`` and; ``corl_basis`` keywords for correlated jobs. The following energy methods have been set up for cbs(). .. hlist::; :columns: 5. * scf; * df-scf; * mp2; * df-mp2; * cc2; * ccsd; * bccd; * cc3; * ccsd(t); * cisd; * cisdt; * cisdtq; * ci\ *n*; * fci. :type name: string; :param name: ``'scf'`` || ``'ccsd'`` || etc. First argument, usually unlabeled. Indicates the computational method; for the correlation energy, unless only reference step to be performed,; in which case should be ``'scf'``. Overruled if stage_wfn keywords supplied. :type corl_wfn: string; :param corl_wfn: ``'mp2'`` || ``'ccsd(t)'`` || etc. Indicates the energy method for which the correlation energy is to be; obtained. Can also be specified with ``name`` or as the unlabeled; first argument to the function. :type delta_wfn: string; :param delta_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a delta correction; to the correlation energy is to be obtained. :type delta_wfn_lesser: string; :param delta_wfn_lesser: |dl| ``'mp2'`` |dr| || ``'ccsd'`` || etc. Indicates the inferior energy method for which a delta correction; to the correlation energy is to be obtained. :type delta2_wfn: string; :param delta2_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a second delta correction; to the correlation energy is to be obtained. :type delta2_wfn_lesser: string; :param delta2_wfn_lesser: |dl| ``'mp2'`` |dr| || ``'ccsd(t)'`` || etc. Indicates the inferior energy method for which a second delta correction; to the correlation energy is to be obtained. * Basis Sets; Currently, the basis set se",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/_modules/wrappers.html:54444,energy,energy,54444,psi4manual/4.0b3/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/_modules/wrappers.html,4,['energy'],['energy']
Energy Efficiency,"_file(filename=None)¶; Converts a Wavefunction object to a base class. Parameters. wfn (Wavefunction) – A Wavefunction or inherited class; filename (Optional[str]) – An optional filename to write the data to. Returns; A dictionary and NumPy representation of the Wavefunction. Return type; dict. total_index(self: psi4.core.CCWavefunction, i: int, h: int) → int¶; Map an index (i) within irrep (h) to its energy-sorted index among all roots. variable(key)¶; Return copy of scalar or array QCVariable key from self psi4.core.Wavefunction. Returns; Scalar variables are returned as floats.; Array variables not naturally 2D (like multipoles) are returned as numpy.ndarray of natural dimensionality.; Other array variables are returned as Matrix and may have an extra dimension with symmetry information. Return type; float or numpy.ndarray or Matrix. Parameters. cls (psi4.core.Wavefunction) – ; key (str) – . Example; >>> g, wfn = psi4.gradient(""hf/cc-pvdz"", return_wfn=True); >>> wfn.variable(""CURRENT ENERGY""); -100.00985995185668; >>> wfn.variable(""CURRENT DIPOLE""); array([ 0. , 0. , -0.83217802]); >>> wfn.variable(""CURRENT GRADIENT""); <psi4.core.Matrix object at 0x12d884fc0>; >>> wfn.variable(""CURRENT GRADIENT"").np; array([[ 6.16297582e-33, 6.16297582e-33, -9.41037138e-02],; [-6.16297582e-33, -6.16297582e-33, 9.41037138e-02]]). variables(include_deprecated_keys=False)¶; Return all scalar or array QCVariables from cls. Return type; Dict[str, Union[float, Matrix, ndarray]]. Parameters; include_deprecated_keys (bool) – . write_molden(filename=None, do_virtual=None, use_natural=False)¶; Function to write wavefunction information in wfn to filename in; molden format. Will write natural orbitals from density (MO basis) if supplied.; Warning! Most post-SCF Wavefunctions do not build the density as this is often; much more costly than the energy. In addition, the Wavefunction density attributes; (Da and Db) return the SO density and must be transformed to the MO basis; to use with this f",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/api/psi4.core.CCWavefunction.html:26261,ENERGY,ENERGY,26261,psi4manual/1.6.x/api/psi4.core.CCWavefunction.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/api/psi4.core.CCWavefunction.html,1,['ENERGY'],['ENERGY']
Energy Efficiency,"_fnocc('qcisd(t)',**kwargs). # HLC: high-level correction based on number of valence electrons; ref = psi4.wavefunction(); nirrep = ref.nirrep(); frzcpi = ref.frzcpi(); nfzc = 0; for i in range (0,nirrep):; nfzc += frzcpi[i]; nalpha = ref.nalpha() - nfzc; nbeta = ref.nbeta() - nfzc; # hlc of gaussian-2; hlc = -0.00481 * nalpha -0.00019 * nbeta; # hlc of gaussian-1; hlc1 = -0.00614 * nalpha. eqci_6311gdp = psi4.get_variable(""QCISD(T) TOTAL ENERGY""); emp4_6311gd = psi4.get_variable(""MP4 TOTAL ENERGY""); emp2_6311gd = psi4.get_variable(""MP2 TOTAL ENERGY""); psi4.clean(). # correction for diffuse functions; psi4.set_global_option('BASIS',""6-311+G(D_P)""); energy('mp4'); emp4_6311pg_dp = psi4.get_variable(""MP4 TOTAL ENERGY""); emp2_6311pg_dp = psi4.get_variable(""MP2 TOTAL ENERGY""); psi4.clean(). # correction for polarization functions; psi4.set_global_option('BASIS',""6-311G(2DF_P)""); energy('mp4'); emp4_6311g2dfp = psi4.get_variable(""MP4 TOTAL ENERGY""); emp2_6311g2dfp = psi4.get_variable(""MP2 TOTAL ENERGY""); psi4.clean(). # big basis mp2; psi4.set_global_option('BASIS',""6-311+G(3DF_2P)""); run_fnocc('_mp2',**kwargs); emp2_big = psi4.get_variable(""MP2 TOTAL ENERGY""); psi4.clean(). eqci = eqci_6311gdp; e_delta_g2 = emp2_big + emp2_6311gd - emp2_6311g2dfp - emp2_6311pg_dp; e_plus = emp4_6311pg_dp - emp4_6311gd; e_2df = emp4_6311g2dfp - emp4_6311gd. eg2 = eqci + e_delta_g2 + e_plus + e_2df; eg2_mp2_0k = eqci + (emp2_big - emp2_6311gd) + hlc + zpe. psi4.print_out('\n'); psi4.print_out(' ==> G1/G2 Energy Components <==\n'); psi4.print_out('\n'); psi4.print_out(' QCISD(T): %20.12lf\n' % eqci); psi4.print_out(' E(Delta): %20.12lf\n' % e_delta_g2); psi4.print_out(' E(2DF): %20.12lf\n' % e_2df); psi4.print_out(' E(+): %20.12lf\n' % e_plus); psi4.print_out(' E(G1 HLC): %20.12lf\n' % hlc1); psi4.print_out(' E(G2 HLC): %20.12lf\n' % hlc); psi4.print_out(' E(ZPE): %20.12lf\n' % zpe); psi4.print_out('\n'); psi4.print_out(' ==> 0 Kelvin Results <==\n'); psi4.print_out('\n'); eg2_0k = eg2 + zp",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/gaussian_n.html:3586,ENERGY,ENERGY,3586,psi4manual/4.0b5/_modules/gaussian_n.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/gaussian_n.html,1,['ENERGY'],['ENERGY']
Energy Efficiency,"_for_input()); p4util.format_kwargs_for_input(freagent, **kwargs). # S/R: Prepare function call and energy save; freagent.write(""""""electronic_energy = %s('%s', **kwargs)\n\n"""""" % (func.__name__, lowername)); freagent.write(""""""psi4.print_out('\\nGRADIENT RESULT: computation %d for item %d """""" % (os.getpid(), n + 1)); freagent.write(""""""yields electronic energy %20.12f\\n' % (electronic_energy))\n\n""""""); freagent.close(). # S/R: Read energy from each displaced geometry output file and save in energies array; elif (opt_mode.lower() == 'reap'):; exec(banners); psi4.set_variable('NUCLEAR REPULSION ENERGY', molecule.nuclear_repulsion_energy()); energies.append(p4util.extract_sowreap_from_output(rfile, 'GRADIENT', n, opt_linkage, True)). # S/R: Quit sow after writing files; if (opt_mode.lower() == 'sow'):; optstash.restore(); return 0.0. if (opt_mode.lower() == 'reap'):; psi4.set_variable('CURRENT ENERGY', energies[-1]). # Obtain the gradient; psi4.fd_1_0(energies); # The last item in the list is the reference energy, return it; optstash.restore(); return energies[-1]. [docs]def property(name, **kwargs):; r""""""Function to compute various properties. :aliases: prop(). :returns: none. .. caution:: Some features are not yet implemented. Buy a developer a coffee. - This function at present handles property functions only for CC methods.; Consult the keywords sections for other modules for further property capabilities. +-------------------------+---------------------------------------------------------------------------------------+; | name | calls method |; +=========================+=======================================================================================+; | scf | Self-consistent field method(s) |; +-------------------------+---------------------------------------------------------------------------------------+; | cc2 | 2nd-order approximate CCSD |; +-------------------------+---------------------------------------------------------------------------------------",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/driver.html:41109,energy,energy,41109,psi4manual/4.0b5/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/driver.html,2,['energy'],['energy']
Energy Efficiency,"_global_option(""BASIS"")); dimer_wfn.set_basisset(""DF_BASIS_ELST"", aux_basis). core.print_out('\n'); p4util.banner('SAPT Charge Transfer'); core.print_out('\n'). core.print_out('\n'); p4util.banner('Dimer Basis SAPT'); core.print_out('\n'); core.IO.change_file_namespace(psif.PSIF_SAPT_MONOMERA, 'monomerA', 'dimer'); core.IO.change_file_namespace(psif.PSIF_SAPT_MONOMERB, 'monomerB', 'dimer'); e_sapt = core.sapt(dimer_wfn, monomerA_wfn, monomerB_wfn); CTd = core.variable('SAPT CT ENERGY'); dimer_wfn.set_module(""sapt""). core.print_out('\n'); p4util.banner('Monomer Basis SAPT'); core.print_out('\n'); core.IO.change_file_namespace(psif.PSIF_SAPT_MONOMERA, 'monomerAm', 'dimer'); core.IO.change_file_namespace(psif.PSIF_SAPT_MONOMERB, 'monomerBm', 'dimer'); e_sapt = core.sapt(dimer_wfn, monomerAm_wfn, monomerBm_wfn); CTm = core.variable('SAPT CT ENERGY'); CT = CTd - CTm. units = (1000.0, constants.hartree2kcalmol, constants.hartree2kJmol); core.print_out('\n\n'); core.print_out(' SAPT Charge Transfer Analysis\n'); core.print_out(' ------------------------------------------------------------------------------------------------\n'); core.print_out(' SAPT Induction (Dimer Basis) %12.4lf [mEh] %12.4lf [kcal/mol] %12.4lf [kJ/mol]\n' %; tuple(CTd * u for u in units)); core.print_out(' SAPT Induction (Monomer Basis)%12.4lf [mEh] %12.4lf [kcal/mol] %12.4lf [kJ/mol]\n' %; tuple(CTm * u for u in units)); core.print_out(' SAPT Charge Transfer %12.4lf [mEh] %12.4lf [kcal/mol] %12.4lf [kJ/mol]\n\n' %; tuple(CT * u for u in units)); core.set_variable(""SAPT CT ENERGY"", CT) # P::e SAPT. optstash.restore(); return dimer_wfn. def run_fisapt(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; an F/ISAPT0 computation. """"""; optstash = p4util.OptionsState(['SCF_TYPE']). # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'). # Get the molecule of interest; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is Non",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html:144447,Charge,Charge,144447,psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,7,['Charge'],['Charge']
Energy Efficiency,"_global_option(""DF_INTS_IO"", ""SAVE""). Ns = []; energies = []; potentials = []; convs = []; stats = []. # Run one SCF to burn things in; energy('scf'). # Determine HOMO; ref = PsiMod.wavefunction(); eps_a = ref.epsilon_a(); eps_b = ref.epsilon_b(); if (Na == Nb):; HOMO = -Nb; elif (Nb == 0):; HOMO = Na; else:; E_a = eps_a[int(Na - 1)] ; E_b = eps_b[int(Nb - 1)] ; if (E_a >= E_b):; HOMO = Na; else: ; HOMO = -Nb. stats.append('\t%6d %6d %6d %6d %6d %6d\n' %(N, Na, Nb, charge, mult, HOMO)). if (HOMO > 0):; Na = Na - 1; else:; Nb = Nb - 1; charge = charge + 1; mult = Na - Nb + 1. PsiMod.set_global_option(""DF_INTS_IO"", ""LOAD""); PsiMod.set_global_option(""FRAC_START"", frac_start); PsiMod.set_global_option(""FRAC_RENORMALIZE"", True). # Nuke 'em Rico! ; for Nintegral in range(N,Nmin,-1):. # Nuke the current HOMO; for occ in foccs:. PsiMod.set_global_option(""FRAC_OCC"", [HOMO]); PsiMod.set_global_option(""FRAC_VAL"", [occ]) . E = energy('scf'); C = 1; if (E == 0.0):; E = PsiMod.get_variable('SCF ITERATION ENERGY'); C = 0. if (HOMO > 0):; ref = PsiMod.wavefunction(); eps = ref.epsilon_a(); potentials.append(eps[HOMO-1]); else:; ref = PsiMod.wavefunction(); eps = ref.epsilon_b(); potentials.append(eps[-HOMO-1]). Ns.append(Nintegral + occ - 1.0); energies.append(E); convs.append(C). PsiMod.set_global_option(""FRAC_START"", 2); PsiMod.set_global_option(""FRAC_LOAD"", True); PsiMod.set_global_option(""FRAC_DIIS"", frac_diis); PsiMod.set_global_option(""GUESS"", ""READ""). # Set the next charge/mult; mol.set_molecular_charge(charge) ; mol.set_multiplicity(mult). # Determine HOMO; ref = PsiMod.wavefunction(); eps_a = ref.epsilon_a(); eps_b = ref.epsilon_b(); if (Na == Nb):; HOMO = -Nb; elif (Nb == 0):; HOMO = Na; else:; E_a = eps_a[int(Na - 1)] ; E_b = eps_b[int(Nb - 1)] ; if (E_a >= E_b):; HOMO = Na; else: ; HOMO = -Nb. stats.append('\t%6d %6d %6d %6d %6d %6d\n' %(Nintegral-1, Na, Nb, charge, mult, HOMO)). if (HOMO > 0):; Na = Na - 1; else:; Nb = Nb - 1; charge = charge + 1; mult = Na - Nb + 1; ;",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/_modules/frac.html:8705,ENERGY,ENERGY,8705,psi4manual/4.0b4/_modules/frac.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/frac.html,1,['ENERGY'],['ENERGY']
Energy Efficiency,"_global_option('DF_BASIS_MP2', ribasis); PsiMod.print_out('No DF_BASIS_MP2 auxiliary basis selected, defaulting to %s\n' % (ribasis)); else:; raise ValidationError('Keyword DF_BASIS_MP2 is required.'). e_dfmp2 = PsiMod.dfmp2(); e_scs_dfmp2 = PsiMod.get_variable('SCS-DF-MP2 ENERGY'). optstash.restore(). if (name.upper() == 'SCS-DFMP2') or (name.upper() == 'SCS-DF-MP2'):; return e_scs_dfmp2; elif (name.upper() == 'DF-MP2') or (name.upper() == 'DFMP2'):; return e_dfmp2. [docs]def run_psimrcc(name, **kwargs):; """"""Function encoding sequence of PSI module calls for a PSIMRCC computation; using a reference from the MCSCF module. """"""; run_mcscf(name, **kwargs); PsiMod.psimrcc(); e_psimrcc = PsiMod.get_variable(""Current Energy""); return e_psimrcc. [docs]def run_psimrcc_scf(name, **kwargs):; """"""Function encoding sequence of PSI module calls for a PSIMRCC computation; using a reference from the SCF module. """""". run_scf(name, **kwargs); PsiMod.psimrcc(); e_psimrcc = PsiMod.get_variable(""Current Energy""); return e_psimrcc. [docs]def run_mp2c(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a coupled MP2 calculation. """"""; optstash = OptionsState(; ['DF_BASIS_MP2']). molecule = PsiMod.get_active_molecule(); molecule.update_geometry(); monomerA = molecule.extract_subsets(1, 2); monomerA.set_name('monomerA'); monomerB = molecule.extract_subsets(2, 1); monomerB.set_name('monomerB'). # if the df_basis_mp2 basis is not set, pick a sensible one.; if PsiMod.get_global_option('DF_BASIS_MP2') == '':; ribasis = corresponding_rifit(PsiMod.get_global_option('BASIS')); if ribasis:; PsiMod.set_global_option('DF_BASIS_MP2', ribasis); PsiMod.print_out('No DF_BASIS_MP2 auxiliary basis selected, defaulting to %s\n' % (ribasis)); else:; raise ValidationError('Keyword DF_BASIS_MP2 is required.'). ri = PsiMod.get_option('SCF', 'SCF_TYPE'); df_ints_io = PsiMod.get_option('SCF', 'DF_INTS_IO'); # inquire if above at all applies to dfmp2. PsiMod.IO.set_default_namespace('dimer'); Ps",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/_modules/proc.html:29569,Energy,Energy,29569,psi4manual/4.0b3/_modules/proc.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/_modules/proc.html,1,['Energy'],['Energy']
Energy Efficiency,"_gradient', name, 'CC_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). [docs]def select_fnoccsd(name, **kwargs):; """"""Function selecting the algorithm for a FNO-CCSD energy call; and directing to specified or best-performance default modules. """"""; reference = psi4.get_option('SCF', 'REFERENCE'); mtd_type = psi4.get_global_option('CC_TYPE'); module = psi4.get_global_option('QC_MODULE'); # Considering only fnocc. func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module in ['', 'FNOCC']:; func = run_fnocc; elif mtd_type == 'DF':; if module in ['', 'FNOCC']:; func = run_fnodfcc; elif mtd_type == 'CD':; if module in ['', 'FNOCC']:; func = run_fnodfcc. if func is None:; raise ManagedMethodError(['select_fnoccsd', name, 'CC_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). [docs]def select_ccsd(name, **kwargs):; """"""Function selecting the algorithm for a CCSD energy call; and directing to specified or best-performance default modules. """"""; reference = psi4.get_option('SCF', 'REFERENCE'); mtd_type = psi4.get_global_option('CC_TYPE'); module = psi4.get_global_option('QC_MODULE'); # Considering only [df]occ/ccenergy/detci/fnocc. func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module == 'DETCI':; func = run_detci; elif module == 'FNOCC':; func = run_fnocc; elif module in ['', 'CCENERGY']:; func = run_ccenergy; elif mtd_type == 'DF':; if module == 'OCC':; func = run_dfocc; elif module in ['', 'FNOCC']:; func = run_fnodfcc; elif mtd_type == 'CD':; if module == 'OCC':; func = run_dfocc; elif module in ['', 'FNOCC']:; func = run_fnodfcc; elif reference == 'UHF':; if mtd_type == 'CONV':; if module in ['', 'CCENERGY']:; func = run_ccenergy; elif reference == 'ROHF':; if mtd_type == 'CONV':; if module == 'DETCI':; func = run_detci; elif module in ['', 'CCENERGY']:; func = run_ccenergy. if func is None:; raise ManagedMethodError([",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html:18935,energy,energy,18935,psi4manual/1.0.0/_modules/procedures/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html,1,['energy'],['energy']
Energy Efficiency,"_gradient(self: psi4.core.HF, arg0: bool, arg1: int) → float¶; docstring. compute_spin_contamination(self: psi4.core.HF) → None¶; docstring. cphf_Hx(self: psi4.core.HF, arg0: List[psi4.core.Matrix]) → List[psi4.core.Matrix]¶; CPHF Hessian-vector prodcuts (4 * J - K - K.T). cphf_converged(self: psi4.core.HF) → bool¶; Adds occupied guess alpha orbitals. cphf_solve(self: psi4.core.HF, x_vec: List[psi4.core.Matrix], conv_tol: float, max_iter: int, print_lvl: int=2) → List[psi4.core.Matrix]¶; Solves the CPHF equations for a given set of x vectors. damping_update(self: psi4.core.HF, arg0: float) → None¶; docstring. diis(self: psi4.core.HF) → bool¶; docstring. diis_manager(self: psi4.core.HF) → psi4.core.DIISManager¶; docstring. finalize(self: psi4.core.HF) → None¶; Cleans up the the Wavefunction’s temporary data. finalize_energy()¶; Performs stability analysis and calls back SCF with new guess; if needed, Returns the SCF energy. This function should be called; once orbitals are ready for energy/property computations, usually; after iterations() is called. find_occupation(self: psi4.core.HF) → None¶; docstring. form_C(self: psi4.core.HF) → None¶; Forms the Orbital Matrices from the current Fock Matrices. form_D(self: psi4.core.HF) → None¶; Forms the Density Matrices from the current Orbitals Matrices. form_F(self: psi4.core.HF) → None¶; Forms the F matrix. form_G(self: psi4.core.HF) → None¶; Forms the G matrix. form_H(self: psi4.core.HF) → None¶; Forms the core Hamiltonian. form_Shalf(self: psi4.core.HF) → None¶; Forms the S^1/2 matrix. form_V(self: psi4.core.HF) → None¶; Form the Kohn-Sham Potential Matrices from the current Density Matrices. form_initial_C(self: psi4.core.HF) → None¶; Forms the initial Orbital Matrices from the current Fock Matrices. form_initial_F(self: psi4.core.HF) → None¶; Forms the initial F matrix. frac_renormalize(self: psi4.core.HF) → None¶; docstring. functional(self: psi4.core.HF) → psi4.core.SuperFunctional¶; Returns the internal DFT Superfunct",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/api/psi4.core.hf.html:6247,energy,energy,6247,psi4manual/1.3.2/api/psi4.core.hf.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/api/psi4.core.hf.html,1,['energy'],['energy']
Energy Efficiency,"_h] for the Hartree–Fock method, without; any dispersion correction; the first three (or four, since; \(E_{xc} = 0\)) terms in Eq. (4). Quantity \(E_{\text{HF}}\); in Eq. (4). HF KINETIC ENERGY¶; The total kinetic energy [E_h] of the Hartree–Fock method. HF POTENTIAL ENERGY¶; The total potential energy [E_h] of the Hartree–Fock method. HF VIRIAL RATIO¶; The virial ratio of the Hartree–Fock method. Only defined for a fully quantum mechanical computation, i.e., not QM/MM. HF TOTAL GRADIENT¶; The total electronic gradient [E_h/a0] of the Hartree–Fock method, ({nat}, 3). HF DIPOLE GRADIENT¶; The derivative of the Hartree–Fock method dipole [E_h a0/u] = [(e a0/a0)^2/u] with respect to nuclear perturbations; as a degree-of-freedom by dipole component array, (3 * {nat}, 3). HF TOTAL HESSIAN¶; The total electronic second derivative [E_h/a0/a0] for the Hartree-Fock method, (3 * {nat}, 3 * {nat}). LCCD TOTAL ENERGY¶. LCCD CORRELATION ENERGY¶; The total electronic energy [E_h] and correlation energy component [E_h]; for the linearized coupled cluster doubles level of theory. LCCSD TOTAL ENERGY¶. LCCSD CORRELATION ENERGY¶; The total electronic energy [E_h] and correlation energy component [E_h]; for the linearized coupled cluster singles and doubles level of theory. LCC2 (+LMP2) TOTAL ENERGY¶; The total electronic energy [E_h] for the local CC2 level of theory. LCCSD (+LMP2) TOTAL ENERGY¶; The total electronic energy [E_h] for the local CCSD level of theory. LEFT-RIGHT CC2 EIGENVECTOR OVERLAP¶. LEFT-RIGHT CC3 EIGENVECTOR OVERLAP¶. LEFT-RIGHT CCSD EIGENVECTOR OVERLAP¶. LEFT-RIGHT CCSD(T) EIGENVECTOR OVERLAP¶; The overlap between the right-hand coupled coupled cluster eigenvector and the; left-hand eigenvector from the coupled cluster lambda (response) equations. LOWDIN CHARGES¶; Property of partial atomic charges [e] by the method of Löwdin, (nat,). MAYER INDICES¶; Property of Mayer bond indices, (nat, nat). MBIS CHARGES¶. MBIS DIPOLES¶. MBIS OCTUPOLES¶. MBIS QUADRUPOLES¶; Per-a",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/glossary_psivariables.html:33143,energy,energy,33143,psi4manual/1.7.x/glossary_psivariables.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/glossary_psivariables.html,8,['energy'],['energy']
Energy Efficiency,"_helgaker_3`. .. hlist::; :columns: 1. * :py:func:`scf_xtpl_helgaker_2`; * :py:func:`scf_xtpl_truhlar_2`; * :py:func:`scf_xtpl_karton_2`. :type corl_alpha: float. Overrides the default \alpha parameter used in the listed :py:func:`corl_xtpl_helgaker_2` correlation; extrapolation to the corl stage. The supplied \alpha does not impact delta or any further stages. .. hlist::; :columns: 1. * :py:func:`corl_xtpl_helgaker_2`. :type delta_alpha: float. Overrides the default \alpha parameter used in the listed; :py:func:`corl_xtpl_helgaker_2` correlation extrapolation for the delta correction. Useful when; delta correction is performed using smaller basis sets for which a different \alpha might; be more appropriate. .. hlist::; :columns: 1. * :py:func:`corl_xtpl_helgaker_2`. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :examples:. >>> # [1] replicates with cbs() the simple model chemistry scf/cc-pVDZ: set basis cc-pVDZ energy('scf'); >>> cbs(name='scf', scf_basis='cc-pVDZ'). >>> # [2] replicates with cbs() the simple model chemistry mp2/jun-cc-pVDZ: set basis jun-cc-pVDZ energy('mp2'); >>> cbs(name='mp2', corl_basis='jun-cc-pVDZ'). >>> # [3] DTQ-zeta extrapolated scf reference energy; >>> cbs(name='scf', scf_basis='cc-pV[DTQ]Z', scf_scheme=scf_xtpl_helgaker_3). >>> # [4] DT-zeta extrapolated mp2 correlation energy atop a T-zeta reference; >>> cbs(corl_wfn='mp2', corl_basis='cc-pv[dt]z', corl_scheme=corl_xtpl_helgaker_2). >>> # [5] a DT-zeta extrapolated coupled-cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference (both equivalent); >>> cbs(corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z'); >>> cbs(energy, wfn='mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z', delta_scheme=corl_xtpl_helgaker_2). >>> # [6] a D-zeta ccsd(t) correcti",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/driver_cbs.html:36026,energy,energy,36026,psi4manual/1.2.1/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/driver_cbs.html,1,['energy'],['energy']
Energy Efficiency,_helper.xtpl_highest_1`; * :py:func:`~psi4.driver.driver_cbs_helper.scf_xtpl_helgaker_3`; * :py:func:`~psi4.driver.driver_cbs_helper.scf_xtpl_helgaker_2`; * :py:func:`~psi4.driver.driver_cbs_helper.scf_xtpl_truhlar_2`; * :py:func:`~psi4.driver.driver_cbs_helper.scf_xtpl_karton_2`. :type corl_scheme: str; :param corl_scheme: |dl| ``'xtpl_highest_1'`` |dr| || ``'corl_xtpl_helgaker_2'`` || etc. Indicates the basis set extrapolation scheme to be applied to the correlation energy.; Defaults to :py:func:`~psi4.driver.driver_cbs_helper.corl_xtpl_helgaker_2` if two valid basis sets; present in ``corl_basis`` and :py:func:`~psi4.driver.driver_cbs_helper.xtpl_highest_1` otherwise. .. hlist::; :columns: 1. * :py:func:`~psi4.driver.driver_cbs_helper.xtpl_highest_1`; * :py:func:`~psi4.driver.driver_cbs_helper.corl_xtpl_helgaker_2`. :type delta_scheme: str; :param delta_scheme: |dl| ``'xtpl_highest_1'`` |dr| || ``'corl_xtpl_helgaker_2'`` || etc. Indicates the basis set extrapolation scheme to be applied to the delta correction; to the correlation energy.; Defaults to :py:func:`~psi4.driver.driver_cbs_helper.corl_xtpl_helgaker_2` if two valid basis sets; present in ``delta_basis`` and :py:func:`~psi4.driver.driver_cbs_helper.xtpl_highest_1` otherwise. .. hlist::; :columns: 1. * :py:func:`~psi4.driver.driver_cbs_helper.xtpl_highest_1`; * :py:func:`~psi4.driver.driver_cbs_helper.corl_xtpl_helgaker_2`. :type delta2_scheme: str; :param delta2_scheme: |dl| ``'xtpl_highest_1'`` |dr| || ``'corl_xtpl_helgaker_2'`` || etc. Indicates the basis set extrapolation scheme to be applied to the second delta correction; to the correlation energy.; Defaults to :py:func:`~psi4.driver.driver_cbs_helper.corl_xtpl_helgaker_2` if two valid basis sets; present in ``delta2_basis`` and :py:func:`~psi4.driver.driver_cbs_helper.xtpl_highest_1` otherwise. .. hlist::; :columns: 1. * :py:func:`~psi4.driver.driver_cbs_helper.xtpl_highest_1`; * :py:func:`~psi4.driver.driver_cbs_helper.corl_xtpl_helgaker_2`. :type ,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver_cbs.html:28719,energy,energy,28719,psi4manual/1.7.x/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver_cbs.html,8,['energy'],['energy']
Energy Efficiency,"_intdump = fcidump_from_file(expected); intdump = fcidump_from_file(computed). # Compare headers; header_diff = DeepDiff(; ref_intdump,; intdump,; ignore_order=True,; exclude_paths={""root['enuc']"", ""root['hcore']"", ""root['eri']"", ""root['epsilon']""}); if header_diff:; message = (""\tComputed FCIDUMP file header does not match expected header.\n""); raise TestComparisonError(header_diff). ref_energies = _energies_from_fcidump(ref_intdump); energies = _energies_from_fcidump(intdump). pass_1el = compare_values(ref_energies['ONE-ELECTRON ENERGY'], energies['ONE-ELECTRON ENERGY'], 7, label + '. 1-electron energy'); pass_2el = compare_values(ref_energies['TWO-ELECTRON ENERGY'], energies['TWO-ELECTRON ENERGY'], 7, label + '. 2-electron energy'); pass_scf = compare_values(ref_energies['SCF TOTAL ENERGY'], energies['SCF TOTAL ENERGY'], 10, label + '. SCF total energy'); pass_mp2 = compare_values(ref_energies['MP2 CORRELATION ENERGY'], energies['MP2 CORRELATION ENERGY'], 10, label + '. MP2 correlation energy'). if (pass_1el and pass_2el and pass_scf and pass_mp2):; success(label). return True. def _energies_from_fcidump(intdump):; energies = {}; energies['NUCLEAR REPULSION ENERGY'] = intdump['enuc']; epsilon = intdump['epsilon']; Hcore = intdump['hcore']; eri = intdump['eri']. # Compute SCF energy; energies['ONE-ELECTRON ENERGY'], energies['TWO-ELECTRON ENERGY'] = _scf_energy(Hcore, eri,; np.where(epsilon < 0)[0],; intdump['uhf']); # yapf: disable; energies['SCF TOTAL ENERGY'] = energies['ONE-ELECTRON ENERGY'] + energies['TWO-ELECTRON ENERGY'] + energies['NUCLEAR REPULSION ENERGY']; # yapf: enable. # Compute MP2 energy; energies['MP2 CORRELATION ENERGY'] = _mp2_energy(eri, epsilon, intdump['uhf']). return energies. def _scf_energy(Hcore, ERI, occ_sl, unrestricted):; scf_1el_e = np.einsum('ii->', Hcore[np.ix_(occ_sl, occ_sl)]); if not unrestricted:; scf_1el_e *= 2; coulomb = np.einsum('iijj->', ERI[np.ix_(occ_sl, occ_sl, occ_sl, occ_sl)]); exchange = np.einsum('ijij->', ERI[np.ix",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/p4util/fcidump.html:13132,energy,energy,13132,psi4manual/1.2.1/_modules/psi4/driver/p4util/fcidump.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/p4util/fcidump.html,1,['energy'],['energy']
Energy Efficiency,"_labels(). core.print_out("" ==> Results <==\n\n""); core.print_out("" %8s %12s %12s %8s\n"" % (""Orbital"", ""Koopmans (eV)"", ""EP2 (eV)"", ""EP2 PS"")); core.print_out("" ----------------------------------------------\n""); for irrep, ep2, ep2_ps, kt, pos in ret_eps:; label = str(pos + 1) + irrep_labels[irrep]; core.print_out("" %8s % 12.3f % 12.3f % 6.3f\n"" % (label, (kt * h2ev), (ep2 * h2ev), ep2_ps)); core.set_variable(""EP2 "" + label.upper() + "" ENERGY"", ep2); core.print_out("" ----------------------------------------------\n\n""). # Figure out the IP and EA; sorted_vals = np.array([x[1] for x in ret_eps]); ip_vals = sorted_vals[sorted_vals < 0]; ea_vals = sorted_vals[sorted_vals > 0]. ip_value = None; ea_value = None; if len(ip_vals):; core.set_variable(""EP2 IONIZATION POTENTIAL"", ip_vals[-1]); core.set_variable(""CURRENT ENERGY"", ip_vals[-1]); if len(ea_vals):; core.set_variable(""EP2 ELECTRON AFFINITY"", ea_vals[0]); if core.variable(""EP2 IONIZATION POTENTIAL"") == 0.0:; core.set_variable(""CURRENT ENERGY"", ea_vals[0]). core.print_out("" EP2 has completed successfully!\n\n""). core.tstop(); return dfep2_wfn. def run_dlpnomp2(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a DLPNO-MP2 calculation. """"""; optstash = p4util.OptionsState(; ['DF_BASIS_MP2'],; ['SCF_TYPE']). # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'); core.print_out("""""" SCF Algorithm Type (re)set to DF.\n""""""). # DLPNO-MP2 is only DF; if core.get_global_option('MP2_TYPE') != ""DF"":; raise ValidationError("""""" DLPNO-MP2 is only implemented with density fitting.\n""""""; """""" 'mp2_type' must be set to 'DF'.\n""""""). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, use_c1=True, **kwargs) # C1 certified; elif ref_wfn.molecule().schoenflies_symbol() != 'c1':; raise ValidationError("""""" DLPNO-MP2 does not make use of molecular symmetry: """"""; ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/_modules/psi4/driver/procrouting/proc.html:130303,ENERGY,ENERGY,130303,psi4manual/1.5.0/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/_modules/psi4/driver/procrouting/proc.html,6,['ENERGY'],['ENERGY']
Energy Efficiency,"_labels(). core.print_out("" ==> Results <==\n\n""); core.print_out("" %8s %12s %12s %8s\n"" % (""Orbital"", ""Koopmans (eV)"", ""EP2 (eV)"", ""EP2 PS"")); core.print_out("" ----------------------------------------------\n""); for irrep, ep2, ep2_ps, kt, pos in ret_eps:; label = str(pos + 1) + irrep_labels[irrep]; core.print_out("" %8s % 12.3f % 12.3f % 6.3f\n"" % (label, (kt * h2ev), (ep2 * h2ev), ep2_ps)); core.set_variable(""EP2 "" + label.upper() + "" ENERGY"", ep2); core.print_out("" ----------------------------------------------\n\n""). # Figure out the IP and EA; sorted_vals = np.array([x[1] for x in ret_eps]); ip_vals = sorted_vals[sorted_vals < 0]; ea_vals = sorted_vals[sorted_vals > 0]. ip_value = None; ea_value = None; if len(ip_vals):; core.set_variable(""EP2 IONIZATION POTENTIAL"", ip_vals[-1]); core.set_variable(""CURRENT ENERGY"", ip_vals[-1]); if len(ea_vals):; core.set_variable(""EP2 ELECTRON AFFINITY"", ea_vals[0]); if core.variable(""EP2 IONIZATION POTENTIAL"") == 0.0:; core.set_variable(""CURRENT ENERGY"", ea_vals[0]). core.print_out("" EP2 has completed successfully!\n\n""). core.tstop(); return dfep2_wfn. def run_dmrgscf(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; an DMRG calculation. """"""; optstash = p4util.OptionsState(; ['SCF_TYPE'],; ['DMRG', 'DMRG_CASPT2_CALC']). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs). # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn). if 'CASPT2' in name.upper():; core.set_local_option(""DMRG"", ""DMRG_CASPT2_CALC"", True). dmrg_wfn = core.dmrg(ref_wfn); optstash.restore(). # Shove variables into global space; for k, v in dmrg_wfn.variables().items():; core.set_variable(k, v). return dmrg_wfn. def run_dmrgci(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; an DMRG calculation. """"""; optstash = p4util.OptionsState(; ['SCF_TY",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html:130008,ENERGY,ENERGY,130008,psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,1,['ENERGY'],['ENERGY']
Energy Efficiency,"_lbl,; ); if nb in compute_dict[""vmfc_levels""]:; vmfc_by_level[nb] = _sum_cluster_ptype_data(; ptype,; component_results,; compute_dict[""vmfc_levels""][nb],; fragment_slice_dict,; fragment_size_dict,; vmfc=True,; nb=nb,; mc_level_lbl=mc_level_lbl,; ). def labeler(item) -> str:; return str(mc_level_lbl) + ""_"" + str(item). # Extract data for monomers in monomer basis for CP total data; if 1 in nbodies:; monomers_in_monomer_basis = [v for v in compute_dict[""nocp""][1] if len(v[1]) == 1]. if ptype == ""energy"":; monomer_energy_list = [component_results[labeler(m)] for m in monomers_in_monomer_basis]; monomer_sum = sum(monomer_energy_list); else:; monomer_sum = _sum_cluster_ptype_data(; ptype,; component_results,; monomers_in_monomer_basis,; fragment_slice_dict,; fragment_size_dict,; mc_level_lbl=mc_level_lbl,; ); else:; monomer_sum = shaped_zero(ptype). nbody_dict = {}. # Compute cp; if 'cp' in metadata['bsse_type']:; for nb in range(1, nbodies[-1] + 1):; if nb == metadata['nfragments']:; if ptype == ""energy"":; cp_body_dict[nb] = cp_by_level[nb] - bsse; else:; cp_body_dict[nb][:] = cp_by_level[nb] - bsse; continue. for k in range(1, nb + 1):; take_nk = math.comb(metadata['nfragments'] - k - 1, nb - k); sign = ((-1)**(nb - k)); cp_body_dict[nb] += take_nk * sign * cp_by_level[k]. if nb == 1:; bsse = cp_body_dict[nb] - monomer_sum; if ptype == ""energy"":; cp_body_dict[nb] = monomer_sum; else:; cp_body_dict[nb] = monomer_sum.copy(); else:; cp_body_dict[nb] -= bsse. if ptype == ""energy"":; if not metadata[""quiet""]:; _print_nbody_energy(cp_body_dict, ""Counterpoise Corrected (CP)"", metadata[""nfragments""], metadata['embedding_charges']). if monomer_sum != 0.0:; nbody_dict[""CP-CORRECTED TOTAL ENERGY""] = cp_body_dict[metadata['max_nbody']]; nbody_dict[""CP-CORRECTED INTERACTION ENERGY""] = cp_body_dict[metadata['max_nbody']] - cp_body_dict[1]. for nb in nbodies[1:]:; nbody_dict[f""CP-CORRECTED INTERACTION ENERGY THROUGH {nb}-BODY""] = cp_body_dict[nb] - cp_body_dict[1]; nbody_dict[f""CP-C",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver_nbody.html:26475,energy,energy,26475,psi4manual/1.6.x/_modules/psi4/driver/driver_nbody.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver_nbody.html,10,['energy'],['energy']
Energy Efficiency,"_lesser'] = 'mp2'; if not ('delta_basis' in kwargs):; kwargs['delta_basis'] = 'aug-cc-pVTZ'; if not ('delta_scheme' in kwargs):; kwargs['delta_scheme'] = highest_1. return cbs(name, **kwargs). #def run_mp2_5(name, **kwargs):; # r""""""Function that computes MP2.5 energy from results of a FNOCC; # MP3 calculation.; #; # .. math:: E_{total}^{\text{MP2.5}} = E_{total,\; \text{SCF}} \; + E_{corl,\; \text{MP2}} + E_{corl, \; \text{MP3}}; #; # :PSI variables: ; #; # .. hlist:: ; # :columns: 1 ; # ; # * :psivar:`MP2.5 TOTAL ENERGY <MP2.5TOTALENERGY>` ; # * :psivar:`MP2.5 CORRELATION ENERGY <MP2.5CORRELATIONENERGY>` ; #; # >>> energy('mp2.5'); #; # """"""; # lowername = name.lower(); # kwargs = kwargs_lower(kwargs); #; # # Run detci calculation and collect conventional quantities; # energy('mp3', **kwargs); # e_scf = PsiMod.get_variable('SCF TOTAL ENERGY'); # ce_mp2 = PsiMod.get_variable('MP2 CORRELATION ENERGY'); # ce_mp3 = PsiMod.get_variable('MP3 CORRELATION ENERGY'); # e_mp2 = e_scf + ce_mp2; # e_mp3 = e_scf + ce_mp3; #; # # Compute quantities particular to MP2.5; # ce_mp25 = 0.5 * (ce_mp2 + ce_mp3); # e_mp25 = e_scf + ce_mp25; # PsiMod.set_variable('MP2.5 CORRELATION ENERGY', ce_mp25); # PsiMod.set_variable('MP2.5 TOTAL ENERGY', e_mp25); # PsiMod.set_variable('CURRENT CORRELATION ENERGY', ce_mp25); # PsiMod.set_variable('CURRENT ENERGY', e_mp25); #; # # build string of title banner and print results; # banners = ''; # banners += """"""PsiMod.print_out('\\n')\n""""""; # banners += """"""banner(' MP2.5 ')\n""""""; # banners += """"""PsiMod.print_out('\\n')\n\n""""""; # exec(banners); #; # tables = ''; # tables += """""" SCF total energy: %16.8f\n"""""" % (e_scf); # tables += """""" MP2 total energy: %16.8f\n"""""" % (e_mp2); # tables += """""" MP2.5 total energy: %16.8f\n"""""" % (e_mp25); # tables += """""" MP3 total energy: %16.8f\n\n"""""" % (e_mp3); # tables += """""" MP2 correlation energy: %16.8f\n"""""" % (ce_mp2); # tables += """""" MP2.5 correlation energy: %16.8f\n"""""" % (ce_mp25); # tables += """""" MP3 correlation ener",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/_modules/aliases.html:2920,ENERGY,ENERGY,2920,psi4manual/4.0b4/_modules/aliases.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/aliases.html,1,['ENERGY'],['ENERGY']
Energy Efficiency,"_mcscf(N3psi5detci14CIWavefunctionE {lvalue}). psi4.CIWavefunction.deep_copy()¶; Python Library Documentation: method deep_copy; deep_copy(...) unbound psi4.CIWavefunction method. deep_copy( (Wavefunction)arg1, (Wavefunction)arg2) -> None :. docstring; C++ signature :. void deep_copy(N3psi12WavefunctionE {lvalue},N5boost10shared_ptrIN3psi12WavefunctionEEE). psi4.CIWavefunction.diag_h()¶; Python Library Documentation: method diag_h; diag_h(...) unbound psi4.CIWavefunction method. diag_h( (CIWavefunction)arg1) -> None :. docstring; C++ signature :. void diag_h(N3psi5detci14CIWavefunctionE {lvalue}). psi4.CIWavefunction.doccpi()¶; Python Library Documentation: method doccpi; doccpi(...) unbound psi4.CIWavefunction method. doccpi( (Wavefunction)arg1) -> Dimension :. docstring; C++ signature :. N3psi9DimensionE doccpi(N3psi12WavefunctionE {lvalue}). psi4.CIWavefunction.energy()¶; Python Library Documentation: method energy; energy(...) unbound psi4.CIWavefunction method. energy( (Wavefunction)arg1) -> float :. docstring; C++ signature :. d energy(N3psi12WavefunctionE {lvalue}). psi4.CIWavefunction.epsilon_a()¶; Python Library Documentation: method epsilon_a; epsilon_a(...) unbound psi4.CIWavefunction method. epsilon_a( (Wavefunction)arg1) -> Vector :. docstring; C++ signature :. N5boost10shared_ptrIN3psi6VectorEEE epsilon_a(N3psi12WavefunctionE {lvalue}). psi4.CIWavefunction.epsilon_a_subset()¶; Python Library Documentation: method epsilon_a_subset; epsilon_a_subset(...) unbound psi4.CIWavefunction method. epsilon_a_subset( (Wavefunction)arg1, (str)arg2, (str)arg3) -> Vector :. docstring; C++ signature :. N5boost10shared_ptrIN3psi6VectorEEE epsilon_a_subset(N3psi12WavefunctionE {lvalue},Ss,Ss). psi4.CIWavefunction.epsilon_b()¶; Python Library Documentation: method epsilon_b; epsilon_b(...) unbound psi4.CIWavefunction method. epsilon_b( (Wavefunction)arg1) -> Vector :. docstring; C++ signature :. N5boost10shared_ptrIN3psi6VectorEEE epsilon_b(N3psi12WavefunctionE {lvalue})",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html:69857,energy,energy,69857,psi4manual/1.0.0/autodoc_psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html,2,['energy'],['energy']
Energy Efficiency,"_memory() API function, which takes either a string like '30 GB' (with units!) or an integer number of bytes of memory as its argument. Next, our molecular geometry is passed as a string into; psi4.geometry() API. We may input this geometry in either Z-matrix or Cartesian format; to allow the string to break over multiple lines, use Python’s triple-quote """"""string"""""" syntax. Finally, we will compute the Hartree-Fock SCF energy with the cc-pVDZ basis set by passing the method/basis set as a string ('scf/cc-pvdz') into the function psi4.energy(); API:. [3]:. #! Sample HF/cc-pVDZ H2O Computation. psi4.set_memory('500 MB'). h2o = psi4.geometry(""""""; O; H 1 0.96; H 1 0.96 2 104.5; """"""). psi4.energy('scf/cc-pvdz'). [3]:. -76.02663273488399. If everything goes well, the computation should complete and should report a final restricted Hartree-Fock energy in the output file output.dat in a section like this:; Energy converged. @DF-RHF Final Energy: -76.02663273486682. By default, the energy should be converged to about \(1.0\times 10^{-6}\), so agreement is only expected for about the first 6 digits after the decimal. If the computation does not complete, there is probably a problem with the compilation or installation of the program (see the installation instructions in the main Psi4 manual section :psicode:[Compiling and Installing from Source] <psi4manual/master/build_planning.html> .; This very simple input is sufficient to run the requested information. Notice we didn’t tell the program some otherwise useful information like the charge of the molecule (0, it’s neutral), the spin multiplicity (1 for a closed-shell molecule with all electrons paired), or the reference wavefunction to use (restricted Hartree-Fock, or RHF, is usually appropriate for a closed-shell molecule). The program correctly guessed all of these options for us. We can change the default behavior through; additional keywords.; Let’s consider what we would do for an open-shell molecule, where not all the e",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/psiapi.html:3861,energy,energy,3861,psi4manual/1.6.x/psiapi.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/psiapi.html,3,['energy'],['energy']
Energy Efficiency,"_memory() API function, which takes either a string like '30 GB' (with units!) or an integer number of bytes of memory as its argument. Next, our molecular geometry is passed as a string into; psi4.geometry() API. We may input this geometry in either Z-matrix or Cartesian format; to allow the string to break over multiple lines, use Python’s triple-quote """"""string"""""" syntax. Finally, we will compute the Hartree-Fock SCF energy with the cc-pVDZ basis set by passing the method/basis set as a string ('scf/cc-pvdz') into the function psi4.energy(); API:. [3]:. #! Sample HF/cc-pVDZ H2O Computation. psi4.set_memory('500 MB'). h2o = psi4.geometry(""""""; O; H 1 0.96; H 1 0.96 2 104.5; """"""). psi4.energy('scf/cc-pvdz'). [3]:. -76.02663273488399. If everything goes well, the computation should complete and should report a final restricted Hartree-Fock energy in the output file output.dat in a section like this:; Energy converged. @DF-RHF Final Energy: -76.02663273486682. By default, the energy should be converged to about \(1.0\times 10^{-6}\), so agreement is only expected for about the first 6 digits after the decimal. If the computation does not complete, there is probably a problem with the compilation or installation of the program (see the installation instructions in the main Psi4 manual section Compiling and Installing from Source).; This very simple input is sufficient to run the requested information. Notice we didn’t tell the program some otherwise useful information like the charge of the molecule (0, it’s neutral), the spin multiplicity (1 for a closed-shell molecule with all electrons paired), or the reference wavefunction to use (restricted Hartree-Fock, or RHF, is usually appropriate for a closed-shell molecule). The program correctly guessed all of these options for us. We can change the default behavior through; additional keywords.; Let’s consider what we would do for an open-shell molecule, where not all the electrons are paired. For example, let’s run a compu",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/psiapi-1.html:3862,energy,energy,3862,psi4manual/1.3.2/psiapi-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/psiapi-1.html,6,['energy'],['energy']
Energy Efficiency,"_memory() API function, which takes either a string like '30 GB' (with units!) or an integer number of bytes of memory as its argument. Next, our molecular geometry is passed as a string into; psi4.geometry() API. We may input this geometry in either Z-matrix or Cartesian format; to allow the string to break over multiple lines, use Python’s triple-quote """"""string"""""" syntax. Finally, we will compute the Hartree-Fock SCF energy with the cc-pVDZ basis set by passing the method/basis set as a string ('scf/cc-pvdz') into the function psi4.energy(); API:. [3]:. #! Sample HF/cc-pVDZ H2O Computation. psi4.set_memory('500 MB'). h2o = psi4.geometry(""""""; O; H 1 0.96; H 1 0.96 2 104.5; """"""). psi4.energy('scf/cc-pvdz'). [3]:. -76.02663273488399. If everything goes well, the computation should complete and should report a final restricted Hartree-Fock energy in the output file output.dat in a section like this:; Energy converged. @DF-RHF Final Energy: -76.02663273486682. By default, the energy should be converged to about \(1.0\times 10^{-6}\), so agreement is only expected for about the first 6 digits after the decimal. If the computation does not complete, there is probably a problem with the compilation or installation of the program (see the installation instructions in the main Psi4 manual section Compiling and Installing from Source.; This very simple input is sufficient to run the requested information. Notice we didn’t tell the program some otherwise useful information like the charge of the molecule (0, it’s neutral), the spin multiplicity (1 for a closed-shell molecule with all electrons paired), or the reference wavefunction to use (restricted Hartree-Fock, or RHF, is usually appropriate for a closed-shell molecule). The program correctly guessed all of these options for us. We can change the default behavior through; additional keywords.; Let’s consider what we would do for an open-shell molecule, where not all the electrons are paired. For example, let’s run a comput",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/psiapi.html:3737,energy,energy,3737,psi4manual/1.9.x/psiapi.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/psiapi.html,2,['energy'],['energy']
Energy Efficiency,"_model. [docs]; def get_psi_results(; self,; client: Optional[""qcportal.FractalClient""] = None,; *,; return_wfn: bool = False) -> EnergyGradientHessianWfnReturn:; """"""Called by driver to assemble results into ManyBody-flavored QCSchema,; then reshape and return them in the customary Psi4 driver interface: ``(e/g/h, wfn)``. Parameters; ----------; return_wfn; Whether to additionally return the dummy :py:class:`~psi4.core.Wavefunction`; calculation result as the second element of a tuple. Contents are:. - supersystem molecule; - dummy basis, def2-svp; - e/g/h member data; - QCVariables. Returns; -------; ret; Energy, gradient, or Hessian according to self.driver.; wfn; Wavefunction described above when *return_wfn* specified. """"""; nbody_model = self.get_results(client=client); ret = nbody_model.return_result. wfn = core.Wavefunction.build(self.molecule, ""def2-svp"", quiet=True). # TODO all besides nbody may be better candidates for extras than qcvars. energy/gradient/hessian_body_dict in particular are too simple for qcvars (e.g., ""2""); dicts = [; #""energies"", # retired; #""ptype"", # retired; ""intermediates"",; ""intermediates_energy"", #""intermediates2"",; ""intermediates_gradient"", #""intermediates_ptype"",; ""intermediates_hessian"", #""intermediates_ptype"",; ""energy_body_dict"",; ""gradient_body_dict"", # ptype_body_dict; ""hessian_body_dict"", # ptype_body_dict; ""nbody"",; ""cp_energy_body_dict"",; ""nocp_energy_body_dict"",; ""vmfc_energy_body_dict"",; ""cp_gradient_body_dict"",; ""nocp_gradient_body_dict"",; ""vmfc_gradient_body_dict"",; ""cp_hessian_body_dict"",; ""nocp_hessian_body_dict"",; ""vmfc_hessian_body_dict"",; ]. for qcv, val in nbody_model.extras['qcvars'].items():; if isinstance(val, dict):; if qcv in dicts:; for qcv2, val2 in val.items():; for obj in [core, wfn]:; try:; obj.set_variable(str(qcv2), val2); except ValidationError:; obj.set_variable(f""{self.driver.name} {qcv2}"", val2); else:; for obj in [core, wfn]:; obj.set_variable(qcv, val). if self.driver == 'gradient':; ret = core.M",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html:92155,energy,energy,92155,psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html,6,['energy'],['energy']
Energy Efficiency,"_molecular_charge(charge); molecule.set_multiplicity(mult). # Determine HOMO; print('DGAS: What ref should this point to?'); eps_a = wfn.epsilon_a(); eps_b = wfn.epsilon_b(); if Na == Nb:; HOMO = -Nb; elif Nb == 0:; HOMO = Na; else:; E_a = eps_a.np[int(Na - 1)]; E_b = eps_b.np[int(Nb - 1)]; if E_a >= E_b:; HOMO = Na; else:; HOMO = -Nb. stats.append("""""" %6d %6d %6d %6d %6d %6d\n"""""" % (Nintegral-1, Na, Nb, charge, mult, HOMO)). if HOMO > 0:; Na -= 1; else:; Nb -= 1; charge += 1; mult = Na - Nb + 1. core.set_local_option(""SCF"", ""DF_INTS_IO"", ""NONE""). # => Print the results out <= #; E = {}; core.print_out(""""""\n ==> Fractional Occupation Nuke Results <==\n\n""""""); core.print_out("""""" %-11s %-24s %-24s %11s\n"""""" % ('N', 'Energy', 'HOMO Energy', 'Converged')); for k in range(len(Ns)):; core.print_out("""""" %11.3E %24.16E %24.16E %11d\n"""""" % (Ns[k], energies[k], potentials[k], convs[k])); E[Ns[k]] = energies[k]. core.print_out('\n'); core.print_out("""""" %6s %6s %6s %6s %6s %6s\n"""""" % ('N', 'Na', 'Nb', 'Charge', 'Mult', 'HOMO')); for line in stats:; core.print_out(line). core.print_out('\n ""You shoot a nuke down a bug hole, you got a lot of dead bugs""\n'); core.print_out(' -Starship Troopers\n'). # Drop the files out; with open(traverse_filename, 'w') as fh:; fh.write("""""" %-11s %-24s %-24s %11s\n"""""" % ('N', 'Energy', 'HOMO Energy', 'Converged')); for k in range(len(Ns)):; fh.write("""""" %11.3E %24.16E %24.16E %11d\n"""""" % (Ns[k], energies[k], potentials[k], convs[k])). with open(stats_filename, 'w') as fh:; fh.write("""""" %6s %6s %6s %6s %6s %6s\n"""""" % ('N', 'Na', 'Nb', 'Charge', 'Mult', 'HOMO')); for line in stats:; fh.write(line). optstash.restore(); return E. [docs]; def ip_fitting(name: Union[str, Callable], omega_l: float = 0.05, omega_r: float = 2.5, omega_convergence: float = 1.0e-3, maxiter: int = 20, **kwargs) -> float:; """"""Optimize DFT omega parameter for molecular system. Parameters; ----------; name; DFT functional string name or function defining functional; whose omega ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/frac.html:13752,Charge,Charge,13752,psi4manual/1.8.x/_modules/psi4/driver/frac.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/frac.html,3,['Charge'],['Charge']
Energy Efficiency,"_molecular_charge(charge); molecule.set_multiplicity(mult). # Determine HOMO; print('DGAS: What ref should this point to?'); eps_a = wfn.epsilon_a(); eps_b = wfn.epsilon_b(); if Na == Nb:; HOMO = -Nb; elif Nb == 0:; HOMO = Na; else:; E_a = eps_a.np[int(Na - 1)]; E_b = eps_b.np[int(Nb - 1)]; if E_a >= E_b:; HOMO = Na; else:; HOMO = -Nb. stats.append("""""" %6d %6d %6d %6d %6d %6d\n"""""" % (Nintegral-1, Na, Nb, charge, mult, HOMO)). if HOMO > 0:; Na -= 1; else:; Nb -= 1; charge += 1; mult = Na - Nb + 1. core.set_local_option(""SCF"", ""DF_INTS_IO"", ""NONE""). # => Print the results out <= #; E = {}; core.print_out(""""""\n ==> Fractional Occupation Nuke Results <==\n\n""""""); core.print_out("""""" %-11s %-24s %-24s %11s\n"""""" % ('N', 'Energy', 'HOMO Energy', 'Converged')); for k in range(len(Ns)):; core.print_out("""""" %11.3E %24.16E %24.16E %11d\n"""""" % (Ns[k], energies[k], potentials[k], convs[k])); E[Ns[k]] = energies[k]. core.print_out('\n'); core.print_out("""""" %6s %6s %6s %6s %6s %6s\n"""""" % ('N', 'Na', 'Nb', 'Charge', 'Mult', 'HOMO')); for line in stats:; core.print_out(line). core.print_out('\n ""You shoot a nuke down a bug hole, you got a lot of dead bugs""\n'); core.print_out(' -Starship Troopers\n'). # Drop the files out; with open(traverse_filename, 'w') as fh:; fh.write("""""" %-11s %-24s %-24s %11s\n"""""" % ('N', 'Energy', 'HOMO Energy', 'Converged')); for k in range(len(Ns)):; fh.write("""""" %11.3E %24.16E %24.16E %11d\n"""""" % (Ns[k], energies[k], potentials[k], convs[k])). with open(stats_filename, 'w') as fh:; fh.write("""""" %6s %6s %6s %6s %6s %6s\n"""""" % ('N', 'Na', 'Nb', 'Charge', 'Mult', 'HOMO')); for line in stats:; fh.write(line). optstash.restore(); return E. [docs]def ip_fitting(name: Union[str, Callable], omega_l: float = 0.05, omega_r: float = 2.5, omega_convergence: float = 1.0e-3, maxiter: int = 20, **kwargs) -> float:; """"""Optimize DFT omega parameter for molecular system. Parameters; ----------; name; DFT functional string name or function defining functional; whose omega is",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/frac.html:13746,Charge,Charge,13746,psi4manual/1.7.x/_modules/psi4/driver/frac.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/frac.html,1,['Charge'],['Charge']
Energy Efficiency,"_mp2 = e_scf + ce_mp2; # e_mp3 = e_scf + ce_mp3; #; # # Compute quantities particular to MP2.5; # ce_mp25 = 0.5 * (ce_mp2 + ce_mp3); # e_mp25 = e_scf + ce_mp25; # PsiMod.set_variable('MP2.5 CORRELATION ENERGY', ce_mp25); # PsiMod.set_variable('MP2.5 TOTAL ENERGY', e_mp25); # PsiMod.set_variable('CURRENT CORRELATION ENERGY', ce_mp25); # PsiMod.set_variable('CURRENT ENERGY', e_mp25); #; # # build string of title banner and print results; # banners = ''; # banners += """"""PsiMod.print_out('\\n')\n""""""; # banners += """"""banner(' MP2.5 ')\n""""""; # banners += """"""PsiMod.print_out('\\n')\n\n""""""; # exec(banners); #; # tables = ''; # tables += """""" SCF total energy: %16.8f\n"""""" % (e_scf); # tables += """""" MP2 total energy: %16.8f\n"""""" % (e_mp2); # tables += """""" MP2.5 total energy: %16.8f\n"""""" % (e_mp25); # tables += """""" MP3 total energy: %16.8f\n\n"""""" % (e_mp3); # tables += """""" MP2 correlation energy: %16.8f\n"""""" % (ce_mp2); # tables += """""" MP2.5 correlation energy: %16.8f\n"""""" % (ce_mp25); # tables += """""" MP3 correlation energy: %16.8f\n"""""" % (ce_mp3); # PsiMod.print_out(tables); #; # return e_mp25. # A direct translation of a plugin input file into a function call. Function calls are the only; # way to call plugins in sow/reap mode for db(), opt(), etc. This isn't best practices; # but is an example of what to do for a more complicated procedure where different options ; # are set for different qc steps.; #def run_plugin_omega(name, **kwargs):; # r""""""Function encoding sequence of PSI module and plugin calls, as well; # as typical options, to access Rob Parrish's omega plugin.; #; # >>> energy('plugin_omega'); #; # """"""; # lowername = name.lower(); # kwargs = kwargs_lower(kwargs); #; # plugfile = PsiMod.Process.environment[""PSIDATADIR""] + ""/../tests/plugin_omega/plugin_omega.so""; # PsiMod.plugin_load(""%s"" % (plugfile)); #; # PsiMod.set_global_option('BASIS', 'AUG-CC-PVDZ'); # PsiMod.set_global_option('DF_BASIS_SCF', 'AUG-CC-PVDZ-RI'); # PsiMod.set_global_option('REFERENCE', 'UHF'); #",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/_modules/aliases.html:3954,energy,energy,3954,psi4manual/4.0b4/_modules/aliases.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/aliases.html,2,['energy'],['energy']
Energy Efficiency,"_multipole_compressor(val[iat], 3) for iat in range(len(val))]); return val; elif key.upper().endswith(""DIPOLE"") or ""DIPOLE -"" in key.upper():; reshaper = (1, 3); elif ""QUADRUPOLE POLARIZABILITY TENSOR"" in key.upper():; reshaper = (3, 3, 3); elif any((key.upper().endswith(p) or f""{p} -"" in key.upper()) for p in _multipole_order):; p = [p for p in _multipole_order if (key.upper().endswith(p) or f""{p} -"" in key.upper())]; val = _multipole_compressor(val, _multipole_order.index(p[0])); reshaper = (1, -1); elif key.upper() in [""MULLIKEN_CHARGES"", ""LOWDIN_CHARGES"", ""MULLIKEN CHARGES"", ""LOWDIN CHARGES""]:; reshaper = (1, -1). if reshaper:; return val.reshape(reshaper); else:; return val. def _qcvar_reshape_get(key: str, val: core.Matrix) -> Union[core.Matrix, np.ndarray]:; """"""For QCVariables where the 2D :py:class:`psi4.core.Matrix` shape is; unnatural, convert to natural shape in :class:`numpy.ndarray`. """"""; reshaper = None; if key.upper().startswith(""MBIS""):; if key.upper().endswith(""CHARGES""):; return val.np; elif key.upper().endswith(""DIPOLES""):; reshaper = (-1, 3); return val.np.reshape(reshaper); elif key.upper().endswith(""QUADRUPOLES""):; val = val.np.reshape(-1, 6); val = np.array([_multipole_plumper(val[iat], 2) for iat in range(len(val))]); return val; elif key.upper().endswith(""OCTUPOLES""):; val = val.np.reshape(-1, 10); val = np.array([_multipole_plumper(val[iat], 3) for iat in range(len(val))]); return val; elif key.upper().endswith(""DIPOLE"") or ""DIPOLE -"" in key.upper():; reshaper = (3, ); elif ""QUADRUPOLE POLARIZABILITY TENSOR"" in key.upper():; reshaper = (3, 3, 3); elif any((key.upper().endswith(p) or f""{p} -"" in key.upper()) for p in _multipole_order):; p = [p for p in _multipole_order if (key.upper().endswith(p) or f""{p} -"" in key.upper())]; return _multipole_plumper(val.np.reshape((-1, )), _multipole_order.index(p[0])); elif key.upper() in [""MULLIKEN_CHARGES"", ""LOWDIN_CHARGES"", ""MULLIKEN CHARGES"", ""LOWDIN CHARGES""]:; reshaper = (-1, ). if reshaper:; return",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/python_helpers.html:31596,CHARGE,CHARGES,31596,psi4manual/1.8.x/_modules/psi4/driver/p4util/python_helpers.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/python_helpers.html,1,['CHARGE'],['CHARGES']
Energy Efficiency,"_object().get_default_path()). # Bounce to CP if bsse kwarg; if kwargs.get('bsse_type', None) is not None:; return driver_nbody.nbody_gufunc(energy, name, ptype='energy', **kwargs). # Bounce if name is function; if hasattr(name, '__call__'):; return name(energy, kwargs.pop('label', 'custom function'), ptype='energy', **kwargs). # Allow specification of methods to arbitrary order; lowername = name.lower(); lowername, level = driver_util.parse_arbitrary_order(lowername); if level:; kwargs['level'] = level. # Bounce to CBS if ""method/basis"" name; if ""/"" in lowername:; return driver_cbs._cbs_gufunc(energy, name, ptype='energy', **kwargs). _filter_renamed_methods(""energy"", lowername). # Commit to procedures['energy'] call hereafter; return_wfn = kwargs.pop('return_wfn', False); core.clean_variables(). # Make sure the molecule the user provided is the active one; molecule = kwargs.pop('molecule', core.get_active_molecule()); molecule.update_geometry(). #for precallback in hooks['energy']['pre']:; # precallback(lowername, **kwargs). optstash = driver_util._set_convergence_criterion('energy', lowername, 6, 8, 6, 8, 6); optstash2 = p4util.OptionsState(['SCF', 'GUESS']). # Before invoking the procedure, we rename any file that should be read.; # This is a workaround to do restarts with the current PSI4 capabilities; # before actual, clean restarts are put in there; # Restartfile is always converted to a single-element list if; # it contains a single string; # DGAS Note: This is hacked together at this point and should be revamped.; if 'restart_file' in kwargs:; restartfile = kwargs['restart_file'] # Option still available for procedure-specific action; if not isinstance(restartfile, (list, tuple)):; restartfile = (restartfile, ); # Rename the files to be read to be consistent with psi4's file system; for item in restartfile:; is_numpy_file = (os.path.isfile(item) and item.endswith("".npy"")) or os.path.isfile(item + "".npy""); name_split = re.split(r'\.', item); if is_numpy_file:;",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:35077,energy,energy,35077,psi4manual/1.4.0/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html,4,['energy'],['energy']
Energy Efficiency,"_option('BASIS').lower()}, molecule={molecule.name()}, nre={'w/EFP' if hasattr(molecule, 'EFP') else molecule.nuclear_repulsion_energy()}""); logger.debug(""w/EFP"" if hasattr(molecule, ""EFP"") else pp.pformat(molecule.to_dict())); wfn = procedures[""properties""][lowername](lowername, molecule=molecule, **kwargs); logger.info(f""Return properties(): {core.variable('CURRENT ENERGY')}""). basisstash.restore(); optstash.restore(). if return_wfn:; return (core.variable('CURRENT ENERGY'), wfn); else:; return core.variable('CURRENT ENERGY'). [docs]def optimize_geometric(name, **kwargs):. import qcelemental as qcel; from qcelemental.util import which_import. if not which_import('geometric', return_bool=True):; raise ModuleNotFoundError('Python module geometric not found. Solve by installing it: `conda install -c conda-forge geometric` or `pip install geometric`'); import geometric. class Psi4NativeEngine(geometric.engine.Engine):; """"""; Internally run an energy and gradient calculation for geometric ; """"""; def __init__(self, p4_name, p4_mol, p4_return_wfn, **p4_kwargs):; ; self.p4_name = p4_name; self.p4_mol = p4_mol; self.p4_return_wfn = p4_return_wfn; self.p4_kwargs = p4_kwargs; ; molecule = geometric.molecule.Molecule(); molecule.elem = [p4_mol.symbol(i) for i in range(p4_mol.natom())]; molecule.xyzs = [p4_mol.geometry().np * qcel.constants.bohr2angstroms] ; molecule.build_bonds(); ; super(Psi4NativeEngine, self).__init__(molecule); ; def calc(self, coords, dirname):; self.p4_mol.set_geometry(core.Matrix.from_array(coords.reshape(-1,3))); self.p4_mol.update_geometry(); if self.p4_return_wfn:; g, wfn = gradient(self.p4_name, return_wfn=True, molecule=self.p4_mol, **self.p4_kwargs); self.p4_wfn = wfn; else:; g = gradient(self.p4_name, return_wfn=False, molecule=self.p4_mol, **self.p4_kwargs); e = core.variable('CURRENT ENERGY'); return {'energy': e, 'gradient': g.np.ravel()}. return_wfn = kwargs.pop('return_wfn', False); return_history = kwargs.pop('return_history', False). if ret",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver.html:47335,energy,energy,47335,psi4manual/1.6.x/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver.html,2,['energy'],['energy']
Energy Efficiency,"_option('BASIS').lower()}, molecule={molecule.name()}, nre={'w/EFP' if hasattr(molecule, 'EFP') else molecule.nuclear_repulsion_energy()}""); logger.debug(""w/EFP"" if hasattr(molecule, ""EFP"") else pp.pformat(molecule.to_dict())); wfn = procedures[""properties""][lowername](lowername, molecule=molecule, **kwargs); logger.info(f""Return properties(): {core.variable('CURRENT ENERGY')}""). basisstash.restore(); optstash.restore(). if return_wfn:; return (core.variable('CURRENT ENERGY'), wfn); else:; return core.variable('CURRENT ENERGY'). [docs]def optimize_geometric(name, **kwargs):. import qcelemental as qcel; from qcelemental.util import which_import. if not which_import('geometric', return_bool=True):; raise ModuleNotFoundError('Python module geometric not found. Solve by installing it: `conda install -c conda-forge geometric` or `pip install geometric`'); import geometric. class Psi4NativeEngine(geometric.engine.Engine):; """"""; Internally run an energy and gradient calculation for geometric ; """"""; def __init__(self, p4_name, p4_mol, p4_return_wfn, **p4_kwargs):; ; self.p4_name = p4_name; self.p4_mol = p4_mol; self.p4_return_wfn = p4_return_wfn; self.p4_kwargs = p4_kwargs; ; molecule = geometric.molecule.Molecule(); molecule.elem = [p4_mol.symbol(i) for i in range(p4_mol.natom())]; molecule.xyzs = [p4_mol.geometry().np * qcel.constants.bohr2angstroms] ; molecule.build_bonds(); ; super(Psi4NativeEngine, self).__init__(molecule); ; def calc(self, coords, dirname, read_data=False):; self.p4_mol.set_geometry(core.Matrix.from_array(coords.reshape(-1,3))); self.p4_mol.update_geometry(); if self.p4_return_wfn:; g, wfn = gradient(self.p4_name, return_wfn=True, molecule=self.p4_mol, **self.p4_kwargs); self.p4_wfn = wfn; else:; g = gradient(self.p4_name, return_wfn=False, molecule=self.p4_mol, **self.p4_kwargs); e = core.variable('CURRENT ENERGY'); return {'energy': e, 'gradient': g.np.ravel()}. return_wfn = kwargs.pop('return_wfn', False); return_history = kwargs.pop('return_history",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver.html:53860,energy,energy,53860,psi4manual/1.7.x/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver.html,2,['energy'],['energy']
Energy Efficiency,"_option('SCF_TYPE'):; raise ValidationError('DF-MP2 properties need DF-SCF reference.'). properties = kwargs.pop('properties'); proc_util.oeprop_validator(properties). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, scf_do_properties=False, use_c1=True, **kwargs) # C1 certified. aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_MP2"",; core.get_option(""DFMP2"", ""DF_BASIS_MP2""),; ""RIFIT"", core.get_global_option('BASIS')); ref_wfn.set_basisset(""DF_BASIS_MP2"", aux_basis). core.tstart(); core.print_out('\n'); p4util.banner('DFMP2'); core.print_out('\n'). dfmp2_wfn = core.dfmp2(ref_wfn); grad = dfmp2_wfn.compute_gradient(). if name == 'scs-mp2':; dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('SCS-MP2 TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('SCS-MP2 CORRELATION ENERGY')); elif name == 'mp2':; dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('MP2 TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('MP2 CORRELATION ENERGY')). # Run OEProp; oe = core.OEProp(dfmp2_wfn); oe.set_title(name.upper()); for prop in properties:; oe.add(prop.upper()); oe.compute(); dfmp2_wfn.oeprop = oe. # Shove variables into global space; for k, v in dfmp2_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); core.tstop(); return dfmp2_wfn. def _clean_detci(keep: bool=True):; psioh = core.IOManager.shared_object(); psio = core.IO.shared_object(); cifl = core.get_option(""DETCI"", ""CI_FILE_START""); for fl in range(cifl, cifl + 4):; if psio.open_check(fl):; psio.close(fl, keep). def run_detci_property(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a configuration interaction calculation, namely FCI,; CIn, MPn, and ZAPTn, computing properties. """"""; optstash = p4util.OptionsState(; ['OPDM'],; ['TDM']). # Find valid properties; valid_transition = [",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html:103881,ENERGY,ENERGY,103881,psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,7,['ENERGY'],['ENERGY']
Energy Efficiency,"_orbitals=False, **kwargs). [docs] def build_tasks(self, obj, **kwargs):; # permanently a dummy function; pass. [docs] def plan(self):; # uncalled function; return [t.plan() for t in self.task_list.values()]. [docs] def compute(self, client: Optional[""qcportal.FractalClient""] = None):; """"""Run each job in task list.""""""; instructions = ""\n"" + p4util.banner(f"" FiniteDifference Computations"", strNotOutfile=True) + ""\n""; logger.debug(instructions); core.print_out(instructions). with p4util.hold_options_state():; for t in self.task_list.values():; t.compute(client=client). def _prepare_results(self, client: Optional[""qcportal.FractalClient""] = None):; results_list = {k: v.get_results(client=client) for k, v in self.task_list.items()}. # load AtomicComputer results into findifrec[reference]; reference = self.findifrec[""reference""]; task = results_list[""reference""]; response = task.return_result; reference[""module""] = getattr(task.provenance, ""module"", None). if task.driver == 'energy':; reference['energy'] = response. elif task.driver == 'gradient':; reference['gradient'] = response; reference['energy'] = task.extras['qcvars']['CURRENT ENERGY']. elif task.driver == 'hessian':; reference['hessian'] = response; reference['energy'] = task.extras['qcvars']['CURRENT ENERGY']; if 'CURRENT GRADIENT' in task.extras['qcvars']:; reference['gradient'] = task.extras['qcvars']['CURRENT GRADIENT']. dipole_available = False; if 'CURRENT DIPOLE' in task.extras['qcvars']:; reference['dipole'] = task.extras['qcvars']['CURRENT DIPOLE']; dipole_available = True. # load AtomicComputer results into findifrec[displacements]; for label, displacement in self.findifrec[""displacements""].items():; task = results_list[label]; response = task.return_result. if task.driver == 'energy':; displacement['energy'] = response. elif task.driver == 'gradient':; displacement['gradient'] = response; displacement['energy'] = task.extras['qcvars']['CURRENT ENERGY']. elif task.driver == 'hessian':; displacement['hes",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver_findif.html:46858,energy,energy,46858,psi4manual/1.7.x/_modules/psi4/driver/driver_findif.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver_findif.html,4,['energy'],['energy']
Energy Efficiency,"_out("" Found user provided orbital data. Setting orbital guess to READ""); fname = os.path.split(os.path.abspath(core.get_writer_file_prefix(molecule.name())))[1]; psi_scratch = core.IOManager.shared_object().get_default_path(); file_num = item.split('.')[-2] if ""180"" in item else ""180""; targetfile = os.path.join(psi_scratch, fname + ""."" + file_num + "".npy""); if not item.endswith("".npy""):; item = item + "".npy""; else:; filenum = name_split[-1]; try:; filenum = int(filenum); except ValueError:; filenum = 32 # Default file number is the checkpoint one; psioh = core.IOManager.shared_object(); psio = core.IO.shared_object(); filepath = psioh.get_file_path(filenum); namespace = psio.get_default_namespace(); pid = str(os.getpid()); prefix = 'psi'; targetfile = filepath + prefix + '.' + pid + '.' + namespace + '.' + str(filenum); core.print_out(f"" \n Copying restart file <{item}> to <{targetfile}> for internal processing\n""); shutil.copy(item, targetfile). wfn = procedures['energy'][lowername](lowername, molecule=molecule, **kwargs). for postcallback in hooks['energy']['post']:; postcallback(lowername, wfn=wfn, **kwargs). optstash.restore(); optstash2.restore(); if return_wfn: # TODO current energy safer than wfn.energy() for now, but should be revisited. # TODO place this with the associated call, very awkward to call this in other areas at the moment; if lowername in ['efp', 'mrcc', 'dmrg', 'psimrcc']:; core.print_out(""\n\nWarning! %s does not have an associated derived wavefunction."" % name); core.print_out(""The returned wavefunction is the incoming reference wavefunction.\n\n""); elif 'sapt' in lowername:; core.print_out(""\n\nWarning! %s does not have an associated derived wavefunction."" % name); core.print_out(""The returned wavefunction is the dimer SCF wavefunction.\n\n""). return (core.variable('CURRENT ENERGY'), wfn); else:; return core.variable('CURRENT ENERGY'). [docs]def gradient(name, **kwargs):; r""""""Function complementary to :py:func:`~psi4.optimize()`. Carries out",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:37128,energy,energy,37128,psi4manual/1.4.0/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html,2,['energy'],['energy']
Energy Efficiency,"_out("" Found user provided orbital data. Setting orbital guess to READ""); fname = os.path.split(os.path.abspath(core.get_writer_file_prefix(molecule.name())))[1]; psi_scratch = core.IOManager.shared_object().get_default_path(); file_num = item.split('.')[-2] if ""180"" in item else ""180""; targetfile = os.path.join(psi_scratch, fname + ""."" + file_num + "".npy""); if not item.endswith("".npy""):; item = item + "".npy""; else:; filenum = name_split[-1]; try:; filenum = int(filenum); except ValueError:; filenum = 32 # Default file number is the checkpoint one; psioh = core.IOManager.shared_object(); psio = core.IO.shared_object(); filepath = psioh.get_file_path(filenum); namespace = psio.get_default_namespace(); pid = str(os.getpid()); prefix = 'psi'; targetfile = filepath + prefix + '.' + pid + '.' + namespace + '.' + str(filenum); core.print_out(f"" \n Copying restart file <{item}> to <{targetfile}> for internal processing\n""); shutil.copy(item, targetfile). wfn = procedures['energy'][lowername](lowername, molecule=molecule, **kwargs). for postcallback in hooks['energy']['post']:; postcallback(lowername, wfn=wfn, **kwargs). optstash.restore(); optstash2.restore(); if return_wfn: # TODO current energy safer than wfn.energy() for now, but should be revisited. # TODO place this with the associated call, very awkward to call this in other areas at the moment; if lowername in ['efp', 'mrcc', 'dmrg']:; core.print_out(""\n\nWarning! %s does not have an associated derived wavefunction."" % name); core.print_out(""The returned wavefunction is the incoming reference wavefunction.\n\n""); elif 'sapt' in lowername:; core.print_out(""\n\nWarning! %s does not have an associated derived wavefunction."" % name); core.print_out(""The returned wavefunction is the dimer SCF wavefunction.\n\n""). return (core.variable('CURRENT ENERGY'), wfn); else:; return core.variable('CURRENT ENERGY'). [docs]def gradient(name, **kwargs):; r""""""Function complementary to :py:func:`~psi4.optimize()`. Carries out one gradie",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/_modules/psi4/driver/driver.html:37361,energy,energy,37361,psi4manual/1.5.0/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/_modules/psi4/driver/driver.html,2,['energy'],['energy']
Energy Efficiency,"_out(); >>> np.array(G). """"""; kwargs = p4util.kwargs_lower(kwargs); ; core.print_out(""\nScratch directory: %s\n"" % core.IOManager.shared_object().get_default_path()). # Figure out what kind of gradient this is; if hasattr(name, '__call__'):; if name.__name__ in ['cbs', 'complete_basis_set']:; gradient_type = 'cbs_wrapper'; else:; # Bounce to name if name is non-CBS function; gradient_type = 'custom_function'; elif kwargs.get('bsse_type', None) is not None:; gradient_type = 'nbody_gufunc'; elif '/' in name:; gradient_type = 'cbs_gufunc'; else:; gradient_type = 'conventional'. # Figure out lowername, dertype, and func; # If we have analytical gradients we want to pass to our wrappers, otherwise we want to run; # finite-diference energy or cbs energies; # TODO MP5/cc-pv[DT]Z behavior unkown due to ""levels""; user_dertype = kwargs.pop('dertype', None); if gradient_type == 'custom_function':; if user_dertype is None:; dertype = 0; core.print_out(; ""\nGradient: Custom function passed in without a defined dertype, assuming fd-energy based gradient.\n""; ); else:; core.print_out(""\nGradient: Custom function passed in with a dertype of %d\n"" % user_dertype); dertype = user_dertype. if dertype == 1:; return name(gradient, kwargs.pop('label', 'custom function'), ptype='gradient', **kwargs); else:; optstash = driver_util._set_convergence_criterion('energy', 'scf', 8, 10, 8, 10, 8); lowername = name. elif gradient_type == 'nbody_gufunc':; return driver_nbody.nbody_gufunc(gradient, name, ptype='gradient', **kwargs). elif gradient_type == 'cbs_wrapper':; cbs_methods = driver_cbs._cbs_wrapper_methods(**kwargs); dertype = min([_find_derivative_type('gradient', method, user_dertype) for method in cbs_methods]); if dertype == 1:; # Bounce to CBS (directly) in pure-gradient mode if name is CBS and all parts have analytic grad. avail.; return name(gradient, kwargs.pop('label', 'custom function'), ptype='gradient', **kwargs); else:; optstash = driver_util._set_convergence_criterion('energy",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:39698,energy,energy,39698,psi4manual/1.4.0/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html,2,['energy'],['energy']
Energy Efficiency,"_point_group(N3psi8MoleculeE {lvalue}); | ; | get_variable(...); | get_variable( (Molecule)arg1, (str)arg2) -> float :; | Checks if variable arg2 is in the list, sets it to val and returns true if it is, and returns false if not; | ; | C++ signature :; | d get_variable(N3psi8MoleculeE {lvalue},Ss); | ; | is_variable(...); | is_variable( (Molecule)arg1, (str)arg2) -> bool :; | Checks if variable arg2 is in the list, returns true if it is, and returns false if not; | ; | C++ signature :; | b is_variable(N3psi8MoleculeE {lvalue},Ss); | ; | label(...); | label( (Molecule)arg1, (int)arg2) -> str :; | Gets the original label of the atom as given in the input file (C2, H4); | ; | C++ signature :; | Ss label(N3psi8MoleculeE {lvalue},i); | ; | mass(...); | mass( (Molecule)arg1, (int)arg2) -> float :; | Gets mass of atom arg2; | ; | C++ signature :; | d mass(N3psi8MoleculeE {lvalue},i); | ; | molecular_charge(...); | molecular_charge( (Molecule)arg1) -> int :; | Gets the molecular charge; | ; | C++ signature :; | i molecular_charge(N3psi8MoleculeE {lvalue}); | ; | move_to_com(...); | move_to_com( (Molecule)arg1) -> None :; | Moves molecule to center of mass; | ; | C++ signature :; | void move_to_com(N3psi8MoleculeE {lvalue}); | ; | multiplicity(...); | multiplicity( (Molecule)arg1) -> int :; | Gets the multiplicity (defined as 2Ms + 1); | ; | C++ signature :; | i multiplicity(N3psi8MoleculeE {lvalue}); | ; | name(...); | name( (Molecule)arg1) -> str :; | Gets molecule name; | ; | C++ signature :; | Ss name(N3psi8MoleculeE {lvalue}); | ; | natom(...); | natom( (Molecule)arg1) -> int :; | Number of real atoms; | ; | C++ signature :; | i natom(N3psi8MoleculeE {lvalue}); | ; | nfragments(...); | nfragments( (Molecule)arg1) -> int :; | Gets the number of fragments in the molecule; | ; | C++ signature :; | i nfragments(N3psi8MoleculeE {lvalue}); | ; | nuclear_repulsion_energy(...); | nuclear_repulsion_energy( (Molecule)arg1) -> float :; | Computes nuclear repulsion energy; | ; | C+",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html:549475,charge,charge,549475,psi4manual/1.0.0/autodoc_psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html,2,['charge'],['charge']
Energy Efficiency,"_portion, job['f_basis'], job['f_zeta'], 0.0]))). #instructions += """"""\n Full listing of computations to be obtained (required and bonus).\n""""""; #for mc in JOBS_EXT:; # instructions += """""" %12s / %-24s for %s\n"""""" % (mc['f_wfn'], mc['f_basis'], VARH[mc['f_wfn']][mc['f_wfn']+mc['f_portion']]); PsiMod.print_out(instructions). psioh = PsiMod.IOManager.shared_object(); psioh.set_specific_retention(PSIF_SCF_DB_MOS, True). # Run necessary computations; for mc in JOBS:; kwargs['name'] = mc['f_wfn']. # Build string of title banner; cbsbanners = ''; cbsbanners += """"""PsiMod.print_out('\\n')\n""""""; cbsbanners += """"""banner(' CBS Computation: %s / %s ')\n"""""" % (mc['f_wfn'].upper(), mc['f_basis'].upper()); cbsbanners += """"""PsiMod.print_out('\\n')\n\n""""""; exec(cbsbanners). # Build string of molecule and commands that are dependent on the database; commands = '\n'; commands += """"""\nPsiMod.set_global_option('BASIS', '%s')\n"""""" % (mc['f_basis']); exec(commands). # Make energy() call; mc['f_energy'] = call_function_in_1st_argument(func, **kwargs). # Fill in energies for subsumed methods; for menial in VARH[mc['f_wfn']]:; temp_wfn, temp_portion = split_menial(menial); for job in JOBS_EXT:; if (temp_wfn == job['f_wfn']) and (temp_portion == job['f_portion']) and (mc['f_basis'] == job['f_basis']):; job['f_energy'] = PsiMod.get_variable(VARH[temp_wfn][menial]). PsiMod.clean(). psioh.set_specific_retention(PSIF_SCF_DB_MOS, False). # Build string of title banner; cbsbanners = ''; cbsbanners += """"""PsiMod.print_out('\\n')\n""""""; cbsbanners += """"""banner(' CBS Results ')\n""""""; cbsbanners += """"""PsiMod.print_out('\\n')\n\n""""""; exec(cbsbanners). # Insert obtained energies into the array that stores the cbs stages; for stage in GRAND_NEED:; for lvl in stage['d_need'].items():; MODELCHEM.append(lvl[1]). for job in JOBS_EXT:; if ((lvl[1]['f_wfn'] == job['f_wfn']) and (lvl[1]['f_portion'] == job['f_portion']) and; (lvl[1]['f_basis'] == job['f_basis'])):; lvl[1]['f_energy'] = job['f_energy']. for stage i",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/_modules/wrappers.html:71353,energy,energy,71353,psi4manual/4.0b3/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/_modules/wrappers.html,2,['energy'],['energy']
Energy Efficiency,"_qcvars:; hold_qcvars[pv] = ref_wfn.variable(pv). ref_wfn.set_variable(""BCCD TOTAL ENERGY"", ref_wfn.variable(""CCSD TOTAL ENERGY"")); ref_wfn.set_variable(""BCCD CORRELATION ENERGY"", ref_wfn.variable(""BCCD TOTAL ENERGY"") - ref_wfn.variable(""SCF TOTAL ENERGY"")); ref_wfn.set_variable(""CURRENT CORRELATION ENERGY"", ref_wfn.variable(""BCCD CORRELATION ENERGY"")). # copy back canonical MP2 and CCSD from initial iteration; for pv, v in hold_qcvars.items():; if v is not None:; ref_wfn.set_variable(pv, v); core.set_variable(pv, v). if name == 'bccd(t)':; core.cctriples(ref_wfn); ref_wfn.set_variable(""B(T) CORRECTION ENERGY"", ref_wfn.variable(""(T) CORRECTION ENERGY"")); ref_wfn.set_variable(""BCCD(T) TOTAL ENERGY"", ref_wfn.variable(""CCSD(T) TOTAL ENERGY"")); ref_wfn.set_variable(""BCCD(T) CORRELATION ENERGY"", ref_wfn.variable(""BCCD(T) TOTAL ENERGY"") - ref_wfn.variable(""SCF TOTAL ENERGY"")) # note != CCSD(T) CORRELATION ENERGY; ref_wfn.set_variable(""CURRENT CORRELATION ENERGY"", ref_wfn.variable(""BCCD(T) CORRELATION ENERGY"")). for pv in [""(T) CORRECTION ENERGY"", ""CCSD(T) TOTAL ENERGY"", ""CCSD(T) CORRELATION ENERGY""]:; ref_wfn.del_variable(pv); core.del_variable(pv). for pv in [; ""BCCD TOTAL ENERGY"",; ""BCCD CORRELATION ENERGY"",; ""B(T) CORRECTION ENERGY"",; ""BCCD(T) TOTAL ENERGY"",; ""BCCD(T) CORRELATION ENERGY"",; ""CURRENT CORRELATION ENERGY"",; ]:; if ref_wfn.has_variable(pv):; core.set_variable(pv, ref_wfn.variable(pv)). # Notes; # * BCCD or BCCD(T) correlation energy is total energy of last Brueckner iteration minus HF energy of first Brueckner iteration. optstash.restore(); return ref_wfn. def run_tdscf_excitations(wfn,**kwargs):. states = core.get_option(""SCF"",""TDSCF_STATES""). # some sanity checks; if sum(states) == 0:; raise ValidationError(""TDSCF: No states requested in TDSCF_STATES""). # unwrap 1-membered list of states, regardless of symmetry; # we will apportion states per irrep later on; if len(states) == 1:; states = states[0]. # Tie TDSCF_R_CONVERGENCE to D_CONVERGENCE in SCF refere",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:98107,ENERGY,ENERGY,98107,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,4,['ENERGY'],['ENERGY']
Energy Efficiency,"_range.sort(); for n in nbody_range:; delta_e = (energy_body_dict[n] - previous_e); delta_e_kcal = delta_e * constants.hartree2kcalmol; int_e_kcal = (; energy_body_dict[n] - energy_body_dict[1]) * constants.hartree2kcalmol if not embedding else np.nan; core.print_out(; """""" %4s %20.12f %20.12f %20.12f\n"""""" % (n, energy_body_dict[n], int_e_kcal, delta_e_kcal)); previous_e = energy_body_dict[n]; core.print_out(""\n""). [docs]def nbody_gufunc(func, method_string, **kwargs):; """"""; Computes the nbody interaction energy, gradient, or Hessian depending on input.; This is a generalized univeral function for computing interaction and total quantities. :returns: *return type of func* |w--w| The data. :returns: (*float*, :py:class:`~psi4.core.Wavefunction`) |w--w| data and wavefunction with energy/gradient/hessian set appropriately when **return_wfn** specified. :type func: function; :param func: ``energy`` || etc. Python function that accepts method_string and a molecule. Returns a; energy, gradient, or Hessian as requested. :type method_string: string; :param method_string: ``'scf'`` || ``'mp2'`` || ``'ci5'`` || etc. First argument, lowercase and usually unlabeled. Indicates the computational; method to be passed to func. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :type return_wfn: :ref:`boolean <op_py_boolean>`; :param return_wfn: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return the :py:class:`~psi4.core.Wavefunction`; calculation result as the second element of a tuple. :type bsse_type: string or list; :param bsse_type: ``'cp'`` || ``['nocp', 'vmfc']`` || |dl| ``None`` |dr| || etc. Type of BSSE correction to compute: CP, NoCP, or VMFC. The first in this; list is returned by this function. By default, this function is not called. :type max_nbody: int; :param max_nbody: ``3`` || etc. Maximum n-body to compute, cannot exceed the number of fragments in the moleucle. :typ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver_nbody.html:4088,energy,energy,4088,psi4manual/1.3.2/_modules/psi4/driver/driver_nbody.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver_nbody.html,1,['energy'],['energy']
Energy Efficiency,_ratio; -1.91304273; neutron mag. mom. to nuclear magneton ratio [] uncertainty=0.000 000 45. neutron_mass; 1.674927471E-27; neutron mass [kg] uncertainty=0.000 000 021 e-27. neutron_mass_energy_equivalent; 1.505349739E-10; neutron mass energy equivalent [J] uncertainty=0.000 000 019 e-10. neutron_mass_energy_equivalent_in_MeV; 939.5654133; neutron mass energy equivalent in MeV [MeV] uncertainty=0.000 0058. neutron_mass_in_u; 1.00866491588; neutron mass in u [u] uncertainty=0.000 000 000 49. neutron_molar_mass; 0.00100866491588; neutron molar mass [kg mol^{-1}] uncertainty=0.000 000 000 49 e-3. neutron_muon_mass_ratio; 8.89248408; neutron-muon mass ratio [] uncertainty=0.000 000 20. neutron_proton_mag_mom_ratio; -0.68497934; neutron-proton mag. mom. ratio [] uncertainty=0.000 000 16. neutron_proton_mass_difference; 2.30557377E-30; neutron-proton mass difference [] uncertainty=0.000 000 85 e-30. neutron_proton_mass_difference_energy_equivalent; 2.07214637E-13; neutron-proton mass difference energy equivalent [] uncertainty=0.000 000 76 e-13. neutron_proton_mass_difference_energy_equivalent_in_MeV; 1.29333205; neutron-proton mass difference energy equivalent in MeV [] uncertainty=0.000 000 48. neutron_proton_mass_difference_in_u; 0.00138844900; neutron-proton mass difference in u [] uncertainty=0.000 000 000 51. neutron_proton_mass_ratio; 1.00137841898; neutron-proton mass ratio [] uncertainty=0.000 000 000 51. neutron_tau_mass_ratio; 0.528790; neutron-tau mass ratio [] uncertainty=0.000 048. neutron_to_shielded_proton_mag_mom_ratio; -0.68499694; neutron to shielded proton mag. mom. ratio [] uncertainty=0.000 000 16. Newtonian_constant_of_gravitation; 6.67408E-11; Newtonian constant of gravitation [m^3 kg^{-1} s^{-2}] uncertainty=0.000 31 e-11. Newtonian_constant_of_gravitation_over_h_bar_c; 6.70861E-39; Newtonian constant of gravitation over h-bar c [(GeV/c^2)^-2] uncertainty=0.000 31 e-39. nuclear_magneton; 5.050783699E-27; nuclear magneton [J T^{-1}] uncertainty=0.,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/autodoc_physconst-1.html:26434,energy,energy,26434,psi4manual/1.3.2/autodoc_physconst-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/autodoc_physconst-1.html,11,['energy'],['energy']
Energy Efficiency,"_reference); if not b_user_reference:; PsiMod.revoke_global_option_changed('REFERENCE'); PsiMod.set_global_option('WRITER_FILE_LABEL', user_writer_file_label). DB_RGT.clear(); DB_RGT.update(VRGT); DB_RXN.clear(); DB_RXN.update(VRXN); return finalenergy . [docs]def tblhead(tbl_maxrgt, tbl_delimit, ttype):; r""""""Function that prints the header for the changable-width results tables in db().; *tbl_maxrgt* is the number of reagent columns the table must plan for. *tbl_delimit*; is a string of dashes of the correct length to set off the table. *ttype* is 1 for; tables comparing the computed values to the reference or 2 for simple tabulation; and sum of the computed values. """"""; tbl_str = ''; tbl_str += """""" %s"""""" % (tbl_delimit); if ttype == 1:; tbl_str += """"""\n%23s %19s %8s"""""" % ('Reaction', 'Reaction Energy', 'Error'); elif ttype == 2:; tbl_str += """"""\n%23s %19s %6s"""""" % ('Reaction', 'Reaction Value', ''); for i in range(tbl_maxrgt):; tbl_str += """"""%20s"""""" % ('Reagent ' + str(i + 1)); if ttype == 1:; tbl_str += """"""\n%23s %8s %8s %8s"""""" % ('', 'Ref', 'Calc', '[kcal/mol]'); elif ttype == 2:; tbl_str += """"""\n%54s"""""" % (''); for i in range(tbl_maxrgt):; if ttype == 1:; tbl_str += """"""%20s"""""" % ('[H] Wt'); elif ttype == 2:; tbl_str += """"""%20s"""""" % ('Value Wt'); tbl_str += """"""\n %s"""""" % (tbl_delimit); return tbl_str. ## Aliases ##; db = database. #######################; ## End of Database ##; #######################. ###################################; ## Start of Complete Basis Set ##; ###################################. [docs]def complete_basis_set(name, **kwargs):; r""""""Function to define a multistage energy method from combinations of; basis set extrapolations and delta corrections and condense the; components into a minimum number of calculations. :aliases: cbs(). :returns: (*float*) -- Total electronic energy in Hartrees. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`CBS TOTAL ENERGY <CBSTOTALENERGY>`; * :psivar:`CBS REFERENCE ENERGY <CBSREFERENCEENERGY>`; * :psiv",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:51509,Energy,Energy,51509,psi4manual/4.0b4/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html,1,['Energy'],['Energy']
Energy Efficiency,"_scf = psi4.get_variable('SCF TOTAL ENERGY'); ce_mp2 = psi4.get_variable('MP2 CORRELATION ENERGY'); ce_mp3 = psi4.get_variable('MP3 CORRELATION ENERGY'); e_mp2 = e_scf + ce_mp2 # reform mp2 and mp3 total energies for printing; e_mp3 = e_scf + ce_mp3. # Compute quantities particular to MP2.5; ce_mp25 = 0.5 * (ce_mp2 + ce_mp3); e_mp25 = e_scf + ce_mp25; psi4.set_variable('MP2.5 CORRELATION ENERGY', ce_mp25) # add new method's important results; psi4.set_variable('MP2.5 TOTAL ENERGY', e_mp25) # to PSI variable repository; psi4.set_variable('CURRENT CORRELATION ENERGY', ce_mp25); psi4.set_variable('CURRENT ENERGY', e_mp25) # geometry optimizer tracks this variable, permits; # MP2.5 finite difference optimizations; # build string of title banner and print results; banners = ''; banners += """"""psi4.print_out('\\n')\n""""""; banners += """"""banner(' MP2.5 ')\n""""""; banners += """"""psi4.print_out('\\n')\n\n""""""; exec banners. tables = ''; tables += """""" SCF total energy: %16.8f\n"""""" % (e_scf); tables += """""" MP2 total energy: %16.8f\n"""""" % (e_mp2); tables += """""" MP2.5 total energy: %16.8f\n"""""" % (e_mp25); tables += """""" MP3 total energy: %16.8f\n\n"""""" % (e_mp3); tables += """""" MP2 correlation energy: %16.8f\n"""""" % (ce_mp2); tables += """""" MP2.5 correlation energy: %16.8f\n"""""" % (ce_mp25); tables += """""" MP3 correlation energy: %16.8f\n"""""" % (ce_mp3); psi4.print_out(tables) # prints nice header and table of all involved quantities to output file. return e_mp25. One final step is necessary. At the end of the aliases.py file, add; the following line.; procedures['energy']['mp2.5'] = run_mp2_5. This permits the newly defined MP2.5 method to be called in the input file; with the following command.; energy('mp2.5'). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Customization: Adding Simple Extensions; Defining a Method Alias. © Copyright 2022, The Psi4 Project.; Last updated on Thursday, 19 May 2022 08:57PM.; Created using Sphinx 4.5.0.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/quickaddalias.html:2983,energy,energy,2983,psi4manual/1.6.x/quickaddalias.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/quickaddalias.html,7,['energy'],['energy']
Energy Efficiency,"_scf basis is not set, pick a sensible one.; if PsiMod.get_global_option('DF_BASIS_SCF') == '':; jkbasis = corresponding_jkfit(PsiMod.get_global_option('BASIS')); if jkbasis:; PsiMod.set_global_option('DF_BASIS_SCF', jkbasis); PsiMod.print_out('\nNo DF_BASIS_SCF auxiliary basis selected, defaulting to %s\n\n' % (jkbasis)); else:; raise ValidationError('Keyword DF_BASIS_SCF is required.'). scf_helper(name, **kwargs). PsiMod.print_out('\n'); banner('DFMP2'); PsiMod.print_out('\n'). # if the df_basis_mp2 basis is not set, pick a sensible one.; if PsiMod.get_global_option('DF_BASIS_MP2') == '':; ribasis = corresponding_rifit(PsiMod.get_global_option('BASIS')); if ribasis:; PsiMod.set_global_option('DF_BASIS_MP2', ribasis); PsiMod.print_out('No DF_BASIS_MP2 auxiliary basis selected, defaulting to %s\n' % (ribasis)); else:; raise ValidationError('Keyword DF_BASIS_MP2 is required.'). PsiMod.dfmp2grad(); e_dfmp2 = PsiMod.get_variable('MP2 TOTAL ENERGY'); e_scs_dfmp2 = PsiMod.get_variable('SCS-MP2 TOTAL ENERGY'). optstash.restore(). if (name.upper() == 'SCS-DFMP2') or (name.upper() == 'SCS-DF-MP2'):; return e_scs_dfmp2; elif (name.upper() == 'DF-MP2') or (name.upper() == 'DFMP2') or (name.upper() == 'MP2'):; return e_dfmp2. [docs]def run_eom_cc(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; an EOM-CC calculation, namely EOM-CC2, EOM-CCSD, and EOM-CC3. """"""; optstash = OptionsState(; ['TRANSQT2', 'WFN'],; ['CCSORT', 'WFN'],; ['CCENERGY', 'WFN'],; ['CCHBAR', 'WFN'],; ['CCEOM', 'WFN']). if (name.lower() == 'eom-ccsd'):; PsiMod.set_local_option('TRANSQT2', 'WFN', 'EOM_CCSD'); PsiMod.set_local_option('CCSORT', 'WFN', 'EOM_CCSD'); PsiMod.set_local_option('CCENERGY', 'WFN', 'EOM_CCSD'); PsiMod.set_local_option('CCHBAR', 'WFN', 'EOM_CCSD'); PsiMod.set_local_option('CCEOM', 'WFN', 'EOM_CCSD'); run_ccenergy('ccsd', **kwargs); elif (name.lower() == 'eom-cc2'):; PsiMod.set_local_option('TRANSQT2', 'WFN', 'EOM_CC2'); PsiMod.set_local_option('CCSORT', 'WFN', 'EOM_C",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/_modules/proc.html:31944,ENERGY,ENERGY,31944,psi4manual/4.0b4/_modules/proc.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/proc.html,1,['ENERGY'],['ENERGY']
Energy Efficiency,"_scf_gradient,; 'ccsd' : run_cc_gradient,; 'ccsd(t)' : run_cc_gradient,; 'mp2' : run_mp2_gradient,; 'df-mp2' : run_dfmp2_gradient,; 'dfmp2' : run_dfmp2_gradient,; 'eom-ccsd' : run_eom_cc_gradient,; 'dcft' : run_dcft_gradient; # Upon adding a method to this list, add it to the docstring in optimize() below; },; 'hessian' : {; # Upon adding a method to this list, add it to the docstring in frequency() below; },; 'property' : {; 'scf' : run_scf_property,; 'cc2' : run_cc_property,; 'ccsd' : run_cc_property,; 'eom-cc2' : run_cc_property,; 'eom-ccsd' : run_cc_property,; 'eom_cc2' : run_cc_property,; 'eom_ccsd' : run_cc_property; # Upon adding a method to this list, add it to the docstring in property() below; }}. # Integrate DFT with driver routines; for ssuper in superfunctional_list():; procedures['energy'][ssuper.name().lower()] = run_dft. for ssuper in superfunctional_list():; procedures['gradient'][ssuper.name().lower()] = run_dft_gradient. [docs]def energy(name, **kwargs):; r""""""Function to compute the single-point electronic energy. :returns: (*float*) Total electronic energy in Hartrees. SAPT returns interaction energy. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`CURRENT ENERGY <CURRENTENERGY>`; * :psivar:`CURRENT REFERENCE ENERGY <CURRENTREFERENCEENERGY>`; * :psivar:`CURRENT CORRELATION ENERGY <CURRENTCORRELATIONENERGY>`. .. comment In this table immediately below, place methods that should only be called by; .. comment developers at present. This table won't show up in the manual.; .. comment; .. comment .. _`table:energy_devel`:; .. comment; .. comment +-------------------------+---------------------------------------------------------------------------------------+; .. comment | name | calls method |; .. comment +=========================+=======================================================================================+; .. comment | df-cc | coupled cluster with density fitting |; .. comment +-------------------------+-----------------------------",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/_modules/driver.html:3594,energy,energy,3594,psi4manual/4.0b3/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/_modules/driver.html,4,['energy'],['energy']
Energy Efficiency,"_sowreap_from_output(rfile, 'HESSIAN', n, freq_linkage, True)). # S/R: Quit sow after writing files. Initialize skeleton wfn to receive grad for reap; if freq_mode == 'sow':; optstash.restore(); optstash_conv.restore(); if return_wfn:; return (None, None); else:; return None; elif freq_mode == 'reap':; # core.set_variable('CURRENT ENERGY', energies[-1]); wfn = core.Wavefunction.build(molecule, core.get_global_option('BASIS')). # Assemble Hessian from energies; H = core.fd_freq_0(molecule, energies, irrep); wfn.set_hessian(H); wfn.set_frequencies(core.get_frequencies()). # The last item in the list is the reference energy, return it; core.set_variable('CURRENT ENERGY', energies[-1]). core.set_parent_symmetry(''); optstash.restore(); optstash_conv.restore(). if return_wfn:; return (wfn.hessian(), wfn); else:; return wfn.hessian(). [docs]def frequency(name, **kwargs):; r""""""Function to compute harmonic vibrational frequencies. :aliases: frequencies(), freq(). :returns: *float* |w--w| Total electronic energy in Hartrees. :returns: (*float*, :py:class:`~psi4.core.Wavefunction`) |w--w| energy and wavefunction when **return_wfn** specified. :type name: string; :param name: ``'scf'`` || ``'mp2'`` || ``'ci5'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the system. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :type return_wfn: :ref:`boolean <op_py_boolean>`; :param return_wfn: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return the :py:class:`~psi4.core.Wavefunction`; calculation result as the second element (after *float* energy) of a tuple.; Arrays of frequencies and the Hessian can be accessed through the wavefunction. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``gradient`` |dr| || ``energy`` || ``cbs``. Indicates the type of calculation to be performed on the molecule.; The default dertype access",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/driver.html:80809,energy,energy,80809,psi4manual/1.1.0/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/driver.html,1,['energy'],['energy']
Energy Efficiency,"_spin_contamination(self); docstring. cphf_Hx(self, arg0); CPHF Hessian-vector prodcuts (4 * J - K - K.T). cphf_converged(self); Adds occupied guess alpha orbitals. cphf_solve(self, x_vec, conv_tol, max_iter); Solves the CPHF equations for a given set of x vectors. damping_update(self, arg0); docstring. deep_copy(self, arg0); Deep copies the internal data. del_array_variable(self, arg0); Removes the requested (case-insensitive) Matrix QC variable. del_potential_variable(self, arg0); Removes the requested (case-insensitive) ExternalPotential QC variable. del_scalar_variable(self, arg0); Removes the requested (case-insensitive) double QC variable. del_variable(key); Removes scalar or array QCVariable key from cls if present. density_fitted(self); Returns whether this wavefunction was obtained using density fitting or not. diis(self, arg0); docstring. doccpi(self); Returns the number of doubly occupied orbitals per irrep. efzc(self); Returns the frozen-core energy. energy(self); Returns the Wavefunction's energy. epsilon_a(self); Returns the Alpha Eigenvalues. epsilon_a_subset(self, basis, subset); Returns the requested Alpha orbital energies subset. epsilon_b(self); Returns the Beta Eigenvalues. epsilon_b_subset(self, basis, subset); Returns the requested Beta orbital energies subset. esp_at_nuclei(self); returns electrostatic potentials at nuclei. external_pot(self); Gets the requested external potential. finalize(self); Cleans up the the Wavefunction's temporary data. finalize_energy(); Performs stability analysis and calls back SCF with new guess if needed, Returns the SCF energy. find_occupation(self); docstring. force_doccpi(self, arg0); Specialized expert use only. force_soccpi(self, arg0); Specialized expert use only. form_C(self[, shift]); Forms the Orbital Matrices from the current Fock Matrices. form_D(self); Forms the Density Matrices from the current Orbitals Matrices. form_F(self); Forms the F matrix. form_FDSmSDF(self, arg0, arg1); Forms the residual of S",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/api/psi4.core.CUHF.html:4225,energy,energy,4225,psi4manual/1.6.x/api/psi4.core.CUHF.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/api/psi4.core.CUHF.html,20,['energy'],['energy']
Energy Efficiency,"_str()) # print convergence and step info. # Update psi4's molecule with new step. (Psi4 can rotate this molecule); molecule.set_geometry(core.Matrix.from_array(opt_object.molsys.geom)); molecule.update_geometry(). opt_status = opt_object.status() # Query optking for convergence, failure or continuing opt.; if opt_status == 'CONVERGED':. # Last geom is normally last in history. For IRC last geom is last in IRC trajectory; # Not sure how to handle ensuring that wfn corresponds to last point.; final_energy, final_geom = opt_object.summarize_result(). # Changing environment to optimized geometry as expected by user; molecule.set_geometry(core.Matrix.from_array(final_geom)); molecule.update_geometry(). print('Optimizer: Optimization complete!'); core.print_out('\n Final optimized geometry and variables:\n'); molecule.print_in_input_format(). for postcallback in hooks['optimize']['post']:; postcallback(lowername, wfn=wfn, **kwargs); core.clean(). optstash.restore(). if return_history:; history = {; 'energy': [step.E for step in opt_object.history.steps],; 'gradient': [step.cart_grad for step in opt_object.history.steps],; 'coordinates': [step.geom for step in opt_object.history.steps],; }. # Create OptimizationResult like Schema. Not validated since optimize() does not pass AtomicResults.; opt_data = opt_object.close(); if core.get_option('OPTKING', 'WRITE_OPT_HISTORY'):; with open(f""{core.get_writer_file_prefix(molecule.name())}.opt.json"", 'w+') as f:; json.dump(opt_data, f, indent=2). if return_wfn and return_history:; return (thisenergy, wfn, history); elif return_wfn and not return_history:; return (thisenergy, wfn); elif return_history and not return_wfn:; return (thisenergy, history); else:; return thisenergy. elif opt_status == 'FAILED':. print('Optimizer: Optimization failed!'); molecule.set_geometry(core.Matrix.from_array(opt_object.molsys.geom)); molecule.update_geometry(); core.clean(); optstash.restore(). opt_data = opt_object.to_dict(); if core.get_option('O",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver.html:76131,energy,energy,76131,psi4manual/1.7.x/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver.html,8,['energy'],['energy']
Energy Efficiency,"_sum_cluster_ptype_data(metadata['ptype'], component_results['ptype'],; cp_compute_list[n], fragment_slice_dict, ; fragment_size_dict, cp_ptype_by_level[n]); _sum_cluster_ptype_data(metadata['ptype'], component_results['ptype'],; nocp_compute_list[n], fragment_slice_dict, ; fragment_size_dict, nocp_ptype_by_level[n]); _sum_cluster_ptype_data(metadata['ptype'], component_results['ptype'],; vmfc_level_list[n], fragment_slice_dict, ; fragment_size_dict, mfc_ptype_by_level[n],; vmfc=True). # Compute cp energy and ptype; if 'cp' in metadata['bsse_type_list']:; for n in nbody_range:; if n == metadata['max_frag']:; cp_energy_body_dict[n] = cp_energy_by_level[n]; if metadata['ptype'] != 'energy':; cp_ptype_body_dict[n][:] = cp_ptype_by_level[n]; continue. for k in range(1, n + 1):; take_nk = nCr(metadata['max_frag'] - k - 1, n - k); sign = ((-1) ** (n - k)); value = cp_energy_by_level[k]; cp_energy_body_dict[n] += take_nk * sign * value. if metadata['ptype'] != 'energy':; value = cp_ptype_by_level[k]; cp_ptype_body_dict[n] += take_nk * sign * value. _print_nbody_energy(cp_energy_body_dict, ""Counterpoise Corrected (CP)""); cp_interaction_energy = cp_energy_body_dict[metadata['max_nbody']] - cp_energy_body_dict[1]; nbody_dict['Counterpoise Corrected Total Energy'] = cp_energy_body_dict[metadata['max_nbody']]; nbody_dict['Counterpoise Corrected Interaction Energy'] = cp_interaction_energy. for n in nbody_range[1:]:; var_key = 'CP-CORRECTED %d-BODY INTERACTION ENERGY' % n; nbody_dict[var_key] = cp_energy_body_dict[n] - cp_energy_body_dict[1]. # Compute nocp energy and ptype; if 'nocp' in metadata['bsse_type_list']:; for n in nbody_range:; if n == metadata['max_frag']:; nocp_energy_body_dict[n] = nocp_energy_by_level[n]; if metadata['ptype'] != 'energy':; nocp_ptype_body_dict[n][:] = nocp_ptype_by_level[n]; continue. for k in range(1, n + 1):; take_nk = nCr(metadata['max_frag'] - k - 1, n - k); sign = ((-1) ** (n - k)); value = nocp_energy_by_level[k]; nocp_energy_body_dict[n] +=",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/driver_nbody.html:21470,energy,energy,21470,psi4manual/1.2.1/_modules/psi4/driver/driver_nbody.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/driver_nbody.html,1,['energy'],['energy']
Energy Efficiency,"_superfunctional(name, npoints, deriv):. # Call this first; sup = psi4.SuperFunctional.blank(); sup.set_max_points(npoints); sup.set_deriv(deriv). # => User-Customization <= #. # No spaces, keep it short and according to convention; sup.set_name('DSD-PBEPBE'); # Tab in, trailing newlines; sup.set_description(' DSD-PBEPBE Dispersion-corrected SCS Double Hybrid XC Functional\n'); # Tab in, trailing newlines; sup.set_citation(' S. Kozuch, Phys. Chem. Chem. Phys., 13, 20104, 2011\n'). # Add member functionals; X = build_functional('PBE_X'); X.set_alpha(1.0); sup.add_x_functional(X); C = build_functional('PBE_C'); C.set_alpha(0.51); sup.add_c_functional(C). # Set GKS up after adding functionals; sup.set_x_omega(0.0); sup.set_c_omega(0.0); sup.set_x_alpha(0.66); sup.set_c_alpha(1.0); sup.set_c_ss_alpha(0.12); sup.set_c_os_alpha(0.53). # => -D2 <=. sup.set_dispersion(psi4.Dispersion.build(*dash_server('dsd-pbepbe', 'd2p4'))). # => End User-Customization <= #. # Call this last; sup.allocate(); return sup. [docs]def build_b2plypd2p4_superfunctional(name, npoints, deriv):. sup = build_b2plyp_superfunctional(name, npoints, deriv); sup.set_name('B2PLYP-D2P4'). # => -D2 <= #; sup.set_dispersion(psi4.Dispersion.build(*dash_server('b2plyp', 'd2p4'))). return sup. [docs]def build_b2plypd2gr_superfunctional(name, npoints, deriv):. sup = build_b2plyp_superfunctional(name, npoints, deriv); sup.set_name('B2PLYP-D2GR'). # => -D2 <= #; sup.set_dispersion(psi4.Dispersion.build(*dash_server('b2plyp', 'd2gr'))). return sup. [docs]def build_b2plypd3zero_superfunctional(name, npoints, deriv):. sup = build_b2plyp_superfunctional(name, npoints, deriv); sup.set_name('B2PLYP-D3ZERO'). # => -D3 <= #; sup.set_dispersion(psi4.Dispersion.build(*dash_server('b2plyp', 'd3zero'))). return sup. [docs]def build_b2plypd3bj_superfunctional(name, npoints, deriv):. sup = build_b2plyp_superfunctional(name, npoints, deriv); sup.set_name('B2PLYP-D3BJ'). # => -D3 <= #; sup.set_dispersion(psi4.Dispersion.build(*das",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/functional.html:77892,allocate,allocate,77892,psi4manual/4.0b5/_modules/functional.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/functional.html,3,['allocate'],['allocate']
Energy Efficiency,"_symbol()); ERGT[rgt] = func(molecule=molecule, **kwargs); core.print_variables(); exec(actives); for envv in db_tabulate:; VRGT[rgt][envv.upper()] = core.get_variable(envv); core.set_global_option(""REFERENCE"", user_reference); core.clean(); #core.opt_clean(); core.clean_variables(). elif db_mode == 'sow':; with open('%s.in' % (rgt), 'w') as freagent:; freagent.write('# This is a psi4 input file auto-generated from the database() wrapper.\n\n'); freagent.write(banners); freagent.write(p4util.format_molecule_for_input(GEOS[rgt], 'dbmol')). freagent.write(commands); freagent.write('''\npickle_kw = (""""""'''); pickle.dump(kwargs, freagent); freagent.write('''"""""")\n'''); freagent.write(""""""\nkwargs = pickle.loads(pickle_kw)\n""""""); freagent.write(""""""electronic_energy = %s(**kwargs)\n\n"""""" % (func.__name__)); freagent.write(""""""core.print_variables()\n""""""); freagent.write(""""""core.print_out('\\nDATABASE RESULT: computation %d for reagent %s """"""; % (os.getpid(), rgt)); freagent.write(""""""yields electronic energy %20.12f\\n' % (electronic_energy))\n\n""""""); freagent.write(""""""core.set_variable('NATOM', dbmol.natom())\n""""""); for envv in db_tabulate:; freagent.write(""""""core.print_out('DATABASE RESULT: computation %d for reagent %s """"""; % (os.getpid(), rgt)); freagent.write(""""""yields variable value %20.12f for variable %s\\n' % (core.get_variable(""""""); freagent.write(""""""'%s'), '%s'))\n"""""" % (envv.upper(), envv.upper())). elif db_mode == 'reap':; ERGT[rgt] = 0.0; for envv in db_tabulate:; VRGT[rgt][envv.upper()] = 0.0; exec(banners); exec(actives); try:; freagent = open('%s.out' % (rgt), 'r'); except IOError:; core.print_out('Warning: Output file \'%s.out\' not found.\n' % (rgt)); core.print_out(' Database summary will have 0.0 and **** in its place.\n'); else:; while 1:; line = freagent.readline(); if not line:; if ERGT[rgt] == 0.0:; core.print_out('Warning: Output file \'%s.out\' has no DATABASE RESULT line.\n' % (rgt)); core.print_out(' Database summary will have 0.0 and **** in its",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/wrapper_database.html:22430,energy,energy,22430,psi4manual/1.1.0/_modules/psi4/driver/wrapper_database.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/wrapper_database.html,1,['energy'],['energy']
Energy Efficiency,"_symbol()); ERGT[rgt] = func(molecule=molecule, **kwargs); psi4.print_variables(); exec(actives); for envv in db_tabulate:; VRGT[rgt][envv.upper()] = psi4.get_variable(envv); psi4.set_global_option(""REFERENCE"", user_reference); psi4.clean(); #psi4.opt_clean(); psi4.clean_variables(). elif db_mode == 'sow':; with open('%s.in' % (rgt), 'w') as freagent:; freagent.write('# This is a psi4 input file auto-generated from the database() wrapper.\n\n'); freagent.write(banners); freagent.write(p4util.format_molecule_for_input(GEOS[rgt], 'dbmol')). freagent.write(commands); freagent.write('''\npickle_kw = (""""""'''); pickle.dump(kwargs, freagent); freagent.write('''"""""")\n'''); freagent.write(""""""\nkwargs = pickle.loads(pickle_kw)\n""""""); freagent.write(""""""electronic_energy = %s(**kwargs)\n\n"""""" % (func.__name__)); freagent.write(""""""psi4.print_variables()\n""""""); freagent.write(""""""psi4.print_out('\\nDATABASE RESULT: computation %d for reagent %s """"""; % (os.getpid(), rgt)); freagent.write(""""""yields electronic energy %20.12f\\n' % (electronic_energy))\n\n""""""); freagent.write(""""""psi4.set_variable('NATOM', dbmol.natom())\n""""""); for envv in db_tabulate:; freagent.write(""""""psi4.print_out('DATABASE RESULT: computation %d for reagent %s """"""; % (os.getpid(), rgt)); freagent.write(""""""yields variable value %20.12f for variable %s\\n' % (psi4.get_variable(""""""); freagent.write(""""""'%s'), '%s'))\n"""""" % (envv.upper(), envv.upper())). elif db_mode == 'reap':; ERGT[rgt] = 0.0; for envv in db_tabulate:; VRGT[rgt][envv.upper()] = 0.0; exec(banners); exec(actives); try:; freagent = open('%s.out' % (rgt), 'r'); except IOError:; psi4.print_out('Warning: Output file \'%s.out\' not found.\n' % (rgt)); psi4.print_out(' Database summary will have 0.0 and **** in its place.\n'); else:; while 1:; line = freagent.readline(); if not line:; if ERGT[rgt] == 0.0:; psi4.print_out('Warning: Output file \'%s.out\' has no DATABASE RESULT line.\n' % (rgt)); psi4.print_out(' Database summary will have 0.0 and **** in its",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/wrapper_database.html:22304,energy,energy,22304,psi4manual/1.0.0/_modules/wrapper_database.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/wrapper_database.html,1,['energy'],['energy']
Energy Efficiency,"_t-4; Mk-MRCCSD(T) single point. \(^1A_1\) O$_3` state described using the Ms = 0 component of the singlet. Uses TCSCF orbitals. dft-custom-gga; DFT (LDA/GGA) test of custom implementations in: gga_superfuncs.py. dft-custom-hybrid; DFT (hybrids) test of implementations in: hybrid_superfuncs.py. opt13; B3LYP cc-pVDZ geometry optimzation of phenylacetylene, starting from not quite linear structure updated reference due to new BraggSlater radii. mp2-h; check that methods can act on single atom. mcscf2; TCSCF cc-pVDZ energy of asymmetrically displaced ozone, with Z-matrix input. fnocc3; Test FNO-QCISD(T) computation. cbs-xtpl-freq; Various gradients for a strained helium dimer and water molecule. sapt5; SAPT0 aug-cc-pVTZ computation of the charge transfer energy of the water dimer. pubchem2; Superficial test of PubChem interface. dfomp2-4; OMP2 cc-pVDZ energy for the NO molecule. dfmp2-freq2; DF-MP2 frequency by difference of energies for H2O. soscf-ref; Triple and Singlet Oxygen energy SOSCF, also tests non-symmetric density matrices. cc36; CC2(RHF)/cc-pVDZ energy of H2O. cbs-xtpl-gradient; Various gradients for a strained helium dimer and water molecule. dft-smoke; DFT Functional Smoke Test. dfmp2-2; Density fitted MP2 energy of H2, using density fitted reference and automatic looping over cc-pVDZ and cc-pVTZ basis sets. Results are tabulated using the built in table functions by using the default options and by specifiying the format. fci-coverage; 6-31G H2O Test for coverage. tdscf-5; td-camb3lyp with DiskDF and method/basis specification. scf-guess; Test initial SCF guesses on FH and FH+ in cc-pVTZ basis. opt1; SCF STO-3G geometry optimzation, with Z-matrix input. fsaptd-terms; F-SAPT0/jun-cc-pvdz procedure for methane dimer. cc4a; RHF-CCSD(T) cc-pVQZ frozen-core energy of the BH molecule, with Cartesian input. This version tests the FROZEN_DOCC option explicitly. sapt-exch-disp-inf; SAPT0 with S^inf exch-disp20. pywrap-opt-sowreap; Finite difference optimization, ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/autodoc_testsuite_corepsi4-1.html:5808,energy,energy,5808,psi4manual/1.4.0/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodoc_testsuite_corepsi4-1.html,4,['energy'],['energy']
Energy Efficiency,"_to_au(self); Returns unit conversion to [a0] for geometry. irrep_labels(self); Returns Irreducible Representation symmetry labels. is_variable(self, arg0); Checks if variable arg0 is in the structural variables list. label(self, atom); Gets the original label of the atom as given in the input file (C2, H4)(0-indexed without dummies). mass(self, atom); Returns mass of atom (0-indexed). mass_number(self, arg0); Mass number (A) of atom if known, else -1. molecular_charge(self); Gets the molecular charge. move_to_com(self); Moves molecule to center of mass. multiplicity(self); Gets the multiplicity (defined as 2Ms + 1). nallatom(self); Number of real and dummy atoms. name(self); Gets molecule name. natom(self); Number of real atoms. nfragments(self); Gets the number of fragments in the molecule. nuclear_dipole(*args, **kwargs); Overloaded function. nuclear_repulsion_energy(self, dipole_field, …); Computes nuclear repulsion energy. nuclear_repulsion_energy_deriv1(self, …); Returns first derivative of nuclear repulsion energy as a matrix (natom, 3). nuclear_repulsion_energy_deriv2(self); Returns second derivative of nuclear repulsion energy as a matrix (natom X 3, natom X 3). orientation_fixed(self); Get whether or not orientation is fixed. point_group(self); Returns the current point group object. print_bond_angles(self); Print the bond angle geometrical parameters. print_cluster(self); Prints the molecule in Cartesians in input units adding fragment separators. print_distances(self); Print the interatomic distance geometrical parameters. print_in_input_format(self); Prints the molecule as Cartesian or ZMatrix entries, just as inputted. print_out(self); Prints the molecule in Cartesians in input units to output file. print_out_in_angstrom(self); Prints the molecule in Cartesians in Angstroms to output file. print_out_in_bohr(self); Prints the molecule in Cartesians in Bohr to output file. print_out_of_planes(self); Print the out-of-plane angle geometrical parameters to o",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/api/psi4.core.molecule.html:5543,energy,energy,5543,psi4manual/1.3.2/api/psi4.core.molecule.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/api/psi4.core.molecule.html,3,['energy'],['energy']
Energy Efficiency,"_values(ref_energies['ONE-ELECTRON ENERGY'], energies['ONE-ELECTRON ENERGY'], 7,; label + '. 1-electron energy'); pass_2el = compare_values(ref_energies['TWO-ELECTRON ENERGY'], energies['TWO-ELECTRON ENERGY'], 7,; label + '. 2-electron energy'); pass_scf = compare_values(ref_energies['SCF TOTAL ENERGY'], energies['SCF TOTAL ENERGY'], 10,; label + '. SCF total energy'); pass_mp2 = compare_values(ref_energies['MP2 CORRELATION ENERGY'], energies['MP2 CORRELATION ENERGY'], 10,; label + '. MP2 correlation energy'). compare_integers(True, (pass_1el and pass_2el and pass_scf and pass_mp2), label). [docs]; def energies_from_fcidump(intdump) -> Dict[str, float]:; """"""From integrals dictionary generated from :py:func:`fcidump_from_file`,; compute energies. :returns: a dictionary with energies. - 'NUCLEAR REPULSION ENERGY'; - 'ONE-ELECTRON ENERGY'; - 'TWO-ELECTRON ENERGY'; - 'SCF TOTAL ENERGY'; - 'MP2 CORRELATION ENERGY'. """"""; energies = {}; energies['NUCLEAR REPULSION ENERGY'] = intdump['enuc']; epsilon = intdump['epsilon']; Hcore = intdump['hcore']; eri = intdump['eri']. # Compute SCF energy; energies['ONE-ELECTRON ENERGY'], energies['TWO-ELECTRON ENERGY'] = _scf_energy(Hcore, eri,; np.where(epsilon < 0)[0],; intdump['uhf']); # yapf: disable; energies['SCF TOTAL ENERGY'] = energies['ONE-ELECTRON ENERGY'] + energies['TWO-ELECTRON ENERGY'] + energies['NUCLEAR REPULSION ENERGY']; # yapf: enable. # Compute MP2 energy; energies['MP2 CORRELATION ENERGY'] = _mp2_energy(eri, epsilon, intdump['uhf']). return energies. def _scf_energy(Hcore, ERI, occ_sl, unrestricted):; scf_1el_e = np.einsum('ii->', Hcore[np.ix_(occ_sl, occ_sl)]); if not unrestricted:; scf_1el_e *= 2; coulomb = np.einsum('iijj->', ERI[np.ix_(occ_sl, occ_sl, occ_sl, occ_sl)]); exchange = np.einsum('ijij->', ERI[np.ix_(occ_sl, occ_sl, occ_sl, occ_sl)]); if unrestricted:; scf_2el_e = 0.5 * (coulomb - exchange); else:; scf_2el_e = 2.0 * coulomb - exchange. return scf_1el_e, scf_2el_e. def _mp2_energy(ERI, epsilon, unrestri",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/fcidump.html:14337,ENERGY,ENERGY,14337,psi4manual/1.8.x/_modules/psi4/driver/p4util/fcidump.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/fcidump.html,3,['ENERGY'],['ENERGY']
Energy Efficiency,"_variable('CURRENT ENERGY'). [docs]def gradient(name, **kwargs):; r""""""Function complementary to optimize(). Carries out one gradient pass,; deciding analytic or finite difference. """"""; lowername = name.lower(); kwargs = p4util.kwargs_lower(kwargs); dertype = 1. optstash = p4util.OptionsState(; ['SCF', 'E_CONVERGENCE'],; ['SCF', 'D_CONVERGENCE'],; ['E_CONVERGENCE']). # Order of precedence:; # 1. Default for wavefunction; # 2. Value obtained from kwargs, if user changed it; # 3. If user provides a custom 'func' use that. # Allow specification of methods to arbitrary order; lowername, level = parse_arbitrary_order(lowername); if level:; kwargs['level'] = level. # 1. set the default to that of the provided name; if lowername in procedures['gradient']:; dertype = 1; elif lowername in procedures['energy']:; dertype = 0; func = energy. # 2. Check if the user passes dertype into this function; if 'dertype' in kwargs:; opt_dertype = kwargs['dertype']. if der0th.match(str(opt_dertype)):; dertype = 0; func = energy; elif der1st.match(str(opt_dertype)):; dertype = 1; else:; raise ValidationError('Requested derivative level \'dertype\' %s not valid for helper function optimize.' % (opt_dertype)). # 3. if the user provides a custom function THAT takes precendence; if ('opt_func' in kwargs) or ('func' in kwargs):; if ('func' in kwargs):; kwargs['opt_func'] = kwargs['func']; del kwargs['func']; dertype = 0; func = kwargs['opt_func']. # Summary validation; if (dertype == 1) and (lowername in procedures['gradient']):; pass; elif (dertype == 0) and (func is energy) and (lowername in procedures['energy']):; pass; elif (dertype == 0) and not(func is energy):; pass; else:; raise ValidationError('Requested method \'name\' %s and derivative level \'dertype\' %s are not available.'; % (lowername, dertype)). # no analytic derivatives for scf_type cd; if psi4.get_option('SCF', 'SCF_TYPE') == 'CD':; if (dertype == 1):; raise ValidationError('No analytic derivatives for SCF_TYPE CD.'). # Make s",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/driver.html:32204,energy,energy,32204,psi4manual/4.0b5/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/driver.html,2,['energy'],['energy']
Energy Efficiency,"_variable(arg0); Returns copy of the requested (case-insensitive) Matrix QC variable. array_variables(); Returns dictionary of all Matrix QC variables. be_quiet(); Redirects output to /dev/null. benchmark_blas1(arg0, arg1); docstring. benchmark_blas2(arg0, arg1); docstring. benchmark_blas3(arg0, arg1, arg2); docstring. benchmark_disk(arg0, arg1); docstring. benchmark_integrals(arg0, arg1); docstring. benchmark_math(arg0); docstring. ccdensity(arg0); Runs the code to compute coupled cluster density matrices. ccenergy(arg0); Runs the coupled cluster energy code. cceom(arg0); Runs the equation of motion coupled cluster code, for excited states. cchbar(arg0); Runs the code to generate the similarity transformed Hamiltonian. cclambda(arg0); Runs the coupled cluster lambda equations code. ccresponse(arg0); Runs the coupled cluster response theory code. cctransort(arg0); Runs CCTRANSORT, which transforms and reorders integrals for use in the coupled cluster codes. cctriples(arg0); Runs the coupled cluster (T) energy code. clean(); Function to remove scratch files. clean_options(); Function to reset options to clean state. clean_variables(); Empties all PSI scalar and array variables that have been set internally. close_outfile(); Closes the output file. dcft(arg0); Runs the density cumulant functional theory code. del_array_variable(arg0); Removes the requested (case-insensitive) Matrix QC variable. del_scalar_variable(arg0); Removes the requested (case-insensitive) double QC variable. del_variable(key). detci(arg0); Runs the determinant-based configuration interaction code. dfmp2(arg0); Runs the DF-MP2 code. dfocc(arg0); Runs the density-fitted orbital optimized CC codes. dmrg(arg0); Runs the DMRG code. doublet(A, B, transA, transB); Returns the multiplication of two matrices A and B, with options to transpose each beforehand. fcidump_tei_helper(nirrep, restricted, …); Write integrals to file in FCIDUMP format. finalize(). flush_outfile(); Flushes the output file. fnocc(ar",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/psi4api-1.html:293649,energy,energy,293649,psi4manual/1.3.2/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/psi4api-1.html,2,['energy'],['energy']
Energy Efficiency,"_variable(self: psi4.core.Wavefunction, arg0: str) → int¶; Removes the requested (case-insensitive) Matrix QC variable. del_potential_variable(self: psi4.core.Wavefunction, arg0: str) → int¶; Removes the requested (case-insensitive) ExternalPotential QC variable. (This function is provisional and might be removed in the future.). del_scalar_variable(self: psi4.core.Wavefunction, arg0: str) → int¶; Removes the requested (case-insensitive) double QC variable. del_variable(key)¶; Removes scalar or array QCVariable key from cls if present. Return type; None. Parameters. cls (psi4.core.Wavefunction) – ; key (str) – . density_fitted(self: psi4.core.Wavefunction) → bool¶; Returns whether this wavefunction was obtained using density fitting or not. diis(self: psi4.core.HF) → bool¶; docstring. doccpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of doubly occupied orbitals per irrep. efzc(self: psi4.core.Wavefunction) → float¶; Returns the frozen-core energy. energy(self: psi4.core.Wavefunction) → float¶; Returns the Wavefunction’s energy. epsilon_a(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the Alpha Eigenvalues. epsilon_a_subset(self: psi4.core.Wavefunction, basis: str, subset: str) → psi4.core.Vector¶; Returns the requested Alpha orbital energies subset. Parameters. basis – {‘AO’, ‘SO’, ‘MO’}; MO or SO select for Pitzer-ordering the return vector in the full computational point group symmetry.; AO selects for Pitzer-ordering the return vector without point group symmetry.; subset – {‘ALL’, ‘ACTIVE’, ‘FROZEN’, ‘OCC’, ‘VIR’, ‘FROZEN_OCC’, ‘ACTIVE_OCC’, ‘ACTIVE_VIR’, ‘FROZEN_VIR’}; Which subspace of orbital energies should be returned?. Returns; A Pitzer-ordered vector of the orbitals. Return type; Vector. epsilon_b(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the Beta Eigenvalues. epsilon_b_subset(self: psi4.core.Wavefunction, basis: str, subset: str) → psi4.core.Vector¶; Returns the requested Beta orbital energies sub",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/api/psi4.core.cuhf.html:20180,energy,energy,20180,psi4manual/1.5.0/api/psi4.core.cuhf.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/api/psi4.core.cuhf.html,10,['energy'],['energy']
Energy Efficiency,"_wavefunction_del_variable(self: core.Wavefunction, key: str) -> None:; """"""Removes scalar or array :ref:`QCVariable <sec:appendices:qcvars>` *key* from *self* if present. Parameters; ----------; self; Wavefunction instance.; key; Case-insensitive key to instance's double or; :py:class:`~psi4.core.Matrix` storage maps. """"""; if self.has_scalar_variable(key):; self.del_scalar_variable(key); elif self.has_array_variable(key):; self.del_array_variable(key). def _core_variables(include_deprecated_keys: bool = False) -> Dict[str, Union[float, core.Matrix, np.ndarray]]:; """"""Return all scalar or array :ref:`QCVariables <sec:appendices:qcvars>`; from global memory. Parameters; ----------; include_deprecated_keys; Also return duplicate entries with keys that have been deprecated. Returns; -------; ~typing.Dict[str, ~typing.Union[float, ~numpy.ndarray, Matrix]; Map of all QCVariables that have been set. - Scalar variables are returned as floats.; - Array variables not naturally 2D (like multipoles or per-atom charges); are returned as :class:`~numpy.ndarray` of natural dimensionality.; - Other array variables are returned as :py:class:`~psi4.core.Matrix` and; may have an extra dimension with symmetry information. """"""; dicary = {**core.scalar_variables(), **{k: _qcvar_reshape_get(k, v) for k, v in core.array_variables().items()}}. if include_deprecated_keys:; for old_key, (current_key, version) in _qcvar_transitions.items():; if current_key in dicary:; dicary[old_key] = dicary[current_key]. return dicary. def _core_wavefunction_variables(self, include_deprecated_keys: bool = False) -> Dict[str, Union[float, core.Matrix, np.ndarray]]:; """"""Return all scalar or array :ref:`QCVariables <sec:appendices:qcvars>`; from *self*. Parameters; ----------; self; Wavefunction instance.; include_deprecated_keys; Also return duplicate entries with keys that have been deprecated. Returns; -------; ~typing.Dict[str, ~typing.Union[float, ~numpy.ndarray, Matrix]; Map of all QCVariables that have bee",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/p4util/python_helpers.html:42774,charge,charges,42774,psi4manual/1.9.x/_modules/psi4/driver/p4util/python_helpers.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/p4util/python_helpers.html,4,['charge'],['charges']
Energy Efficiency,"_wfn = core.dfmp2(ref_wfn); grad = dfmp2_wfn.compute_gradient(); dfmp2_wfn.set_gradient(grad). # Shove variables into global space; dfmp2_wfn.set_variable(""MP2 TOTAL GRADIENT"", grad) # P::e DFMP2; dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('MP2 TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('MP2 CORRELATION ENERGY')); for k, v in dfmp2_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); core.tstop(); return dfmp2_wfn. def run_dfmp2d_gradient(name, **kwargs):; """"""Encode MP2-D method."""""". dfmp2_wfn = run_dfmp2_gradient('mp2', **kwargs); wfn_grad = dfmp2_wfn.gradient().clone(). _, _disp_functor = build_functional_and_disp('MP2D', restricted=True); disp_grad = _disp_functor.compute_gradient(dfmp2_wfn.molecule(), dfmp2_wfn); wfn_grad.add(disp_grad); dfmp2_wfn.set_gradient(wfn_grad). dfmp2_wfn.set_variable('MP2D CORRELATION ENERGY', dfmp2_wfn.variable('MP2 CORRELATION ENERGY') + dfmp2_wfn.variable('DISPERSION CORRECTION ENERGY')); dfmp2_wfn.set_variable('MP2D TOTAL ENERGY', dfmp2_wfn.variable('MP2D CORRELATION ENERGY') + dfmp2_wfn.variable('HF TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('MP2D TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('MP2D CORRELATION ENERGY')). # Shove variables into global space; for k, v in dfmp2_wfn.variables().items():; core.set_variable(k, v). return dfmp2_wfn. def run_ccenergy(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a CCSD, CC2, and CC3 calculation. """"""; optstash = p4util.OptionsState(; ['TRANSQT2', 'WFN'],; ['CCSORT', 'WFN'],; ['CCENERGY', 'WFN']). if name == 'ccsd':; core.set_local_option('TRANSQT2', 'WFN', 'CCSD'); core.set_local_option('CCSORT', 'WFN', 'CCSD'); core.set_local_option('CCTRANSORT', 'WFN', 'CCSD'); core.set_local_option('CCENERGY', 'WFN', 'CCSD'); elif name == 'ccsd(t)':; core.set_local_option('TRANSQT2', 'WFN', 'CCSD_T'); core.set_local_option",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:89507,ENERGY,ENERGY,89507,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,3,['ENERGY'],['ENERGY']
Energy Efficiency,"_wfn = kwargs.pop('corl_wfn', '').lower(); if cbs_corl_wfn:; do_corl = True. # Establish method for reference energy; if do_corl and cbs_corl_wfn.startswith('c4-'):; default_scf = 'c4-hf'; else:; default_scf = 'hf'; cbs_scf_wfn = kwargs.pop('scf_wfn', default_scf).lower(). if do_scf:; if cbs_scf_wfn not in VARH.keys():; raise ValidationError(""""""Requested SCF method '%s' is not recognized. Add it to VARH in wrapper.py to proceed."""""" % (cbs_scf_wfn)). # ... resume correlation logic; if do_corl:; if cbs_corl_wfn not in VARH.keys():; raise ValidationError(""""""Requested CORL method '%s' is not recognized. Add it to VARH in wrapper.py to proceed."""""" % (cbs_corl_wfn)). cbs_corl_wfn_lesser = kwargs.get('corl_wfn_lesser', cbs_scf_wfn).lower(); if cbs_corl_wfn_lesser not in VARH.keys():; raise ValidationError(""""""Requested CORL method lesser '%s' is not recognized. Add it to VARH in wrapper.py to proceed."""""" % (cbs_delta_wfn_lesser)). # Establish method for delta correction energy; if 'delta_wfn' in kwargs:; do_delta = True; cbs_delta_wfn = kwargs['delta_wfn'].lower(); if cbs_delta_wfn not in VARH.keys():; raise ValidationError(""""""Requested DELTA method '%s' is not recognized. Add it to VARH in wrapper.py to proceed."""""" % (cbs_delta_wfn)). cbs_delta_wfn_lesser = kwargs.get('delta_wfn_lesser', cbs_corl_wfn).lower(); if cbs_delta_wfn_lesser not in VARH.keys():; raise ValidationError(""""""Requested DELTA method lesser '%s' is not recognized. Add it to VARH in wrapper.py to proceed."""""" % (cbs_delta_wfn_lesser)). # Establish method for second delta correction energy; if 'delta2_wfn' in kwargs:; do_delta2 = True; cbs_delta2_wfn = kwargs['delta2_wfn'].lower(); if cbs_delta2_wfn not in VARH.keys():; raise ValidationError(""""""Requested DELTA2 method '%s' is not recognized. Add it to VARH in wrapper.py to proceed."""""" % (cbs_delta2_wfn)). cbs_delta2_wfn_lesser = kwargs.get('delta2_wfn_lesser', cbs_delta_wfn).lower(); if cbs_delta2_wfn_lesser not in VARH.keys():; raise ValidationError(""""""Reque",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/driver_cbs.html:40065,energy,energy,40065,psi4manual/1.2.1/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/driver_cbs.html,1,['energy'],['energy']
Energy Efficiency,"_wfn'],; '/', GRAND_NEED[2]['d_basis'], '', GRAND_NEED[2]['d_energy'] - GRAND_NEED[3]['d_energy'], GRAND_NEED[2]['d_scheme'].__name__); if do_delta2:; tables += """""" %6s %20s %1s %-27s %2s %16.8f %-s\n"""""" % (GRAND_NEED[4]['d_stage'], GRAND_NEED[4]['d_wfn'] + ' - ' + GRAND_NEED[5]['d_wfn'],; '/', GRAND_NEED[4]['d_basis'], '', GRAND_NEED[4]['d_energy'] - GRAND_NEED[5]['d_energy'], GRAND_NEED[4]['d_scheme'].__name__); tables += """""" %6s %20s %1s %-27s %2s %16.8f %-s\n"""""" % ('total', 'CBS', '', '', '', finalenergy, ''); tables += table_delimit. #print tables; PsiMod.print_out(tables). # Restore molecule and options; #PsiMod.set_local_option('SCF', ""WFN"", user_wfn) # TODO refuses to set global option WFN - rejects SCF as option; PsiMod.set_global_option('BASIS', user_basis). PsiMod.set_global_option('WFN', user_wfn); if not b_user_wfn:; PsiMod.revoke_global_option_changed('WFN'). PsiMod.set_global_option('WRITER_FILE_LABEL', user_writer_file_label). PsiMod.set_variable('CBS REFERENCE ENERGY', GRAND_NEED[0]['d_energy']); PsiMod.set_variable('CBS CORRELATION ENERGY', finalenergy - GRAND_NEED[0]['d_energy']); PsiMod.set_variable('CBS TOTAL ENERGY', finalenergy); PsiMod.set_variable('CURRENT REFERENCE ENERGY', GRAND_NEED[0]['d_energy']); PsiMod.set_variable('CURRENT CORRELATION ENERGY', finalenergy - GRAND_NEED[0]['d_energy']); PsiMod.set_variable('CURRENT ENERGY', finalenergy); return finalenergy. # Transform and validate basis sets from 'cc-pV[Q5]Z' into [cc-pVQZ, cc-pV5Z] and [4, 5]; [docs]def validate_bracketed_basis(basisstring):; r""""""Function to transform and validate basis sets for cbs(). A basis set with no; paired square brackets is passed through with zeta level 0 (e.g., '6-31+G(d,p)'; is returned as [6-31+G(d,p)] and [0]). A basis set with square brackets is; checked for sensible sequence and Dunning-ness and returned as separate basis; sets (e.g., 'cc-pV[Q5]Z' is returned as [cc-pVQZ, cc-pV5Z] and [4, 5]). Note; that this function has no communication with the basi",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:79127,ENERGY,ENERGY,79127,psi4manual/4.0b4/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html,1,['ENERGY'],['ENERGY']
Energy Efficiency,"_wfn, monomerB_wfn); CTd = core.variable('SAPT CT ENERGY'); dimer_wfn.set_module(""sapt""). core.print_out('\n'); p4util.banner('Monomer Basis SAPT'); core.print_out('\n'); core.IO.change_file_namespace(psif.PSIF_SAPT_MONOMERA, 'monomerAm', 'dimer'); core.IO.change_file_namespace(psif.PSIF_SAPT_MONOMERB, 'monomerBm', 'dimer'); e_sapt = core.sapt(dimer_wfn, monomerAm_wfn, monomerBm_wfn); CTm = core.variable('SAPT CT ENERGY'); CT = CTd - CTm. units = (1000.0, constants.hartree2kcalmol, constants.hartree2kJmol); core.print_out('\n\n'); core.print_out(' SAPT Charge Transfer Analysis\n'); core.print_out(' ------------------------------------------------------------------------------------------------\n'); core.print_out(' SAPT Induction (Dimer Basis) %12.4lf [mEh] %12.4lf [kcal/mol] %12.4lf [kJ/mol]\n' %; tuple(CTd * u for u in units)); core.print_out(' SAPT Induction (Monomer Basis)%12.4lf [mEh] %12.4lf [kcal/mol] %12.4lf [kJ/mol]\n' %; tuple(CTm * u for u in units)); core.print_out(' SAPT Charge Transfer %12.4lf [mEh] %12.4lf [kcal/mol] %12.4lf [kJ/mol]\n\n' %; tuple(CT * u for u in units)); core.set_variable(""SAPT CT ENERGY"", CT) # P::e SAPT. optstash.restore(); return dimer_wfn. def run_fisapt(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; an F/ISAPT0 computation. """"""; optstash = p4util.OptionsState(['SCF_TYPE']). # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'). # Get the molecule of interest; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; sapt_dimer = kwargs.pop('molecule', core.get_active_molecule()); else:; core.print_out('Warning! FISAPT argument ""ref_wfn"" is only able to use molecule information.'); sapt_dimer = ref_wfn.molecule(); sapt_dimer.update_geometry() # make sure since mol from wfn, kwarg, or P::e. # Shifting to C1 so we need to copy the active molecule; if sapt_dimer.schoenflies_symbol() != 'c1':; core.print_out(' FISAPT does not make use of mole",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html:144887,Charge,Charge,144887,psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,7,['Charge'],['Charge']
Energy Efficiency,"_wfn=True); G, wfn = gradient(..., return_wfn=True) # used by optimize(); H, wfn = hessian(..., return_wfn=True) # used by frequency(). # print gradient array and its rms; wfn.gradient.print_out(); print wfn.gradient().rms(). # format output for other programs; molden(wfn, 'mycalc.molden'). # access array in another format; np.array(wfn.hessian()). Loops¶; Python provides many control structures, any of which can be used within PSI4; input files. For example, to loop over three basis sets, the following code can; be used:; basis_sets = [""cc-pVDZ"", ""cc-pVTZ"", ""cc-pVQZ""]; for basis_set in basis_sets:; set basis = $basis_set; energy('scf'). The declaration of basis_sets is completely standard Python, as is the next; line, which iterates over the list. However, because the Psithon preprocessor; wraps strings in quotes by default, we have to tell it that basis_set is a; Python variable, not a string, by prefixing it with a dollar sign.; The geometry specification supports delayed initialization of variable,; which permits potential energy scans. As an example, we can scan both the; angle and bond length in water:; molecule h2o{; O; H 1 R; H 1 R 2 A; }. Rvals = [0.9, 1.0, 1.1]; Avals = range(102, 106, 2). set basis cc-pvdz; set scf e_convergence=11; for R in Rvals:; h2o.R = R; for A in Avals:; h2o.A = A; energy('scf'). The declarations of Rvals and Avals are both completely standard Python syntax.; Having named our molecule h2o we can then set the values of R and A within; the loops. Note that we do not need the dollar sign to access the Python; variable in this example; that is required only when using Python variables; with the set keyword.; Cartesian geometries, because of details of the geometry update process,; need to be specified within the loop(s) along with their basis set when; geometry scans are performed. See scf4 for analogous Z-matrix; and Cartiesian scans. Tables of Results¶; The Psithon function psi4.driver.p4util.Table has been removed,; as the Python eco",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/psithoninput.html:11043,energy,energy,11043,psi4manual/1.7.x/psithoninput.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/psithoninput.html,3,['energy'],['energy']
Energy Efficiency,"_wfn=True); G, wfn = gradient(..., return_wfn=True) # used by optimize(); H, wfn = hessian(..., return_wfn=True) # used by frequency(). # print gradient array and its rms; wfn.gradient.print_out(); print wfn.gradient().rms(). # format output for other programs; molden(wfn, 'mycalc.molden'). # access array in another format; np.array(wfn.hessian()). Loops¶; Python provides many control structures, any of which can be used within PSI4; input files. For example, to loop over three basis sets, the following code can; be used:; basis_sets = [""cc-pVDZ"", ""cc-pVTZ"", ""cc-pVQZ""]; for basis_set in basis_sets:; set basis = $basis_set; energy('scf'). The declaration of basis_sets is completely standard Python, as is the next; line, which iterates over the list. However, because the Psithon preprocessor; wraps strings in quotes by default, we have to tell it that basis_set is a; Python variable, not a string, by prefixing it with a dollar sign.; The geometry specification supports delayed initialization of variable,; which permits potential energy scans. As an example, we can scan both the; angle and bond length in water:; molecule h2o{; O; H 1 R; H 1 R 2 A; }. Rvals = [0.9, 1.0, 1.1]; Avals = range(102, 106, 2). set basis cc-pvdz; set scf e_convergence=11; for R in Rvals:; h2o.R = R; for A in Avals:; h2o.A = A; energy('scf'). The declarations of Rvals and Avals are both completely standard Python syntax.; Having named our molecule h2o we can then set the values of R and A within; the loops. Note that we do not need the dollar sign to access the Python; variable in this example; that is required only when using Python variables; with the set keyword.; Cartesian geometries, because of details of the geometry update process,; need to be specified within the loop(s) along with their basis set when; geometry scans are performed. See scf4 for analogous Z-matrix; and Cartiesian scans. Tables of Results¶; The results of computations can be compactly tabulated with the Table() Psithon; f",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/psithoninput-1.html:11043,energy,energy,11043,psi4manual/1.4.0/psithoninput-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/psithoninput-1.html,5,['energy'],['energy']
Energy Efficiency,"_wfn=True); G, wfn = gradient(..., return_wfn=True) # used by optimize(); H, wfn = hessian(..., return_wfn=True) # used by frequency(). # print gradient array and its rms; wfn.gradient.print_out(); print wfn.gradient().rms(). # format output for other programs; molden(wfn, 'mycalc.molden'). # access array in another format; np.array(wfn.hessian()). Loops¶; Python provides many control structures, any of which can be used within Psi4; input files. For example, to loop over three basis sets, the following code can; be used:; basis_sets = [""cc-pVDZ"", ""cc-pVTZ"", ""cc-pVQZ""]; for basis_set in basis_sets:; set basis = $basis_set; energy('scf'). The declaration of basis_sets is completely standard Python, as is the next; line, which iterates over the list. However, because the Psithon preprocessor; wraps strings in quotes by default, we have to tell it that basis_set is a; Python variable, not a string, by prefixing it with a dollar sign.; The geometry specification supports delayed initialization of variable,; which permits potential energy scans. As an example, we can scan both the; angle and bond length in water:; molecule h2o{; O; H 1 R; H 1 R 2 A; }. Rvals = [0.9, 1.0, 1.1]; Avals = range(102, 106, 2). set basis cc-pvdz; set scf e_convergence=11; for R in Rvals:; h2o.R = R; for A in Avals:; h2o.A = A; energy('scf'). The declarations of Rvals and Avals are both completely standard Python syntax.; Having named our molecule h2o we can then set the values of R and A within; the loops. Note that we do not need the dollar sign to access the Python; variable in this example; that is required only when using Python variables; with the set keyword.; Cartesian geometries, because of details of the geometry update process,; need to be specified within the loop(s) along with their basis set when; geometry scans are performed. See scf4 for analogous Z-matrix; and Cartiesian scans. Tables of Results¶; The results of computations can be compactly tabulated with the Table() Psithon; f",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/psithoninput-1.html:11611,energy,energy,11611,psi4manual/1.0.0/psithoninput-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/psithoninput-1.html,2,['energy'],['energy']
Energy Efficiency,"_xtpl_Karton_2: datatype is not recognized '{type(valueLO)}'.""). [docs]def scf_xtpl_helgaker_3(functionname: str, zLO: int, valueLO: Extrapolatable, zMD: int, valueMD: Extrapolatable, zHI: int, valueHI: Extrapolatable, verbose: int = 1, alpha: Optional[float] = None) -> Extrapolatable:; r""""""Extrapolation scheme for reference energies with three adjacent zeta-level bases.; Used by :py:func:`~psi4.driver.cbs`. Parameters; ----------; functionname; Name of the CBS component (e.g., 'HF') used in summary printing.; zLO; Zeta number of the smaller basis set in 3-point extrapolation.; valueLO; Energy, gradient, or Hessian value at the smaller basis set in 3-point; extrapolation.; zMD; Zeta number of the medium basis set in 3-point extrapolation.; Must be `zLO + 1`.; valueMD; Energy, gradient, or Hessian value at the medium basis set in 3-point; extrapolation.; zHI; Zeta number of the larger basis set in 3-point extrapolation.; Must be `zLO + 2`.; valueHI; Energy, gradient, or Hessian value at the larger basis set in 3-point; extrapolation.; verbose; Controls volume of printing.; alpha; Not used. Returns; -------; float or ~numpy.ndarray; Eponymous function applied to input zetas and values; type from `valueLO`. Notes; -----; The extrapolation is calculated according to [4]_:; :math:`E_{total}^X = E_{total}^{\infty} + \beta e^{-\alpha X}, \alpha = 3.0`. References; ----------. .. [4] Halkier, Helgaker, Jorgensen, Klopper, & Olsen, Chem. Phys. Lett. 302 (1999) 437-446,; DOI: 10.1016/S0009-2614(99)00179-7. Examples; --------; >>> # [1] Hartree-Fock extrapolation; >>> psi4.energy('cbs', scf_wfn='hf', scf_basis='cc-pV[DTQ]Z', scf_scheme='scf_xtpl_helgaker_3'). """""". if (type(valueLO) != type(valueMD)) or (type(valueMD) != type(valueHI)):; raise ValidationError(; f""scf_xtpl_helgaker_3: Inputs must be of the same datatype! ({type(valueLO)}, {type(valueMD)}, {type(valueHI)})""; ). if isinstance(valueLO, float):. ratio = (valueHI - valueMD) / (valueMD - valueLO); alpha = -1 * math.lo",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver_cbs_helper.html:14211,Energy,Energy,14211,psi4manual/1.7.x/_modules/psi4/driver/driver_cbs_helper.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver_cbs_helper.html,1,['Energy'],['Energy']
Energy Efficiency,"_xtpl_helgaker_2`` || etc. Indicates the basis set extrapolation scheme to be applied to the delta correction; to the correlation energy. :type delta2_scheme: function; :param delta2_scheme: |dl| ``highest_1`` |dr| || ``corl_xtpl_helgaker_2`` || etc. Indicates the basis set extrapolation scheme to be applied to the second delta correction; to the correlation energy. :type delta3_scheme: function; :param delta3_scheme: |dl| ``highest_1`` |dr| || ``corl_xtpl_helgaker_2`` || etc. Indicates the basis set extrapolation scheme to be applied to the third delta correction; to the correlation energy. :type delta4_scheme: function; :param delta4_scheme: |dl| ``highest_1`` |dr| || ``corl_xtpl_helgaker_2`` || etc. Indicates the basis set extrapolation scheme to be applied to the fourth delta correction; to the correlation energy. :type delta5_scheme: function; :param delta5_scheme: |dl| ``highest_1`` |dr| || ``corl_xtpl_helgaker_2`` || etc. Indicates the basis set extrapolation scheme to be applied to the fifth delta correction; to the correlation energy. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :examples:. >>> # [1] replicates with cbs() the simple model chemistry scf/cc-pVDZ: set basis cc-pVDZ energy('scf'); >>> cbs('scf', scf_basis='cc-pVDZ'). >>> # [2] replicates with cbs() the simple model chemistry mp2/jun-cc-pVDZ: set basis jun-cc-pVDZ energy('mp2'); >>> cbs('mp2', corl_basis='jun-cc-pVDZ'). >>> # [3] DTQ-zeta extrapolated scf reference energy; >>> cbs('scf', scf_basis='cc-pV[DTQ]Z', scf_scheme=scf_xtpl_helgaker_3). >>> # [4] DT-zeta extrapolated mp2 correlation energy atop a T-zeta reference; >>> cbs('mp2', corl_basis='cc-pv[dt]z', corl_scheme=corl_xtpl_helgaker_2). >>> # [5] a DT-zeta extrapolated coupled-cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference; >>> cbs('mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme=corl_xtpl_helgaker_2,",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:61666,energy,energy,61666,psi4manual/4.0b5/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html,2,['energy'],['energy']
Energy Efficiency,"_xtpl_helgaker_3(). scf_xtpl_helgaker_2(); scf_xtpl_truhlar_2(); scf_xtpl_karton_2(). corl_alpha (float) – \(\Rightarrow\) 3.00 \(\Leftarrow\); Overrides the default alpha parameter used in the listed corl_xtpl_helgaker_2() correlation; extrapolation to the corl stage. The supplied alpha does not impact delta or any further stages. corl_xtpl_helgaker_2(). delta_alpha (float) – \(\Rightarrow\) 3.00 \(\Leftarrow\); Overrides the default alpha parameter used in the listed; corl_xtpl_helgaker_2() correlation extrapolation for the delta correction. Useful when; delta correction is performed using smaller basis sets for which a different alpha might; be more appropriate. corl_xtpl_helgaker_2(). Combined interface. Parameters; cbs_metadata (List[Dict]) – \(\Rightarrow\) autogenerated from above keywords \(\Leftarrow\) || [{""wfn"": ""hf"", ""basis"": ""cc-pv[TQ5]z""}] || etc.; This is the interface to which all of the above calls are internally translated. The first item in; the array is always defining the SCF contribution to the total energy. The required items in the; dictionary are:. `wfn`: typically `HF`, which is subsumed in correlated methods anyway.; `basis`: basis set, can be in a bracketed form (eg. `cc-pv[tq]z`). Other supported arguments for the first dictionary are:. `scheme`: scf extrapolation scheme function, by default it is worked out from the number of basis sets (1 - 3) supplied as `basis`.; `alpha`: alpha for the above scheme, if the default is to be overriden; `options`: if special options are required for a step, they should be entered as a dict here. If some options should be used for both parts of the stage, they should be entered in both `options` and `options_lo`. This is helpful for calculating all electron corrections in otherwise frozen core calculations, or relativistic (DKH) Hamiltionian corrections for otherwise nonrelativistic.; `options_lo`: special options for lower method in a given stage. This is useful to calculate a direct stage in an otherwi",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/api/psi4.driver.cbs-1.html:10658,energy,energy,10658,psi4manual/1.4.0/api/psi4.driver.cbs-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/api/psi4.driver.cbs-1.html,15,['energy'],['energy']
Energy Efficiency,"_{LS} \\; h_{SL} & h_{SS}; \end{pmatrix}; U; =; \begin{pmatrix}; h^{\rm FW}_{++} & 0 \\; 0 & h^{\rm FW}_{--}; \end{pmatrix}\end{split}\]; The transformation ( \(U\) ) is obtained from the solutions of the Dirac equation in kinetically balanced basis [Kutzelnigg:1984] treatment.; In the X2C treatment, the positive-energy block of the Hamiltonian ( \(h^{FW}_{\rm ++}\) ); is given by the sum; of a transformed kinetic (\(T_{\rm X2C}\)) and potential energy ( \(V_{\rm X2C}\) ) contribution.; Relativistic kinetic energy ( \(T_{\rm X2C}\) ) and nuclear-electron interaction potential ( \(V_{\rm X2C}\) ) is given in terms of non-relativisitc kinetic (\(T=\hat{p}^2/2\)) energy and nuclear-electron interaction potential (\(V\)), coupling matrix ( \(X\)) and renormalization matrix ( \(R\)). \[T_{\rm X2C} = R^{\dagger} (TX + {X}^{\dagger}T - {X}^{\dagger}TX ) R\]. \[V_{\rm X2C} = R^{\dagger}(V + \frac{1}{4c^2} X^{\dagger}W^{\text{SF}}X) R\]; The coupling matrix ( \({X} = C^{S} (C^{L})^{-1}\) ) is obtained from the large (\(C^{\rm L}\)) and small (\(C^{\rm S}\)) components of the \(N\) positive energy solutions of the Dirac equation.; The renormalization matrix; \({R}=S^{-1/2}(S^{-1/2}\tilde{S}S^{-1/2})^{-1/2}S^{1/2}\),; depends on the modified overlap matrix; \(\tilde{S}=S+\frac{1}{2c^2}X^{\dagger}TX\). The integrals \(W^{\rm SF}_{\mu\nu} = \langle {\chi_\mu} | \hat{p}\cdot (\hat{V}\hat{p}) |{\chi_\nu}\rangle\) can be easily computed as derivatives of the nuclear-electron attraction integrals with respect to nuclear coordinates.; Existing nonrelativistic electronic structure code can be extended to include scalar relativistic effects; treated with the X2C method by replacing nonrelativistic kinetic and potential energy with the corresponding; X2C operators \(T_{X2C}\) and \(V_{X2C}\). It is important to note that fully uncontracted basis in needed for the construction of X2C Hamiltonian as Foldy-Wouthuysen (FW [FW:1950]) transformation is obtained in kinetically balance basis. K",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/relativistic-1.html:4309,energy,energy,4309,psi4manual/1.1.0/relativistic-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/relativistic-1.html,15,['energy'],['energy']
Energy Efficiency,"_{NN} + E_{1e^-} + E_{2e^-} + E_{xc} + E_{\text{-D}} + E_{\text{DH}} \\; & = E_{\text{FCTL}} + E_{\text{-D}} + E_{\text{DH}} \\; & = E_{\text{SCF}} + E_{\text{DH}}; \end{align*}Unless the method is a DFT double-hybrid, this quantity is equal to; SCF TOTAL ENERGY. If the method is neither a; double-hybrid, nor dispersion corrected, this quantity is equal to; DFT FUNCTIONAL TOTAL ENERGY. DFT TOTAL GRADIENT¶; The total electronic gradient [E_h/a0] of the requested DFT method, ({nat}, 3). DFT DIPOLE GRADIENT¶; The derivative of the requested DFT method dipole [E_h a0/u] = [(e a0/a0)^2/u] with respect to nuclear perturbations; as a degree-of-freedom by dipole component array, (3 * {nat}, 3). DFT TOTAL HESSIAN¶; The total electronic second derivative [E_h/a0/a0] for the requested DFT method, (3 * {nat}, 3 * {nat}). DFT XC ENERGY¶; The functional energy contribution [E_h] to the total SCF energy (DFT only).; Quantity \(E_{xc}\) in Eqs. (4) and (1). DFT VV10 ENERGY¶; The VV10 nonlocal contribution [E_h] to the total SCF energy (DFT only).; Included in DFT FUNCTIONAL TOTAL ENERGY. DISPERSION CORRECTION ENERGY¶. fctl DISPERSION CORRECTION ENERGY¶; The dispersion correction [E_h] appended to an underlying functional; when a DFT-D method is requested. Quantity \(E_{\text{-D}}\); in Eqs. (4) and (1).; When dispersion parameters are untweaked for a functional and dispersion; level, labeled QCVariable also defined. DOUBLE-HYBRID CORRECTION ENERGY¶; The scaled MP2 correlation energy correction [E_h] appended to an; underlying functional when a DH-DFT method is requested.; Quantity \(E_{\text{DH}}\) in Eq. (1). DMA DISTRIBUTED MULTIPOLES¶; Distributed multipoles in units given by GDMA_MULTIPOLE_UNITS; with the row index corresponding to the site and the column index; referencing the multipole component. Both indices are zero based,; and the Qlm components of the multipoles are ordered as Q00, Q10,; Q11c, Q11s, Q20, Q21c, Q21s, Q22c, Q22s, etc. DMA TOTAL MULTIPOLES¶; Distributed multi",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/glossary_psivariables.html:29531,energy,energy,29531,psi4manual/1.7.x/glossary_psivariables.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/glossary_psivariables.html,4,['energy'],['energy']
Energy Efficiency,"_{\text{corl},\; \textbf{delta3_wfn}}^{\textbf{delta3_basis}}\right) - \mathcal{F}_{\textbf{delta3_scheme}} \left(E_{\text{corl},\; \textbf{delta3_wfn_lesser}}^{\textbf{delta3_basis}}\right)\]. \[\delta_{\textbf{delta4_wfn_lesser}}^{\textbf{delta4_wfn}} \; = \mathcal{F}_{\textbf{delta4_scheme}} \left(E_{\text{corl},\; \textbf{delta4_wfn}}^{\textbf{delta4_basis}}\right) - \mathcal{F}_{\textbf{delta4_scheme}} \left(E_{\text{corl},\; \textbf{delta4_wfn_lesser}}^{\textbf{delta4_basis}}\right)\]. \[\delta_{\textbf{delta5_wfn_lesser}}^{\textbf{delta5_wfn}} \; = \mathcal{F}_{\textbf{delta5_scheme}} \left(E_{\text{corl},\; \textbf{delta5_wfn}}^{\textbf{delta5_basis}}\right) - \mathcal{F}_{\textbf{delta5_scheme}} \left(E_{\text{corl},\; \textbf{delta5_wfn_lesser}}^{\textbf{delta5_basis}}\right)\]; A translation of this ungainly equation to example [5] below is as; follows. In words, this is a double- and triple-zeta 2-point; Helgaker-extrapolated CCSD(T) coupled-cluster correlation correction; appended to a triple- and quadruple-zeta 2-point; Helgaker-extrapolated MP2 correlation energy appended to a SCF/aug-cc-pVQZ; reference energy. \[E_{\text{total}}^{\text{CBS}} = \mathcal{F}_{\text{highest_1}} \left(E_{\text{total},\; \text{SCF}}^{\text{aug-cc-pVQZ}}\right) \; + \mathcal{F}_{\text{corl_xtpl_helgaker_2}} \left(E_{\text{corl},\; \text{MP2}}^{\text{aug-cc-pV[TQ]Z}}\right) \; + \delta_{\text{MP2}}^{\text{CCSD(T)}}\]. \[\delta_{\text{MP2}}^{\text{CCSD(T)}} \; = \mathcal{F}_{\text{corl_xtpl_helgaker_2}} \left(E_{\text{corl},\; \text{CCSD(T)}}^{\text{aug-cc-pV[DT]Z}}\right) - \mathcal{F}_{\text{corl_xtpl_helgaker_2}} \left(E_{\text{corl},\; \text{MP2}}^{\text{aug-cc-pV[DT]Z}}\right)\]. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Psithon Functions: Invoking a Calculation; Complete Basis Set; <no title>. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/cbs_eqn-1.html:2610,energy,energy,2610,psi4manual/1.4.0/cbs_eqn-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/cbs_eqn-1.html,4,['energy'],['energy']
Energy Efficiency,"_{\text{corl},\; \textbf{delta3_wfn}}^{\textbf{delta3_basis}}\right) - \mathcal{F}_{\textbf{delta3_scheme}} \left(E_{\text{corl},\; \textbf{delta3_wfn_lesser}}^{\textbf{delta3_basis}}\right)\]. \[\delta_{\textbf{delta4_wfn_lesser}}^{\textbf{delta4_wfn}} \; = \mathcal{F}_{\textbf{delta4_scheme}} \left(E_{\text{corl},\; \textbf{delta4_wfn}}^{\textbf{delta4_basis}}\right) - \mathcal{F}_{\textbf{delta4_scheme}} \left(E_{\text{corl},\; \textbf{delta4_wfn_lesser}}^{\textbf{delta4_basis}}\right)\]. \[\delta_{\textbf{delta5_wfn_lesser}}^{\textbf{delta5_wfn}} \; = \mathcal{F}_{\textbf{delta5_scheme}} \left(E_{\text{corl},\; \textbf{delta5_wfn}}^{\textbf{delta5_basis}}\right) - \mathcal{F}_{\textbf{delta5_scheme}} \left(E_{\text{corl},\; \textbf{delta5_wfn_lesser}}^{\textbf{delta5_basis}}\right)\]; A translation of this ungainly equation to example [5] below is as; follows. In words, this is a double- and triple-zeta 2-point; Helgaker-extrapolated CCSD(T) coupled-cluster correlation correction; appended to a triple- and quadruple-zeta 2-point; Helgaker-extrapolated MP2 correlation energy appended to a SCF/aug-cc-pVQZ; reference energy. \[E_{\text{total}}^{\text{CBS}} = \mathcal{F}_{\text{highest_1}} \left(E_{\text{total},\; \text{SCF}}^{\text{aug-cc-pVQZ}}\right) \; + \mathcal{F}_{\text{corl_xtpl_helgaker_2}} \left(E_{\text{corl},\; \text{MP2}}^{\text{aug-cc-pV[TQ]Z}}\right) \; + \delta_{\text{MP2}}^{\text{CCSD(T)}}\]. \[\delta_{\text{MP2}}^{\text{CCSD(T)}} \; = \mathcal{F}_{\text{corl_xtpl_helgaker_2}} \left(E_{\text{corl},\; \text{CCSD(T)}}^{\text{aug-cc-pV[DT]Z}}\right) - \mathcal{F}_{\text{corl_xtpl_helgaker_2}} \left(E_{\text{corl},\; \text{MP2}}^{\text{aug-cc-pV[DT]Z}}\right)\]. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.5;  · . PSI4. Psithon Functions: Invoking a Calculation; Complete Basis Set; <no title>. © Copyright 2021, The Psi4 Project.; Last updated on Sunday, 28 November 2021 02:41AM.; Created using Sphinx 4.3.1.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/cbs_eqn-1.html:2610,energy,energy,2610,psi4manual/1.5.0/cbs_eqn-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/cbs_eqn-1.html,4,['energy'],['energy']
Energy Efficiency,"_{exch-disp}^{(20)} + \delta_{HF}^{(2)}\]; In this notation, \(E^{(vw)}\) defines the order in \(V\) and in \(W_A+W_B\); the; subscript, \(resp\), indicates that orbital relaxation effects are included. (2)¶\[E_{SAPT2} = E_{SAPT0} + E_{elst,resp}^{(12)} + E_{exch}^{(11)} +; E_{exch}^{(12)} + \; ^{t}\!E_{ind}^{(22)} + \; ^{t}\!E_{exch-ind}^{(22)}\]. (3)¶\[E_{SAPT2+} = E_{SAPT2} + E_{disp}^{(21)} + E_{disp}^{(22)}\]. (4)¶\[E_{SAPT2+(3)} = E_{SAPT2+} + E_{elst,resp}^{(13)} + E_{disp}^{(30)}\]. (5)¶\[E_{SAPT2+3} = E_{SAPT2+(3)}; + E_{exch-ind}^{(30)} + E_{ind,resp}^{(30)}; + E_{exch-disp}^{(30)} + E_{ind-disp}^{(30)} + E_{exch-ind-disp}^{(30)}; - \delta_{HF}^{(2)} + \delta_{HF}^{(3)}\]; For SAPT(DFT), the SAPT expansion is truncated at the same level of SAPT0, but the zeroth-order Hamiltonian is chosen to be \(K_A+K_B\), the monomer Kohn-Sham operators, instead of the Fock operators. The dispersion term needs to be computed with orbital relaxation for the result to be reasonable, and this is possible by computing dispersion energy through coupled frequency-dependent density susceptibility (FDDS). The exchange-dispersion term is estimated by scaling the uncoupled exchange-dispersion energy. (6)¶\[E_{SAPT(DFT)} = E_{elst}^{(10)} + E_{exch}^{(10)} + E_{ind,resp}^{(20)} +; E_{exch-ind,resp}^{(20)} + E_{disp,resp}^{(20)} + E_{exch-disp,resp}^{(20)}(est.) + \delta_{HF}^{(2)}\]. \[E_{disp,resp}^{(20)} = -\frac{1}{2\pi}\int_0^\infty d\omega \int d\mathbf{r}_A d\mathbf{r}'_A d\mathbf{r}_B d\mathbf{r}'_B \frac{1}{\left|\mathbf{r}_A-\mathbf{r}_B\right|}\frac{1}{\left|\mathbf{r}'_A-\mathbf{r}'_B\right|}\chi^A_{coup}\left(\mathbf{r}_A,\mathbf{r}'_A|i\omega\right)\chi^B_{coup}\left(\mathbf{r}_B,\mathbf{r}'_B|i\omega\right)\]. \[\chi_{coup}\left(\mathbf{r},\mathbf{r}'|\omega\right) = \chi_0\left(\mathbf{r},\mathbf{r}'|\omega\right) + \int d\omega d\mathbf{r}_1 d\mathbf{r}_2 \chi_0\left(\mathbf{r},\mathbf{r}_1|\omega\right)\left[\frac{1}{r_{12}} + f_{xc}\left(\mathbf{r}_1,\mathbf{r}_2,\",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/sapt-1.html:4100,energy,energy,4100,psi4manual/1.4.0/sapt-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/sapt-1.html,9,['energy'],['energy']
Energy Efficiency,"_{ij}/(s_{r,n} R_0^{ij}))^{- \alpha_n}}\]; A modified damping scheme for DFT-D3 using the rational damping form of; Becke and Johnson was introduced in [Grimme:2011:1456]. The parameters; fit for individual functionals are now \(s_6\), \(s_8\),; \(a_1\), and \(a_2\). \[E_{disp}^{\text{D3BJ}}=-\sum_{n=6,8} s_n \sum_{i,j>i}^{N_{at}}; \frac{C_n^{ij}}{(R_{ij})^n + (f_{damp})^n}\]. \[f_{damp} = a_1 \sqrt{\frac{C_8^{ij}}{C_6^{ij}}} + a_2\]; All parameters characterizing the dispersion correction are taken from; Grimme’s website; or else from the literature. Running DFTD3¶; A number of a posteriori dispersion corrections are available in; PSI4. While some are computed within PSI4‘s codebase (-D1, -D2,; -CHG, -DAS2009, -DAS2010), the -D3 correction and its variants are; available only through the DFTD3 program. Once installed, the; dftd3/PSI4 interface is transparent, and all corrections are; interfaced exactly alike.; Dispersion corrections are built into DFT functionals, so appending an a; posteriori correction to a computation is as simple as; energy('b2plyp-d') vs. energy('b2plyp'). For example, the; following input file computes (with much redundant work) for water a; B3LYP, a B3LYP-D2, and a B3LYP-D3 (zero-damping) energy.; molecule h2o {; O; H 1 1.0; H 1 1.0 2 104.5; }; set {; basis cc-pVDZ; }; energy('b3lyp'); energy('b3lyp-d'); energy('b3lyp-d3'). Consult the table -D Functionals to see for each; functional what corrections are available and what default parameters; define them. The dispersion correction is available after a calculation in; the PSI variable DISPERSION CORRECTION ENERGY.; By default, the output from the dftd3; program is suppressed; to see it in the output file, set print > 2. Variants of dispersion corrections¶. Extension 1; Variant; Computing Program (engine); DFT_DISPERSION_PARAMETERS 11. -D; alias to -D2. -D1; -D1 2; PSI4‘s libdisp; [\(s_6\)]. -D2; -D2 3; PSI4‘s libdisp OR dftd3; [\(s_6\), \(\alpha_6\), \(s_{r,6}\)]. -D3; alias to -D3ZERO. -D3ZE",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/dftd3-1.html:4865,energy,energy,4865,psi4manual/1.4.0/dftd3-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/dftd3-1.html,2,['energy'],['energy']
Energy Efficiency,"_{ij}/(s_{r,n} R_0^{ij}))^{- \alpha_n}}\]; A modified damping scheme for DFT-D3 using the rational damping form of; Becke and Johnson was introduced in [Grimme:2011:1456]. The parameters; fit for individual functionals are now \(s_6\), \(s_8\),; \(a_1\), and \(a_2\). \[E_{disp}^{\text{D3BJ}}=-\sum_{n=6,8} s_n \sum_{i,j>i}^{N_{at}}; \frac{C_n^{ij}}{(R_{ij})^n + (f_{damp})^n}\]. \[f_{damp} = a_1 \sqrt{\frac{C_8^{ij}}{C_6^{ij}}} + a_2\]; All parameters characterizing the dispersion correction are taken from; Grimme’s website; or else from the literature. Running DFTD3¶; A number of a posteriori dispersion corrections are available in; PSI4. While some are computed within PSI4’s codebase (-D1, -D2,; -CHG, -DAS2009, -DAS2010), the -D3 correction and its variants are; available only through the DFTD3 program. Once installed, the; dftd3/PSI4 interface is transparent, and all corrections are; interfaced exactly alike.; Dispersion corrections are built into DFT functionals, so appending an a; posteriori correction to a computation is as simple as; energy('b2plyp-d') vs. energy('b2plyp'). For example, the; following input file computes (with much redundant work) for water a; B3LYP, a B3LYP-D2, and a B3LYP-D3 (zero-damping) energy.; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11molecule h2o {; O; H 1 1.0; H 1 1.0 2 104.5; }; set {; basis cc-pVDZ; }; energy('b3lyp'); energy('b3lyp-d'); energy('b3lyp-d3'). Consult the table -D Functionals to see for each; functional what corrections are available and what default parameters; define them. The dispersion correction is available after a calculation in; the PSI variable DISPERSION CORRECTION ENERGY.; By default, the output from the dftd3; program is suppressed; to see it in the output file, set print > 2. Variants of dispersion corrections¶. Extension [1]; Variant; Computing Program (engine); DFT_DISPERSION_PARAMETERS [11]. -D; -D1; -D2; -D3; -D3ZERO; -D3BJ; -D3(BJ); -D3M; -D3MZERO; -D3MBJ; -D3M(BJ); -NL; -CHG; -DAS2009; -DAS2010; alias to -D2; ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/dftd3-1.html:4830,energy,energy,4830,psi4manual/1.3.2/dftd3-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/dftd3-1.html,2,['energy'],['energy']
Energy Efficiency,"` only displays dummy atoms. """"""; text = """"; if self.natom():; if self.pg:; text += """""" Molecular point group: %s\n"""""" % (self.pg.symbol()); # if self.full_pg: TODO symmetry; # text += """""" Full point group: %s\n\n"""""" % (self.full_point_group()) TODO symmetry; text += """""" Geometry (in %s), charge = %d, multiplicity = %d:\n\n"""""" % \; (self.units(), self.molecular_charge(), self.multiplicity()); text += """""" Center X Y Z \n""""""; text += """""" ------------ ----------------- ----------------- -----------------\n"""""". for i in range(self.nallatom()):; geom = self.full_atoms[i].compute(); text += """""" %8s%4s """""" % (self.fsymbol(i), """" if self.fZ(i) else ""(Gh)""); for j in range(3):; text += """""" %17.12f"""""" % (geom[j]); text += ""\n""; text += ""\n""; else:; text += "" No atoms in this molecule.\n""; print text; # TODO outfile. [docs] def print_in_input_format(self):; """"""Print the molecule in the same format that the user provided.; """"""; text = """"; if self.nallatom():; text += "" Geometry (in %s), charge = %d, multiplicity = %d:\n\n"" % \; (""Angstrom"" if self.units() == 'Angstrom' else ""Bohr"",; self.molecular_charge(), self.multiplicity()); for i in range(self.nallatom()):; if self.fZ(i) or self.fsymbol(i) == ""X"":; text += "" %-8s"" % (self.fsymbol(i)); else:; text += "" %-8s"" % (""Gh("" + self.fsymbol(i) + "")""); text += self.full_atoms[i].print_in_input_format(); text += ""\n""; if len(self.geometry_variables):; for vb, val in self.geometry_variables.items():; text += """""" %-10s=%16.10f\n"""""" % (vb, val); text += ""\n"". print text; # TODO outfile. [docs] def everything(self):; """"""Quick print of class data""""""; text = """""" ==> qcdb Molecule %s <==\n\n"""""" % (self.name()); text += """""" Natom %d\t\tNallatom %d\n"""""" % (self.natom(), self.nallatom()); text += """""" charge %d\t\tspecified? %s\n"""""" % (self.molecular_charge(), self.charge_specified()); text += """""" multiplicity %d\t\tspecified? %s\n"""""" % (self.multiplicity(), self.multiplicity_specified()); text += """""" units %s\tconversion %f\n"""""" % (self.units(),",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html:28903,charge,charge,28903,psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html,2,['charge'],['charge']
Energy Efficiency,"` |dr| || ``'ccsd(t)'`` || etc. Indicates the inferior energy method for which a fifth delta correction; to the correlation energy is to be obtained. * Basis Sets; Currently, the basis set set through ``set`` commands have no influence; on a cbs calculation. :type scf_basis: :ref:`basis string <apdx:basisElement>`; :param scf_basis: |dl| ``corl_basis`` |dr| || ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the reference energy.; If any correlation method is specified, ``scf_basis`` can default; to ``corl_basis``. :type corl_basis: :ref:`basis string <apdx:basisElement>`; :param corl_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the correlation energy. :type delta_basis: :ref:`basis string <apdx:basisElement>`; :param delta_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the delta correction; to the correlation energy. :type delta2_basis: :ref:`basis string <apdx:basisElement>`; :param delta2_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the second delta correction; to the correlation energy. :type delta3_basis: :ref:`basis string <apdx:basisElement>`; :param delta3_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the third delta correction; to the correlation energy. :type delta4_basis: :ref:`basis string <apdx:basisElement>`; :param delta4_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the fourth delta correction; to the correlation energy. :type delta5_basis: :ref:`basis string <apdx:basisElement>`; :param delta5_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets empl",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:58746,energy,energy,58746,psi4manual/4.0b5/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html,5,['energy'],['energy']
Energy Efficiency,"`""blyp/sto-3g""``) are; bounced out of CBS. More complex calls (e.g. ``""mp2/cc-pv[tq]z""`` or; ``""mp2/cc-pv[tq]z+D:ccsd(t)/cc-pvtz""``) are expanded by `_parse_cbs_gufunc_string()`; and pushed through :py:func:`~psi4.cbs`. Returns; -------; tuple or float; Float, or if ``return_wfn`` is specified, a tuple of ``(value, wavefunction)``.; """""". # Catch kwarg issues for all methods; kwargs = p4util.kwargs_lower(kwargs); return_wfn = kwargs.pop('return_wfn', False); core.clean_variables(); ptype = kwargs.pop('ptype', None). # Make sure the molecule the user provided is the active one; molecule = kwargs.pop('molecule', core.get_active_molecule()); molecule.update_geometry(). # Sanitize total_method_name; label = total_method_name; total_method_name = total_method_name.lower(); total_method_name = total_method_name.replace(' ', ''). # Split into components; method_list, basis_list = _parse_cbs_gufunc_string(total_method_name). # Single energy call?; single_call = len(method_list) == 1; single_call &= '[' not in basis_list[0]; single_call &= ']' not in basis_list[0]. if single_call:; method_name = method_list[0]; basis = basis_list[0]. # Save some global variables so we can reset them later; optstash = p4util.OptionsState(['BASIS']); core.set_global_option('BASIS', basis); ptype_value, wfn = func(method_name, return_wfn=True, molecule=molecule, **kwargs); core.clean(). optstash.restore(). if return_wfn:; return (ptype_value, wfn); else:; return ptype_value. # Drop out for unsupported calls; if ptype not in [""energy"", ""gradient"", ""hessian""]:; raise ValidationError(""%s: Cannot extrapolate or delta correct %s yet."" % (ptype.title(), ptype)). # Catch kwarg issues for CBS methods only; user_dertype = kwargs.pop('dertype', None); cbs_verbose = kwargs.pop('cbs_verbose', False). # If we are not a single call, let CBS wrapper handle it!; cbs_kwargs = {}; cbs_kwargs['ptype'] = ptype; cbs_kwargs['return_wfn'] = True; cbs_kwargs['molecule'] = molecule; cbs_kwargs['verbose'] = cbs_verbose. ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver_cbs.html:64272,energy,energy,64272,psi4manual/1.3.2/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver_cbs.html,1,['energy'],['energy']
Energy Efficiency,"`""blyp/sto-3g""``) are; bounced out of CBS. More complex calls (e.g. ``""mp2/cc-pv[tq]z""`` or; ``""mp2/cc-pv[tq]z+D:ccsd(t)/cc-pvtz""``) are expanded by `_parse_cbs_gufunc_string()`; and pushed through :py:func:`~psi4.cbs`. Returns; -------; tuple or float; Float, or if ``return_wfn`` is specified, a tuple of ``(value, wavefunction)``.; """""". # Catch kwarg issues for all methods; kwargs = p4util.kwargs_lower(kwargs); return_wfn = kwargs.pop('return_wfn', False); core.clean_variables(); ptype = kwargs.pop('ptype', None). # Make sure the molecule the user provided is the active one; molecule = kwargs.pop('molecule', core.get_active_molecule()); molecule.update_geometry(). # Sanitize total_method_name; label = total_method_name; total_method_name = total_method_name.lower(); total_method_name = total_method_name.replace(' ', ''). # Split into components; method_list, basis_list = _parse_cbs_gufunc_string(total_method_name). # Single energy call?; single_call = len(method_list) == 1; single_call &= '[' not in basis_list[0]; single_call &= ']' not in basis_list[0]. if single_call:; method_name = method_list[0]; basis = basis_list[0]. # Save some global variables so we can reset them later; optstash = p4util.OptionsState(['BASIS']); core.set_global_option('BASIS', basis); ptype_value, wfn = func(method_name, return_wfn=True, molecule=molecule, **kwargs); if core.get_option(""SCF"", ""DF_INTS_IO"") != ""SAVE"":; core.clean(); optstash.restore(). if return_wfn:; return (ptype_value, wfn); else:; return ptype_value. # Drop out for unsupported calls; if ptype not in [""energy"", ""gradient"", ""hessian""]:; raise ValidationError(""%s: Cannot extrapolate or delta correct %s yet."" % (ptype.title(), ptype)). # Catch kwarg issues for CBS methods only; user_dertype = kwargs.pop('dertype', None); cbs_verbose = kwargs.pop('cbs_verbose', False). # If we are not a single call, let CBS wrapper handle it!; cbs_kwargs = {}; cbs_kwargs['ptype'] = ptype; cbs_kwargs['return_wfn'] = True; cbs_kwargs['molecule",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html:65829,energy,energy,65829,psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html,4,['energy'],['energy']
Energy Efficiency,"`'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a fifth delta correction; to the correlation energy is to be obtained. :type delta5_wfn_lesser: string; :param delta5_wfn_lesser: |dl| ``delta4_wfn`` |dr| || ``'ccsd(t)'`` || etc. Indicates the inferior energy method for which a fifth delta correction; to the correlation energy is to be obtained. * Basis Sets; Currently, the basis set set through ``set`` commands have no influence; on a cbs calculation. :type scf_basis: :ref:`basis string <apdx:basisElement>`; :param scf_basis: |dl| ``corl_basis`` |dr| || ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the reference energy.; If any correlation method is specified, ``scf_basis`` can default; to ``corl_basis``. :type corl_basis: :ref:`basis string <apdx:basisElement>`; :param corl_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the correlation energy. :type delta_basis: :ref:`basis string <apdx:basisElement>`; :param delta_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the delta correction; to the correlation energy. :type delta2_basis: :ref:`basis string <apdx:basisElement>`; :param delta2_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the second delta correction; to the correlation energy. :type delta3_basis: :ref:`basis string <apdx:basisElement>`; :param delta3_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the third delta correction; to the correlation energy. :type delta4_basis: :ref:`basis string <apdx:basisElement>`; :param delta4_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the fourth d",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html:23451,energy,energy,23451,psi4manual/1.0.0/_modules/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html,3,['energy'],['energy']
Energy Efficiency,"`; * :psivar:`db_name DATABASE MEAN ABSOLUTE DEVIATION`; * :psivar:`db_name DATABASE ROOT-MEAN-SQUARE DEVIATION`; * Python dictionaries of results accessible as ``DB_RGT`` and ``DB_RXN``. .. note:: It is very easy to make a database from a collection of xyz files; using the script :source:`psi4/share/psi4/scripts/ixyz2database.py`.; See :ref:`sec:createDatabase` for details. .. caution:: Some features are not yet implemented. Buy a developer some coffee. - In sow/reap mode, use only global options (e.g., the local option set by ``set scf scf_type df`` will not be respected). .. note:: To access a database that is not embedded in a |PSIfour|; distribution, add the path to the directory containing the database; to the environment variable :envvar:`PYTHONPATH`. :type name: str; :param name: ``'scf'`` || ``'sapt0'`` || ``'ccsd(t)'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; :py:func:`psi4.energy`. :type db_name: str; :param db_name: ``'BASIC'`` || ``'S22'`` || ``'HTBH'`` || etc. Second argument, usually unlabeled. Indicates the requested database; name, matching (case insensitive) the name of a python file in; ``psi4/share/databases`` or :envvar:`PYTHONPATH`. Consult that; directory for available databases and literature citations. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``energy`` |dr| || ``optimize`` || ``cbs``. Indicates the type of calculation to be performed on each database; member. The default performs a single-point ``energy('name')``, while; ``optimize`` perfoms a geometry optimization on each reagent, and; ``cbs`` performs a compound single-point energy. If a nested series; of python functions is intended (see :ref:`sec:intercalls`), use; keyword ``db_func`` instead of ``func``. :type mode: str; :param mode: |dl| ``'continuous'`` |dr| || ``'sow'`` || ``'reap'``. Indicates whether the calculations required to complete the; database are to be",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html:2947,energy,energy,2947,psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html,6,['energy'],['energy']
Energy Efficiency,"`; :param wfn: set of molecule, basis, orbitals from which to generate cube files. :type filename: string; :param filename: destination file name for MOLDEN file (optional). :type density_a: :py:class:`~psi4.core.Matrix`; :param density_a: density in the MO basis to build alpha NO's from (optional). :type density_b: :py:class:`~psi4.core.Matrix`; :param density_b: density in the MO basis to build beta NO's from, assumes restricted if not supplied (optional). :type dovirtual: bool; :param dovirtual: do write all the MOs to the MOLDEN file (true) or discard the unoccupied MOs, not valid for NO's (false) (optional). :examples:. >>> # [1] Molden file for DFT calculation; >>> E, wfn = energy('b3lyp', return_wfn=True); >>> molden(wfn, 'mycalc.molden'). >>> # [2] Molden file for CI/MCSCF computation using NO roots; >>> E, wfn = energy('ci', return_wfn=True); >>> molden(wfn, 'no_root1.molden', density_a=wfn.opdm(0, 0, ""A"", True)). >>> # [3] The following does NOT work, please see below; >>> E, wfn = energy('ccsd', return_wfn=True); >>> molden(wfn, 'ccsd_no.molden', density_a=wfn.Da()). >>> # [4] This WILL work, note the transformation of Da (SO->MO); >>> E, wfn = properties('ccsd', properties=['dipole'], return_wfn=True); >>> Da_so = wfn.Da(); >>> Da_mo = Matrix.triplet(wfn.Ca(), Da_so, wfn.Ca(), True, False, False); >>> molden(wfn, 'ccsd_no.molden', density_a=Da_mo). """""". if filename is None:; filename = core.get_writer_file_prefix(wfn.molecule().name()) + "".molden"". if dovirtual is None:; dovirt = bool(core.get_option(""SCF"", ""MOLDEN_WITH_VIRTUAL"")). else:; dovirt = dovirtual. if density_a:; nmopi = wfn.nmopi(); nsopi = wfn.nsopi(). NO_Ra = core.Matrix(""NO Alpha Rotation Matrix"", nmopi, nmopi); NO_occa = core.Vector(nmopi); density_a.diagonalize(NO_Ra, NO_occa, core.DiagonalizeOrder.Descending); NO_Ca = core.Matrix(""Ca Natural Orbitals"", nsopi, nmopi); NO_Ca.gemm(False, False, 1.0, wfn.Ca(), NO_Ra, 0). if density_b:; NO_Rb = core.Matrix(""NO Beta Rotation Matrix"", nmopi, nmo",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/driver.html:98056,energy,energy,98056,psi4manual/1.2.1/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/driver.html,1,['energy'],['energy']
Energy Efficiency,"`; :param wfn: set of molecule, basis, orbitals from which to generate cube files. :type filename: string; :param filename: destination file name for MOLDEN file (optional). :type density_a: :py:class:`~psi4.core.Matrix`; :param density_a: density in the MO basis to build alpha NO's from (optional). :type density_b: :py:class:`~psi4.core.Matrix`; :param density_b: density in the MO basis to build beta NO's from, assumes restricted if not supplied (optional). :type dovirtual: bool; :param dovirtual: do write all the MOs to the MOLDEN file (true) or discard the unoccupied MOs, not valid for NO's (false) (optional). :examples:. >>> # [1] Molden file for DFT calculation; >>> E, wfn = energy('b3lyp', return_wfn=True); >>> molden(wfn, 'mycalc.molden'). >>> # [2] Molden file for CI/MCSCF computation using NO roots; >>> E, wfn = energy('ci', return_wfn=True); >>> molden(wfn, 'no_root1.molden', density_a=wfn.opdm(0, 0, ""A"", True)). >>> # [3] The following does NOT work, please see below; >>> E, wfn = energy('ccsd', return_wfn=True); >>> molden(wfn, 'ccsd_no.molden', density_a=wfn.Da()). >>> # [4] This WILL work, note the transformation of Da (SO->MO); >>> E, wfn = properties('ccsd', properties=['dipole'], return_wfn=True); >>> Da_so = wfn.Da(); >>> SCa = core.doublet(wfn.S(), wfn.Ca(), False, False); >>> Da_mo = core.triplet(SCa, Da_so, SCa, True, False, False); >>> molden(wfn, 'ccsd_no.molden', density_a=Da_mo). """""". if filename is None:; filename = core.get_writer_file_prefix(wfn.molecule().name()) + "".molden"". if dovirtual is None:; dovirt = bool(core.get_option(""SCF"", ""MOLDEN_WITH_VIRTUAL"")). else:; dovirt = dovirtual. if density_a:; nmopi = wfn.nmopi(); nsopi = wfn.nsopi(). NO_Ra = core.Matrix(""NO Alpha Rotation Matrix"", nmopi, nmopi); NO_occa = core.Vector(nmopi); density_a.diagonalize(NO_Ra, NO_occa, core.DiagonalizeOrder.Descending); NO_Ca = core.Matrix(""Ca Natural Orbitals"", nsopi, nmopi); NO_Ca.gemm(False, False, 1.0, wfn.Ca(), NO_Ra, 0). if density_b:; NO_Rb = core",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver.html:83034,energy,energy,83034,psi4manual/1.3.2/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver.html,1,['energy'],['energy']
Energy Efficiency,"`; :param wfn: set of molecule, basis, orbitals from which to generate cube files. :type filename: string; :param filename: destination file name for MOLDEN file (optional). :type density_a: :py:class:`~psi4.core.Matrix`; :param density_a: density in the MO basis to build alpha NO's from (optional). :type density_b: :py:class:`~psi4.core.Matrix`; :param density_b: density in the MO basis to build beta NO's from, assumes restricted if not supplied (optional). :type dovirtual: bool; :param dovirtual: do write all the MOs to the MOLDEN file (true) or discard the unoccupied MOs, not valid for NO's (false) (optional). :examples:. >>> # [1] Molden file for DFT calculation; >>> E, wfn = energy('b3lyp', return_wfn=True); >>> molden(wfn, 'mycalc.molden'). >>> # [2] Molden file for CI/MCSCF computation using NO roots; >>> E, wfn = energy('ci', return_wfn=True); >>> molden(wfn, 'no_root1.molden', density_a=wfn.opdm(0, 0, ""A"", True)). >>> # [3] The following does NOT work, please see below; >>> E, wfn = energy('ccsd', return_wfn=True); >>> molden(wfn, 'ccsd_no.molden', density_a=wfn.Da()). >>> # [4] This WILL work, note the transformation of Da (SO->MO); >>> E, wfn = property('ccsd', properties=['dipole'], return_wfn=True); >>> Da_so = wfn.Da(); >>> Da_mo = Matrix.triplet(wfn.Ca(), Da_so, wfn.Ca(), True, False, False); >>> molden(wfn, 'ccsd_no.molden', density_a=Da_mo). """""". if filename is None:; filename = core.get_writer_file_prefix(wfn.molecule().name()) + "".molden"". if dovirtual is None:; dovirt = bool(core.get_option(""SCF"", ""MOLDEN_WITH_VIRTUAL"")). else:; dovirt = dovirtual. if density_a:; nmopi = wfn.nmopi(); nsopi = wfn.nsopi(). NO_Ra = core.Matrix(""NO Alpha Rotation Matrix"", nmopi, nmopi); NO_occa = core.Vector(nmopi); density_a.diagonalize(NO_Ra, NO_occa, core.DiagonalizeOrder.Descending); NO_Ca = core.Matrix(""Ca Natural Orbitals"", nsopi, nmopi); NO_Ca.gemm(False, False, 1.0, wfn.Ca(), NO_Ra, 0). if density_b:; NO_Rb = core.Matrix(""NO Beta Rotation Matrix"", nmopi, nmopi",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/driver.html:90500,energy,energy,90500,psi4manual/1.1.0/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/driver.html,1,['energy'],['energy']
Energy Efficiency,"`CBS CORRELATION ENERGY <CBSCORRELATIONENERGY>`; * :psivar:`CURRENT ENERGY <CURRENTENERGY>`; * :psivar:`CURRENT REFERENCE ENERGY <CURRENTREFERENCEENERGY>`; * :psivar:`CURRENT CORRELATION ENERGY <CURRENTCORRELATIONENERGY>`. .. caution:: Some features are not yet implemented. Buy a developer a coffee. - No way to tell function to boost fitting basis size for all calculations. - No way to extrapolate def2 family basis sets. - Need to add more extrapolation schemes. As represented in the equation below, a CBS energy method is defined in several; sequential stages (scf, corl, delta, delta2, delta3, delta4, delta5) covering treatment; of the reference total energy, the correlation energy, a delta correction to the; correlation energy, and a second delta correction, etc.. Each is activated by its; stage_wfn keyword and is only allowed if all preceding stages are active. .. include:: ../cbs_eqn.rst. * Energy Methods; The presence of a stage_wfn keyword is the indicator to incorporate; (and check for stage_basis and stage_scheme keywords) and compute; that stage in defining the CBS energy. The cbs() function requires, at a minimum, ``name='scf'`` and ``scf_basis``; keywords to be specified for reference-step only jobs and ``name`` and; ``corl_basis`` keywords for correlated jobs. The following energy methods have been set up for cbs(). .. hlist::; :columns: 5. * scf; * hf; * mp2; * mp2.5; * mp3; * mp4(sdq); * mp4; * mp\ *n*; * omp2; * omp2.5; * omp3; * olccd; * lccd; * lccsd; * cepa(0); * cepa(1); * cepa(3); * acpf; * aqcc; * qcisd; * cc2; * ccsd; * fno-ccsd; * bccd; * cc3; * qcisd(t); * ccsd(t); * fno-ccsd(t); * bccd(t); * cisd; * cisdt; * cisdtq; * ci\ *n*; * fci; * mrccsd; * mrccsd(t); * mrccsdt; * mrccsdt(q). :type name: string; :param name: ``'scf'`` || ``'ccsd'`` || etc. First argument, usually unlabeled. Indicates the computational method; for the correlation energy, unless only reference step to be performed,; in which case should be ``'scf'``. Overruled if stage_wfn ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/driver_cbs.html:19530,energy,energy,19530,psi4manual/1.1.0/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/driver_cbs.html,2,['energy'],['energy']
Energy Efficiency,"`` || etc. Indicates which properties should be computed. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :examples:. >>> # [1] Optical rotation calculation; >>> property('cc2', properties=['rotation']). """"""; lowername = name.lower(); kwargs = kwargs_lower(kwargs). optstash = OptionsState(; ['SCF', 'E_CONVERGENCE'],; ['SCF', 'D_CONVERGENCE'],; ['E_CONVERGENCE']). # Make sure the molecule the user provided is the active one; if ('molecule' in kwargs):; activate(kwargs['molecule']); del kwargs['molecule']; molecule = PsiMod.get_active_molecule(); molecule.update_geometry(); #PsiMod.set_global_option('BASIS', PsiMod.get_global_option('BASIS')). # Allow specification of methods to arbitrary order; lowername, level = parse_arbitrary_order(lowername); if level:; kwargs['level'] = level. try:; # Set method-dependent scf convergence criteria (test on procedures['energy'] since that's guaranteed); # SCF properties have been set as 6/5 so as to match those ; # run normally through OEProp so subject to change; if not PsiMod.has_option_changed('SCF', 'E_CONVERGENCE'):; if procedures['energy'][lowername] == run_scf or procedures['energy'][lowername] == run_dft:; PsiMod.set_local_option('SCF', 'E_CONVERGENCE', 6); else:; PsiMod.set_local_option('SCF', 'E_CONVERGENCE', 10); if not PsiMod.has_option_changed('SCF', 'D_CONVERGENCE'):; if procedures['energy'][lowername] == run_scf or procedures['energy'][lowername] == run_dft:; PsiMod.set_local_option('SCF', 'D_CONVERGENCE', 6); else:; PsiMod.set_local_option('SCF', 'D_CONVERGENCE', 10). # Set post-scf convergence criteria (global will cover all correlated modules); if not PsiMod.has_global_option_changed('E_CONVERGENCE'):; if not procedures['energy'][lowername] == run_scf and not procedures['energy'][lowername] == run_dft:; PsiMod.set_global_option('E_CONVERGENCE', 8). returnvalue = procedures['property'][lowername](lowername, **kwargs). except ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/_modules/driver.html:43778,energy,energy,43778,psi4manual/4.0b4/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/driver.html,2,['energy'],['energy']
Energy Efficiency,"``'off'`` |dr| || ``'cc-pVDZ-RI'`` || ``'aug-cc-pVDZ-JKFIT'`` || etc. Indicates whether, when *cast_up* is active, to run the preliminary; scf in density-fitted mode or what fitting basis to employ (when; available for all elements, cc-pVDZ-RI is the default). .. deprecated:: Sept-2012; Use option |scf__df_basis_guess| instead. :type bypass_scf: :ref:`boolean <op_py_boolean>`; :param bypass_scf: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether, for *name* values built atop of scf calculations,; the scf step is skipped. Suitable when special steps are taken to get; the scf to converge in an explicit preceeding scf step. :examples:. >>> # [1] Coupled-cluster singles and doubles calculation with psi code; >>> energy('ccsd'). >>> # [2] Charge-transfer SAPT calculation with scf projection from small into; >>> # requested basis, with specified projection fitting basis; >>> set basis_guess true; >>> set df_basis_guess jun-cc-pVDZ-JKFIT; >>> energy('sapt0-ct'). >>> # [3] Arbitrary-order MPn calculation; >>> energy('mp4'). >>> # [4] Converge scf as singlet, then run detci as triplet upon singlet reference; >>> molecule H2 {\\n0 1\\nH\\nH 1 0.74\\n}; >>> energy('scf'); >>> H2.set_multiplicity(3); >>> energy('detci', bypass_scf=True). """"""; lowername = name.lower(); kwargs = kwargs_lower(kwargs). # Make sure the molecule the user provided is the active one; if 'molecule' in kwargs:; activate(kwargs['molecule']); del kwargs['molecule']; molecule = PsiMod.get_active_molecule(); molecule.update_geometry(). # Allow specification of methods to arbitrary order; lowername, level = parse_arbitrary_order(lowername); if level:; kwargs['level'] = level. try:; return procedures['energy'][lowername](lowername, **kwargs); except KeyError:; raise ValidationError('Energy method %s not available.' % (lowername)). [docs]def gradient(name, **kwargs):; r""""""Function complementary to optimize(). Carries out one gradient pass,; deciding analytic or finite difference. """"""; lowername = name.lower(); ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/_modules/driver.html:22181,energy,energy,22181,psi4manual/4.0b3/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/_modules/driver.html,2,['energy'],['energy']
Energy Efficiency,"``name='scf'`` and ``scf_basis``; keywords to be specified for reference-step only jobs and ``name`` and; ``corl_basis`` keywords for correlated jobs. The following energy methods have been set up for cbs(). .. hlist::; :columns: 5. * scf; * hf; * mp2; * mp2.5; * mp3; * mp4(sdq); * mp4; * mp\ *n*; * omp2; * omp2.5; * omp3; * olccd; * lccd; * lccsd; * cepa(0); * cepa(1); * cepa(3); * acpf; * aqcc; * qcisd; * cc2; * ccsd; * fno-ccsd; * bccd; * cc3; * qcisd(t); * ccsd(t); * fno-ccsd(t); * bccd(t); * cisd; * cisdt; * cisdtq; * ci\ *n*; * fci; * mrccsd; * mrccsd(t); * mrccsdt; * mrccsdt(q). :type name: string; :param name: ``'scf'`` || ``'ccsd'`` || etc. First argument, usually unlabeled. Indicates the computational method; for the correlation energy, unless only reference step to be performed,; in which case should be ``'scf'``. Overruled if stage_wfn keywords supplied. :type scf_wfn: string; :param scf_wfn: |dl| ``'scf'`` |dr| || ``'c4-scf'`` || etc. Indicates the energy method for which the reference energy is to be; obtained. Generally unnecessary, as 'scf' is *the* scf in |PSIfour| but; can be used to direct lone scf components to run in |PSIfour| or Cfour; in a mixed-program composite method. :type corl_wfn: string; :param corl_wfn: ``'mp2'`` || ``'ccsd(t)'`` || etc. Indicates the energy method for which the correlation energy is to be; obtained. Can also be specified with ``name`` or as the unlabeled; first argument to the function. :type delta_wfn: string; :param delta_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a delta correction; to the correlation energy is to be obtained. :type delta_wfn_lesser: string; :param delta_wfn_lesser: |dl| ``corl_wfn`` |dr| || ``'mp2'`` || etc. Indicates the inferior energy method for which a delta correction; to the correlation energy is to be obtained. :type delta2_wfn: string; :param delta2_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a seco",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/driver_cbs.html:20557,energy,energy,20557,psi4manual/1.1.0/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/driver_cbs.html,4,['energy'],['energy']
Energy Efficiency,"`computed` is compared.; :param computed: Input FCIDUMP file to compare against `expected`.; :param label: string labeling the test; """""". # Grab expected header and integrals; ref_intdump = fcidump_from_file(expected); intdump = fcidump_from_file(computed). # Compare headers; compare_recursive(; ref_intdump,; intdump,; 'FCIDUMP header',; forgive=['enuc', 'hcore', 'eri', 'epsilon']). ref_energies = energies_from_fcidump(ref_intdump); energies = energies_from_fcidump(intdump). pass_1el = compare_values(ref_energies['ONE-ELECTRON ENERGY'], energies['ONE-ELECTRON ENERGY'], 7,; label + '. 1-electron energy'); pass_2el = compare_values(ref_energies['TWO-ELECTRON ENERGY'], energies['TWO-ELECTRON ENERGY'], 7,; label + '. 2-electron energy'); pass_scf = compare_values(ref_energies['SCF TOTAL ENERGY'], energies['SCF TOTAL ENERGY'], 10,; label + '. SCF total energy'); pass_mp2 = compare_values(ref_energies['MP2 CORRELATION ENERGY'], energies['MP2 CORRELATION ENERGY'], 10,; label + '. MP2 correlation energy'). compare_integers(True, (pass_1el and pass_2el and pass_scf and pass_mp2), label). [docs]; def energies_from_fcidump(intdump) -> Dict[str, float]:; """"""From integrals dictionary generated from :py:func:`fcidump_from_file`,; compute energies. :returns: a dictionary with energies. - 'NUCLEAR REPULSION ENERGY'; - 'ONE-ELECTRON ENERGY'; - 'TWO-ELECTRON ENERGY'; - 'SCF TOTAL ENERGY'; - 'MP2 CORRELATION ENERGY'. """"""; energies = {}; energies['NUCLEAR REPULSION ENERGY'] = intdump['enuc']; epsilon = intdump['epsilon']; Hcore = intdump['hcore']; eri = intdump['eri']. # Compute SCF energy; energies['ONE-ELECTRON ENERGY'], energies['TWO-ELECTRON ENERGY'] = _scf_energy(Hcore, eri,; np.where(epsilon < 0)[0],; intdump['uhf']); # yapf: disable; energies['SCF TOTAL ENERGY'] = energies['ONE-ELECTRON ENERGY'] + energies['TWO-ELECTRON ENERGY'] + energies['NUCLEAR REPULSION ENERGY']; # yapf: enable. # Compute MP2 energy; energies['MP2 CORRELATION ENERGY'] = _mp2_energy(eri, epsilon, intdump['uh",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/fcidump.html:13871,energy,energy,13871,psi4manual/1.8.x/_modules/psi4/driver/p4util/fcidump.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/fcidump.html,6,['energy'],['energy']
Energy Efficiency,"`computed` is compared.; :param computed: Input FCIDUMP file to compare against `expected`.; :param label: string labeling the test; """""". # Grab expected header and integrals; ref_intdump = fcidump_from_file(expected); intdump = fcidump_from_file(computed). # Compare headers; compare_recursive(; ref_intdump,; intdump,; 'FCIDUMP header',; forgive=['enuc', 'hcore', 'eri', 'epsilon']). ref_energies = energies_from_fcidump(ref_intdump); energies = energies_from_fcidump(intdump). pass_1el = compare_values(ref_energies['ONE-ELECTRON ENERGY'], energies['ONE-ELECTRON ENERGY'], 7,; label + '. 1-electron energy'); pass_2el = compare_values(ref_energies['TWO-ELECTRON ENERGY'], energies['TWO-ELECTRON ENERGY'], 7,; label + '. 2-electron energy'); pass_scf = compare_values(ref_energies['SCF TOTAL ENERGY'], energies['SCF TOTAL ENERGY'], 10,; label + '. SCF total energy'); pass_mp2 = compare_values(ref_energies['MP2 CORRELATION ENERGY'], energies['MP2 CORRELATION ENERGY'], 10,; label + '. MP2 correlation energy'). compare_integers(True, (pass_1el and pass_2el and pass_scf and pass_mp2), label). [docs]def energies_from_fcidump(intdump) -> Dict[str, float]:; """"""From integrals dictionary generated from :py:func:`fcidump_from_file`,; compute energies. :returns: a dictionary with energies. - 'NUCLEAR REPULSION ENERGY'; - 'ONE-ELECTRON ENERGY'; - 'TWO-ELECTRON ENERGY'; - 'SCF TOTAL ENERGY'; - 'MP2 CORRELATION ENERGY'. """"""; energies = {}; energies['NUCLEAR REPULSION ENERGY'] = intdump['enuc']; epsilon = intdump['epsilon']; Hcore = intdump['hcore']; eri = intdump['eri']. # Compute SCF energy; energies['ONE-ELECTRON ENERGY'], energies['TWO-ELECTRON ENERGY'] = _scf_energy(Hcore, eri,; np.where(epsilon < 0)[0],; intdump['uhf']); # yapf: disable; energies['SCF TOTAL ENERGY'] = energies['ONE-ELECTRON ENERGY'] + energies['TWO-ELECTRON ENERGY'] + energies['NUCLEAR REPULSION ENERGY']; # yapf: enable. # Compute MP2 energy; energies['MP2 CORRELATION ENERGY'] = _mp2_energy(eri, epsilon, intdump['uhf'",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/fcidump.html:13863,energy,energy,13863,psi4manual/1.7.x/_modules/psi4/driver/p4util/fcidump.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/fcidump.html,2,['energy'],['energy']
Energy Efficiency,"`computed` is compared.; :param computed: Input FCIDUMP file to compare against `expected`.; :param label: string labeling the test; """""". # Grab expected header and integrals; ref_intdump = fcidump_from_file(expected); intdump = fcidump_from_file(computed). # Compare headers; compare_recursive(; ref_intdump,; intdump,; 'FCIDUMP header',; forgive=['enuc', 'hcore', 'eri', 'epsilon']). ref_energies = energies_from_fcidump(ref_intdump); energies = energies_from_fcidump(intdump). pass_1el = compare_values(ref_energies['ONE-ELECTRON ENERGY'], energies['ONE-ELECTRON ENERGY'], 7,; label + '. 1-electron energy'); pass_2el = compare_values(ref_energies['TWO-ELECTRON ENERGY'], energies['TWO-ELECTRON ENERGY'], 7,; label + '. 2-electron energy'); pass_scf = compare_values(ref_energies['SCF TOTAL ENERGY'], energies['SCF TOTAL ENERGY'], 10,; label + '. SCF total energy'); pass_mp2 = compare_values(ref_energies['MP2 CORRELATION ENERGY'], energies['MP2 CORRELATION ENERGY'], 10,; label + '. MP2 correlation energy'). compare_integers(True, (pass_1el and pass_2el and pass_scf and pass_mp2), label). [docs]def energies_from_fcidump(intdump):; energies = {}; energies['NUCLEAR REPULSION ENERGY'] = intdump['enuc']; epsilon = intdump['epsilon']; Hcore = intdump['hcore']; eri = intdump['eri']. # Compute SCF energy; energies['ONE-ELECTRON ENERGY'], energies['TWO-ELECTRON ENERGY'] = _scf_energy(Hcore, eri,; np.where(epsilon < 0)[0],; intdump['uhf']); # yapf: disable; energies['SCF TOTAL ENERGY'] = energies['ONE-ELECTRON ENERGY'] + energies['TWO-ELECTRON ENERGY'] + energies['NUCLEAR REPULSION ENERGY']; # yapf: enable. # Compute MP2 energy; energies['MP2 CORRELATION ENERGY'] = _mp2_energy(eri, epsilon, intdump['uhf']). return energies. def _scf_energy(Hcore, ERI, occ_sl, unrestricted):; scf_1el_e = np.einsum('ii->', Hcore[np.ix_(occ_sl, occ_sl)]); if not unrestricted:; scf_1el_e *= 2; coulomb = np.einsum('iijj->', ERI[np.ix_(occ_sl, occ_sl, occ_sl, occ_sl)]); exchange = np.einsum('ijij->', ERI[np",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/p4util/fcidump.html:13635,energy,energy,13635,psi4manual/1.6.x/_modules/psi4/driver/p4util/fcidump.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/p4util/fcidump.html,2,['energy'],['energy']
Energy Efficiency,"`function <op_py_function>`; :param func: |dl| ``gradient`` |dr| || ``energy`` || ``cbs``. Indicates the type of calculation to be performed on the molecule.; The default dertype accesses ``'gradient'`` or ``'energy'``, while; ``'cbs'`` performs a multistage finite difference calculation.; If a nested series of python functions is intended (see :ref:`sec:intercalls`),; use keyword ``freq_func`` instead of ``func``. :type mode: string; :param mode: |dl| ``'continuous'`` |dr| || ``'sow'`` || ``'reap'``. For a finite difference of energies or gradients frequency, indicates; whether the calculations required to complete the frequency are to be run; in one file (``'continuous'``) or are to be farmed out in an; embarrassingly parallel fashion (``'sow'``/``'reap'``)/ For the latter,; run an initial job with ``'sow'`` and follow instructions in its output file.; For maximum flexibility, ``return_wfn`` is always on in ``'reap'`` mode. :type dertype: :ref:`dertype <op_py_dertype>`; :param dertype: |dl| ``'hessian'`` |dr| || ``'gradient'`` || ``'energy'``. Indicates whether analytic (if available- they're not), finite; difference of gradients (if available) or finite difference of; energies is to be performed. :type irrep: int or string; :param irrep: |dl| ``-1`` |dr| || ``1`` || ``'b2'`` || ``'App'`` || etc. Indicates which symmetry block (:ref:`Cotton <table:irrepOrdering>` ordering) of vibrational; frequencies to be computed. ``1``, ``'1'``, or ``'a1'`` represents; :math:`a_1`, requesting only the totally symmetric modes.; ``-1`` indicates a full frequency calculation. .. note:: Analytic hessians are not available. Frequencies will proceed through; finite differences according to availability of gradients or energies. .. _`table:freq_gen`:. :examples:. >>> # [1] Frequency calculation for all modes through highest available derivatives; >>> frequency('ccsd'). >>> # [2] Frequency calculation for b2 modes through finite difference of gradients; >>> # printing lowest mode frequ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/driver.html:80697,energy,energy,80697,psi4manual/1.0.0/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver.html,1,['energy'],['energy']
Energy Efficiency,"`function <op_py_function>`; :param func: |dl| ``gradient`` |dr| || ``energy`` || ``cbs``. Indicates the type of calculation to be performed on the molecule.; The default dertype accesses ``'gradient'`` or ``'energy'``, while; ``'cbs'`` performs a multistage finite difference calculation.; If a nested series of python functions is intended (see :ref:`sec:intercalls`),; use keyword ``freq_func`` instead of ``func``. :type mode: string; :param mode: |dl| ``'continuous'`` |dr| || ``'sow'`` || ``'reap'``. For a finite difference of energies or gradients frequency, indicates; whether the calculations required to complete the frequency are to be run; in one file (``'continuous'``) or are to be farmed out in an; embarrassingly parallel fashion (``'sow'``/``'reap'``)/ For the latter,; run an initial job with ``'sow'`` and follow instructions in its output file.; For maximum flexibility, ``return_wfn`` is always on in ``'reap'`` mode. :type dertype: :ref:`dertype <op_py_dertype>`; :param dertype: |dl| ``'hessian'`` |dr| || ``'gradient'`` || ``'energy'``. Indicates whether analytic (if available- they're not), finite; difference of gradients (if available) or finite difference of; energies is to be performed. :type irrep: int or string; :param irrep: |dl| ``-1`` |dr| || ``1`` || ``'b2'`` || ``'App'`` || etc. Indicates which symmetry block (:ref:`Cotton <table:irrepOrdering>` ordering) of vibrational; frequencies to be computed. ``1``, ``'1'``, or ``'a1'`` represents; :math:`a_1`, requesting only the totally symmetric modes.; ``-1`` indicates a full frequency calculation. .. note:: Analytic hessians are only available for RHF. For all other methods, Frequencies will; proceed through finite differences according to availability of gradients or energies. .. _`table:freq_gen`:. +-------------------------+---------------------------------------------------------------------------------------------------------------+; | name | calls method |; +=========================+============",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/driver.html:82663,energy,energy,82663,psi4manual/1.1.0/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/driver.html,2,['energy'],['energy']
Energy Efficiency,"`highest_1`` |dr| || ``corl_xtpl_helgaker_2`` || etc. Indicates the basis set extrapolation scheme to be applied to the third delta correction; to the correlation energy. :type delta4_scheme: function; :param delta4_scheme: |dl| ``highest_1`` |dr| || ``corl_xtpl_helgaker_2`` || etc. Indicates the basis set extrapolation scheme to be applied to the fourth delta correction; to the correlation energy. :type delta5_scheme: function; :param delta5_scheme: |dl| ``highest_1`` |dr| || ``corl_xtpl_helgaker_2`` || etc. Indicates the basis set extrapolation scheme to be applied to the fifth delta correction; to the correlation energy. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :examples:. >>> # [1] replicates with cbs() the simple model chemistry scf/cc-pVDZ: set basis cc-pVDZ energy('scf'); >>> cbs('scf', scf_basis='cc-pVDZ'). >>> # [2] replicates with cbs() the simple model chemistry mp2/jun-cc-pVDZ: set basis jun-cc-pVDZ energy('mp2'); >>> cbs('mp2', corl_basis='jun-cc-pVDZ'). >>> # [3] DTQ-zeta extrapolated scf reference energy; >>> cbs('scf', scf_basis='cc-pV[DTQ]Z', scf_scheme=scf_xtpl_helgaker_3). >>> # [4] DT-zeta extrapolated mp2 correlation energy atop a T-zeta reference; >>> cbs('mp2', corl_basis='cc-pv[dt]z', corl_scheme=corl_xtpl_helgaker_2). >>> # [5] a DT-zeta extrapolated coupled-cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference; >>> cbs('mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z', delta_scheme=corl_xtpl_helgaker_2). >>> # [6] a D-zeta ccsd(t) correction atop a DT-zeta extrapolated ccsd cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference; >>> cbs('mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd', delta_basis='aug-cc-pv[dt]z', delta_scheme=corl_xtpl_helgaker_2, delta2_wfn='c",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:62064,energy,energy,62064,psi4manual/4.0b5/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html,2,['energy'],['energy']
Energy Efficiency,"`scf_basis``; keywords to be specified for reference-step only jobs and ``name`` and; ``corl_basis`` keywords for correlated jobs. The following energy methods have been set up for cbs(). .. hlist::; :columns: 5. * scf; * df-scf; * mp2; * df-mp2; * cc2; * ccsd; * bccd; * cc3; * ccsd(t); * cisd; * cisdt; * cisdtq; * ci\ *n*; * fci. :type name: string; :param name: ``'scf'`` || ``'ccsd'`` || etc. First argument, usually unlabeled. Indicates the computational method; for the correlation energy, unless only reference step to be performed,; in which case should be ``'scf'``. Overruled if stage_wfn keywords supplied. :type corl_wfn: string; :param corl_wfn: ``'mp2'`` || ``'ccsd(t)'`` || etc. Indicates the energy method for which the correlation energy is to be; obtained. Can also be specified with ``name`` or as the unlabeled; first argument to the function. :type delta_wfn: string; :param delta_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a delta correction; to the correlation energy is to be obtained. :type delta_wfn_lesser: string; :param delta_wfn_lesser: |dl| ``'mp2'`` |dr| || ``'ccsd'`` || etc. Indicates the inferior energy method for which a delta correction; to the correlation energy is to be obtained. :type delta2_wfn: string; :param delta2_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a second delta correction; to the correlation energy is to be obtained. :type delta2_wfn_lesser: string; :param delta2_wfn_lesser: |dl| ``'mp2'`` |dr| || ``'ccsd(t)'`` || etc. Indicates the inferior energy method for which a second delta correction; to the correlation energy is to be obtained. * Basis Sets; Currently, the basis set set through ``set`` commands have no influence; on a cbs calculation. :type scf_basis: :ref:`basis string <apdx:basisElement>`; :param scf_basis: |dl| ``corl_basis`` |dr| || ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of b",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/_modules/wrappers.html:54704,energy,energy,54704,psi4manual/4.0b3/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/_modules/wrappers.html,4,['energy'],['energy']
Energy Efficiency,"a Cartesian representation; to avoid this problem. Caution; In early versions (notably PSI4 alpha circa 2011; and before), frozen core was implemented incompletely and for; only selected terms. Comparisons with papers published using early; PSI4 SAPT code may show discrepancies of 0.01-0.10 kcal/mol in; individual terms, particularly \(E_{exch}^{(11)}\) and \(E_{exch}^{(12)}\). Caution; January 28th 2016, the default for all NAT_ORBS options; was changed to true. Hence the code now by default uses natural; orbital truncation to speed up the evaluation of energy terms; wherever possible, according to literature recommendations.; In early July 2016, some total SAPT energy psivars were renamed. Symmetry-adapted perturbation theory (SAPT) provides a means of directly; computing the noncovalent interaction between two molecules, that is, the; interaction energy is determined without computing the total energy of the; monomers or dimer. In addition, SAPT provides a decomposition of the; interaction energy into physically meaningful components: i.e.,; electrostatic, exchange, induction, and dispersion terms. In SAPT, the; Hamiltonian of the dimer is partitioned into contributions from each; monomer and the interaction. \[H=F_A+W_A+F_B+W_B+V\]; Here, the Hamiltonian is written as a sum of the usual monomer Fock; operators, \(F\), the fluctuation potential of each monomer, \(W\), and the; interaction potential, \(V\). The monomer Fock operators, \(F_A+F_B\), are; treated as the zeroth-order Hamiltonian and the interaction energy is; evaluated through a perturbative expansion of \(V\), \(W_A\), and \(W_B\).; Through first-order in \(V\), electrostatic and exchange interactions are; included; induction and dispersion first appear at second-order in \(V\). For; a complete description of SAPT, the reader is referred to the excellent; review by Jeziorski, Moszynski, and Szalewicz [Jeziorski:1994:1887].; Several truncations of the closed-shell SAPT expansion are available in the S",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/sapt-1.html:1571,energy,energy,1571,psi4manual/1.1.0/sapt-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/sapt-1.html,6,['energy'],['energy']
Energy Efficiency,"a MP2 calculation, corrected by CCSD(T) at the TQ-zeta extrapolated level, and all-electron CCSD(T) correlation at T-zeta level; >>> energy(cbs, cbs_metadata=[{""wfn"": ""hf"", ""basis"": ""cc-pv5z""}, {""wfn"": ""mp2"", ""basis"": ""cc-pv[q5]z""}, {""wfn"": ""ccsd(t)"", ""basis"": ""cc-pv[tq]z""}, {""wfn"": ""ccsd(t)"", ""basis"": ""cc-pvtz"", ""options"": {""freeze_core"": ""False""}}]). >>> # [8] cbs() coupled with database(); >>> TODO database('mp2', 'BASIC', subset=['h2o','nh3'], symm='on', func=cbs, corl_basis='cc-pV[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd(t)', delta_basis='sto-3g'). >>> # [9] cbs() coupled with optimize(); >>> TODO optimize('mp2', corl_basis='cc-pV[DT]Z', corl_scheme=corl_xtpl_helgaker_2, func=cbs). """"""; kwargs = p4util.kwargs_lower(kwargs); metadata = _process_cbs_kwargs(kwargs); return_wfn = kwargs.pop('return_wfn', False); verbose = kwargs.pop('verbose', 0); ptype = kwargs.pop('ptype'). if ptype not in ['energy', 'gradient', 'hessian']:; raise ValidationError(""""""Wrapper complete_basis_set is unhappy to be calling; function '%s' instead of 'energy', 'gradient' or 'hessian'."""""" % ptype). optstash = p4util.OptionsState(['BASIS'], ['WFN'], ['WRITER_FILE_LABEL']). # Define some quantum chemical knowledge, namely what methods are subsumed in others. user_writer_file_label = core.get_global_option('WRITER_FILE_LABEL'). # Make sure the molecule the user provided is the active one; molecule = kwargs.pop('molecule', core.get_active_molecule()); molecule.update_geometry(); natom = molecule.natom(). if metadata[0][""wfn""] not in VARH.keys():; raise ValidationError(; """"""Requested SCF method '%s' is not recognized. Add it to VARH in wrapper.py to proceed."""""" %; (metadata[0][""wfn""])). if len(metadata) > 1:; for delta in metadata[1:]:; if delta[""wfn""] not in VARH.keys():; raise ValidationError(; """"""Requested higher %s method '%s' is not recognized. Add it to VARH in wrapper.py to proceed."""""" %; (delta[""treatment""], delta[""wfn""])); if delta[""wfn_lo""] not in VARH.keys():; raise ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver_cbs.html:46185,energy,energy,46185,psi4manual/1.3.2/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver_cbs.html,10,['energy'],['energy']
Energy Efficiency,"a MP4 energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); mtd_type = core.get_global_option('MP_TYPE'); module = core.get_global_option('QC_MODULE'); # Considering only detci/fnocc. func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module == 'DETCI':; func = run_detci; elif module in ['', 'FNOCC']:; func = run_fnocc; elif reference == 'ROHF':; if mtd_type == 'CONV':; if module == 'DETCI': # no default for this case; func = run_detci; elif module in ['']:; core.print_out(""""""\nThis method is available inefficiently as a """"""; """"""byproduct of a CISDT computation.\n Add ""set """"""; """"""qc_module detci"" to input to access this route.\n""""""). if func is None:; raise ManagedMethodError(['select_mp4', name, 'MP_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_adc2(name, **kwargs):; """"""Function selecting the algorithm for ADC(2) excited state energy; call and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); mtd_type = core.get_global_option('MP_TYPE'); module = core.get_global_option('QC_MODULE'); # Considering only adcc/adc. # TODO Actually one should do selection on a couple of other options here; # as well, e.g. adcc supports frozen-core and frozen-virtual,; # spin-specific states or spin-flip methods.; # But as far as I (mfherbst) know the BUILTIN ADC routine only supports; # singlet states and without freezing some core or some virtual orbitals. func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module == 'ADCC' and extras.addons(""adcc""):; func = run_adcc; elif module in ['', 'BUILTIN']:; func = run_adc. if reference == 'UHF':; if mtd_type == 'CONV':; if module in ['ADCC', ''] and extras.addons(""adcc""):; func = run_adcc. # Note: ROHF is theoretically available in adcc, but are not fully tested; # ... so will be added later. if func ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html:29615,energy,energy,29615,psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,4,['energy'],['energy']
Energy Efficiency,"a MP4 energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); mtd_type = core.get_global_option('MP_TYPE'); module = core.get_global_option('QC_MODULE'); # Considering only detci/fnocc. func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module == 'DETCI':; func = run_detci; elif module in ['', 'FNOCC']:; func = run_fnocc; elif reference == 'ROHF':; if mtd_type == 'CONV':; if module == 'DETCI': # no default for this case; func = run_detci; elif module in ['']:; core.print_out(""""""\nThis method is available inefficiently as a """"""; """"""byproduct of a CISDT computation.\n Add ""set """"""; """"""qc_module detci"" to input to access this route.\n""""""). if func is None:; raise ManagedMethodError(['select_mp4', name, 'MP_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_adc2(name, **kwargs):; """"""Function selecting the algorithm for ADC(2) excited state energy; call and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); mtd_type = core.get_global_option('MP_TYPE'); module = core.get_global_option('QC_MODULE'); # Considering only adcc/adc. # TODO Actually one should do selection on a couple of other options here; # as well, e.g. adcc supports frozen-core and frozen-virtual,; # spin-specific states or spin-flip methods.; # But as far as I (mfherbst) know the BUILTIN ADC routine only supports; # singlet states and without freezing some core or some virtual orbitals. func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module in {'ADCC', ''} and extras.addons(""adcc""):; func = run_adcc; elif module in {'BUILTIN', ''}:; func = run_adc. if reference == 'UHF':; if mtd_type == 'CONV':; if module in ['ADCC', ''] and extras.addons(""adcc""):; func = run_adcc. # Note: ROHF is theoretically available in adcc, but are not fully tested; # ... so will be added later. if",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:30455,energy,energy,30455,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,2,['energy'],['energy']
Energy Efficiency,"a Method Alias. Defining a Method Alias¶. Note; No recompile of the PSI4 program is necessary for changes made to; files in $PSIDATADIR aka psi4/psi4/share/psi4, including those described below. Caution; As of 1.0, the below, while essentially still correct, is so aged; as to be difficult to follow. Since quantum chemical methods in PSI4 are accessed through Python functions, and; most important quantities are available as PSI variables, it is straightforward; to create aliases to commonly run calculations or to define hybrid methods. The; psi4/psi4/driver/aliases.py file is intended for editing by the user for; this purpose.; As an example, the MP2.5 method; (which admittedly is already built in to PSI4); is the average of MP2 and MP3. The latter is; available through the arbitrary order MPn code and returns all lower energies; along with it in PSI variables. The following is basic code that will compute; and return the MP2.5 energy.; def run_mp2_5(name, **kwargs):. energy('mp3', **kwargs); e_scf = psi4.get_variable('SCF TOTAL ENERGY'); ce_mp2 = psi4.get_variable('MP2 CORRELATION ENERGY'); ce_mp3 = psi4.get_variable('MP3 CORRELATION ENERGY'). ce_mp25 = 0.5 * (ce_mp2 + ce_mp3); e_mp25 = e_scf + ce_mp25. print """""" MP2.5 total energy: %16.8f\n"""""" % (e_mp25); print """""" MP2.5 correlation energy: %16.8f\n"""""" % (ce_mp25). return e_mp25. Compare the above to the method that resides in psi4/psi4/driver/aliases.py.; The rationale for the changes is indicated in the comments below.; def run_mp2_5(name, **kwargs):; lowername = name.lower() # handy variable with name keyword in lowercase; kwargs = kwargs_lower(kwargs) # removes case sensitivity in keyword names. # Run detci calculation and collect conventional quantities; energy('mp3', **kwargs); e_scf = psi4.get_variable('SCF TOTAL ENERGY'); ce_mp2 = psi4.get_variable('MP2 CORRELATION ENERGY'); ce_mp3 = psi4.get_variable('MP3 CORRELATION ENERGY'); e_mp2 = e_scf + ce_mp2 # reform mp2 and mp3 total energies for printing; e_mp3 = ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/quickaddalias-1.html:1128,energy,energy,1128,psi4manual/1.4.0/quickaddalias-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/quickaddalias-1.html,9,['energy'],['energy']
Energy Efficiency,"a an interface to the adcc python module.; After a more general introduction, specific aspects of the implementation will be highlighted; in section Interface to adcc. ADC capabilities of Psi4¶. Method; References; Exc. Energies; Props; Supported values for kind keyword. ADC(1); RHF, UHF; yes; yes; any, singlet, triplet, spin_flip. ADC(2); RHF, UHF; yes; yes; any, singlet, triplet, spin_flip. ADC(2)-x; RHF, UHF; yes; yes; any, singlet, triplet, spin_flip. ADC(3); RHF, UHF; yes; yes | any, singlet, triplet, spin_flip. CVS-ADC(1); RHF, UHF; yes; yes | any, singlet, triplet. CVS-ADC(2); RHF, UHF; yes; yes; any, singlet, triplet. CVS-ADC(2)-x; RHF, UHF; yes; yes; any, singlet, triplet. CVS-ADC(3); RHF, UHF; yes; yes; any, singlet, triplet. The leftmost column of table ADC capabilities of Psi4 provides the supported ADC methods.; If only excitation energies are desired, one can simply pass one; of the listed method strings to the function energy().; For example, energy('adc(2)-x') will compute; excitation energies at ADC(2)-x level.; Properties such as oscillator strengths, transition or state dipole moments; are available by calling the function properties(); with appropriate arguments.; Most commonly users will want to compute at least oscillator strengths; along with the excitation energies,; resulting in a call like properties('adc(2)', properties=[""oscillator_strength""]). Running ADC calculations¶; Section author: Michael F. Herbst; Running an ADC calculation with PSI4 requires; the call to properties() as discussed above; as well as one or more mandatory keyword arguments.; The most important keyword argument is ROOTS_PER_IRREP,; which is an array with the number of excited states desired; for each irreducible representation. Most ADC methods; are only supported at C1 symmetry at the moment, such that; this option should in most cases be set to an array with a single; element only. For example one can run an ADC(2) calculation for 10; (singlet) excited states using",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/adc.html:4260,energy,energy,4260,psi4manual/1.7.x/adc.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/adc.html,4,['energy'],['energy']
Energy Efficiency,"a basis set extrapolation formula to scalars and optionally to; NumPy arrays. See psi4/psi4/driver/driver_cbs_helper.py and pywrap-cbs1 for; examples. The name of the function should follow the pattern <scf|corl>_xtpl_<scientist>_<#basis>. Aliases¶; When a particular composite method or its functional form is going to be; reused often, it is convenient to define an alias to it. A convenient; place for such Python code to reside is in psi4/psi4/driver/aliases.py; Some existing examples are below. psi4.driver.aliases.sherrill_gold_standard(**kwargs)[source]¶; Function to call the quantum chemical method known as ‘Gold Standard’; in the Sherrill group. Uses the composite wrapper to evaluate; the following expression. Two-point extrapolation of the correlation energy; performed according to corl_xtpl_helgaker_2().; :rtype: List[Dict[str, Any]]. \[E_{total}^{\text{Au\_std}} = E_{total,\; \text{SCF}}^{\text{aug-cc-pVQZ}} \; + E_{corl,\; \text{MP2}}^{\text{aug-cc-pV[TQ]Z}} \; + \delta_{\text{MP2}}^{\text{CCSD(T)}}\big\vert_{\text{aug-cc-pVTZ}}\]; >>> # [1] single-point energy by this composite method; >>> energy('sherrill_gold_standard'). >>> # [2] finite-difference geometry optimization; >>> optimize('sherrill_gold_standard'). >>> # [3] finite-difference geometry optimization, overwriting some pre-defined sherrill_gold_standard options; >>> optimize('sherrill_gold_standard', corl_basis='cc-pV[DT]Z', delta_basis='3-21g'). Return type:; List[Dict[str, Any]]. psi4.driver.aliases.allen_focal_point(**kwargs)[source]¶; Function to call Wes Allen-style Focal; Point Analysis. JCP 127 014306, https://doi.org/10.1063/1.2747241 .; Uses the composite wrapper to evaluate the following; expression. SCF employs a three-point extrapolation according; to scf_xtpl_helgaker_3(). MP2, CCSD, and; CCSD(T) employ two-point extrapolation performed according to; corl_xtpl_helgaker_2(). CCSDT and CCSDT(Q); are plain deltas. This wrapper requires Kallay’s MRCC code.; :rtype: List[Dict[str, Any]]. \[",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/cbs.html:30932,energy,energy,30932,psi4manual/1.8.x/cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/cbs.html,6,['energy'],['energy']
Energy Efficiency,"a breadth-first search (BFS) on the real atoms; | in molecule, returning an array of atom indices of fragments.; | Relies upon van der Waals radii and so faulty for close; | (esp. hydrogen-bonded) fragments. Original code from; | Michael S. Marshall.; | ; | Z(...); | Z( (Molecule)arg1, (int)arg2) -> float :; | Nuclear charge of atom; | ; | __getattr__ = new_get_attr(self, name); | Function to redefine get_attr method of molecule class.; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | __setattr__ = new_set_attr(self, name, value); | Function to redefine set_attr method of molecule class.; | ; | activate_all_fragments(...); | activate_all_fragments( (Molecule)arg1) -> None :; | Sets all fragments in the molecule to be active; | ; | add_atom(...); | add_atom( (Molecule)arg1, (int)arg2, (float)arg3, (float)arg4, (float)arg5, (str)arg6, (float)arg7, (float)arg8, (int)arg9) -> None :; | Adds to Molecule arg1 an atom with atomic number arg2, Cartesian coordinates in Bohr (arg3, arg4, arg5), atomic symbol arg6, mass arg7, charge arg8 (optional), and lineno arg9 (optional); | ; | atom_at_position(...); | atom_at_position( (Molecule)arg1, (float)arg2, (float)arg3) -> int :; | Tests to see if an atom is at the position arg2 with a given tolerance arg3; | ; | center_of_mass(...); | center_of_mass( (Molecule)arg1) -> Vector3 :; | Computes center of mass of molecule (does not translate molecule); | ; | charge(...); | charge( (Molecule)arg1, (int)arg2) -> float :; | Gets charge of atom; | ; | clone(...); | clone( (Molecule)arg1) -> Molecule :; | Returns a new Molecule identical to arg1; | ; | deactivate_all_fragments(...); | deactivate_all_fragments( (Molecule)arg1) -> None :; | Sets all fragments in the molecule to be inactive; | ; | extract_subsets(...); | extract_subsets( (Molecule)arg1, (list)arg2, (list)arg3) -> Molecule :; | Returns copy of arg1 with arg2 fragments Real and arg3 fragments Ghost; | ; | ext",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/psimod-1.html:52731,charge,charge,52731,psi4manual/4.0b3/psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod-1.html,4,['charge'],['charge']
Energy Efficiency,"a cc-pVDZ basis set.; Now, here comes the real beauty of running Psi4 interactively: above, when we computed the energy of H\(_2\)O with HF/cc-pVDZ, we defined the Psi4 molecule object h2o. Since we’re still in the Python shell, as long as you executed that block of code, we can reuse the h2o molecule object in our optimization without redefining it, by adding the molecule=h2o argument to the psi4.optimize(); API function:. [5]:. psi4.set_options({'reference': 'rhf'}); psi4.optimize('scf/cc-pvdz', molecule=h2o). Optimizer: Optimization complete!. [5]:. -76.02703272937504. This should perform a series of gradient computations. The gradient points which way is downhill in energy, and the optimizer then modifies the geometry to follow the gradient. After a few cycles, the geometry should converge with a message like Optimization complete!. As indicated in the following table (printed by the optimizer at the end of the computation and grep-able with ~), the energy decreases with each step, and the maximum force on each atom also decreases with each step (in; principle, these numbers could increase in some iterations, but here they do not).; --------------------------------------------------------------------------------------------------------------- ~  Step         Total Energy             Delta E       MAX Force       RMS Force        MAX Disp        RMS Disp  ~ --------------------------------------------------------------------------------------------------------------- ~     1     -76.026632734908    -76.026632734908      0.01523518      0.01245755      0.02742222      0.02277530  ~     2     -76.027022666011     -0.000389931104      0.00178779      0.00142946      0.01008137      0.00594928  ~     3     -76.027032729374     -0.000010063363      0.00014019      0.00008488      0.00077463      0.00044738  ~ --------------------------------------------------------------------------------------------------------------- ~; To get harmonic vibrational frequencies, it’s i",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/psiapi-1.html:7872,energy,energy,7872,psi4manual/1.3.2/psiapi-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/psiapi-1.html,9,['energy'],['energy']
Energy Efficiency,"a cc-pVDZ basis set.; Now, here comes the real beauty of running Psi4 interactively: above, when we computed the energy of H\(_2\)O with HF/cc-pVDZ, we defined the Psi4 molecule object h2o. Since we’re still in the Python shell, as long as you executed that block of code, we can reuse the h2o molecule object in our optimization without redefining it, by adding the molecule=h2o argument to the psi4.optimize(); API function:. [5]:. psi4.set_options({'reference': 'rhf'}); psi4.optimize('scf/cc-pvdz', molecule=h2o). Optimizer: Optimization complete!. [5]:. -76.02703272937504. This should perform a series of gradient computations. The gradient points which way is downhill in energy, and the optimizer then modifies the geometry to follow the gradient. After a few cycles, the geometry should converge with a message like Optimization complete!. As indicated in the following table (printed by the optimizer at the end of the computation and grep-able with ~), the energy decreases with each step, and the maximum force on each atom also decreases with each step; (in principle, these numbers could increase in some iterations, but here they do not).; --------------------------------------------------------------------------------------------------------------- ~; Step Total Energy Delta E MAX Force RMS Force MAX Disp RMS Disp ~; --------------------------------------------------------------------------------------------------------------- ~; 1 -76.026632734908 -76.026632734908 0.01523518 0.01245755 0.02742222 0.02277530 ~; 2 -76.027022666011 -0.000389931104 0.00178779 0.00142946 0.01008137 0.00594928 ~; 3 -76.027032729374 -0.000010063363 0.00014019 0.00008488 0.00077463 0.00044738 ~; --------------------------------------------------------------------------------------------------------------- ~. To get harmonic vibrational frequencies, it’s important to keep in mind that the values of the vibrational frequencies are a function of the molecular geometry. Therefore, it’s important ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/psiapi.html:7746,energy,energy,7746,psi4manual/1.9.x/psiapi.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/psiapi.html,2,['energy'],['energy']
Energy Efficiency,"a compound single-point energy.; If a nested series of python functions is intended; (see :ref:`sec:intercalls`), use keyword ``cp_func`` instead of ``func``. :type check_bsse: :ref:`boolean <op_py_boolean>`; :param check_bsse: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether to additionally compute un-counterpoise corrected; monomers and thus obtain an estimate for the basis set superposition error. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :examples:. >>> # [1] counterpoise-corrected mp2 interaction energy; >>> cp('df-mp2'). """"""; lowername = name.lower(); kwargs = p4util.kwargs_lower(kwargs). # Wrap any positional arguments into kwargs (for intercalls among wrappers); if not('name' in kwargs) and name:; kwargs['name'] = name.lower(). # Establish function to call; if not('cp_func' in kwargs):; if ('func' in kwargs):; kwargs['cp_func'] = kwargs['func']; del kwargs['func']; else:; kwargs['cp_func'] = energy; func = kwargs['cp_func']; if not func:; raise ValidationError('Function \'%s\' does not exist to be called by wrapper counterpoise_correct.' % (func.__name__)); if (func is db):; raise ValidationError('Wrapper counterpoise_correct is unhappy to be calling function \'%s\'.' % (func.__name__)). if 'check_bsse' in kwargs and yes.match(str(kwargs['check_bsse'])):; check_bsse = True; else:; check_bsse = False. # Make sure the molecule the user provided is the active one; if 'molecule' in kwargs:; activate(kwargs['molecule']); del kwargs['molecule']; molecule = psi4.get_active_molecule(); molecule.update_geometry(); psi4.set_global_option(""BASIS"", psi4.get_global_option(""BASIS"")). df_ints_io = psi4.get_global_option('DF_INTS_IO'); # inquire if above at all applies to dfmp2 or just scf; psi4.set_global_option('DF_INTS_IO', 'SAVE'); psioh = psi4.IOManager.shared_object(); psioh.set_specific_retention(97, True). activate(molecule); molecule.update_geometry(). psi4.print_out(""\",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:19244,energy,energy,19244,psi4manual/4.0b5/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html,2,['energy'],['energy']
Energy Efficiency,"a correction to the; correlation energy, and a second delta correction, etc.. Each is activated by its; stage_wfn keyword and is only allowed if all preceding stages are active. Here, is an energy or energy extrapolation scheme, and the following also hold. A translation of this ungainly equation to example [5] below is as; follows. In words, this is a double- and triple-zeta 2-point; Helgaker-extrapolated CCSD(T) coupled-cluster correlation correction; appended to a triple- and quadruple-zeta 2-point; Helgaker-extrapolated MP2 correlation energy appended to a SCF/aug-cc-pVQZ; reference energy. Energy Methods; The presence of a stage_wfn keyword is the indicator to incorporate; (and check for stage_basis and stage_scheme keywords) and compute; that stage in defining the CBS energy.; The cbs() function requires, at a minimum, name='scf' and scf_basis; keywords to be specified for reference-step only jobs and name and; corl_basis keywords for correlated jobs.; The following energy methods have been set up for cbs(). scf; mp2; mp2.5; mp3; mp4(sdq); mp4; mpn; omp2. omp2.5; omp3; olccd; lccd; lccsd; cepa(0); cepa(1); cepa(3). acpf; aqcc; qcisd; cc2; ccsd; fno-ccsd; bccd. cc3; qcisd(t); ccsd(t); fno-ccsd(t); bccd(t); cisd; cisdt. cisdtq; cin; fci; mrccsd; mrccsd(t); mrccsdt; mrccsdt(q). Parameters:; name (string) – 'scf' || 'ccsd' || etc.; First argument, usually unlabeled. Indicates the computational method; for the correlation energy, unless only reference step to be performed,; in which case should be 'scf'. Overruled if stage_wfn keywords supplied. scf_wfn (string) – 'scf' || 'c4-scf' || etc.; Indicates the energy method for which the reference energy is to be; obtained. Generally unnecessary, as ‘scf’ is the scf in Psi4 but; can be used to direct lone scf components to run in Psi4 or Cfour; in a mixed-program composite method. corl_wfn (string) – 'mp2' || 'ccsd(t)' || etc.; Indicates the energy method for which the correlation energy is to be; obtained. Can also be s",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/cbs-1.html:2513,energy,energy,2513,psi4manual/1.0.0/cbs-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/cbs-1.html,2,['energy'],['energy']
Energy Efficiency,"a correction to the; correlation energy, and a second delta correction, etc.. Each is activated by its; stage_wfn keyword and is only allowed if all preceding stages are active. Here, is an energy or energy extrapolation scheme, and the following also hold. A translation of this ungainly equation to example [5] below is as; follows. In words, this is a double- and triple-zeta 2-point; Helgaker-extrapolated CCSD(T) coupled-cluster correlation correction; appended to a triple- and quadruple-zeta 2-point; Helgaker-extrapolated MP2 correlation energy appended to a SCF/aug-cc-pVQZ; reference energy. Energy Methods; The presence of a stage_wfn keyword is the indicator to incorporate; (and check for stage_basis and stage_scheme keywords) and compute; that stage in defining the CBS energy.; The cbs() function requires, at a minimum, name='scf' and scf_basis; keywords to be specified for reference-step only jobs and name and; corl_basis keywords for correlated jobs.; The following energy methods have been set up for cbs(). scf; mp2; mp2.5; mp3; mp4(sdq); mp4; omp2. omp3; ocepa; cepa0; cepa(0); cepa(1); cepa(3); acpf. aqcc; qcisd; cc2; ccsd; fno-df-ccsd; bccd; cc3. qcisd(t); ccsd(t); fno-df-ccsd(t); bccd(t); cisd; cisdt; cisdtq. cin; fci; mrccsd; mrccsd(t); mrccsdt; mrccsdt(q). Parameters:; name (string) – 'scf' || 'ccsd' || etc.; First argument, usually unlabeled. Indicates the computational method; for the correlation energy, unless only reference step to be performed,; in which case should be 'scf'. Overruled if stage_wfn keywords supplied. corl_wfn (string) – 'mp2' || 'ccsd(t)' || etc.; Indicates the energy method for which the correlation energy is to be; obtained. Can also be specified with name or as the unlabeled; first argument to the function. delta_wfn (string) – 'ccsd' || 'ccsd(t)' || etc.; Indicates the (superior) energy method for which a delta correction; to the correlation energy is to be obtained. delta_wfn_lesser (string) – 'mp2' || 'ccsd' || etc.; Indicates",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/cbs-1.html:2710,energy,energy,2710,psi4manual/4.0b5/cbs-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/cbs-1.html,2,['energy'],['energy']
Energy Efficiency,"a delta correction to the; correlation energy, and a second delta correction. Each is activated by its; stage_wfn keyword and is only allowed if all preceding stages are active. Here, is an energy or energy extrapolation scheme, and the following also hold. A translation of this ungainly equation to example [5] below is as; follows. In words, this is a double- and triple-zeta 2-point; Helgaker-extrapolated CCSD(T) coupled-cluster correlation correction; appended to a triple- and quadruple-zeta 2-point; Helgaker-extrapolated MP2 correlation energy appended to a SCF/aug-cc-pVQZ; reference energy. Energy Methods; The presence of a stage_wfn keyword is the indicator to incorporate; (and check for stage_basis and stage_scheme keywords) and compute; that stage in defining the CBS energy.; The cbs() function requires, at a minimum, name='scf' and scf_basis; keywords to be specified for reference-step only jobs and name and; corl_basis keywords for correlated jobs.; The following energy methods have been set up for cbs(). scf; df-scf. mp2; df-mp2. cc2; ccsd. bccd; cc3. ccsd(t); fci. Parameters:; name (string) – 'scf' || 'ccsd' || etc.; First argument, usually unlabeled. Indicates the computational method; for the correlation energy, unless only reference step to be performed,; in which case should be 'scf'. Overruled if stage_wfn keywords supplied. corl_wfn (string) – 'mp2' || 'ccsd(t)' || etc.; Indicates the energy method for which the correlation energy is to be; obtained. Can also be specified with name or as the unlabeled; first argument to the function. delta_wfn (string) – 'ccsd' || 'ccsd(t)' || etc.; Indicates the (superior) energy method for which a delta correction; to the correlation energy is to be obtained. delta_wfn_lesser (string) – 'mp2' || 'ccsd' || etc.; Indicates the inferior energy method for which a delta correction; to the correlation energy is to be obtained. delta2_wfn (string) – 'ccsd' || 'ccsd(t)' || etc.; Indicates the (superior) energy method for ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/cbs-1.html:2482,energy,energy,2482,psi4manual/4.0b2/cbs-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/cbs-1.html,2,['energy'],['energy']
Energy Efficiency,"a delta correction to the; correlation energy, and a second delta correction. Each is activated by its; stage_wfn keyword and is only allowed if all preceding stages are active. Here, is an energy or energy extrapolation scheme, and the following also hold. A translation of this ungainly equation to example [5] below is as; follows. In words, this is a double- and triple-zeta 2-point; Helgaker-extrapolated CCSD(T) coupled-cluster correlation correction; appended to a triple- and quadruple-zeta 2-point; Helgaker-extrapolated MP2 correlation energy appended to a SCF/aug-cc-pVQZ; reference energy. Energy Methods; The presence of a stage_wfn keyword is the indicator to incorporate; (and check for stage_basis and stage_scheme keywords) and compute; that stage in defining the CBS energy.; The cbs() function requires, at a minimum, name='scf' and scf_basis; keywords to be specified for reference-step only jobs and name and; corl_basis keywords for correlated jobs.; The following energy methods have been set up for cbs(). scf; df-scf; mp2. df-mp2; cc2; ccsd. bccd; cc3; ccsd(t). cisd; cisdt; cisdtq. cin; fci. Parameters:; name (string) – 'scf' || 'ccsd' || etc.; First argument, usually unlabeled. Indicates the computational method; for the correlation energy, unless only reference step to be performed,; in which case should be 'scf'. Overruled if stage_wfn keywords supplied. corl_wfn (string) – 'mp2' || 'ccsd(t)' || etc.; Indicates the energy method for which the correlation energy is to be; obtained. Can also be specified with name or as the unlabeled; first argument to the function. delta_wfn (string) – 'ccsd' || 'ccsd(t)' || etc.; Indicates the (superior) energy method for which a delta correction; to the correlation energy is to be obtained. delta_wfn_lesser (string) – 'mp2' || 'ccsd' || etc.; Indicates the inferior energy method for which a delta correction; to the correlation energy is to be obtained. delta2_wfn (string) – 'ccsd' || 'ccsd(t)' || etc.; Indicates the (su",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/cbs-1.html:2621,energy,energy,2621,psi4manual/4.0b3/cbs-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/cbs-1.html,2,['energy'],['energy']
Energy Efficiency,"a delta correction to the; correlation energy, and a second delta correction. Each is activated by its; stage_wfn keyword and is only allowed if all preceding stages are active. Here, is an energy or energy extrapolation scheme, and the following also hold. A translation of this ungainly equation to example [5] below is as; follows. In words, this is a double- and triple-zeta 2-point; Helgaker-extrapolated CCSD(T) coupled-cluster correlation correction; appended to a triple- and quadruple-zeta 2-point; Helgaker-extrapolated MP2 correlation energy appended to a SCF/aug-cc-pVQZ; reference energy. Energy Methods; The presence of a stage_wfn keyword is the indicator to incorporate; (and check for stage_basis and stage_scheme keywords) and compute; that stage in defining the CBS energy.; The cbs() function requires, at a minimum, name='scf' and scf_basis; keywords to be specified for reference-step only jobs and name and; corl_basis keywords for correlated jobs.; The following energy methods have been set up for cbs(). scf; mp2; mp2.5; mp3; mp4(sdq); mp4. omp2; omp3; ocepa; cepa0; cepa(0); cepa(1). cepa(3); acpf; aqcc; qcisd; cc2; ccsd. fno-df-ccsd; bccd; cc3; qcisd(t); ccsd(t); fno-df-ccsd(t). bccd(t); cisd; cisdt; cisdtq; cin; fci. Parameters:; name (string) – 'scf' || 'ccsd' || etc.; First argument, usually unlabeled. Indicates the computational method; for the correlation energy, unless only reference step to be performed,; in which case should be 'scf'. Overruled if stage_wfn keywords supplied. corl_wfn (string) – 'mp2' || 'ccsd(t)' || etc.; Indicates the energy method for which the correlation energy is to be; obtained. Can also be specified with name or as the unlabeled; first argument to the function. delta_wfn (string) – 'ccsd' || 'ccsd(t)' || etc.; Indicates the (superior) energy method for which a delta correction; to the correlation energy is to be obtained. delta_wfn_lesser (string) – 'mp2' || 'ccsd' || etc.; Indicates the inferior energy method for which a ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/cbs-1.html:2497,energy,energy,2497,psi4manual/4.0b4/cbs-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/cbs-1.html,2,['energy'],['energy']
Energy Efficiency,"a developer a coffee. This function at present has a limited functionality.; Consult the keywords sections of other modules for further property capabilities. Name; Calls Method; Reference; Supported Properties. scf; Self-consistent field method(s); RHF/ROHF/UHF; Listed here. hf; HF Self-consistent field method(s); RHF/ROHF/UHF; Listed here. mp2; MP2 with density fitting only (mp2_type df); RHF; Listed here. cc2; 2nd-order approximate CCSD; RHF; dipole, quadrupole, polarizability, rotation, roa_tensor. ccsd; Coupled cluster singles and doubles (CCSD); RHF; dipole, quadrupole, polarizability, rotation, roa_tensor. eom-cc2; 2nd-order approximate EOM-CCSD; RHF; oscillator_strength, rotational_strength. eom-ccsd; Equation-of-motion CCSD (EOM-CCSD); RHF; oscillator_strength, rotational_strength. cisd, cisdt,; cisdt, cisdtq,; ci5, ..., fci; Configuration interaction; RHF/ROHF; Listed here, transition_dipole,; transition_quadrupole. casscf, rasscf; Multi-configurational SCF; RHF/ROHF; Listed here, transition_dipole,; transition_quadrupole. Parameters:; name (string) – 'ccsd' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the system. properties (array of strings) – [] || ['rotation', 'polarizability', 'oscillator_strength', 'roa'] || etc.; Indicates which properties should be computed. Defaults to dipole and quadrupole. molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. Examples:. >>> # [1] Optical rotation calculation; >>> property('cc2', properties=['rotation']). Previous topic; Single-Point Energy, energy(); Next topic; Counterpoise Correct. This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; Psi4 [1.0.0 6a9a71b] » ; Psithon Functions: Invoking a Calculation ». © Copyright 2016, The Psi4 Project.; Last updated on Tuesday, 05 July 2016 02:54AM.; Created using Sphinx 1.3.5.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/prop-1.html:1966,energy,energy,1966,psi4manual/1.0.0/prop-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/prop-1.html,2,['energy'],['energy']
Energy Efficiency,"a dispersion correction, this quantity is; equal to SCF TOTAL ENERGY. DFT TOTAL ENERGY¶; The total electronic energy [H] for the requested DFT method,; \(E_{\text{DFT}}\) in Eq. (1). \begin{align*}; E_{\text{DFT}} & = E_{NN} + E_{1e^-} + E_{2e^-} + E_{xc} + E_{\text{-D}} + E_{\text{DH}} \\; & = E_{\text{FCTL}} + E_{\text{-D}} + E_{\text{DH}} \\; & = E_{\text{SCF}} + E_{\text{DH}}; \end{align*}Unless the method is a DFT double-hybrid, this quantity is equal to; SCF TOTAL ENERGY. If the method is neither a; double-hybrid, nor dispersion corrected, this quantity is equal to; DFT FUNCTIONAL TOTAL ENERGY. DFT XC ENERGY¶; The functional energy contribution [H] to the total SCF energy (DFT only).; Quantity \(E_{xc}\) in Eqs. (4) and (1). DISPERSION CORRECTION ENERGY¶; The dispersion correction [H] appended to an underlying functional; when a DFT-D method is requested. Quantity \(E_{\text{-D}}\); in Eqs. (4) and (1). DOUBLE-HYBRID CORRECTION ENERGY¶; The scaled MP2 correlation energy correction [H] appended to an; underlying functional when a DH-DFT method is requested.; Quantity \(E_{\text{DH}}\) in Eq. (1). FCI TOTAL ENERGY¶. FCI CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the full configuration interaction level of theory. HF TOTAL ENERGY¶; The total electronic energy [H] for the Hartree–Fock method, without; any dispersion correction; the first three (or four, since; \(E_{xc} = 0\)) terms in Eq. (4). Quantity \(E_{\text{HF}}\); in Eq. (4). LCC2 (+LMP2) TOTAL ENERGY¶; The total electronic energy [H] for the local CC2 level of theory. LCCSD (+LMP2) TOTAL ENERGY¶; The total electronic energy [H] for the local CCSD level of theory. MP2 TOTAL ENERGY¶. MP2 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the MP2 level of theory. MP2.5 TOTAL ENERGY¶. MP2.5 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the MP2.5 level of theory. MP3 T",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/glossary_psivariables-1.html:12430,energy,energy,12430,psi4manual/1.1.0/glossary_psivariables-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/glossary_psivariables-1.html,6,['energy'],['energy']
Energy Efficiency,"a fit to %d data points\n"" % npoints). # Make sure the molecule the user provided is the active one; molecule = mol if mol is not None else core.get_active_molecule(); molecule.update_geometry(); natoms = molecule.natom(); if natoms != 2:; raise Exception(""The current molecule must be a diatomic for this code to work!""); m1 = molecule.mass(0); m2 = molecule.mass(1). # Optimize the geometry, refitting the surface around each new geometry; core.print_out(""\nOptimizing geometry based on current surface:\n\n"");; re = np.mean(rvals); maxit = 30; thres = 1.0e-9; for i in range(maxit):; derivs = least_squares_fit_polynomial(rvals,energies,localization_point=re); e,g,H = derivs[0:3]; core.print_out("" E = %20.14f, x = %14.7f, grad = %20.14f\n"" % (e, re, g)); if abs(g) < thres:; break; re -= g/H;; if i == maxit-1:; raise ConvergenceError(""diatomic geometry optimization"", maxit); core.print_out("" Final E = %20.14f, x = %14.7f, grad = %20.14f\n"" % (e, re, g));; if re < min(rvals):; raise Exception(""Minimum energy point is outside range of points provided. Use a lower range of r values.""); if re > max(rvals):; raise Exception(""Minimum energy point is outside range of points provided. Use a higher range of r values.""). # Convert to convenient units, and compute spectroscopic constants; d0,d1,d2,d3,d4 = derivs*constants.hartree2aJ; core.print_out(""\nEquilibrium Energy %20.14f Hartrees\n"" % e); core.print_out(""Gradient %20.14f\n"" % g); core.print_out(""Quadratic Force Constant %14.7f MDYNE/A\n"" % d2); core.print_out(""Cubic Force Constant %14.7f MDYNE/A**2\n"" % d3); core.print_out(""Quartic Force Constant %14.7f MDYNE/A**3\n"" % d4). hbar = constants.h / (2.0 * np.pi); mu = ((m1*m2)/(m1+m2))*constants.amu2kg; we = 5.3088375e-11 * np.sqrt(d2/mu); wexe = (1.2415491e-6)*(we/d2)**2 * ((5.0*d3*d3)/(3.0*d2)-d4). # Rotational constant: Be; I = ((m1*m2)/(m1+m2)) * constants.amu2kg * (re * angstrom_to_meter)**2; B = constants.h / (8.0 * np.pi**2 * constants.c * I). # alpha_e and quartic centrif",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/diatomic.html:5009,energy,energy,5009,psi4manual/1.3.2/_modules/psi4/driver/diatomic.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/diatomic.html,2,['energy'],['energy']
Energy Efficiency,"a fit to %d data points\n"" % npoints). # Make sure the molecule the user provided is the active one; molecule = mol if mol is not None else core.get_active_molecule(); molecule.update_geometry(); natoms = molecule.natom(); if natoms != 2:; raise Exception(""The current molecule must be a diatomic for this code to work!""); m1 = molecule.mass(0); m2 = molecule.mass(1). # Optimize the geometry, refitting the surface around each new geometry; core.print_out(""\nOptimizing geometry based on current surface:\n\n"");; re = np.mean(rvals); maxit = 30; thres = 1.0e-9; for i in range(maxit):; derivs = least_squares_fit_polynomial(rvals,energies,localization_point=re); e,g,H = derivs[0:3]; core.print_out("" E = %20.14f, x = %14.7f, grad = %20.14f\n"" % (e, re, g)); if abs(g) < thres:; break; re -= g/H;; if i == maxit-1:; raise ConvergenceError(""diatomic geometry optimization"", maxit); core.print_out("" Final E = %20.14f, x = %14.7f, grad = %20.14f\n"" % (e, re, g));; if re < min(rvals):; raise Exception(""Minimum energy point is outside range of points provided. Use a lower range of r values.""); if re > max(rvals):; raise Exception(""Minimum energy point is outside range of points provided. Use a higher range of r values.""). # Convert to convenient units, and compute spectroscopic constants; d0,d1,d2,d3,d4 = derivs*constants.hartree2aJ; core.print_out(""\nEquilibrium Energy %20.14f Hartrees\n"" % e); core.print_out(""Gradient %20.14f\n"" % g); core.print_out(""Quadratic Force Constant %14.7f MDYNE/A\n"" % d2); core.print_out(""Cubic Force Constant %14.7f MDYNE/A**2\n"" % d3); core.print_out(""Quartic Force Constant %14.7f MDYNE/A**3\n"" % d4). hbar = constants.h / (2.0 * pi); mu = ((m1*m2)/(m1+m2))*constants.amu2kg; we = 5.3088375e-11*sqrt(d2/mu); wexe = (1.2415491e-6)*(we/d2)**2 * ((5.0*d3*d3)/(3.0*d2)-d4). # Rotational constant: Be; I = ((m1*m2)/(m1+m2)) * constants.amu2kg * (re * angstrom_to_meter)**2; B = constants.h / (8.0 * pi**2 * constants.c * I). # alpha_e and quartic centrifugal distor",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/diatomic.html:5074,energy,energy,5074,psi4manual/1.1.0/_modules/psi4/driver/diatomic.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/diatomic.html,1,['energy'],['energy']
Energy Efficiency,"a minimum and to allow all options to be used in the presence of all other; options. Below are some rough words of advice about using the SCF code for; practical calculations:. For GUESS, the SAD guess is usually your; friend, even for open-shell systems (at the very least, it gets the right; number of electrons, unlike some other programs). For instance, we have found; that a simple SAD guess is often as good as doing a full SCF in a 3-21G basis; and then performing a cast-up, at a fraction of the cost. However, SAD and; DOCC/SOCC arrays do not play very well together at the moment.; For wall time, DF may be a factor of ten or more faster than the exact; integral technologies available in PSI4.; Use DF unless you need absolute accuracy or do not; have a -JKFIT auxiliary set for your orbital basis/atom type. Then use; DIRECT.; Don’t mess with the DIIS convergence options unless convergence is a problem.; We have optimized the parameters for efficiency over a wide array of system; types.; Buy a developer a beer!. The “best-practice” input file for HF is:; memory 1 GB # As much as you've got, the DF algorithm can use. molecule {; O; H 1 1.0; H 1 1.0 2 104.5; }. set {; basis cc-pvdz; scf_type df; guess sad; ints_tolerance 1.0E-10 # Even this is epically tight, 1.0E-8 is OK; }. energy('scf'). table of contents. HF: Hartree–Fock Theory; Introduction; Theory; Minimal Input; Spin/Symmetry Treatment; Broken Symmetry; Orthogonalization; Initial Guess; Restarting the SCF; Convergence Stabilization; ERI Algorithms; COSX Exchange; LinK Exchange; Second-order Convergence; Stability Analysis; Effective core potentials (ECPs); External potentials and QM/MM; Convergence and Algorithm Defaults; Recommendations. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Theoretical Methods: SCF to FCI; HF: Hartree–Fock Theory. © Copyright 2022, The Psi4 Project.; Last updated on Thursday, 19 May 2022 08:57PM.; Created using Sphinx 4.5.0.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/scf.html:49833,energy,energy,49833,psi4manual/1.6.x/scf.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/scf.html,1,['energy'],['energy']
Energy Efficiency,"a missing feature in adcc; # ... we store this variant here to be able to fall back to MP(2) energies.; is_cvs_adc3 = state.method.level >= 3 and state.ground_state.has_core_occupied_space. # Ground-state energies; mp = state.ground_state; mp_energy = mp.energy(state.method.level if not is_cvs_adc3 else 2); mp_corr = 0.0; if state.method.level > 1:; core.print_out(""Ground state energy breakdown:\n""); core.print_out("" Energy SCF {0:15.8g} [Eh]\n"".format(ref_wfn.energy())); for level in range(2, state.method.level + 1):; if level >= 3 and is_cvs_adc3:; continue; energy = mp.energy_correction(level); mp_corr += energy; adc_wfn.set_variable(f""MP{level} CORRELATION ENERGY"", energy); adc_wfn.set_variable(f""MP{level} TOTAL ENERGY"", mp.energy(level)); core.print_out(f"" Energy correlation MP{level} {energy:15.8g} [Eh]\n""); core.print_out("" Energy total {0:15.8g} [Eh]\n"".format(mp_energy)); adc_wfn.set_variable(""CURRENT CORRELATION ENERGY"", mp_corr) # P::e ADC; adc_wfn.set_variable(""CURRENT ENERGY"", mp_energy) # P::e ADC. # Set results of excited-states computation; # TODO Does not work: Can't use strings; # adc_wfn.set_variable(""excitation kind"", state.kind); adc_wfn.set_variable(""ADC ITERATIONS"", state.n_iter) # P::e ADC; adc_wfn.set_variable(name + "" excitation energies"",; core.Matrix.from_array(state.excitation_energy.reshape(-1, 1))); adc_wfn.set_variable(""number of excited states"", len(state.excitation_energy)). core.print_out(""\n\n ==> Excited states summary <== \n""); core.print_out(""\n"" + state.describe(oscillator_strengths=False) + ""\n""). # TODO Setting the excitation amplitude elements inside the wavefunction is a little; # challenging, since for each excitation vector one needs to extract the elements; # and map the indices from the adcc to the Psi4 convention. For this reason it; # is not yet done. core.print_out(""\n ==> Dominant amplitudes per state <== \n\n""); tol_ampl = core.get_option(""ADC"", ""CUTOFF_AMPS_PRINT""); core.print_out(state.describe_amplitudes(toleran",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html:116201,ENERGY,ENERGY,116201,psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,2,['ENERGY'],['ENERGY']
Energy Efficiency,"a missing feature in adcc; # ... we store this variant here to be able to fall back to MP(2) energies.; is_cvs_adc3 = state.method.level >= 3 and state.ground_state.has_core_occupied_space. # Ground-state energies; mp = state.ground_state; mp_energy = mp.energy(state.method.level if not is_cvs_adc3 else 2); mp_corr = 0.0; if state.method.level > 1:; core.print_out(""Ground state energy breakdown:\n""); core.print_out("" Energy SCF {0:15.8g} [Eh]\n"".format(ref_wfn.energy())); for level in range(2, state.method.level + 1):; if level >= 3 and is_cvs_adc3:; continue; energy = mp.energy_correction(level); mp_corr += energy; adc_wfn.set_variable(f""MP{level} CORRELATION ENERGY"", energy); adc_wfn.set_variable(f""MP{level} TOTAL ENERGY"", mp.energy(level)); core.print_out(f"" Energy correlation MP{level} {energy:15.8g} [Eh]\n""); core.print_out("" Energy total {0:15.8g} [Eh]\n"".format(mp_energy)); adc_wfn.set_variable(""CURRENT CORRELATION ENERGY"", mp_corr) # P::e ADC; adc_wfn.set_variable(""CURRENT ENERGY"", mp_energy) # P::e ADC. # Set results of excited-states computation; # TODO Does not work: Can't use strings; # adc_wfn.set_variable(""excitation kind"", state.kind); adc_wfn.set_variable(""number of excited states"", len(state.excitation_energy)); adc_wfn.set_variable(""ADC ITERATIONS"", state.n_iter) # P::e ADC; methods = [name.upper(), 'ADC']; for excitation in state.excitations:; root_index = excitation.index + 1; for method in methods:; adc_wfn.set_variable(f""{method} ROOT 0 (A) -> ROOT {root_index} (A) EXCITATION ENERGY"",; excitation.excitation_energy); adc_wfn.set_variable(f""{method} ROOT 0 (IN A) -> ROOT {root_index} (IN A) EXCITATION ENERGY"",; excitation.excitation_energy); adc_wfn.set_variable(f""{method} ROOT 0 -> ROOT {root_index} EXCITATION ENERGY"",; excitation.excitation_energy); adc_wfn.set_variable(f""{method} ROOT 0 -> ROOT {root_index} EXCITATION ENERGY - A TRANSITION"",; excitation.excitation_energy). core.print_out(""\n\n ==> Excited states summary <== \n""); core.print_out",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:118478,ENERGY,ENERGY,118478,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,5,['ENERGY'],['ENERGY']
Energy Efficiency,"a new wavefunction with internal data converted to \(C_1\) symmetry, using pre-c1-constructed basis. compute(self, arg0); Computes the density-fitted EP2 energy for the input orbitals. compute_energy(self); Computes the energy of the Wavefunction. compute_gradient(self); Computes the gradient of the Wavefunction. compute_hessian(self); Computes the Hessian of the Wavefunction. deep_copy(self, arg0); Deep copies the internal data. del_array_variable(self, arg0); Removes the requested (case-insensitive) Matrix QC variable. del_potential_variable(self, arg0); Removes the requested (case-insensitive) ExternalPotential QC variable. del_scalar_variable(self, arg0); Removes the requested (case-insensitive) double QC variable. del_variable(key); Removes scalar or array QCVariable key from cls if present. density_fitted(self); Returns whether this wavefunction was obtained using density fitting or not. doccpi(self); Returns the number of doubly occupied orbitals per irrep. efzc(self); Returns the frozen-core energy. energy(self); Returns the Wavefunction's energy. epsilon_a(self); Returns the Alpha Eigenvalues. epsilon_a_subset(self, basis, subset); Returns the requested Alpha orbital energies subset. epsilon_b(self); Returns the Beta Eigenvalues. epsilon_b_subset(self, basis, subset); Returns the requested Beta orbital energies subset. esp_at_nuclei(self); returns electrostatic potentials at nuclei. external_pot(self); Gets the requested external potential. force_doccpi(self, arg0); Specialized expert use only. force_soccpi(self, arg0); Specialized expert use only. frequencies(). from_file(wfn_data); Build Wavefunction from data. frzcpi(self); Returns the number of frozen core orbitals per irrep. frzvpi(self); Returns the number of frozen virtual orbitals per irrep. get_array(key). Deprecated since version 1.4. get_basisset(self, arg0); Returns the requested auxiliary basis. get_density(self, arg0); Experimental!. get_dipole_field_strength(self); Returns a vector of length ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/api/psi4.core.DFEP2Wavefunction.html:2940,energy,energy,2940,psi4manual/1.6.x/api/psi4.core.DFEP2Wavefunction.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/api/psi4.core.DFEP2Wavefunction.html,2,['energy'],['energy']
Energy Efficiency,"a new wavefunction with internal data converted to \(C_1\) symmetry, using pre-c1-constructed basis. compute(self, arg0); Computes the density-fitted EP2 energy for the input orbitals. compute_energy(self); Computes the energy of the Wavefunction. compute_gradient(self); Computes the gradient of the Wavefunction. compute_hessian(self); Computes the Hessian of the Wavefunction. deep_copy(self, arg0); Deep copies the internal data. del_array_variable(self, arg0); Removes the requested (case-insensitive) Matrix QC variable. del_potential_variable(self, arg0); Removes the requested (case-insensitive) ExternalPotential QC variable. del_scalar_variable(self, arg0); Removes the requested (case-insensitive) double QC variable. del_variable(key); Removes scalar or array QCVariable key from cls if present. density_fitted(self); Returns whether this wavefunction was obtained using density fitting or not. doccpi(self); Returns the number of doubly occupied orbitals per irrep. efzc(self); Returns the frozen-core energy. energy(self); Returns the Wavefunction's energy. epsilon_a(self); Returns the Alpha Eigenvalues. epsilon_a_subset(self, basis, subset); Returns the requested Alpha orbital energies subset. epsilon_b(self); Returns the Beta Eigenvalues. epsilon_b_subset(self, basis, subset); Returns the requested Beta orbital energies subset. esp_at_nuclei(self); returns electrostatic potentials at nuclei. external_pot(self); Gets the requested external potential. force_doccpi(self, arg0); Specialized expert use only. force_soccpi(self, arg0); Specialized expert use only. frequencies(). from_file(wfn_data); Build Wavefunction from data. frzcpi(self); Returns the number of frozen core orbitals per irrep. frzvpi(self); Returns the number of frozen virtual orbitals per irrep. get_array(key). Deprecated since version 1.4. get_basisset(self, arg0); Returns the requested auxiliary basis. get_dipole_field_strength(self); Returns a vector of length 3, containing the x, y, and z dipole fie",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/api/psi4.core.dfep2wavefunction.html:2933,energy,energy,2933,psi4manual/1.5.0/api/psi4.core.dfep2wavefunction.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/api/psi4.core.dfep2wavefunction.html,2,['energy'],['energy']
Energy Efficiency,"a new wavefunction with internal data converted to \(C_1\) symmetry, using pre-c1-constructed basis. compute(self, arg0); Computes the density-fitted EP2 energy for the input orbitals. compute_energy(self); Computes the energy of the Wavefunction. compute_gradient(self); Computes the gradient of the Wavefunction. compute_hessian(self); Computes the Hessian of the Wavefunction. deep_copy(self, arg0); Deep copies the internal data. del_array_variable(self, arg0); Removes the requested (case-insensitive) Matrix QC variable. del_potential_variable(self, arg0); Removes the requested (case-insensitive) ExternalPotential QC variable. del_scalar_variable(self, arg0); Removes the requested (case-insensitive) double QC variable. del_variable(key); Removes scalar or array QCVariable key from cls if present. density_fitted(self); Returns whether this wavefunction was obtained using density fitting or not. doccpi(self); Returns the number of doubly occupied orbitals per irrep. efzc(self); Returns the frozen-core energy. energy(self); Returns the Wavefunction’s energy. epsilon_a(self); Returns the Alpha Eigenvalues. epsilon_a_subset(self, arg0, arg1); Returns the requested Alpha Eigenvalues subset. epsilon_b(self); Returns the Beta Eigenvalues. epsilon_b_subset(self, arg0, arg1); Returns the requested Beta Eigenvalues subset. esp_at_nuclei(self); returns electrostatic potentials at nuclei. external_pot(self); Gets the requested external potential. force_doccpi(self, arg0); Specialized expert use only. force_soccpi(self, arg0); Specialized expert use only. frequencies(). from_file(wfn_data); Build Wavefunction from data. frzcpi(self); Returns the number of frozen core orbitals per irrep. frzvpi(self); Returns the number of frozen virtual orbitals per irrep. get_array(key). Deprecated since version 1.4. get_basisset(self, arg0); Returns the requested auxiliary basis. get_dipole_field_strength(self); Returns a vector of length 3, containing the x, y, and z dipole field strengths. ge",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/api/psi4.core.dfep2wavefunction.html:2933,energy,energy,2933,psi4manual/1.4.0/api/psi4.core.dfep2wavefunction.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/api/psi4.core.dfep2wavefunction.html,1,['energy'],['energy']
Energy Efficiency,"a package can; be obtained through conda install gcp -c psi4 or conda install; psi4-rt -c psi4. If using PSI4 built from source, and anaconda or miniconda has; already been installed (instructions at Quick Installation),; the gcp executable can be obtained through conda install gcp -c psi4. To remove a conda installation, conda remove gcp. Source. If using PSI4 built from source and you want to build gCP from; from source also, follow the instructions provided with the source; (essentially, download the freely available tarball, unpack the source,; edit the Makefile to select a Fortran compiler, and run make). To be used by PSI4, the program binary (gcp) must be; found in your PSIPATH or PATH (in that order). If; PSI4 is unable to execute the binary, an error will be reported.; To preferentially use a particular gcp compilation, simply adjust its; position in the path environment variables. Running gCP¶; At present there is a limited interface to gCP that is used; only to implement the “HF-3c” [Sure:2013:1672] and “PBEh-3c”; [Grimme:2015:054107] methods (both energy and gradient). The DFTD3 executable must also be available for these methods to; run. Unlike every other method in PSI4, if a basis set has not been; set, these will default to their intended basis sets: MINIX for HF-3c; and def2-mSVP for PBEh-3c. If a basis has previously been set, but you; want to use the default basis, use the slash syntax to “empty” the basis; option for the scope of the current calculation, energy(""hf3c/"").; A few practical examples:. HF-3c single point with default minix basis; 1energy('hf3c'). PBEh-3c optimization with default def2-mSVP basis; 1optimize('pbeh3c'). HF-3c with non-standard basis; 1; 2set basis cc-pvdz; energy('hf3c'). PBEh-3c with default basis after basis set; 1; 2set basis cc-pvdz; energy('pbeh3c/'). If only BSSE/basis set corrections (rather than total energies) are of; interest, the gcp program can be run independently of the scf; through the python function run",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/gcp-1.html:1570,energy,energy,1570,psi4manual/1.2.1/gcp-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/gcp-1.html,4,['energy'],['energy']
Energy Efficiency,"a polynomial, with specified order; to an array of input function values (fvals) evaluated at given locations (xvals).; See https://doi.org/10.1063/1.4862157, particularly eqn (7) for details. """"""; xpts = np.array(xvals) - localization_point; if weighted:; R = 1.0; p_nu = 1; epsilon = 1e-3; zvals = np.square(xpts/R); weights = np.exp(-zvals) / (zvals**p_nu + epsilon**p_nu); else:; weights = None; fit = np.polynomial.polynomial.polyfit(xpts, fvals, polynomial_order, w=weights); # Remove the 1/n! coefficients; if no_factorials:; scalefac = 1.0; for n in range(2,polynomial_order+1):; scalefac *= n; fit[n] *= scalefac; return fit. [docs]def anharmonicity(rvals: List, energies: List, plot_fit: str = '', mol = None) -> Dict:; """"""Generates spectroscopic constants for a diatomic molecules.; Fits a diatomic potential energy curve using a weighted least squares approach; (c.f. https://doi.org/10.1063/1.4862157, particularly eqn. 7), locates the minimum; energy point, and then applies second order vibrational perturbation theory to obtain spectroscopic; constants. Any number of points greater than 4 may be provided, and they should bracket the minimum.; The data need not be evenly spaced, and can be provided in any order. The data are weighted such that; those closest to the minimum have highest impact. A dictionary with the following keys, which correspond to spectroscopic constants, is returned:. :param rvals: The bond lengths (in Angstrom) for which energies are; provided, of length at least 5 and equal to the length of the energies array. :param energies: The energies (Eh) computed at the bond lengths in the rvals list. :param plot_fit: A string describing where to save a plot of the harmonic and anharmonic fits, the; inputted data points, re, r0 and the first few energy levels, if matplotlib; is available. Set to 'screen' to generate an interactive plot on the screen instead. If a filename is; provided, the image type is determined by the extension; see matplotlib for supp",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/diatomic.html:2379,energy,energy,2379,psi4manual/1.4.0/_modules/psi4/driver/diatomic.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/diatomic.html,6,['energy'],['energy']
Energy Efficiency,"a"": False, ""run_ccsd"": False, ""compute_triples"": True, },. ""ccsd"": { ""dfcc"": False, ""run_cepa"": False, ""run_ccsd"": True, ""compute_triples"": False, },; ""fno-ccsd"": {""nat_orbs"": True, ""dfcc"": False, ""run_cepa"": False, ""run_ccsd"": True, ""compute_triples"": False, },. ""ccsd(t)"": { ""dfcc"": False, ""run_cepa"": False, ""run_ccsd"": True, ""compute_triples"": True, },; ""fno-ccsd(t)"": {""nat_orbs"": True, ""dfcc"": False, ""run_cepa"": False, ""run_ccsd"": True, ""compute_triples"": True, },; }. if name not in director:; raise ValidationError(f""Invalid method {name} for FNOCC energy""). # throw exception for open-shells; if (ref := core.get_option(""SCF"", ""REFERENCE"")) != ""RHF"":; raise ValidationError(f""Invalid reference type {ref} != RHF for FNOCC energy. See Capabilities Table at {dtl}""). # throw exception for DF/CD. most of these pre-trapped by select_* functions but some escape, incl. mp4(sdq) and qcisd variants; if (corl_type := method_algorithm_type(name).now) != ""CONV"":; raise ValidationError(f""Invalid type {corl_type} for FNOCC energy through `run_fnocc`. See Capabilities Table at {dtl}""). for k, v in director[name].items():; core.set_local_option(""FNOCC"", k.upper(), v). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. if not core.get_option('FNOCC', 'USE_DF_INTS'):; # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn); else:; core.print_out("" Constructing Basis Sets for FNOCC...\n\n""); scf_aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_SCF"",; core.get_option(""SCF"", ""DF_BASIS_SCF""),; ""JKFIT"", core.get_global_option('BASIS'),; puream=ref_wfn.basisset().has_puream()); ref_wfn.set_basisset(""DF_BASIS_SCF"", scf_aux_basis). if core.get_global_option(""RELATIVISTIC"") in [""X2C"", ""DKH""]:; rel_bas = core.BasisSet.build(ref_wfn.molecule(), ""BASIS_RELATIVISTIC"",; core.get_option(""SCF"", ""BASIS_R",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:173295,energy,energy,173295,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,8,['energy'],['energy']
Energy Efficiency,"a().to_array() if wfn.epsilon_a() else None,; 'epsilon_b': wfn.epsilon_b().to_array() if wfn.epsilon_b() else None,; 'frequencies': wfn.frequencies().to_array() if wfn.frequencies() else None; },; 'dimension': {; 'doccpi': wfn.doccpi().to_tuple(),; 'frzcpi': wfn.frzcpi().to_tuple(),; 'frzvpi': wfn.frzvpi().to_tuple(),; 'nalphapi': wfn.nalphapi().to_tuple(),; 'nbetapi': wfn.nbetapi().to_tuple(),; 'nmopi': wfn.nmopi().to_tuple(),; 'nsopi': wfn.nsopi().to_tuple(),; 'soccpi': wfn.soccpi().to_tuple(); },; 'int': {; 'nalpha': wfn.nalpha(),; 'nbeta': wfn.nbeta(),; 'nfrzc': wfn.nfrzc(),; 'nirrep': wfn.nirrep(),; 'nmo': wfn.nmo(),; 'nso': wfn.nso(),; 'print': wfn.get_print(),; },; 'string': {; 'name': wfn.name(),; 'module': wfn.module(),; 'basisname': wfn.basisset().name(); },; 'boolean': {; 'PCM_enabled': wfn.PCM_enabled(),; 'same_a_b_dens': wfn.same_a_b_dens(),; 'same_a_b_orbs': wfn.same_a_b_orbs(),; 'density_fitted': wfn.density_fitted(),; 'basispuream': wfn.basisset().has_puream(); },; 'float': {; 'energy': wfn.energy(),; 'efzc': wfn.efzc(),; 'dipole_field_x': wfn.get_dipole_field_strength()[0],; 'dipole_field_y': wfn.get_dipole_field_strength()[1],; 'dipole_field_z': wfn.get_dipole_field_strength()[2]; },; 'floatvar': wfn.scalar_variables(),; 'matrixarr': {k: v.to_array() for k, v in wfn.array_variables().items()}; } # yapf: disable. if filename is not None:; if not filename.endswith('.npy'): filename += '.npy'; np.save(filename, wfn_data, allow_pickle=True). return wfn_data. core.Wavefunction.to_file = _core_wavefunction_to_file. ## Python JK helps. @staticmethod; def _core_jk_build(orbital_basis: core.BasisSet, aux: core.BasisSet = None, jk_type: str = None, do_wK: bool = None, memory: int = None) -> core.JK:; """"""; Constructs a Psi4 JK object from an input basis. Parameters; ----------; orbital_basis; Orbital basis to use in the JK object.; aux; Optional auxiliary basis set for density-fitted tensors. Defaults; to the DF_BASIS_SCF if set, otherwise the correspond JKFI",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html:9385,energy,energy,9385,psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html,6,['energy'],['energy']
Energy Efficiency,"a(0). dfomp2p5-grad1; DF-OMP2.5 cc-pVDZ gradients for the H2O molecule. cbs-xtpl-alpha; Extrapolated water energies. omp2-4; SCS-OMP2 cc-pVDZ geometry optimization for the H2O molecule. frac; Carbon/UHF Fractionally-Occupied SCF Test Case. nbody-nocp-gradient; Computation of NoCP-corrected water trimer gradient (geometry from J. Chem. Theory Comput. 11, 2126-2136 (2015)). sapt2; SAPT0 aug-cc-pVDZ computation of the benzene-methane interaction energy, using the aug-pVDZ-JKFIT DF basis for SCF, the aug-cc-pVDZ-RI DF basis for SAPT0 induction and dispersion, and the aug-pVDZ-JKFIT DF basis for SAPT0 electrostatics and induction. This example uses frozen core as well as asyncronous I/O while forming the DF integrals and CPHF coefficients. sapt-exch-ind30-inf; SAPT2+3 with S^inf exch-ind30 Geometries taken from the S66x10 database, the shortest-range point (R = 0.7 R_e). cc42; RHF-CC2-LR/STO-3G optical rotation of (S)-methyloxirane. gauge = length, omega = (589 355 nm). casscf-semi; CASSCF/6-31G** energy point. Check energy with frozen core/virtual orbs. after semicanonicalization. density-screen-2; RKS Density Matrix based-Integral Screening Test for benzene. cc40; RHF-CC2-LR/cc-pVDZ optical rotation of H2O2. gauge = length, omega= (589 355 nm). fci-h2o; 6-31G H2O Test FCI Energy Point. dfremp-1; density fitted REMP/cc-pVDZ energies for the CO2 molecule. omp2-5; SOS-OMP2 cc-pVDZ geometry optimization for the H2O molecule. opt13; B3LYP cc-pVDZ geometry optimzation of phenylacetylene, starting from not quite linear structure updated reference due to new BraggSlater radii. mints9; A test of the basis specification. Various basis sets are specified outright and in blocks, both orbital and auxiliary. Constructs libmints BasisSet objects through the constructor that calls qcdb.BasisSet infrastructure. Checks that the resulting bases are of the right size and checks that symmetry of the Molecule observes the basis assignment to atoms. scf1; RHF cc-pVQZ energy for the BH molecu",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/autodoc_testsuite_corepsi4.html:8421,energy,energy,8421,psi4manual/master/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/master/autodoc_testsuite_corepsi4.html,2,['energy'],['energy']
Energy Efficiency,"a) w/ cp/nocp/vmfc treat. (dep. on 1st of bsse_type|; +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+; | ret_hessian | (nat * 3, nat * 3) | when driver is h | interaction Hessian: IE or total (depending on return_total_data) w/ cp/nocp/vmfc treat. (dep. on 1st of bsse_type)|; +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+; | | | | |; +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+; | nbody | >=1 | always | energy n-body QCVariables to be set |; +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+; | |em| CP-CORRECTED TOTAL ENERGY THROUGH 1-BODY | |em| 1 | when cp in bsse_type | MBE sum of subsystems of 1-body. summed are total energies with cp treatment |; +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+; | |em| CP-CORRECTED TOTAL ENERGY THROUGH 2-BODY | |em| 1 | when cp in bsse_type & max_nbody>=2 | MBE sum of subsystems of 2-body or fewer (cumulative); summ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver_nbody.html:43235,energy,energy,43235,psi4manual/1.6.x/_modules/psi4/driver/driver_nbody.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver_nbody.html,15,"['ENERGY', 'energy']","['ENERGY', 'energy']"
Energy Efficiency,"a). text += """"""\n\n Constant volume heat capacity, Cv""""""; for term in terms:; text += format_S_Cv_Cp.format(terms[term] + ' Cv', *sm[('Cv', term)] * uconv). text += """"""\n\n Constant pressure heat capacity, Cp""""""; for term in terms:; text += format_S_Cv_Cp.format(terms[term] + ' Cp', *sm[('Cp', term)] * uconv). del terms['tot']; terms['corr'] = 'Correction'. text += """"""\n\n ==> Thermochemistry Energy Analysis <=="""""". text += """"""\n\n Raw electronic energy, E0""""""; text += """"""\n Total E0, Electronic energy at well bottom at 0 [K] {:15.8f} [Eh]"""""".format(E0). text += """"""\n\n Zero-point energy, ZPE_vib = Sum_i nu_i / 2""""""; for term in terms:; text += format_ZPE_E_H_G.format(terms[term] + ' ZPE', *sm[('ZPE', term)] * uconv); if term in ['vib', 'corr']:; text += """""" {:15.3f} [cm^-1]"""""".format(sm[('ZPE', term)] * qcel.constants.hartree2wavenumbers); text += """"""\n Total ZPE, Electronic energy at 0 [K] {:15.8f} [Eh]"""""".format(; sm[('ZPE', 'tot')]). text += """"""\n\n Thermal Energy, E (includes ZPE)""""""; for term in terms:; text += format_ZPE_E_H_G.format(terms[term] + ' E', *sm[('E', term)] * uconv); text += """"""\n Total E, Electronic energy at {:7.2f} [K] {:15.8f} [Eh]"""""".format(; T, sm[('E', 'tot')]). text += """"""\n\n Enthalpy, H_trans = E_trans + k_B * T""""""; for term in terms:; text += format_ZPE_E_H_G.format(terms[term] + ' H', *sm[('H', term)] * uconv); text += """"""\n Total H, Enthalpy at {:7.2f} [K] {:15.8f} [Eh]"""""".format(; T, sm[('H', 'tot')]). text += """"""\n\n Gibbs free energy, G = H - T * S""""""; for term in terms:; text += format_ZPE_E_H_G.format(terms[term] + ' G', *sm[('G', term)] * uconv); text += """"""\n Total G, Free enthalpy at {:7.2f} [K] {:15.8f} [Eh]\n"""""".format(; T, sm[('G', 'tot')]). return therminfo, text. [docs]; def filter_nonvib(vibinfo: Dict[str, Datum], remove: List[int] = None) -> Dict[str, Datum]:; """"""From a dictionary of vibration Datum, remove normal coordinates. Parameters; ----------; vibinfo; Results of Hessian analysis.; remove; 0-indexed indices of no",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qcdb/vib.html:37695,Energy,Energy,37695,psi4manual/1.8.x/_modules/psi4/driver/qcdb/vib.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qcdb/vib.html,1,['Energy'],['Energy']
Energy Efficiency,"a). text += """"""\n\n Constant volume heat capacity, Cv""""""; for term in terms:; text += format_S_Cv_Cp.format(terms[term] + ' Cv', *sm[('Cv', term)] * uconv). text += """"""\n\n Constant pressure heat capacity, Cp""""""; for term in terms:; text += format_S_Cv_Cp.format(terms[term] + ' Cp', *sm[('Cp', term)] * uconv). del terms['tot']; terms['corr'] = 'Correction'. text += """"""\n\n ==> Thermochemistry Energy Analysis <=="""""". text += """"""\n\n Raw electronic energy, E0""""""; text += """"""\n Total E0, Electronic energy at well bottom at 0 [K] {:15.8f} [Eh]"""""".format(E0). text += """"""\n\n Zero-point energy, ZPE_vib = Sum_i nu_i / 2""""""; for term in terms:; text += format_ZPE_E_H_G.format(terms[term] + ' ZPE', *sm[('ZPE', term)] * uconv); if term in ['vib', 'corr']:; text += """""" {:15.3f} [cm^-1]"""""".format(sm[('ZPE', term)] * qcel.constants.hartree2wavenumbers); text += """"""\n Total ZPE, Electronic energy at 0 [K] {:15.8f} [Eh]"""""".format(; sm[('ZPE', 'tot')]). text += """"""\n\n Thermal Energy, E (includes ZPE)""""""; for term in terms:; text += format_ZPE_E_H_G.format(terms[term] + ' E', *sm[('E', term)] * uconv); text += """"""\n Total E, Electronic energy at {:7.2f} [K] {:15.8f} [Eh]"""""".format(; T, sm[('E', 'tot')]). text += """"""\n\n Enthalpy, H_trans = E_trans + k_B * T""""""; for term in terms:; text += format_ZPE_E_H_G.format(terms[term] + ' H', *sm[('H', term)] * uconv); text += """"""\n Total H, Enthalpy at {:7.2f} [K] {:15.8f} [Eh]"""""".format(; T, sm[('H', 'tot')]). text += """"""\n\n Gibbs free energy, G = H - T * S""""""; for term in terms:; text += format_ZPE_E_H_G.format(terms[term] + ' G', *sm[('G', term)] * uconv); text += """"""\n Total G, Free enthalpy at {:7.2f} [K] {:15.8f} [Eh]\n"""""".format(; T, sm[('G', 'tot')]). return therminfo, text. [docs]def filter_nonvib(vibinfo: Dict[str, Datum], remove: List[int] = None) -> Dict[str, Datum]:; """"""From a dictionary of vibration Datum, remove normal coordinates. Parameters; ----------; vibinfo; Results of Hessian analysis.; remove; 	 0-indexed indices of no",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/qcdb/vib.html:37681,Energy,Energy,37681,psi4manual/1.4.0/_modules/psi4/driver/qcdb/vib.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/qcdb/vib.html,2,['Energy'],['Energy']
Energy Efficiency,"a). text += """"""\n\n Constant volume heat capacity, Cv""""""; for term in terms:; text += format_S_Cv_Cp.format(terms[term] + ' Cv', *sm[('Cv', term)] * uconv). text += """"""\n\n Constant pressure heat capacity, Cp""""""; for term in terms:; text += format_S_Cv_Cp.format(terms[term] + ' Cp', *sm[('Cp', term)] * uconv). del terms['tot']; terms['corr'] = 'Correction'. text += """"""\n\n ==> Thermochemistry Energy Analysis <=="""""". text += """"""\n\n Raw electronic energy, E0""""""; text += """"""\n Total E0, Electronic energy at well bottom at 0 [K] {:15.8f} [Eh]"""""".format(E0). text += """"""\n\n Zero-point energy, ZPE_vib = Sum_i nu_i / 2""""""; for term in terms:; text += format_ZPE_E_H_G.format(terms[term] + ' ZPE', *sm[('ZPE', term)] * uconv); if term in ['vib', 'corr']:; text += """""" {:15.3f} [cm^-1]"""""".format(sm[('ZPE', term)] * qcel.constants.hartree2wavenumbers); text += """"""\n Total ZPE, Electronic energy at 0 [K] {:15.8f} [Eh]"""""".format(; sm[('ZPE', 'tot')]). text += """"""\n\n Thermal Energy, E (includes ZPE)""""""; for term in terms:; text += format_ZPE_E_H_G.format(terms[term] + ' E', *sm[('E', term)] * uconv); text += """"""\n Total E, Electronic energy at {:7.2f} [K] {:15.8f} [Eh]"""""".format(; T, sm[('E', 'tot')]). text += """"""\n\n Enthalpy, H_trans = E_trans + k_B * T""""""; for term in terms:; text += format_ZPE_E_H_G.format(terms[term] + ' H', *sm[('H', term)] * uconv); text += """"""\n Total H, Enthalpy at {:7.2f} [K] {:15.8f} [Eh]"""""".format(; T, sm[('H', 'tot')]). text += """"""\n\n Gibbs free energy, G = H - T * S""""""; for term in terms:; text += format_ZPE_E_H_G.format(terms[term] + ' G', *sm[('G', term)] * uconv); text += """"""\n Total G, Free enthalpy at {:7.2f} [K] {:15.8f} [Eh]\n"""""".format(; T, sm[('G', 'tot')]). return therminfo, text. [docs]def filter_nonvib(vibinfo: Dict[str, Datum], remove: List[int] = None) -> Dict[str, Datum]:; """"""From a dictionary of vibration Datum, remove normal coordinates. Parameters; ----------; vibinfo; Results of Hessian analysis.; remove; 0-indexed indices of norm",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qcdb/vib.html:37681,Energy,Energy,37681,psi4manual/1.6.x/_modules/psi4/driver/qcdb/vib.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qcdb/vib.html,2,['Energy'],['Energy']
Energy Efficiency,"a). text += """"""\n\n Constant volume heat capacity, Cv""""""; for term in terms:; text += format_S_Cv_Cp.format(terms[term] + ' Cv', *sm[('Cv', term)] * uconv). text += """"""\n\n Constant pressure heat capacity, Cp""""""; for term in terms:; text += format_S_Cv_Cp.format(terms[term] + ' Cp', *sm[('Cp', term)] * uconv). del terms['tot']; terms['corr'] = 'Correction'. text += """"""\n\n ==> Thermochemistry Energy Analysis <=="""""". text += """"""\n\n Raw electronic energy, E0""""""; text += """"""\n Total E0, Electronic energy at well bottom at 0 [K] {:15.8f} [Eh]"""""".format(E0). text += """"""\n\n Zero-point energy, ZPE_vib = Sum_i nu_i / 2""""""; for term in terms:; text += format_ZPE_E_H_G.format(terms[term] + ' ZPE', *sm[('ZPE', term)] * uconv); if term in ['vib', 'corr']:; text += """""" {:15.3f} [cm^-1]"""""".format(sm[('ZPE', term)] * qcel.constants.hartree2wavenumbers); text += """"""\n Total ZPE, Electronic energy at 0 [K] {:15.8f} [Eh]"""""".format(; sm[('ZPE', 'tot')]). text += """"""\n\n Thermal Energy, E (includes ZPE)""""""; for term in terms:; text += format_ZPE_E_H_G.format(terms[term] + ' E', *sm[('E', term)] * uconv); text += """"""\n Total E, Electronic energy at {:7.2f} [K] {:15.8f} [Eh]"""""".format(; T, sm[('E', 'tot')]). text += """"""\n\n Enthalpy, H_trans = E_trans + k_B * T""""""; for term in terms:; text += format_ZPE_E_H_G.format(terms[term] + ' H', *sm[('H', term)] * uconv); text += """"""\n Total H, Enthalpy at {:7.2f} [K] {:15.8f} [Eh]"""""".format(; T, sm[('H', 'tot')]). text += """"""\n\n Gibbs free energy, G = H - T * S""""""; for term in terms:; text += format_ZPE_E_H_G.format(terms[term] + ' G', *sm[('G', term)] * uconv); text += """"""\n Total G, Free enthalpy at {:7.2f} [K] {:15.8f} [Eh]\n"""""".format(; T, sm[('G', 'tot')]). return therminfo, text. def filter_nonvib(vibinfo: Dict[str, Datum], remove: List[int] = None) -> Dict[str, Datum]:; """"""From a dictionary of vibration Datum, remove normal coordinates. Parameters; ----------; vibinfo; Results of Hessian analysis.; remove; 0-indexed indices of normal mod",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/qcdb/vib.html:37615,Energy,Energy,37615,psi4manual/1.6.x/_modules/qcdb/vib.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/qcdb/vib.html,3,['Energy'],['Energy']
Energy Efficiency,"a-level bases.; Used by complete_basis_set(). corl_xtpl_helgaker_2(functionname, zLO, valueLO, zHI, valueHI, verbose=True)[source]¶; Extrapolation scheme for correlation energies with two adjacent zeta-level bases.; Used by complete_basis_set(). Aliases¶; When a particular composite method or its functional form is going to be; reused often, it is convenient to define an alias to it. A convenient; place for such Python code to reside is in psi4/share/python/aliases.py; (source location) or psi4/share/psi/python/aliases.py (installed; location). No recompilation is necessary after defining an alias. Some; existing examples are below. sherrill_gold_standard(func, label, **kwargs)[source]¶; Function to call the quantum chemical method known as ‘Gold Standard’; in the Sherrill group. Uses complete_basis_set() to evaluate; the following expression. Two-point extrapolation of the correlation energy; performed according to corl_xtpl_helgaker_2(). >>> # [1] single-point energy by this composite method; >>> energy('sherrill_gold_standard'). >>> # [2] finite-difference geometry optimization; >>> optimize('sherrill_gold_standard'). >>> # [3] finite-difference geometry optimization, overwriting some pre-defined sherrill_gold_standard options; >>> optimize('sherrill_gold_standard', corl_basis='cc-pV[DT]Z', delta_basis='3-21g'). allen_focal_point(func, label, **kwargs)[source]¶; Function to call Wes Allen-style Focal; Point Analysis. JCP 127 014306. Uses; complete_basis_set() to evaluate the following; expression. SCF employs a three-point extrapolation according; to scf_xtpl_helgaker_3(). MP2, CCSD, and; CCSD(T) employ two-point extrapolation performed according to; corl_xtpl_helgaker_2(). CCSDT and CCSDT(Q); are plain deltas. This wrapper requires Kallay’s MRCC code. >>> # [1] single-point energy by this composite method; >>> energy('allen_focal_point'). >>> # [2] finite-difference geometry optimization embarrasingly parallel; >>> optimize('allen_focal_point', mode='sow'). Tabl",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/cbs-1.html:16861,energy,energy,16861,psi4manual/1.0.0/cbs-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/cbs-1.html,4,['energy'],['energy']
Energy Efficiency,"a0' : run_cepa0_gradient,; 'ocepa' : run_ocepa_gradient; # Upon adding a method to this list, add it to the docstring in optimize() below; },; 'hessian' : {; # Upon adding a method to this list, add it to the docstring in frequency() below; },; 'property' : {; 'scf' : run_scf_property,; 'cc2' : run_cc_property,; 'ccsd' : run_cc_property,; 'df-mp2' : run_dfmp2_property,; 'dfmp2' : run_dfmp2_property,; 'eom-cc2' : run_cc_property,; 'eom-ccsd' : run_cc_property,; # Upon adding a method to this list, add it to the docstring in property() below; }}. # Integrate DFT with driver routines; for ssuper in superfunctional_list():; procedures['energy'][ssuper.name().lower()] = run_dft. for ssuper in superfunctional_list():; if ((not ssuper.is_c_hybrid()) and (not ssuper.is_c_lrc()) and (not ssuper.is_x_lrc())):; procedures['gradient'][ssuper.name().lower()] = run_dft_gradient. [docs]def energy(name, **kwargs):; r""""""Function to compute the single-point electronic energy. :returns: (*float*) Total electronic energy in Hartrees. SAPT returns interaction energy. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`CURRENT ENERGY <CURRENTENERGY>`; * :psivar:`CURRENT REFERENCE ENERGY <CURRENTREFERENCEENERGY>`; * :psivar:`CURRENT CORRELATION ENERGY <CURRENTCORRELATIONENERGY>`. .. comment In this table immediately below, place methods that should only be called by; .. comment developers at present. This table won't show up in the manual.; .. comment; .. comment .. _`table:energy_devel`:; .. comment; .. comment +-------------------------+---------------------------------------------------------------------------------------+; .. comment | name | calls method |; .. comment +=========================+=======================================================================================+; .. comment | mp2c | coupled MP2 (MP2C) |; .. comment +-------------------------+---------------------------------------------------------------------------------------+; .. comment | mp2-drpa | random pha",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/_modules/driver.html:5321,energy,energy,5321,psi4manual/4.0b4/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/driver.html,4,['energy'],['energy']
Energy Efficiency,"a2_wfn_lesser: string; :param delta2_wfn_lesser: |dl| ``'mp2'`` |dr| || ``'ccsd(t)'`` || etc. Indicates the inferior energy method for which a second delta correction; to the correlation energy is to be obtained. :type delta3_wfn: string; :param delta3_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a third delta correction; to the correlation energy is to be obtained. :type delta3_wfn_lesser: string; :param delta3_wfn_lesser: |dl| ``'mp2'`` |dr| || ``'ccsd(t)'`` || etc. Indicates the inferior energy method for which a third delta correction; to the correlation energy is to be obtained. :type delta4_wfn: string; :param delta4_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a fourth delta correction; to the correlation energy is to be obtained. :type delta4_wfn_lesser: string; :param delta4_wfn_lesser: |dl| ``'mp2'`` |dr| || ``'ccsd(t)'`` || etc. Indicates the inferior energy method for which a fourth delta correction; to the correlation energy is to be obtained. :type delta5_wfn: string; :param delta5_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a fifth delta correction; to the correlation energy is to be obtained. :type delta5_wfn_lesser: string; :param delta5_wfn_lesser: |dl| ``'mp2'`` |dr| || ``'ccsd(t)'`` || etc. Indicates the inferior energy method for which a fifth delta correction; to the correlation energy is to be obtained. * Basis Sets; Currently, the basis set set through ``set`` commands have no influence; on a cbs calculation. :type scf_basis: :ref:`basis string <apdx:basisElement>`; :param scf_basis: |dl| ``corl_basis`` |dr| || ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the reference energy.; If any correlation method is specified, ``scf_basis`` can default; to ``corl_basis``. :type corl_basis: :ref:`basis string <apdx:basisElement>`; :param corl_basis: `",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:57334,energy,energy,57334,psi4manual/4.0b5/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html,4,['energy'],['energy']
Energy Efficiency,"a3] » ; Module code ». Source code for qcdb.molecule; #import os; #import re; #import math; #import copy; #from periodictable import *; #from physconst import *; #from vecutil import *; #from exceptions import *; #from coordentry import *; from libmintsmolecule import *. [docs]class Molecule(LibmintsMolecule):; """"""Class to store python extensions to the MoleculeLibmints class.; Multiple classes allows separation of libmints and extension methods. """""". def __init__(self, psi4molstr=None):; """"""Initialize Molecule object from LibmintsMolecule""""""; LibmintsMolecule.__init__(self, psi4molstr). # The comment line; self.tagline = """". def __str__(self):; text = """""" ==> qcdb Molecule %s <==\n\n"""""" % (self.name()); text += """""" => %s <=\n\n"""""" % (self.tagline); text += self.save_string_for_psi4(); return text. @classmethod; [docs] def init_with_xyz(cls, xyzfilename, no_com=False, no_reorient=False):; """"""Pull information from an XYZ file. No fragment info detected.; Charge, multiplicity, tagline pulled from second line if available. >>> H2O = qcdb.Molecule.init_with_xyz('h2o.xyz'). """"""; instance = cls(); instance.lock_frame = False; instance.PYmove_to_com = not no_com; instance.PYfix_orientation = no_reorient. try:; infile = open(xyzfilename, 'r'); except IOError:; raise ValidationError(""""""Molecule::init_with_xyz: given filename '%s' does not exist."""""" % (xyzfilename)); if os.stat(xyzfilename).st_size == 0:; raise ValidationError(""""""Molecule::init_with_xyz: given filename '%s' is blank."""""" % (xyzfilename)); text = infile.readlines(). xyz1 = re.compile(r""^\s*(\d+)\s*(bohr|au)?\s*$"", re.IGNORECASE); xyz2 = re.compile(r'^\s*(-?\d+)\s+(\d+)\s+(.*)\s*$'); xyzN = re.compile(r""(?:\s*)([A-Z](?:[a-z])?)(?:\s+)(-?\d+\.\d+)(?:\s+)(-?\d+\.\d+)(?:\s+)(-?\d+\.\d+)(?:\s*)"", re.IGNORECASE). # Try to match the first line; if xyz1.match(text[0]):; fileNatom = int(xyz1.match(text[0]).group(1)); if xyz1.match(text[0]).group(2) == None:; fileUnits = 'Angstrom'; else:; fileUnits = 'Bohr'; else:; raise",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/_modules/qcdb/molecule.html:1065,Charge,Charge,1065,psi4manual/4.0b3/_modules/qcdb/molecule.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/_modules/qcdb/molecule.html,1,['Charge'],['Charge']
Energy Efficiency,"a3_wfn_lesser', cbs_delta2_wfn).lower(); # if not (cbs_delta3_wfn_lesser in VARH.keys()):; # raise ValidationError(""""""Requested DELTA3 method lesser '%s' is not recognized. Add it to VARH in wrapper.py to proceed."""""" % (cbs_delta3_wfn_lesser)); #; # # Establish method for fourth delta correction energy; # if 'delta4_wfn' in kwargs:; # do_delta4 = True; # cbs_delta4_wfn = kwargs['delta4_wfn'].lower(); # if not (cbs_delta4_wfn in VARH.keys()):; # raise ValidationError('Requested DELTA4 method \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta4_wfn)); #; # if 'delta4_wfn_lesser' in kwargs:; # cbs_delta4_wfn_lesser = kwargs['delta4_wfn_lesser'].lower(); # else:; # cbs_delta4_wfn_lesser = cbs_delta3_wfn; # if not (cbs_delta4_wfn_lesser in VARH.keys()):; # raise ValidationError('Requested DELTA4 method lesser \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta4_wfn_lesser)); #; # # Establish method for fifth delta correction energy; # if 'delta5_wfn' in kwargs:; # do_delta5 = True; # cbs_delta5_wfn = kwargs['delta5_wfn'].lower(); # if not (cbs_delta5_wfn in VARH.keys()):; # raise ValidationError('Requested DELTA5 method \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta5_wfn)); #; # if 'delta5_wfn_lesser' in kwargs:; # cbs_delta5_wfn_lesser = kwargs['delta5_wfn_lesser'].lower(); # else:; # cbs_delta5_wfn_lesser = cbs_delta4_wfn; # if not (cbs_delta5_wfn_lesser in VARH.keys()):; # raise ValidationError('Requested DELTA5 method lesser \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta5_wfn_lesser)). # Check that user isn't skipping steps in scf + corl + delta + delta2 sequence; if do_scf and not do_corl and not do_delta and not do_delta2 and not do_delta3 and not do_delta4 and not do_delta5:; pass; elif do_scf and do_corl and not do_delta and not do_delta2 and not do_delta3 and not do_delta4 and not do_delta5:; pass; elif do_scf and do_corl and do_delta and ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html:34083,energy,energy,34083,psi4manual/1.0.0/_modules/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html,3,['energy'],['energy']
Energy Efficiency,"a3_wfn_lesser: string; :param delta3_wfn_lesser: |dl| ``'mp2'`` |dr| || ``'ccsd(t)'`` || etc. Indicates the inferior energy method for which a third delta correction; to the correlation energy is to be obtained. :type delta4_wfn: string; :param delta4_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a fourth delta correction; to the correlation energy is to be obtained. :type delta4_wfn_lesser: string; :param delta4_wfn_lesser: |dl| ``'mp2'`` |dr| || ``'ccsd(t)'`` || etc. Indicates the inferior energy method for which a fourth delta correction; to the correlation energy is to be obtained. :type delta5_wfn: string; :param delta5_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a fifth delta correction; to the correlation energy is to be obtained. :type delta5_wfn_lesser: string; :param delta5_wfn_lesser: |dl| ``'mp2'`` |dr| || ``'ccsd(t)'`` || etc. Indicates the inferior energy method for which a fifth delta correction; to the correlation energy is to be obtained. * Basis Sets; Currently, the basis set set through ``set`` commands have no influence; on a cbs calculation. :type scf_basis: :ref:`basis string <apdx:basisElement>`; :param scf_basis: |dl| ``corl_basis`` |dr| || ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the reference energy.; If any correlation method is specified, ``scf_basis`` can default; to ``corl_basis``. :type corl_basis: :ref:`basis string <apdx:basisElement>`; :param corl_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the correlation energy. :type delta_basis: :ref:`basis string <apdx:basisElement>`; :param delta_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the delta correction; to the correlation energy. :type delta2_basis: :ref:`basis string ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:57758,energy,energy,57758,psi4manual/4.0b5/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html,4,['energy'],['energy']
Energy Efficiency,"a4] » ; Module code ». Source code for qcdb.molecule; #import os; #import re; #import math; #import copy; #from periodictable import *; #from physconst import *; #from vecutil import *; #from exceptions import *; #from coordentry import *; from libmintsmolecule import *. [docs]class Molecule(LibmintsMolecule):; """"""Class to store python extensions to the MoleculeLibmints class.; Multiple classes allows separation of libmints and extension methods. """""". def __init__(self, psi4molstr=None):; """"""Initialize Molecule object from LibmintsMolecule""""""; LibmintsMolecule.__init__(self, psi4molstr). # The comment line; self.tagline = """". def __str__(self):; text = """""" ==> qcdb Molecule %s <==\n\n"""""" % (self.name()); text += """""" => %s <=\n\n"""""" % (self.tagline); text += self.save_string_for_psi4(); return text. @classmethod; [docs] def init_with_xyz(cls, xyzfilename, no_com=False, no_reorient=False):; """"""Pull information from an XYZ file. No fragment info detected.; Charge, multiplicity, tagline pulled from second line if available. >>> H2O = qcdb.Molecule.init_with_xyz('h2o.xyz'). """"""; instance = cls(); instance.lock_frame = False; instance.PYmove_to_com = not no_com; instance.PYfix_orientation = no_reorient. try:; infile = open(xyzfilename, 'r'); except IOError:; raise ValidationError(""""""Molecule::init_with_xyz: given filename '%s' does not exist."""""" % (xyzfilename)); if os.stat(xyzfilename).st_size == 0:; raise ValidationError(""""""Molecule::init_with_xyz: given filename '%s' is blank."""""" % (xyzfilename)); text = infile.readlines(). xyz1 = re.compile(r""^\s*(\d+)\s*(bohr|au)?\s*$"", re.IGNORECASE); xyz2 = re.compile(r'^\s*(-?\d+)\s+(\d+)\s+(.*)\s*$'); xyzN = re.compile(r""(?:\s*)([A-Z](?:[a-z])?)(?:\s+)(-?\d+\.\d+)(?:\s+)(-?\d+\.\d+)(?:\s+)(-?\d+\.\d+)(?:\s*)"", re.IGNORECASE). # Try to match the first line; if xyz1.match(text[0]):; fileNatom = int(xyz1.match(text[0]).group(1)); if xyz1.match(text[0]).group(2) == None:; fileUnits = 'Angstrom'; else:; fileUnits = 'Bohr'; else:; raise",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/_modules/qcdb/molecule.html:1065,Charge,Charge,1065,psi4manual/4.0b4/_modules/qcdb/molecule.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/qcdb/molecule.html,1,['Charge'],['Charge']
Energy Efficiency,"a_1}\). This option has a limited; functionality and should only be used for test purposes. For the production-level CEPA0 code, see the; OCC module. The DCFT code can also be used to; compute the \((\lambda_3)\) energy correction that perturbatively accounts; for three-particle correlation effects, similarly to the (T) correction in coupled; cluster theory. Computation of the \((\lambda_3)\) correction can be; requested by setting the THREE_PARTICLE option to PERTURBATIVE. A; combination of the ODC-13 functional with the \((\lambda_3)\) correction; [denoted as \(\mbox{ODC-13$(\lambda_3)$}\)] has been shown to provide highly; accurate results for open-shell molecules near equilibrium geometries.; At the present moment, all of the DCFT methods support unrestricted reference; orbitals (REFERENCE UHF), which can be used to perform energy and; gradient computations for both closed- and open-shell molecules. In addition,; the ODC-06 and ODC-12 methods support restricted reference orbitals; (REFERENCE RHF) for the energy and gradient computations of; closed-shell molecules. Note that in this case restricted reference orbitals; are only available for ALGORITHM SIMULTANEOUS. Iterative Algorithms¶; As explained in the Theory section, in order to obtain the DCFT energy one; needs to solve a system of coupled equations for orbitals and density; cumulant. At the present moment three iterative algorithms for the solution of the; equations are available. The choice of the algorithm is controlled using the; ALGORITHM option. SIMULTANEOUS [Default]; In the simultaneous algorithm the DCFT equations are solved in macroiterations.; Each macroiteration consists of a single iteration of the cumulant update; followed by a single iteration of the orbital update and orbital transformation; of the integrals. The macroiterations are repeated until the simultaneous; convergence of the cumulant and orbitals is achieved.; Convergence of the simultaneous algorithm is accelerated using the; DIIS ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/dcft-1.html:8025,energy,energy,8025,psi4manual/1.2.1/dcft-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/dcft-1.html,6,['energy'],['energy']
Energy Efficiency,"a_gradient; # Upon adding a method to this list, add it to the docstring in optimize() below; },; 'hessian' : {; # Upon adding a method to this list, add it to the docstring in frequency() below; },; 'property' : {; 'scf' : run_scf_property,; 'cc2' : run_cc_property,; 'ccsd' : run_cc_property,; 'df-mp2' : run_dfmp2_property,; 'dfmp2' : run_dfmp2_property,; 'eom-cc2' : run_cc_property,; 'eom-ccsd' : run_cc_property,; # Upon adding a method to this list, add it to the docstring in property() below; }}. # Integrate DFT with driver routines; for ssuper in superfunctional_list():; procedures['energy'][ssuper.name().lower()] = run_dft. for ssuper in superfunctional_list():; if ((not ssuper.is_c_hybrid()) and (not ssuper.is_c_lrc()) and (not ssuper.is_x_lrc())):; procedures['gradient'][ssuper.name().lower()] = run_dft_gradient. [docs]def energy(name, **kwargs):; r""""""Function to compute the single-point electronic energy. :returns: (*float*) Total electronic energy in Hartrees. SAPT returns interaction energy. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`CURRENT ENERGY <CURRENTENERGY>`; * :psivar:`CURRENT REFERENCE ENERGY <CURRENTREFERENCEENERGY>`; * :psivar:`CURRENT CORRELATION ENERGY <CURRENTCORRELATIONENERGY>`. .. comment In this table immediately below, place methods that should only be called by; .. comment developers at present. This table won't show up in the manual.; .. comment; .. comment .. _`table:energy_devel`:; .. comment; .. comment +-------------------------+---------------------------------------------------------------------------------------+; .. comment | name | calls method |; .. comment +=========================+=======================================================================================+; .. comment | mp2c | coupled MP2 (MP2C) |; .. comment +-------------------------+---------------------------------------------------------------------------------------+; .. comment | mp2-drpa | random phase approximation? |; .. comment +------------",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/_modules/driver.html:5366,energy,energy,5366,psi4manual/4.0b4/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/driver.html,4,['energy'],['energy']
Energy Efficiency,"a_wfn_lesser: string; :param delta_wfn_lesser: |dl| ``corl_wfn`` |dr| || ``'mp2'`` || etc. Indicates the inferior energy method for which a delta correction; to the correlation energy is to be obtained. :type delta2_wfn: string; :param delta2_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a second delta correction; to the correlation energy is to be obtained. :type delta2_wfn_lesser: string; :param delta2_wfn_lesser: |dl| ``delta_wfn`` |dr| || ``'ccsd(t)'`` || etc. Indicates the inferior energy method for which a second delta correction; to the correlation energy is to be obtained. :type delta3_wfn: string; :param delta3_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a third delta correction; to the correlation energy is to be obtained. :type delta3_wfn_lesser: string; :param delta3_wfn_lesser: |dl| ``delta2_wfn`` |dr| || ``'ccsd(t)'`` || etc. Indicates the inferior energy method for which a third delta correction; to the correlation energy is to be obtained. :type delta4_wfn: string; :param delta4_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a fourth delta correction; to the correlation energy is to be obtained. :type delta4_wfn_lesser: string; :param delta4_wfn_lesser: |dl| ``delta3_wfn`` |dr| || ``'ccsd(t)'`` || etc. Indicates the inferior energy method for which a fourth delta correction; to the correlation energy is to be obtained. :type delta5_wfn: string; :param delta5_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a fifth delta correction; to the correlation energy is to be obtained. :type delta5_wfn_lesser: string; :param delta5_wfn_lesser: |dl| ``delta4_wfn`` |dr| || ``'ccsd(t)'`` || etc. Indicates the inferior energy method for which a fifth delta correction; to the correlation energy is to be obtained. * Basis Sets; Currently, the basis set set through ``set`` commands have no influe",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html:21850,energy,energy,21850,psi4manual/1.0.0/_modules/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html,6,['energy'],['energy']
Energy Efficiency,"abase db_name. If no reference is available, this will be a large; and nonsensical value. db_name DATABASE MEAN SIGNED DEVIATION¶; The mean deviation [kcal mol-1] of the requested method name; from the stored reference values for the requested reactions in; database db_name. If no reference is available, this will be a large; and nonsensical value. db_name DATABASE ROOT-MEAN-SQUARE SIGNED DEVIATION¶; The rms deviation [kcal mol-1] of the requested method name; from the stored reference values for the requested reactions in; database db_name. If no reference is available, this will be a large; and nonsensical value. DF-MP2 TOTAL ENERGY¶. DF-MP2 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the density-fitted MP2 level of theory. DFT FUNCTIONAL ENERGY¶; The functional energy contribution [H] to the total SCF energy (DFT only).; Quantity in Eq. (2). DFT FUNCTIONAL TOTAL ENERGY¶; The total electronic energy [H] for the underlying functional; of the requested DFT method, without any dispersion correction,; the first four terms in Eq. (2).; When the requested method includes a dispersion correction, this; quantity is in Eq. (1).; Otherwise, quantity equal to DFT TOTAL ENERGY; and SCF TOTAL ENERGY. DFT TOTAL ENERGY¶; The total electronic energy [H] for the requested DFT method,; in Eq. (2).; When the method includes a dispersion correction, this quantity; is in Eq. (1). DISPERSION CORRECTION ENERGY¶; The dispersion correction [H] appended to an underlying functional; when a DFT-D method is requested. Quantity ; in Eqs. (1) and (2). (1). FCI TOTAL ENERGY¶. FCI CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the full configuration interaction level of theory. LCC2 (+LMP2) TOTAL ENERGY¶; The total electronic energy [H] for the local CC2 level of theory. LCCSD (+LMP2) TOTAL ENERGY¶; The total electronic energy [H] for the local CCSD level of theory. MP2 TOTAL ENERGY¶. MP2 CORRELATIO",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/glossary_psivariables-1.html:5849,energy,energy,5849,psi4manual/4.0b2/glossary_psivariables-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/glossary_psivariables-1.html,2,['energy'],['energy']
Energy Efficiency,"abase python files for available; molecular systems (case insensitive). [1,2,5] || ['1','2','5'] || ['BzMe-3.5', 'MeMe-5.0'] || etc.Specify a list of database members to run. Consult the; database python files for available molecular systems. This; is the only portion of database input that is case sensitive;; choices for this keyword must match the database python file. Examples:. >>> # [1] Two-stage SCF calculation on short, equilibrium, and long helium dimer; >>> db('scf','RGC10',cast_up='sto-3g',subset=['HeHe-0.85','HeHe-1.0','HeHe-1.5'], tabulate=['scf total energy','natom']). >>> # [2] Counterpoise-corrected interaction energies for three complexes in S22; >>> # Error statistics computed wrt an old benchmark, S22A; >>> database('mp2','S22',cp=1,subset=[16,17,8],benchmark='S22A'). >>> # [3] SAPT0 on the neon dimer dissociation curve; >>> db('sapt0',subset='NeNe',cp=0,symm=0,db_name='RGC10'). >>> # [4] Optimize system 1 in database S22, producing tables of scf and mp2 energy; >>> db('mp2','S22',db_func=optimize,subset=[1], tabulate=['mp2 total energy','current energy']). >>> # [5] CCSD on the smallest systems of HTBH, a hydrogen-transfer database; >>> database('ccsd','HTBH',subset='small', tabulate=['ccsd total energy', 'mp2 total energy']). Output¶; At the beginning of a database job is printed a listing of the individual system; calculations which will be performed. The output snippet below is from the example job [1]; above. It shows each reagent required for the subset of database reactions requested.; Note that this is an un-counterpoise-corrected example, and the wrapper is smart enough; to compute only once the monomer whose energy will be subtracted from each of the three dimers.; RGC1-HeHe-0.85-dimer; RGC1-He-mono-unCP; RGC1-HeHe-1.0-dimer; RGC1-HeHe-1.5-dimer. At the end of the job, the Requested Energy table is printed that gives the total; energies for the requested model chemistry for each reagent and each reaction, as; well as the stoichiometric we",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/db.html:5964,energy,energy,5964,psi4manual/1.7.x/db.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/db.html,12,['energy'],['energy']
Energy Efficiency,"abase.py.; See Creating a Database for details. Caution; Some features are not yet implemented. Buy a developer some coffee. In sow/reap mode, use only global options (e.g., the local option set by set scf scf_type df will not be respected). Note; To access a database that is not embedded in a PSI4; distribution, add the path to the directory containing the database; to the environment variable PYTHONPATH. Parameters:. name (str) – 'scf' || 'sapt0' || 'ccsd(t)' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; psi4.driver.energy(). db_name (str) – 'BASIC' || 'S22' || 'HTBH' || etc.; Second argument, usually unlabeled. Indicates the requested database; name, matching (case insensitive) the name of a python file in; psi4/share/databases or PYTHONPATH. Consult that; directory for available databases and literature citations. func (function) – \(\Rightarrow\) energy \(\Leftarrow\) || optimize || cbs; Indicates the type of calculation to be performed on each database; member. The default performs a single-point energy('name'), while; optimize perfoms a geometry optimization on each reagent, and; cbs performs a compound single-point energy. If a nested series; of python functions is intended (see Function Intercalls), use; keyword db_func instead of func. mode (str) – \(\Rightarrow\) 'continuous' \(\Leftarrow\) || 'sow' || 'reap'; Indicates whether the calculations required to complete the; database are to be run in one file ('continuous') or are to be; farmed out in an embarrassingly parallel fashion; ('sow'/'reap'). For the latter, run an initial job with; 'sow' and follow instructions in its output file. cp (boolean) – 'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicates whether counterpoise correction is employed in computing; interaction energies. Use this option and NOT the bsse_type=""cp""; function for BSSE correction in database(). Option available; (See Available Database",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/db.html:1845,energy,energy,1845,psi4manual/1.7.x/db.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/db.html,4,['energy'],['energy']
Energy Efficiency,"able I in S. Grimme’s J. Chem. Phys 124 034108 (2006) paper defining the functional. mp2-1; All-electron MP2 6-31G** geometry optimization of water. cc8c; ROHF-CCSD cc-pVDZ frozen-core energy for the \(^2\Sigma^+\) state of the CN radical, with Cartesian input. mbis-6; MBIS calculation on H2O. scf-freq1; Analytic vs. finite difference DF-SCF frequency test for water. cc13c; Tests RHF CCSD(T)gradients. cubeprop-frontier; ROHF frontier orbitals of CH2(s) and CH2(t). mp3-grad1; MP3 cc-pVDZ gradient for the H2O molecule. sad-scf-type; Test SAD SCF guesses on noble gas atom. x2c1; Test of SFX2C-1e on water uncontracted cc-pVDZ-DK The reference numbers are from Lan Cheng’s implementation in Cfour. cc38; RHF-CC2-LR/cc-pVDZ static polarizabilities of HOF molecule. freq-isotope2; Vibrational and thermo analysis of several water isotopologs. Demonstrates Hessian reuse for different temperatures, pressures, and isotopologs. mp2-grad2; MP2 cc-pVDZ gradient for the NO radical. casscf-fzc-sp; CASSCF/6-31G** energy point. rasci-ne; Ne atom RASCI/cc-pVQZ Example of split-virtual CISD[TQ] from Sherrill and Schaefer, J. Phys. Chem. XXX This uses a “primary” virtual space 3s3p (RAS 2), a “secondary” virtual space 3d4s4p4d4f (RAS 3), and a “tertiary” virtual space consisting of the remaining virtuals. First, an initial CISD computation is run to get the natural orbitals; this allows a meaningful partitioning of the virtual orbitals into groups of different importance. Next, the RASCI is run. The split-virtual CISD[TQ] takes all singles and doubles, and all triples and quadruples with no more than 2 electrons in the secondary virtual subspace (RAS 3). If any electrons are present in the tertiary virtual subspace (RAS 4), then that excitation is only allowed if it is a single or double. dft-grad-lr2; Tests CAM gradients with and without XC pieces to narrow grid error. dfccd1; DF-CCD cc-pVDZ energy for the H2O molecule. fsaptd-terms; F-SAPT0/jun-cc-pvdz procedure for methane dimer. cc8; U",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/autodoc_testsuite_corepsi4.html:3489,energy,energy,3489,psi4manual/1.8.x/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/autodoc_testsuite_corepsi4.html,2,['energy'],['energy']
Energy Efficiency,"able embedding module. Type: boolean; Default: false. POTFILE¶. Name of the potential file OR contents of potential file to be written anonymously on-the-fly. Type: string; Default: potfile.pot. ISOTROPIC_POL¶. Make polarizabilities isotropic. Type: boolean; Default: false. INDUCED_CONVERGENCE¶. Threshold for induced moments convergence. Type: conv double; Default: 1e-8. MAXITER¶. Maximum number of iterations for induced moments. Type: integer; Default: 50. BORDER¶. Activate border options for sites in proximity to the QM/MM border. Type: boolean; Default: false. BORDER_TYPE¶. border type, either remove or redistribute moments/polarizabilities. Type: string; Possible Values: REMOVE, REDIST; Default: REMOVE. BORDER_N_REDIST¶. number of neighbor sites to redistribute to. The default (-1) redistributes to all sites which are not in the border region. Type: integer; Default: -1. BORDER_REDIST_ORDER¶. order from which moments are removed, e.g., if set to 1 (default), only charges are redistributed and all higher order moments are removed. Type: integer; Default: 1. BORDER_RMIN¶. minimum radius from QM atoms to MM sites to be taken into account for removal/redistribution. Type: double; Default: 2.2. BORDER_RMIN_UNIT¶. unit of BORDER_RMIN, default is atomic units (AU). Type: string; Possible Values: AU, AA; Default: AU. BORDER_REDIST_POL¶. redistribute polarizabilities? If false, polarizabilities are removed (default). Type: boolean; Default: false. How to configure CPPE for building Psi4¶; Role and Dependencies. Role — In PSI4, CPPE is a library that provides additional; quantum chemical capabilities (explicit solvation modeling).; Downstream Dependencies — PSI4 (\(\Leftarrow\) optional) CPPE; Upstream Dependencies — CPPE. CMake Variables. ENABLE_cppe — CMake variable toggling whether Psi4 builds with CPPE; cppe_DIR — CMake variable to specify where pre-built CPPE can be found. Set to installation directory containing share/cmake/cppe/cppeConfig.cmake. Examples. Build bund",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/cppe-1.html:3912,charge,charges,3912,psi4manual/1.4.0/cppe-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/cppe-1.html,9,['charge'],['charges']
Energy Efficiency,"able('Valiron-Mayer Function Couterpoise Total Energy', vmfc_energy_body_dict[max_nbody]); psi4.set_variable('Valiron-Mayer Function Couterpoise Interaction Energy', vmfc_interaction_energy). for n in nbody_range[1:]:; var_key = 'VMFC-CORRECTED %d-BODY INTERACTION ENERGY' % n; psi4.set_variable(var_key, vmfc_energy_body_dict[n] - vmfc_energy_body_dict[1]). if return_method == 'cp':; ptype_body_dict = cp_ptype_body_dict; energy_body_dict = cp_energy_body_dict; elif return_method == 'nocp':; ptype_body_dict = nocp_ptype_body_dict; energy_body_dict = nocp_energy_body_dict; elif return_method == 'vmfc':; ptype_body_dict = vmfc_ptype_body_dict; energy_body_dict = vmfc_energy_body_dict; else:; raise ValidationError(""N-Body Wrapper: Invalid return type. Should never be here, please post this error on github.""). # Figure out and build return types; if return_total_data:; ret_energy = energy_body_dict[max_nbody]; else:; ret_energy = energy_body_dict[max_nbody]; ret_energy -= energy_body_dict[1]. if ptype != 'energy':; if return_total_data:; np_final_ptype = ptype_body_dict[max_nbody].copy(); else:; np_final_ptype = ptype_body_dict[max_nbody].copy(); np_final_ptype -= ptype_body_dict[1]. ret_ptype = psi4.Matrix.from_array(np_final_ptype); else:; ret_ptype = ret_energy. # Build and set a wavefunction; wfn = psi4.new_wavefunction(molecule, 'sto-3g'); wfn.nbody_energy = energies_dict; wfn.nbody_ptype = ptype_dict; wfn.nbody_body_energy = energy_body_dict; wfn.nbody_body_ptype = ptype_body_dict. if ptype == 'gradient':; wfn.set_gradient(ret_ptype); elif ptype == 'hessian':; wfn.set_hessian(ret_ptype). psi4.set_variable(""CURRENT ENERGY"", ret_energy). if return_wfn:; return (ret_ptype, wfn); else:; return ret_ptype. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    ; Psi4 [1.0.0 6a9a71b] » ; Module code ». © Copyright 2016, The Psi4 Project.; Last updated on Tuesday, 05 July 2016 02:54AM.; Created using Sphinx 1.3.5.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/driver_nbody.html:15469,energy,energy,15469,psi4manual/1.0.0/_modules/driver_nbody.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver_nbody.html,1,['energy'],['energy']
Energy Efficiency,"able(f""{method} ROOT 0 (A) -> ROOT {root_index} (A) ""; ""ROTATORY STRENGTH (VEL)"", data); adc_wfn.set_variable(f""{method} ROOT 0 (IN A) -> ROOT {root_index} (IN A) ""; ""ROTATORY STRENGTH (VEL)"", data); adc_wfn.set_variable(f""{method} ROOT 0 -> ROOT {root_index} ""; ""ROTATORY STRENGTH (VEL)"", data); adc_wfn.set_variable(f""{method} ROOT 0 -> ROOT {root_index} ""; ""ROTATORY STRENGTH (VEL) - A TRANSITION"", data). if ""DIPOLE"" in properties:; data = excitation.state_dipole_moment; props[""State dipole moment (in a.u.)""] = data; data_mat = data.reshape(1, 3); for method in methods:; adc_wfn.set_variable(f""{method} ROOT {root_index} DIPOLE MOMENT"", data_mat); adc_wfn.set_variable(f""{method} ROOT {root_index} DIPOLE MOMENT - A TRANSITION"", data_mat); adc_wfn.set_variable(f""{method} ROOT {root_index} (A) DIPOLE MOMENT"", data_mat); adc_wfn.set_variable(f""{method} ROOT {root_index} (IN A) DIPOLE MOMENT"", data_mat). computed.append(props). # for Psivar scraper; # wfn.set_variable(""ADC ROOT 0 -> ROOT n EXCITATION ENERGY"") # P::e ADC; # wfn.set_variable(""ADC ROOT 0 (IN h) -> ROOT n (IN i) EXCITATION ENERGY"") # P::e ADC; # wfn.set_variable(""ADC ROOT 0 (h) -> ROOT n (i) EXCITATION ENERGY"") # P::e ADC; # wfn.set_variable(""ADC ROOT 0 -> ROOT n EXCITATION ENERGY - h TRANSITION"") # P::e ADC; # wfn.set_array_variable(""ADC ROOT 0 -> ROOT n ELECTRIC TRANSITION DIPOLE MOMENT (LEN)"") # P::e ADC; # wfn.set_array_variable(""ADC ROOT 0 (IN h) -> ROOT n (IN i) ELECTRIC TRANSITION DIPOLE MOMENT (LEN)"") # P::e ADC; # wfn.set_array_variable(""ADC ROOT 0 (h) -> ROOT n (i) ELECTRIC TRANSITION DIPOLE MOMENT (LEN)"") # P::e ADC; # wfn.set_array_variable(""ADC ROOT 0 -> ROOT n ELECTRIC TRANSITION DIPOLE MOMENT (LEN) - h TRANSITION"") # P::e ADC; # wfn.set_array_variable(""ADC ROOT n DIPOLE MOMENT"") # P::e ADC; # wfn.set_array_variable(""ADC ROOT n (IN i) DIPOLE MOMENT"") # P::e ADC; # wfn.set_array_variable(""ADC ROOT n (i) DIPOLE MOMENT"") # P::e ADC; # wfn.set_array_variable(""ADC ROOT n DIPOLE MOMENT - h TRANSITION"")",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:125263,ENERGY,ENERGY,125263,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,5,['ENERGY'],['ENERGY']
Energy Efficiency,"able, OFF otherwise). Type: boolean; Default: true. CFOUR_DBOC (CFOUR)¶CFOUR — Specifies whether the diagonal Born-Oppenheimer correction (DBOC) to the energy is evaluated (ON =1) or not (OFF =0). DBOC calculations are currently only available for HF-SCF and CCSD using RHF or UHF reference functions. Type: boolean; Default: false. CFOUR_DCT (CFOUR)¶CFOUR — Specifies whether the Dipole Coupling Tensor (DCT) is calculated (ON =1) or not (OFF =0). Type: boolean; Default: false. CFOUR_DERIV_LEVEL (CFOUR)¶CFOUR — Specifies whether or not energy derivatives are to be calculated and if so whether first or second derivatives are computed. ZERO (= 0) derivatives are not calculated, FIRST (=1) first derivatives are calculated, SECOND (=2) second derivatives are calculated. Note that this keyword usually needs not be set in any calculation since it is automatically set if the appropriate other options in the CFOUR namelist are turned on. Psi4 Interface: Keyword set from type of computation command: ZERO if energy(), FIRST if gradient() or optimize(), etc. Type: string; Possible Values: ZERO, FIRST, SECOND; Default: ZERO. CFOUR_DIFF_TYPE (CFOUR)¶CFOUR — Specifies whether orbital-relaxed (RELAXED =0) or orbital-unrelaxed (UNRELAXED =1) derivatives are computed in the CC calculation. Type: string; Possible Values: RELAXED, UNRELAXED; Default: RELAXED. CFOUR_DROPMO (CFOUR)¶CFOUR — Specifies which molecular orbitals will be dropped from the post-SCF calculation. The orbitals are numbered in ascending order from the most stable (negative energy) to the most unstable (largest positive energy). Individual orbitals must be separated with a dash, while x>y means orbitals x through y inclusive. For example, the string 1>10-55-58>64, would result in orbitals 1,2,3,4,5,6,7,8,9,10,55,58,59,60,61,62,63 and 64 being dropped. For UHF calculations, the appropriate orbitals are deleted for both spin cases. No dropped virtual MOs are currently allowed for gradient or property calculations. Psi4 I",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/autodoc_glossary_options_c-1.html:32711,energy,energy,32711,psi4manual/1.4.0/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodoc_glossary_options_c-1.html,9,['energy'],['energy']
Energy Efficiency,"able. del_potential_variable(self: psi4.core.Wavefunction, arg0: str) → int¶; Removes the requested (case-insensitive) ExternalPotential QC variable. (This function is provisional and might be removed in the future.). del_scalar_variable(self: psi4.core.Wavefunction, arg0: str) → int¶; Removes the requested (case-insensitive) double QC variable. del_variable(key)¶; Removes scalar or array QCVariable key from cls if present. Return type; None. Parameters. cls (psi4.core.Wavefunction) – ; key (str) – . density_fitted(self: psi4.core.Wavefunction) → bool¶; Returns whether this wavefunction was obtained using density fitting or not. diis(self: psi4.core.HF) → bool¶; docstring. diis_manager(self: psi4.core.HF) → psi4.core.DIISManager¶; docstring. doccpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of doubly occupied orbitals per irrep. efzc(self: psi4.core.Wavefunction) → float¶; Returns the frozen-core energy. energy(self: psi4.core.Wavefunction) → float¶; Returns the Wavefunction’s energy. epsilon_a(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the Alpha Eigenvalues. epsilon_a_subset(self: psi4.core.Wavefunction, arg0: str, arg1: str) → psi4.core.Vector¶; Returns the requested Alpha Eigenvalues subset. epsilon_b(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the Beta Eigenvalues. epsilon_b_subset(self: psi4.core.Wavefunction, arg0: str, arg1: str) → psi4.core.Vector¶; Returns the requested Beta Eigenvalues subset. esp_at_nuclei(self: psi4.core.Wavefunction) → psi4.core.Vector¶; returns electrostatic potentials at nuclei. external_pot(self: psi4.core.Wavefunction) → psi4.core.ExternalPotential¶; Gets the requested external potential. finalize(self: psi4.core.HF) → None¶; Cleans up the the Wavefunction’s temporary data. finalize_energy()¶; Performs stability analysis and calls back SCF with new guess; if needed, Returns the SCF energy. This function should be called; once orbitals are ready for energy/property computat",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/api/psi4.core.cuhf.html:19825,energy,energy,19825,psi4manual/1.4.0/api/psi4.core.cuhf.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/api/psi4.core.cuhf.html,8,['energy'],['energy']
Energy Efficiency,"ables(). Note that PSI variables; are cleared at the start of each energy(), etc. in an input; file by clean_variables().; So if you run in a single input file a STO-3G FCI followed by a; aug-cc-pVQZ SCF followed by a print_variables() command, the; last will include SCF TOTAL ENERGY but not; FCI TOTAL ENERGY.; The entire dictionary of PSI variables can be obtained through; get_variables(). Return Values¶; Most of the usual user computation functions (i.e.,; energy(), optimize(), and; frequency()) return simply the current total energy.; Consult the descriptions of other functions in Psithon Functions: Invoking a Calculation for; what quantities they return and for what data structures they make; available for post-processing. Many users need only deal with the simple return; form for the computation functions.; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11# E is total energy float; # G is gradient array; # H is hessian array; # wfn is class instance with many computational details. # simple returns; E = energy(...); E = optimize(...); E = frequency(...); G = gradient(...) # used by optimize(); H = hessian(...) # used by frequency(). For more elaborate post-processing of computations, adding; return_wfn=True keyword argument additionally returns; Wavefunction.; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16# power user returns; E, wfn = energy(..., return_wfn=True); E, wfn = optimize(..., return_wfn=True); E, wfn = frequency(..., return_wfn=True); G, wfn = gradient(..., return_wfn=True) # used by optimize(); H, wfn = hessian(..., return_wfn=True) # used by frequency(). # print gradient array and its rms; wfn.gradient.print_out(); print wfn.gradient().rms(). # format output for other programs; molden(wfn, 'mycalc.molden'). # access array in another format; np.array(wfn.hessian()). Loops¶; Python provides many control structures, any of which can be used within PSI4; input files. For example, to loop over three basis sets, the following code can; be used:; 1; 2; 3; 4basis_s",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/psithoninput-1.html:10924,energy,energy,10924,psi4manual/1.1.0/psithoninput-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/psithoninput-1.html,6,['energy'],['energy']
Energy Efficiency,"ables; self.mpi_world = None; self.world_rank = 0. # Flag for if a lattice of point charges has been set; self.set_lattice = False. # Get correct intra-code MPI communicator; if use_mpi4py:; self.mpi_world = MDI_MPI_get_world_comm(); self.world_rank = self.mpi_world.Get_rank(). # Psi4 does not currently support multiple MPI ranks; if self.mpi_world.Get_size() != 1:; MPI.COMM_WORLD.Abort(). # Accept a communicator to the driver code; self.comm = MDI_Accept_Communicator(). # Ensure that the molecule is using c1 symmetry; self.molecule.reset_point_group('c1'); self.molecule.fix_orientation(True); self.molecule.fix_com(True); self.molecule.reinterpret_coordentry(False); self.molecule.update_geometry(). # Flag to stop listening for MDI commands; self.stop_listening = False. # Dictionary of all supported MDI commands; self.commands = {; ""<NATOMS"": self.send_natoms,; ""<COORDS"": self.send_coords,; ""<CHARGES"": self.send_charges,; ""<ELEMENTS"": self.send_elements,; ""<MASSES"": self.send_masses,; ""<ENERGY"": self.send_energy,; ""<FORCES"": self.send_forces,; "">COORDS"": self.recv_coords,; "">NLATTICE"": self.recv_nlattice,; "">CLATTICE"": self.recv_clattice,; "">LATTICE"": self.recv_lattice,; "">MASSES"": self.recv_masses,; ""SCF"": self.run_scf,; ""<DIMENSIONS"": self.send_dimensions,; ""<TOTCHARGE"": self.send_total_charge,; "">TOTCHARGE"": self.recv_total_charge,; ""<ELEC_MULT"": self.send_multiplicity,; "">ELEC_MULT"": self.recv_multiplicity,; ""EXIT"": self.exit; }. # Register all the supported commands; MDI_Register_Node(""@DEFAULT""); for command in self.commands.keys():; MDI_Register_Command(""@DEFAULT"", command). def length_conversion(self):; """""" Obtain the conversion factor between the geometry specification units and bohr. :returns: *unit_conv* Conversion factor between the geometry specification units and bohr; """"""; unit_name = self.molecule.units(); if unit_name == ""Angstrom"":; # beware if MDI and psi4 choose different sets of constants; unit_conv = psi4.driver.constants.bohr2angstroms; elif un",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/mdi_engine.html:3986,ENERGY,ENERGY,3986,psi4manual/1.9.x/_modules/psi4/driver/mdi_engine.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/mdi_engine.html,2,['ENERGY'],['ENERGY']
Energy Efficiency,"ables; self.mpi_world = None; self.world_rank = 0. # Flag for if a lattice of point charges has been set; self.set_lattice = False. # Get correct intra-code MPI communicator; if use_mpi4py:; self.mpi_world = MDI_MPI_get_world_comm(); self.world_rank = self.mpi_world.Get_rank(). # Psi4 does not currently support multiple MPI ranks; if self.mpi_world.Get_size() != 1:; MPI.COMM_WORLD.Abort(). # Accept a communicator to the driver code; self.comm = MDI_Accept_Communicator(). # Ensure that the molecule is using c1 symmetry; self.molecule.reset_point_group('c1'); self.molecule.fix_orientation(True); self.molecule.fix_com(True); self.molecule.reinterpret_coordentry(False); self.molecule.update_geometry(). # Flag to stop listening for MDI commands; self.stop_listening = False. # Dictionary of all supported MDI commands; self.commands = {; ""<NATOMS"": self.send_natoms,; ""<COORDS"": self.send_coords,; ""<CHARGES"": self.send_charges,; ""<ELEMENTS"": self.send_elements,; ""<MASSES"": self.send_masses,; ""<ENERGY"": self.send_energy,; ""<FORCES"": self.send_forces,; "">COORDS"": self.recv_coords,; "">NLATTICE"": self.recv_nlattice,; "">CLATTICE"": self.recv_clattice,; "">LATTICE"": self.recv_lattice,; "">MASSES"": self.recv_masses,; ""SCF"": self.run_scf,; ""<DIMENSIONS"": self.send_dimensions,; ""<TOTCHARGE"": self.send_total_charge,; "">TOTCHARGE"": self.recv_total_charge,; ""<ELEC_MULT"": self.send_multiplicity,; "">ELEC_MULT"": self.recv_multiplicity,; ""EXIT"": self.exit; }. # Register all the supported commands; MDI_Register_Node(""@DEFAULT""); for command in self.commands.keys():; MDI_Register_Command(""@DEFAULT"", command). def length_conversion(self):; """""" Obtain the conversion factor between the geometry specification units and bohr. :returns: *unit_conv* Conversion factor between the geometry specification units and bohr; """"""; unit_name = self.molecule.units(); if unit_name == ""Angstrom"":; unit_conv = qcel.constants.bohr2angstroms; elif unit_name == ""Bohr"":; unit_conv = 1.0; else:; raise Exception('Unrecog",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/mdi_engine.html:3544,ENERGY,ENERGY,3544,psi4manual/1.4.0/_modules/psi4/driver/mdi_engine.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/mdi_engine.html,5,['ENERGY'],['ENERGY']
Energy Efficiency,"ablish list of valid basis sets for delta correction energy; if do_delta:; if 'delta_basis' in kwargs:; BSTD, ZETD = validate_bracketed_basis(kwargs['delta_basis'].lower()); else:; raise ValidationError('DELTA basis sets through keyword \'%s\' are required.' % ('delta_basis')). # Establish list of valid basis sets for second delta correction energy; if do_delta2:; if 'delta2_basis' in kwargs:; BSTD2, ZETD2 = validate_bracketed_basis(kwargs['delta2_basis'].lower()); else:; raise ValidationError('DELTA2 basis sets through keyword \'%s\' are required.' % ('delta2_basis')). # Establish treatment for scf energy (validity check useless since python will catch it long before here); cbs_scf_scheme = highest_1; if 'scf_scheme' in kwargs:; cbs_scf_scheme = kwargs['scf_scheme']. # Establish treatment for correlation energy; cbs_corl_scheme = highest_1; if 'corl_scheme' in kwargs:; cbs_corl_scheme = kwargs['corl_scheme']. # Establish treatment for delta correction energy; cbs_delta_scheme = highest_1; if 'delta_scheme' in kwargs:; cbs_delta_scheme = kwargs['delta_scheme']. # Establish treatment for delta2 correction energy; cbs_delta2_scheme = highest_1; if 'delta2_scheme' in kwargs:; cbs_delta2_scheme = kwargs['delta2_scheme']. # Build string of title banner; cbsbanners = ''; cbsbanners += """"""PsiMod.print_out('\\n')\n""""""; cbsbanners += """"""banner(' CBS Setup ')\n""""""; cbsbanners += """"""PsiMod.print_out('\\n')\n\n""""""; exec cbsbanners. # Call schemes for each portion of total energy to 'place orders' for calculations needed; d_fields = ['d_stage', 'd_scheme', 'd_basis', 'd_wfn', 'd_need', 'd_coef', 'd_energy']; f_fields = ['f_wfn', 'f_portion', 'f_basis', 'f_zeta', 'f_energy']; GRAND_NEED = []; MODELCHEM = []; bstring = ''; if do_scf:; NEED = call_function_in_1st_argument(cbs_scf_scheme,; mode='requisition', basisname=BSTR, basiszeta=ZETR, wfnname='scf'); GRAND_NEED.append(dict(zip(d_fields, ['scf', cbs_scf_scheme, reconstitute_bracketed_basis(NEED), 'scf', NEED, +1, 0.0]))). if do",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:65407,energy,energy,65407,psi4manual/4.0b2/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html,2,['energy'],['energy']
Energy Efficiency,"ablish list of valid basis sets for delta correction energy; if do_delta:; if 'delta_basis' in kwargs:; BSTD, ZETD = validate_bracketed_basis(kwargs['delta_basis'].lower()); else:; raise ValidationError('DELTA basis sets through keyword \'%s\' are required.' % ('delta_basis')). # Establish list of valid basis sets for second delta correction energy; if do_delta2:; if 'delta2_basis' in kwargs:; BSTD2, ZETD2 = validate_bracketed_basis(kwargs['delta2_basis'].lower()); else:; raise ValidationError('DELTA2 basis sets through keyword \'%s\' are required.' % ('delta2_basis')). # Establish treatment for scf energy (validity check useless since python will catch it long before here); cbs_scf_scheme = highest_1; if 'scf_scheme' in kwargs:; cbs_scf_scheme = kwargs['scf_scheme']. # Establish treatment for correlation energy; cbs_corl_scheme = highest_1; if 'corl_scheme' in kwargs:; cbs_corl_scheme = kwargs['corl_scheme']. # Establish treatment for delta correction energy; cbs_delta_scheme = highest_1; if 'delta_scheme' in kwargs:; cbs_delta_scheme = kwargs['delta_scheme']. # Establish treatment for delta2 correction energy; cbs_delta2_scheme = highest_1; if 'delta2_scheme' in kwargs:; cbs_delta2_scheme = kwargs['delta2_scheme']. # Build string of title banner; cbsbanners = ''; cbsbanners += """"""PsiMod.print_out('\\n')\n""""""; cbsbanners += """"""banner(' CBS Setup ')\n""""""; cbsbanners += """"""PsiMod.print_out('\\n')\n\n""""""; exec(cbsbanners). # Call schemes for each portion of total energy to 'place orders' for calculations needed; d_fields = ['d_stage', 'd_scheme', 'd_basis', 'd_wfn', 'd_need', 'd_coef', 'd_energy']; f_fields = ['f_wfn', 'f_portion', 'f_basis', 'f_zeta', 'f_energy']; GRAND_NEED = []; MODELCHEM = []; bstring = ''; if do_scf:; NEED = call_function_in_1st_argument(cbs_scf_scheme,; mode='requisition', basisname=BSTR, basiszeta=ZETR, wfnname='scf'); GRAND_NEED.append(dict(zip(d_fields, ['scf', cbs_scf_scheme, reconstitute_bracketed_basis(NEED), 'scf', NEED, +1, 0.0]))). if d",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/_modules/wrappers.html:66507,energy,energy,66507,psi4manual/4.0b3/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/_modules/wrappers.html,4,['energy'],['energy']
Energy Efficiency,"above and obtain the exact energy. This is,; however, not trivial, as the density matrix elements and; cannot be varied arbitrarily, but must satisfy some; conditions that make sure that the density matrices are N-representable, i.e.; correspond to an antisymmetric N-electron wavefunction. Unfortunately, no; simple set of necessary and sufficient N-representability conditions are known,; and some of the known conditions are not easily imposed. In addition, the lack; of separability of the density matrices may result in the loss of; size-consistency and size-extensivity. In DCFT, one takes a different route and; replaces in favor of its two-particle density cumulant:. The one-particle density matrix is separated into its idempotent part; and a correction :. The idempotent part of corresponds to a mean-field Hartree-Fock-like density,; while the non-idempotent correction ; depends on the density cumulant and describes the electron correlation effects.; Inserting the above two equations into the energy expression, we obtain:. where the antisymmetrized two-electron integrals and the generalized Fock operator; matrix elements were defined as follows:. Energy functional has several important properties. First,; the energy is now a function of two sets of independent parameters, the; idempotent part of () and the density cumulant; (). As a result, the energy functional is Hermitian,; which is important for the evaluation of the molecular properties. The additive; separability of the density cumulant guarantees that all of the DCFT methods; are size-extensive and size-consistent. Furthermore, the N-representability; problem is now greatly simplified, because the idempotent part of is; N-representable by construction. One only needs to worry about the; N-representability of the density cumulant, which is a relatively small part of; .; In order to obtain the DCFT energy, two conditions must be satisfied:; 1) The energy must be stationary with respect to a set of orbitals. This",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/dcft-1.html:1959,energy,energy,1959,psi4manual/1.0.0/dcft-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/dcft-1.html,2,['energy'],['energy']
Energy Efficiency,"abspathfile = os.path.join(os.path.abspath(pth), fil); if relpath:; return os.path.relpath(abspathfile, os.getcwd()); else:; return abspathfile. [docs]def segment_color(argcolor, saptcolor):; """"""Find appropriate color expression between overall color directive; *argcolor* and particular color availibility *rxncolor*. """"""; import matplotlib. # validate any sapt color; if saptcolor is not None:; if saptcolor < 0.0 or saptcolor > 1.0:; saptcolor = None. if argcolor is None:; # no color argument, so take from rxn; if rxncolor is None:; clr = 'grey'; elif saptcolor is not None:; clr = matplotlib.cm.jet(saptcolor); else:; clr = rxncolor; elif argcolor == 'sapt':; # sapt color from rxn if available; if saptcolor is not None:; clr = matplotlib.cm.jet(saptcolor); else:; clr = 'grey'; elif argcolor == 'rgb':; # HB/MX/DD sapt color from rxn if available; if saptcolor is not None:; if saptcolor < 0.333:; clr = 'blue'; elif saptcolor < 0.667:; clr = 'green'; else:; clr = 'red'; else:; clr = 'grey'; else:; # color argument is name of mpl color; clr = argcolor. return clr. [docs]def bars(data, title='', saveas=None, relpath=False, graphicsformat=['pdf'], view=True):; """"""Generates a 'gray-bars' diagram between model chemistries with error; statistics in list *data*, which is supplied as part of the dictionary; for each participating bar/modelchem, along with *mc* keys in argument; *data*. The plot is labeled with *title* and each bar with *mc* key and; plotted at a fixed scale to facilitate comparison across projects. """"""; import hashlib; import matplotlib.pyplot as plt. # initialize plot, fix dimensions for consistent Illustrator import; fig, ax = plt.subplots(figsize=(12, 7)); plt.ylim([0, 4.86]); plt.xlim([0, 6]); plt.xticks([]). # label plot and tiers; ax.text(0.4, 4.6, title,; verticalalignment='bottom', horizontalalignment='left',; family='Times New Roman', weight='bold', fontsize=12). widths = [0.15, 0.02, 0.02, 0.02] # TT, HB, MX, DD; xval = 0.1 # starting posn along x-axis.",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/mpl.html:2246,green,green,2246,psi4manual/1.0.0/_modules/qcdb/mpl.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/mpl.html,1,['green'],['green']
Energy Efficiency,"ac 1 2 \sum_{i,j} [ii|jj] + E_{\mathrm{xc}} [\rho_\alpha, \rho_\beta] \\; &= D_{\mu\nu}^{\mathrm{T}}\left(T_{\mu\nu} +; V_{\mu\nu}\right) + \frac{1}{2} D_{\mu\nu}^{\mathrm{T}}; D_{\lambda\sigma}^{\mathrm{T}} (\mu\nu|\lambda\sigma) + E_{\mathrm{xc}} [\rho_\alpha, \rho_\beta]\end{split}\]; Here, \(T\) is the noninteracting quasiparticle kinetic energy operator,; \(V\) is the nucleus-electron attraction potential, \(D^{\mathrm{T}}\); is the total electron density matrix, and \(E_{\mathrm{xc}} [\rho_\alpha,; \rho_\beta]\) is the (potentially nonlocal) exchange, correlation, and residual; kinetic energy functional. The residual kinetic energy term is usually quite; small, and is often ignored, hence \(E_{\mathrm{xc}}\) is often referred to; as simply the exchange-correlation functional (exchange and correlation, not; just exchange-type correlation).; In practice, the first few generations of KS-DFT functionals were chosen to be; local, meaning that the form of the exchange correlation energy is an integral; over all of space of a function depending only on local information in the; density, such as the density value or derivatives. The simplest variants are; Local Spin-Density Approximations (LSDA), which depend only on the spin density; \(\rho_\alpha\) or \(\rho_\beta\),. \[\rho_\sigma (\vec r_1) = D_{\mu\nu}^{\sigma} \phi_{\mu} (\vec r_1); \phi_\nu (\vec r_1)\]; The most popular variants are Generalized Gradient Approximation (GGA); functionals which use the norm of the density gradient; \(\gamma_{\alpha\alpha}\), \(\gamma_{\alpha\beta}\) or; \(\gamma_{\beta\beta}\) to build an inhomogeneity; parameter. \[\gamma_{\alpha\alpha} (\vec r_1) = \nabla \rho_{\alpha} (\vec r_1) \cdot \nabla; \rho_{\alpha} (\vec r_1)\]. \[\gamma_{\alpha\beta} (\vec r_1) = \nabla \rho_{\alpha} (\vec r_1) \cdot \nabla; \rho_{\beta} (\vec r_1)\]; where,. \[\nabla \rho_{\sigma} (\vec r_1) = 2 D_{\mu\nu}^{\sigma} \phi_{\mu}; (\vec r_1) \nabla \phi_{\nu} (\vec r_1)\]; GGA functionals are essentially",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/dft-1.html:2824,energy,energy,2824,psi4manual/1.2.1/dft-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/dft-1.html,15,['energy'],['energy']
Energy Efficiency,"ac=0.0\n"";; # print $handle ""dfit,basis_coul=jkfit,basis_exch=jkfit,cfit_scf=3}\n"";; # print $handle ""eedisp=E2disp\n\n"";; #; # ],; }. #'dft-sapt-shift': [; #; # # this is written in an inflexible way (fixed basis, functional) so that it is computed; # # only once, then used when writing DFT-SAPT inputs, which we'll be more flexible with; #; # print $handle ""basis={\n"";; # print $handle ""set,orbital; default,aug-cc-pVQZ\n"";; # print $handle ""set,jkfit; default,avqz/jkfit\n"";; # print $handle ""set,dflhf; default,avqz/jkfit\n"";; # print $handle ""}\n"";; #; # if ($handle eq ""M1OUT"") { $charge = $cgmp{CHGmol1}; $spin = $cgmp{MLPmol1} - 1; }; # elsif ($handle eq ""M2OUT"") { $charge = $cgmp{CHGmol2}; $spin = $cgmp{MLPmol2} - 1; }; #; # print $handle ""\ngdirect\n"";; # print $handle ""{df-ks,pbex,pw91c,lhf; dftfac,0.75,1.0,0.25}\n"";; # print $handle ""basis=tzvpp\n"";; # print $handle ""{ks,pbe0; orbprint,0}\n"";; # print $handle ""eeneut=energy\n"";; # $charge += 1;; # $spin += 1;; # print $handle ""SET,CHARGE=$charge\nSET,SPIN=$spin\n"";; # print $handle ""{ks,pbe0}\n"";; # print $handle ""eecat=energy\n"";; # print $handle ""eeie=eecat-eeneut\n"";; # print $handle ""show[1,20f20.12],ee*,ce*,te*\n"";; # print $handle ""show[1,60f20.12],_E*\n"";; # ]; #'dft-sapt': [; #; # if ( ($asyA eq '') || ($asyB eq '') ) {; # print ""ERROR: asymptotic correction not defined for one or more monomers in index $system.\n"";; # close(DIOUT);; # unlink(""$pathDIOUT"");; # }; #; # print $handle ""gdirect\n"";; # print $handle ""ca=2101.2; cb=2102.2\n\n"";; #; # $spin = $cgmp{MLPmol1} - 1;; # print $handle ""SET,CHARGE=$cgmp{CHGmol1}\nSET,SPIN=$spin\ndummy"";; # foreach $at (@monoBreal) { print $handle "",$at""; }; # print $handle ""\n{df-ks,pbex,pw91c,lhf,df_basis=dflhf,basis_coul=jkfitb,basis_exch=jkfitb; dftfac,0.75,1.0,0.25; asymp,$asyA; save,\$ca}\n"";; # print $handle ""eehfa=energy; sapt; monomerA\n\n"";; #; # $spin = $cgmp{MLPmol2} - 1;; # print $handle ""SET,CHARGE=$cgmp{CHGmol2}\nSET,SPIN=$spin\ndummy"";; # foreach $at (",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/molpro.html:7968,energy,energy,7968,psi4manual/1.0.0/_modules/qcdb/molpro.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/molpro.html,4,"['charge', 'energy']","['charge', 'energy']"
Energy Efficiency,"accordingly, the \(S^{2}\) approximation implies a Heisenberg Hamiltonian; picture with a single coupling strength parameter determining all the; splittings. This method can be invoked with energy(“SF-SAPT”) and; publications resulting from the use of the SF-SAPT code should cite the; following publications: [Patkowski:2018:164110]. Higher-Order Exchange Terms without Single-Exchange Approximation¶; Recently, several SAPT higher-order exchange terms have been derived without; the \(S^{2}\) approximation: \(E_{exch-ind}^{(20)}\) [Schaffer:2012:1235],; \(E_{exch-disp}^{(20)}\) [Schaffer:2013:2570], and \(E_{exch-ind}^{(30)}\); [Waldrop:2021:024103]. The second-order terms can be computed with the following; settings:; set SAPT_DFT_FUNCTIONAL HF; set DO_IND_EXCH_SINF true # calculate Exch-Ind20 (S^inf); set SAPT_DFT_MP2_DISP_ALG fisapt; set DO_DISP_EXCH_SINF true # calculate Exch-Disp20 (S^inf); energy('sapt(dft)'). and the third-order exchange-induction term is computed as follows:; set DO_IND30_EXCH_SINF true # calculate Exch-Ind30 (S^inf); energy('sapt2+3'). These calculations are performed with the atomic orbital and; density-fitting scheme described in the Supplementary Material to; [Smith:2020:184108] for the second-order terms and in [Waldrop:2021:024103]; for the third-order exchange induction. The coupled (response) version of the; exchange-induction corrections are also calculated, exactly for; \(E_{exch-ind,resp}^{(20)}\) and by scaling the uncoupled term for; \(E_{exch-ind,resp}^{(30)}\). S^inf Keywords¶. DO_IND_EXCH_SINF¶. For SAPT0 or SAPT(DFT), compute the non-approximated second-order exchange-induction term. Type: boolean; Default: false. DO_DISP_EXCH_SINF¶. For SAPT0 or SAPT(DFT), compute the non-approximated second-order exchange-dispersion term. Type: boolean; Default: false. DO_IND30_EXCH_SINF¶. For SAPT2+3, compute the non-approximated third-order exchange-induction term. Type: boolean; Default: false. SAPT0-D¶; In SAPT0, the computation of \(E_{d",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/sapt.html:46377,energy,energy,46377,psi4manual/1.6.x/sapt.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/sapt.html,5,['energy'],['energy']
Energy Efficiency,"accuracy of the decomposition can be controlled through the keyword; CHOLESKY_TOLERANCE.; The following input file sets up a DF-CCSD(T); computation using CD integrals; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14molecule h2o {; 0 1; O; H 1 1.0; H 1 1.0 2 104.5; }. set {; scf_type cd; cc_type cd; basis aug-cc-pvdz; freeze_core true; }; energy('ccsd(t)'). The resulting CCSD(T) correlation energy will be equivalent to that; obtained from a conventional computation if CHOLESKY_TOLERANCE is; sufficiently small (e.g. 1e-9). Gn theory¶; The FNOCC module contains all the components that comprise the Gn family; of composite methods. Currently, only the G2 method is supported; [Curtiss:1991:7221]. The G2 procedure may be called through the; energy() wrapper:; 1energy('gaussian-2'). Supported methods¶; The various methods supported by the FNOCC module in PSI4 are detailed; in Table FNOCC Methods. Note that these methods; are implemented for closed-shell references only. For open-shell references,; the calls energy('mp2.5'), energy('mp3'), and energy('mp4') will; default to implementations of these methods in other modules. name; calls method; type select. qcisd; quadratic configuration interaction singles doubles; CI_TYPE CONV. qcisd(t); qcisd with perturbative triples; CI_TYPE CONV. mp2.5; average of second- and third-order perturbation theories; MP_TYPE CONV. mp3; third-order perturbation theory; MP_TYPE CONV. mp4(sdq); fourth-order perturbation theory, minus triples contribution; MP_TYPE CONV. mp4; full fourth-order perturbation theory; MP_TYPE CONV. lccd; linear ccd; CC_TYPE CONV. cepa(0), lccsd; coupled electron pair approximation, variant 0; CC_TYPE CONV. cepa(1); coupled electron pair approximation, variant 1; CC_TYPE CONV. cepa(3); coupled electron pair approximation, variant 3; CC_TYPE CONV. acpf; averaged coupled-pair functional; CC_TYPE CONV. aqcc; averaged quadratic coupled-cluster; CC_TYPE CONV. cisd; configuration interaction with single and double excitations; ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/fnocc-1.html:12892,energy,energy,12892,psi4manual/1.1.0/fnocc-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/fnocc-1.html,6,['energy'],['energy']
Energy Efficiency,"ace them into your “rc” file and open a new terminal. (To; use a staged installation directory, substitute; objdir/stage/prefix for prefix.); # csh, tcsh: add to shell or ~/.tcshrc file; setenv PYTHONPATH {prefix}/lib:$PYTHONPATH; setenv PSI_SCRATCH /path/to/existing/writable/local-not-network/directory/for/scratch/files. # sh, bash: add to shell or ~/.bashrc (Linux/Windows) or ~/.bash_profile (Mac) file; export PYTHONPATH={prefix}/lib:$PYTHONPATH; export PSI_SCRATCH=/path/to/existing/writable/local-not-network/directory/for/scratch/files. Note; If you know the location of the PSI4 executable; (bin/psi4) and want to know the corresponding location to add to; PYTHONPATH, execute psi4 --psiapi-path. It will return; bash commands to set PATH (for correct python interpreter); and PYTHONPATH (to find psi4 module) correctly, after which; python -c ""import psi4"" will work. Run PSI4.; 1; 2; 3; 4; 5; 6; 7; 8; 9>>> cat sample.py; import psi4; mol = psi4.geometry(""""""; He; """"""); psi4.energy('hf/cc-pvdz'); psi4.compare_values(-2.85518839, psi4.core.get_variable('current energy'), 5, 'SCF E'); >>> python sample.py; SCF E.............................................................PASSED. How to run Psi4 as executable or Python module from conda installation¶; The configuration commands below are generic versions of the ones printed; to your screen as advice upon installing PSI4 into a Anaconda,; Miniconda, or Psi4conda distribution, condadist =; ana|mini|psi4conda. If which conda python psi4 points to your; condadist and echo $PSI_SCRATCH is set, skip ahead to the; “Run PSI4” commands below. Otherwise, issue the following; commands directly in your terminal or place them into your “rc” file and; open a new terminal.; If you installed the Psi4conda distribution or installed the PSI4; conda package into the main environment of an Anaconda or Miniconda; distribution and added that to your PATH, as prompted, then; which psi4 likely yields condadist/bin/psi4 and the PATH; setting lines",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/build_planning-1.html:20909,energy,energy,20909,psi4manual/1.1.0/build_planning-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/build_planning-1.html,2,['energy'],['energy']
Energy Efficiency,"aced point groups; core.set_parent_symmetry(molecule.schoenflies_symbol()). ndisp = len(findif_meta_dict[""displacements""]) + 1. print("""""" %d displacements needed."""""" % ndisp). wfn = _process_displacement(gradient, lowername, molecule, findif_meta_dict[""reference""], 1, ndisp,; **kwargs); var_dict = core.variables(). for n, displacement in enumerate(findif_meta_dict[""displacements""].values(), start=2):; _process_displacement(; gradient, lowername, molecule, displacement, n, ndisp, write_orbitals=False, **kwargs). # Reset variables; for key, val in var_dict.items():; core.set_variable(key, val). # Assemble Hessian from gradients; # Final disp is undisp, so wfn has mol, G, H general to freq calc; H = driver_findif.compute_hessian_from_gradients(findif_meta_dict, irrep); wfn.set_hessian(core.Matrix.from_array(H)); wfn.set_gradient(G0). # Explicitly set the current energy..; core.set_variable('CURRENT ENERGY', findif_meta_dict[""reference""][""energy""]); wfn.set_variable('CURRENT ENERGY', findif_meta_dict[""reference""][""energy""]). core.set_parent_symmetry(''); optstash.restore(); optstash_conv.restore(). else:; core.print_out(""""""hessian() will perform frequency computation by finite difference of analytic energies.\n""""""). # Set method-dependent scf convergence criteria (test on procedures['energy'] since that's guaranteed); optstash.restore(); optstash_conv.restore(); optstash_conv = driver_util._set_convergence_criterion('energy', lowername, 10, 11, 10, 11, 10). # Obtain list of displacements; findif_meta_dict = driver_findif.hessian_from_energy_geometries(molecule, irrep). # Record undisplaced symmetry for projection of diplaced point groups; core.set_parent_symmetry(molecule.schoenflies_symbol()). ndisp = len(findif_meta_dict[""displacements""]) + 1. print(' %d displacements needed.' % ndisp). wfn = _process_displacement(energy, lowername, molecule, findif_meta_dict[""reference""], 1, ndisp,; **kwargs); var_dict = core.variables(). for n, displacement in enumerate(findif_meta_",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver.html:67233,energy,energy,67233,psi4manual/1.3.2/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver.html,1,['energy'],['energy']
Energy Efficiency,"acement in enumerate(findif_meta_dict[""displacements""].values(), start=2):; _process_displacement(; energy, lowername, molecule, displacement, n, ndisp, write_orbitals=False, **kwargs). # Reset variables; for key, val in var_dict.items():; core.set_variable(key, val). # Assemble Hessian from energies; H = driver_findif.assemble_hessian_from_energies(findif_meta_dict, irrep); wfn.set_hessian(core.Matrix.from_array(H)); wfn.set_gradient(G0). # Explicitly set the current energy..; if isinstance(lowername, str) and lowername in procedures['energy']:; # this correctly filters out cbs fn and ""hf/cc-pvtz""; # it probably incorrectly filters out mp5, but reconsider in DDD; core.set_variable(f""CURRENT HESSIAN"", H); core.set_variable(f""{lowername.upper()} TOTAL HESSIAN"", H); core.set_variable(f""{lowername.upper()} TOTAL GRADIENT"", G0); wfn.set_variable(f""{lowername.upper()} TOTAL HESSIAN"", H); wfn.set_variable(f""{lowername.upper()} TOTAL GRADIENT"", G0); core.set_variable('CURRENT ENERGY', findif_meta_dict[""reference""][""energy""]); wfn.set_variable('CURRENT ENERGY', findif_meta_dict[""reference""][""energy""]). core.set_global_option(""PARENT_SYMMETRY"", """"); optstash.restore(); optstash_conv.restore(). _hessian_write(wfn). if return_wfn:; return (wfn.hessian(), wfn); else:; return wfn.hessian(). [docs]def frequency(name, **kwargs):; r""""""Function to compute harmonic vibrational frequencies. :aliases: frequencies(), freq(). :returns: *float* |w--w| Total electronic energy in Hartrees. :returns: (*float*, :py:class:`~psi4.core.Wavefunction`) |w--w| energy and wavefunction when **return_wfn** specified. :type name: str; :param name: ``'scf'`` || ``'mp2'`` || ``'ci5'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the system. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :type return_wfn: :ref:`boolean <op_py_boolean>`; :param return_wfn: ``'on'`` ||",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/_modules/psi4/driver/driver.html:82769,energy,energy,82769,psi4manual/1.5.0/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/_modules/psi4/driver/driver.html,3,"['ENERGY', 'energy']","['ENERGY', 'energy']"
Energy Efficiency,"acement[""geometry""], (-1, 3)); clone.set_geometry(core.Matrix.from_array(geom_array)). # If the user insists on symmetry, weaken it if some is lost when displacing.; if molecule.symmetry_from_input():; disp_group = clone.find_highest_point_group(); new_bits = parent_group.bits() & disp_group.bits(); new_symm_string = qcdb.PointGroup.bits_to_full_name(new_bits); clone.reset_point_group(new_symm_string). # clean possibly necessary for n=1 if its irrep (unsorted in displacement list) different from initial G0 for freq; core.clean(). # Perform the derivative calculation; derivative, wfn = derivfunc(method, return_wfn=True, molecule=clone, **kwargs); displacement[""energy""] = core.variable('CURRENT ENERGY'). # If we computed a first or higher order derivative, set it.; if derivfunc == gradient:; displacement[""gradient""] = wfn.gradient().np.ravel().tolist(). # clean may be necessary when changing irreps of displacements; core.clean(). return wfn. [docs]def energy(name, **kwargs):; r""""""Function to compute the single-point electronic energy. :returns: *float* |w--w| Total electronic energy in Hartrees. SAPT & EFP return interaction energy. :returns: (*float*, :py:class:`~psi4.core.Wavefunction`) |w--w| energy and wavefunction when **return_wfn** specified. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`CURRENT ENERGY <CURRENTENERGY>`; * :psivar:`CURRENT REFERENCE ENERGY <CURRENTREFERENCEENERGY>`; * :psivar:`CURRENT CORRELATION ENERGY <CURRENTCORRELATIONENERGY>`. :type name: string; :param name: ``'scf'`` || ``'mp2'`` || ``'ci5'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the system. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :type return_wfn: :ref:`boolean <op_py_boolean>`; :param return_wfn: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return the :py:class:`~psi4.core.Wavefunction`; calculation result as the s",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver.html:6876,energy,energy,6876,psi4manual/1.3.2/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver.html,2,['energy'],['energy']
Energy Efficiency,"ach reagent required for the subset of database reactions requested.; Note that this is an un-counterpoise-corrected example, and the wrapper is smart enough; to compute only once the monomer whose energy will be subtracted from each of the three dimers.; RGC1-HeHe-0.85-dimer; RGC1-He-mono-unCP; RGC1-HeHe-1.0-dimer; RGC1-HeHe-1.5-dimer. At the end of the job, the Requested Energy table is printed that gives the total; energies for the requested model chemistry for each reagent and each reaction, as; well as the stoichiometric weights by which the reagent energies are transformed; into the reaction energy. In this case, the dimer is +1 and the monomer is -2,; indicating the interaction energy is computed from dimer less first monomer; less second (identical) monomer. Error statistics are computed with respect to the reference; energies stored in the database. One of these, the mean absolute deviation, is; returned by the wrapper as an ordinary Python variable. (For databases; without a stored reference energy, e.g., BASIC, large and meaningless numbers are; printed for error.) The other two tables tabulate the PSI variables requested; through keyword tabulate, in this case the total SCF energy and the number; of atoms in each reagent.; ==> Mp2 Total Energy <==. ------------------------------------------------------------------------------------------------------; Reaction Reaction Value Reagent 1 Reagent 2; Value Wt Value Wt; ------------------------------------------------------------------------------------------------------; RGC1-HeHe-0.85 0.00004802 -5.69430495 1 -2.84717649 -2; RGC1-HeHe-1.0 -0.00000064 -5.69435362 1 -2.84717649 -2; ------------------------------------------------------------------------------------------------------. ==> Requested Energy <==. ------------------------------------------------------------------------------------------------------; Reaction Reaction Energy Reaction Error Reagent 1 Reagent 2; Ref Calc [kcal/mol] [kJ/mol] [Eh] Wt [Eh",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/db-1.html:7448,energy,energy,7448,psi4manual/1.4.0/db-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/db-1.html,9,['energy'],['energy']
Energy Efficiency,"action energies for three complexes in S22; >>> # Error statistics computed wrt an old benchmark, S22A; >>> database('mp2','S22',cp=1,subset=[16,17,8],benchmark='S22A'). >>> # [3] SAPT0 on the neon dimer dissociation curve; >>> db('sapt0',subset='NeNe',cp=0,symm=0,db_name='RGC10'). >>> # [4] Optimize system 1 in database S22, producing tables of scf and mp2 energy; >>> db('mp2','S22',db_func=optimize,subset=[1], tabulate=['mp2 total energy','current energy']). >>> # [5] CCSD on the smallest systems of HTBH, a hydrogen-transfer database; >>> database('ccsd','HTBH',subset='small', tabulate=['ccsd total energy', 'mp2 total energy']). Output¶; At the beginning of a database job is printed a listing of the individual system; calculations which will be performed. The output snippet below is from the example job [1]; above. It shows each reagent required for the subset of database reactions requested.; Note that this is an un-counterpoise-corrected example, and the wrapper is smart enough; to compute only once the monomer whose energy will be subtracted from each of the three dimers.; 1; 2; 3; 4RGC1-HeHe-0.85-dimer; RGC1-He-mono-unCP; RGC1-HeHe-1.0-dimer; RGC1-HeHe-1.5-dimer. At the end of the job, the Requested Energy table is printed that gives the total; energies for the requested model chemistry for each reagent and each reaction, as; well as the stoichiometric weights by which the reagent energies are transformed; into the reaction energy. In this case, the dimer is +1 and the monomer is -2,; indicating the interaction energy is computed from dimer less first monomer; less second (identical) monomer. Error statistics are computed with respect to the reference; energies stored in the database. One of these, the mean absolute deviation, is; returned by the wrapper as an ordinary Python variable. (For databases; without a stored reference energy, e.g., BASIC, large and meaningless numbers are; printed for error.) The other two tables tabulate the PSI variables requested;",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/db-1.html:6614,energy,energy,6614,psi4manual/1.3.2/db-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/db-1.html,2,['energy'],['energy']
Energy Efficiency,"action energies for three complexes in S22; >>> # Error statistics computed wrt an old benchmark, S22A; >>> database('mp2','S22',cp=1,subset=[16,17,8],benchmark='S22A'). >>> # [3] SAPT0 on the neon dimer dissociation curve; >>> db('sapt0',subset='NeNe',cp=0,symm=0,db_name='RGC10'). >>> # [4] Optimize system 1 in database S22, producing tables of scf and mp2 energy; >>> db('mp2','S22',db_func=optimize,subset=[1], tabulate=['mp2 total energy','current energy']). >>> # [5] CCSD on the smallest systems of HTBH, a hydrogen-transfer database; >>> database('ccsd','HTBH',subset='small', tabulate=['ccsd total energy', 'mp2 total energy']). Output¶; At the beginning of a database job is printed a listing of the individual system; calculations which will be performed. The output snippet below is from the example job [1]; above. It shows each reagent required for the subset of database reactions requested.; Note that this is an un-counterpoise-corrected example, and the wrapper is smart enough; to compute only once the monomer whose energy will be subtracted from each of the three dimers.; RGC1-HeHe-0.85-dimer; RGC1-He-mono-unCP; RGC1-HeHe-1.0-dimer; RGC1-HeHe-1.5-dimer. At the end of the job, the Requested Energy table is printed that gives the total; energies for the requested model chemistry for each reagent and each reaction, as; well as the stoichiometric weights by which the reagent energies are transformed; into the reaction energy. In this case, the dimer is +1 and the monomer is -2,; indicating the interaction energy is computed from dimer less first monomer; less second (identical) monomer. Error statistics are computed with respect to the reference; energies stored in the database. One of these, the mean absolute deviation, is; returned by the wrapper as an ordinary Python variable. (For databases; without a stored reference energy, e.g., BASIC, large and meaningless numbers are; printed for error.) The other two tables tabulate the PSI variables requested; through k",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/db-1.html:6629,energy,energy,6629,psi4manual/1.4.0/db-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/db-1.html,9,['energy'],['energy']
Energy Efficiency,"action energies for three complexes in S22; >>> # Error statistics computed wrt an old benchmark, S22A; >>> database('mp2','S22',cp=1,subset=[16,17,8],benchmark='S22A'). >>> # [3] SAPT0 on the neon dimer dissociation curve; >>> db('sapt0',subset='NeNe',cp=0,symm=0,db_name='RGC10'). >>> # [4] Optimize system 1 in database S22, producing tables of scf and mp2 energy; >>> db('mp2','S22',db_func=optimize,subset=[1], tabulate=['mp2 total energy','current energy']). >>> # [5] CCSD on the smallest systems of HTBH, a hydrogen-transfer database; >>> database('ccsd','HTBH',subset='small', tabulate=['ccsd total energy', 'mp2 total energy']). Output¶; At the beginning of a database job is printed a listing of the individual system; calculations which will be performed. The output snippet below is from the example job [1]; above. It shows each reagent required for the subset of database reactions requested.; Note that this is an un-counterpoise-corrected example, and the wrapper is smart enough; to compute only once the monomer whose energy will be subtracted from each of the three dimers.; RGC1-HeHe-0.85-dimer; RGC1-He-mono-unCP; RGC1-HeHe-1.0-dimer; RGC1-HeHe-1.5-dimer. At the end of the job, the Requested Energy table is printed that gives the total; energies for the requested model chemistry for each reagent and each reaction, as; well as the stoichoimetric weights by which the reagent energies are transfromed; into the reaction energy. In this case, the dimer is +1 and the monomer is -2,; indicating the the interaction energy is computed from dimer less first monomer; less second (identical) monomer. Error statistics are computed with respect to the reference; energies stored in the database. One of these, the mean absolute deviation, is; returned by the wrapper as an ordinary Python variable. (For databases; without a stored reference energy, e.g., BASIC, large and meaningless numbers are; printed for error.) The other two tables tabulate the PSI variables requested; throu",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/db-1.html:6380,energy,energy,6380,psi4manual/1.0.0/db-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/db-1.html,2,['energy'],['energy']
Energy Efficiency,"active[lf])); else:; text.append(' post-proj low-frequency mode: {:9.4f} [cm^-1] ({})'.format(vlf.real, active[lf])); text.append(' post-proj all modes:' + str(_format_omega(frequency_cm_1, 4)) + '\n'); if project_trans and not project_rot:; text.append(f' Note that ""Vibration""s include {nrt_expected - 3} un-projected rotation-like modes.'); elif not project_trans and not project_rot:; text.append(; f' Note that ""Vibration""s include {nrt_expected} un-projected rotation-like and translation-like modes.'). # general conversion factors, LAB II.11; uconv_K = (constants.h * constants.na * 1.0e21) / (8 * np.pi * np.pi * constants.c); uconv_S = np.sqrt((constants.c * (2 * np.pi * constants.bohr2angstroms)**2) /; (constants.h * constants.na * 1.0e21)). # normco & reduced mass, LAB II.14 & II.15; wL = np.einsum('i,ij->ij', sqrtmmminv, qL); vibinfo['w'] = Datum('normal mode', 'a0', wL, comment='un-mass-weighted'). reduced_mass_u = np.divide(1.0, np.linalg.norm(wL, axis=0)**2); vibinfo['mu'] = Datum('reduced mass', 'u', reduced_mass_u). xL = np.sqrt(reduced_mass_u) * wL; vibinfo['x'] = Datum('normal mode', 'a0', xL, comment='normalized un-mass-weighted'). # IR intensities, CCQC Proj. Eqns. 15-16; uconv_kmmol = (constants.get(""Avogadro constant"") * np.pi * 1.e-3 * constants.get(""electron mass in u"") *; constants.get(""fine-structure constant"")**2 * constants.get(""atomic unit of length"") / 3); uconv_D2A2u = (constants.get('atomic unit of electric dipole mom.') * 1.e11 /; constants.get('hertz-inverse meter relationship') /; constants.get('atomic unit of length'))**2; if not (dipder is None or np.array(dipder).size == 0):; qDD = dipder.dot(wL); ir_intensity = np.zeros(qDD.shape[1]); for i in range(qDD.shape[1]):; ir_intensity[i] = qDD[:, i].dot(qDD[:, i]); # working but not needed; #vibinfo['IR_intensity'] = Datum('infrared intensity', 'Eh a0/u', ir_intensity); #ir_intensity_D2A2u = ir_intensity * uconv_D2A2u; #vibinfo['IR_intensity'] = Datum('infrared intensity', '(D/AA)^2/u', ir_i",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/_modules/qcdb/vib.html:21566,reduce,reduced,21566,psi4manual/1.9.x/_modules/qcdb/vib.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/_modules/qcdb/vib.html,8,['reduce'],['reduced']
Energy Efficiency,"actly alike.; The -D3 interface can use classic or simple-dftd3 programs interchangeably and will prefer the latter.; Despite different defaults in these programs when run independently,; when run through PSI4 as EmpiricalDispersion engine, each should; produce the same result. Moreover, PSI4‘s own defaults and aliases; are unchanged by the new engines, so -D continues to mean -D2,; -D3 continues to mean zero-damping without 3-body correction,; and input files should continue producing the same results. Please file; an issue if found otherwise.; Dispersion corrections are built into DFT functionals, so appending an a; posteriori correction to a computation is as simple as; energy('b2plyp-d') vs. energy('b2plyp'). For example, the; following input file computes (with much redundant work) for water a; B3LYP, a B3LYP-D2, a B3LYP-D3 (zero-damping), and a B3LYP-D4 (Becke-Johnson damping) energy.; molecule h2o {; O; H 1 1.0; H 1 1.0 2 104.5; }; set {; basis cc-pVDZ; }; energy('b3lyp'); energy('b3lyp-d'); energy('b3lyp-d3'); energy('b3lyp-d4'). Consult the table -D Functionals to see for each; functional what corrections are available and what default parameters; define them. The dispersion correction is available after a calculation in; the PSI variable DISPERSION CORRECTION ENERGY.; By default, the output from the dftd3; program is suppressed; to see it in the output file, set print > 2.; No text output is available from the dftd4 or s-dftd3 programs. Variants of dispersion corrections¶. Extension [1] and Aliases; Variant; Computing Program (engine); DFT_DISPERSION_PARAMETERS [11]. -D; alias to -D2. -D1; -D1 [2]; PSI4‘s libdisp; [\(s_6\)]. -D2; -D2 [3]; PSI4‘s libdisp OR dftd3; [\(s_6\), \(\alpha_6\), \(s_{r,6}\)]. -D3ZERO2B, -D3ZERO, -D32B, -D3; -D3 [4] w/ original zero-damping w/o 3-body ATM; s-dftd3 or dftd3; [\(s_6\), \(s_8\), \(s_{r,6}\), \(\alpha_6\), \(s_{r,8}\)]. -D3ZEROATM; -D3 [4] w/ original zero-damping w/ 3-body ATM; s-dftd3; [\(s_6\), \(s_8\), \(s_{r,6}\), ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/dftd3.html:7286,energy,energy,7286,psi4manual/1.7.x/dftd3.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/dftd3.html,8,['energy'],['energy']
Energy Efficiency,"actor for dipoles ; psi_c_au = 137.035999679 # Speed of light in atomic units ; psi_hartree2ev = 27.21138 # Hartree to eV conversion factor ; psi_hartree2wavenumbers = 219474.6 # Hartree to cm$^{-1}$ conversion factor ; psi_hartree2kcalmol = 627.5095 # Hartree to kcal mol$^{-1}$ conversion factor ; psi_hartree2MHz = 6.579684E9 # Hartree to MHz conversion factor ; psi_kcalmol2wavenumbers = 349.7551 # kcal mol$^{-1}$ to cm$^{-1}$ conversion factor ; psi_e0 = 8.854187817E-12 # Vacuum permittivity (Fm$^{-1}$) ; psi_na = 6.02214179E23 # Avagadro's number ; psi_me = 9.10938215E-31 # Electron rest mass (in kg) . wrappers¶; Module with functions that call the four main driver; functions: driver.energy, driver.optimize,; driver.response, and driver.frequency. auto_fragments(name, **kwargs)[source]¶; Detects fragments if the user does not supply them.; Currently only used for the WebMO implementation of SAPT; usage: auto_fragments(‘’). call_function_in_1st_argument(funcarg, **largs)[source]¶; Function to make primary function call to energy(), opt(), etc.; with options dictionary largs.; Useful when funcarg to call is stored in variable. convert(p, symbol)[source]¶. reconstitute_bracketed_basis(needarray)[source]¶; Function to reform a bracketed basis set string from a sequential series; of basis sets (e.g, form ‘cc-pv[q5]z’ from array [cc-pvqz, cc-pv5z]). The; basis set array is extracted from the f_basis field of a NEED dictionary in; complete_basis_set(). Result is used to print a nicely; formatted basis set string in the results table. split_menial(menial)[source]¶; Function used by complete_basis_set() to separate; menial ‘scftot’ into [scf, tot] and ‘mp2corl’ into [mp2, corl]. tblhead(tbl_maxrgt, tbl_delimit, ttype)[source]¶; Function that prints the header for the changable-width results tables in db().; tbl_maxrgt is the number of reagent columns the table must plan for. tbl_delimit; is a string of dashes of the correct length to set off the table. ttype is 1 for; tab",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/autodoc_driver-1.html:11853,energy,energy,11853,psi4manual/4.0b2/autodoc_driver-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/autodoc_driver-1.html,6,['energy'],['energy']
Energy Efficiency,"acts density matrices with derivative integrals, to compute gradients.; ; detci(...); detci() -> float :; Runs the determinant-based configuration interaction code.; ; dfmp2(...); dfmp2() -> float :; Runs the DF-MP2 code.; ; dfmp2grad(...); dfmp2grad() -> float :; Runs the DF-MP2 gradient.; ; dftsapt(...); dftsapt( (Wavefunction)arg1, (Wavefunction)arg2, (Wavefunction)arg3) -> float :; Runs the DFT variant of the symmetry adapted perturbation theory code.; ; fd_1_0(...); fd_1_0( (list)arg1) -> PsiReturnType :; Performs a finite difference gradient computation, from energy points.; ; fd_freq_0(...); fd_freq_0( (list)arg1, (int)arg2) -> PsiReturnType :; Performs a finite difference frequency computation, from energy points, for a given irrep.; ; fd_freq_1(...); fd_freq_1( (list)arg1, (int)arg2) -> PsiReturnType :; Performs a finite difference frequency computation, from gradients, for a given irrep.; ; fd_geoms_1_0(...); fd_geoms_1_0() -> matrix_vector :; Gets the list of displacements needed for a finite difference gradient computation, from energy points.; ; fd_geoms_freq_0(...); fd_geoms_freq_0( (int)arg1) -> matrix_vector :; Gets the list of displacements needed for a finite difference frequency computation, from energy points, for a given irrep.; ; fd_geoms_freq_1(...); fd_geoms_freq_1( (int)arg1) -> matrix_vector :; Gets the list of displacements needed fof a finite difference frequency computation, from gradients, for a given irrep; ; fd_geoms_hessian_0(...); fd_geoms_hessian_0() -> matrix_vector :; Gets the list of displacements needed fof a finite difference frequency computation, from energy points.; ; fd_hessian_0(...); fd_hessian_0( (list)arg1) -> PsiReturnType :; Performs a finite difference frequency computation, from energy points.; ; flush_outfile(...); flush_outfile() -> None :; Flushes the output file.; ; fnocc(...); fnocc() -> float :; Runs the fno-ccsd(t)/qcisd(t)/mp4/cepa energy code; ; get_active_molecule(...); get_active_molecule() -> Molecule :;",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/psimod-1.html:106716,energy,energy,106716,psi4manual/4.0b4/psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod-1.html,2,['energy'],['energy']
Energy Efficiency,"ad) # P::e DFMP2; dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('MP2 TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('MP2 CORRELATION ENERGY')); for k, v in dfmp2_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); core.tstop(); return dfmp2_wfn. def run_dfmp2d_gradient(name, **kwargs):; """"""Encode MP2-D method."""""". dfmp2_wfn = run_dfmp2_gradient('mp2', **kwargs); wfn_grad = dfmp2_wfn.gradient().clone(). _, _disp_functor = build_functional_and_disp('MP2D', restricted=True); disp_grad = _disp_functor.compute_gradient(dfmp2_wfn.molecule(), dfmp2_wfn); wfn_grad.add(disp_grad); dfmp2_wfn.set_gradient(wfn_grad). dfmp2_wfn.set_variable('MP2D CORRELATION ENERGY', dfmp2_wfn.variable('MP2 CORRELATION ENERGY') + dfmp2_wfn.variable('DISPERSION CORRECTION ENERGY')); dfmp2_wfn.set_variable('MP2D TOTAL ENERGY', dfmp2_wfn.variable('MP2D CORRELATION ENERGY') + dfmp2_wfn.variable('HF TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('MP2D TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('MP2D CORRELATION ENERGY')). # Shove variables into global space; for k, v in dfmp2_wfn.variables().items():; core.set_variable(k, v). return dfmp2_wfn. def run_ccenergy(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a CCSD, CC2, and CC3 calculation. """"""; optstash = p4util.OptionsState(; ['TRANSQT2', 'WFN'],; ['CCSORT', 'WFN'],; ['CCENERGY', 'WFN']). if name == 'ccsd':; core.set_local_option('TRANSQT2', 'WFN', 'CCSD'); core.set_local_option('CCSORT', 'WFN', 'CCSD'); core.set_local_option('CCTRANSORT', 'WFN', 'CCSD'); core.set_local_option('CCENERGY', 'WFN', 'CCSD'); elif name == 'ccsd(t)':; core.set_local_option('TRANSQT2', 'WFN', 'CCSD_T'); core.set_local_option('CCSORT', 'WFN', 'CCSD_T'); core.set_local_option('CCTRANSORT', 'WFN', 'CCSD_T'); core.set_local_option('CCENERGY', 'WFN', 'CCSD_T'); elif name == 'a-ccsd(t)':; core.set_local_op",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:89682,ENERGY,ENERGY,89682,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,3,['ENERGY'],['ENERGY']
Energy Efficiency,"ad1; Sample UHF/cc-pVDZ H2O computation on a doublet cation, using RHF/cc-pVDZ orbitals for the closed-shell neutral as a guess. cc43; RHF-CC2-LR/STO-3G optical rotation of (S)-methyloxirane. gauge = both, omega = (589 355 nm). cc41; RHF-CC2-LR/cc-pVDZ optical rotation of H2O2. gauge = both, omega = (589 355 nm). molden2; Test of the superposition of atomic densities (SAD) guess, using a highly distorted water geometry with a cc-pVDZ basis set. This is just a test of the code and the user need only specify guess=sad to the SCF module’s (or global) options in order to use a SAD guess. The test is first performed in C2v symmetry, and then in C1. dfcasscf-sa-sp; Example of state-averaged CASSCF for the C2 molecule. dfomp3-grad2; DF-OMP3 cc-pVDZ gradients for the H2O+ cation. dfmp2-grad2; DF-MP2 cc-pVDZ gradient for the NO molecule. cc38; RHF-CC2-LR/cc-pVDZ static polarizabilities of HOF molecule. frac; Carbon/UHF Fractionally-Occupied SCF Test Case. cc34; RHF-CCSD/cc-pVDZ energy of H2O partitioned into pair energy contributions. sapt2; SAPT0 aug-cc-pVDZ computation of the benzene-methane interaction energy, using the aug-pVDZ-JKFIT DF basis for SCF, the aug-cc-pVDZ-RI DF basis for SAPT0 induction and dispersion, and the aug-pVDZ-JKFIT DF basis for SAPT0 electrostatics and induction. This example uses frozen core as well as asyncronous I/O while forming the DF integrals and CPHF coefficients. rasscf-sp; 6-31G** H2O Test RASSCF Energy Point will default to only singles and doubles in the active space. omp2p5-grad1; OMP2.5 cc-pVDZ gradient for the H2O molecule. cisd-sp; 6-31G** H2O Test CISD Energy Point. opt-multi-frozen-dimer-c2h; Frozen-fragment opt of C2h methane dimer with user-combined reference points. dfmp2-4; conventional and density-fitting mp2 test of mp2 itself and setting scs-mp2. cc54; CCSD dipole with user-specified basis set. pywrap-db1; Database calculation, so no molecule section in input file. Portions of the full databases, restricted by subset keyword,",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/testsuite-1.html:22892,energy,energy,22892,psi4manual/1.1.0/testsuite-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/testsuite-1.html,8,['energy'],['energy']
Energy Efficiency,"ad3; Restricted DF-DCT ODC-12 gradient for ethylene with cc-pVDZ/cc-pVDZ-RI standard/auxiliary basis set. mints10; H2 with tiny basis set, to test basis set parser’s handling of integers. mp2-h; check that methods can act on single atom. dfep2-2; Compute three IP and 2 EA’s for the PH3 molecule. cdremp-1; Cholesky decomposed REMP/cc-pVDZ energies for the CO2 molecule. cbs-xtpl-opt; Various extrapolated optimization methods for the H2 molecule. lccd-grad2; LCCD cc-pVDZ gradient for the NO radical. cc32; CC3/cc-pVDZ H2O \(R_e\) geom from Olsen et al., JCP 104, 8007 (1996). tdscf-6; td-camb3lyp with DiskDF and method/basis specification. cdomp2-2; OMP2 cc-pVDZ energy for the NO molecule. cc13; UHF-CCSD/cc-pVDZ \(^{3}B_1\) CH2 geometry optimization via analytic gradients. casscf-sp; CASSCF/6-31G** energy point. cc13a; UHF-CCSD(T)/cc-pVDZ \(^{3}B_1\) CH2 geometry optimization via analytic gradients. cbs-xtpl-func; optimization with method defined via cbs. omp3-2; OMP3 cc-pCVDZ energy with ROHF initial guess for the NO radical. dfmp2-fc; Kr–Kr nocp energies with all-electron basis set to check frozen core. scf-occ; force occupations in scf. cdoremp-energy2; density fitted OO-REMP/cc-pVDZ engrad single points for the H2O+ molecule. dft-b2plyp; Double-hybrid density functional B2PYLP. Reproduces portion of Table I in S. Grimme’s J. Chem. Phys 124 034108 (2006) paper defining the functional. cc5; RHF CCSD(T) cc-pVDZ frozen-core energy of C4NH4 Anion. aediis-2; EDIIS test case from 10.1063/1.1470195. sapt7; SAPT0 open-shell computation of H2O-HO2 interaction energy First with cc-pVDZ and density fitted integrals with UHF Then with 6-31g and direct integrals, except for dispersion that is computed with cc-pVDZ-ri density fitting with UHF. isapt2; This is a shorter version if isapt1 - does not do cube plots. See isapt1 for full details. dfccsd1; DF-CCSD cc-pVDZ energy for the H2O molecule. nbody-freq; Vibrational and thermo analysis of water trimer (geometry from J. Chem. Theory",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/autodoc_testsuite_corepsi4.html:34695,energy,energy,34695,psi4manual/master/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/master/autodoc_testsuite_corepsi4.html,2,['energy'],['energy']
Energy Efficiency,"add_atom(self: psi4.core.Molecule, Z: float, x: float, y: float, z: float, symbol: str, mass: float, charge: float, label: str, A: int) → None¶; Adds to self Molecule an atom with atomic number Z, Cartesian coordinates in Bohr (x, y, z), atomic symbol, mass, and charge, extended atomic label, and mass number A. atom_at_position(*args, **kwargs)¶; Overloaded function. atom_at_position(self: psi4.core.Molecule, coord: float, tol: float) -> int. Tests to see if an atom is at the position coord with a given tolerance tol. atom_at_position(self: psi4.core.Molecule, coord: List[float[3]], tol: float) -> int. Tests to see if an atom is at the position coord with a given tolerance tol. basis_on_atom(self: psi4.core.Molecule, arg0: int) → str¶; Gets the label of the orbital basis set on a given atom arg0. center_of_mass(self: psi4.core.Molecule) → psi4.core.Vector3¶; Computes center of mass of molecule (does not translate molecule). charge(self: psi4.core.Molecule, atom: int) → float¶; Gets charge of atom (0-indexed without dummies). clone(self: psi4.core.Molecule) → psi4.core.Molecule¶; Returns a new Molecule identical to arg1. com_fixed(self: psi4.core.Molecule) → bool¶; Gets whether or not center of mass is fixed. comment(self: psi4.core.Molecule) → str¶; Gets molecule comment. connectivity(self: psi4.core.Molecule) → List[Tuple[int, int, float]]¶; Gets molecule connectivity. create_psi4_string_from_molecule(self: psi4.core.Molecule) → str¶; Gets a string re-expressing in input format the current state of the molecule.Contains Cartesian geometry info, fragmentation, charges and multiplicities, and any frame restriction. deactivate_all_fragments(self: psi4.core.Molecule) → None¶; Sets all fragments in the molecule to be inactive. distance_matrix(self: psi4.core.Molecule) → psi4.core.Matrix¶; Returns Matrix of interatom distances. extract_subsets(*args, **kwargs)¶; Overloaded function. extract_subsets(self: psi4.core.Molecule, arg0: List[int], arg1: List[int]) -> psi4.core.M",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/api/psi4.core.molecule.html:16538,charge,charge,16538,psi4manual/1.3.2/api/psi4.core.molecule.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/api/psi4.core.molecule.html,7,['charge'],['charge']
Energy Efficiency,"added:: 0.6. :returns: None. :param wfn: set of molecule, basis, orbitals from which to generate fchk file. :param filename: destination file name for FCHK file. :param debug: returns a dictionary to aid with debugging. :param strict_label: If true set a density label compliant with what Gaussian would write. A warning will be printed if this is not possible.; Otherwise set the density label according to the method name. Notes; -----; * A description of the FCHK format is http://wild.life.nctu.edu.tw/~jsyu/compchem/g09/g09ur/f_formchk.htm; * The allowed headers for methods are general and limited, i.e., ""Total SCF|MP2|CI|CC Density"",; PSI4 will try to find the right one for the current calculation. If `strict_label=False` the PSI4 method name will be used as label.; * Not all theory modules in PSI4 are compatible with the FCHK writer.; A warning will be printed if a theory module is not supported.; * Caution! For orbital-optimized correlated methods (e.g. DCT, OMP2) the 'Orbital Energy' field contains ambiguous data. :examples:. >>> # [1] FCHK file for DFT calculation; >>> E, wfn = energy('b3lyp', return_wfn=True); >>> fchk(wfn, 'mycalc.fchk'). >>> # [2] FCHK file for correlated densities; >>> E, wfn = gradient('ccsd', return_wfn=True); >>> fchk(wfn, 'mycalc.fchk'). >>> # [2] Write FCHK file with non-standard label.; >>> E, wfn = gradient('mp2.5', return_wfn=True); >>> fchk(wfn, 'mycalc.fchk', strict_label=False). """"""; # * Known limitations and notes *; #; # OCC: (occ theory module only, not dfocc) is turned off as densities are not correctly set.; # DFMP2: Contains natural orbitals in wfn.C() and wfn.epsilon() data. This is fixed to contain respective HF data. allowed = ['DFMP2', 'SCF', 'CCENERGY', 'DCT', 'DFOCC']; module_ = wfn.module().upper(); if module_ not in allowed:; core.print_out(f""FCHKWriter: Theory module {module_} is currently not supported by the FCHK writer.""); return None. if (wfn.basisset().has_ECP()):; core.print_out(f""FCHKWriter: Limited ECP suppor",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:94736,Energy,Energy,94736,psi4manual/1.4.0/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html,7,['Energy'],['Energy']
Energy Efficiency,"adeoff is rough here. isapt2; This is a shorter version if isapt1 - does not do cube plots. See isapt1 for full details. cbs-xtpl-func; optimization with method defined via cbs. extern2; External potential calculation involving a TIP3P water and a QM water for DFMP2. Finite different test of the gradient is performed to validate forces. x2c1; Test of SFX2C-1e on water uncontracted cc-pVDZ-DK The reference numbers are from Lan Cheng’s implementation in Cfour. fci-h2o-2; 6-31G H2O Test FCI Energy Point. cbs-xtpl-energy; Extrapolated water energies - density-fitted version. nbody-convergence; Convergence of many-body gradients of different BSSE schemes. cc2; 6-31G** H2O CCSD optimization by energies, with Z-Matrix input. tu3-h2o-opt; Optimize H2O HF/cc-pVDZ. tdscf-4; td-wb97x singlet excitation energies of methylene (tda). nbody-multi-level; Multilevel computation of water trimer energy (geometry from J. Chem. Theory Comput. 11, 2126-2136 (2015)). pywrap-all; Intercalls among python wrappers- database, cbs, optimize, energy, etc. Though each call below functions individually, running them all in sequence or mixing up the sequence is aspirational at present. Also aspirational is using the intended types of gradients. tdscf-6; td-camb3lyp with DiskDF and method/basis specification. dfccsd-grad2; DF-CCSD cc-pVDZ gradient for the NH molecule. cubeprop; RHF orbitals and density for water. dft-smoke; DFT Functional Smoke Test. nbody-freq; Vibrational and thermo analysis of water trimer (geometry from J. Chem. Theory Comput. 11, 2126-2136 (2015)). scf-ecp; Water-Argon complex with ECP present; check of energies and forces. mints8; Patch of a glycine with a methyl group, to make alanine, then DF-SCF energy calculation with the cc-pVDZ basis set. dft-grad2; DF-BP86-D2 cc-pVDZ frozen core gradient of S22 HCN updated ref gradient due to new BraggSlater radii. fci-h2o; 6-31G H2O Test FCI Energy Point. extern1; External potential calculation involving a TIP3P water and a QM water. ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/autodoc_testsuite_corepsi4.html:6045,energy,energy,6045,psi4manual/1.9.x/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/autodoc_testsuite_corepsi4.html,2,['energy'],['energy']
Energy Efficiency,"ader):; psi4.print_out(""""""\n ==> N-Body: %s energies <==\n\n"""""" % header); psi4.print_out("""""" n-Body Total Energy [Eh] I.E. [kcal/mol] Delta [kcal/mol]\n""""""); previous_e = energy_body_dict[1]; nbody_range = energy_body_dict.keys(); nbody_range.sort(); for n in nbody_range:; delta_e = (energy_body_dict[n] - previous_e); delta_e_kcal = delta_e * p4const.psi_hartree2kcalmol; int_e_kcal = (energy_body_dict[n] - energy_body_dict[1]) * p4const.psi_hartree2kcalmol; psi4.print_out("""""" %4s %20.12f %20.12f %20.12f\n"""""" %; (n, energy_body_dict[n], int_e_kcal, delta_e_kcal)); previous_e = energy_body_dict[n]; psi4.print_out(""\n""). [docs]def _nbody_gufunc(func, method_string, **kwargs):; """"""; Computes the nbody interaction energy, gradient, or Hessian depending on input.; This is a generalized univeral function for computing interaction quantities. :returns: *return type of func* |w--w| The interaction data. :returns: (*float*, :ref:`Wavefunction<sec:psimod_Wavefunction>`) |w--w| interaction data and wavefunction with energy/gradient/hessian set appropriately when **return_wfn** specified. :type func: function; :param func: ``energy`` || etc. Python function that accepts method_string and a molecule. Returns a; energy, gradient, or Hessian as requested. :type method_string: string; :param method_string: ``'scf'`` || ``'mp2'`` || ``'ci5'`` || etc. First argument, lowercase and usually unlabeled. Indicates the computational; method to be passed to func. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :type return_wfn: :ref:`boolean <op_py_boolean>`; :param return_wfn: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return the :ref:`Wavefunction<sec:psimod_Wavefunction>`; calculation result as the second element of a tuple. :type bsse_type: string or list; :param bsse_type: ``'cp'`` || ``['nocp', 'vmfc']`` || |dl| ``None`` |dr| || etc. Type of BSSE correction to compute: CP, NoCP, or ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/driver_nbody.html:3770,energy,energy,3770,psi4manual/1.0.0/_modules/driver_nbody.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver_nbody.html,1,['energy'],['energy']
Energy Efficiency,"adical, with Cartesian input. pywrap-molecule; Check that C++ Molecule class and qcdb molecule class are reading molecule input strings identically. opt1-fd; SCF STO-3G geometry optimzation, with Z-matrix input, by finite-differences. x2c2; Test of SFX2C-1e on Water cc-pVDZ-DK. In this test the Dirac equation is solved in the uncontracted cc-pVDZ-DK basis. The reference numbers are from Lan Cheng’s implementation in Cfour. cbs-xtpl-func; optimization with method defined via cbs. cubeprop; RHF orbitals and density for water. omp3-1; OMP3 cc-pVDZ energy for the H2O molecule. fd-gradient; SCF STO-3G finite-difference tests. mints5; Tests to determine full point group symmetry. Currently, these only matter for the rotational symmetry number in thermodynamic computations. sapt6; checks that all SAPT physical components (elst, exch, indc, disp) and total IE are being computed correctly for SAPT2+3(CCD)dMP2/aug-cc-pvdz and all lesser methods thereof. cc4a; RHF-CCSD(T) cc-pVQZ frozen-core energy of the BH molecule, with Cartesian input. This version tests the FROZEN_DOCC option explicitly. matrix1; An example of using BLAS and LAPACK calls directly from the Psi input file, demonstrating matrix multiplication, eigendecomposition, Cholesky decomposition and LU decomposition. These operations are performed on vectors and matrices provided from the Psi library. mp2-property; MP2 cc-pvDZ properties for Nitrogen oxide. pywrap-checkrun-rohf; This checks that all energy methods can run with a minimal input and set symmetry. dft-smoke; DFT Functional Smoke Test. omp2p5-2; OMP2 cc-pVDZ energy for the H2O molecule. dcft1; DC-06, DC-12, ODC-06 and ODC-12 calculation for the He dimer. This performs a simultaneous update of the orbitals and cumulant, using DIIS extrapolation. Four-virtual integrals are handled in the MO Basis. opt7; Various constrained energy minimizations of HOOH with cc-pvdz RHF. For “fixed” coordinates, the final value is provided by the user. sapt4; SAPT2+(3) aug-cc-p",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/autodoc_testsuite_corepsi4-1.html:32611,energy,energy,32611,psi4manual/1.2.1/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/autodoc_testsuite_corepsi4-1.html,4,['energy'],['energy']
Energy Efficiency,"adical, with Cartesian input. pywrap-molecule; Check that C++ Molecule class and qcdb molecule class are reading molecule input strings identically. opt1-fd; SCF STO-3G geometry optimzation, with Z-matrix input, by finite-differences. x2c2; Test of SFX2C-1e on Water cc-pVDZ-DK. In this test the Dirac equation is solved in the uncontracted cc-pVDZ-DK basis. The reference numbers are from Lan Cheng’s implementation in Cfour. cbs-xtpl-func; optimization with method defined via cbs. cubeprop; RHF orbitals and density for water. omp3-1; OMP3 cc-pVDZ energy for the H2O molecule. fd-gradient; SCF STO-3G finite-difference tests. mints5; Tests to determine full point group symmetry. Currently, these only matter for the rotational symmetry number in thermodynamic computations. sapt6; checks that all SAPT physical components (elst, exch, indc, disp) and total IE are being computed correctly for SAPT2+3(CCD)dMP2/aug-cc-pvdz and all lesser methods thereof. cc4a; RHF-CCSD(T) cc-pVQZ frozen-core energy of the BH molecule, with Cartesian input. This version tests the FROZEN_DOCC option explicitly. matrix1; An example of using BLAS and LAPACK calls directly from the Psi input file, demonstrating matrix multiplication, eigendecomposition, Cholesky decomposition and LU decomposition. These operations are performed on vectors and matrices provided from the Psi library. mp2-property; MP2 cc-pvDZ properties for Nitrogen oxide. pywrap-checkrun-rohf; This checks that all energy methods can run with a minimal input and set symmetry. omp2p5-2; OMP2 cc-pVDZ energy for the H2O molecule. dcft1; DC-06, DC-12, ODC-06 and ODC-12 calculation for the He dimer. This performs a simultaneous update of the orbitals and cumulant, using DIIS extrapolation. Four-virtual integrals are handled in the MO Basis. opt7; Various constrained energy minimizations of HOOH with cc-pvdz RHF. For “fixed” coordinates, the final value is provided by the user. sapt4; SAPT2+(3) aug-cc-pVDZ computation of the formamide dimer",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/testsuite-1.html:29661,energy,energy,29661,psi4manual/1.1.0/testsuite-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/testsuite-1.html,4,['energy'],['energy']
Energy Efficiency,"adical, with Cartesian input. pywrap-molecule; Check that C++ Molecule class and qcdb molecule class are reading molecule input strings identically. opt1-fd; SCF STO-3G geometry optimzation, with Z-matrix input, by finite-differences. x2c2; Test of SFX2C-1e on Water cc-pVDZ-DK. In this test the Dirac equation is solved in the uncontracted cc-pVDZ-DK basis. The reference numbers are from Lan Cheng’s implementation in Cfour. cbs-xtpl-func; optimization with method defined via cbs. cubeprop; RHF orbitals and density for water. omp3-1; OMP3 cc-pVDZ energy for the H2O molecule. fd-gradient; SCF STO-3G finite-difference tests. mints5; Tests to determine full point group symmetry. Currently, these only matter for the rotational symmetry number in thermodynamic computations. sapt6; checks that all SAPT physical components (elst, exch, indc, disp) and total IE are being computed correctly for SAPT2+3(CCD)dMP2/aug-cc-pvdz and all lesser methods thereof. cc4a; RHF-CCSD(T) cc-pVQZ frozen-core energy of the BH molecule, with Cartesian input. This version tests the FROZEN_DOCC option explicitly. nbo; Generation of NBO file. matrix1; An example of using BLAS and LAPACK calls directly from the Psi input file, demonstrating matrix multiplication, eigendecomposition, Cholesky decomposition and LU decomposition. These operations are performed on vectors and matrices provided from the Psi library. mp2-property; MP2 cc-pvDZ properties for Nitrogen oxide. pywrap-checkrun-rohf; This checks that all energy methods can run with a minimal input and set symmetry. dft-smoke; DFT Functional Smoke Test. omp2p5-2; OMP2 cc-pVDZ energy for the H2O molecule. dcft1; DC-06, DC-12, ODC-06 and ODC-12 calculation for the He dimer. This performs a simultaneous update of the orbitals and cumulant, using DIIS extrapolation. Four-virtual integrals are handled in the MO Basis. opt7; Various constrained energy minimizations of HOOH with cc-pvdz RHF. For “fixed” coordinates, the final value is provided by the us",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/autodoc_testsuite_corepsi4-1.html:34198,energy,energy,34198,psi4manual/1.3.2/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/autodoc_testsuite_corepsi4-1.html,4,['energy'],['energy']
Energy Efficiency,"adient calculation. run_dfmp2_property(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; a DFMP2 property calculation. run_dft(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; a density-functional-theory calculation. run_dft_gradient(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; a density-functional-theory gradient calculation. run_eom_cc(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; an EOM-CC calculation, namely EOM-CC2, EOM-CCSD, and EOM-CC3. run_eom_cc_gradient(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; an EOM-CCSD gradient calculation. run_fnocc(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; a QCISD(T), CCSD(T), MP2.5, MP3, and MP4 computation.; >>> energy('fno-ccsd(t)'). run_fnodfcc(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; a DF-CCSD(T) computation.; >>> energy('df-ccsd(t)'). run_libfock(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; a calculation through libfock, namely RCPHF,; RCIS, RTDHF, RTDA, and RTDDFT. run_mcscf(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; a multiconfigurational self-consistent-field calculation. run_mp2(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; a MP2 calculation. run_mp2_5(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; a MP2.5 calculation. run_mp2_5_gradient(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; a MP3 gradient calculation. run_mp2_gradient(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; a MP2 gradient calculation. run_mp2_select(name, **kwargs)[source]¶; Function selecting the algorithm for a MP2 energy call; and directing toward the OCC (conv MP2) or the DFMP2 modules. run_mp2_select_gradient(name, **kwargs)[source]¶; Fu",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/autodoc_driver-1.html:8339,energy,energy,8339,psi4manual/4.0b5/autodoc_driver-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodoc_driver-1.html,2,['energy'],['energy']
Energy Efficiency,"adient due to new BraggSlater radii. dft-custom-hybrid; DFT (hybrids) test of implementations in: hybrid_superfuncs.py. scf-ecp3; Water-Argon complex with ECP present; check of UHF Hessian. dft-smoke; DFT Functional Smoke Test. dfcasscf-sp; CASSCF/6-31G** energy point. nbody-he-cluster; MP2/aug-cc-pv[DT]Z many body energies of an arbitrary Helium complex Size vs cost tradeoff is rough here. dfomp3-1; DF-OMP3 cc-pVDZ energy for the H2O molecule. fsapt-allterms; This test case shows an example of running and analyzing a standard F-SAPT0/jun-cc-pvdz procedure for HSG-18-dimer from the HSG database. nbo; Generation of NBO file. tdscf-6; td-camb3lyp with DiskDF and method/basis specification. mpn-bh; MP(n)/aug-cc-pVDZ BH Energy Point, with n=2-19. Compare against M. L. Leininger et al., J. Chem. Phys. 112, 9213 (2000). stability1; UHF->UHF stability analysis test for BH with cc-pVDZ Test direct SCF with and without symmetry, test PK without symmetry. mcscf1; ROHF 6-31G** energy of the \(^{3}B_1\) state of CH2, with Z-matrix input. The occupations are specified explicitly. dfccsdl1; DF-CCSDL cc-pVDZ energy for the H2O molecule. scf2; RI-SCF cc-pVTZ energy of water, with Z-matrix input and cc-pVTZ-RI auxilliary basis. opt-irc-2; Compute the IRC for HCN <-> NCH interconversion at the RHF/DZP level of theory. dfccd1; DF-CCD cc-pVDZ energy for the H2O molecule. mints15; check SP basis Fortran exponent parsing. cc32; CC3/cc-pVDZ H2O \(R_e\) geom from Olsen et al., JCP 104, 8007 (1996). cc16; ROHF and UHF-B-CCD(T)/cc-pVDZ \(^{3}B_1\) CH2 single-point energy (fzc, MO-basis \(\langle ab|cd \rangle\) ). dfomp2-3; OMP2 cc-pVDZ energy for the H2O molecule. mp2p5-grad1; MP2.5 cc-pVDZ gradient for the H2O molecule. mints10; H2 with tiny basis set, to test basis set parser’s handling of integers. scf-occ; force occupations in scf. x2c-perturb-h; Test SFX2C-1e with a static electric field on He aug-cc-pVTZ. cisd-h2o+-1; 6-31G** H2O+ Test CISD Energy Point. dft-custom; DFT custom functio",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/autodoc_testsuite_corepsi4.html:24911,energy,energy,24911,psi4manual/1.6.x/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/autodoc_testsuite_corepsi4.html,2,['energy'],['energy']
Energy Efficiency,"adient in the presence of a dipole field. cc31; CCSD/sto-3g optical rotation calculation (both gauges) at two frequencies on methyloxirane. cc44; Test case for some of the PSI4 out-of-core codes. The code is given only 2.0 MB of memory, which is insufficient to hold either the A1 or B2 blocks of an ovvv quantity in-core, but is sufficient to hold at least two copies of an oovv quantity in-core. omp3-3; OMP3 cc-pCVDZ energy with B3LYP initial guess for the NO radical. sapt-ecp; sapt0 of charged system in ECP basis set. dct11; Restricted DF-DCT ODC-12 energies with linearly dependent basis functions. sapt3; SAPT2+3(CCD) aug-cc-pVDZ+midbond computation of the water dimer interaction energy, using the aug-cc-pVDZ-JKFIT DF basis for SCF and aug-cc-pVDZ-RI for SAPT. dft-grad-lr1; wB97X-D cc-pVDZ gradient of S22 HCN update df/pk_ref values due to new BraggSlater radii. opt-multi-frozen-dimer-c2h; Frozen-fragment opt of C2h methane dimer with user-combined reference points. casscf-sp; CASSCF/6-31G** energy point. mbis-3; MBIS calculation on OH radical. dfrasscf-sp; 6-31G** H2O Test RASSCF Energy Point will default to only singles and doubles in the active space. opt-multi-dimer-c1; Multi-fragment opt of C2h methane dimer with user-combined reference points. scf-hess1; RHF STO-3G (Cartesian) and cc-pVDZ (spherical) water Hessian test, against Psi3 reference values. ao-casscf-sp; CASSCF/6-31G** energy point. cisd-sp-2; 6-31G** H2O Test CISD Energy Point. omp2p5-1; OMP2.5 cc-pVDZ energy for the H2O molecule. fnocc6; Test method/basis with disk_df. cc43; RHF-CC2-LR/STO-3G optical rotation of (S)-methyloxirane. gauge = both, omega = (589 355 nm). nbody-vmfc-gradient; Computation of VMFC-corrected water trimer gradient (geometry from J. Chem. Theory Comput. 11, 2126-2136 (2015)). cc48; reproduces dipole moments in J.F. Stanton’s “biorthogonal” JCP paper. pywrap-opt-sowreap; Finite difference optimization, run in sow/reap mode. soscf-ref; Triple and Singlet Oxygen energy SOSCF, al",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/autodoc_testsuite_corepsi4.html:38403,energy,energy,38403,psi4manual/1.6.x/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/autodoc_testsuite_corepsi4.html,2,['energy'],['energy']
Energy Efficiency,"adient pass,; deciding analytic or finite difference. hessian(name, **kwargs)[source]¶; Function to compute force constants. Presently identical to frequency(). molden(filename)[source]¶. parse_arbitrary_order(name)[source]¶; Function to parse name string into a method family like CI or MRCC and specific; level information like 4 for CISDTQ or MRCCSDTQ. parse_cotton_irreps(irrep)[source]¶; Function to return validated Cotton ordering index from string or integer; irreducible representation irrep. physconst¶; # Do not modify this file! It is auto-generated by the document_options_and_tests; # script, from psi4topdir/include/physconst.h; psi_h = 6.62606896E-34 # The Planck constant (Js) ; psi_c = 2.99792458E8 # Speed of light (ms$^{-1}$) ; psi_kb = 1.3806504E-23 # The Boltzmann constant (JK$^{-1}$) ; psi_R = 8.314472 # Universal gas constant (JK$^{-1}$mol$^{-1}$) ; psi_bohr2angstroms = 0.52917720859 # Bohr to Angstroms conversion factor ; psi_bohr2m = 0.52917720859E-10 # Bohr to meters conversion factor ; psi_bohr2cm = 0.52917720859E-8 # Bohr to centimeters conversion factor ; psi_amu2g = 1.660538782E-24 # Atomic mass units to grams conversion factor ; psi_amu2kg = 1.660538782E-27 # Atomic mass units to kg conversion factor ; psi_au2amu = 5.485799097E-4 # Atomic units (m$@@e$) to atomic mass units conversion factor ; psi_hartree2J = 4.359744E-18 # Hartree to joule conversion factor ; psi_hartree2aJ = 4.359744 # Hartree to attojoule (10$^{-18}$J) conversion factor ; psi_cal2J = 4.184 # Calorie to joule conversion factor ; psi_dipmom_au2si = 8.47835281E-30 # Atomic units to SI units (Cm) conversion factor for dipoles ; psi_dipmom_au2debye = 2.54174623 # Atomic units to Debye conversion factor for dipoles ; psi_dipmom_debye2si = 3.335640952E-30 # Debye to SI units (Cm) conversion factor for dipoles ; psi_c_au = 137.035999679 # Speed of light in atomic units ; psi_hartree2ev = 27.21138 # Hartree to eV conversion factor ; psi_hartree2wavenumbers = 219474.6 # Hartree to cm$^",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/autodoc_driver-1.html:9998,meter,meters,9998,psi4manual/4.0b2/autodoc_driver-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/autodoc_driver-1.html,2,['meter'],['meters']
Energy Efficiency,"adient', name, 'CC_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_fnoccsd_t_(name, **kwargs):; """"""Function selecting the algorithm for a FNO-CCSD(T) energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); mtd_type = core.get_global_option('CC_TYPE'); module = core.get_global_option('QC_MODULE'); # Considering only fnocc. func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module in ['', 'FNOCC']:; func = run_fnocc; elif mtd_type == 'DF':; if module in ['', 'FNOCC']:; func = run_fnodfcc; elif mtd_type == 'CD':; if module in ['', 'FNOCC']:; func = run_fnodfcc. if func is None:; raise ManagedMethodError(['select_fnoccsd_t_', name, 'CC_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_ccsd_t_(name, **kwargs):; """"""Function selecting the algorithm for a CCSD(T) energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); mtd_type = core.get_global_option('CC_TYPE'); module = core.get_global_option('QC_MODULE'); # Considering only [df]occ/ccenergy/fnocc. func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module == 'FNOCC':; func = run_fnocc; elif module in ['', 'CCENERGY']:; func = run_ccenergy; elif mtd_type == 'DF':; if module == 'OCC':; func = run_dfocc; elif module in ['', 'FNOCC']:; func = run_fnodfcc; elif mtd_type == 'CD':; if module == 'OCC':; func = run_dfocc; elif module in ['', 'FNOCC']:; func = run_fnodfcc; elif reference in ['UHF', 'ROHF']:; if mtd_type == 'CONV':; if module in ['', 'CCENERGY']:; func = run_ccenergy. if func is None:; raise ManagedMethodError(['select_ccsd_t_', name, 'CC_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_ccsd_t__gradient(name, **kwargs):",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/procrouting/proc.html:21602,energy,energy,21602,psi4manual/1.3.2/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/procrouting/proc.html,9,['energy'],['energy']
Energy Efficiency,"adient']:; dertype = 1; if procedures['gradient'][method_name].__name__.startswith('select_'):; try:; procedures['gradient'][method_name](method_name, probe=True); except ManagedMethodError:; dertype = 0; elif method_name in procedures['energy']:; dertype = 0; else:; # Quick sanity check. Only *should* be able to be None or int, but hey, kids today...; if not isinstance(user_dertype, int):; raise ValidationError(""_find_derivative_type: user_dertype should only be None or int!""); dertype = user_dertype. if (core.get_global_option('INTEGRAL_PACKAGE') == 'ERD') and (dertype != 0):; raise ValidationError('INTEGRAL_PACKAGE ERD does not play nicely with derivatives, so stopping.'). if (core.get_global_option('PCM')) and (dertype != 0):; core.print_out('\nPCM analytic gradients are not implemented yet, re-routing to finite differences.\n'); dertype = 0. # Summary validation; if (dertype == 2) and (method_name in procedures['hessian']):; pass; elif (dertype == 1) and (method_name in procedures['gradient']):; pass; elif (dertype == 0) and (method_name in procedures['energy']):; pass; else:; alternatives = ''; alt_method_name = p4util.text.find_approximate_string_matches(method_name, procedures['energy'].keys(), 2); if len(alt_method_name) > 0:; alternatives = """""" Did you mean? %s"""""" % (' '.join(alt_method_name)). raise ValidationError(""""""Derivative method 'name' %s and derivative level 'dertype' %s are not available.%s""""""; % (method_name, str(dertype), alternatives)). return dertype. def _energy_is_invariant(gradient, stationary_criterion=1.e-2):; """"""Polls options and probes `gradient` to return whether current method; and system expected to be invariant to translations and rotations of; the coordinate system. """"""; stationary_point = gradient.rms() < stationary_criterion # 1.e-2 pulled out of a hat. efp = core.get_active_efp(); efp_present = efp.nfragments() > 0. translations_projection_sound = (not core.get_option('SCF', 'EXTERN') and; not core.get_option('SCF', 'PERTURB_H')",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/driver.html:3531,energy,energy,3531,psi4manual/1.2.1/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/driver.html,1,['energy'],['energy']
Energy Efficiency,"adient']:; dertype = 1; if procedures['gradient'][method_name].__name__.startswith('select_'):; try:; procedures['gradient'][method_name](method_name, probe=True); except ManagedMethodError:; dertype = 0; elif method_name in procedures['energy']:; dertype = 0; else:; # Quick sanity check. Only *should* be able to be None or int, but hey, kids today...; if not isinstance(user_dertype, int):; raise ValidationError(""_find_derivative_type: user_dertype should only be None or int!""); dertype = user_dertype. if (core.get_global_option('INTEGRAL_PACKAGE') == 'ERD') and (dertype != 0):; raise ValidationError('INTEGRAL_PACKAGE ERD does not play nicely with derivatives, so stopping.'). if (core.get_global_option('PCM')) and (dertype != 0):; core.print_out('\nPCM analytic gradients are not implemented yet, re-routing to finite differences.\n'); dertype = 0. # Summary validation; if (dertype == 2) and (method_name in procedures['hessian']):; pass; elif (dertype == 1) and (method_name in procedures['gradient']):; pass; elif (dertype == 0) and (method_name in procedures['energy']):; pass; else:; alternatives = ''; alt_method_name = p4util.text.find_approximate_string_matches(method_name, procedures['energy'].keys(), 2); if len(alt_method_name) > 0:; alternatives = """""" Did you mean? %s"""""" % (' '.join(alt_method_name)). raise ValidationError(""""""Derivative method 'name' %s and derivative level 'dertype' %s are not available.%s""""""; % (method_name, str(dertype), alternatives)). return dertype. def _energy_is_invariant(gradient, stationary_criterion=1.e-2):; """"""Polls options and probes `gradient` to return whether current method; and system expected to be invariant to translations and rotations of; the coordinate system. """"""; stationary_point = gradient.rms() < stationary_criterion # 1.e-2 pulled out of a hat. mol = core.get_active_molecule(); efp_present = hasattr(mol, 'EFP'). translations_projection_sound = (not core.get_option('SCF', 'EXTERN') and not core.get_option('SCF', 'PERTURB_",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver.html:3491,energy,energy,3491,psi4manual/1.3.2/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver.html,1,['energy'],['energy']
Energy Efficiency,"adient(molecule)[source]¶; Compute dispersion gradient based on engine, dispersion level, and parameters in self. Parameters:molecule (psi4.core.Molecule) – System for which to compute empirical dispersion correction. Returns:(nat, 3) dispersion gradient [Eh/a0]. Return type:psi4.core.Matrix. compute_hessian(molecule)[source]¶; Compute dispersion Hessian based on engine, dispersion level, and parameters in self.; Uses finite difference, as no dispersion engine has analytic second derivatives. Parameters:molecule (psi4.core.Molecule) – System for which to compute empirical dispersion correction. Returns:(3*nat, 3*nat) dispersion Hessian [Eh/a0/a0]. Return type:psi4.core.Matrix. print_out()[source]¶; Format dispersion parameters of self for output file. compute_energy(molecule)[source]; Compute dispersion energy based on engine, dispersion level, and parameters in self. Parameters:molecule (psi4.core.Molecule) – System for which to compute empirical dispersion correction. Returns:Dispersion energy [Eh]. Return type:float. Notes. DISPERSION CORRECTION ENERGY; Disp always set. Overridden in SCF finalization, but that only changes for “-3C” methods.; self.fctldash + DISPERSION CORRECTION ENERGY; Set if fctldash nonempty. compute_gradient(molecule)[source]; Compute dispersion gradient based on engine, dispersion level, and parameters in self. Parameters:molecule (psi4.core.Molecule) – System for which to compute empirical dispersion correction. Returns:(nat, 3) dispersion gradient [Eh/a0]. Return type:psi4.core.Matrix. compute_hessian(molecule)[source]; Compute dispersion Hessian based on engine, dispersion level, and parameters in self.; Uses finite difference, as no dispersion engine has analytic second derivatives. Parameters:molecule (psi4.core.Molecule) – System for which to compute empirical dispersion correction. Returns:(3*nat, 3*nat) dispersion Hessian [Eh/a0/a0]. Return type:psi4.core.Matrix. print_out()[source]; Format dispersion parameters of self for output f",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/api/psi4.driver.empiricaldispersion.html:5038,energy,energy,5038,psi4manual/1.3.2/api/psi4.driver.empiricaldispersion.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/api/psi4.driver.empiricaldispersion.html,1,['energy'],['energy']
Energy Efficiency,"adient(name, **kwargs):; r""""""Function complementary to optimize(). Carries out one gradient pass,; deciding analytic or finite difference. """"""; lowername = name.lower(); kwargs = kwargs_lower(kwargs); dertype = 1. # Order of precedence:; # 1. Default for wavefunction; # 2. Value obtained from kwargs, if user changed it; # 3. If user provides a custom 'func' use that. # Allow specification of methods to arbitrary order; lowername, level = parse_arbitrary_order(lowername); if level:; kwargs['level'] = level. # 1. set the default to that of the provided name; if lowername in procedures['gradient']:; dertype = 1; elif lowername in procedures['energy']:; dertype = 0; func = energy. if (PsiMod.get_global_option('REFERENCE').lower() == 'rks') or (PsiMod.get_global_option('REFERENCE').lower() == 'uks'):; dertype = 0; func = energy. # 2. Check if the user passes dertype into this function; if 'dertype' in kwargs:; opt_dertype = kwargs['dertype']. if input.der0th.match(str(opt_dertype)):; dertype = 0; func = energy; elif input.der1st.match(str(opt_dertype)):; dertype = 1; else:; raise ValidationError('Requested derivative level \'dertype\' %s not valid for helper function optimize.' % (opt_dertype)). # 3. if the user provides a custom function THAT takes precendence; if ('opt_func' in kwargs) or ('func' in kwargs):; if ('func' in kwargs):; kwargs['opt_func'] = kwargs['func']; del kwargs['func']; dertype = 0; func = kwargs['opt_func']. # Summary validation; if (dertype == 1) and (lowername in procedures['gradient']):; pass; elif (dertype == 0) and (func is energy) and (lowername in procedures['energy']):; pass; elif (dertype == 0) and not(func is energy):; pass; else:; raise ValidationError('Requested method \'name\' %s and derivative level \'dertype\' %s are not available.'; % (lowername, dertype)). # Make sure the molecule the user provided is the active one; if ('molecule' in kwargs):; activate(kwargs['molecule']); del kwargs['molecule']; molecule = PsiMod.get_active_molecul",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/_modules/driver.html:21377,energy,energy,21377,psi4manual/4.0b2/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/driver.html,2,['energy'],['energy']
Energy Efficiency,"adient/Hessian) of the system,; otherwise returns interaction data. Default is 'off' for energies,; 'on' for gradients and Hessians. Note that the calculation of total; counterpoise corrected energies implies the calculation of the energies of; monomers in the monomer basis, hence specifying return_total_data = True; may carry out more computations than return_total_data = False.; For gradients and Hessians, return_total_data = False is rarely useful. levels (dict) – {1: 'ccsd(t)', 2: 'mp2', 'supersystem': 'scf'} || {1: 2, 2: 'ccsd(t)', 3: 'mp2'} || etc; Dictionary of different levels of theory for different levels of expansion; Note that method_string is not used in this case. supersystem computes; all higher order n-body effects up to the number of fragments. embedding_charges (dict) – {1: [-0.834, 0.417, 0.417], ..}; Dictionary of atom-centered point charges. keys: 1-based index of fragment, values: list of charges for each fragment.; Add atom-centered point charges for fragments whose basis sets are not included in the computation. The nbody function computes counterpoise-corrected (CP), non-CP (noCP), and Valiron-Mayer Function Counterpoise (VMFC) interaction energies for complexes composed of arbitrary numbers of monomers.; Examples :; # Counterpoise corrected CCSD(T) energies for the Helium dimer; molecule mol {; He; --; He 1 3; }; # Calculate interaction energies only (skips monomers in monomer basis):; energy('CCSD(T)', bsse_type='cp'); # Calculate interaction and total energies, return interaction energies:; energy('CCSD(T)', bsse_type=['cp','nocp']); # Calculate and return counterpoise-corrected gradient; # Useful for e.g. CP-corrected geometry optimization; gradient('CCSD(T)', bsse_type='cp', return_total_data=True). # noCP, VMFC, and CP energy for a helium cluster, limited at 3 bodies; molecule mol {; He 0 0 0; --; He 0 0 4; --; He 0 4 0; --; He 4 0 0; }. # Returns the nocp energy as its first in the list; energy('CCSD(T)', bsse_type=['nocp', 'cp', 'vmfc",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/nbody.html:2676,charge,charges,2676,psi4manual/1.6.x/nbody.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/nbody.html,4,['charge'],['charges']
Energy Efficiency,"adient/Hessian) of the system,; otherwise returns interaction data. Default is 'off' for energies,; 'on' for gradients and Hessians. Note that the calculation of total; counterpoise corrected energies implies the calculation of the energies of; monomers in the monomer basis, hence specifying return_total_data = True; may carry out more computations than return_total_data = False.; For gradients and Hessians, return_total_data = False is rarely useful. levels (dict) – {1: 'ccsd(t)', 2: 'mp2', 'supersystem': 'scf'} || {1: 2, 2: 'ccsd(t)', 3: 'mp2'} || etc; Dictionary of different levels of theory for different levels of expansion; Note that method_string is not used in this case. supersystem computes; all higher order n-body effects up to the number of fragments. embedding_charges (dict) – {1: [-0.834, 0.417, 0.417], ..}; Dictionary of atom-centered point charges. keys: 1-based index of fragment, values: list of charges for each fragment.; Add atom-centered point charges for fragments whose basis sets are not included in the computation. The nbody function computes counterpoise-corrected (CP), non-CP (noCP), and Valiron-Mayer Function Counterpoise (VMFC) interaction energies for complexes composed of arbitrary numbers of monomers.; Examples :; set {; basis def2-svp; }. # Counterpoise corrected CCSD(T) energies for the Helium dimer; molecule mol {; He; --; He 1 3; }; # Calculate interaction energies only (skips monomers in monomer basis):; energy('CCSD(T)', bsse_type='cp'); # Calculate interaction and total energies, return interaction energies:; energy('CCSD(T)', bsse_type=['cp','nocp']); # Calculate and return counterpoise-corrected gradient; # Useful for e.g. CP-corrected geometry optimization; gradient('CCSD(T)', bsse_type='cp', return_total_data=True). # noCP, VMFC, and CP energy for a helium cluster, limited at 3 bodies; molecule mol {; He 0 0 0; --; He 0 0 4; --; He 0 4 0; --; He 4 0 0; }. # Returns the nocp energy as its first in the list; energy('CCSD(T)', bsse",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/nbody.html:2688,charge,charges,2688,psi4manual/master/nbody.html,https://psicode.org,https://psicode.org/psi4manual/master/nbody.html,1,['charge'],['charges']
Energy Efficiency,"adients. cc45; RHF-EOM-CC2/cc-pVDZ lowest two states of each symmetry of H2O. dcft1; DC-06, DC-12, ODC-06 and ODC-12 calculation for the He dimer. This performs a simultaneous update of the orbitals and cumulant, using DIIS extrapolation. Four-virtual integrals are handled in the MO Basis. opt5; 6-31G** UHF CH2 3B1 optimization. Uses a Z-Matrix with dummy atoms, just for demo and testing purposes. tu1-h2o-energy; Sample HF/cc-pVDZ H2O computation. pywrap-checkrun-uhf; This checks that all energy methods can run with a minimal input and set symmetry. opt4; SCF cc-pVTZ geometry optimzation, with Z-matrix input. dfomp2p5-2; DF-OMP2.5 cc-pVDZ energy for the H2O+ cation. dfmp2-3; DF-MP2 cc-pVDZ frozen core gradient of benzene, computed at the DF-SCF cc-pVDZ geometry. dfcasscf-sp; CASSCF/6-31G** energy point. cc35; CC3(ROHF)/cc-pVDZ H2O geom from Olsen et al., JCP 104, 8007 (1996). psithon1; Spectroscopic constants of H2, and the full ci cc-pVTZ level of theory. cc5a; RHF CCSD(T) STO-3G frozen-core energy of C4NH4 Anion. rasci-ne; Ne atom RASCI/cc-pVQZ Example of split-virtual CISD[TQ] from Sherrill and Schaefer, J. Phys. Chem. XXX This uses a “primary” virtual space 3s3p (RAS 2), a “secondary” virtual space 3d4s4p4d4f (RAS 3), and a “tertiary” virtual space consisting of the remaining virtuals. First, an initial CISD computation is run to get the natural orbitals; this allows a meaningful partitioning of the virtual orbitals into groups of different importance. Next, the RASCI is run. The split-virtual CISD[TQ] takes all singles and doubles, and all triples and quadruples with no more than 2 electrons in the secondary virtual subspace (RAS 3). If any electrons are present in the tertiary virtual subspace (RAS 4), then that excitation is only allowed if it is a single or double. fnocc1; Test QCISD(T) for H2O/cc-pvdz Energy. cc28; CCSD/cc-pVDZ optical rotation calculation (length gauge only) on Z-mat H2O2. opt1; SCF STO-3G geometry optimzation, with Z-matrix input. cc10; R",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_testsuite_corepsi4-1.html:17875,energy,energy,17875,psi4manual/1.0.0/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_testsuite_corepsi4-1.html,4,['energy'],['energy']
Energy Efficiency,"adients.; molecule; The target molecule, if not the last molecule defined.; kwargs; Any additional arguments to pass to :func:`psi4.driver.energy` or; :func:`psi4.driver.gradient` computation. """""". # Method used when the SCF command is received; self.scf_method = scf_method. # Additional arguments for energy, gradient, or optimization calculations; self.kwargs = kwargs. # Molecule all MDI operations are performed on; input_molecule = kwargs.pop('molecule', psi4.core.get_active_molecule()); _ini_cart = getattr(input_molecule, ""_initial_cartesian"", None); self.molecule = input_molecule.clone(); if _ini_cart:; self.molecule._initial_cartesian = _ini_cart; psi4.core.set_active_molecule(self.molecule). # Most recent SCF energy; self.energy = 0.0. # Variables used when MDI sets a lattice of point charges; self.nlattice = 0 # number of lattice point charges; self.clattice = [] # list of lattice coordinates; self.lattice = [] # list of lattice charges; self.lattice_field = psi4.QMMMbohr() # Psi4 chargefield. # MPI variables; self.mpi_world = None; self.world_rank = 0. # Flag for if a lattice of point charges has been set; self.set_lattice = False. # Get correct intra-code MPI communicator; if use_mpi4py:; self.mpi_world = MDI_MPI_get_world_comm(); self.world_rank = self.mpi_world.Get_rank(). # Psi4 does not currently support multiple MPI ranks; if self.mpi_world.Get_size() != 1:; MPI.COMM_WORLD.Abort(). # Accept a communicator to the driver code; self.comm = MDI_Accept_Communicator(). # Ensure that the molecule is using c1 symmetry; self.molecule.reset_point_group('c1'); self.molecule.fix_orientation(True); self.molecule.fix_com(True); self.molecule.reinterpret_coordentry(False); self.molecule.update_geometry(). # Flag to stop listening for MDI commands; self.stop_listening = False. # Dictionary of all supported MDI commands; self.commands = {; ""<NATOMS"": self.send_natoms,; ""<COORDS"": self.send_coords,; ""<CHARGES"": self.send_charges,; ""<ELEMENTS"": self.send_elements,; ""<MAS",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/mdi_engine.html:2952,charge,chargefield,2952,psi4manual/1.8.x/_modules/psi4/driver/mdi_engine.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/mdi_engine.html,6,['charge'],['chargefield']
Energy Efficiency,"ads to parallelize across. success(label)[source]¶; Function to print a ‘label...PASSED’ line to screen.; Used by util.compare_values() family when functions pass. basislistdunning¶; Module (auto-generated from make_dunning.pl script); with commands building BasisFamily objects that; encode the Dunning basis set orbital definitions in; psi4/lib/basis/NOTES and fitting bases designed for those; orbital bases. load_basfam_dunning()[source]¶. aliases¶; Module with functions that call upon those in modules; proc, driver, and wrappers. Place in this file quickly defined procedures such as. aliases for complex methods; simple modifications to existing methods. sherrillgroup_gold_standard(name='mp2', **kwargs)[source]¶; Function to call the quantum chemical method known as ‘Gold Standard’; in the Sherrill group. Uses complete_basis_set() to evaluate; the following expression. Two-point extrapolation of the correlation energy; performed according to corl_xtpl_helgaker_2(). >>> energy('sherrillgroup_gold_standard'). qcdb¶; Module to facilitate quantum chemical computations on chemical; databases. Contains Molecule class and physical constants from psi4 suite.; Module to largely replicate in python the psi4 libmints; CoordValue and CoordEntry classes, which were developed by; Justin M. Turney, with incremental improvements by other; psi4 developers. class CartesianEntry(entry_number, Z, charge, mass, symbol, label, x, y, z)[source]¶; Class to hold all information about an atom, including its; coordinate specification as three Cartesians. clone()[source]¶; Returns new, independent CartesianEntry object. compute()[source]¶; Computes the values of the coordinates (in whichever units; were inputted), returning them in a Vector. everything()[source]¶. invalidate()[source]¶; Flags the current coordinates as being outdated. print_in_input_format()[source]¶; Prints the updated geometry, in the format provided by the user. set_coordinates(x, y, z)[source]¶; Given the current set of coo",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/autodoc_driver-1.html:36883,energy,energy,36883,psi4manual/4.0b4/autodoc_driver-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/autodoc_driver-1.html,2,['energy'],['energy']
Energy Efficiency,"ag = []. # handle atom markers; else:; entries = re.split(r'\s+|\s*,\s*', line.strip()); atomm = atom.match(line.split()[0].strip().upper()); atomLabel = atomm.group('label'); atomSym = atomm.group('symbol'). # We don't know whether the @C or Gh(C) notation matched. Do a quick check.; ghostAtom = False if (atomm.group('gh1') is None and atomm.group('gh2') is None) else True. # Check that the atom symbol is valid; if not atomSym in el2z:; raise ValidationError('Molecule::create_molecule_from_string: Illegal atom symbol in geometry specification: %s' % (atomSym)). zVal = el2z[atomSym]; atomMass = el2mass[atomSym] if atomm.group('mass') is None else float(atomm.group('mass')); charge = float(zVal); if ghostAtom:; zVal = 0; charge = 0.0. # handle cartesians; if len(entries) == 4:; tempfrag.append(iatom); xval = self.get_coord_value(entries[1]); yval = self.get_coord_value(entries[2]); zval = self.get_coord_value(entries[3]); self.full_atoms.append(CartesianEntry(iatom, zVal, charge, \; atomMass, atomSym, atomLabel, \; xval, yval, zval)). # handle first line of Zmat; elif len(entries) == 1:; zmatrix = True; tempfrag.append(iatom); self.full_atoms.append(ZMatrixEntry(iatom, zVal, charge, \; atomMass, atomSym, atomLabel)). # handle second line of Zmat; elif len(entries) == 3:; zmatrix = True; tempfrag.append(iatom). rTo = self.get_anchor_atom(entries[1], line); if rTo >= iatom:; raise ValidationError(""Molecule::create_molecule_from_string: Error on geometry input line %s. Atom %s has not been defined yet.\n"" % (line, entries[1])); rval = self.get_coord_value(entries[2]). if self.full_atoms[rTo].symbol() == 'X':; rval.set_fixed(True). self.full_atoms.append(ZMatrixEntry(iatom, zVal, charge, \; atomMass, atomSym, atomLabel, \; self.full_atoms[rTo], rval)). # handle third line of Zmat; elif len(entries) == 5:; zmatrix = True; tempfrag.append(iatom). rTo = self.get_anchor_atom(entries[1], line); if rTo >= iatom:; raise ValidationError(""Molecule::create_molecule_from_string: Er",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html:18927,charge,charge,18927,psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html,1,['charge'],['charge']
Energy Efficiency,"against the initial wavels implementation. mints2; A test of the basis specification. A benzene atom is defined using a ZMatrix containing dummy atoms and various basis sets are assigned to different atoms. The symmetry of the molecule is automatically lowered to account for the different basis sets. dfomp2-1; OMP2 cc-pVDZ energy for the H2O molecule. scf-hess3; CONV SCF 6-31G analytical vs finite-difference tests Tests UHF hessian code for Ca != Cb. scf-response2; Compute the dipole polarizability for water with custom basis set. cdomp2-1; OMP2 cc-pVDZ energy for the H2O molecule. dft-psivar; HF and DFT variants single-points on zmat methane, mostly to test that PSI variables are set and computed correctly. Now also testing that CSX harvesting PSI variables correctly update ref_dft_2e/xc due to new BraggSlater radii. cisd-sp; 6-31G** H2O Test CISD Energy Point. pywrap-checkrun-rhf; This checks that all energy methods can run with a minimal input and set symmetry. casscf-fzc-sp; CASSCF/6-31G** energy point. sapt-sf1; Tests the Psi4 SF-SAPT code. sad-scf-type; Test SAD SCF guesses on noble gas atom. x2c3; Test of SFX2C-1e on Water uncontracted cc-pVDZ The reference numbers are from Lan Cheng’s implementation in Cfour. cc13d; Tests analytic CC2 gradients. cc45; RHF-EOM-CC2/cc-pVDZ lowest two states of each symmetry of H2O. dct7; DCT calculation for the triplet O2 using ODC-06 and ODC-12 functionals. Only simultaneous algorithm is tested. cubeprop-esp; RHF orbitals and density for water. mp3-grad1; MP3 cc-pVDZ gradient for the H2O molecule. nbody-nocp-gradient; Computation of NoCP-corrected water trimer gradient (geometry from J. Chem. Theory Comput. 11, 2126-2136 (2015)). cc53; Matches Table II a-CCSD(T)/cc-pVDZ H2O @ 2.5 * Re value from Crawford and Stanton, IJQC 98, 601-611 (1998). dct5; DC-06 calculation for the O2 molecule (triplet ground state). This performs geometry optimization using two-step and simultaneous solution of the response equations for the analytic",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/autodoc_testsuite_corepsi4.html:20221,energy,energy,20221,psi4manual/1.7.x/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/autodoc_testsuite_corepsi4.html,2,['energy'],['energy']
Energy Efficiency,"age of MP2 and MP3. The latter is; available through the arbitrary order MPn code and returns all lower energies; along with it in PSI variables. The following is basic code that will compute; and return the MP2.5 energy.; def run_mp2_5(name, **kwargs):. energy('mp3', **kwargs); e_scf = psi4.get_variable('SCF TOTAL ENERGY'); ce_mp2 = psi4.get_variable('MP2 CORRELATION ENERGY'); ce_mp3 = psi4.get_variable('MP3 CORRELATION ENERGY'). ce_mp25 = 0.5 * (ce_mp2 + ce_mp3); e_mp25 = e_scf + ce_mp25. print """""" MP2.5 total energy: %16.8f\n"""""" % (e_mp25); print """""" MP2.5 correlation energy: %16.8f\n"""""" % (ce_mp25). return e_mp25. Compare the above to the method that resides in psi4/lib/python/aliases.py.; The rationale for the changes is indicated in the comments below.; def run_mp2_5(name, **kwargs):; lowername = name.lower() # handy variable with name keyword in lowercase; kwargs = kwargs_lower(kwargs) # removes case sensitivity in keyword names. # Run detci calculation and collect conventional quantities; energy('mp3', **kwargs); e_scf = psi4.get_variable('SCF TOTAL ENERGY'); ce_mp2 = psi4.get_variable('MP2 CORRELATION ENERGY'); ce_mp3 = psi4.get_variable('MP3 CORRELATION ENERGY'); e_mp2 = e_scf + ce_mp2 # reform mp2 and mp3 total energies for printing; e_mp3 = e_scf + ce_mp3. # Compute quantities particular to MP2.5; ce_mp25 = 0.5 * (ce_mp2 + ce_mp3); e_mp25 = e_scf + ce_mp25; psi4.set_variable('MP2.5 CORRELATION ENERGY', ce_mp25) # add new method's important results; psi4.set_variable('MP2.5 TOTAL ENERGY', e_mp25) # to PSI variable repository; psi4.set_variable('CURRENT CORRELATION ENERGY', ce_mp25); psi4.set_variable('CURRENT ENERGY', e_mp25) # geometry optimizer tracks this variable, permits; # MP2.5 finite difference optimizations; # build string of title banner and print results; banners = ''; banners += """"""psi4.print_out('\\n')\n""""""; banners += """"""banner(' MP2.5 ')\n""""""; banners += """"""psi4.print_out('\\n')\n\n""""""; exec banners. tables = ''; tables += """""" SCF total ene",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/quickaddalias-1.html:1736,energy,energy,1736,psi4manual/4.0b5/quickaddalias-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/quickaddalias-1.html,2,['energy'],['energy']
Energy Efficiency,"age', 'Method', '/', 'Basis', '', 'Energy [Eh]',; 'Scheme'); tables += table_delimit; tables += """""" %6s %20s %1s %-27s %2s %16.8f %-s\n"""""" % (; GRAND_NEED[0]['d_stage'], GRAND_NEED[0]['d_wfn'], '/', GRAND_NEED[0]['d_basis'], '', GRAND_NEED[0]['d_energy'],; GRAND_NEED[0]['d_scheme'].__name__); if len(metadata) > 1:; tables += """""" %6s %20s %1s %-27s %2s %16.8f %-s\n"""""" % (; GRAND_NEED[1]['d_stage'], GRAND_NEED[1]['d_wfn'], '/', GRAND_NEED[1]['d_basis'], '',; GRAND_NEED[1]['d_energy'] - GRAND_NEED[2]['d_energy'], GRAND_NEED[1]['d_scheme'].__name__); if len(metadata) > 2:; dc = 3; for delta in metadata[2:]:; deltaE_total = GRAND_NEED[dc]['d_energy'] - GRAND_NEED[dc + 1]['d_energy']; tables += """""" %6s %20s %1s %-27s %2s %16.8f %-s\n"""""" % (; GRAND_NEED[dc]['d_stage'], GRAND_NEED[dc]['d_wfn'] + ' - ' + GRAND_NEED[dc + 1]['d_wfn'], '/',; GRAND_NEED[dc]['d_basis'], '', deltaE_total,; GRAND_NEED[dc]['d_scheme'].__name__); core.set_variable(f""CBS {GRAND_NEED[dc]['d_stage'].upper()} TOTAL ENERGY"", deltaE_total); dc += 2. tables += """""" %6s %20s %1s %-27s %2s %16.8f %-s\n"""""" % ('total', 'CBS', '', '', '', finalenergy, ''); tables += table_delimit. core.print_out(tables). core.set_variable('CBS REFERENCE ENERGY', GRAND_NEED[0]['d_energy']); core.set_variable('CBS CORRELATION ENERGY', finalenergy - GRAND_NEED[0]['d_energy']); core.set_variable('CBS TOTAL ENERGY', finalenergy); core.set_variable('CURRENT REFERENCE ENERGY', GRAND_NEED[0]['d_energy']); core.set_variable('CURRENT CORRELATION ENERGY', finalenergy - GRAND_NEED[0]['d_energy']); core.set_variable('CURRENT ENERGY', finalenergy); core.set_variable('CBS NUMBER', Njobs). # new skeleton wavefunction w/mol, highest-SCF basis (just to choose one), & not energy; basis = core.BasisSet.build(molecule, ""ORBITAL"", 'def2-svp'); wfn = core.Wavefunction(molecule, basis). optstash.restore(). if ptype == 'energy':; finalquantity = finalenergy; elif ptype == 'gradient':; finalquantity = finalgradient; wfn.set_gradient(finalquantity); if fina",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html:59280,ENERGY,ENERGY,59280,psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html,2,['ENERGY'],['ENERGY']
Energy Efficiency,"age; dbdat = []; ssarray = ['pospos', 'posneg', 'pospolar', 'posaliph', 'posaryl',; None, 'negneg', 'negpolar', 'negaliph', 'negaryl',; None, None, 'polarpolar', 'polaraliph', 'polararyl',; None, None, None, 'aliphaliph', 'alipharyl',; None, None, None, None, 'arylaryl']; for ss in ssarray:; dbdat.append(0.0 if ss is None else errors[ss][self.dbse]['mae']). # generate matplotlib instructions and call or print; try:; from . import mpl; import matplotlib.pyplot as plt; except ImportError:; print('Matplotlib not avail'); else:; filedict = mpl.liliowa(dbdat, xlimit=xlimit, view=view,; saveas=saveas, relpath=relpath, graphicsformat=graphicsformat); return filedict. [docs] def plot_iowa(self, modelchem, benchmark='default', sset='default',; failoninc=True, verbose=False,; title='', xtitle='', xlimit=2.0,; view=True,; saveas=None, relpath=False, graphicsformat=['pdf']):; """"""Computes individual errors for single *modelchem* versus; *benchmark* over subset *sset*. Coloring green-to-purple with; maximum intensity at *xlimit*. Prepares Iowa plot instructions and; either executes them if matplotlib available (Canopy) or prints them. """"""; title = self.dbse + ' ' + modelchem; # compute errors; mc = modelchem; errors, indiv = self.compute_statistics(mc, benchmark=benchmark, sset=sset,; failoninc=failoninc, verbose=verbose, returnindiv=True); # repackage; dbdat = []; dblbl = []; for db in self.dbdict.keys():; if indiv[db] is not None:; for rxn in indiv[db].keys():; dbdat.append(indiv[db][rxn][0]); dblbl.append(str(rxn)); title = """"""%s vs %s for %s subset %s"""""" % (mc, benchmark, self.dbse, sset); me = errors[self.dbse]['me']; # generate matplotlib instructions and call or print; try:; from . import mpl; import matplotlib.pyplot as plt; except ImportError:; # if not running from Canopy, print line to execute from Canopy; print(""""""mpl.iowa(%s,\n %s,\n title='%s',\n xtitle='%s'\n xlimit=%s,\n saveas=%s,\n relpath=%s\n graphicsformat=%s)\n\n"""""" %; (dbdat, dblbl, title, xtitle, xlimit, r",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:82439,green,green-to-purple,82439,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html,1,['green'],['green-to-purple']
Energy Efficiency,"aged CASSCF for the C2 molecule. cc9; UHF-CCSD(T) cc-pVDZ frozen-core energy for the state of the CN radical, with Z-matrix input. adc1; ADC/6-31G** on H2O. cc37; CC2(UHF)/cc-pVDZ energy of H2O+. omp2p5-grad1; OMP2.5 cc-pVDZ gradient for the H2O molecule. rasscf-sp; 6-31G** H2O Test RASSCF Energy Point will default to only singles and doubles in the active space. psithon2; Accesses basis sets, databases, plugins, and executables in non-install locations. x2c1; Test of SFX2C-1e on water uncontracted cc-pVDZ-DK The reference numbers are from Lan Cheng’s implementation in Cfour. dft2; DFT Functional Test. scf4; RHF cc-pVDZ energy for water, automatically scanning the symmetric stretch and bending coordinates using Python’s built-in loop mechanisms. The geometry is specified using a Z-matrix with variables that are updated during the potential energy surface scan, and then the same procedure is performed using polar coordinates, converted to Cartesian coordinates. dfomp2-1; OMP2 cc-pVDZ energy for the H2O molecule. cisd-sp; 6-31G** H2O Test CISD Energy Point. dft-psivar; HF and DFT variants single-points on zmat methane, mostly to test that PSI variables are set and computed correctly. Now also testing that CSX harvesting PSI variables correctly. sad1; Test of the superposition of atomic densities (SAD) guess, using a highly distorted water geometry with a cc-pVDZ basis set. This is just a test of the code and the user need only specify guess=sad to the SCF module’s (or global) options in order to use a SAD guess. The test is first performed in C2v symmetry, and then in C1. mp3-grad1; MP3 cc-pVDZ gradient for the H2O molecule. mp2-def2; Test case for Binding Energy of C4H5N (Pyrrole) with CO2 using MP2/def2-TZVPP. scf3; File retention, docc, socc, and bond distances specified explicitly. dfscf-bz2; Benzene Dimer DF-HF/cc-pVDZ. dfomp3-grad2; DF-OMP3 cc-pVDZ gradients for the H2O+ cation. sapt6; checks that all SAPT physical components (elst, exch, indc, disp) and total I",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_testsuite_corepsi4-1.html:30711,energy,energy,30711,psi4manual/1.0.0/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_testsuite_corepsi4-1.html,4,['energy'],['energy']
Energy Efficiency,"agedMethodError(['select_omp2p5', name, 'MP_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_omp2p5_gradient(name, **kwargs):; """"""Function selecting the algorithm for an OMP2.5 gradient call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); mtd_type = core.get_global_option('MP_TYPE'); module = core.get_global_option('QC_MODULE'); # Considering only [df]occ. func = None; if reference in ['RHF', 'UHF', 'ROHF', 'RKS', 'UKS']:; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ_gradient; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc_gradient. if func is None:; raise ManagedMethodError(['select_omp2p5_gradient', name, 'MP_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_lccd(name, **kwargs):; """"""Function selecting the algorithm for a LCCD energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); mtd_type = core.get_global_option('CC_TYPE'); module = core.get_global_option('QC_MODULE'); # Considering only [df]occ/fnocc. func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module == 'OCC':; func = run_occ; elif module in ['', 'FNOCC']:; func = run_cepa; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc; elif reference == 'UHF':; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc. if func is None:; raise ManagedMethodError(['select_lccd', name, 'CC_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_lccd_gradient(name, **kwargs):;",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/procrouting/proc.html:14611,energy,energy,14611,psi4manual/1.3.2/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/procrouting/proc.html,9,['energy'],['energy']
Energy Efficiency,"agents (GEOS), their combination into reactions (RXNM &; ACTV), available reference values for reactions (BIND), and brief comments; for reagents and reactions (TAGL). The journey from reagent geometries to; functional database.py file is largely automated, in a process described; below. Prepare geometry files; Assemble xyz files for all intended reagent systems in a directory.; Follow the rules below for best results. The filename for each xyz; file should be the name of the system. lowercase or MixedCase is; preferable (according to Sherrill lab convention). Avoid dashes and; dots in the name as python won’t allow them. If you’re determined to; have dashes and dots, they must be replaced by other characters in the; process_input line, then translated back in the GEOS section; see; NBC10.py for an example. The first line for each xyz file should be the number of atoms in the system.; The second line for each xyz file can be blank (interpreted as no comment), anything (interpreted as a comment), or two integers and anything (interpreted as charge, multiplicity, and remainder as comment).; The third and subsequent lines have four fields: the element symbol and the three cartesian coordinates in angstroms. The atom lines should not contain any dummy atoms (what’s the use in cartesian form). For dimer systems, an algorithm is used to apportion the atoms into two fragments; thus the atoms need not be arranged with all fragmentA atoms before all fragmentB atoms. The algorithm will fail for very closely arranged fragments. For dimers, any charge and multiplicity from the second line will be applied to fragmentA (python); charge and multiplicity may need to be redistributed later in the editing step. Run script psi4/lib/scripts/ixyz2database.pl. Move into the directory where all your xyz files are located. Run the; script in place, probably as; $PSIDATADIR/scripts/ixyz2database.pl. It will ask a number of; questions about your intended database and generate a python file; ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/quickadddatabase-1.html:2448,charge,charge,2448,psi4manual/4.0b2/quickadddatabase-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/quickadddatabase-1.html,2,['charge'],['charge']
Energy Efficiency,"agents (GEOS), their combination into reactions (RXNM &; ACTV), available reference values for reactions (BIND), and brief comments; for reagents and reactions (TAGL). The journey from reagent geometries to; functional database.py file is largely automated, in a process described; below. Prepare geometry files; Assemble xyz files for all intended reagent systems in a directory.; Follow the rules below for best results. The filename for each xyz; file should be the name of the system. lowercase or MixedCase is; preferable (according to Sherrill lab convention). Avoid dashes and; dots in the name as python won’t allow them. If you’re determined to; have dashes and dots, they must be replaced by other characters in the; process_input line, then translated back in the GEOS section; see; NBC10.py for an example. The first line for each xyz file should be the number of atoms in the system.; The second line for each xyz file can be blank (interpreted as no comment), anything (interpreted as a comment), or two integers and anything (interpreted as charge, multiplicity, and remainder as comment).; The third and subsequent lines have four fields: the element symbol and the three cartesian coordinates in angstroms. The atom lines should not contain any dummy atoms (what’s the use in cartesian form). For dimer systems, an algorithm is used to apportion the atoms into two fragments; thus the atoms need not be arranged with all fragmentA atoms before all fragmentB atoms. The algorithm will fail for very closely arranged fragments. For dimers, any charge and multiplicity from the second line will be applied to fragmentA (python); charge and multiplicity may need to be redistributed later in the editing step. Run script psi4/lib/scripts/ixyz2database.py. Move into the directory where all your xyz files are located. Run the; script, probably as $PSIDATADIR/scripts/ixyz2database.py. (If you; run it in place, there won’t be any path problems. It will ask a number of; questions about y",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/quickadddatabase-1.html:2463,charge,charge,2463,psi4manual/4.0b3/quickadddatabase-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/quickadddatabase-1.html,6,['charge'],['charge']
Energy Efficiency,"agents (GEOS), their combination into reactions (RXNM &; ACTV), available reference values for reactions (BIND), and brief comments; for reagents and reactions (TAGL). The journey from reagent geometries to; functional database.py file is largely automated, in a process described; below. Prepare geometry files; Assemble xyz files for all intended reagent systems in a directory.; Follow the rules below for best results. The filename for each xyz; file should be the name of the system. lowercase or MixedCase is; preferable (according to Sherrill lab convention). Avoid dashes and; dots in the name as python won’t allow them. If you’re determined to; have dashes and dots, they must be replaced by other characters in the; process_input line, then translated back in the GEOS section; see; NBC10.py for an example. The first line for each xyz file should be the number of atoms in the system.; The second line for each xyz file can be blank (interpreted as no comment), anything (interpreted as a comment), or two integers and anything (interpreted as charge, multiplicity, and remainder as comment).; The third and subsequent lines have four fields: the element symbol and the three cartesian coordinates in angstroms. The atom lines should not contain any dummy atoms (what’s the use in cartesian form). For dimer systems, an algorithm is used to apportion the atoms into two fragments; thus the atoms need not be arranged with all fragmentA atoms before all fragmentB atoms. The algorithm will fail for very closely arranged fragments. For dimers, any charge and multiplicity from the second line will be applied to fragmentA (python); charge and multiplicity may need to be redistributed later in the editing step. Run script psi4/share/scripts/ixyz2database.py. Move into the directory where all your xyz files are located. Run the; script, probably as $PSIDATADIR/scripts/ixyz2database.py. (If you; run it in place, there won’t be any path problems. It will ask a number of; questions about",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/quickadddatabase-1.html:2418,charge,charge,2418,psi4manual/1.1.0/quickadddatabase-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/quickadddatabase-1.html,8,['charge'],['charge']
Energy Efficiency,"agments is fixed so orientation info from `self` is; not lost. Loses chgmult and ghost/dummy info from `self` and contains; default chgmult.; Only provided if `return_molecules` is True.; Returned are of same type as `self`.; bfs_molecule : qcdb.Molecule or psi4.core.Molecule, optional; Single molecule with same number of real atoms as `self` with atoms; reordered into adjacent fragments and fragment markers inserted.; Loses ghost/dummy info from `self`; keeps total charge but not total mult.; Only provided if `return_molecule` is True.; Returned is of same type as `self`. Notes; -----; Relies upon van der Waals radii and so faulty for close (especially; hydrogen-bonded) fragments. See `seed_atoms`.; Any existing fragmentation info/chgmult encoded in `self` is lost. Authors; -------; Original code from Michael S. Marshall, linear-scaling algorithm from; Trent M. Parker, revamped by Lori A. Burns. """"""; self.update_geometry(); if self.natom() != self.nallatom():; raise ValidationError(""""""BFS not adapted for dummy atoms""""""). cgeom, cmass, celem, celez, cuniq = self.to_arrays(); frag_pattern = BFS(cgeom, celez, seed_atoms=seed_atoms, bond_threshold=bond_threshold); outputs = [frag_pattern]. if return_arrays:; fgeoms = [cgeom[fr] for fr in frag_pattern]; fmasss = [cmass[fr] for fr in frag_pattern]; felems = [celem[fr] for fr in frag_pattern]; outputs.append((fgeoms, fmasss, felems)). if return_molecules:; molrecs = [; qcel.molparse.from_arrays(; geom=cgeom[fr],; mass=cmass[fr],; elem=celem[fr],; elez=celez[fr],; units='Bohr',; fix_com=True,; fix_orientation=True) for fr in frag_pattern; ]; if isinstance(self, Molecule):; ret_mols = [Molecule.from_dict(molrec) for molrec in molrecs]; else:; from psi4 import core; ret_mols = [core.Molecule.from_dict(molrec) for molrec in molrecs]; outputs.append(ret_mols). if return_molecule:; dcontig = qcel.molparse.contiguize_from_fragment_pattern(; frag_pattern, geom=cgeom, elez=celez, elem=celem, mass=cmass); molrec = qcel.molparse.fro",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/qcdb/molecule.html:52258,adapt,adapted,52258,psi4manual/1.3.2/_modules/psi4/driver/qcdb/molecule.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/qcdb/molecule.html,1,['adapt'],['adapted']
Energy Efficiency,"agments is fixed so orientation info from `self` is; not lost. Loses chgmult and ghost/dummy info from `self` and contains; default chgmult.; Only provided if `return_molecules` is True.; Returned are of same type as `self`.; bfs_molecule : qcdb.Molecule or psi4.core.Molecule, optional; Single molecule with same number of real atoms as `self` with atoms; reordered into adjacent fragments and fragment markers inserted.; Loses ghost/dummy info from `self`; keeps total charge but not total mult.; Only provided if `return_molecule` is True.; Returned is of same type as `self`. Notes; -----; Relies upon van der Waals radii and so faulty for close (especially; hydrogen-bonded) fragments. See `seed_atoms`.; Any existing fragmentation info/chgmult encoded in `self` is lost. Authors; -------; Original code from Michael S. Marshall, linear-scaling algorithm from; Trent M. Parker, revamped by Lori A. Burns. """"""; self.update_geometry(); if self.natom() != self.nallatom():; raise ValidationError(""""""BFS not adapted for dummy atoms""""""). cgeom, cmass, celem, celez, cuniq = self.to_arrays(); frag_pattern = BFS(cgeom, celez, seed_atoms=seed_atoms, bond_threshold=bond_threshold); outputs = [frag_pattern]. if return_arrays:; fgeoms = [cgeom[fr] for fr in frag_pattern]; fmasss = [cmass[fr] for fr in frag_pattern]; felems = [celem[fr] for fr in frag_pattern]; outputs.append((fgeoms, fmasss, felems)). if return_molecules:; molrecs = [molparse.from_arrays(geom=cgeom[fr],; mass=cmass[fr],; elem=celem[fr],; elez=celez[fr],; units='Bohr',; fix_com=True,; fix_orientation=True) for fr in frag_pattern]; if isinstance(self, Molecule):; ret_mols = [Molecule.from_dict(molrec) for molrec in molrecs]; else:; from psi4 import core; ret_mols = [core.Molecule.from_dict(molrec) for molrec in molrecs]; outputs.append(ret_mols). if return_molecule:; dcontig = Molecule.contiguize_from_fragment_pattern(frag_pattern,; geom=cgeom,; elez=celez,; elem=celem,; mass=cmass); molrec = molparse.from_arrays(geom=dcont",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/qcdb/molecule.html:55399,adapt,adapted,55399,psi4manual/1.2.1/_modules/psi4/driver/qcdb/molecule.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/qcdb/molecule.html,1,['adapt'],['adapted']
Energy Efficiency,"agments(self, arg0); Sets the specified list arg2 of fragments to be Real. set_basis_all_atoms(self, arg0, arg1); Sets basis set arg2 to all atoms. set_basis_by_label(self, arg0, arg1, arg2); Sets basis set arg3 to all atoms with label (e.g., H4) arg2. set_basis_by_symbol(self, arg0, arg1, arg2); Sets basis set arg3 to all atoms with symbol (e.g., H) arg2. set_geometry(self, arg0); Sets the geometry, given a (Natom X 3) matrix arg2 of coordinates (in Bohr). set_ghost_fragment(self, arg0); Sets the specified fragment arg2 to be Ghost. set_ghost_fragments(self, arg0); Sets the specified list arg2 of fragments to be Ghost. set_input_units_to_au(self, arg0); Sets unit conversion to [a0] for geometry. set_mass(self, atom, mass); Sets mass of atom (0-indexed) to mass. set_molecular_charge(self, arg0); Sets the molecular charge. set_multiplicity(self, arg0); Sets the multiplicity (defined as 2Ms + 1). set_name(self, arg0); Sets molecule name. set_nuclear_charge(self, arg0, arg1); Set the nuclear charge of the given atom to the value provided. set_point_group(self, arg0); Sets the molecular point group to the point group object arg2. set_units(self, arg0); Sets units (Angstrom or Bohr) used to define the geometry. set_variable(self, arg0, arg1); Assigns the value arg3 to the variable arg2 in the list of geometry variables, then calls update_geometry(). symbol(self, arg0); Gets the cleaned up label of atom arg2 (C2 => C, H4 = H). symmetrize(self, arg0); Finds the highest point Abelian point group within the specified tolerance, and forces the geometry to have that symmetry. symmetry_from_input(self); Returns the symmetry specified in the input. to_arrays(); Exports coordinate info into NumPy arrays. to_dict([force_c1, force_units, np_out]); Serializes instance into Molecule dictionary. to_schema(dtype[, units, return_type]); Serializes instance into JSON or YAML according to schema dtype. to_string(dtype[, units, atom_format, …]); Format a string representation of QM molecul",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/api/psi4.core.molecule.html:7829,charge,charge,7829,psi4manual/1.2.1/api/psi4.core.molecule.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/api/psi4.core.molecule.html,1,['charge'],['charge']
Energy Efficiency,"ail or crash (nans) without screening!. fd-freq-gradient; SCF STO-3G finite-differences frequencies from gradients for H2O. castup2; SCF with various combinations of pk/density-fitting, castup/no-castup, and spherical/cartesian settings. Demonstrates that puream setting is getting set by orbital basis for all df/castup parts of calc. Demonstrates that answer doesn’t depend on presence/absence of castup. Demonstrates (by comparison to castup3) that output file doesn’t depend on options (scf_type) being set global or local. This input uses global. freq-masses; check nonphysical masses possible. stability2; ROHF stability analysis check for CN with cc-pVDZ. This test corresponds to the rohf-stab test from Psi3. dft1; DFT Functional Test all values update for new BraggSlater radii. cepa2; cc-pvdz H2O Test ACPF Energy/Properties. scf-level-shift-rks; SCF level shift on an RKS computation. scf-guess; Test initial SCF guesses on FH and FH+ in cc-pVTZ basis. opt8; Various constrained energy minimizations of HOOH with cc-pvdz RHF. Cartesian-coordinate constrained optimizations of HOOH in Cartesians. ci-property; CI/MCSCF cc-pvDZ properties for Potassium nitrate (rocket fuel!). dfccsd-grad1; DF-CCSD cc-pVDZ gradients for the H2O molecule. cc31; CCSD/sto-3g optical rotation calculation (both gauges) at two frequencies on methyloxirane. mints3; Test individual integral objects for correctness. dft-smoke; DFT Functional Smoke Test. dfmp2-grad4; DF-MP2 cc-pVDZ gradient for the NO molecule. soscf-ref; Triple and Singlet Oxygen energy SOSCF, also tests non-symmetric density matrices. dfomp2-grad2; OMP2 cc-pVDZ energy for the NO molecule. linK-1; RHF Linear Exchange Algorithm test for water. mbis-3; MBIS calculation on OH radical. sapt6; checks that all SAPT physical components (elst, exch, indc, disp) and total IE are being computed correctly for SAPT2+3(CCD)dMP2/aug-cc-pvdz and all lesser methods thereof. dft-grad-lr1; wB97X-D cc-pVDZ gradient of S22 HCN update df/pk_ref values due",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/autodoc_testsuite_corepsi4.html:31157,energy,energy,31157,psi4manual/1.7.x/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/autodoc_testsuite_corepsi4.html,2,['energy'],['energy']
Energy Efficiency,"ailable at a given level of SAPT computed; from a subset of the terms of that grouping. The groupings shown above are; not unique and are certainly not rigorously defined. We regard the groupings; used in PSI4 as a “chemist’s grouping” as opposed to a more; mathematically based grouping, which would group all exchange terms; (i.e. \(E_{exch-ind,resp}^{(20)}\), \(E_{exch-disp}^{(20)}\), etc.) in; the exchange component. A final note is that both Disp22(T); and Est.Disp22(T) results appear if MP2 natural orbitals are; used to evaluate the triples correction to dispersion. The Disp22(T); result is the triples correction as computed in the truncated NO basis;; Est.Disp22(T) is a scaled result that attempts to recover; the effect of the truncated virtual space and is our best estimate. The Est.Disp22(T); value is used in the SAPT energy and dispersion component (see [Hohenstein:2010:104107]; for details). Finally, this part of the output file contains sSAPT0, a special scaling; scheme of the SAPT0 energy that can yield improved results and was described in more details; above. The corresponding scaled total component energies are printed as well.; As mentioned above, SAPT results with scaled exchange are also optionally available; by setting the EXCH_SCALE_ALPHA keyword. When activated, the unscaled results are; printed first as reported above, and then repeated with exchange scaling for all; relevant terms:; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19; 20; 21; 22; 23; 24; 25; 26; 27; 28; 29; 30; 31; 32; 33; 34; 35; 36; 37; 38; 39; 40; 41; 42; 43; 44; 45 SAPT Results ==> ALL S2 TERMS SCALED (see Manual) <==. Scaling factor (Exch10/Exch10(S^2))^{Alpha} = 1.007200; with Alpha = 1.000000; --------------------------------------------------------------------------------------------------------; Electrostatics -13.06509118 [mEh] -8.19846883 [kcal/mol] -34.30239689 [kJ/mol]; Elst10,r -13.37542977 [mEh] -8.39320925 [kcal/mol] -35.11719087 [kJ/mol]; Elst12,r ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/sapt-1.html:32460,energy,energy,32460,psi4manual/1.1.0/sapt-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/sapt-1.html,6,['energy'],['energy']
Energy Efficiency,"ailable at a given level of SAPT computed; from a subset of the terms of that grouping. The groupings shown above are; not unique and are certainly not rigorously defined. We regard the groupings; used in PSI4 as a “chemist’s grouping” as opposed to a more; mathematically based grouping, which would group all exchange terms; (i.e. \(E_{exch-ind,resp}^{(20)}\), \(E_{exch-disp}^{(20)}\), etc.) in; the exchange component. A final note is that both Disp22(T); and Est.Disp22(T) results appear if MP2 natural orbitals are; used to evaluate the triples correction to dispersion. The Disp22(T); result is the triples correction as computed in the truncated NO basis;; Est.Disp22(T) is a scaled result that attempts to recover; the effect of the truncated virtual space and is our best estimate. The Est.Disp22(T); value is used in the SAPT energy and dispersion component (see [Hohenstein:2010:104107]; for details). Finally, this part of the output file contains sSAPT0, a special scaling; scheme of the SAPT0 energy that can yield improved results and was described in more details; above. The corresponding scaled total component energies are printed as well.; As mentioned above, SAPT results with scaled exchange are also optionally available; by setting the EXCH_SCALE_ALPHA keyword. When activated, the unscaled results are; printed first as reported above, and then repeated with exchange scaling for all; relevant terms:; SAPT Results ==> ALL S2 TERMS SCALED (see Manual) <==. Scaling factor (Exch10/Exch10(S^2))^{Alpha} = 1.007200; with Alpha = 1.000000; --------------------------------------------------------------------------------------------------------; Electrostatics -13.06509118 [mEh] -8.19846883 [kcal/mol] -34.30239689 [kJ/mol]; Elst10,r -13.37542977 [mEh] -8.39320925 [kcal/mol] -35.11719087 [kJ/mol]; Elst12,r 0.04490350 [mEh] 0.02817737 [kcal/mol] 0.11789413 [kJ/mol]; Elst13,r 0.26543510 [mEh] 0.16656305 [kcal/mol] 0.69689985 [kJ/mol]. Exchange sc. 13.43351854 [mEh] 8.42966050",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/sapt-1.html:38667,energy,energy,38667,psi4manual/1.4.0/sapt-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/sapt-1.html,9,['energy'],['energy']
Energy Efficiency,"ailable schemes. Parameters:; scf_scheme (function) – \(\Rightarrow\) xtpl_highest_1 \(\Leftarrow\) || scf_xtpl_helgaker_3 || etc.; Indicates the basis set extrapolation scheme to be applied to the reference energy.; Defaults to scf_xtpl_helgaker_3() if three valid basis sets; present in scf_basis, scf_xtpl_helgaker_2() if two valid basis; sets present in scf_basis, and xtpl_highest_1() otherwise. xtpl_highest_1; scf_xtpl_helgaker_3; scf_xtpl_helgaker_2; scf_xtpl_truhlar_2; scf_xtpl_karton_2. corl_scheme (function) – \(\Rightarrow\) xtpl_highest_1 \(\Leftarrow\) || corl_xtpl_helgaker_2 || etc.; Indicates the basis set extrapolation scheme to be applied to the correlation energy.; Defaults to corl_xtpl_helgaker_2() if two valid basis sets; present in corl_basis and xtpl_highest_1() otherwise. xtpl_highest_1; corl_xtpl_helgaker_2. delta_scheme (function) – \(\Rightarrow\) xtpl_highest_1 \(\Leftarrow\) || corl_xtpl_helgaker_2 || etc.; Indicates the basis set extrapolation scheme to be applied to the delta correction; to the correlation energy.; Defaults to corl_xtpl_helgaker_2() if two valid basis sets; present in delta_basis and xtpl_highest_1() otherwise. xtpl_highest_1; corl_xtpl_helgaker_2. delta2_scheme (function) – \(\Rightarrow\) xtpl_highest_1 \(\Leftarrow\) || corl_xtpl_helgaker_2 || etc.; Indicates the basis set extrapolation scheme to be applied to the second delta correction; to the correlation energy.; Defaults to corl_xtpl_helgaker_2() if two valid basis sets; present in delta2_basis and xtpl_highest_1() otherwise. xtpl_highest_1; corl_xtpl_helgaker_2. Combined interface. Others. Parameters:molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. Examples:. >>> # [1] replicates with cbs() the simple model chemistry scf/cc-pVDZ: set basis cc-pVDZ energy('scf'); >>> energy(cbs, scf_wfn='scf', scf_basis='cc-pVDZ'). >>> # [2] replicates with cbs() the simple model chemistry mp2/jun-cc-pVDZ: set basis jun-cc-pVDZ energy('mp2');",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/api/psi4.driver.cbs-1.html:8826,energy,energy,8826,psi4manual/1.3.2/api/psi4.driver.cbs-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/api/psi4.driver.cbs-1.html,4,['energy'],['energy']
Energy Efficiency,"ailable schemes. Parameters:; scf_scheme (function) – \(\Rightarrow\) xtpl_highest_1 \(\Leftarrow\) || scf_xtpl_helgaker_3 || etc.; Indicates the basis set extrapolation scheme to be applied to the reference energy.; Defaults to scf_xtpl_helgaker_3() if three valid basis sets; present in scf_basis, scf_xtpl_helgaker_2() if two valid basis; sets present in scf_basis, and xtpl_highest_1() otherwise. xtpl_highest_1; scf_xtpl_helgaker_3; scf_xtpl_helgaker_2; scf_xtpl_truhlar_2; scf_xtpl_karton_2. corl_scheme (function) – \(\Rightarrow\) xtpl_highest_1 \(\Leftarrow\) || corl_xtpl_helgaker_2 || etc.; Indicates the basis set extrapolation scheme to be applied to the correlation energy.; Defaults to corl_xtpl_helgaker_2() if two valid basis sets; present in corl_basis and xtpl_highest_1() otherwise. xtpl_highest_1; corl_xtpl_helgaker_2. delta_scheme (function) – \(\Rightarrow\) xtpl_highest_1 \(\Leftarrow\) || corl_xtpl_helgaker_2 || etc.; Indicates the basis set extrapolation scheme to be applied to the delta correction; to the correlation energy.; Defaults to corl_xtpl_helgaker_2() if two valid basis sets; present in delta_basis and xtpl_highest_1() otherwise. xtpl_highest_1; corl_xtpl_helgaker_2. delta2_scheme (function) – \(\Rightarrow\) xtpl_highest_1 \(\Leftarrow\) || corl_xtpl_helgaker_2 || etc.; Indicates the basis set extrapolation scheme to be applied to the second delta correction; to the correlation energy.; Defaults to corl_xtpl_helgaker_2() if two valid basis sets; present in delta2_basis and xtpl_highest_1() otherwise. xtpl_highest_1; corl_xtpl_helgaker_2. delta3_scheme (function) – \(\Rightarrow\) xtpl_highest_1 \(\Leftarrow\) || corl_xtpl_helgaker_2 || etc.; Indicates the basis set extrapolation scheme to be applied to the third delta correction; to the correlation energy.; Defaults to corl_xtpl_helgaker_2() if two valid basis sets; present in delta3_basis and xtpl_highest_1() otherwise. delta4_scheme (function) – \(\Rightarrow\) xtpl_highest_1 \(\Leftarrow",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/cbs-1.html:8873,energy,energy,8873,psi4manual/1.2.1/cbs-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/cbs-1.html,4,['energy'],['energy']
Energy Efficiency,"ails of discretisation,; numerical integration and iterative solvers,; see the next sections for details. Note; At present dd-based solvation models; can only be used for energy calculations with SCF; wavefunctions. All ERI algorithms (PK, OUT_OF_CORE, DIRECT, DF,; CD) are supported. Warning; Currently the ddx interface cannot exploit molecular point group symmetry. Warning; Analytic gradients and Hessians are currently not available; with dd-based solvation models. A minimal input for a Hartree–Fock calculation with dd-based PCM would look like; the following:; import psi4; nh3 = psi4.geometry(""""""; N -0.0000000001 -0.1040380466 0.0000000000; H -0.9015844116 0.4818470201 -1.5615900098; H -0.9015844116 0.4818470201 1.5615900098; H 1.8031688251 0.4818470204 0.0000000000; symmetry c1; no_reorient; no_com; units bohr; """"""). psi4.set_options({; ""basis"": ""sto-3g"",; ""scf_type"": ""pk"",; ""ddx"": True,; ""ddx_model"": ""pcm"",; ""ddx_solvent"": ""water"",; ""ddx_radii_set"": ""uff"",; }). scf_e = psi4.energy('SCF'). Solvent model and solvent cavity definition¶; Beyond setting DDX to true and selecting; a solvent model using DDX_MODEL,; the definition of the solvent is mandatory.; Regularly one might want to influence the setup of the solvent; cavity as well.; The solvent can be defined either by directly providing a dielectric; constant using DDX_SOLVENT_EPSILON or by looking up the dielectric; constant in from a solvent trivial name provided by DDX_SOLVENT; (e.g. water, ethanol, cis-1,2-dimethylcyclohexane).; By convention solvent names are all lowercase and use dashes (-) to separate; quantifiers like o, n etc.; The full list understood by ddx can be obtained using; import pyddx; print(pyddx.data.solvent_epsilon.keys()). For when an LPB solvent model is selected (DDX_MODEL is LPB); additionally the Debye-Hückel parameter DDX_SOLVENT_KAPPA needs to be provided; (in units of inverse Bohr or inverse Angström, depending on the unit used to define; the molecular geometry). pyddx provides a ha",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/ddx.html:3243,energy,energy,3243,psi4manual/1.8.x/ddx.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/ddx.html,1,['energy'],['energy']
Energy Efficiency,"ails of discretisation,; numerical integration and iterative solvers,; see the next sections for details. Note; At present dd-based solvation models; can only be used for energy calculations with SCF; wavefunctions. All ERI algorithms (PK, OUT_OF_CORE, DIRECT, DF,; CD) are supported. Warning; Currently the ddx interface cannot exploit molecular point group symmetry. Warning; Analytic gradients and Hessians are currently not available; with dd-based solvation models. A minimal input for a Hartree–Fock calculation with dd-based PCM would look like; the following:; import psi4; nh3 = psi4.geometry(""""""; N -0.0000000001 -0.1040380466 0.0000000000; H -0.9015844116 0.4818470201 -1.5615900098; H -0.9015844116 0.4818470201 1.5615900098; H 1.8031688251 0.4818470204 0.0000000000; symmetry c1; no_reorient; no_com; units bohr; """"""). psi4.set_options({; ""basis"": ""sto-3g"",; ""scf_type"": ""pk"",; ""ddx"": True,; ""ddx_model"": ""pcm"",; ""ddx_solvent"": ""water"",; ""ddx_radii_set"": ""uff"",; }). scf_e = psi4.energy('SCF'). Solvent model and solvent cavity definition¶; Beyond setting DDX to true and selecting; a solvent model using DDX_MODEL,; the definition of the solvent is mandatory.; Regularly one might want to influence the setup of the solvent; cavity as well.; The solvent can be defined either by directly providing a dielectric; constant using DDX_SOLVENT_EPSILON or by looking up the dielectric; constant in from a solvent trivial name provided by DDX_SOLVENT; (e.g. water, ethanol, cis-1,2-dimethylcyclohexane).; By convention solvent names are all lowercase and use dashes (-) to separate; quantifiers like o, n etc.; The full list understood by ddx can be obtained using; import pyddx; print(pyddx.data.solvent_epsilon.keys()). The cavity in ddx is defined as a union of spheres around each atom.; Usually the spehere radii for each atom are determined using a standard; set of tabulated radii per atomic species, determined by the DDX_RADII_SET parameter.; Currently bondi [Bondi:1964:441] and uff ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/ddx.html:3163,energy,energy,3163,psi4manual/1.7.x/ddx.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/ddx.html,1,['energy'],['energy']
Energy Efficiency,"aindx = [i for i in range(len(basisarray[0])) if basisarray[0][i] != basisarray[1][i]][0]; ZSET = [bas[zetaindx] for bas in basisarray]; pre = basisarray[1][:zetaindx]; post = basisarray[1][zetaindx + 1:]. return """".join([pre, ""["", *ZSET, ""]"", post]). def return_energy_components():; """"""Define some quantum chemical knowledge, namely what methods are subsumed in others."""""". # yapf: disable; VARH = {}; VARH['scf'] = {; 'scf': 'SCF TOTAL ENERGY'}; VARH['hf'] = {; 'hf': 'HF TOTAL ENERGY'}; VARH['mp2'] = {; 'hf': 'HF TOTAL ENERGY',; 'mp2': 'MP2 TOTAL ENERGY'}; VARH['dlpno-mp2'] = {; 'hf': 'HF TOTAL ENERGY',; 'dlpno-mp2': 'MP2 TOTAL ENERGY'}; VARH['mp2d'] = {; 'hf': 'HF TOTAL ENERGY',; 'mp2d': 'MP2D TOTAL ENERGY'}; VARH['mp2.5'] = {; 'hf': 'HF TOTAL ENERGY',; 'mp2': 'MP2 TOTAL ENERGY',; 'mp2.5': 'MP2.5 TOTAL ENERGY',; 'mp3': 'MP3 TOTAL ENERGY'}; VARH['mp3'] = {; 'hf': 'HF TOTAL ENERGY',; 'mp2': 'MP2 TOTAL ENERGY',; 'mp2.5': 'MP2.5 TOTAL ENERGY',; 'mp3': 'MP3 TOTAL ENERGY'}; VARH['mp4(sdq)'] = {; 'hf': 'HF TOTAL ENERGY',; 'mp2': 'MP2 TOTAL ENERGY',; 'mp2.5': 'MP2.5 TOTAL ENERGY',; 'mp3': 'MP3 TOTAL ENERGY',; 'mp4(sdq)': 'MP4(SDQ) TOTAL ENERGY'}; VARH['mp4'] = {; 'hf': 'HF TOTAL ENERGY',; 'mp2': 'MP2 TOTAL ENERGY',; 'mp2.5': 'MP2.5 TOTAL ENERGY',; 'mp3': 'MP3 TOTAL ENERGY',; 'mp4(sdq)': 'MP4(SDQ) TOTAL ENERGY',; 'mp4': 'MP4 TOTAL ENERGY'}; VARH['omp2'] = {; 'hf': 'HF TOTAL ENERGY',; 'mp2': 'MP2 TOTAL ENERGY',; 'omp2': 'OMP2 TOTAL ENERGY'}; VARH['omp2.5'] = {; 'hf': 'HF TOTAL ENERGY',; 'mp2': 'MP2 TOTAL ENERGY',; 'mp2.5': 'MP2.5 TOTAL ENERGY',; 'omp2.5': 'OMP2.5 TOTAL ENERGY'}; VARH['omp3'] = {; 'hf': 'HF TOTAL ENERGY',; 'mp2': 'MP2 TOTAL ENERGY',; 'mp3': 'MP3 TOTAL ENERGY',; 'omp3': 'OMP3 TOTAL ENERGY'}; VARH['olccd'] = {; 'hf': 'HF TOTAL ENERGY',; 'mp2': 'MP2 TOTAL ENERGY',; 'olccd': 'OLCCD TOTAL ENERGY'}; VARH['lccd'] = {; 'hf': 'HF TOTAL ENERGY',; 'mp2': 'MP2 TOTAL ENERGY',; 'lccd': 'LCCD TOTAL ENERGY'}; VARH['lccsd'] = {; 'hf': 'HF TOTAL ENERGY',; 'mp2': 'MP2 TOTAL ENERG",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver_cbs.html:11651,ENERGY,ENERGY,11651,psi4manual/1.6.x/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver_cbs.html,4,['ENERGY'],['ENERGY']
Energy Efficiency,"aindx = [i for i in range(len(basisarray[0])) if basisarray[0][i] != basisarray[1][i]][0]; ZSET = [bas[zetaindx] for bas in basisarray]; pre = basisarray[1][:zetaindx]; post = basisarray[1][zetaindx + 1:]. return """".join([pre, ""["", *ZSET, ""]"", post]). def return_energy_components():; """"""Define some quantum chemical knowledge, namely what methods are subsumed in others."""""". # yapf: disable; VARH = {}; VARH['scf'] = {; 'scf': 'SCF TOTAL ENERGY'}; VARH['hf'] = {; 'hf': 'HF TOTAL ENERGY'}; VARH['mp2'] = {; 'hf': 'HF TOTAL ENERGY',; 'mp2': 'MP2 TOTAL ENERGY'}; VARH['dlpno-mp2'] = {; 'hf': 'HF TOTAL ENERGY',; 'dlpno-mp2': 'MP2 TOTAL ENERGY'}; VARH['mp2d'] = {; 'hf': 'HF TOTAL ENERGY',; 'mp2d': 'MP2D TOTAL ENERGY'}; VARH['mp2.5'] = {; 'hf': 'HF TOTAL ENERGY',; 'mp2': 'MP2 TOTAL ENERGY',; 'mp2.5': 'MP2.5 TOTAL ENERGY',; 'mp3': 'MP3 TOTAL ENERGY'}; VARH['mp3'] = {; 'hf': 'HF TOTAL ENERGY',; 'mp2': 'MP2 TOTAL ENERGY',; 'mp2.5': 'MP2.5 TOTAL ENERGY',; 'mp3': 'MP3 TOTAL ENERGY'}; VARH['mp4(sdq)'] = {; 'hf': 'HF TOTAL ENERGY',; 'mp2': 'MP2 TOTAL ENERGY',; 'mp2.5': 'MP2.5 TOTAL ENERGY',; 'mp3': 'MP3 TOTAL ENERGY',; 'mp4(sdq)': 'MP4(SDQ) TOTAL ENERGY'}; VARH['mp4'] = {; 'hf': 'HF TOTAL ENERGY',; 'mp2': 'MP2 TOTAL ENERGY',; 'mp2.5': 'MP2.5 TOTAL ENERGY',; 'mp3': 'MP3 TOTAL ENERGY',; 'mp4(sdq)': 'MP4(SDQ) TOTAL ENERGY',; 'mp4': 'MP4 TOTAL ENERGY'}; VARH['omp2'] = {; 'hf': 'HF TOTAL ENERGY',; 'mp2': 'MP2 TOTAL ENERGY',; 'omp2': 'OMP2 TOTAL ENERGY'}; VARH['omp2.5'] = {; 'hf': 'HF TOTAL ENERGY',; 'mp2': 'MP2 TOTAL ENERGY',; 'mp2.5': 'MP2.5 TOTAL ENERGY',; 'omp2.5': 'OMP2.5 TOTAL ENERGY'}; VARH['omp3'] = {; 'hf': 'HF TOTAL ENERGY',; 'mp2': 'MP2 TOTAL ENERGY',; 'mp3': 'MP3 TOTAL ENERGY',; 'omp3': 'OMP3 TOTAL ENERGY'}; VARH['olccd'] = {; 'hf': 'HF TOTAL ENERGY',; 'mp2': 'MP2 TOTAL ENERGY',; 'olccd': 'OLCCD TOTAL ENERGY'}; VARH['oremp2'] = {; 'hf': 'HF TOTAL ENERGY',; 'mp2': 'MP2 TOTAL ENERGY',; 'oremp2': 'OREMP2 TOTAL ENERGY'}; VARH['lccd'] = {; 'hf': 'HF TOTAL ENERGY',; 'mp2': 'MP2 TOTAL ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver_cbs.html:11702,ENERGY,ENERGY,11702,psi4manual/1.7.x/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver_cbs.html,16,['ENERGY'],['ENERGY']
Energy Efficiency,"ained energy minimizations of HOOH with cc-pvdz RHF Internal-coordinate constraints in internal-coordinate optimizations. molden2; Test of the superposition of atomic densities (SAD) guess, using a highly distorted water geometry with a cc-pVDZ basis set. This is just a test of the code and the user need only specify guess=sad to the SCF module’s (or global) options in order to use a SAD guess. The test is first performed in C2v symmetry, and then in C1. dfccsd-t-grad1; DF-CCSD(T) cc-pVDZ gradients for the H2O molecule. dfmp2-grad2; DF-MP2 cc-pVDZ gradient for the NO molecule. casscf-semi; CASSCF/6-31G** energy point. Check energy with frozen core/virtual orbs. after semicanonicalization. dlpnomp2-1; comparison of DF-MP2 and DLPNO-MP2. scf4; RHF cc-pVDZ energy for water, automatically scanning the symmetric stretch and bending coordinates using Python’s built-in loop mechanisms. The geometry is specified using a Z-matrix with variables that are updated during the potential energy surface scan, and then the same procedure is performed using polar coordinates, converted to Cartesian coordinates. dfmp2-grad1; DF-MP2 cc-pVDZ gradients for the H2O molecule. pywrap-cbs1; Various basis set extrapolation tests. dfmp2-ecp; Ne-Xe dimer MP2 energies with ECP, with electrons correlated then frozen. scf3; File retention, docc, socc, and bond distances specified explicitly. mbis-2; MBIS calculation on OH- (Expanded Arrays). opt13; B3LYP cc-pVDZ geometry optimzation of phenylacetylene, starting from not quite linear structure updated reference due to new BraggSlater radii. cisd-h2o-clpse; 6-31G** H2O Test CISD Energy Point with subspace collapse. mbis-3; MBIS calculation on OH radical. props1; RHF STO-3G dipole moment computation, performed by applying a finite electric field and numerical differentiation. fnocc4; Test FNO-DF-CCSD(T) energy. cc42; RHF-CC2-LR/STO-3G optical rotation of (S)-methyloxirane. gauge = length, omega = (589 355 nm). cbs-xtpl-energy; Extrapolated water energ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/autodoc_testsuite_corepsi4-1.html:7555,energy,energy,7555,psi4manual/1.5.0/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/autodoc_testsuite_corepsi4-1.html,4,['energy'],['energy']
Energy Efficiency,"ained. delta2_wfn_lesser (string) – delta_wfn || 'ccsd(t)' || etc.; Indicates the inferior energy method for which a second delta correction; to the correlation energy is to be obtained. delta3_wfn (string) – 'ccsd' || 'ccsd(t)' || etc.; Indicates the (superior) energy method for which a third delta correction; to the correlation energy is to be obtained. delta3_wfn_lesser (string) – delta2_wfn || 'ccsd(t)' || etc.; Indicates the inferior energy method for which a third delta correction; to the correlation energy is to be obtained. delta4_wfn (string) – 'ccsd' || 'ccsd(t)' || etc.; Indicates the (superior) energy method for which a fourth delta correction; to the correlation energy is to be obtained. delta4_wfn_lesser (string) – delta3_wfn || 'ccsd(t)' || etc.; Indicates the inferior energy method for which a fourth delta correction; to the correlation energy is to be obtained. delta5_wfn (string) – 'ccsd' || 'ccsd(t)' || etc.; Indicates the (superior) energy method for which a fifth delta correction; to the correlation energy is to be obtained. delta5_wfn_lesser (string) – delta4_wfn || 'ccsd(t)' || etc.; Indicates the inferior energy method for which a fifth delta correction; to the correlation energy is to be obtained. Basis Sets; Currently, the basis set set through set commands have no influence; on a cbs calculation. Parameters:; scf_basis (basis string) – corl_basis || 'cc-pV[TQ]Z' || 'jun-cc-pv[tq5]z' || '6-31G*' || etc.; Indicates the sequence of basis sets employed for the reference energy.; If any correlation method is specified, scf_basis can default; to corl_basis. corl_basis (basis string) – 'cc-pV[TQ]Z' || 'jun-cc-pv[tq5]z' || '6-31G*' || etc.; Indicates the sequence of basis sets employed for the correlation energy. delta_basis (basis string) – 'cc-pV[TQ]Z' || 'jun-cc-pv[tq5]z' || '6-31G*' || etc.; Indicates the sequence of basis sets employed for the delta correction; to the correlation energy. delta2_basis (basis string) – 'cc-pV[TQ]Z' || 'jun-cc-pv",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/cbs-1.html:5061,energy,energy,5061,psi4manual/1.0.0/cbs-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/cbs-1.html,4,['energy'],['energy']
Energy Efficiency,"air[0]), str(pair[1]))); ghost = list(set(pair[1]) - set(pair[0])). current_mol = molecule.extract_subsets(list(pair[0]), ghost); ptype_dict[pair] = func(method_string, molecule=current_mol, **kwargs); energies_dict[pair] = core.get_variable(""CURRENT ENERGY""); core.print_out(""\n N-Body: Complex Energy (fragments = %s, basis = %s: %20.14f)\n"" %; (str(pair[0]), str(pair[1]), energies_dict[pair])). # Flip this off for now, needs more testing; #if 'cp' in bsse_type_list and (len(bsse_type_list) == 1):; # core.set_global_option('DF_INTS_IO', 'LOAD'). core.clean(). # Final dictionaries; cp_energy_by_level = {n: 0.0 for n in nbody_range}; nocp_energy_by_level = {n: 0.0 for n in nbody_range}. cp_energy_body_dict = {n: 0.0 for n in nbody_range}; nocp_energy_body_dict = {n: 0.0 for n in nbody_range}; vmfc_energy_body_dict = {n: 0.0 for n in nbody_range}. # Build out ptype dictionaries if needed; if ptype != 'energy':; if ptype == 'gradient':; arr_shape = (molecule_total_atoms, 3); elif ptype == 'hessian':; arr_shape = (molecule_total_atoms * 3, molecule_total_atoms * 3); else:; raise KeyError(""N-Body: ptype '%s' not recognized"" % ptype). cp_ptype_by_level = {n: np.zeros(arr_shape) for n in nbody_range}; nocp_ptype_by_level = {n: np.zeros(arr_shape) for n in nbody_range}; vmfc_ptype_by_level = {n: np.zeros(arr_shape) for n in nbody_range}. cp_ptype_body_dict = {n: np.zeros(arr_shape) for n in nbody_range}; nocp_ptype_body_dict = {n: np.zeros(arr_shape) for n in nbody_range}; vmfc_ptype_body_dict = {n: np.zeros(arr_shape) for n in nbody_range}; else:; cp_ptype_by_level, cp_ptype_body_dict = None, None; nocp_ptype_by_level, nocp_ptype_body_dict = None, None; vmfc_ptype_body_dict = None. # Sum up all of the levels; for n in nbody_range:. # Energy; cp_energy_by_level[n] = sum(energies_dict[v] for v in cp_compute_list[n]); nocp_energy_by_level[n] = sum(energies_dict[v] for v in nocp_compute_list[n]). # Special vmfc case; if n > 1:; vmfc_energy_body_dict[n] = vmfc_energy_body_dict[n ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/driver_nbody.html:10622,energy,energy,10622,psi4manual/1.1.0/_modules/psi4/driver/driver_nbody.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/driver_nbody.html,1,['energy'],['energy']
Energy Efficiency,"airwise_disp=save_pair, **kwargs). ## Dimer dispersion; dimer_disp_energy = _disp_functor.compute_energy(dimer_wfn.molecule(), dimer_wfn); ## Monomer dispersion; mon_disp_energy = _disp_functor.compute_energy(monomerA); mon_disp_energy += _disp_functor.compute_energy(monomerB). disp_interaction_energy = dimer_disp_energy - mon_disp_energy; core.set_variable(saptd_name + ""-D DISP ENERGY"", disp_interaction_energy); core.set_variable(""SAPT DISP ENERGY"", disp_interaction_energy); core.set_variable(""DISPERSION CORRECTION ENERGY"", disp_interaction_energy); core.set_variable(saptd_name + ""DISPERSION CORRECTION ENERGY"", disp_interaction_energy). ## Set SAPT0-D3 variables; total = disp_interaction_energy; saptd_en = {}; saptd_en['DISP'] = disp_interaction_energy; for term in ['ELST', 'EXCH', 'IND']:; en = core.variable(' '.join([sapt0_name, term, 'ENERGY'])); saptd_en[term] = en; core.set_variable(' '.join([saptd_name + '-D', term, 'ENERGY']), en); core.set_variable(' '.join(['SAPT', term, 'ENERGY']), en); total += en. core.set_variable(saptd_name + '-D TOTAL ENERGY', total); core.set_variable('SAPT TOTAL ENERGY', total); core.set_variable('CURRENT ENERGY', total). ## Print Energy Summary; units = (1000.0, constants.hartree2kcalmol, constants.hartree2kJmol); core.print_out(f"" => {saptd_name +'-D'} Energy Summary <=\n""). core.print_out("" "" + ""-"" * 104 + ""\n""); core.print_out(; "" %-25s % 16.8f [mEh] % 16.8f [kcal/mol] % 16.8f [kJ/mol]\n"" %; (""Electrostatics"", saptd_en['ELST'] * units[0], saptd_en['ELST'] * units[1], saptd_en['ELST'] * units[2])); core.print_out("" %-25s % 16.8f [mEh] % 16.8f [kcal/mol] % 16.8f [kJ/mol]\n"" %; (""Exchange"", saptd_en['EXCH'] * units[0], saptd_en['EXCH'] * units[1], saptd_en['EXCH'] * units[2])); core.print_out("" %-25s % 16.8f [mEh] % 16.8f [kcal/mol] % 16.8f [kJ/mol]\n"" %; (""Induction"", saptd_en['IND'] * units[0], saptd_en['IND'] * units[1], saptd_en['IND'] * units[2])); core.print_out(; "" %-25s % 16.8f [mEh] % 16.8f [kcal/mol] % 16.8f [kJ/mol]\n"" %",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc_util.html:9826,ENERGY,ENERGY,9826,psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc_util.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc_util.html,3,['ENERGY'],['ENERGY']
Energy Efficiency,"aise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_omp3_gradient(name, **kwargs):; """"""Function selecting the algorithm for an OMP3 gradient call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference in ['RHF', 'UHF', 'ROHF', 'RKS', 'UKS']:; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ_gradient; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc_gradient. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_mp2p5(name, **kwargs):; """"""Function selecting the algorithm for a MP2.5 energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference in ['RHF', 'UHF']:; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_mp2p5_gradient(name, **kwargs):; """"""Function selecting the algorithm for a MP2.5 gradient call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'); all_electron = (core.get_global_option('FREEZE_CORE') =",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:15060,energy,energy,15060,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,8,['energy'],['energy']
Energy Efficiency,"aise ValidationError(f""This little engine ({engine}) can't (3c)""). [docs] def print_out(self):; """"""Format dispersion parameters of `self` for output file."""""". text = []; text.append("" => {}: Empirical Dispersion <="".format(; (self.fctldash.upper() if self.fctldash.upper() else 'Custom'))); text.append(''); text.append(self.description); text.append(self.dashlevel_citation.rstrip()); if self.dashparams_citation:; text.append("" Parametrisation from:{}"".format(self.dashparams_citation.rstrip())); text.append(''); for op in self.ordered_params:; text.append("" %6s = %14.6f"" % (op, self.dashparams[op])); text.append('\n'). core.print_out('\n'.join(text)). [docs] def compute_energy(self, molecule: core.Molecule, wfn: core.Wavefunction = None) -> float:; """"""Compute dispersion energy based on engine, dispersion level, and parameters in `self`. Parameters; ----------; molecule; System for which to compute empirical dispersion correction.; wfn; Location to set QCVariables. Returns; -------; float; Dispersion energy [Eh]. Notes; -----; :psivar:`DISPERSION CORRECTION ENERGY`; Disp always set. Overridden in SCF finalization, but that only changes for ""-3C"" methods.; :psivar:`fctl DISPERSION CORRECTION ENERGY`; Set if :py:attr:`fctldash` nonempty. """"""; if self.engine in [""s-dftd3"", 'dftd3', 'mp2d', ""dftd4""]:; resi = AtomicInput(; **{; 'driver': 'energy',; 'model': {; 'method': self.fctldash,; 'basis': '(auto)',; },; 'keywords': {; 'level_hint': self.dashlevel,; 'params_tweaks': self.dashparams,; 'dashcoeff_supplement': self.dashcoeff_supplement,; 'pair_resolved': self.save_pairwise_disp,; 'apply_qcengine_aliases': True, # for s-dftd3; 'verbose': 1,; },; 'molecule': molecule.to_schema(dtype=2),; 'provenance': p4util.provenance_stamp(__name__),; }); jobrec = qcng.compute(; resi,; self.engine,; raise_error=True,; task_config={""scratch_directory"": core.IOManager.shared_object().get_default_path(), ""ncores"": core.get_num_threads()}). dashd_part = float(jobrec.extras['qcvars']['DISPERSIO",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/empirical_dispersion.html:8878,energy,energy,8878,psi4manual/1.7.x/_modules/psi4/driver/procrouting/empirical_dispersion.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/empirical_dispersion.html,2,['energy'],['energy']
Energy Efficiency,"ak your code. If most of your work was on the python (as opposed to c++) side, the test case prefix pywrap_ is suggested. Be sure to set any new PSI variables through lines like those below. Especially if the function returns an energy, set the ‘current energy’ variable. This last is needed to communicate with the optimizer.; PsiMod.set_variable('MP2.5 CORRELATION ENERGY', ce_mp25); PsiMod.set_variable('MP2.5 TOTAL ENERGY', e_mp25); PsiMod.set_variable('CURRENT ENERGY', e_mp25). Once your python function is fairly stable on its own, it’s potential for interoperability with energy()/opt()/cp()/db()/cbs()/etc. should be evaluated. If it makes physical sense that it should work, you should strive to make that interoperability a reality. Some steps:. If any interoperability is possible, define an argument xx_func, where xx is a short name for your function. Add near the top of your function code like the below (less the final two lines). The net result of this code is that if the user specifies no *_func arguments, then energy() gets called. If the user defines xx_func, then its value gets called. If the user defines func, then its value gets reassigned to xx_func, func itself is deleted, and xx_func() gets called. Whatever is getting called is stored in func within the function.; # Establish function to call; if not('xx_func' in kwargs):; if ('func' in kwargs):; kwargs['xx_func'] = kwargs['func']; del kwargs['func']; else:; kwargs['xx_func'] = energy; func = kwargs['xx_func']; if not func:; raise ValidationError('Function \'%s\' does not exist to be called by wrapper counterpoise_correct.' % (func.__name__)); if (func is db):; raise ValidationError('Wrapper xx is unhappy to be calling function \'%s\'.' % (func.__name__)). If specific interoperabilities are known, code them in. For example, if xx shouldn’t call db, add the last two lines above to the xx function. If db shouldn’t call xx, add the following two lines below to the db function.; if (func is xx):; raise Vali",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/bestpractices_py-1.html:5034,energy,energy,5034,psi4manual/4.0b2/bestpractices_py-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/bestpractices_py-1.html,6,['energy'],['energy']
Energy Efficiency,"ake). To be used by PSI4, the program binary (gcp or mctc-gcp) must be; found in your PATH so that QCEngine can detect it. Check if and where; found through qcengine info. If; PSI4 is unable to execute the binary, an error will be reported.; To preferentially use a particular gcp compilation, simply adjust its; position in the path environment variables. Running gCP¶; At present there is a limited interface to gCP that is used; only to implement the “HF-3c” [Sure:2013:1672] and “PBEh-3c”; [Grimme:2015:054107] methods (both energy and gradient). The interface; can use classic or mctc-gcp executables interchangeably and will prefer the latter.; A DFTD3 executable, classic or simple-dftd3,; must also be available for these methods to; run. Unlike every other method in PSI4, if a basis set has not been; set, these will default to their intended basis sets: MINIX for HF-3c; and def2-mSVP for PBEh-3c. If a basis has previously been set, but you; want to use the default basis, use the slash syntax to “empty” the basis; option for the scope of the current calculation, energy(""hf3c/"").; A few practical examples:. HF-3c single point with default minix basis; energy('hf3c'). PBEh-3c optimization with default def2-mSVP basis; optimize('pbeh3c'). HF-3c with non-standard basis; set basis cc-pvdz; energy('hf3c'). PBEh-3c with default basis after basis set; set basis cc-pvdz; energy('pbeh3c/'). If only BSSE/basis set corrections (rather than total energies) are of; interest, the gcp program can be run independently of the scf; through the python function run_gcp(). (This function; is the same PSI4/gcp interface that is called during an scf job.); This route is much faster than running a HF or DFT energy.; molecule nene {; Ne; Ne 1 2.0; }. nene.update_geometry(). >>> E, G = nene.run_gcp('hf3c'). >>> E, G = nene.run_gcp(func='HF3c', verbose=True). qcdb.Molecule.run_gcp(self, func=None, dertype=None, verbose=1)¶; Compute geometrical BSSE correction via Grimme’s GCP program.; Function t",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/gcp.html:2566,energy,energy,2566,psi4manual/1.7.x/gcp.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/gcp.html,2,['energy'],['energy']
Energy Efficiency,"aken from a string. atom_at_position(b, tol=0.05)[source]¶; Tests to see of an atom is at the passed position b in Bohr with a tolerance tol.; >>> print H2OH2O.atom_at_position([1.35*(1.0/psi_bohr2angstroms), 0.10*(1.0/psi_bohr2angstroms), 0.0*(1.0/psi_bohr2angstroms)]); 3. atom_entry(atom)[source]¶; Returns the CoordEntry for an atom. atom_to_unique(iatom)[source]¶; Converts an atom number to the number of its generating unique atom.; The return value is in [0, nunique). atom_to_unique_offset(iatom)[source]¶; Converts an atom number to the offset of this atom; in the list of generated atoms. The unique atom itself is allowed offset 0. center_of_mass()[source]¶; Computes center of mass of molecule (does not translate molecule).; >>> H2OH2O.center_of_mass(); [-0.12442647346606871, 0.00038657002584110707, 0.0]. charge(atom)[source]¶; Returns charge of atom (0-indexed).; Related to SAD guess in libmints version.; >>> print H2OH2O.charge(4); 1.0. charge_specified()[source]¶; Whether the charge was given by the user; >>> print H2OH2O.charge_specified(); True. clear()[source]¶; Zero it out. clear_basis_all_atoms()[source]¶; Remove all basis information from atoms. clone()[source]¶; Returns new, independent Molecule object.; >>> dimer = H2OH2O.clone(). create_molecule_from_string(text)[source]¶; Given a string text of psi4-style geometry specification; (including newlines to separate lines), builds a new molecule.; Called from constructor. create_psi4_string_from_molecule()[source]¶; Regenerates a input file molecule specification string from the; current state of the Molecule. Contains geometry info,; fragmentation, charges and multiplicities, and any frame; restriction. deactivate_all_fragments()[source]¶; Sets all fragments in the molecule to be inactive. distance_matrix()[source]¶; Computes a matrix depicting distances between atoms. Prints; formatted and returns array.; >>> H2OH2O.distance_matrix(); Interatomic Distances (Angstroms); [1] [2] [3] [4] [5] [6]; [1] 0.0000",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_driver-1.html:76411,charge,charge,76411,psi4manual/1.0.0/autodoc_driver-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_driver-1.html,2,['charge'],['charge']
Energy Efficiency,"aking it ideal for; large systems and multi-core CPUs. See COSX Exchange for more information. LINKAn implementation of the linear-scaling “Linear Exchange” (LinK); algorithm described in [Ochsenfeld:1998:1663]. The LINK algorithm provides; many of the benefits of integral-direct SCF algorithms, including no disk I/O,; low memory usage, and effective parallelization. Additionally, the; LINK implementation scales well with system size; while simultaneously providing a formally-exact computation of the; Exchange term. See Linear Exchange for more information. SNLINKAn algorithm based on the “seminumerical Linear Exchange” (sn-LinK); approach described in [Laqua:2020:1456], SNLINK is only available if PSI4; is compiled with the GauXC library, described in [Williams-Young:2023:234104].; Algorithmically, SNLINK is very similar to COSX, differing primarily in screening of; the analytic 3-center integrals. In terms of implementation, SNLINK is more efficient,; owing to more highly-optimized integral contraction kernels; and supports execution; on Graphics Processing Units (GPUs). See Seminumerical Linear Exchange for more information. In some cases the above algorithms have multiple implementations that return; the same result, but are optimal under different molecules sizes and hardware; configurations. Psi4 will automatically detect the correct algorithm to run and; only expert users should manually select the below implementations. The DF; algorithm has the following two implementations. MEM_DFA DF algorithm optimized around memory layout and is optimal as long as; there is sufficient memory to hold the three-index DF tensors in memory. This; algorithm may be faster for builds that require disk if SSDs are used. DISK_DFA DF algorithm (the default DF algorithm before Psi4 1.2) optimized to; minimize Disk IO by sacrificing some performance due to memory layout. Note that these algorithms have both in-memory and on-disk options, but; performance penalties up to a factor of ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/scf.html:30727,efficient,efficient,30727,psi4manual/master/scf.html,https://psicode.org,https://psicode.org/psi4manual/master/scf.html,1,['efficient'],['efficient']
Energy Efficiency,"al 4-index AO integrals use a; density-fitted SCF reference. That is, for DF-MP2 and SAPT, the default SCF_TYPE is DF. [4]; Note that this table applies to the final convergence criteria for; all the post-SCF modules that define a E_CONVERGENCE keyword. [5]; The E_CONVERGENCE keyword is implemented for most post-SCF modules.; See a list beginning at E_CONVERGENCE. [6]; The R_CONVERGENCE keyword places a convergence check on an internal; residual error measure and is implemented for several post-SCF; modules (see list beginning at R_CONVERGENCE). It is defined; according to the quantum chemical method and so its default value is set; by each module individually. [7]; (1,2,3); For frequency computations by finite difference of energies,; convergence criteria are tightened further still to 10 for; E_CONVERGENCE and D_CONVERGENCE for SCF of HF or DFT, 11; for E_CONVERGENCE and D_CONVERGENCE for SCF of post-HF,; and 10 for E_CONVERGENCE for post-HF of post-HF. Recommendations¶; The SCF code is quite flexible and powerful.; We have tried as much as possible to keep the number of options to; a minimum and to allow all options to be used in the presence of all other; options. Below are some rough words of advice about using the SCF code for; practical calculations:. For GUESS, the SAD guess is usually your; friend, even for open-shell systems (at the very least, it gets the right; number of electrons, unlike some other programs). For instance, we have found; that a simple SAD guess is often as good as doing a full SCF in a 3-21G basis; and then performing a cast-up, at a fraction of the cost. However, SAD and; DOCC/SOCC arrays do not play very well together at the moment.; For wall time, DF may be a factor of ten or more faster than the exact; integral technologies available in PSI4.; Use DF unless you need absolute accuracy or do not; have a -JKFIT auxiliary set for your orbital basis/atom type. Then use; DIRECT.; Don’t mess with the DIIS convergence options unless converge",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/scf.html:48502,power,powerful,48502,psi4manual/1.7.x/scf.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/scf.html,4,['power'],['powerful']
Energy Efficiency,"al EXTERN object and the external_potential"" +; "" keyword argument are specified. The external_potentials keyword argument will be ignored.\n""); raise ValidationError(""double extern""). ep = kwargs.get(""external_potentials"", None); if ep is not None:; _set_external_potentials_to_wavefunction(ep, wfn). return wfn. def _set_external_potentials_to_wavefunction(external_potential: Union[List, Dict[str, List]], wfn: ""core.Wavefunction""):; """"""Initialize :py:class:`psi4.core.ExternalPotential` object(s) from charges and locations and set on **wfn**. Parameters; ----------; external_potential; List-like structure where each row corresponds to a charge. Lines can be composed of ``q, [x, y, z]`` or; ``q, x, y, z``. Locations are in [a0].; Or, dictionary where keys are FI-SAPT fragments A, B, or C and values are as above. """"""; from psi4.driver.qmmm import QMMMbohr. def validate_qxyz(qxyz):; if len(qxyz) == 2:; return qxyz[0], qxyz[1][0], qxyz[1][1], qxyz[1][2]; elif len(qxyz) == 4:; return qxyz[0], qxyz[1], qxyz[2], qxyz[3]; else:; raise ValidationError(f""Point charge '{qxyz}' not mapping into 'chg, [x, y, z]' or 'chg, x, y, z'""). if isinstance(external_potential, dict):; # For FSAPT, we can take a dictionary of external potentials, e.g.,; # external_potentials={'A': potA, 'B': potB, 'C': potC} (any optional); # For the dimer SAPT calculation, we need to account for the external potential; # in all of the subsystems A, B, C. So we add them all in total_external_potential; # and set the external potential to the dimer wave function. total_external_potential = core.ExternalPotential(). for frag, frag_qxyz in external_potential.items():; if frag.upper() in ""ABC"":; chrgfield = QMMMbohr(); for qxyz in frag_qxyz:; chrgfield.extern.addCharge(*validate_qxyz(qxyz)). wfn.set_potential_variable(frag.upper(), chrgfield.extern); total_external_potential.appendCharges(chrgfield.extern.getCharges()). else:; core.print_out(""\n Warning! Unknown key for the external_potentials argument: %s"" % fra",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:36731,charge,charge,36731,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,10,['charge'],['charge']
Energy Efficiency,"al QC variable. del_scalar_variable(self, arg0); Removes the requested (case-insensitive) double QC variable. del_variable(key); Removes scalar or array QCVariable key from cls if present. density_fitted(self); Returns whether this wavefunction was obtained using density fitting or not. diis(self); docstring. doccpi(self); Returns the number of doubly occupied orbitals per irrep. efzc(self); Returns the frozen-core energy. energy(self); Returns the Wavefunction's energy. epsilon_a(self); Returns the Alpha Eigenvalues. epsilon_a_subset(self, basis, subset); Returns the requested Alpha orbital energies subset. epsilon_b(self); Returns the Beta Eigenvalues. epsilon_b_subset(self, basis, subset); Returns the requested Beta orbital energies subset. esp_at_nuclei(self); returns electrostatic potentials at nuclei. external_pot(self); Gets the requested external potential. finalize(self); Cleans up the the Wavefunction's temporary data. finalize_energy(); Performs stability analysis and calls back SCF with new guess if needed, Returns the SCF energy. find_occupation(self); docstring. force_doccpi(self, arg0); Specialized expert use only. force_soccpi(self, arg0); Specialized expert use only. form_C(self[, shift]); Forms the Orbital Matrices from the current Fock Matrices. form_D(self); Forms the Density Matrices from the current Orbitals Matrices. form_F(self); Forms the F matrix. form_FDSmSDF(self, arg0, arg1); Forms the residual of SCF theory. form_G(self); Forms the G matrix. form_H(self); Forms the core Hamiltonian. form_Shalf(self); Forms the S^1/2 matrix. form_V(self); Form the Kohn-Sham Potential Matrices from the current Density Matrices. form_initial_C(self); Forms the initial Orbital Matrices from the current Fock Matrices. form_initial_F(self); Forms the initial F matrix. frac_renormalize(self); docstring. frequencies(). from_file(wfn_data); Build Wavefunction from data. frzcpi(self); Returns the number of frozen core orbitals per irrep. frzvpi(self); Returns the",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/api/psi4.core.cuhf.html:4836,energy,energy,4836,psi4manual/1.5.0/api/psi4.core.cuhf.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/api/psi4.core.cuhf.html,10,['energy'],['energy']
Energy Efficiency,"al and Thermochemical Analysis — Psi4 [1.0.0 6a9a71b] Docs. Navigation. index. modules    . toc    . next    . previous    ; Psi4 [1.0.0 6a9a71b] » ; Theoretical Methods: SCF to FCI ». Vibrational and Thermochemical Analysis¶; Code author: Rollin A. King; Module: Keywords, PSI Variables, THERMO. Caution; It is important to know that Psi4, like any other; quantum chemistry program, does not compute the usual enthalpies,; entropies, or Gibbs free energies of formation provided by most; reference books. Instead, quantum chemistry programs compute “absolute”; thermodynamic properties relative to infinitely separated nuclei and; electrons, not “formation” values relative to elements in their standard; states. If you are computing thermodynamic differences, like a reaction; enthalpy computed as the enthalpy of the products minus the enthalpy; of the reactants, then these “absolute” enthalpies are perfectly valid; and usable. However, they cannot be mixed and matched with enthalpies of; formation from reference books, since the zero of energy is not the same.; Additionally, the “thermal energies” reported in kcal/mol are the; finite-temperature corrections to the electronic total energy, and; not the overall thermal energies themselves. If in doubt, use the; reported Total Energies in Hartree/particle. Keywords¶. T¶. Temperature in Kelvin for thermodynamic analysis. Note that 273.15 is the value for IUPAC STP. Type: double; Default: 298.15. P¶. Pressure in Pascal for thermodynamic analysis. Note that 100000. is the value for IUPAC STP. Type: double; Default: 101325. ROTATIONAL_SYMMETRY_NUMBER¶. Rotational symmetry number for thermodynamic analysis. Default is set from the full point group (e.g., Td for methane) as opposed to the computational point group (e.g., C2v for methane). Default takes into account symmetry reduction through asymmetric isotopic substitution and is unaffected by user-set symmetry on molecule, so this option is the sole way to influence the symmetry-d",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/thermo-1.html:1057,energy,energy,1057,psi4manual/1.0.0/thermo-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/thermo-1.html,2,['energy'],['energy']
Energy Efficiency,al data for cumulative IE; inputs are total energies w/ vmfc treatment |; +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+; | |em| VMFC-CORRECTED INTERACTION ENERGY THROUGH {nb}-BODY | |em| 1 | when vmfc in bsse_type | {max_nbody}-body total data less 1-body total data for cumulative IE; inputs are total energies w/ vmfc treatment |; +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+; | |em| VMFC-CORRECTED INTERACTION ENERGY | |em| 1 | when vmfc in bsse_type | best available interaction energy with vmfc treatment: VMFC-CORRECTED INTERACTION ENERGY THROUGH {max_nbody}-BODY |; +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+; | |em| VMFC-CORRECTED 2-BODY CONTRIBUTION TO ENERGY | |em| 1 | when vmfc in bsse_type & max_nbody>=2 | 2-body total data less (2-1)-body total data for partial IE; inputs are total energies w/ vmfc treatment |; +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+; | |em| VMFC-CORRECTED {nb}-BODY CONTRIBUTION TO ENERGY | |em| 1 | when vmfc in bsse_type | {max_nbody}-body total data less ({max_nbody}-1)-body data for partial IE; inputs are total energies w/ vmfc treat.,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver_nbody.html:55618,ENERGY,ENERGY,55618,psi4manual/1.6.x/_modules/psi4/driver/driver_nbody.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver_nbody.html,15,['ENERGY'],['ENERGY']
Energy Efficiency,"al electronic energy [H] for the requested DFT method,; in Eq. (1). (1); Unless the method is a DFT double-hybrid, this quantity is equal to; SCF TOTAL ENERGY. If the method is neither a; double-hybrid, nor dispersion corrected, this quantity is equal to; DFT FUNCTIONAL TOTAL ENERGY. DFT XC ENERGY¶; The functional energy contribution [H] to the total SCF energy (DFT only).; Quantity in Eqs. (3) and (1). DISPERSION CORRECTION ENERGY¶; The dispersion correction [H] appended to an underlying functional; when a DFT-D method is requested. Quantity ; in Eqs. (3) and (1). DOUBLE-HYBRID CORRECTION ENERGY¶; The scaled MP2 correlation energy correction [H] appended to an; underlying functional when a DH-DFT method is requested.; Quantity in Eq. (1). FCI TOTAL ENERGY¶. FCI CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the full configuration interaction level of theory. HF TOTAL ENERGY¶; The total electronic energy [H] for the Hartree–Fock method, without; any dispersion correction; the first three (or four, since; ) terms in Eq. (3). Quantity ; in Eq. (3). LCC2 (+LMP2) TOTAL ENERGY¶; The total electronic energy [H] for the local CC2 level of theory. LCCSD (+LMP2) TOTAL ENERGY¶; The total electronic energy [H] for the local CCSD level of theory. MP2 TOTAL ENERGY¶. MP2 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the MP2 level of theory. MP2.5 TOTAL ENERGY¶. MP2.5 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the MP2.5 level of theory. MP3 TOTAL ENERGY¶. MP3 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the MP3 level of theory. MPn TOTAL ENERGY¶. MPn CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the labeled Möller–Plesset perturbation theory level.; n is MP perturbation order. NUCLEAR REPULSION ENERGY¶; The nuclear repulsion energy contri",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/glossary_psivariables-1.html:11452,energy,energy,11452,psi4manual/4.0b3/glossary_psivariables-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/glossary_psivariables-1.html,2,['energy'],['energy']
Energy Efficiency,"al electronic energy [H] for the requested DFT method,; in Eq. (1). (1); Unless the method is a DFT double-hybrid, this quantity is equal to; SCF TOTAL ENERGY. If the method is neither a; double-hybrid, nor dispersion corrected, this quantity is equal to; DFT FUNCTIONAL TOTAL ENERGY. DFT XC ENERGY¶; The functional energy contribution [H] to the total SCF energy (DFT only).; Quantity in Eqs. (4) and (1). DISPERSION CORRECTION ENERGY¶; The dispersion correction [H] appended to an underlying functional; when a DFT-D method is requested. Quantity ; in Eqs. (4) and (1). DOUBLE-HYBRID CORRECTION ENERGY¶; The scaled MP2 correlation energy correction [H] appended to an; underlying functional when a DH-DFT method is requested.; Quantity in Eq. (1). FCI TOTAL ENERGY¶. FCI CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the full configuration interaction level of theory. HF TOTAL ENERGY¶; The total electronic energy [H] for the Hartree–Fock method, without; any dispersion correction; the first three (or four, since; ) terms in Eq. (4). Quantity ; in Eq. (4). LCC2 (+LMP2) TOTAL ENERGY¶; The total electronic energy [H] for the local CC2 level of theory. LCCSD (+LMP2) TOTAL ENERGY¶; The total electronic energy [H] for the local CCSD level of theory. MP2 TOTAL ENERGY¶. MP2 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the MP2 level of theory. MP2.5 TOTAL ENERGY¶. MP2.5 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the MP2.5 level of theory. MP3 TOTAL ENERGY¶. MP3 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the MP3 level of theory. MP4(SDQ) TOTAL ENERGY¶. MP4(SDQ) CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the MP4 singles, doubles, quadruples level of theory. Quantity; MP4(SDQ) CORRELATION ENERGY is; first right-hand term in Eq. (2). MP4 T",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/glossary_psivariables-1.html:11646,energy,energy,11646,psi4manual/1.0.0/glossary_psivariables-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/glossary_psivariables-1.html,6,['energy'],['energy']
Energy Efficiency,"al energy surface scan and CP-correction for Ne2. memory 250 mb. molecule dimer {; Ne; --; Ne 1 R; }. Rvals=[2.5, 3.0, 4.0]. set basis aug-cc-pVDZ; set freeze_core True. # Initialize a blank dictionary of counterpoise corrected energies; # (Need this for the syntax below to work); ecp = {}. for R in Rvals:; dimer.R = R; ecp[R] = cp('ccsd(t)'). psi4.print_out(""\n""); psi4.print_out(""CP-corrected CCSD(T)/aug-cc-pVDZ interaction energies\n\n""); psi4.print_out("" R (Ang) E_int (kcal/mol) \n""); psi4.print_out(""-----------------------------------------------------\n""); for R in Rvals:; e = ecp[R] * 627.5095; psi4.print_out("" %3.1f %10.6f\n"" % (R, e)). First, you can see the molecule block has a couple dashes to; separate the monomers from each other. Also note we’ve used a Z-matrix to; specify the geometry, and we’ve used a variable (R) as the; interatomic distance. We have not specified the value of R in; the molecule block like we normally would. That’s because we’re; going to vary it during the scan across the potential energy surface.; Below the molecule block, you can see the Rvals array; specified. This is a Python array holding the interatomic distances we; want to consider. In Python, arrays are surrounded by square brackets, and; elements are separated by commas.; The next lines, set basis aug-cc-pVDZ and set freeze_core True,; are familiar from previous test cases. Next comes a slightly; unusual-looking line, ecp = {}. This is Python’s way of initializing; a “dictionary”. We’re going to use this dictionary to store the; counterpoise-corrected energies as they become available. A dictionary is; like an array, but we can index it using strings or floating-point numbers; instead of integers if we want. Here, we will index it using; floating-point numbers, namely, the R values. This winds up being; slightly more elegant than a regular array in later parts of the input; file.; The next section, beginning with for R in Rvals:, loops over the; interatomic distances, R, i",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/tutorial-1.html:17038,energy,energy,17038,psi4manual/4.0b5/tutorial-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/tutorial-1.html,2,['energy'],['energy']
Energy Efficiency,"al error enough for DIIS to work; well. The level shift is controlled by the parameter; LEVEL_SHIFT, and it is turned off when the DIIS error is; smaller than LEVEL_SHIFT_CUTOFF. Reasonable values for; the shift and convergence threshold are 5.0 and 1e-2,; respectively. SOSCF [Off by Default]See Second-order Convergence. ERI Algorithms¶; The key difficulty in the SCF procedure is treatment of the four-index ERI; contributions to the Fock Matrix. A number of algorithms are available in; PSI4 for these terms. The algorithm is selected by the SCF_TYPE; keyword, which may be one of the following. PK [Default]An out-of-core, presorted algorithm using exact ERIs. Quite fast for a; zero-error algorithm if enough memory is available. Integrals are; generated only once, and symmetry is utilized to reduce number of; integrals. OUT_OF_COREAn out-of-core, unsorted algorithm using exact ERIs. Overcomes the; memory bottleneck of the current PK algorithm. Integrals are generated; only once, and symmetry is utilized to reduce number of integrals. DIRECTA threaded, sieved, integral-direct algorithm, with full permutational; symmetry. This algorithm is brand new, but seems to be reasonably fast; up to 1500 basis functions, uses zero disk (if DF pre-iterations are; turned off), and can obtain significant; speedups with negligible error loss if INTS_TOLERANCE; is set to 1.0E-8 or so. DF [Default]A density-fitted algorithm designed for computations with thousands of; basis functions. This algorithm is highly optimized, and is threaded; with a mixture of parallel BLAS and OpenMP. Note that this algorithm; should use the -JKFIT series of auxiliary bases, not the -RI or; -MP2FIT bases. The default guess for auxiliary basis set should work; for most bases, otherwise the DF_BASIS_SCF keyword can; be used to manually specify the auxiliary basis. This algorithm is; preferred unless either absolute accuracy is required; [\(\gtrsim\)CCSD(T)] or a -JKFIT auxiliary basis is unavailable; for the or",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/scf-1.html:24860,reduce,reduce,24860,psi4manual/1.4.0/scf-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/scf-1.html,6,['reduce'],['reduce']
Energy Efficiency,"al exchange scaling [manual]. fisapt0; 0th-order functional and/or intramolecular SAPT [manual]. sapt2; 2nd-order SAPT, traditional definition [manual]. sapt2+; SAPT including all 2nd-order terms [manual]. sapt2+(3); SAPT including perturbative triples [manual]. sapt2+3; SAPT including all 3rd-order terms [manual]. sapt2+(ccd); SAPT2+ with CC-based dispersion [manual]. sapt2+(3)(ccd); SAPT2+(3) with CC-based dispersion [manual]. sapt2+3(ccd); SAPT2+3 with CC-based dispersion [manual]. sapt2+dmp2; SAPT including all 2nd-order terms and MP2 correction [manual]. sapt2+(3)dmp2; SAPT including perturbative triples and MP2 correction [manual]. sapt2+3dmp2; SAPT including all 3rd-order terms and MP2 correction [manual]. sapt2+(ccd)dmp2; SAPT2+ with CC-based dispersion and MP2 correction [manual]. sapt2+(3)(ccd)dmp2; SAPT2+(3) with CC-based dispersion and MP2 correction [manual]. sapt2+3(ccd)dmp2; SAPT2+3 with CC-based dispersion and MP2 correction [manual]. sapt0-ct; 0th-order SAPT plus charge transfer (CT) calculation [manual]. sapt2-ct; SAPT2 plus CT [manual]. sapt2+-ct; SAPT2+ plus CT [manual]. sapt2+(3)-ct; SAPT2+(3) plus CT [manual]. sapt2+3-ct; SAPT2+3 plus CT [manual]. sapt2+(ccd)-ct; SAPT2+(CCD) plus CT [manual]. sapt2+(3)(ccd)-ct; SAPT2+(3)(CCD) plus CT [manual]. sapt2+3(ccd)-ct; SAPT2+3(CCD) plus CT [manual]. adc; 2nd-order algebraic diagrammatic construction (ADC) [manual]. eom-cc2; EOM-CC2 [manual]. eom-ccsd; equation of motion (EOM) CCSD [manual]. eom-cc3; EOM-CC3 [manual]. Examples:. 1; 2>>> # [1] Coupled-cluster singles and doubles calculation with psi code; >>> energy('ccsd'). 1; 2; 3; 4; 5>>> # [2] Charge-transfer SAPT calculation with scf projection from small into; >>> # requested basis, with specified projection fitting basis; >>> set basis_guess true; >>> set df_basis_guess jun-cc-pVDZ-JKFIT; >>> energy('sapt0-ct'). 1; 2>>> # [3] Arbitrary-order MPn calculation; >>> energy('mp7'). 1; 2; 3; 4; 5; 6; 7; 8; 9>>> # [4] Converge scf as singlet, then run detc",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/energy.html:6705,charge,charge,6705,psi4manual/1.1.0/energy.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/energy.html,4,['charge'],['charge']
Energy Efficiency,"al exchange scaling [manual]. fisapt0; 0th-order functional and/or intramolecular SAPT [manual]. sapt2; 2nd-order SAPT, traditional definition [manual]. sapt2+; SAPT including all 2nd-order terms [manual]. sapt2+(3); SAPT including perturbative triples [manual]. sapt2+3; SAPT including all 3rd-order terms [manual]. sapt2+(ccd); SAPT2+ with CC-based dispersion [manual]. sapt2+(3)(ccd); SAPT2+(3) with CC-based dispersion [manual]. sapt2+3(ccd); SAPT2+3 with CC-based dispersion [manual]. sapt2+dmp2; SAPT including all 2nd-order terms and MP2 correction [manual]. sapt2+(3)dmp2; SAPT including perturbative triples and MP2 correction [manual]. sapt2+3dmp2; SAPT including all 3rd-order terms and MP2 correction [manual]. sapt2+(ccd)dmp2; SAPT2+ with CC-based dispersion and MP2 correction [manual]. sapt2+(3)(ccd)dmp2; SAPT2+(3) with CC-based dispersion and MP2 correction [manual]. sapt2+3(ccd)dmp2; SAPT2+3 with CC-based dispersion and MP2 correction [manual]. sapt0-ct; 0th-order SAPT plus charge transfer (CT) calculation [manual]. sapt2-ct; SAPT2 plus CT [manual]. sapt2+-ct; SAPT2+ plus CT [manual]. sapt2+(3)-ct; SAPT2+(3) plus CT [manual]. sapt2+3-ct; SAPT2+3 plus CT [manual]. sapt2+(ccd)-ct; SAPT2+(CCD) plus CT [manual]. sapt2+(3)(ccd)-ct; SAPT2+(3)(CCD) plus CT [manual]. sapt2+3(ccd)-ct; SAPT2+3(CCD) plus CT [manual]. adc; 2nd-order algebraic diagrammatic construction (ADC) [manual]. eom-cc2; EOM-CC2 [manual]. eom-ccsd; equation of motion (EOM) CCSD [manual]. eom-cc3; EOM-CC3 [manual]. Examples:. >>> # [1] Coupled-cluster singles and doubles calculation with psi code; >>> energy('ccsd'). >>> # [2] Charge-transfer SAPT calculation with scf projection from small into; >>> # requested basis, with specified projection fitting basis; >>> set basis_guess true; >>> set df_basis_guess jun-cc-pVDZ-JKFIT; >>> energy('sapt0-ct'). >>> # [3] Arbitrary-order MPn calculation; >>> energy('mp7'). >>> # [4] Converge scf as singlet, then run detci as triplet upon singlet reference; >>> # Not",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/energy-1.html:6707,charge,charge,6707,psi4manual/1.3.2/energy-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/energy-1.html,2,['charge'],['charge']
Energy Efficiency,"al exchange scaling [manual]. fisapt0; 0th-order functional and/or intramolecular SAPT [manual]. sapt2; 2nd-order SAPT, traditional definition [manual]. sapt2+; SAPT including all 2nd-order terms [manual]. sapt2+(3); SAPT including perturbative triples [manual]. sapt2+3; SAPT including all 3rd-order terms [manual]. sapt2+(ccd); SAPT2+ with CC-based dispersion [manual]. sapt2+(3)(ccd); SAPT2+(3) with CC-based dispersion [manual]. sapt2+3(ccd); SAPT2+3 with CC-based dispersion [manual]. sapt2+dmp2; SAPT including all 2nd-order terms and MP2 correction [manual]. sapt2+(3)dmp2; SAPT including perturbative triples and MP2 correction [manual]. sapt2+3dmp2; SAPT including all 3rd-order terms and MP2 correction [manual]. sapt2+(ccd)dmp2; SAPT2+ with CC-based dispersion and MP2 correction [manual]. sapt2+(3)(ccd)dmp2; SAPT2+(3) with CC-based dispersion and MP2 correction [manual]. sapt2+3(ccd)dmp2; SAPT2+3 with CC-based dispersion and MP2 correction [manual]. sapt0-ct; 0th-order SAPT plus charge transfer (CT) calculation [manual]. sapt2-ct; SAPT2 plus CT [manual]. sapt2+-ct; SAPT2+ plus CT [manual]. sapt2+(3)-ct; SAPT2+(3) plus CT [manual]. sapt2+3-ct; SAPT2+3 plus CT [manual]. sapt2+(ccd)-ct; SAPT2+(CCD) plus CT [manual]. sapt2+(3)(ccd)-ct; SAPT2+(3)(CCD) plus CT [manual]. sapt2+3(ccd)-ct; SAPT2+3(CCD) plus CT [manual]. adc; 2nd-order algebraic diagrammatic construction (ADC) [manual]. eom-cc2; EOM-CC2 [manual]. eom-ccsd; equation of motion (EOM) CCSD [manual]. eom-cc3; EOM-CC3 [manual]. name; calls method DFT [manual]. b1lyp; B1LYP Hyb-GGA Exchange-Correlation Functional. b1lyp-d3bj. b1pw91; B1PW91 Hyb-GGA Exchange-Correlation Functional. b1wc; B1WC Hyb-GGA Exchange-Correlation Functional. b2gpplyp; B2GPPLYP Double Hybrid Exchange-Correlation Functional. b2gpplyp-d3bj. b2gpplyp-nl; B2GPPLYP Double Hybrid Exchange-Correlation Functional. b2plyp; B2PLYP Double Hybrid Exchange-Correlation Functional. b2plyp-d3bj. b2plyp-d3mbj. b2plyp-nl; B2PLYP Double Hybrid Exchange-Correlati",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/api/psi4.driver.energy-1.html:6919,charge,charge,6919,psi4manual/1.4.0/api/psi4.driver.energy-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/api/psi4.driver.energy-1.html,15,['charge'],['charge']
Energy Efficiency,"al exchange scaling [manual]. fisapt0; 0th-order functional and/or intramolecular SAPT [manual]. sapt2; 2nd-order SAPT, traditional definition [manual]. sapt2+; SAPT including all 2nd-order terms [manual]. sapt2+(3); SAPT including perturbative triples [manual]. sapt2+3; SAPT including all 3rd-order terms [manual]. sapt2+(ccd); SAPT2+ with CC-based dispersion [manual]. sapt2+(3)(ccd); SAPT2+(3) with CC-based dispersion [manual]. sapt2+3(ccd); SAPT2+3 with CC-based dispersion [manual]. sapt2+dmp2; SAPT including all 2nd-order terms and MP2 correction [manual]. sapt2+(3)dmp2; SAPT including perturbative triples and MP2 correction [manual]. sapt2+3dmp2; SAPT including all 3rd-order terms and MP2 correction [manual]. sapt2+(ccd)dmp2; SAPT2+ with CC-based dispersion and MP2 correction [manual]. sapt2+(3)(ccd)dmp2; SAPT2+(3) with CC-based dispersion and MP2 correction [manual]. sapt2+3(ccd)dmp2; SAPT2+3 with CC-based dispersion and MP2 correction [manual]. sapt0-ct; 0th-order SAPT plus charge transfer (CT) calculation [manual]. sapt2-ct; SAPT2 plus CT [manual]. sapt2+-ct; SAPT2+ plus CT [manual]. sapt2+(3)-ct; SAPT2+(3) plus CT [manual]. sapt2+3-ct; SAPT2+3 plus CT [manual]. sapt2+(ccd)-ct; SAPT2+(CCD) plus CT [manual]. sapt2+(3)(ccd)-ct; SAPT2+(3)(CCD) plus CT [manual]. sapt2+3(ccd)-ct; SAPT2+3(CCD) plus CT [manual]. adc; 2nd-order algebraic diagrammatic construction (ADC) [manual]. eom-cc2; EOM-CC2 [manual]. eom-ccsd; equation of motion (EOM) CCSD [manual]. eom-cc3; EOM-CC3 [manual]. name; calls method DFT [manual]. b1lyp; B1LYP Hyb-GGA Exchange-Correlation Functional. b1lyp-d3bj;  . b1pw91; B1PW91 Hyb-GGA Exchange-Correlation Functional. b1wc; B1WC Hyb-GGA Exchange-Correlation Functional. b2gpplyp; B2GPPLYP Double Hybrid Exchange-Correlation Functional. b2gpplyp-d3bj;  . b2gpplyp-nl; B2GPPLYP Double Hybrid Exchange-Correlation Functional. b2plyp; B2PLYP Double Hybrid Exchange-Correlation Functional. b2plyp-d3bj;  . b2plyp-d3mbj;  . b2plyp-nl; B2PLYP Double Hybrid Exchan",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/api/psi4.driver.energy-1.html:6504,charge,charge,6504,psi4manual/1.3.2/api/psi4.driver.energy-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/api/psi4.driver.energy-1.html,4,['charge'],['charge']
Energy Efficiency,"al exchange scaling [manual]. fisapt0; 0th-order functional and/or intramolecular SAPT [manual]. sapt2; 2nd-order SAPT, traditional definition [manual]. sapt2+; SAPT including all 2nd-order terms [manual]. sapt2+(3); SAPT including perturbative triples [manual]. sapt2+3; SAPT including all 3rd-order terms [manual]. sapt2+(ccd); SAPT2+ with CC-based dispersion [manual]. sapt2+(3)(ccd); SAPT2+(3) with CC-based dispersion [manual]. sapt2+3(ccd); SAPT2+3 with CC-based dispersion [manual]. sapt2+dmp2; SAPT including all 2nd-order terms and MP2 correction [manual]. sapt2+(3)dmp2; SAPT including perturbative triples and MP2 correction [manual]. sapt2+3dmp2; SAPT including all 3rd-order terms and MP2 correction [manual]. sapt2+(ccd)dmp2; SAPT2+ with CC-based dispersion and MP2 correction [manual]. sapt2+(3)(ccd)dmp2; SAPT2+(3) with CC-based dispersion and MP2 correction [manual]. sapt2+3(ccd)dmp2; SAPT2+3 with CC-based dispersion and MP2 correction [manual]. sapt0-ct; 0th-order SAPT plus charge transfer (CT) calculation [manual]. sapt2-ct; SAPT2 plus CT [manual]. sapt2+-ct; SAPT2+ plus CT [manual]. sapt2+(3)-ct; SAPT2+(3) plus CT [manual]. sapt2+3-ct; SAPT2+3 plus CT [manual]. sapt2+(ccd)-ct; SAPT2+(CCD) plus CT [manual]. sapt2+(3)(ccd)-ct; SAPT2+(3)(CCD) plus CT [manual]. sapt2+3(ccd)-ct; SAPT2+3(CCD) plus CT [manual]. adc; 2nd-order algebraic diagrammatic construction (ADC) [manual]. eom-cc2; EOM-CC2 [manual]. eom-ccsd; equation of motion (EOM) CCSD [manual]. eom-cc3; EOM-CC3 [manual]. name; calls method DFT [manual]. b2plyp; B2PLYP Double Hybrid Exchange-Correlation Functional. b2plyp-d;  . b2plyp-d3;  . b2plyp-d3bj;  . b2plyp-d3m;  . b2plyp-d3mbj;  . b3lyp; B3LYP Hybrid-GGA Exchange-Correlation Functional (VWN1-RPA). b3lyp-d;  . b3lyp-d3;  . b3lyp-d3bj;  . b3lyp-d3m;  . b3lyp-d3mbj;  . b3lyp5; B3LYP5 Hybrid-GGA Exchange-Correlation Functional (VWN5). b3_x; Becke88 GGA Exchange (B3LYP weighting). b86bpbe; B86BPBE GGA Exchange-Correlation Functional. b88_x; Becke88 GGA Exc",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.energy.html:6482,charge,charge,6482,psi4manual/1.1.0/api/psi4.driver.energy.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.energy.html,1,['charge'],['charge']
Energy Efficiency,"al integrals (MP/CC Methods OCC keywords); Non-orbital-optimized MP and CC methods with DF and CD integrals (MP/CC Methods DFOCC keywords). Theory¶; What follows is a very basic description of orbital-optimized Møller–Plesset perturbation; theory as implemented in Psi4. We will follow our previous presentations ([Bozkaya:2011:omp2],; [Bozkaya:2011:omp3], and [Bozkaya:2012:odtl]); The orbital variations may be expressed by means of an exponential unitary operator. where is the orbital rotation operator. The effect of the orbital rotations on the MO coefficients can be written as. where is the initial MO coefficient matrix and is the new; MO coefficient matrix as a function of .; Now, let us define a variational energy functional (Lagrangian) as a function of . OMP2. OMP3. OLCCD. where subscript c means only connected diagrams are allowed, and; , , and defined as. where , and are the one- and two-electron components of normal-ordered Hamiltonian. Then,; first and second derivatives of the energy with respect to the parameter at . Then the energy can be expanded up to second-order as follows. where is the MO gradient vector, is the MO rotation vector,; and is the MO Hessian matrix. Therefore, minimizing the energy with respect to ; yields. This final equation corresponds to the usual Newton-Raphson step.; Publications resulting from the use of the orbital-optimized code should cite the following publications:. OMP2 [Bozkaya:2011:omp2] and [Bozkaya:2013:omp2grad]; OMP3 [Bozkaya:2011:omp3] , [Bozkaya:2013:omp3], and [Bozkaya:2013:omp3grad]; OMP2.5 [Bozkaya:2011:omp3]; OLCCD [Bozkaya:2013:ocepa]; LCCD [Bozkaya:2013:ocepa]. Convergence Problems¶; For problematic open-shell systems, we recommend to use the ROHF or DFT orbitals as an initial guess for orbital-optimized methods. Both ROHF and; DFT orbitals may provide better initial guesses than UHF orbitals, hence convergence may be significantly speeded up with ROHF or DFT orbitals.; In order to use ROHF orbitals we can simp",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/occ-1.html:5024,energy,energy,5024,psi4manual/1.0.0/occ-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/occ-1.html,2,['energy'],['energy']
Energy Efficiency,"al memory. close_outfile(); Closes the output file. dct(ref_wfn); Runs the density cumulant (functional) theory code. del_array_variable(key); Removes the Matrix QCVariable key (case-insensitive); prefer del_variable(). del_scalar_variable(key); Removes the double QCVariable key (case-insensitive); prefer del_variable(). del_variable(key); Removes scalar or array QCVariable key from global memory if present. detci(ref_wfn); Runs the determinant-based configuration interaction code. dfmp2(ref_wfn); Runs the DF-MP2 code. dfocc(ref_wfn); Runs the density-fitted orbital optimized CC codes. dmrg(ref_wfn); Runs the CheMPS2 interface DMRG code. doublet(A, B, transA, transB); Returns the multiplication of two matrices A and B, with options to transpose each beforehand. fcidump_tei_helper(nirrep, restricted, …); Write integrals to file in FCIDUMP format. finalize(); Called upon psi4 module exit to closes timers and I/O. flush_outfile(); Flushes the output file. fnocc(ref_wfn); Runs the FNO-CCSD(T)/QCISD(T)/MP4/CEPA energy code. get_active_molecule(); Returns the currently active molecule object. get_array_variable(key). Deprecated since version 1.4. get_array_variables(). Deprecated since version 1.4. get_atomic_point_charges(). Deprecated since version 1.4. get_datadir(); Returns the path to shared text resources, PSIDATADIR. get_global_option(key); Return keyword key value at global (all-module) scope. get_global_option_list(); Returns a list of all global options. get_gradient(). Deprecated since version 1.2. get_legacy_gradient(); Returns the global gradient as a (nat, 3) Matrix object. get_legacy_molecule(); Returns the currently active legacy molecule object. get_local_option(module, key); Return keyword key value at module scope. get_memory(); Returns the amount of memory available to Psi (in bytes). get_num_threads(); Returns the number of threads to use in SMP parallel computations. get_option(module, key); Return keyword key value used by module. get_options(); Get",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/psi4api-1.html:4888,energy,energy,4888,psi4manual/1.4.0/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/psi4api-1.html,2,['energy'],['energy']
Energy Efficiency,"al optimized geometry and variables:\n'); moleculeclone.print_in_input_format(); # Check if user wants to see the intcos; if so, don't delete them.; if core.get_option('OPTKING', 'INTCOS_GENERATE_EXIT') == False:; if core.get_option('OPTKING', 'KEEP_INTCOS') == False:; core.opt_clean(); # Changing environment to optimized geometry as expected by user; molecule.set_geometry(moleculeclone.geometry()); for postcallback in hooks['optimize']['post']:; postcallback(lowername, wfn=wfn, **kwargs); core.clean(). # S/R: Clean up opt input file; if opt_mode == 'reap':; with open('OPT-master.in', 'wb') as fmaster:; fmaster.write('# This is a psi4 input file auto-generated from the gradient() wrapper.\n\n'.encode('utf-8')); fmaster.write('# Optimization complete!\n\n'.encode('utf-8')). # Cleanup binary file 1; if custom_gradient or ('/' in lowername):; core.IOManager.shared_object().set_specific_retention(1, False). optstash.restore(). if return_history:; history = { 'energy' : step_energies ,; 'gradient' : step_gradients ,; 'coordinates' : step_coordinates,; }. if return_wfn and return_history:; return (thisenergy, wfn, history); elif return_wfn and not return_history:; return (thisenergy, wfn); elif return_history and not return_wfn:; return (thisenergy, history); else:; return thisenergy. elif optking_rval == core.PsiReturnType.Failure:; print('Optimizer: Optimization failed!'); if (core.get_option('OPTKING', 'KEEP_INTCOS') == False):; core.opt_clean(); molecule.set_geometry(moleculeclone.geometry()); core.clean(); optstash.restore(); raise OptimizationConvergenceError(""""""geometry optimization"""""", n - 1, wfn); return thisenergy. core.print_out('\n Structure for next step:\n'); moleculeclone.print_in_input_format(). # S/R: Preserve opt data file for next pass and switch modes to get new displacements; if opt_mode == 'reap':; kwargs['opt_datafile'] = p4util.get_psifile(1); kwargs['mode'] = 'sow'. n += 1. if core.get_option('OPTKING', 'INTCOS_GENERATE_EXIT') == False:; if core.ge",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/driver.html:65110,energy,energy,65110,psi4manual/1.2.1/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/driver.html,1,['energy'],['energy']
Energy Efficiency,"al particle curves. Other gap; fitting techniques involving the electron affinity or band gap are sometimes; also used. IP-fitting is found to be particularly critical for the qualitative; determination of excited state ordering in many low band-gap systems.; For dispersion-bound complexes, a very simple additive empirical dispersion; potential, based on a damped Lennard-Jones potential can often produce; remarkably accurate results with KS-DFT. This approach was championed by Grimme,; whose “-D2” and more modern “-D3” approaches are a de facto industry standards. Minimal Input¶; Minimal input for a KS-DFT computation is a molecule block, basis set; option, and a call to energy('b3lyp') (or other valid functional name):; molecule {; He; }. set basis sto-3g. energy('b3lyp'). This will run a B3LYP Restricted Kohn–Sham (RKS) on neutral singlet Helium in; \(D_{2h}\) spatial symmetry with a minimal STO-3G basis, 1.0E-6 energy; and density convergence criteria, a DF ERI algorithm, symmetric; orthogonalization, DIIS, and a core Hamiltonian guess (because single atom). For more information on; any of these options, see the relevant section below, or in the preceding; Hartree–Fock section. Spin/Symmetry Treatment¶; PSI4 implements the most popular spin specializations of KS-DFT, including:. Restricted Kohn–Sham (RKS) [Default]Appropriate only for closed-shell singlet systems, but twice as efficient; as the other flavors, as the alpha and beta densities are constrained to be; identical. Unrestricted Kohn–Sham (UKS)Appropriate for most open-shell systems and fairly easy to converge.; The spatial parts of the alpha and beta orbitals are fully independent of each; other, which allows a considerable amount of flexibility in the wavefunction.; However, this flexibility comes at the cost of spin symmetry; the resultant; wavefunction may not be an eigenfunction of the \(\hat S^2\) operator.; However, spin contamination is usually less of a problem with UKS than with; UHF, as the spi",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/dft-1.html:13205,energy,energy,13205,psi4manual/1.4.0/dft-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/dft-1.html,9,['energy'],['energy']
Energy Efficiency,"al symmetries. This may result in the; occupation shifting between iterations. If the occupations are known a priori,; they may be clamped throughout the procedure by using the DOCC and; SOCC options. For instance, all good quantum chemists know that; water is; actually,:; molecule h2o {; 0 1; O; H 1 1.0; H 1 1.0 2 104.5; }. set {; docc [3,0,1,1] # 1A1 2A1 1B1 3A1 1B2; basis cc-pvdz; }. energy('scf'). Broken Symmetry¶; For certain problems, such diradicals, allowing the spin-up and spin-down; orbitals to differ in closed-shell computations can be advantageous;; this is known as symmetry breaking. The resulting unrestricted wavefunction; will often provide superior energetics, due to the increased flexibility,; but will suffer non-physicical spin contamination from higher multiplicity states.; A convenient approach to break symmetry is to perform a UHF or UKS calculation; with the guess HOMO and LUMO orbitals mixed.; Mixing of the guess orbitals can be requested by setting the GUESS_MIX; keyword to true:; set reference uhf; set guess_mix true; energy('scf'). Orthogonalization¶; One of the first steps in the SCF procedure is the determination of an; orthogonal basis (known as the OSO basis) from the atomic orbital basis (known; as the AO basis). The Molecular Orbital basis (MO basis) is then built as a; particular unitary transformation of the OSO basis. In Psi4, the; determination of the OSO basis is accomplished via either symmetric or canonical; orthogonalization. Symmetric orthogonalization uses the symmetric inverse square; root of the overlap matrix for the orthogonalization matrix. Use of symmetric; orthogonalization always yields the same number of OSO functions (and thereby; MOs) as AO functions. However, this may lead to numerical problems if the; overlap matrix has small eigenvalues, which may occur for large systems or for; systems where diffuse basis sets are used. This problem may be avoided by using; canonical orthogonalization, in which an asymmetric in",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/scf-1.html:9601,energy,energy,9601,psi4manual/1.0.0/scf-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/scf-1.html,2,['energy'],['energy']
Energy Efficiency,"al, not all the required matrix; elements have been coded for high-spin cases, meaning that results will; correspond to an approximate Mk-MRCC computation for high-spin cases. A Simple Example¶; The CORR_WFN allows you to select one of three methods Mk-MRPT2 [PT2], Mk-MRCCSD [CCSD], or Mk-MRCCSD(T) [CCSD_T]. The CORR_MULTP option allows you to select the Slater determinants with a particular value. The WFN_SYM keyword is neccesary if you do not want to compute the energy of the all-symmetric state. The FOLLOW_ROOT option may be used to follow different roots of the effective Hamiltonian. A value of 1 instructs PSIMRCC to follow the solution with the lowest energy given a certain set of determinants.; molecule o2 {; 0 3; O; O 1 2.265122720724; units au; }; set {; basis cc-pvtz; }; set mcscf {; reference rohf; docc [3,0,0,0,0,2,1,1] # Doubly occupied MOs; socc [0,0,1,1,0,0,0,0] # Singly occupied MOs; }; set psimrcc {; corr_wfn ccsd # Do Mk-MRCCSD; frozen_docc [1,0,0,0,0,1,0,0] # Frozen MOs; restricted_docc [2,0,0,0,0,1,1,1] # Doubly occupied MOs; active [0,0,1,1,0,0,0,0] # Active MOs; frozen_uocc [0,0,0,0,0,0,0,0] # Frozen virtual MOs; corr_multp 1 # Select the Ms = 0 component; root 1; wfn_sym B1g # Select the B1g state; }; energy('psimrcc'). Note that the oxygen molecule has 16 electrons (including core), while; the docc array contains only 7 doubly-occupied orbitals (or 14; electrons). Hence, two more electrons are available to place into; the active space (given by active), which consists of 2 orbitals.; Thus there are two active electrons in two orbitals. In this particular; example, we are using standard ROHF orbitals for the Mk-MRCCSD procedure,; rather than TCSCF orbitals. Nevertheless, with the present code,; these orbitals must be provided through the MCSCF module, as specified in; the; set mcscf section above. Orbital ordering and selection of the model space¶; The reference determinants are specified in PSIMRCC; via occupational numbers. PSIMRCC requires t",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/psimrcc-1.html:4616,energy,energy,4616,psi4manual/4.0b2/psimrcc-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psimrcc-1.html,2,['energy'],['energy']
Energy Efficiency,"al, with Cartesian input. gdma1; Water RHF/cc-pVTZ distributed multipole analysis. cc47; EOM-CCSD/cc-pVDZ on H2O2 with two excited states in each irrep. props2; DF-SCF cc-pVDZ of benzene-hydronium ion, scanning the dissociation coordinate with Python’s built-in loop mechanism. The geometry is specified by a Z-matrix with dummy atoms, fixed parameters, updated parameters, and separate charge/multiplicity specifiers for each monomer. One-electron properties computed for dimer and one monomer. cepa0-grad2; CEPA cc-pVDZ gradient for the NO radical. dcft3; DC-06 calculation for the He dimer. This performs a simultaneous update of the orbitals and cumulant, using DIIS extrapolation. Four-virtual integrals are handled in the AO Basis, using integrals stored on disk. cc2; 6-31G** H2O CCSD optimization by energies, with Z-Matrix input. cc6; Frozen-core CCSD(T)/cc-pVDZ on C4H4N anion with disk ao algorithm. dfomp2p5-grad1; DF-OMP2.5 cc-pVDZ gradients for the H2O molecule. omp2-3; OMP2 cc-pVDZ energy for the NO radical. cc49; EOM-CC3(UHF) on CH radical with user-specified basis and properties for particular root. dcft7; DCFT calculation for the triplet O2 using ODC-06 and ODC-12 functionals. Only simultaneous algorithm is tested. cc48; reproduces dipole moments in J.F. Stanton’s “biorthogonal” JCP paper. pywrap-checkrun-rohf; This checks that all energy methods can run with a minimal input and set symmetry. ci-property; CI/MCSCF cc-pvDZ properties for Potassium nitrate (rocket fuel!). tu4-h2o-freq; Optimization followed by frequencies H2O HF/cc-pVDZ. dcft2; DC-06 calculation for the He dimer. This performs a two-step update of the orbitals and cumulant, using DIIS extrapolation. Four-virtual integrals are handled in the MO Basis. x2c3; Test of SFX2C-1e on Water uncontracted cc-pVDZ The reference numbers are from Lan Cheng’s implementation in Cfour. scf11-freq-from-energies; Test frequencies by finite differences of energies for planar C4NH4 TS. tu3-h2o-opt; Optimize H2O HF/cc-",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_testsuite_corepsi4-1.html:22810,energy,energy,22810,psi4manual/1.0.0/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_testsuite_corepsi4-1.html,4,['energy'],['energy']
Energy Efficiency,"al-optimized linearized coupled cluster doubles level of theory. OMP2 TOTAL ENERGY¶. OMP2 CORRELATION ENERGY¶; The total electronic energy [Eh] and correlation energy component [Eh]; for the orbital-optimized MP2 level of theory. OMP2.5 TOTAL ENERGY¶. OMP2.5 CORRELATION ENERGY¶; The total electronic energy [Eh] and correlation energy component [Eh]; for the orbital-optimized MP2.5 level of theory. OMP3 TOTAL ENERGY¶. OMP3 CORRELATION ENERGY¶; The total electronic energy [Eh] and correlation energy component [Eh]; for the orbital-optimized MP3 level of theory. ONE-ELECTRON ENERGY¶; The one-electron energy contribution [Eh] to the total SCF energy.; Quantity \(E_{1e^-}\) in Eq. (4). PCM POLARIZATION ENERGY¶; The energy contribution [Eh] from the polarizable continuum model for solvation. PE ENERGY¶; The energy contribution [Eh] from the polarizable embedding model for solvation. QCISD TOTAL ENERGY¶. QCISD CORRELATION ENERGY¶; The total electronic energy [Eh] and correlation energy component [Eh]; for the quadratic configuration interaction singles and doubles level; of theory. QCISD(T) TOTAL ENERGY¶. QCISD(T) CORRELATION ENERGY¶; The total electronic energy [Eh] and correlation energy component [Eh]; for the quadratic configuration interaction singles and doubles with; perturbative triples correction level of theory. SAPT DISP ENERGY¶. SAPT ELST ENERGY¶. SAPT EXCH ENERGY¶. SAPT IND ENERGY¶; Respectively, the dispersion, electrostatics, exchange, and induction; components of the total electronic interaction energy [Eh] for the; requested SAPT level of theory. The sum of these four components yields; SAPT TOTAL ENERGY. SAPT TOTAL ENERGY¶. SAPT ENERGY¶; The total electronic interaction energy [Eh] for the requested SAPT; level of theory. SAPT ELST10,R ENERGY¶; An electrostatics-classified SAPT term energy [Eh] implemented for SAPT0. SAPT ELST EXTERN-EXTERN ENERGY¶; Electrostatic interaction [Eh] between the point charges in fragments; A and B in F/I-SAPT. SAPT EXCH10 ENER",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/glossary_psivariables-1.html:34493,energy,energy,34493,psi4manual/1.4.0/glossary_psivariables-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/glossary_psivariables-1.html,10,['energy'],['energy']
Energy Efficiency,"al. JCP 135 194102 (2011). cp 'off' || 'on'; rlxd 'off'; benchmark; 'S220' Jurecka et al. PCCP 8 1985 (2006).; 'S22A' Takatani et al. JCP 132 144104 (2010).; 'S22B' Marshall et al. JCP 135 194102 (2011). subset; 'small' water dimer, methane dimer, ethene-ethine; 'large' adenine-thymine; 'HB' hydrogen-bonded systems; 'MX' mixed-influence systems; 'DD' dispersion-dominated systems; 'S11' smaller systems in S22; 'WATER' water dimer. HTBH¶. Database (Truhlar) of hydrogen-transfer barrier height reactions.; Geometries from Truhlar and coworkers at site http://t1.chem.umn.edu/misc/database_group/database_therm_bh/raw_geom.cgi .; Reference energies from Zhao et al. JPCA, 109 2012-2018 (2005) doi: 10.1021/jp045141s [in supporting information]. cp 'off'; rlxd 'off'; subset; 'small'; 'large'. NCB31¶. Database (Truhlar) of several classes of noncovalent interactions.; Geometries from Truhlar and coworkers at site http://comp.chem.umn.edu/database_noncov/noncovalent.htm; Reference energies from Truhlar and coworkers at site http://comp.chem.umn.edu/database_noncov/noncovalent.htm; First comprehensive citation JPCA 109 5656 (2005). . cp 'off' || 'on'; rlxd 'off' || 'on'; benchmark; '<benchmark_name>' <Reference>.; '<default_benchmark_name>' <Reference>. subset; 'small' 3: HF-HF, He-Ne, HCCH-HCCH; 'large' 1: BzBz_PD; 'HB6' hydrogen-bonded; 'CT7' charge-transfer; 'DI6' dipole-interacting; 'WI7' weakly interacting; 'PPS5' pi-pi stacking. Table Of Contents. BAKERJCC96; ACENES; NBC10; A24; S22by5; BENCH12; RSE42; BAKERJCC93; HTR40; RGC10; S66; CORE; BASIC; NHTBH; HBC6; HSG; JSCH; S22; HTBH; NCB31. Previous topic; Database; Next topic; Complete Basis Set; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta5] » ; Psithon Functions: Invoking a Calculation »; Database ». © Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/autodoc_available_databases-1.html:9985,charge,charge-transfer,9985,psi4manual/4.0b5/autodoc_available_databases-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodoc_available_databases-1.html,2,['charge'],['charge-transfer']
Energy Efficiency,"al. name; calls method in Stanton and Gauss’s CFOUR program [manual]. c4-scf; Hartree–Fock (HF). c4-mp2; 2nd-order Møller–Plesset perturbation theory (non-density-fitting) (MP2). c4-mp3; 3rd-order Møller–Plesset perturbation theory (MP3). c4-mp4(sdq); 4th-order MP perturbation theory (MP4) less triples. c4-mp4; full MP4. c4-cc2; approximate coupled cluster singles and doubles (CC2). c4-ccsd; coupled cluster singles and doubles (CCSD). c4-cc3; approximate CC singles, doubles, and triples (CC3). c4-ccsd(t); CCSD with perturbative triples (CCSD(T)). c4-ccsdt; coupled cluster singles, doubles, and triples (CCSDT). cfour; expert full control over cfour program. Examples. >>> # [1] Analytic hf optimization; >>> optimize('hf'). >>> # [2] Finite difference mp5 optimization with gradient; >>> # printed to output file; >>> e, wfn = opt('mp5', return_wfn='yes'); >>> wfn.gradient().print_out(). >>> # [3] Can automatically perform complete basis set extrapolations; >>> optimize('MP2/cc-pV([D,T]+d)Z'). >>> # [4] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> optimize(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). >>> # [5] Get info like geometry, gradient, energy back after an; >>> # optimization fails. Note that the energy and gradient; >>> # correspond to the last optimization cycle, whereas the; >>> # geometry (by default) is the anticipated *next* optimization step.; >>> try:; >>> optimize('hf/cc-pvtz'); >>> except psi4.OptimizationConvergenceError as ex:; >>> next_geom_coords_as_numpy_array = np.asarray(ex.wfn.molecule().geometry()). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. PSI4 API: Linking C++ and Python; opt. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/api/psi4.driver.opt-1.html:13428,energy,energy,13428,psi4manual/1.4.0/api/psi4.driver.opt-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/api/psi4.driver.opt-1.html,8,['energy'],['energy']
Energy Efficiency,"al. name; calls method in Stanton and Gauss’s CFOUR program [manual]. c4-scf; Hartree–Fock (HF). c4-mp2; 2nd-order Møller–Plesset perturbation theory (non-density-fitting) (MP2). c4-mp3; 3rd-order Møller–Plesset perturbation theory (MP3). c4-mp4(sdq); 4th-order MP perturbation theory (MP4) less triples. c4-mp4; full MP4. c4-cc2; approximate coupled cluster singles and doubles (CC2). c4-ccsd; coupled cluster singles and doubles (CCSD). c4-cc3; approximate CC singles, doubles, and triples (CC3). c4-ccsd(t); CCSD with perturbative triples (CCSD(T)). c4-ccsdt; coupled cluster singles, doubles, and triples (CCSDT). cfour; expert full control over cfour program. Examples. >>> # [1] Analytic hf optimization; >>> optimize('hf'). >>> # [2] Finite difference mp5 optimization with gradient; >>> # printed to output file; >>> e, wfn = opt('mp5', return_wfn='yes'); >>> wfn.gradient().print_out(). >>> # [3] Can automatically perform complete basis set extrapolations; >>> optimize('MP2/cc-pV([D,T]+d)Z'). >>> # [4] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> optimize(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). >>> # [5] Get info like geometry, gradient, energy back after an; >>> # optimization fails. Note that the energy and gradient; >>> # correspond to the last optimization cycle, whereas the; >>> # geometry (by default) is the anticipated *next* optimization step.; >>> try:; >>> optimize('hf/cc-pvtz'); >>> except psi4.OptimizationConvergenceError as ex:; >>> next_geom_coords_as_numpy_array = np.asarray(ex.wfn.molecule().geometry()). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.5;  · . PSI4. PSI4 API: Linking C++ and Python; opt. © Copyright 2021, The Psi4 Project.; Last updated on Sunday, 28 November 2021 02:41AM.; Created using Sphinx 4.3.1.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/api/psi4.driver.opt-1.html:13428,energy,energy,13428,psi4manual/1.5.0/api/psi4.driver.opt-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/api/psi4.driver.opt-1.html,8,['energy'],['energy']
Energy Efficiency,"al]. adc; 2nd-order algebraic diagrammatic construction (ADC) [manual]. eom-cc2; EOM-CC2 [manual]. eom-ccsd; equation of motion (EOM) CCSD [manual]. eom-cc3; EOM-CC3 [manual]. Examples:. 1; 2>>> # [1] Coupled-cluster singles and doubles calculation with psi code; >>> energy('ccsd'). 1; 2; 3; 4; 5>>> # [2] Charge-transfer SAPT calculation with scf projection from small into; >>> # requested basis, with specified projection fitting basis; >>> set basis_guess true; >>> set df_basis_guess jun-cc-pVDZ-JKFIT; >>> energy('sapt0-ct'). 1; 2>>> # [3] Arbitrary-order MPn calculation; >>> energy('mp7'). 1; 2; 3; 4; 5; 6; 7; 8; 9>>> # [4] Converge scf as singlet, then run detci as triplet upon singlet reference; >>> # Note that the integral transformation is not done automatically when detci is run in a separate step.; >>> molecule H2 {\n0 1\nH\nH 1 0.74\n}; >>> set basis cc-pVDZ; >>> set reference rohf; >>> scf_e, scf_wfn = energy('scf', return_wfn=True); >>> H2.set_multiplicity(3); >>> core.MintsHelper(scf_wfn.basisset()).integrals(); >>> energy('detci', ref_wfn=scf_wfn). 1; 2; 3; 4; 5>>> # [5] Run two CI calculations, keeping the integrals generated in the first one.; >>> molecule ne {\nNe\n}; >>> set basis cc-pVDZ; >>> cisd_e, cisd_wfn = energy('cisd', return_wfn=True); >>> energy('fci', ref_wfn=cisd_wfn). 1; 2>>> # [6] Can automatically perform complete basis set extrapolations; >>> energy(""CCSD/cc-pV[DT]Z""). 1; 2; 3; 4>>> # [7] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> energy(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Psithon Functions: Invoking a Calculation. © Copyright 2018, The Psi4 Project.; Last updated on Wednesday, 25 July 2018 04:21AM.; Created using Sphinx 1.7.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/energy-1.html:8085,energy,energy,8085,psi4manual/1.2.1/energy-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/energy-1.html,10,['energy'],['energy']
Energy Efficiency,"al]. sapt2+(3)dmp2; SAPT including perturbative triples and MP2 correction [manual]. sapt2+3dmp2; SAPT including all 3rd-order terms and MP2 correction [manual]. sapt2+(ccd)dmp2; SAPT2+ with CC-based dispersion and MP2 correction [manual]. sapt2+(3)(ccd)dmp2; SAPT2+(3) with CC-based dispersion and MP2 correction [manual]. sapt2+3(ccd)dmp2; SAPT2+3 with CC-based dispersion and MP2 correction [manual]. sapt0-ct; 0th-order SAPT plus charge transfer (CT) calculation [manual]. sapt2-ct; SAPT2 plus CT [manual]. sapt2+-ct; SAPT2+ plus CT [manual]. sapt2+(3)-ct; SAPT2+(3) plus CT [manual]. sapt2+3-ct; SAPT2+3 plus CT [manual]. sapt2+(ccd)-ct; SAPT2+(CCD) plus CT [manual]. sapt2+(3)(ccd)-ct; SAPT2+(3)(CCD) plus CT [manual]. sapt2+3(ccd)-ct; SAPT2+3(CCD) plus CT [manual]. adc; 2nd-order algebraic diagrammatic construction (ADC) [manual]. eom-cc2; EOM-CC2 [manual]. eom-ccsd; equation of motion (EOM) CCSD [manual]. eom-cc3; EOM-CC3 [manual]. Examples:. >>> # [1] Coupled-cluster singles and doubles calculation with psi code; >>> energy('ccsd'). >>> # [2] Charge-transfer SAPT calculation with scf projection from small into; >>> # requested basis, with specified projection fitting basis; >>> set basis_guess true; >>> set df_basis_guess jun-cc-pVDZ-JKFIT; >>> energy('sapt0-ct'). >>> # [3] Arbitrary-order MPn calculation; >>> energy('mp7'). >>> # [4] Converge scf as singlet, then run detci as triplet upon singlet reference; >>> # Note that the integral transformation is not done automatically when detci is run in a separate step.; >>> molecule H2 {\n0 1\nH\nH 1 0.74\n}; >>> set basis cc-pVDZ; >>> set reference rohf; >>> scf_e, scf_wfn = energy('scf', return_wfn=True); >>> H2.set_multiplicity(3); >>> core.MintsHelper(scf_wfn.basisset()).integrals(); >>> energy('detci', ref_wfn=scf_wfn). >>> # [5] Run two CI calculations, keeping the integrals generated in the first one.; >>> molecule ne {\nNe\n}; >>> set basis cc-pVDZ; >>> cisd_e, cisd_wfn = energy('cisd', return_wfn=True); >>> energy",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/energy-1.html:7305,energy,energy,7305,psi4manual/1.3.2/energy-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/energy-1.html,2,['energy'],['energy']
Energy Efficiency,"al_disp = True if '-d' in name.lower() else False. if do_empirical_disp:; ## Make sure we are turning SAPT0 dispersion off; core.set_local_option('SAPT', 'SAPT0_E10', True); core.set_local_option('SAPT', 'SAPT0_E20IND', True); core.set_local_option('SAPT', 'SAPT0_E20Disp', False). ri = core.get_global_option('SCF_TYPE'); df_ints_io = core.get_option('SCF', 'DF_INTS_IO'); # inquire if above at all applies to dfmp2. core.IO.set_default_namespace('dimer'); core.print_out('\n'); p4util.banner('Dimer HF'); core.print_out('\n'). # Compute dimer wavefunction. if (sapt_basis == 'dimer') and (ri == 'DF'):; core.set_global_option('DF_INTS_IO', 'SAVE'). optstash2 = p4util.OptionsState(['NUM_FROZEN_DOCC']); core.set_global_option(""NUM_FROZEN_DOCC"", nfc_ab); core.timer_on(""SAPT: Dimer SCF""); dimer_wfn = scf_helper('RHF', molecule=sapt_dimer, **kwargs); core.timer_off(""SAPT: Dimer SCF""). if do_delta_mp2:; select_mp2(""mp2"", ref_wfn=dimer_wfn, **kwargs); mp2_corl_interaction_e = core.variable('MP2 CORRELATION ENERGY'). optstash2.restore(); if (sapt_basis == 'dimer') and (ri == 'DF'):; core.set_global_option('DF_INTS_IO', 'LOAD'). # Compute Monomer A wavefunction; if (sapt_basis == 'dimer') and (ri == 'DF'):; core.IO.change_file_namespace(97, 'dimer', 'monomerA'). core.IO.set_default_namespace('monomerA'); core.print_out('\n'); p4util.banner('Monomer A HF'); core.print_out('\n'). core.timer_on(""SAPT: Monomer A SCF""); monomerA_wfn = scf_helper('RHF', molecule=monomerA, **kwargs); core.timer_off(""SAPT: Monomer A SCF""). if do_delta_mp2:; select_mp2(""mp2"", ref_wfn=monomerA_wfn, **kwargs); mp2_corl_interaction_e -= core.variable('MP2 CORRELATION ENERGY'). # Compute Monomer B wavefunction; if (sapt_basis == 'dimer') and (ri == 'DF'):; core.IO.change_file_namespace(97, 'monomerA', 'monomerB'); core.IO.set_default_namespace('monomerB'); core.print_out('\n'); p4util.banner('Monomer B HF'); core.print_out('\n'). core.timer_on(""SAPT: Monomer B SCF""); monomerB_wfn = scf_helper('RHF', molecule=mo",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:147748,ENERGY,ENERGY,147748,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,2,['ENERGY'],['ENERGY']
Energy Efficiency,"al_option(""BASIS"", basis). ## Second half of this fn -- entry means program running exactly analytic property. # Commit to procedures['properties'] call hereafter; core.clean_variables(). # needed (+restore below) so long as AtomicComputer-s aren't run through json (where convcrit also lives); optstash = driver_util.negotiate_convergence_criterion((""prop"", ""prop""), lowername, return_optstash=True). logger.info(f""Compute properties(): method={lowername}, basis={core.get_global_option('BASIS').lower()}, molecule={molecule.name()}, nre={'w/EFP' if hasattr(molecule, 'EFP') else molecule.nuclear_repulsion_energy()}""); logger.debug(""w/EFP"" if hasattr(molecule, ""EFP"") else pp.pformat(molecule.to_dict())); wfn = procedures[""properties""][lowername](lowername, molecule=molecule, **kwargs); logger.info(f""Return properties(): {core.variable('CURRENT ENERGY')}""). basisstash.restore(); optstash.restore(). if return_wfn:; return (core.variable('CURRENT ENERGY'), wfn); else:; return core.variable('CURRENT ENERGY'). [docs]; def optimize_geometric(name, **kwargs):. import qcelemental as qcel; from qcelemental.util import which_import. if not which_import('geometric', return_bool=True):; raise ModuleNotFoundError('Python module geometric not found. Solve by installing it: `conda install -c conda-forge geometric` or `pip install geometric`'); import geometric. class Psi4NativeEngine(geometric.engine.Engine):; """"""; Internally run an energy and gradient calculation for geometric ; """"""; def __init__(self, p4_name, p4_mol, p4_return_wfn, **p4_kwargs):; ; self.p4_name = p4_name; self.p4_mol = p4_mol; self.p4_return_wfn = p4_return_wfn; self.p4_kwargs = p4_kwargs; ; molecule = geometric.molecule.Molecule(); molecule.elem = [p4_mol.symbol(i).capitalize() for i in range(p4_mol.natom())]; # beware if geomeTRIC and psi4 choose different sets of constants; molecule.xyzs = [p4_mol.geometry().np * constants.bohr2angstroms]; molecule.build_bonds(); ; super(Psi4NativeEngine, self).__init__(molecule); ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/driver.html:54006,ENERGY,ENERGY,54006,psi4manual/1.9.x/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/driver.html,2,['ENERGY'],['ENERGY']
Energy Efficiency,"al_option(""BASIS"", basis). ## Second half of this fn -- entry means program running exactly analytic property. # Commit to procedures['properties'] call hereafter; core.clean_variables(). # needed (+restore below) so long as AtomicComputer-s aren't run through json (where convcrit also lives); optstash = driver_util.negotiate_convergence_criterion((""prop"", ""prop""), lowername, return_optstash=True). logger.info(f""Compute properties(): method={lowername}, basis={core.get_global_option('BASIS').lower()}, molecule={molecule.name()}, nre={'w/EFP' if hasattr(molecule, 'EFP') else molecule.nuclear_repulsion_energy()}""); logger.debug(""w/EFP"" if hasattr(molecule, ""EFP"") else pp.pformat(molecule.to_dict())); wfn = procedures[""properties""][lowername](lowername, molecule=molecule, **kwargs); logger.info(f""Return properties(): {core.variable('CURRENT ENERGY')}""). basisstash.restore(); optstash.restore(). if return_wfn:; return (core.variable('CURRENT ENERGY'), wfn); else:; return core.variable('CURRENT ENERGY'). [docs]; def optimize_geometric(name, **kwargs):. import qcelemental as qcel; from qcelemental.util import which_import. if not which_import('geometric', return_bool=True):; raise ModuleNotFoundError('Python module geometric not found. Solve by installing it: `conda install -c conda-forge geometric` or `pip install geometric`'); import geometric. class Psi4NativeEngine(geometric.engine.Engine):; """"""; Internally run an energy and gradient calculation for geometric ; """"""; def __init__(self, p4_name, p4_mol, p4_return_wfn, **p4_kwargs):; ; self.p4_name = p4_name; self.p4_mol = p4_mol; self.p4_return_wfn = p4_return_wfn; self.p4_kwargs = p4_kwargs; ; molecule = geometric.molecule.Molecule(); molecule.elem = [p4_mol.symbol(i).capitalize() for i in range(p4_mol.natom())]; molecule.xyzs = [p4_mol.geometry().np * qcel.constants.bohr2angstroms] ; molecule.build_bonds(); ; super(Psi4NativeEngine, self).__init__(molecule); ; def calc(self, coords, dirname, read_data=False):; self.p4_",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html:53439,ENERGY,ENERGY,53439,psi4manual/1.8.x/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html,1,['ENERGY'],['ENERGY']
Energy Efficiency,"al_option(""BASIS"", basis). ## Second half of this fn -- entry means program running exactly analytic property. # Commit to procedures['properties'] call hereafter; core.clean_variables(). # needed (+restore below) so long as AtomicComputer-s aren't run through json (where convcrit also lives); optstash = driver_util.negotiate_convergence_criterion((""prop"", ""prop""), lowername, return_optstash=True). logger.info(f""Compute properties(): method={lowername}, basis={core.get_global_option('BASIS').lower()}, molecule={molecule.name()}, nre={'w/EFP' if hasattr(molecule, 'EFP') else molecule.nuclear_repulsion_energy()}""); logger.debug(""w/EFP"" if hasattr(molecule, ""EFP"") else pp.pformat(molecule.to_dict())); wfn = procedures[""properties""][lowername](lowername, molecule=molecule, **kwargs); logger.info(f""Return properties(): {core.variable('CURRENT ENERGY')}""). basisstash.restore(); optstash.restore(). if return_wfn:; return (core.variable('CURRENT ENERGY'), wfn); else:; return core.variable('CURRENT ENERGY'). [docs]def optimize_geometric(name, **kwargs):. import qcelemental as qcel; from qcelemental.util import which_import. if not which_import('geometric', return_bool=True):; raise ModuleNotFoundError('Python module geometric not found. Solve by installing it: `conda install -c conda-forge geometric` or `pip install geometric`'); import geometric. class Psi4NativeEngine(geometric.engine.Engine):; """"""; Internally run an energy and gradient calculation for geometric ; """"""; def __init__(self, p4_name, p4_mol, p4_return_wfn, **p4_kwargs):; ; self.p4_name = p4_name; self.p4_mol = p4_mol; self.p4_return_wfn = p4_return_wfn; self.p4_kwargs = p4_kwargs; ; molecule = geometric.molecule.Molecule(); molecule.elem = [p4_mol.symbol(i) for i in range(p4_mol.natom())]; molecule.xyzs = [p4_mol.geometry().np * qcel.constants.bohr2angstroms] ; molecule.build_bonds(); ; super(Psi4NativeEngine, self).__init__(molecule); ; def calc(self, coords, dirname):; self.p4_mol.set_geometry(core.Matrix.fro",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver.html:46906,ENERGY,ENERGY,46906,psi4manual/1.6.x/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver.html,1,['ENERGY'],['ENERGY']
Energy Efficiency,"al_option(""BASIS"", basis). ## Second half of this fn -- entry means program running exactly analytic property. # Commit to procedures['properties'] call hereafter; core.clean_variables(). # needed (+restore below) so long as AtomicComputer-s aren't run through json (where convcrit also lives); optstash = driver_util.negotiate_convergence_criterion((""prop"", ""prop""), lowername, return_optstash=True). logger.info(f""Compute properties(): method={lowername}, basis={core.get_global_option('BASIS').lower()}, molecule={molecule.name()}, nre={'w/EFP' if hasattr(molecule, 'EFP') else molecule.nuclear_repulsion_energy()}""); logger.debug(""w/EFP"" if hasattr(molecule, ""EFP"") else pp.pformat(molecule.to_dict())); wfn = procedures[""properties""][lowername](lowername, molecule=molecule, **kwargs); logger.info(f""Return properties(): {core.variable('CURRENT ENERGY')}""). basisstash.restore(); optstash.restore(). if return_wfn:; return (core.variable('CURRENT ENERGY'), wfn); else:; return core.variable('CURRENT ENERGY'). [docs]def optimize_geometric(name, **kwargs):. import qcelemental as qcel; from qcelemental.util import which_import. if not which_import('geometric', return_bool=True):; raise ModuleNotFoundError('Python module geometric not found. Solve by installing it: `conda install -c conda-forge geometric` or `pip install geometric`'); import geometric. class Psi4NativeEngine(geometric.engine.Engine):; """"""; Internally run an energy and gradient calculation for geometric ; """"""; def __init__(self, p4_name, p4_mol, p4_return_wfn, **p4_kwargs):; ; self.p4_name = p4_name; self.p4_mol = p4_mol; self.p4_return_wfn = p4_return_wfn; self.p4_kwargs = p4_kwargs; ; molecule = geometric.molecule.Molecule(); molecule.elem = [p4_mol.symbol(i) for i in range(p4_mol.natom())]; molecule.xyzs = [p4_mol.geometry().np * qcel.constants.bohr2angstroms] ; molecule.build_bonds(); ; super(Psi4NativeEngine, self).__init__(molecule); ; def calc(self, coords, dirname, read_data=False):; self.p4_mol.set_geometr",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver.html:53431,ENERGY,ENERGY,53431,psi4manual/1.7.x/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver.html,1,['ENERGY'],['ENERGY']
Energy Efficiency,"al_option('SAPT', 'SAPT_LEVEL', 'SAPT2+'); elif (name.lower() == 'sapt2+(3)'):; PsiMod.set_local_option('SAPT', 'SAPT_LEVEL', 'SAPT2+3'); PsiMod.set_local_option('SAPT', 'DO_THIRD_ORDER', False); elif (name.lower() == 'sapt2+3'):; PsiMod.set_local_option('SAPT', 'SAPT_LEVEL', 'SAPT2+3'); PsiMod.set_local_option('SAPT', 'DO_THIRD_ORDER', True). # if the df_basis_sapt basis is not set, pick a sensible one.; if PsiMod.get_global_option('DF_BASIS_SAPT') == '':; ribasis = corresponding_rifit(PsiMod.get_global_option('BASIS')); if ribasis:; PsiMod.set_global_option('DF_BASIS_SAPT', ribasis); PsiMod.print_out('No DF_BASIS_SAPT auxiliary basis selected, defaulting to %s\n' % (ribasis)); else:; raise ValidationError('Keyword DF_BASIS_SAPT is required.'). PsiMod.print_out('\n'); banner(name.upper()); PsiMod.print_out('\n'); e_sapt = PsiMod.sapt(). molecule.reset_point_group(user_pg); molecule.update_geometry(). return e_sapt. [docs]def run_sapt_ct(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a charge-transfer SAPT calcuation of any level. """"""; molecule = PsiMod.get_active_molecule(); user_pg = molecule.schoenflies_symbol(); molecule.reset_point_group('c1'); molecule.fix_orientation(True); molecule.update_geometry(). nfrag = molecule.nfragments(); if nfrag != 2:; raise ValidationError('SAPT requires active molecule to have 2 fragments, not %s.' % (nfrag)). monomerA = molecule.extract_subsets(1, 2); monomerA.set_name('monomerA'); monomerB = molecule.extract_subsets(2, 1); monomerB.set_name('monomerB'); molecule.update_geometry(); monomerAm = molecule.extract_subsets(1); monomerAm.set_name('monomerAm'); monomerBm = molecule.extract_subsets(2); monomerBm.set_name('monomerBm'). ri = PsiMod.get_option('SCF', 'SCF_TYPE'); df_ints_io = PsiMod.get_option('SCF', 'DF_INTS_IO'); # inquire if above at all applies to dfmp2. PsiMod.IO.set_default_namespace('dimer'); PsiMod.set_local_option('SCF', 'SAPT', '2-dimer'); PsiMod.print_out('\n'); banner('Dimer HF'); PsiM",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/_modules/proc.html:36227,charge,charge-transfer,36227,psi4manual/4.0b3/_modules/proc.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/_modules/proc.html,2,['charge'],['charge-transfer']
Energy Efficiency,"al_option_python. ## QCvar helps. _qcvar_transitions = {; ""SCSN-MP2 CORRELATION ENERGY"": ""SCS(N)-MP2 CORRELATION ENERGY"",; ""SCSN-MP2 TOTAL ENERGY"": ""SCS(N)-MP2 TOTAL ENERGY"",; ""MAYER_INDICES"": ""MAYER INDICES"",; ""WIBERG_LOWDIN_INDICES"": ""WIBERG LOWDIN INDICES"",; ""LOWDIN_CHARGES"": ""LOWDIN CHARGES"",; ""MULLIKEN_CHARGES"": ""MULLIKEN CHARGES"",; ""(AT) CORRECTION ENERGY"": ""A-(T) CORRECTION ENERGY"",; ""CCSD(AT) TOTAL ENERGY"": ""A-CCSD(T) TOTAL ENERGY"",; ""CCSD(AT) CORRELATION ENERGY"": ""A-CCSD(T) CORRELATION ENERGY"",; }. _qcvar_cancellations = {; ""SCSN-MP2 SAME-SPIN CORRELATION ENERGY"": [""MP2 SAME-SPIN CORRELATION ENERGY""],; ""SCSN-MP2 OPPOSITE-SPIN CORRELATION ENERGY"": [""MP2 OPPOSITE-SPIN CORRELATION ENERGY""],; ""SCS-CCSD SAME-SPIN CORRELATION ENERGY"": [""CCSD SAME-SPIN CORRELATION ENERGY""],; ""SCS-CCSD OPPOSITE-SPIN CORRELATION ENERGY"": [""CCSD OPPOSITE-SPIN CORRELATION ENERGY""],; ""SCS-MP2 SAME-SPIN CORRELATION ENERGY"": [""MP2 SAME-SPIN CORRELATION ENERGY""],; ""SCS-MP2 OPPOSITE-SPIN CORRELATION ENERGY"": [""MP2 OPPOSITE-SPIN CORRELATION ENERGY""],; ""SCS(N)-OMP2 CORRELATION ENERGY"": [""OMP2 SAME-SPIN CORRELATION ENERGY"", ""OMP2 OPPOSITE-SPIN CORRELATION ENERGY""],; ""SCS(N)-OMP2 TOTAL ENERGY"": [""OMP2 SAME-SPIN CORRELATION ENERGY"", ""OMP2 OPPOSITE-SPIN CORRELATION ENERGY""],; ""SCSN-OMP2 CORRELATION ENERGY"": [""OMP2 SAME-SPIN CORRELATION ENERGY"", ""OMP2 OPPOSITE-SPIN CORRELATION ENERGY""],; ""SCSN-OMP2 TOTAL ENERGY"": [""OMP2 SAME-SPIN CORRELATION ENERGY"", ""OMP2 OPPOSITE-SPIN CORRELATION ENERGY""],; }. def _qcvar_warnings(key: str) -> str:; if any([key.upper().endswith("" DIPOLE "" + cart) for cart in [""X"", ""Y"", ""Z""]]):; warnings.warn(; f""Using scalar QCVariable `{key.upper()}` [D] instead of array `{key.upper()[:-2]}` [e a0] is deprecated, and in 1.5 it will stop working\n"",; category=FutureWarning,; stacklevel=3). if any([key.upper().endswith("" QUADRUPOLE "" + cart) for cart in [""XX"", ""YY"", ""ZZ"", ""XY"", ""XZ"", ""YZ""]]):; warnings.warn(; f""Using scalar QCVariable `{key.upper()}` [D A] instead of array `{key.u",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html:18987,ENERGY,ENERGY,18987,psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html,48,['ENERGY'],['ENERGY']
Energy Efficiency,"alculation. felst(self); F-SAPT0 electrostatics. fexch(self); F-SAPT0 exchange. find(self); F-SAPT0 induction. flocalize(self); F-SAPT0 localize. freeze_core(self); Freeze the core orbitals. ind(self); SAPT0 induction. kinetic(self); Build the kinetic integrals T. localize(self); Localize the active occupied orbitals via IBO2. matrices(self); Return the interally computed matrices (not copied). molecule(self); Returns the FISAPT’s molecule. nuclear(self); Build the nuclear potentials V and interaction energies. overlap(self); Build the overlap integrals S. partition(self); Partition the nuclei and electrons. plot(); Filesystem wrapper for FISAPT::plot. print_header(self); Print header, bases, sizes, etc. print_trailer(self); Print SAPT results. raw_plot(self, arg0); Plot some analysis files. scalars(self); Return the interally computed scalars (not copied). scf(self); Solve the relaxed SCF equations for A0 and B0. sinf_disp(self, arg0, psi4.core.Matrix], …); Computes the MP2-based DispE20 and Exch-DispE20 energy without S^2. unify(self); Produce unified matrices for A’, B’, and C’. vectors(self); Return the interally computed vectors (not copied). Methods Documentation. compute_energy(external_potentials=None)¶; Computes the FSAPT energy. FISAPT::compute_energy. coulomb(self: psi4.core.FISAPT) → None¶; Build the J/K potentials for C, D, and E. dHF(self: psi4.core.FISAPT) → None¶; SAPT0 delta HF. disp(self: psi4.core.FISAPT, arg0: Dict[str, psi4.core.Matrix], arg1: Dict[str, psi4.core.Vector], arg2: bool) → None¶; Computes the MP2-based DispE20 and Exch-DispE20 energy. elst(self: psi4.core.FISAPT) → None¶; SAPT0 electrostatics. exch(self: psi4.core.FISAPT) → None¶; SAPT0 exchange. fdisp(self: psi4.core.FISAPT) → None¶; F-SAPT0 dispersion. fdrop(external_potentials=None)¶; Drop output files from FSAPT calculation. FISAPT::fdrop. felst(self: psi4.core.FISAPT) → None¶; F-SAPT0 electrostatics. fexch(self: psi4.core.FISAPT) → None¶; F-SAPT0 exchange. find(self: psi4.core.",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/api/psi4.core.fisapt.html:1672,energy,energy,1672,psi4manual/1.4.0/api/psi4.core.fisapt.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/api/psi4.core.fisapt.html,1,['energy'],['energy']
Energy Efficiency,"alculation; >>> energy('mp7'). >>> # [4] Converge scf as singlet, then run detci as triplet upon singlet reference; >>> # Note that the integral transformation is not done automatically when detci is run in a separate step.; >>> molecule H2 {\n0 1\nH\nH 1 0.74\n}; >>> set global basis cc-pVDZ; >>> set global reference rohf; >>> scf_e, scf_wfn = energy('scf', return_wfn = True); >>> H2.set_multiplicity(3); >>> psi4.MintsHelper(scf_wfn.basisset()).integrals(); >>> energy('detci', ref_wfn=scf_wfn). >>> # [5] Run two CI calculations, keeping the integrals generated in the first one.; >>> molecule ne {\nNe\n}; >>> set globals basis cc-pVDZ; >>> cisd_e, cisd_wfn = energy('cisd', return_wfn = True); >>> energy('fci', ref_wfn=cisd_wfn). >>> # [6] Can automatically perform complete basis set extrapolations; >>> energy(""MP2/cc-pV[DT]Z""). """"""; kwargs = p4util.kwargs_lower(kwargs). # Bounce if name is function; if hasattr(name, '__call__'):; return name(energy, kwargs.pop('label', 'custom function'), ptype='energy', **kwargs). # Allow specification of methods to arbitrary order; lowername = name.lower(); lowername, level = driver_util.parse_arbitrary_order(lowername); if level:; kwargs['level'] = level. # Bounce to CP if bsse kwarg; if kwargs.get('bsse_type', None) is not None:; return driver_nbody._nbody_gufunc(energy, name, ptype='energy', **kwargs). # Bounce to CBS if ""method/basis"" name; if ""/"" in lowername:; return driver_cbs._cbs_gufunc(energy, name, ptype='energy', **kwargs). # Commit to procedures['energy'] call hereafter; return_wfn = kwargs.pop('return_wfn', False); psi4.clean_variables(). # Make sure the molecule the user provided is the active one; molecule = kwargs.pop('molecule', psi4.get_active_molecule()); molecule.update_geometry(). for precallback in hooks['energy']['pre']:; precallback(lowername, **kwargs). optstash = driver_util._set_convergence_criterion('energy', lowername, 6, 8, 6, 8, 6). # Before invoking the procedure, we rename any file that should be r",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/driver.html:28687,energy,energy,28687,psi4manual/1.0.0/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver.html,1,['energy'],['energy']
Energy Efficiency,"alculation; Spectroscopic Constants for Diatomics. Spectroscopic Constants for Diatomics¶; Code author: Andrew C. Simmonett. psi4.driver.diatomic.anharmonicity(rvals, energies, plot_fit='', mol=None)[source]¶; Generates spectroscopic constants for a diatomic molecules.; Fits a diatomic potential energy curve using a weighted least squares approach; (c.f. https://doi.org/10.1063/1.4862157, particularly eqn. 7), locates the minimum; energy point, and then applies second order vibrational perturbation theory to obtain spectroscopic; constants. Any number of points greater than 4 may be provided, and they should bracket the minimum.; The data need not be evenly spaced, and can be provided in any order. The data are weighted such that; those closest to the minimum have highest impact.; A dictionary with the following keys, which correspond to spectroscopic constants, is returned:. Parameters. rvals (List) – The bond lengths (in Angstrom) for which energies are; provided, of length at least 5 and equal to the length of the energies array; energies (List) – The energies (Eh) computed at the bond lengths in the rvals list; plot_fit (str) – A string describing where to save a plot of the harmonic and anharmonic fits, the; inputted data points, re, r0 and the first few energy levels, if matplotlib; is available. Set to ‘screen’ to generate an interactive plot on the screen instead. If a filename is; provided, the image type is determined by the extension; see matplotlib for supported file types. Return type; Dict. Returns; (dict) Keys: “re”, “r0”, “we”, “wexe”, “nu”, “ZPVE(harmonic)”, “ZPVE(anharmonic)”, “Be”, “B0”, “ae”, “De”; corresponding to the spectroscopic constants in cm-1. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Psithon Functions: Invoking a Calculation; Spectroscopic Constants for Diatomics. © Copyright 2022, The Psi4 Project.; Last updated on Thursday, 19 May 2022 08:57PM.; Created using Sphinx 4.5.0.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/diatomic.html:1421,energy,energy,1421,psi4manual/1.6.x/diatomic.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/diatomic.html,1,['energy'],['energy']
Energy Efficiency,"alculations which will actually be run.; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13Naive listing of computations required.; scf / aug-cc-pvqz for SCF TOTAL ENERGY; mp2 / aug-cc-pvtz for MP2 CORRELATION ENERGY; mp2 / aug-cc-pvqz for MP2 CORRELATION ENERGY; ccsd(t) / aug-cc-pvdz for CCSD(T) CORRELATION ENERGY; ccsd(t) / aug-cc-pvtz for CCSD(T) CORRELATION ENERGY; mp2 / aug-cc-pvdz for MP2 CORRELATION ENERGY; mp2 / aug-cc-pvtz for MP2 CORRELATION ENERGY. Enlightened listing of computations required.; mp2 / aug-cc-pvqz for MP2 CORRELATION ENERGY; ccsd(t) / aug-cc-pvdz for CCSD(T) CORRELATION ENERGY; ccsd(t) / aug-cc-pvtz for CCSD(T) CORRELATION ENERGY. At the end of a cbs() job is printed a summary section like the one below. First,; in the components section, are listed the results for each model chemistry available, whether; required for the cbs job (*) or not. Next, in the stages section, are listed the results for; each extrapolation. The energies of this section must be dotted with the weightings in column Wt; to get the total cbs energy. Finally, in the CBS section, are listed the results for each stage; of the cbs procedure. The stage energies of this section sum outright to the total cbs energy.; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19; 20; 21; 22; 23; 24; 25; 26; 27; 28; 29; 30; 31; 32; 33; 34; 35; 36; 37; 38==> Components <==. ----------------------------------------------------------------------------------; Method / Basis Rqd Energy [H] Variable; ----------------------------------------------------------------------------------; scf / aug-cc-pvqz * -1.11916375 SCF TOTAL ENERGY; mp2 / aug-cc-pvqz * -0.03407997 MP2 CORRELATION ENERGY; scf / aug-cc-pvdz -1.11662884 SCF TOTAL ENERGY; mp2 / aug-cc-pvdz * -0.02881480 MP2 CORRELATION ENERGY; ccsd(t) / aug-cc-pvdz * -0.03893812 CCSD(T) CORRELATION ENERGY; ccsd / aug-cc-pvdz -0.03893812 CCSD CORRELATION ENERGY; scf / aug-cc-pvtz -1.11881134 SCF TOTAL ENERGY; mp2 / aug-cc-pvtz * -0.03288936 MP2",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/cbs-1.html:14352,energy,energy,14352,psi4manual/1.2.1/cbs-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/cbs-1.html,6,['energy'],['energy']
Energy Efficiency,"alculations. This is a simple alias to run_scf(); since DFT properties all handled through oeprop. run_dmrgci(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; an DMRG calculation. run_dmrgscf(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; an DMRG calculation. run_efp(name, **kwargs)[source]¶; Function encoding sequence of module calls for a pure EFP; computation (ignore any QM atoms). run_eom_cc(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; an EOM-CC calculation, namely EOM-CC2, EOM-CCSD, and EOM-CC3. run_eom_cc_gradient(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; an EOM-CCSD gradient calculation. run_fisapt(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; an F/ISAPT0 computation. run_fnocc(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; a QCISD(T), CCSD(T), MP2.5, MP3, and MP4 computation.; >>> energy('fno-ccsd(t)'). run_fnodfcc(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; a DF-CCSD(T) computation.; >>> set cc_type df; >>> energy('fno-ccsd(t)'). run_libfock(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; a calculation through libfock, namely RCPHF,; RCIS, RTDHF, RTDA, and RTDDFT. run_mcscf(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; a multiconfigurational self-consistent-field calculation. run_mrcc(name, **kwargs)[source]¶; Function that prepares environment and input files; for a calculation calling Kallay’s MRCC code. run_occ(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; a conventional integral (O)MPN computation. run_occ_gradient(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; a conventional integral (O)MPN computation. run_psimrcc(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for a PSIMRCC computa",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_driver-1.html:163970,energy,energy,163970,psi4manual/1.0.0/autodoc_driver-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_driver-1.html,2,['energy'],['energy']
Energy Efficiency,"alewicz et. al., J. Phys. Chem. Lett., 1, 550-555 (2010). mp3-grad1; MP3 cc-pVDZ gradient for the H2O molecule. scf-ecp; Water-Argon complex with ECP present; check of energies and forces. linK-2; RKS Linear Exchange Algorithm test for benzene. sapt-dft1; SAPT(DFT) aug-cc-pVDZ interaction energy between Ne and Ar atoms. ao-dfcasscf-sp; CASSCF/6-31G** energy point. cbs-parser; mtd/basis syntax examples. dlpnomp2-3; comparison of DF-MP2 and DLPNO-MP2 with a cartesian basis set. fisapt-siao1; This test case shows an example of running the I-SAPT0/jun-cc-pVDZ computation for 2,4-pentanediol (targeting the intramolecular hydrogen bond between the two hydroxyl groups) The SIAO1 link partitioning algorithm is used. An F-SAPT partitioning follows I-SAPT. omp2-2; OMP2 cc-pVDZ energy with ROHF initial guess orbitals for the NO radical. dft-jk; DFT JK on-disk test. cubeprop-esp; RHF orbitals and density for water. cbs-delta-energy; Extrapolated energies with delta correction. dfcasscf-sp; CASSCF/6-31G** energy point. cc9; UHF-CCSD(T) cc-pVDZ frozen-core energy for the \(^2\Sigma^+\) state of the CN radical, with Z-matrix input. dfccd-grad1; DF-CCSD cc-pVDZ gradients for the H2O molecule. fsapt-d; Tests SAPT0-D corrections, with a variety of damping functions/parameters. dforemp-grad1; density fitted OO-REMP/cc-pVDZ engrad single points for the H2O molecule. scf-hess4; DF SCF 6-31G UHFl vs RHF test Tests DF UHF hessian code for Ca = Cb. dft-vv10; He Dimer VV10 functional test. notes: DFT_VV10_B/C overwrites the NL_DISPERSION_PARAMETERS tuple updated ‘bench’ reference values for new BraggSlater radii. dct-grad4; Unrestricted DF-DCT ODC-12 gradient for O2 with cc-pVTZ/cc-pVTZ-RI standard/auxiliary basis set. dfomp3-grad2; DF-OMP3 cc-pVDZ gradients for the H2O+ cation. cc12; Single point energies of multiple excited states with EOM-CCSD. fnocc1; Test QCISD(T) for H2O/cc-pvdz Energy. dfmp2-grad3; DF-MP2 cc-pVDZ gradients for the H2O molecule. scf-ecp2; Water-Argon complex with ECP ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/autodoc_testsuite_corepsi4.html:31790,energy,energy,31790,psi4manual/master/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/master/autodoc_testsuite_corepsi4.html,2,['energy'],['energy']
Energy Efficiency,algorithm for CC-EOM. See Table Post-SCF Convergence for default convergence criteria for different calculation types. Type: conv double; Default: 1e-6. E_CONVERGENCE (DETCI); DETCI — Convergence criterion for energy. See Table Post-SCF Convergence for default convergence criteria for different calculation types. Type: conv double; Default: 1e-6. E_CONVERGENCE (FNOCC); FNOCC — Convergence criterion for CC energy. See Table Post-SCF Convergence for default convergence criteria for different calculation types. Note that convergence is met only when E_CONVERGENCE and R_CONVERGENCE are satisfied. Type: conv double; Default: 1.0e-6. E_CONVERGENCE (MCSCF); MCSCF — Convergence criterion for energy. Type: conv double; Default: 1e-6. E_CONVERGENCE (MRCC); MRCC — Convergence criterion for energy. See Table Post-SCF Convergence for default convergence criteria for different calculation types. This becomes tol (option #16) in fort.56. Type: conv double; Default: 1e-6. E_CONVERGENCE (OCC); OCC — Convergence criterion for energy. See Table Post-SCF Convergence for default convergence criteria for different calculation types. Type: conv double; Default: 1e-6. E_CONVERGENCE (PSIMRCC); PSIMRCC — Convergence criterion for energy. See Table Post-SCF Convergence for default convergence criteria for different calculation types. Type: conv double; Default: 1e-6. E_CONVERGENCE (SAPT); SAPT — Convergence criterion for energy (change) in the SAPT term during solution of the CPHF equations. Type: conv double; Default: 1e-10. E_CONVERGENCE (SCF); SCF — Convergence criterion for SCF energy. See Table SCF Convergence & Algorithm for default convergence criteria for different calculation types. Type: conv double; Default: 1e-6. EA_POLES (OCC); OCC — Do compute OCC poles for electron affinities? Only valid for OMP2. Type: boolean; Default: false. EKT_EA (OCC); OCC — Do compute virtual orbital energies based on extended Koopmans’ theorem?. Type: boolean; Default: false. EKT_IP (OCC); OCC — Do compu,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/autodoc_glossary_options_c-1.html:38463,energy,energy,38463,psi4manual/4.0b5/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodoc_glossary_options_c-1.html,2,['energy'],['energy']
Energy Efficiency,"algorithm is tested. sad1; Test of the superposition of atomic densities (SAD) guess, using a highly distorted water geometry with a cc-pVDZ basis set. This is just a test of the code and the user need only specify guess=sad to the SCF module’s (or global) options in order to use a SAD guess. The test is first performed in C2v symmetry, and then in C1. cc7; Tests CCENERGY’s CCSD gradient in the presence of a dipole field. dft-freq; Frequencies for H2O B3LYP/6-31G* at optimized geometry. cc12; Single point energies of multiple excited states with EOM-CCSD. cc8b; ROHF-CCSD cc-pVDZ frozen-core energy for the \(^2\Sigma^+\) state of the CN radical, with Cartesian input. dft3; DFT integral algorithms test, performing w-B97 RKS and UKS computations on water and its cation, using all of the different integral algorithms. This tests both the ERI and ERF integrals. cbs-xtpl-func; optimization with method defined via cbs. fcidump; test FCIDUMP functionality for rhf/uhf. dfomp2-3; OMP2 cc-pVDZ energy for the H2O molecule. scf-level-shift-rohf; SCF level shift on an ROHF computation. cc19; CCSD/cc-pVDZ dipole polarizability at two frequencies. dforemp-grad2; density fitted OO-REMP/cc-pVDZ engrad single points for the H2O+ molecule. scf3; File retention, docc, socc, and bond distances specified explicitly. opt16; SCF 6-31G(d) optimization of TS for HCN to HNC Performs finite difference hessian calculation. Then optimizes using previous orbitals for scf guess, in subsequent calculations. The last two displacements of the hessian break the plane of symemtry, This test confirms that only the reference geometry, with the correct symmetry, writes orbitals to disk. SCF will fail (ValidationError) otherwise. nbo; Generation of NBO file. fnocc6; Test method/basis with disk_df. dfomp2p5-grad2; DF-OMP2.5 cc-pVDZ gradients for the H2O+ cation. dfccsdl1; DF-CCSDL cc-pVDZ energy for the H2O molecule. opt1-fd; SCF STO-3G geometry optimzation, with Z-matrix input, by finite-differences. tu1-h2",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/autodoc_testsuite_corepsi4.html:34294,energy,energy,34294,psi4manual/1.8.x/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/autodoc_testsuite_corepsi4.html,2,['energy'],['energy']
Energy Efficiency,"algorithm reduces the memory requirements and can significantly reduce the cost of the energy computation if SIMULTANEOUS algorithm is used. For the TWOSTEP algorithm, however, AO_BASIS = DISK option is not recommended due to extra I/O. Type: string; Possible Values: NONE, DISK; Default: DISK. DCT_FUNCTIONAL¶. Chooses appropriate DCT method. Type: string; Possible Values: DC-06, DC-12, ODC-06, ODC-12, ODC-13, CEPA0; Default: ODC-12. DCT_TYPE¶. What algorithm to use for the DCT computation. Type: string; Possible Values: CONV, DF; Default: CONV. DF_BASIS_DCT¶. Auxiliary basis set for DCT density fitting computations. Defaults to a RI basis. Type: string; Possible Values: basis string; Default: No Default. DIIS_START_CONVERGENCE¶. Value of RMS of the density cumulant residual and SCF error vector below which DIIS extrapolation starts. Same keyword controls the DIIS extrapolation for the solution of the response equations. Type: conv double; Default: 1e-3. E_CONVERGENCE¶. Convergence criterion for energy. See Table Post-SCF Convergence for default convergence criteria for different calculation types. Type: conv double; Default: 1e-10. GUESS_R_CONVERGENCE¶. Convergence criterion for the density cumulant and orbital guess for the variationally orbital-optimized DFT methods. Currently only available for ALGORITHM = SIMULTANEOUS. Type: conv double; Default: 1e-3. MAXITER¶. Maximum number of macro- or micro-iterations for both energy and response equations. Type: integer; Default: 40. ODC_GUESS¶. Whether to perform a guess DC-06 or DC-12 computation for ODC-06 or ODC-12 methods, respectively. Currently only available for ALGORITHM = SIMULTANEOUS. Type: boolean; Default: false. OPDM¶. Compute a (relaxed) one-particle density matrix? Can be set manually. Set internally for property and gradient computations. Type: boolean; Default: false. QC_COUPLING¶. Controls whether to include the coupling terms in the DCT electronic Hessian (for ALOGRITHM = QC with QC_TYPE = SIMULTANEOUS ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/autodir_options_c/module__dct-1.html:1847,energy,energy,1847,psi4manual/1.4.0/autodir_options_c/module__dct-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/module__dct-1.html,18,['energy'],['energy']
Energy Efficiency,"alid with \'%s\' basis sets.' % (functionname, len(ZSET))). # Return array that logs the requisite jobs; NEED = {'HI': dict(zip(f_fields, [wfnname, 'tot', BSET[1], ZSET[1], 0.0])),; 'LO': dict(zip(f_fields, [wfnname, 'tot', BSET[0], ZSET[0], 0.0]))}. return NEED. elif (mode == 'evaluate'):. # Extract required energies and zeta integers from array; eHI = NEED['HI']['f_energy']; eLO = NEED['LO']['f_energy']; zHI = NEED['HI']['f_zeta']; zLO = NEED['LO']['f_zeta']. # LAB TODO add ability to pass alternate parameter values in. # Return extrapolated energy; alpha = 1.63; beta = (eHI - eLO) / (math.exp(-1 * alpha * zLO) * (math.exp(-1 * alpha) - 1)); energypiece = eHI - beta * math.exp(-1 * alpha * zHI). # Output string with extrapolation parameters; cbsscheme = ''; cbsscheme += """"""\n ==> %s <==\n\n"""""" % (functionname); cbsscheme += """""" LO-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(zLO), eLO); cbsscheme += """""" HI-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(zHI), eHI); cbsscheme += """""" Extrapolated Correlation Energy: %16.8f\n"""""" % (energypiece); cbsscheme += """""" Alpha (exponent) Value: %16.8f\n"""""" % (alpha); cbsscheme += """""" Beta (coefficient) Value: %16.8f\n"""""" % (beta); PsiMod.print_out(cbsscheme). return energypiece. [docs]def validate_scheme_args(functionname, **largs):; r""""""Function called by each extrapolation scheme in :py:func:`~wrappers.complete_basis_set`.; Checks that all the input arguments are present and suitable so that; the scheme function can focus on defining the extrapolation. """"""; mode = ''; NEED = []; wfnname = ''; BSET = []; ZSET = []. # Mode where function fills out a form NEED with the computations needed to fulfill its call; if (largs['mode'].lower() == 'requisition'):; mode = largs['mode'].lower(). if 'wfnname' in largs:; wfnname = largs['wfnname']; else:; raise ValidationError('Call to \'%s\' has keyword \'wfnname\' missing.' % (functionname)). if re.match(r'scf_.*$', functionname) and (wfnname != 'scf'):; raise ValidationError('Call to",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:84198,Energy,Energy,84198,psi4manual/4.0b2/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html,3,['Energy'],['Energy']
Energy Efficiency,"alid with \'%s\' basis sets.' % (functionname, len(ZSET))). # Return array that logs the requisite jobs; NEED = {'HI': dict(zip(f_fields, [wfnname, 'tot', BSET[1], ZSET[1], 0.0])),; 'LO': dict(zip(f_fields, [wfnname, 'tot', BSET[0], ZSET[0], 0.0]))}. return NEED. elif (mode == 'evaluate'):. # Extract required energies and zeta integers from array; eHI = NEED['HI']['f_energy']; eLO = NEED['LO']['f_energy']; zHI = NEED['HI']['f_zeta']; zLO = NEED['LO']['f_zeta']. # LAB TODO add ability to pass alternate parameter values in. # Return extrapolated energy; alpha = 1.63; beta = (eHI - eLO) / (math.exp(-1 * alpha * zLO) * (math.exp(-1 * alpha) - 1)); energypiece = eHI - beta * math.exp(-1 * alpha * zHI). # Output string with extrapolation parameters; cbsscheme = ''; cbsscheme += """"""\n ==> %s <==\n\n"""""" % (functionname); cbsscheme += """""" LO-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(zLO), eLO); cbsscheme += """""" HI-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(zHI), eHI); cbsscheme += """""" Extrapolated Correlation Energy: %16.8f\n"""""" % (energypiece); cbsscheme += """""" Alpha (exponent) Value: %16.8f\n"""""" % (alpha); cbsscheme += """""" Beta (coefficient) Value: %16.8f\n"""""" % (beta); psi4.print_out(cbsscheme). return energypiece. [docs]def validate_scheme_args(functionname, **largs):; r""""""Function called by each extrapolation scheme in :py:func:`~wrappers.complete_basis_set`.; Checks that all the input arguments are present and suitable so that; the scheme function can focus on defining the extrapolation. """"""; mode = ''; NEED = []; wfnname = ''; BSET = []; ZSET = []. # Mode where function fills out a form NEED with the computations needed to fulfill its call; if (largs['mode'].lower() == 'requisition'):; mode = largs['mode'].lower(). if 'wfnname' in largs:; wfnname = largs['wfnname']; else:; raise ValidationError('Call to \'%s\' has keyword \'wfnname\' missing.' % (functionname)). if re.match(r'scf_.*$', functionname) and (wfnname != 'scf'):; raise ValidationError('Call to \",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:99975,Energy,Energy,99975,psi4manual/4.0b5/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html,1,['Energy'],['Energy']
Energy Efficiency,"alidate forces. psimrcc-sp1; Mk-MRCCSD single point. \(^3 \Sigma ^-\) O2 state described using the Ms = 0 component of the triplet. Uses ROHF triplet orbitals. olccd-grad2; OLCCD cc-pVDZ gradient for the NO radical. nbody-vmfc-gradient; Computation of VMFC-corrected water trimer gradient (geometry from J. Chem. Theory Comput. 11, 2126-2136 (2015)). scf-freq1; Analytic vs. finite difference DF-SCF frequency test for water. cbs-xtpl-energy-conv; Extrapolated water energies - conventional integrals version. cc40; RHF-CC2-LR/cc-pVDZ optical rotation of H2O2. gauge = length, omega= (589 355 nm). nbo; Generation of NBO file. cc54; CCSD dipole with user-specified basis set. scf-guess-read3; Test if the the guess read in the same basis converges. scf-upcast-custom-basis; test scf castup with custom basis sets. density-screen-2; RKS Density Matrix based-Integral Screening Test for benzene. fci-dipole; 6-31G H2O Test FCI Energy Point. mints6; Patch of a glycine with a methyl group, to make alanine, then DF-SCF energy calculation with the cc-pVDZ basis set. scf-response1; Compute the dipole, quadrupole, and traceless quadrupoles for water. fsapt1; This test case shows an example of running and analyzing a standard F-SAPT0/jun-cc-pvdz procedure for phenol dimer from the S22 database. cc42; RHF-CC2-LR/STO-3G optical rotation of (S)-methyloxirane. gauge = length, omega = (589 355 nm). fnocc5; Test FNO-DF-CCSD(T) energy. opt4; SCF cc-pVTZ geometry optimzation, with Z-matrix input. psimrcc-ccsd_t-3; Mk-MRCCSD(T) single point. \(^1A_1\) CH2 state described using the Ms = 0 component of the singlet. Uses RHF singlet orbitals. cc35; CC3(ROHF)/cc-pVDZ H2O \(R_e\) geom from Olsen et al., JCP 104, 8007 (1996). dfccsd-t-grad1; DF-CCSD(T) cc-pVDZ gradients for the H2O molecule. mints15; check SP basis Fortran exponent parsing. tdscf-5; td-camb3lyp with DiskDF and method/basis specification. dfccsd1; DF-CCSD cc-pVDZ energy for the H2O molecule. fci-tdm; He2+ FCI/cc-pVDZ Transition Dipole Mo",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/autodoc_testsuite_corepsi4.html:23094,energy,energy,23094,psi4manual/1.7.x/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/autodoc_testsuite_corepsi4.html,2,['energy'],['energy']
Energy Efficiency,"alidate forces. scf-guess; Test initial SCF guesses on FH and FH+ in cc-pVTZ basis. dct8; DCT calculation for the NH3+ radical using the ODC-12 and ODC-13 functionals. This performs both simultaneous and QC update of the orbitals and cumulant using DIIS extrapolation. Four-virtual integrals are first handled in the MO Basis for the first two energy computations. In the next computation ao_basis=disk algorithm is used, where the transformation of integrals for four-virtual case is avoided. opt1-fd; SCF STO-3G geometry optimzation, with Z-matrix input, by finite-differences. fd-freq-energy; SCF STO-3G finite-difference frequencies from energies for H2O. cc30; CCSD/sto-3g optical rotation calculation (length gauge only) at two frequencies on methyloxirane. dfccsd-grad2; DF-CCSD cc-pVDZ gradient for the NH molecule. dft-pruning; Tests all grid pruning options available and screening of small weights. Check against grid size. cc51; EOM-CC3/cc-pVTZ on H2O. opt7; Various constrained energy minimizations of HOOH with cc-pvdz RHF. For “fixed” coordinates, the final value is provided by the user. cbs-xtpl-gradient; Various gradients for a strained helium dimer and water molecule. sapt9; usapt example with empty beta. cc7; Tests CCENERGY’s CCSD gradient in the presence of a dipole field. mcscf2; TCSCF cc-pVDZ energy of asymmetrically displaced ozone, with Z-matrix input. dct5; DC-06 calculation for the O2 molecule (triplet ground state). This performs geometry optimization using two-step and simultaneous solution of the response equations for the analytic gradient. dfscf-bz2; Benzene Dimer DF-HF/cc-pVDZ. cepa1; cc-pvdz H2O Test CEPA(1) Energy. tu1-h2o-energy; Sample HF/cc-pVDZ H2O computation. cc56; EOM-CCSD/6-31g excited state transition data for water cation. cc3; cc3: RHF-CCSD/6-31G** H2O geometry optimization and vibrational frequency analysis by finite-differences of gradients. dfmp2-grad1; DF-MP2 cc-pVDZ gradients for the H2O molecule. opt-irc-2; Compute the IRC for HCN <",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/autodoc_testsuite_corepsi4.html:5610,energy,energy,5610,psi4manual/master/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/master/autodoc_testsuite_corepsi4.html,2,['energy'],['energy']
Energy Efficiency,"alidate the gradient on the charges. tdscf-7; TD-HF test variable access. cc35; CC3(ROHF)/cc-pVDZ H2O \(R_e\) geom from Olsen et al., JCP 104, 8007 (1996). mom-h2o-3; MOM excitation from LUMO HOMO+3. pywrap-bfs; apply linear fragmentation algorithm to a water cluster. dfmp2-grad4; DF-MP2 cc-pVDZ gradient for the NO molecule. olccd3; OLCCD cc-pVDZ energy with ROHF initial guess for the NO radical. sapt2; SAPT0 aug-cc-pVDZ computation of the benzene-methane interaction energy, using the aug-pVDZ-JKFIT DF basis for SCF, the aug-cc-pVDZ-RI DF basis for SAPT0 induction and dispersion, and the aug-pVDZ-JKFIT DF basis for SAPT0 electrostatics and induction. This example uses frozen core as well as asyncronous I/O while forming the DF integrals and CPHF coefficients. fsapt-ext-abc; FSAPT with external charge on trimer. casscf-sa-sp; Example of state-averaged CASSCF for the C2 molecule see C. D. Sherrill and P. Piecuch, J. Chem. Phys. 122, 124104 (2005). mcscf1; ROHF 6-31G** energy of the \(^{3}B_1\) state of CH2, with Z-matrix input. The occupations are specified explicitly. mints10; H2 with tiny basis set, to test basis set parser’s handling of integers. mints12; test roundtrip-ness of dict repr for psi4.core.Molecule and qcdb.Molecule. mp2-h; check that methods can act on single atom. pywrap-basis; SAPT calculation on bimolecular complex where monomers are unspecified so driver auto-fragments it. Basis set and auxiliary basis sets are assigned by atom type. mp2-1; All-electron MP2 6-31G** geometry optimization of water. molden1; Test of the superposition of atomic densities (SAD) guess, using a highly distorted water geometry with a cc-pVDZ basis set. This is just a test of the code and the user need only specify guess=sad to the SCF module’s (or global) options in order to use a SAD guess. The test is first performed in C2v symmetry, and then in C1. dct12; Spin-restricted DC-06 counterpart of dct1. ao-dfcasscf-sp; CASSCF/6-31G** energy point. mom; Maximum Overlap Method ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/autodoc_testsuite_corepsi4.html:18228,energy,energy,18228,psi4manual/1.9.x/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/autodoc_testsuite_corepsi4.html,2,['energy'],['energy']
Energy Efficiency,"alidationError(f""psi4.core.set_variable: Target variable '{key}' already a scalar variable!""); else:; core.set_array_variable(key, val); elif isinstance(val, np.ndarray):; if core.has_scalar_variable(key):; raise ValidationError(f""psi4.core.set_variable: Target variable '{key}' already a scalar variable!""); else:; core.set_array_variable(key, core.Matrix.from_array(_qcvar_reshape_set(key, val))); else:; if core.has_array_variable(key):; raise ValidationError(f""psi4.core.set_variable: Target variable '{key}' already an array variable!""); else:; core.set_scalar_variable(key, val). # TODO _qcvar_warnings(key). def _core_wavefunction_set_variable(self: core.Wavefunction, key: str, val: Union[core.Matrix, np.ndarray, float]) -> None:; """"""Sets scalar or array :ref:`QCVariable <sec:appendices:qcvars>` *key* to; *val* on *self*. Parameters; ----------; self; Wavefunction instance.; key; Case-insensitive key to instance's double or :class:`~psi4.core.Matrix`; storage maps. - If ``CURRENT ENERGY``, syncs with ``self.energy_``.; - If ``CURRENT GRADIENT``, syncs with ``gradient_``.; - If ``CURRENT HESSIAN``, syncs with ``self.hessian_``.; val; Scalar or array to be stored in `key`. If :class:`~numpy.ndarray` and; data `key` does not naturally fit in 2D Matrix (often charge and; multipole QCVariables), it will be reshaped, as all; :class:`~numpy.ndarray` are stored as :class:`~psi4.core.Matrix`. Raises; ------; ~psi4.driver.ValidationError; If `val` is a scalar but `key` already exists as an array variable. Or; if `val` is an array but `key` already exists as a scalar variable. """"""; if isinstance(val, core.Matrix):; if self.has_scalar_variable(key):; raise ValidationError(""psi4.core.Wavefunction.set_variable: Target variable '{key}' already a scalar variable!""); else:; self.set_array_variable(key, val); elif isinstance(val, np.ndarray):; if self.has_scalar_variable(key):; raise ValidationError(""psi4.core.Wavefunction.set_variable: Target variable '{key}' already a scalar variabl",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/python_helpers.html:37950,ENERGY,ENERGY,37950,psi4manual/1.7.x/_modules/psi4/driver/p4util/python_helpers.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/python_helpers.html,2,['ENERGY'],['ENERGY']
Energy Efficiency,"aling value for 3rd order energy correction (S. Grimme, Vol. 24, pp. 1529, J. Comput. Chem.). Type: double; Default: 0.25. E_CONVERGENCE (CCENERGY); CCENERGY — Convergence criterion for energy. See Table Post-SCF Convergence for default convergence criteria for different calculation types. Type: conv double; Default: 1e-6. E_CONVERGENCE (CCEOM); CCEOM — Convergence criterion for excitation energy (change) in the Davidson algorithm for CC-EOM. See Table Post-SCF Convergence for default convergence criteria for different calculation types. Type: conv double; Default: 1e-6. E_CONVERGENCE (DCFT); DCFT — Convergence criterion for energy. See Table Post-SCF Convergence for default convergence criteria for different calculation types. Type: conv double; Default: 1e-10. E_CONVERGENCE (DETCI); DETCI — Convergence criterion for energy. See Table Post-SCF Convergence for default convergence criteria for different calculation types. Type: conv double; Default: 1e-6. E_CONVERGENCE (DFOCC); DFOCC — Convergence criterion for energy. See Table Post-SCF Convergence for default convergence criteria for different calculation types. Type: conv double; Default: 1e-6. E_CONVERGENCE (FNOCC); FNOCC — Convergence criterion for CC energy. See Table Post-SCF Convergence for default convergence criteria for different calculation types. Note that convergence is met only when E_CONVERGENCE and R_CONVERGENCE are satisfied. Type: conv double; Default: 1.0e-6. E_CONVERGENCE (MCSCF); MCSCF — Convergence criterion for energy. Type: conv double; Default: 1e-6. E_CONVERGENCE (MRCC); MRCC — Convergence criterion for energy. See Table Post-SCF Convergence for default convergence criteria for different calculation types. This becomes tol (option #16) in fort.56. Type: conv double; Default: 1e-6. E_CONVERGENCE (OCC); OCC — Convergence criterion for energy. See Table Post-SCF Convergence for default convergence criteria for different calculation types. Type: conv double; Default: 1e-6. E_CONVERGENCE (PSIMRCC",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_glossary_options_c-1.html:113831,energy,energy,113831,psi4manual/1.0.0/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_glossary_options_c-1.html,8,['energy'],['energy']
Energy Efficiency,"alization. The OSOs are rarely; encountered, as usually we go straight from USOs to MOs. MO (Molecular Orbitals): The combination of OSOs that diagonalizes; the Fock Matrix, so each basis function is a Hartree-Fock (or Kohn-Sham); molecular orbital. The number of OSOs and MOs is always the same. MOs are; orthonormal. LO (Localized Orbitals): Localized occupied orbitals, a different; combination of the occupied molecular orbitals which enhances spatial; locality. LOs do not diagonalize the occ-occ block of the Fock Matrix, but; remain orthonormal to each other and the virtual space. How to name orbital dimensions¶; There are a number of different names used to refer to the basis set size.; These may seem redundant, but they have subtly different meanings, as; detailed below.; A calculation can use either pure (5D, 7F, 9G, etc.) basis functions or; Cartesian (6D, 10F, 15G, etc.), as dictated by the input file / basis set; specification. Also, the basis can be represented in terms of atomic; orbitals (AO) or symmetry-adapted orbitals (SO). Further complications; come from the fact that a nearly linearly-dependent basis set will have; functions removed from it to prevent redundancies. With all of these; factors in mind, here are the conventions used internally:. nao — The number of atomic orbitals in Cartesian representation.; nso — The number of atomic orbitals but in the pure representation if the current basis uses pure functions, number of Cartesian AOs otherwise.; nbf — The number of basis functions, which is the same as nso.; nmo — The number of basis functions, after projecting out redundancies in the basis. When molecular symmetry is utilized, a small array of sizes per irrep is; usually allocated on the stack, and is named by augmenting the name above; with a pi (per-irrep), e.g. nmopi. Note that the number of irreps is; always the singular nirrep, and that the index variable h is always used; in a for-loop traverse of irreps. How to name orbital spaces (e.g., ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/prog_blas-1.html:12139,adapt,adapted,12139,psi4manual/1.2.1/prog_blas-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/prog_blas-1.html,4,['adapt'],['adapted']
Energy Efficiency,"all atoms with symbol (e.g., H) arg2. set_geometry(self: psi4.core.Molecule, arg0: psi4.core.Matrix) → None; Sets the geometry, given a (Natom X 3) matrix arg2 of coordinates (in Bohr). set_ghost_fragment(self: psi4.core.Molecule, arg0: int) → None; Sets the specified fragment arg2 to be Ghost. set_ghost_fragments(self: psi4.core.Molecule, arg0: List[int]) → None; Sets the specified list arg2 of fragments to be Ghost. set_input_units_to_au(self: psi4.core.Molecule, arg0: float) → None; Sets unit conversion to [a0] for geometry. set_mass(self: psi4.core.Molecule, atom: int, mass: float) → None; Sets mass of atom (0-indexed) to mass. set_molecular_charge(self: psi4.core.Molecule, arg0: int) → None; Sets the molecular charge. set_multiplicity(self: psi4.core.Molecule, arg0: int) → None; Sets the multiplicity (defined as 2Ms + 1). set_name(self: psi4.core.Molecule, arg0: str) → None; Sets molecule name. set_nuclear_charge(self: psi4.core.Molecule, arg0: int, arg1: float) → None; Set the nuclear charge of the given atom to the value provided. set_point_group(self: psi4.core.Molecule, arg0: psi4.core.PointGroup) → None; Sets the molecular point group to the point group object arg2. set_units(self: psi4.core.Molecule, arg0: psi4.core.GeometryUnits) → None; Sets units (Angstrom or Bohr) used to define the geometry. set_variable(self: psi4.core.Molecule, arg0: str, arg1: float) → None; Assigns the value arg3 to the variable arg2 in the list of geometry variables, then calls update_geometry(). symbol(self: psi4.core.Molecule, arg0: int) → str; Gets the cleaned up label of atom arg2 (C2 => C, H4 = H). symmetrize(self: psi4.core.Molecule, arg0: float) → None; Finds the highest point Abelian point group within the specified tolerance, and forces the geometry to have that symmetry. symmetry_from_input(self: psi4.core.Molecule) → str; Returns the symmetry specified in the input. to_arrays(); Exports coordinate info into NumPy arrays. Returns:; geom, mass, elem, elez, uniq (ndarray,",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/api/psi4.core.molecule.html:54348,charge,charge,54348,psi4manual/1.2.1/api/psi4.core.molecule.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/api/psi4.core.molecule.html,1,['charge'],['charge']
Energy Efficiency,"all available schemes. :type scf_scheme: string; :param scf_scheme: |dl| ``'xtpl_highest_1'`` |dr| || ``'scf_xtpl_helgaker_3'`` || etc. Indicates the basis set extrapolation scheme to be applied to the reference energy.; Defaults to :py:func:`~psi4.driver.driver_cbs.scf_xtpl_helgaker_3` if three valid basis sets; present in ``psi4.driver.driver_cbs.scf_basis``, :py:func:`~psi4.driver.driver_cbs.scf_xtpl_helgaker_2` if two valid basis; sets present in ``scf_basis``, and :py:func:`~psi4.driver.driver_cbs.xtpl_highest_1` otherwise. .. hlist::; :columns: 1. * :py:func:`~psi4.driver.driver_cbs.xtpl_highest_1`; * :py:func:`~psi4.driver.driver_cbs.scf_xtpl_helgaker_3`; * :py:func:`~psi4.driver.driver_cbs.scf_xtpl_helgaker_2`; * :py:func:`~psi4.driver.driver_cbs.scf_xtpl_truhlar_2`; * :py:func:`~psi4.driver.driver_cbs.scf_xtpl_karton_2`. :type corl_scheme: string; :param corl_scheme: |dl| ``'xtpl_highest_1'`` |dr| || ``'corl_xtpl_helgaker_2'`` || etc. Indicates the basis set extrapolation scheme to be applied to the correlation energy.; Defaults to :py:func:`~psi4.driver.driver_cbs.corl_xtpl_helgaker_2` if two valid basis sets; present in ``corl_basis`` and :py:func:`~psi4.driver.driver_cbs.xtpl_highest_1` otherwise. .. hlist::; :columns: 1. * :py:func:`~psi4.driver.driver_cbs.xtpl_highest_1`; * :py:func:`~psi4.driver.driver_cbs.corl_xtpl_helgaker_2`. :type delta_scheme: string; :param delta_scheme: |dl| ``'xtpl_highest_1'`` |dr| || ``'corl_xtpl_helgaker_2'`` || etc. Indicates the basis set extrapolation scheme to be applied to the delta correction; to the correlation energy.; Defaults to :py:func:`~psi4.driver.driver_cbs.corl_xtpl_helgaker_2` if two valid basis sets; present in ``delta_basis`` and :py:func:`~psi4.driver.driver_cbs.xtpl_highest_1` otherwise. .. hlist::; :columns: 1. * :py:func:`~psi4.driver.driver_cbs.xtpl_highest_1`; * :py:func:`~psi4.driver.driver_cbs.corl_xtpl_helgaker_2`. :type delta2_scheme: string; :param delta2_scheme: |dl| ``'xtpl_highest_1'`` |dr| ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver_cbs.html:28092,energy,energy,28092,psi4manual/1.6.x/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver_cbs.html,2,['energy'],['energy']
Energy Efficiency,"all('dmrcc', shell=True); else:; retcode = subprocess.call('dmrcc >> ' + current_directory + '/' + PsiMod.outfile_name(), shell=True). if retcode < 0:; print('MRCC was terminated by signal %d' % -retcode, file=sys.stderr); exit(1); elif retcode > 0:; print('MRCC errored %d' % retcode, file=sys.stderr); exit(1). except OSError as e:; print('Execution failed: %s' % e, file=sys.stderr); exit(1). # Restore the OMP_NUM_THREADS that the user set.; if omp_num_threads_found == True:; if PsiMod.has_option_changed('MRCC', 'MRCC_OMP_NUM_THREADS') == True:; os.environ['OMP_NUM_THREADS'] = omp_num_threads_user. # Scan iface file and grab the file energy.; e = 0.0; for line in file('iface'):; fields = line.split(); m = fields[1]; try:; e = float(fields[5]); if m == ""MP(2)"":; m = ""MP2""; PsiMod.set_variable(m + ' TOTAL ENERGY', e); PsiMod.set_variable(m + ' CORRELATION ENERGY', e - vscf); except ValueError:; continue. # The last 'e' in iface is the one the user requested.; PsiMod.set_variable('CURRENT ENERGY', e); PsiMod.set_variable('CURRENT CORRELATION ENERGY', e - vscf). # Load the iface file; iface = open('iface', 'r'); iface_contents = iface.read(). # Delete mrcc tempdir; os.chdir('..'); try:; # Delete unless we're told not to; if (keep == False and not('path' in kwargs)):; shutil.rmtree(mrcc_tmpdir); except OSError as e:; print('Unable to remove MRCC temporary directory %s' % e, file=sys.stderr); exit(1). # Revert to previous current directory location; os.chdir(current_directory). # Reopen output file; PsiMod.reopen_outfile(). # If we're told to keep the files or the user provided a path, do nothing.; if (keep != False or ('path' in kwargs)):; PsiMod.print_out('\nMRCC scratch files have been kept.\n'); PsiMod.print_out('They can be found in ' + mrcc_tmpdir). # Dump iface contents to output; PsiMod.print_out('\n'); banner('Full results from MRCC'); PsiMod.print_out('\n'); PsiMod.print_out(iface_contents). return e. [docs]def run_fnodfcc(name, **kwargs):; """"""Function encoding ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/_modules/proc.html:67037,ENERGY,ENERGY,67037,psi4manual/4.0b4/_modules/proc.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/proc.html,1,['ENERGY'],['ENERGY']
Energy Efficiency,"alling from Source).; This very simple input is sufficient to run the requested information.; Notice that we didn’t tell the program some otherwise useful information; like the charge on the molecule (0, it’s neutral), the spin multiplicity; (1 for a closed-shell molecule with all electrons paired), or the reference; wavefunction to use (restricted Hartree–Fock, or RHF, is usually; appropriate for a closed-shell molecule). The program correctly guessed; all of these options for us. We can change the default behavior through; additional keywords.; Let’s consider what we would do for an open-shell molecule, where; not all electrons are paired. For example, let’s run a computation; on methylene (CH2), whose ground electronic state has two unpaired; electrons (triplet electronic state, or a spin multiplicity \(2S+1 = 3\)).; In this case, the default spin multiplicity (1) is not correct, so we; need to tell the program the true value (3). Like many programs, PSI4; can get the charge and multiplicity as the first two integers in the; Z-matrix. Note the line with 0 3 at the beginning of the molecule; specification below. In this example we will also specify the bond length; and bond angle as variables (\(R\) and \(A\)), whose values are given; at the end of the Z-matrix specification.; #! Sample UHF/6-31G** CH2 computation. molecule ch2 {; 0 3; C ; H 1 R; H 1 R 2 A. R = 1.075; A = 133.93; }. set basis 6-31G**; set reference uhf; energy ('scf'). This sample input can be found in; tu2-ch2-energy and as; before it can be run through the command psi4 input.dat output.dat; (actually, because psi4 by default looks for an input file named; input.dat and writes by default to a file called output.dat, in this; case one could also just type psi4). If it works, it should print; the final energy as; 1@UHF Final Energy: -38.92533462456894. Notice we added a new keyword, set reference uhf, to the input. For; open-shell molecules, we have a choice of unrestricted orbitals; (unrestricted ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/tutorial-1.html:4179,charge,charge,4179,psi4manual/1.1.0/tutorial-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/tutorial-1.html,6,['charge'],['charge']
Energy Efficiency,"alling from Source).; This very simple input is sufficient to run the requested information.; Notice that we didn’t tell the program some otherwise useful information; like the charge on the molecule (0, it’s neutral), the spin multiplicity; (1 for a closed-shell molecule with all electrons paired), or the reference; wavefunction to use (restricted Hartree–Fock, or RHF, is usually; appropriate for a closed-shell molecule). The program correctly guessed; all of these options for us. We can change the default behavior through; additional keywords.; Let’s consider what we would do for an open-shell molecule, where; not all electrons are paired. For example, let’s run a computation; on methylene (CH2), whose ground electronic state has two unpaired; electrons (triplet electronic state, or a spin multiplicity \(2S+1 = 3\)).; In this case, the default spin multiplicity (1) is not correct, so we; need to tell the program the true value (3). Like many programs, PSI4; can get the charge and multiplicity as the first two integers in the; Z-matrix. Note the line with 0 3 at the beginning of the molecule; specification below. In this example we will also specify the bond length; and bond angle as variables (\(R\) and \(A\)), whose values are given; at the end of the Z-matrix specification.; #! Sample UHF/6-31G** CH2 computation. molecule ch2 {; 0 3; C ; H 1 R; H 1 R 2 A. R = 1.075; A = 133.93; }. set basis 6-31G**; set reference uhf; energy ('scf'). This sample input can be found in; tu2-ch2-energy and as; before it can be run through the command psi4 input.dat output.dat; (actually, because psi4 by default looks for an input file named; input.dat and writes by default to a file called output.dat, in this; case one could also just type psi4). If it works, it should print; the final energy as; @UHF Final Energy: -38.92533462456894. Notice we added a new keyword, set reference uhf, to the input. For; open-shell molecules, we have a choice of unrestricted orbitals; (unrestricted H",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/tutorial-1.html:4217,charge,charge,4217,psi4manual/1.4.0/tutorial-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/tutorial-1.html,9,['charge'],['charge']
Energy Efficiency,"alls to the; energy function.; energy('sapt0-ct'); energy('sapt2-ct'); energy('sapt2+-ct'); energy('sapt2+(3)-ct'); energy('sapt2+3-ct'). A SAPT charge-transfer analysis will perform 5 HF computations: the dimer; in the dimer basis, monomer A in the dimer basis, monomer B in the dimer; basis, monomer A in the monomer A basis, and monomer B in the monomer B; basis. Next, it performs two SAPT computations, one in the dimer basis and; one in the monomer basis. Finally, it will print a summary of the; charge-transfer results:; SAPT Charge Transfer Analysis; -----------------------------------------------------------------------------; SAPT Induction (Dimer Basis) -2.0970 mH -1.3159 kcal mol^-1; SAPT Induction (Monomer Basis) -1.1396 mH -0.7151 kcal mol^-1; SAPT Charge Transfer -0.9574 mH -0.6008 kcal mol^-1. These results are for the water dimer geometry shown above computed with; SAPT0/aug-cc-pVDZ. Monomer-Centered Basis Computations¶; The charge-transfer analysis above is carried out by taking the; difference between SAPT induction as calculated in the dimer-centered; basis (i.e., each monomer sees the basis functions on both monomers); vs. the monomer-centered basis (i.e., each monomer utilizes only its; own basis set). It is also possible to run a SAPT computation at any; level using only the monomer-centered basis. To do this, simply add; sapt_basis='monomer' to the energy function, such as; energy('sapt2',sapt_basis='monomer'). This procedure leads to faster compuations, but it converges more slowly; towards the complete basis set limit than the default procedure, which uses; the dimer-centered basis set. Hence, monomer-centered basis SAPT; computations are not recommended. Interpreting SAPT Results¶; We will examine the results of a SAPT2+3/aug-cc-pVDZ computation on the; water dimer. This computation can be performed with the following; input:; molecule water_dimer {; 0 1; O -1.551007 -0.114520 0.000000; H -1.934259 0.762503 0.000000; H -0.599677 0.040712 0.0000",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/sapt-1.html:13208,charge,charge-transfer,13208,psi4manual/4.0b5/sapt-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/sapt-1.html,2,['charge'],['charge-transfer']
Energy Efficiency,"ally compute any energies, but serves as an example of the many ways to specify geometries in Psi4. omp2-2; OMP2 cc-pVDZ energy with ROHF initial guess orbitals for the NO radical. fci-h2o-2; 6-31G H2O Test FCI Energy Point. molden2; Test of the superposition of atomic densities (SAD) guess, using a highly distorted water geometry with a cc-pVDZ basis set. This is just a test of the code and the user need only specify guess=sad to the SCF module’s (or global) options in order to use a SAD guess. The test is first performed in C2v symmetry, and then in C1. cc54; CCSD dipole with user-specified basis set. cc39; RHF-CC2-LR/cc-pVDZ dynamic polarizabilities of HOF molecule. cc34; RHF-CCSD/cc-pVDZ energy of H2O partitioned into pair energy contributions. opt-irc-1; Compute the IRC for HOOH torsional rotation at the RHF/DZP level of theory. cepa3; cc-pvdz H2O Test coupled-pair CISD against DETCI CISD. cc33; CC3(UHF)/cc-pVDZ H2O geom from Olsen et al., JCP 104, 8007 (1996). casscf-sp; CASSCF/6-31G** energy point. ocepa-freq1; OCEPA cc-pVDZ freqs for C2H2. opt1-fd; SCF STO-3G geometry optimzation, with Z-matrix input, by finite-differences. pywrap-cbs1; Various basis set extrapolation tests. dcft-grad3; Restricted DF-DCFT ODC-12 gradient for ethylene with cc-pVDZ/cc-pVDZ-RI standard/auxiliary basis set. cisd-h2o-clpse; 6-31G** H2O Test CISD Energy Point with subspace collapse. dfomp3-grad1; DF-OMP3 cc-pVDZ gradients for the H2O molecule. extern1; External potential calculation involving a TIP3P water and a QM water. Finite different test of the gradient is performed to validate forces. psimrcc-fd-freq2; Mk-MRCCSD frequencies. O$_3` state described using the Ms = 0 component of the singlet. Uses TCSCF orbitals. mp2-1; All-electron MP2 6-31G** geometry optimization of water. ocepa3; OCEPA cc-pVDZ energy with ROHF initial guess for the NO radical. cc27; Single point gradient of 1-1B2 state of H2O with EOM-CCSD. pywrap-molecule; Check that C++ Molecule class and qcdb molecule cl",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_testsuite_corepsi4-1.html:25926,energy,energy,25926,psi4manual/1.0.0/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_testsuite_corepsi4-1.html,4,['energy'],['energy']
Energy Efficiency,"ally occupying orbitals (or 0 for no fractional occupation). Type: integer; Default: 0. FRAC_VAL (SCF)¶SCF — The occupations of the orbital indices specified above (\(0.0\le {\rm occ} \le 1.0\)). Type: array; Default: No Default. FRAG_MODE (OPTKING)¶OPTKING — For multi-fragment molecules, treat as single bonded molecule or via interfragment coordinates. A primary difference is that in MULTI mode, the interfragment coordinates are not redundant. Type: string; Possible Values: SINGLE, MULTI; Default: SINGLE. FRAG_REF_ATOMS (OPTKING)¶OPTKING — Specify atoms to use for reference points in interfragment coordinates. Type: array; Default: No Default. FREEZE_ALL_DIHEDRALS (OPTKING)¶OPTKING — Freeze ALL dihedral angles. Type: boolean; Default: false. FREEZE_CORE (GLOBALS)¶GLOBALS — Specifies how many core orbitals to freeze in correlated computations. TRUE or 1 will default to freezing the previous noble gas shell on each atom. In case of positive charges on fragments, an additional shell may be unfrozen, to ensure there are valence electrons in each fragment. With FALSE or 0, no electrons are frozen (with the exception of electrons treated by an ECP). With -1, -2, and -3, the user might request strict freezing of the previous first/second/third noble gas shell on every atom. In this case, when there are no valence electrons, the code raises an exception. More precise control over the number of frozen orbitals can be attained by using the keywords NUM_FROZEN_DOCC (gives the total number of orbitals to freeze, program picks the lowest-energy orbitals) or FROZEN_DOCC (gives the number of orbitals to freeze per irreducible representation) or by the option POLICY in combination with appropriate inputs to FREEZE_CORE_POLICY. At present, POLICY is an experimental option and is subject to change. Type: string; Possible Values: FALSE, TRUE, 1, 0, -1, -2, -3, POLICY; Default: FALSE. FREEZE_CORE (SAPT)¶SAPT — The scope of core orbitals to freeze in evaluation of SAPT \(E_{disp}^{(20)}",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/autodoc_glossary_options_c.html:140625,charge,charges,140625,psi4manual/master/autodoc_glossary_options_c.html,https://psicode.org,https://psicode.org/psi4manual/master/autodoc_glossary_options_c.html,1,['charge'],['charges']
Energy Efficiency,"ally return Molecule dictionary intermediate.; verbose (int, optional) – Amount of printing. Returns:; mol (psi4.core.Molecule); molrec (dict, optional) – Dictionary representation of instance.; Only provided if return_dict is True. classmethod from_string(molstr, dtype=None, name=None, fix_com=None, fix_orientation=None, fix_symmetry=None, return_dict=False, enable_qm=True, enable_efp=True, missing_enabled_return_qm='none', missing_enabled_return_efp='none', verbose=1). fx(self: psi4.core.Molecule, arg0: int) → float; x position of atom arg1 (0-indexed including dummies in Bohr). fy(self: psi4.core.Molecule, arg0: int) → float; y position of atom arg1 (0-indexed including dummies in Bohr). fz(self: psi4.core.Molecule, arg0: int) → float; z position of atom arg1 (0-indexed including dummies in Bohr). geometry(self: psi4.core.Molecule) → psi4.core.Matrix; Gets the geometry as a (Natom X 3) matrix of coordinates (in Bohr). get_fragment_charges(self: psi4.core.Molecule) → List[int]; Gets the charge of each fragment. get_fragment_multiplicities(self: psi4.core.Molecule) → List[int]; Gets the multiplicity of each fragment. get_fragment_types(self: psi4.core.Molecule) → List[str]; Returns a list describing how to handle each fragment {Real, Ghost, Absent}. get_fragments(self: psi4.core.Molecule) → List[Tuple[int, int]]; Returns list of pairs of atom ranges defining each fragment from parent molecule(fragments[frag_ind] = <Afirst,Alast+1>). get_full_point_group(self: psi4.core.Molecule) → str; Gets point group name such as C3v or S8. get_variable(self: psi4.core.Molecule, arg0: str) → float; Checks if variable arg2 is in the list, sets it to val and returns true if it is, and returns false if not. inertia_tensor(self: psi4.core.Molecule) → psi4.core.Matrix; Returns intertial tensor. input_units_to_au(self: psi4.core.Molecule) → float; Returns unit conversion to [a0] for geometry. irrep_labels(self: psi4.core.Molecule) → List[str]; Returns Irreducible Representation symmetr",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/api/psi4.core.molecule.html:42718,charge,charge,42718,psi4manual/1.2.1/api/psi4.core.molecule.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/api/psi4.core.molecule.html,1,['charge'],['charge']
Energy Efficiency,"ally; converged orbital which should be occupied in the fully-optimized SCF solution; has a slightly higher orbital eigenvalue than some other orbital which should be; destined to be a virtual orbital. This results in the virtual orbital being; spuriously occupied for one or more iterations. Sometimes this resolves itself; without help, other times the occupation flips back and forth between two, four,; or more orbitals. This is typically visible in the output as a non-converging; SCF which eventually settles down to steady oscillation between two (or more); different total energies. This behavior can be ameliorated by choosing occupied; orbitals by “shape” instead of by orbital eigenvalue, i.e., by choosing the set; of new orbitals which looks most like some previously known “good” set. The; “good” set is typically the occupied orbitals from one of the oscillating; iterations with the lowest total energy. For an oscillating system where the; lowest total energy occurs on iterations \(N,N+2,\ldots\), invoking; MOM_START N can often rescue the convergence of the SCF. MOM can; be used in concert with DIIS, though care should be taken to not turn MOM on; until the oscillatory behavior begins. Damping [Off by Default]In some cases, a static mixing of Fock Matrices from adjacent; iterations can quench oscillations. This mixing, known as; “damping” can be activated by setting the; DAMPING_PERCENTAGE keyword to a nonzero percent. Damping is; turned off when the DIIS error is smaller than; DAMPING_CONVERGENCE. Level shifting [Off by default]A commonly used alternative to damping is to use level shifting,; which decreases the mixing of occupied and unoccupied orbitals in; the SCF update by moving the unoccupied orbitals up in energy. It; can be shown that the SCF procedure always converges with a; suitably large level shift; however, the larger the shift is, the; slower the convergence becomes, and the calculation may end up; converging onto a higher lying SCF solution. Becau",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/scf-1.html:22695,energy,energy,22695,psi4manual/1.4.0/scf-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/scf-1.html,9,['energy'],['energy']
Energy Efficiency,"ally; converged orbital which should be occupied in the fully-optimized SCF solution; has a slightly higher orbital eigenvalue than some other orbital which should be; destined to be a virtual orbital. This results in the virtual orbital being; spuriously occupied for one or more iterations. Sometimes this resolves itself; without help, other times the occupation flips back and forth between two, four,; or more orbitals. This is typically visible in the output as a non-converging; SCF which eventually settles down to steady oscillation between two (or more); different total energies. This behavior can be ameliorated by choosing occupied; orbitals by “shape” instead of by orbital eigenvalue, i.e., by choosing the set; of new orbitals which looks most like some previously known “good” set. The; “good” set is typically the occupied orbitals from one of the oscillating; iterations with the lowest total energy. For an oscillating system where the; lowest total energy occurs on iterations \(N,N+2,\ldots\), invoking; MOM_START N can often rescue the convergence of the SCF. MOM can; be used in concert with DIIS, though care should be taken to not turn MOM on; until the oscillatory behavior begins.; Damping [Off by Default]; In some cases, a static mixing of Fock Matrices from adjacent iterations can; quench oscillations. This mixing, known as “damping” can be activated by setting; the DAMPING_PERCENTAGE keyword to a nonzero percent.; SOSCF [Off by Default]; See Second-order Convergence. ERI Algorithms¶; The key difficulty in the SCF procedure is treatment of the four-index ERI; contributions to the Fock Matrix. A number of algorithms are available in; PSI4 for these terms. The algorithm is selected by the SCF_TYPE; keyword, which may be one of the following. PK [Default]; An out-of-core, presorted algorithm using exact ERIs. Quite fast for a; zero-error algorithm if enough memory is available. Integrals are; generated only once, and symmetry is utilized to reduce number of; ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/scf-1.html:19838,energy,energy,19838,psi4manual/1.1.0/scf-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/scf-1.html,6,['energy'],['energy']
Energy Efficiency,"alpha = 3.4`. Returns; -------; float or ~numpy.ndarray; Eponymous function applied to input zetas and values; type from `valueLO`. Notes; -----; The extrapolation is calculated according to [2]_:; :math:`E_{total}^X = E_{total}^{\infty} + \beta X^{-\alpha}, \alpha = 3.4`. References; ----------. .. [2] Truhlar, Chem. Phys. Lett. 294 (1998) 45-48,; DOI: 10.1016/S0009-2614(98)00866-5. """""". if type(valueLO) != type(valueHI):; raise ValidationError(; f""scf_xtpl_truhlar_2: Inputs must be of the same datatype! ({type(valueLO)}, {type(valueHI)})""). if alpha is None:; alpha = 3.40. beta_division = 1 / (zHI**(-1 * alpha) - zLO**(-1 * alpha)); beta_mult = zHI**(-1 * alpha). if isinstance(valueLO, float):; beta = (valueHI - valueLO) * beta_division; value = valueHI - beta * beta_mult. if verbose:; # Output string with extrapolation parameters; cbsscheme = ''; cbsscheme += """"""\n ==> Truhlar 2-point power form SCF extrapolation for method: %s <==\n\n"""""" % (; functionname.upper()); cbsscheme += """""" LO-zeta (%s) Energy: % 16.12f\n"""""" % (str(zLO), valueLO); cbsscheme += """""" HI-zeta (%s) Energy: % 16.12f\n"""""" % (str(zHI), valueHI); cbsscheme += """""" Alpha (exponent) Value: % 16.12f\n"""""" % (alpha); cbsscheme += """""" Beta (coefficient) Value: % 16.12f\n\n"""""" % (beta). name_str = ""%s/(%s,%s)"" % (functionname.upper(), _zeta_val2sym[zLO].upper(), _zeta_val2sym[zHI].upper()); cbsscheme += """""" @Extrapolated """"""; cbsscheme += name_str + ':'; cbsscheme += "" "" * (18 - len(name_str)); cbsscheme += """"""% 16.12f\n\n"""""" % value; core.print_out(cbsscheme); logger.debug(cbsscheme). return value. elif isinstance(valueLO, np.ndarray):. beta = (valueHI - valueLO) * beta_division; value = valueHI - beta * beta_mult. if verbose > 2:; cbsscheme = f""""""\n ==> Truhlar 2-point power SCF extrapolation for method: {functionname.upper()} <==\n""""""; cbsscheme += f""""""\n LO-zeta ({zLO}) Data\n""""""; cbsscheme += nppp(valueLO); cbsscheme += f""""""\n HI-zeta ({zHI}) Data\n""""""; cbsscheme += nppp(valueHI). cbsscheme += f""""""\n",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver_cbs_helper.html:8522,Energy,Energy,8522,psi4manual/1.7.x/_modules/psi4/driver/driver_cbs_helper.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver_cbs_helper.html,4,['Energy'],['Energy']
Energy Efficiency,"alpha(0.81); vwn = build_functional('VWN3RPA_C'); vwn.set_alpha(0.19); sup.add_c_functional(vwn); sup.add_c_functional(lyp). # Set GKS up after adding functionals; sup.set_x_omega(0.0); sup.set_c_omega(0.0); sup.set_x_alpha(0.2); sup.set_c_alpha(0.0). # => End User-Customization <= #. # Call this last; sup.allocate(); return sup. [docs]def build_hf_x_superfunctional(name, npoints, deriv):. # Call this first; sup = psi4.SuperFunctional.blank(); sup.set_max_points(npoints); sup.set_deriv(deriv). # => User-Customization <= #. # No spaces, keep it short and according to convention; sup.set_name('HF_X'); # Tab in, trailing newlines; sup.set_description(' Hartree-Fock Exchange Functional\n'); # Tab in, trailing newlines; sup.set_citation(' \n'). # Add member functionals; hf_x = build_functional('hf_x'); hf_x.set_alpha(1.0); sup.add_x_functional(hf_x). # Set GKS up after adding functionals; sup.set_x_omega(0.0); sup.set_c_omega(0.0); sup.set_x_alpha(1.0); sup.set_c_alpha(0.0). sup.allocate(); return sup. [docs]def build_b3lyp5_superfunctional(name, npoints, deriv):. # Call this first; sup = psi4.SuperFunctional.blank(); sup.set_max_points(npoints); sup.set_deriv(deriv). # => User-Customization <= #. # No spaces, keep it short and according to convention; sup.set_name('B3LYP5'); # Tab in, trailing newlines; sup.set_description(' B3LYP5 Hybrid-GGA Exchange-Correlation Functional (VWN5)\n'); # Tab in, trailing newlines; sup.set_citation(' P.J. Stephens et. al., J. Phys. Chem., 98, 11623-11627, 1994\n'). # Add member functionals; b3 = build_functional('B3_X'); b3.set_alpha(1.0); sup.add_x_functional(b3); lyp = build_functional('LYP_C'); lyp.set_alpha(0.81); vwn = build_functional('VWN5_C'); vwn.set_alpha(0.19); sup.add_c_functional(lyp); sup.add_c_functional(vwn). # Set GKS up after adding functionals; sup.set_x_omega(0.0); sup.set_c_omega(0.0); sup.set_x_alpha(0.2); sup.set_c_alpha(0.0). # => End User-Customization <= #. # Call this last; sup.allocate(); return sup. [docs]def ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/procedures/functional.html:33755,allocate,allocate,33755,psi4manual/1.0.0/_modules/procedures/functional.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/procedures/functional.html,1,['allocate'],['allocate']
Energy Efficiency,"alpha=None)[source]¶; Extrapolation scheme for correlation energies with two adjacent zeta-level bases.; Used by cbs(). Parameters:; functionname (str) – Name of the CBS component.; zLO (int) – Lower zeta level.; valueLO (float) – Lower value used for extrapolation.; zHI (int) – Higher zeta level. Should be equal to zLO + 1.; valueHI (float) – Higher value used for extrapolation.; alpha (float, optional) – Overrides the default \(\alpha = 3.0\). Returns:Returns \(E_{total}^{\infty}\), see below. Return type:float. Notes; The extrapolation is calculated according to [5]:; \(E_{corl}^X = E_{corl}^{\infty} + \beta X^{-alpha}\); References. [5]Halkier, Helgaker, Jorgensen, Klopper, Koch, Olsen, & Wilson,; Chem. Phys. Lett. 286 (1998) 243-252,; DOI: 10.1016/S0009-2614(99)00179-7. psi4.driver.driver_cbs._get_default_xtpl(nbasis, xtpl_type)[source]¶; A helper function to determine default extrapolation type. Parameters:; nbasis (int) – Number of basis sets; xtpl_type ({'scf', 'corl'}) – Extrapolation type: ‘scf’ for the total energy, ‘corl’ for just the; correlation component. Returns:Extrapolation function to be used. Return type:function. Aliases¶; When a particular composite method or its functional form is going to be; reused often, it is convenient to define an alias to it. A convenient; place for such Python code to reside is in psi4/psi4/driver/aliases.py; (source location) or psi4/lib/psi4/driver/aliases.py (installed; location). No recompilation is necessary after defining an alias. Some; existing examples are below. psi4.driver.aliases.sherrill_gold_standard(func, label, **kwargs)[source]¶; Function to call the quantum chemical method known as ‘Gold Standard’; in the Sherrill group. Uses complete_basis_set() to evaluate; the following expression. Two-point extrapolation of the correlation energy; performed according to corl_xtpl_helgaker_2(). \[E_{total}^{\text{Au\_std}} = E_{total,\; \text{SCF}}^{\text{aug-cc-pVQZ}} \; + E_{corl,\; \text{MP2}}^{\text{aug-cc-pV[T",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/cbs-1.html:19822,energy,energy,19822,psi4manual/1.3.2/cbs-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/cbs-1.html,2,['energy'],['energy']
Energy Efficiency,"alpha\beta,1}; C.set_parameter('B97_os_a2', -1.20477E1) # Table 1: c_{c\alpha\beta,2}; C.set_parameter('B97_os_a3', 1.40847E1) # Table 1: c_{c\alpha\beta,3}; C.set_parameter('B97_os_a4', -8.50809E0) # Table 1: c_{c\alpha\beta,4}. C.set_parameter('B97_ss_gamma', 0.2); C.set_parameter('B97_ss_a0', 1.0) # Table 1: c_{c\sigma\sigma,0}; C.set_parameter('B97_ss_a1', -6.90539E0) # Table 1: c_{c\sigma\sigma,1}; C.set_parameter('B97_ss_a2', 3.13343E1) # Table 1: c_{c\sigma\sigma,2}; C.set_parameter('B97_ss_a3', -5.10533E1) # Table 1: c_{c\sigma\sigma,3}; C.set_parameter('B97_ss_a4', 2.64423E1) # Table 1: c_{c\sigma\sigma,4}. sup.add_x_functional(X); sup.add_c_functional(C). # Set GKS up after adding functionals; sup.set_x_omega(omega) # Table 1: omega; sup.set_c_omega(0.0); sup.set_x_alpha(alpha) # Table 1: c_x; sup.set_c_alpha(0.0). # => -D2 (CHG Damping Function) <= #; sup.set_dispersion(PsiMod.Dispersion.build('-CHG', 1.0)). # => End User-Customization <= #. # Call this last; sup.allocate(); return sup. [docs]def build_m05_superfunctional(name, npoints, deriv):. # Call this first; sup = PsiMod.SuperFunctional.blank(); sup.set_max_points(npoints); sup.set_deriv(deriv). # => User-Customization <= #. # No spaces, keep it short and according to convention; sup.set_name('M05'); # Tab in, trailing newlines; sup.set_description(' Heavily Parameterized Hybrid Meta-GGA XC Functional\n'); # Tab in, trailing newlines; sup.set_citation(' Zhao et. al., J. Chem. Phys., 123, 161103, 2005\n'). # Add member functionals; X = build_functional('M_X'); X.set_name('M05_X'); X.set_alpha(1.0). # LSDA Exchange type is Slater, no parameters. # GGA Exchange type is PBE, special parameters because Truhlar is lazy; C1 = 3.36116E-3 # Should be reported/implemented to more digits; C2 = 4.49267E-3 # Should be reported/implemented to more digits; K0 = 3.0 / 2.0 * math.pow(3.0 / (math.pi * 4.0), 1.0 / 3.0); k0 = math.pow(6.0 * math.pi * math.pi, 1.0 / 3.0); kp = C1 / (C2 * K0); mu = 4.0 * k0 * k0 * kp * C2",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/_modules/functional.html:49550,allocate,allocate,49550,psi4manual/4.0b2/_modules/functional.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/functional.html,2,['allocate'],['allocate']
Energy Efficiency,"alpha\beta,1}; C.set_parameter('B97_os_a2', -1.20477E1) # Table 1: c_{c\alpha\beta,2}; C.set_parameter('B97_os_a3', 1.40847E1) # Table 1: c_{c\alpha\beta,3}; C.set_parameter('B97_os_a4', -8.50809E0) # Table 1: c_{c\alpha\beta,4}. C.set_parameter('B97_ss_gamma', 0.2); C.set_parameter('B97_ss_a0', 1.0) # Table 1: c_{c\sigma\sigma,0}; C.set_parameter('B97_ss_a1', -6.90539E0) # Table 1: c_{c\sigma\sigma,1}; C.set_parameter('B97_ss_a2', 3.13343E1) # Table 1: c_{c\sigma\sigma,2}; C.set_parameter('B97_ss_a3', -5.10533E1) # Table 1: c_{c\sigma\sigma,3}; C.set_parameter('B97_ss_a4', 2.64423E1) # Table 1: c_{c\sigma\sigma,4}. sup.add_x_functional(X); sup.add_c_functional(C). # Set GKS up after adding functionals; sup.set_x_omega(omega) # Table 1: omega; sup.set_c_omega(0.0); sup.set_x_alpha(alpha) # Table 1: c_x; sup.set_c_alpha(0.0). # => -D2 (CHG Damping Function) <= #; sup.set_dispersion(PsiMod.Dispersion.build('-CHG', 1.0)). # => End User-Customization <= #. # Call this last; sup.allocate(); return sup. [docs]def build_m05_superfunctional(name, npoints, deriv):. # Call this first; sup = PsiMod.SuperFunctional.blank(); sup.set_max_points(npoints); sup.set_deriv(deriv). # => User-Customization <= #. # No spaces, keep it short and according to convention; sup.set_name('M05'); # Tab in, trailing newlines; sup.set_description(' Heavily Parameterized Hybrid Meta-GGA XC Functional\n'); # Tab in, trailing newlines; sup.set_citation(' Zhao et. al., J. Chem. Phys., 123, 161103, 2005\n'). # Add member functionals; X = build_functional('M_X'); X.set_name('M05_X'); X.set_alpha(1.0). # LSDA Exchange type is Slater, no parameters. # GGA Exchange type is PBE, special parameters because Truhlar is lazy; C1 = 3.36116E-3; C2 = 4.49267E-3; K0 = 3.0 / 2.0 * math.pow(3.0 / (math.pi * 4.0), 1.0 / 3.0); k0 = math.pow(6.0 * math.pi * math.pi, 1.0 / 3.0); kp = C1 / (C2 * K0); mu = 4.0 * k0 * k0 * kp * C2; X.set_parameter('PBE_kp', kp) # Different effective kp; X.set_parameter('PBE_mu', mu) # Differ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/_modules/functional.html:53034,allocate,allocate,53034,psi4manual/4.0b3/_modules/functional.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/_modules/functional.html,2,['allocate'],['allocate']
Energy Efficiency,"als are fully independent of each; other, which allows a considerable amount of flexibility in the wavefunction.; However, this flexibility comes at the cost of spin symmetry; UHF wavefunctions; need not be eigenfunctions of the operator. The deviation of; this operator from its expectation value is printed on the output file. If the; deviation is greater than a few hundredths, it is advisable to switch to an; ROHF to avoid this “spin-contamination” problem.; Restricted Open-Shell Hartree-Fock (ROHF); Appropriate for open-shell systems where spin-contamination is problem.; Sometimes more difficult to converge, and assumes uniformly positive spin; polarization (the alpha and beta doubly-occupied orbitals are identical).; Constrained Unrestricted Hartree-Fock (CUHF); A variant of ROHF that starts from a UHF ansatz, and is therefore often; easier to converge. These can be invoked by the REFERENCE keyword, which defaults to RHF.; The charge and multiplicity may either be specified in the molecule definition:; molecule h {; 0 2 # Neutral doublet; H; }. or, dynamically, by setting the relevant attributes in the Python molecule; object:; h.set_molecular_charge(0); h.set_multiplicity(2). Abelian spatial symmetry is fully supported in PSI4, and can be used to; obtain physical interpretation of the molecular orbitals, to assist in difficult; convergence cases, and, in some methods, to obtain significant performance; gains. The point group of the molecule is inferred when reading the molecule; section, and may be overridden by the symmetry flag, as in:; molecule h {; 0 2; H; symmetry c1; }. or by the set_point_group Python molecule attribute:; h.set_point_group('c2v'). During the SCF procedure, the occupation of orbitals is typically determined by; the Aufbau principal across all spatial symmetries. This may result in the; occupation shifting between iterations. If the occupations are known a priori,; they may be clamped throughout the procedure by using the DOCC and; SOCC opti",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/scf-1.html:6999,charge,charge,6999,psi4manual/4.0b2/scf-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/scf-1.html,8,['charge'],['charge']
Energy Efficiency,"als are fully independent of each; other, which allows a considerable amount of flexibility in the wavefunction.; However, this flexibility comes at the cost of spin symmetry; UHF wavefunctions; need not be eigenfunctions of the operator. The deviation of; this operator from its expectation value is printed on the output file. If the; deviation is greater than a few hundredths, it is advisable to switch to an; ROHF to avoid this “spin-contamination” problem.; Restricted Open-Shell Hartree-Fock (ROHF); Appropriate for open-shell systems where spin-contamination is problem.; Sometimes more difficult to converge, and assumes uniformly positive spin; polarization (the alpha and beta doubly-occupied orbitals are identical).; Constrained Unrestricted Hartree-Fock (CUHF); A variant of ROHF that starts from a UHF ansatz, and is therefore often; easier to converge. These can be invoked by the REFERENCE keyword, which defaults to RHF.; The charge and multiplicity may either be specified in the molecule definition:; molecule h {; 0 2 # Neutral doublet; H; }. or, dynamically, by setting the relevant attributes in the Python molecule; object:; h.set_molecular_charge(0); h.set_multiplicity(2). Abelian spatial symmetry is fully supported in Psi4, and can be used to; obtain physical interpretation of the molecular orbitals, to assist in difficult; convergence cases, and, in some methods, to obtain significant performance; gains. The point group of the molecule is inferred when reading the molecule; section, and may be overridden by the symmetry flag, as in:; molecule h {; 0 2; H; symmetry c1; }. or by the set_point_group Python molecule attribute:; h.set_point_group('c2v'). During the SCF procedure, the occupation of orbitals is typically determined by; the Aufbau principal across all spatial symmetries. This may result in the; occupation shifting between iterations. If the occupations are known a priori,; they may be clamped throughout the procedure by using the DOCC and; SOCC opti",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/scf-1.html:7681,charge,charge,7681,psi4manual/1.0.0/scf-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/scf-1.html,2,['charge'],['charge']
Energy Efficiency,"als from a previous computation, or to compute an MP2 guess. Type: string; Possible Values: CC, BCC, MP2, DCT; Default: MP2. DCT_TYPE (DCT)¶DCT — What algorithm to use for the DCT computation. Type: string; Possible Values: CONV, DF; Default: CONV. DEBUG (CCDENSITY)¶CCDENSITY — Reproducing energies from densities ?. Type: integer; Default: 0. DEBUG (CPHF)¶CPHF — The amount of debug information printed to the output file. Type: integer; Default: 0. DEBUG (GLOBALS)¶GLOBALS (Expert) — The amount of information to print to the output file. Type: integer; Default: 0. DELETE_TEI (CCTRANSORT)¶CCTRANSORT — Delete the SO two-electron integrals after the transformation?. Type: boolean; Default: true. DENOMINATOR_ALGORITHM (SAPT)¶SAPT — Denominator algorithm for PT methods. Laplace transformations are slightly more efficient. Type: string; Possible Values: LAPLACE, CHOLESKY; Default: LAPLACE. DENOMINATOR_DELTA (SAPT)¶SAPT — Maximum error allowed (Max error norm in Delta tensor) in the approximate energy denominators employed for most of the \(E_{disp}^{(20)}\) and \(E_{exch-disp}^{(20)}\) evaluation. Type: double; Default: 1.0e-6. DERTYPE (EFP)¶EFP (Expert) — Do EFP gradient?. Type: string; Possible Values: NONE, FIRST; Default: NONE. DERTYPE (GLOBALS)¶GLOBALS (Expert) — Derivative level. Type: string; Possible Values: NONE, FIRST, SECOND, RESPONSE; Default: NONE. DETCI_FREEZE_CORE (DETCI)¶DETCI — Do freeze core orbitals?. Type: boolean; Default: true. DF_BASIS_CC (FNOCC)¶FNOCC — Auxilliary basis for df-ccsd(t). Type: string; Possible Values: basis string; Default: No Default. DF_BASIS_CC (GLOBALS)¶GLOBALS — The density fitting basis to use in coupled cluster computations. Type: string; Possible Values: basis string; Default: No Default. DF_BASIS_DCT (DCT)¶DCT — Auxiliary basis set for DCT density fitting computations. Defaults to a RI basis. Type: string; Possible Values: basis string; Default: No Default. DF_BASIS_ELST (SAPT)¶SAPT — Auxiliary basis set for SAPT Elst10 and Ex",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/autodoc_glossary_options_c-1.html:96561,energy,energy,96561,psi4manual/1.4.0/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodoc_glossary_options_c-1.html,5,['energy'],['energy']
Energy Efficiency,"als from which to compute properties. How to specify args, which are actually the most important. :type title: string; :param title: label prepended to all psivars computed. :examples:. >>> # [1] Moments with specific label; >>> E, wfn = energy('hf', return_wfn=True); >>> oeprop(wfn, 'DIPOLE', 'QUADRUPOLE', title='H3O+ SCF'). """"""; oe = core.OEProp(wfn); if 'title' in kwargs:; oe.set_title(kwargs['title']); for prop in args:; oe.add(prop); oe.compute(). [docs]def cubeprop(wfn, **kwargs):; """"""Evaluate properties on a grid and generate cube files. .. versionadded:: 0.5; *wfn* parameter passed explicitly. :returns: None. :type wfn: :py:class:`~psi4.core.Wavefunction`; :param wfn: set of molecule, basis, orbitals from which to generate cube files. :examples:. >>> # [1] Cube files for all orbitals; >>> E, wfn = energy('b3lyp', return_wfn=True); >>> cubeprop(wfn). >>> # [2] Cube files for density (alpha, beta, total, spin) and four orbitals; >>> # (two alpha, two beta); >>> set cubeprop_tasks ['orbitals', 'density']; >>> set cubeprop_orbitals [5, 6, -5, -6]; >>> E, wfn = energy('scf', return_wfn=True); >>> cubeprop(wfn). """"""; # By default compute the orbitals; if not core.has_global_option_changed('CUBEPROP_TASKS'):; core.set_global_option('CUBEPROP_TASKS', ['ORBITALS']). if ((core.get_global_option('INTEGRAL_PACKAGE') == 'ERD') and ('ESP' in core.get_global_option('CUBEPROP_TASKS'))):; raise ValidationError('INTEGRAL_PACKAGE ERD does not play nicely with electrostatic potential, so stopping.'). cp = core.CubeProperties(wfn); cp.compute_properties(). [docs]def set_memory(inputval, execute=True):; """"""Function to reset the total memory allocation. Takes memory value; *inputval* as type int, float, or str; int and float are taken literally; as bytes to be set, string taken as a unit-containing value (e.g., 30 mb); which is case-insensitive. Set *execute* to False to interpret *inputval*; without setting in Psi4 core. :returns: *memory_amount* (float) Number of bytes of memory",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/p4util/util.html:2575,energy,energy,2575,psi4manual/1.3.2/_modules/psi4/driver/p4util/util.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/p4util/util.html,2,['energy'],['energy']
Energy Efficiency,"als from which to compute properties. How to specify args, which are actually the most important. :type title: string; :param title: label prepended to all psivars computed. :examples:. >>> # [1] Moments with specific label; >>> E, wfn = energy('hf', return_wfn=True); >>> oeprop(wfn, 'DIPOLE', 'QUADRUPOLE', title='H3O+ SCF'). """"""; oe = core.OEProp(wfn); if 'title' in kwargs:; oe.set_title(kwargs['title']); for prop in args:; oe.add(prop); oe.compute(). [docs]def cubeprop(wfn, **kwargs):; """"""Evaluate properties on a grid and generate cube files. .. versionadded:: 0.5; *wfn* parameter passed explicitly. :returns: None. :type wfn: :py:class:`~psi4.core.Wavefunction`; :param wfn: set of molecule, basis, orbitals from which to generate cube files. :examples:. >>> # [1] Cube files for all orbitals; >>> E, wfn = energy('b3lyp', return_wfn=True); >>> cubeprop(wfn). >>> # [2] Cube files for density (alpha, beta, total, spin) and four orbitals; >>> # (two alpha, two beta); >>> set cubeprop_tasks ['orbitals', 'density']; >>> set cubeprop_orbitals [5, 6, -5, -6]; >>> E, wfn = energy('scf', return_wfn=True); >>> cubeprop(wfn). """"""; # By default compute the orbitals; if not core.has_global_option_changed('CUBEPROP_TASKS'):; core.set_global_option('CUBEPROP_TASKS',['ORBITALS']). if ((core.get_global_option('INTEGRAL_PACKAGE') == 'ERD') and; ('ESP' in core.get_global_option('CUBEPROP_TASKS'))):; raise ValidationError('INTEGRAL_PACKAGE ERD does not play nicely with electrostatic potential, so stopping.'). cp = core.CubeProperties(wfn); cp.compute_properties(). [docs]def set_memory(inputval, execute=True):; """"""Function to reset the total memory allocation. Takes memory value; *inputval* as type int, float, or str; int and float are taken literally; as bytes to be set, string taken as a unit-containing value (e.g., 30 mb); which is case-insensitive. Set *execute* to False to interpret *inputval*; without setting in Psi4 core. :returns: *memory_amount* (float) Number of bytes of memory",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/p4util/util.html:2531,energy,energy,2531,psi4manual/1.1.0/_modules/psi4/driver/p4util/util.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/p4util/util.html,1,['energy'],['energy']
Energy Efficiency,"als per irrep. efzc(self: psi4.core.Wavefunction) → float¶; Returns the frozen-core energy. energy(self: psi4.core.Wavefunction) → float¶; Returns the Wavefunction’s energy. epsilon_a(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the Alpha Eigenvalues. epsilon_a_subset(self: psi4.core.Wavefunction, arg0: str, arg1: str) → psi4.core.Vector¶; Returns the requested Alpha Eigenvalues subset. epsilon_b(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the Beta Eigenvalues. epsilon_b_subset(self: psi4.core.Wavefunction, arg0: str, arg1: str) → psi4.core.Vector¶; Returns the requested Beta Eigenvalues subset. esp_at_nuclei(self: psi4.core.Wavefunction) → psi4.core.Vector¶; returns electrostatic potentials at nuclei. external_pot(self: psi4.core.Wavefunction) → psi4.core.ExternalPotential¶; Gets the requested external potential. finalize(self: psi4.core.HF) → None¶; Cleans up the the Wavefunction’s temporary data. finalize_energy()¶; Performs stability analysis and calls back SCF with new guess; if needed, Returns the SCF energy. This function should be called; once orbitals are ready for energy/property computations, usually; after iterations() is called. find_occupation(self: psi4.core.HF) → None¶; docstring. force_doccpi(self: psi4.core.Wavefunction, arg0: psi4.core.Dimension) → None¶; Specialized expert use only. Sets the number of doubly occupied oribtals per irrep. Note that this results in inconsistent Wavefunction objects for SCF, so caution is advised. force_soccpi(self: psi4.core.Wavefunction, arg0: psi4.core.Dimension) → None¶; Specialized expert use only. Sets the number of singly occupied oribtals per irrep. Note that this results in inconsistent Wavefunction objects for SCF, so caution is advised. form_C(self: psi4.core.HF, shift: float = 0.0) → None¶; Forms the Orbital Matrices from the current Fock Matrices. form_D(self: psi4.core.HF) → None¶; Forms the Density Matrices from the current Orbitals Matrices. form_F(self: psi4.core.HF) → No",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/api/psi4.core.cuhf.html:20711,energy,energy,20711,psi4manual/1.4.0/api/psi4.core.cuhf.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/api/psi4.core.cuhf.html,8,['energy'],['energy']
Energy Efficiency,"als). Type: conv double; Default: 1e-5. SCS_TYPE¶. Type of the SCS method. Type: string; Possible Values: SCS, SCSN, SCSVDW, SCSMI; Default: SCS. SOS_TYPE¶. Type of the SOS method. Type: string; Possible Values: SOS, SOSPI; Default: SOS. SS_SCALE¶. A custom scaling parameter for same-spin terms in OCC. The result goes to a CUSTOM SCS variable, exact name method-dependent. Type: double; Default: 1. SYMMETRIZE¶. Do symmetrize the GFM and OPDM in the EKT computations?. Type: boolean; Default: true. TPDM_ABCD_TYPE¶. How to take care of the TPDM VVVV-block. The COMPUTE option means it will be computed via an IC/OOC algorithm. The DIRECT option (default) means it will not be computed and stored, instead its contribution will be directly added to Generalized-Fock Matrix. Type: string; Possible Values: DIRECT, COMPUTE; Default: DIRECT. WFN_TYPE¶. Type of the wavefunction. Type: string; Possible Values: OMP2, OMP3, OCEPA, OMP2.5; Default: OMP2. Expert¶. SPIN_SCALE_TYPE¶. Controls the spin scaling set to current energy. This is set by Psi internally. Type: string; Possible Values: NONE, CUSTOM, SCS, SCSN, SCSVDW, SOS, SOSPI; Default: NONE. table of contents. OCC; General; CACHELEVEL; CCL_ENERGY; CC_DIIS_MAX_VECS; CC_DIIS_MIN_VECS; CC_MAXITER; CEPA_OS_SCALE; CEPA_SOS_SCALE; CEPA_SS_SCALE; CEPA_TYPE; CUTOFF; DIIS_MAX_VECS; DIIS_MIN_VECS; DO_DIIS; DO_LEVEL_SHIFT; DO_SCS; DO_SOS; E3_SCALE; EA_POLES; EKT_EA; EKT_IP; EP_EA_POLES; EP_IP_POLES; EP_MAXITER; E_CONVERGENCE; IP_POLES; LEVEL_SHIFT; LINEQ_SOLVER; MAX_MOGRAD_CONVERGENCE; MOGRAD_DAMPING; MO_DIIS_NUM_VECS; MO_MAXITER; MO_READ; MO_STEP_MAX; MO_WRITE; MP2_OS_SCALE; MP2_SOS_SCALE; MP2_SOS_SCALE2; MP2_SS_SCALE; NAT_ORBS; OCC_ORBS_PRINT; OEPROP; OPT_METHOD; ORB_OPT; ORB_RESP_SOLVER; ORTH_TYPE; OS_SCALE; PCG_BETA_TYPE; PCG_CONVERGENCE; PCG_MAXITER; RELAXED; RMS_MOGRAD_CONVERGENCE; R_CONVERGENCE; SCS_TYPE; SOS_TYPE; SS_SCALE; SYMMETRIZE; TPDM_ABCD_TYPE; WFN_TYPE. Expert; SPIN_SCALE_TYPE. «; hide menu. menu; sidebar; »; . Navigation. ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/autodir_options_c/module__occ-1.html:8319,energy,energy,8319,psi4manual/1.4.0/autodir_options_c/module__occ-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/module__occ-1.html,8,['energy'],['energy']
Energy Efficiency,"als). Type: conv double; Default: 1e-5. SCS_TYPE¶. Type of the SCS method. Type: string; Possible Values: SCS, SCSN, SCSVDW, SCSMI; Default: SCS. SOS_TYPE¶. Type of the SOS method. Type: string; Possible Values: SOS, SOSPI; Default: SOS. SS_SCALE¶. A custom scaling parameter for same-spin terms in OCC. The result goes to a CUSTOM SCS variable, exact name method-dependent. Type: double; Default: 1. SYMMETRIZE¶. Do symmetrize the GFM and OPDM in the EKT computations?. Type: boolean; Default: true. TPDM_ABCD_TYPE¶. How to take care of the TPDM VVVV-block. The COMPUTE option means it will be computed via an IC/OOC algorithm. The DIRECT option (default) means it will not be computed and stored, instead its contribution will be directly added to Generalized-Fock Matrix. Type: string; Possible Values: DIRECT, COMPUTE; Default: DIRECT. WFN_TYPE¶. Type of the wavefunction. Type: string; Possible Values: OMP2, OMP3, OCEPA, OMP2.5; Default: OMP2. Expert¶. SPIN_SCALE_TYPE¶. Controls the spin scaling set to current energy. This is set by Psi internally. Type: string; Possible Values: NONE, CUSTOM, SCS, SCSN, SCSVDW, SOS, SOSPI; Default: NONE. table of contents. OCC; General; CACHELEVEL; CCL_ENERGY; CC_MAXITER; CEPA_OS_SCALE; CEPA_SOS_SCALE; CEPA_SS_SCALE; CEPA_TYPE; CUTOFF; DIIS_MAX_VECS; DIIS_MIN_VECS; DO_DIIS; DO_LEVEL_SHIFT; DO_SCS; DO_SOS; E3_SCALE; EA_POLES; EKT_EA; EKT_IP; EP_EA_POLES; EP_IP_POLES; EP_MAXITER; E_CONVERGENCE; IP_POLES; LEVEL_SHIFT; LINEQ_SOLVER; MAX_MOGRAD_CONVERGENCE; MOGRAD_DAMPING; MO_MAXITER; MO_READ; MO_STEP_MAX; MO_WRITE; MP2_OS_SCALE; MP2_SOS_SCALE; MP2_SOS_SCALE2; MP2_SS_SCALE; NAT_ORBS; OCC_ORBS_PRINT; OEPROP; OPT_METHOD; ORB_OPT; ORB_RESP_SOLVER; ORTH_TYPE; OS_SCALE; PCG_BETA_TYPE; PCG_CONVERGENCE; PCG_MAXITER; RELAXED; RMS_MOGRAD_CONVERGENCE; R_CONVERGENCE; SCS_TYPE; SOS_TYPE; SS_SCALE; SYMMETRIZE; TPDM_ABCD_TYPE; WFN_TYPE. Expert; SPIN_SCALE_TYPE. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/autodir_options_c/module__occ.html:8049,energy,energy,8049,psi4manual/1.6.x/autodir_options_c/module__occ.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/autodir_options_c/module__occ.html,2,['energy'],['energy']
Energy Efficiency,"als. mom; Maximum Overlap Method (MOM) Test. MOM is designed to stabilize SCF convergence and to target excited Slater determinants directly. props2; DF-SCF cc-pVDZ of benzene-hydronium ion, scanning the dissociation coordinate with Python’s built-in loop mechanism. The geometry is specified by a Z-matrix with dummy atoms, fixed parameters, updated parameters, and separate charge/multiplicity specifiers for each monomer. One-electron properties computed for dimer and one monomer. castup1; Test of SAD/Cast-up (mainly not dying due to file weirdness). fcidump; test FCIDUMP functionality for rhf/uhf. fnocc5; Test FNO-DF-CCSD(T) energy. cepa3; cc-pvdz H2O Test coupled-pair CISD against DETCI CISD. cc12; Single point energies of multiple excited states with EOM-CCSD. extern1; External potential calculation involving a TIP3P water and a QM water. Finite different test of the gradient is performed to validate forces. fnocc4; Test FNO-DF-CCSD(T) energy. fd-freq-energy-large; SCF DZ finite difference frequencies by energies for C4NH4. cc54; CCSD dipole with user-specified basis set. dft-grad-lr2; Tests CAM gradients with and without XC pieces to narrow grid error. sapt-dft1; SAPT(DFT) aug-cc-pVDZ interaction energy between Ne and Ar atoms. fci-h2o-fzcv; 6-31G H2O Test FCI Energy Point. pywrap-alias; Test parsed and exotic calls to energy() like zapt4, mp2.5, and cisd are working. cc4a; RHF-CCSD(T) cc-pVQZ frozen-core energy of the BH molecule, with Cartesian input. This version tests the FROZEN_DOCC option explicitly. sad1; Test of the superposition of atomic densities (SAD) guess, using a highly distorted water geometry with a cc-pVDZ basis set. This is just a test of the code and the user need only specify guess=sad to the SCF module’s (or global) options in order to use a SAD guess. The test is first performed in C2v symmetry, and then in C1. psimrcc-pt2; Mk-MRPT2 single point. \(^1A_1\) F2 state described using the Ms = 0 component of the singlet. Uses TCSCF singlet orbi",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/autodoc_testsuite_corepsi4.html:8299,energy,energy-large,8299,psi4manual/1.6.x/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/autodoc_testsuite_corepsi4.html,2,['energy'],['energy-large']
Energy Efficiency,"alse, contentsNotFilename=False):; """"""Pull information from an XYZ file. No fragment info detected.; Bohr/Angstrom pulled from first line if available. Charge,; multiplicity, tagline pulled from second line if available. Body; accepts atom symbol or atom charge in first column. Arguments; *no_com* and *no_reorient* can be used to turn off shift and; rotation. If *xyzfilename* is a string of the contents of an XYZ; file, rather than the name of a file, set *contentsNotFilename*; to ``True``. >>> H2O = qcdb.Molecule.init_with_xyz('h2o.xyz'). """"""; raise FeatureDeprecated(; """"""qcdb.Molecule.init_with_xyz. Replace with: qcdb.Molecule.from_string(..., dtype='xyz+')""""""). @classmethod; def init_with_mol2(cls, xyzfilename, no_com=False, no_reorient=False, contentsNotFilename=False):; """"""Pull information from a MOl2 file. No fragment info detected.; Bohr/Angstrom pulled from first line if available. Charge,; multiplicity, tagline pulled from second line if available. Body; accepts atom symbol or atom charge in first column. Arguments; *no_com* and *no_reorient* can be used to turn off shift and; rotation. If *xyzfilename* is a string of the contents of an XYZ; file, rather than the name of a file, set *contentsNotFilename*; to ``True``. NOTE: chg/mult NYI. >>> H2O = qcdb.Molecule.init_with_mol2('h2o.mol2'). """"""; instance = cls(); instance.lock_frame = False; instance.PYmove_to_com = not no_com; instance.PYfix_orientation = no_reorient. if contentsNotFilename:; text = xyzfilename.splitlines(); else:; try:; infile = open(xyzfilename, 'r'); except IOError:; raise ValidationError(; """"""Molecule::init_with_mol2: given filename '%s' does not exist."""""" % (xyzfilename)); if os.stat(xyzfilename).st_size == 0:; raise ValidationError(""""""Molecule::init_with_mol2: given filename '%s' is blank."""""" % (xyzfilename)); text = infile.readlines(). # fixed-width regex ((?=[ ]*-?\d+)[ -\d]{5}); v2000 = re.compile(r'^((?=[ ]*\d+)[ \d]{3})((?=[ ]*\d+)[ \d]{3})(.*)V2000\s*$'); vend = re.compile(r'^\s*",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/qcdb/molecule.html:5827,charge,charge,5827,psi4manual/1.3.2/_modules/psi4/driver/qcdb/molecule.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/qcdb/molecule.html,15,['charge'],['charge']
Energy Efficiency,"alse. DO_TRIPLETS (CPHF)¶CPHF — Do triplet states? Default true. Type: boolean; Default: true. DOCC (GLOBALS)¶GLOBALS — An array containing the number of doubly-occupied orbitals per irrep (in Cotton order). Type: array; Default: No Default. DOCC (MCSCF)¶MCSCF — The number of doubly occupied orbitals, per irrep. Type: array; Default: No Default. DYNAMIC_LEVEL (OPTKING)¶OPTKING — Starting level for dynamic optimization (0=nondynamic, higher=>more conservative). Type: integer; Default: 0. E3_SCALE (DFOCC)¶DFOCC — CEPA opposite-spin scaling value from SCS-CCSD. Type: double; Default: 0.25. E3_SCALE (OCC)¶OCC — Scaling value for 3rd order energy correction (S. Grimme, Vol. 24, pp. 1529, J. Comput. Chem.). Type: double; Default: 0.25. E_CONVERGENCE (CCENERGY)¶CCENERGY — Convergence criterion for energy. See Table Post-SCF Convergence for default convergence criteria for different calculation types. Type: conv double; Default: 1e-6. E_CONVERGENCE (CCEOM)¶CCEOM — Convergence criterion for excitation energy (change) in the Davidson algorithm for CC-EOM. See Table Post-SCF Convergence for default convergence criteria for different calculation types. Type: conv double; Default: 1e-6. E_CONVERGENCE (DCT)¶DCT — Convergence criterion for energy. See Table Post-SCF Convergence for default convergence criteria for different calculation types. Type: conv double; Default: 1e-10. E_CONVERGENCE (DETCI)¶DETCI — Convergence criterion for energy. See Table Post-SCF Convergence for default convergence criteria for different calculation types. Type: conv double; Default: 1e-6. E_CONVERGENCE (DFOCC)¶DFOCC — Convergence criterion for energy. See Table Post-SCF Convergence for default convergence criteria for different calculation types. Type: conv double; Default: 1e-6. E_CONVERGENCE (FNOCC)¶FNOCC — Convergence criterion for CC energy. See Table Post-SCF Convergence for default convergence criteria for different calculation types. Note that convergence is met only when E_CONVERGENCE and R_CON",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/autodoc_glossary_options_c-1.html:116787,energy,energy,116787,psi4manual/1.4.0/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodoc_glossary_options_c-1.html,2,['energy'],['energy']
Energy Efficiency,"alse; if core.get_option(""DETCI"", ""NAT_ORBS""):; ciwfn.ci_nat_orbs(); print_nos = True. proc_util.print_ci_results(ciwfn, name.upper(), ciwfn.variable(""HF TOTAL ENERGY""), ciwfn.variable(""CURRENT ENERGY""), print_nos). core.print_out(""\t\t \""A good bug is a dead bug\"" \n\n""); core.print_out(""\t\t\t - Starship Troopers\n\n""); core.print_out(""\t\t \""I didn't write FORTRAN. That's the problem.\""\n\n""); core.print_out(""\t\t\t - Edward Valeev\n""). if core.get_global_option(""DIPMOM"") and (""mp"" not in name.lower()):; # We always would like to print a little dipole information; oeprop = core.OEProp(ciwfn); oeprop.set_title(name.upper()); oeprop.add(""DIPOLE""); oeprop.compute(); ciwfn.oeprop = oeprop; core.set_variable(""CURRENT DIPOLE"", core.variable(name.upper() + "" DIPOLE"")). ciwfn.cleanup_ci(); ciwfn.cleanup_dpd(); _clean_detci(). for lvl in range(4, 11):; if ciwfn.has_variable(f""MP{lvl} CORRELATION ENERGY"") and ciwfn.has_variable(f""MP{lvl-1} CORRELATION ENERGY""):; ciwfn.set_variable(f""MP{lvl} CORRECTION ENERGY"", ciwfn.variable(f""MP{lvl} CORRELATION ENERGY"") - ciwfn.variable(f""MP{lvl-1} CORRELATION ENERGY"")); core.set_variable(f""MP{lvl} CORRECTION ENERGY"", ciwfn.variable(f""MP{lvl} CORRELATION ENERGY"") - ciwfn.variable(f""MP{lvl-1} CORRELATION ENERGY"")). optstash.restore(); return ciwfn. def run_dfmp2(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a density-fitted MP2 calculation. """"""; optstash = p4util.OptionsState(; ['DF_BASIS_MP2'],; ['SCF_TYPE']). # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'); core.print_out("""""" SCF Algorithm Type (re)set to DF.\n""""""). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. core.tstart(); core.print_out('\n'); p4util.banner('DFMP2'); core.print_out('\n'). if core.get_global_option('REFERENCE') == ""ROHF"":; ref_wfn.semicanonicaliz",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:135581,ENERGY,ENERGY,135581,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,4,['ENERGY'],['ENERGY']
Energy Efficiency,"alse; os.chdir('..'); try:; if keep or ('path' in kwargs):; core.print_out('\n CFOUR scratch files have been kept in %s\n' % (psioh.get_default_path() + cfour_tmpdir)); else:; shutil.rmtree(cfour_tmpdir); except OSError as e:; print('Unable to remove CFOUR temporary directory %s' % e, file=sys.stderr); exit(1). # Return to submission directory and reopen output file; os.chdir(current_directory). core.print_out('\n'); p4util.banner(' Cfour %s %s Results ' % (name.lower(), calledby.capitalize())); core.print_variables(); if c4grad is not None:; psi_grad.print_out(). core.print_out('\n'); p4util.banner(' Cfour %s %s Results ' % (name.lower(), calledby.capitalize())); core.print_variables(); if c4grad is not None:; psi_grad.print_out(). # Quit if Cfour threw error; if 'CFOUR ERROR CODE' in core.variables():; raise ValidationError(""""""Cfour exited abnormally.""""""). P4C4_INFO.clear(); P4C4_INFO.update(internal_p4c4_info). optstash.restore(). # new skeleton wavefunction w/mol, highest-SCF basis (just to choose one), & not energy; # Feb 2017 hack. Could get proper basis in skel wfn even if not through p4 basis kw; if core.get_global_option('BASIS') in ["""", ""(AUTO)""]:; gobas = ""sto-3g""; else:; gobas = core.get_global_option('BASIS'); basis = core.BasisSet.build(molecule, ""ORBITAL"", gobas); if basis.has_ECP():; raise ValidationError(""""""ECPs not hooked up for Cfour""""""); wfn = core.Wavefunction(molecule, basis); for k, v in psivar.items():; wfn.set_variable(k.upper(), float(v)). optstash.restore(). if dertype == 0:; finalquantity = psivar['CURRENT ENERGY']; elif dertype == 1:; finalquantity = psi_grad; wfn.set_gradient(finalquantity); if finalquantity.rows(0) < 20:; core.print_out('CURRENT GRADIENT'); finalquantity.print_out(); elif dertype == 2:; pass; #finalquantity = finalhessian; #wfn.set_hessian(finalquantity); #if finalquantity.rows(0) < 20:; # core.print_out('CURRENT HESSIAN'); # finalquantity.print_out(). return wfn. def cfour_list():; """"""Form list of Cfour :py:func:`~dri",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/interface_cfour.html:13273,energy,energy,13273,psi4manual/1.7.x/_modules/psi4/driver/procrouting/interface_cfour.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/interface_cfour.html,8,['energy'],['energy']
Energy Efficiency,"aluate the one-electron properties, the; values at each grid point may be captured as Python arrays in the input file:; E, wfn = prop('scf', properties=[""GRID_ESP"", ""GRID_FIELD""], return_wfn=True); Vvals = wfn.oeprop.Vvals(); Exvals = wfn.oeprop.Exvals(); Eyvals = wfn.oeprop.Eyvals(); Ezvals = wfn.oeprop.Ezvals(). In this example, the Vvals array contains the electrostatic potential at each; grid point, in the order that the grid was specified, while the Exvals,; Eyvals and Ezvals arrays contain the x, y and z components of the; electric field, respectively; all of these arrays can be iterated and; manipulated using standard Python syntax. For a complete demonstration of this; utility, see the props4 test case. Minimal Basis Iterative Stockholder¶; The Minimal Basis Iterative Stockholder (MBIS) method is one of many procedures; that partitions a molecular one-particle density matrix into atomic electron densities.; Running MBIS in PSI4 will calculate atomic valence charge widths, volume ratios,; atomic charges, as well as dipoles, quadrupoles, and octupoles.; Additionally, all expectation values of radial moments of n-th order (\(<r^n>\)); are computed up to fourth order. Higher moments can be computed by specifying MAX_RADIAL_MOMENT.; The volume ratios are computed as the ratio between the volume of the atomic density; (\(<r^3>\)) and the volume of the free atom computed using the same level; of theory, but with a potentially unrestricted reference.; The allowed number of iterations and convergence criteria for the stockholder; algorithm is controlled by MBIS_MAXITER and MBIS_D_CONVERGENCE. Note; that the density is partitioned on a molecular quadrature grid, the details of which can be; controlled with the keywords MBIS_RADIAL_POINTS, MBIS_SPHERICAL_POINTS, and; MBIS_PRUNING_SCHEME. (Associated Paper: [Verstraelen:2016]). table of contents. Evaluation of One-Electron Properties — oeprop(); Basic Keywords; Properties evaluated on a grid; Minimal Basis Iterative Stoc",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/oeprop-1.html:5789,charge,charge,5789,psi4manual/1.4.0/oeprop-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/oeprop-1.html,18,['charge'],"['charge', 'charges']"
Energy Efficiency,"alue (float, default = 0.05); --rx [<angle>] the x-axis rotation angle (float, default = 30.0); --ry [<angle>] the y-axis rotation angle (float, default = 40.0); --rz [<angle>] the z-axis rotation angle (float, default = 15.0); --tx [<length>] the x-axis translation (float, default = 0.0); --ty [<length>] the y-axis translation (float, default = 0.0); --tz [<length>] the z-axis translation (float, default = 0.0); --opacity [<opacity>]; opacity of the isosurface (float, default = 1.0); --scale [<factor>] the scaling factor (float, default = 1.0); --no-montage call montage to combine images. (string, default =; false); --no-labels do not add labels to images. (string, default = false); --imagesize [<integer>]; the size of each image (integer, default = 250); --imagew [<integer>] the width of images (integer, default = 250); --imageh [<integer>] the height of images (integer, default = 250); --fontsize [<integer>]; the font size (integer, default = 20); --interactive run in interactive mode (default = false); --gzip gzip cube files (default = false); --national_scheme use a red/blue color scheme. (string, default = false); --silver_scheme use a gray/white color scheme. (string, default =; false); --bright_scheme use a soft yellow/blue color scheme. (string, default; = false); --electron_scheme use a purple/green color scheme. (string, default =; false). table of contents. Generation of Cube Files — cubeprop(); Introduction; Cubeprop Tasks; Keywords; CUBEPROP_TASKS; CUBEPROP_FILEPATH; CUBEPROP_ORBITALS; CUBEPROP_BASIS_FUNCTIONS; CUBIC_GRID_SPACING; CUBIC_GRID_OVERAGE. Orbital Visualization with VMD; Script Prerequisites; Running the Script; Script Options. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Psithon Functions: Invoking a Calculation; Generation of Cube Files — cubeprop(). © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/cubeprop.html:11354,green,green,11354,psi4manual/master/cubeprop.html,https://psicode.org,https://psicode.org/psi4manual/master/cubeprop.html,1,['green'],['green']
Energy Efficiency,"alue is provided by the user. nbody-freq; Vibrational and thermo analysis of water trimer (geometry from J. Chem. Theory Comput. 11, 2126-2136 (2015)). gibbs; Test Gibbs free energies at 298 K of N2, H2O, and CH4. mints5; Tests to determine full point group symmetry. Currently, these only matter for the rotational symmetry number in thermodynamic computations. stability2; ROHF stability analysis check for CN with cc-pVDZ. This test corresponds to the rohf-stab test from Psi3. cc27; Single point gradient of 1-1B2 state of H2O with EOM-CCSD. frac; Carbon/UHF Fractionally-Occupied SCF Test Case. cc33; CC3(UHF)/cc-pVDZ H2O \(R_e\) geom from Olsen et al., JCP 104, 8007 (1996). psimrcc-ccsd_t-1; Mk-MRCCSD(T) single point. \(^1A_1\) CH2 state described using the Ms = 0 component of the singlet. Uses RHF singlet orbitals. cc54; CCSD dipole with user-specified basis set. opt1-fd; SCF STO-3G geometry optimzation, with Z-matrix input, by finite-differences. sapt-dft-api; SAPT(DFT) aug-cc-pVDZ interaction energy between Ne and Ar atoms. cbs-xtpl-wrapper; RHF aug-cc-pVQZ energy for the BH molecule, with Cartesian input. Various gradients for a strained helium dimer and water molecule. scf-coverage; Lithium test for coverage. sad1; Test of the superposition of atomic densities (SAD) guess, using a highly distorted water geometry with a cc-pVDZ basis set. This is just a test of the code and the user need only specify guess=sad to the SCF module’s (or global) options in order to use a SAD guess. The test is first performed in C2v symmetry, and then in C1. cc1; RHF-CCSD 6-31G** all-electron optimization of the H2O molecule. dft-grac; Gradient regularized asymptotic correction (GRAC) test. cdomp2-1; OMP2 cc-pVDZ energy for the H2O molecule. tdscf-1; td-uhf test on triplet states of methylene (rpa). dfccd1; DF-CCD cc-pVDZ energy for the H2O molecule. soscf-large; Second-order SCF convergnece: Benzene. opt-irc-2; Compute the IRC for HCN <-> NCH interconversion at the RHF/DZP level of t",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/autodoc_testsuite_corepsi4-1.html:10964,energy,energy,10964,psi4manual/1.4.0/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodoc_testsuite_corepsi4-1.html,4,['energy'],['energy']
Energy Efficiency,"alueHI - beta * beta_mult. if verbose:; # Output string with extrapolation parameters; cbsscheme = ''; cbsscheme += """"""\n ==> Truhlar 2-point power form SCF extrapolation for method: %s <==\n\n"""""" % (; functionname.upper()); cbsscheme += """""" LO-zeta (%s) Energy: % 16.12f\n"""""" % (str(zLO), valueLO); cbsscheme += """""" HI-zeta (%s) Energy: % 16.12f\n"""""" % (str(zHI), valueHI); cbsscheme += """""" Alpha (exponent) Value: % 16.12f\n"""""" % (alpha); cbsscheme += """""" Beta (coefficient) Value: % 16.12f\n\n"""""" % (beta). name_str = ""%s/(%s,%s)"" % (functionname.upper(), _zeta_val2sym[zLO].upper(), _zeta_val2sym[zHI].upper()); cbsscheme += """""" @Extrapolated """"""; cbsscheme += name_str + ':'; cbsscheme += "" "" * (18 - len(name_str)); cbsscheme += """"""% 16.12f\n\n"""""" % value; core.print_out(cbsscheme); logger.debug(cbsscheme). return value. elif isinstance(valueLO, np.ndarray):. beta = (valueHI - valueLO) * beta_division; value = valueHI - beta * beta_mult. if verbose > 2:; cbsscheme = f""""""\n ==> Truhlar 2-point power SCF extrapolation for method: {functionname.upper()} <==\n""""""; cbsscheme += f""""""\n LO-zeta ({zLO}) Data\n""""""; cbsscheme += nppp(valueLO); cbsscheme += f""""""\n HI-zeta ({zHI}) Data\n""""""; cbsscheme += nppp(valueHI). cbsscheme += f""""""\n Alpha (exponent) Value: {alpha:16.8f}""""""; cbsscheme += f""""""\n Beta Data\n""""""; cbsscheme += nppp(beta); cbsscheme += f""""""\n Extrapolated Data\n""""""; cbsscheme += nppp(value); cbsscheme += ""\n""; core.print_out(cbsscheme); logger.debug(cbsscheme). return value. else:; raise ValidationError(f""scf_xtpl_truhlar_2: datatype is not recognized '{type(valueLO)}'.""). [docs]; def scf_xtpl_karton_2(functionname: str, zLO: int, valueLO: Extrapolatable, zHI: int, valueHI: Extrapolatable, verbose: int = 1, alpha: Optional[float] = None) -> Extrapolatable:; r""""""Extrapolation scheme using root-power form for reference energies with two adjacent; zeta-level bases. Used by :py:func:`~psi4.driver.cbs`. Parameters; ----------; functionname; Name of the CBS component (e.g",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs_helper.html:9279,power,power,9279,psi4manual/1.8.x/_modules/psi4/driver/driver_cbs_helper.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs_helper.html,6,['power'],['power']
Energy Efficiency,"alueHI - beta * beta_mult. if verbose:; # Output string with extrapolation parameters; cbsscheme = ''; cbsscheme += """"""\n ==> Truhlar 2-point power form SCF extrapolation for method: %s <==\n\n"""""" % (; functionname.upper()); cbsscheme += """""" LO-zeta (%s) Energy: % 16.12f\n"""""" % (str(zLO), valueLO); cbsscheme += """""" HI-zeta (%s) Energy: % 16.12f\n"""""" % (str(zHI), valueHI); cbsscheme += """""" Alpha (exponent) Value: % 16.12f\n"""""" % (alpha); cbsscheme += """""" Beta (coefficient) Value: % 16.12f\n\n"""""" % (beta). name_str = ""%s/(%s,%s)"" % (functionname.upper(), _zeta_val2sym[zLO].upper(), _zeta_val2sym[zHI].upper()); cbsscheme += """""" @Extrapolated """"""; cbsscheme += name_str + ':'; cbsscheme += "" "" * (18 - len(name_str)); cbsscheme += """"""% 16.12f\n\n"""""" % value; core.print_out(cbsscheme); logger.debug(cbsscheme). return value. elif isinstance(valueLO, np.ndarray):. beta = (valueHI - valueLO) * beta_division; value = valueHI - beta * beta_mult. if verbose > 2:; cbsscheme = f""""""\n ==> Truhlar 2-point power SCF extrapolation for method: {functionname.upper()} <==\n""""""; cbsscheme += f""""""\n LO-zeta ({zLO}) Data\n""""""; cbsscheme += nppp(valueLO); cbsscheme += f""""""\n HI-zeta ({zHI}) Data\n""""""; cbsscheme += nppp(valueHI). cbsscheme += f""""""\n Alpha (exponent) Value: {alpha:16.8f}""""""; cbsscheme += f""""""\n Beta Data\n""""""; cbsscheme += nppp(beta); cbsscheme += f""""""\n Extrapolated Data\n""""""; cbsscheme += nppp(value); cbsscheme += ""\n""; core.print_out(cbsscheme); logger.debug(cbsscheme). return value. else:; raise ValidationError(f""scf_xtpl_truhlar_2: datatype is not recognized '{type(valueLO)}'.""). [docs]def scf_xtpl_karton_2(functionname: str, zLO: int, valueLO: Extrapolatable, zHI: int, valueHI: Extrapolatable, verbose: int = 1, alpha: Optional[float] = None) -> Extrapolatable:; r""""""Extrapolation scheme using root-power form for reference energies with two adjacent; zeta-level bases. Used by :py:func:`~psi4.cbs`. Parameters; ----------; functionname; Name of the CBS component (e.g., 'HF') ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver_cbs_helper.html:9229,power,power,9229,psi4manual/1.6.x/_modules/psi4/driver/driver_cbs_helper.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver_cbs_helper.html,2,['power'],['power']
Energy Efficiency,"alueHI - beta * beta_mult. if verbose:; # Output string with extrapolation parameters; cbsscheme = ''; cbsscheme += """"""\n ==> Truhlar 2-point power form SCF extrapolation for method: %s <==\n\n"""""" % (; functionname.upper()); cbsscheme += """""" LO-zeta (%s) Energy: % 16.12f\n"""""" % (str(zLO), valueLO); cbsscheme += """""" HI-zeta (%s) Energy: % 16.12f\n"""""" % (str(zHI), valueHI); cbsscheme += """""" Alpha (exponent) Value: % 16.12f\n"""""" % (alpha); cbsscheme += """""" Beta (coefficient) Value: % 16.12f\n\n"""""" % (beta). name_str = ""%s/(%s,%s)"" % (functionname.upper(), _zeta_val2sym[zLO].upper(), _zeta_val2sym[zHI].upper()); cbsscheme += """""" @Extrapolated """"""; cbsscheme += name_str + ':'; cbsscheme += "" "" * (18 - len(name_str)); cbsscheme += """"""% 16.12f\n\n"""""" % value; core.print_out(cbsscheme); logger.debug(cbsscheme). return value. elif isinstance(valueLO, np.ndarray):. beta = (valueHI - valueLO) * beta_division; value = valueHI - beta * beta_mult. if verbose > 2:; cbsscheme = f""""""\n ==> Truhlar 2-point power SCF extrapolation for method: {functionname.upper()} <==\n""""""; cbsscheme += f""""""\n LO-zeta ({zLO}) Data\n""""""; cbsscheme += nppp(valueLO); cbsscheme += f""""""\n HI-zeta ({zHI}) Data\n""""""; cbsscheme += nppp(valueHI). cbsscheme += f""""""\n Alpha (exponent) Value: {alpha:16.8f}""""""; cbsscheme += f""""""\n Beta Data\n""""""; cbsscheme += nppp(beta); cbsscheme += f""""""\n Extrapolated Data\n""""""; cbsscheme += nppp(value); cbsscheme += ""\n""; core.print_out(cbsscheme); logger.debug(cbsscheme). return value. else:; raise ValidationError(f""scf_xtpl_truhlar_2: datatype is not recognized '{type(valueLO)}'.""). [docs]def scf_xtpl_karton_2(functionname: str, zLO: int, valueLO: Extrapolatable, zHI: int, valueHI: Extrapolatable, verbose: int = 1, alpha: Optional[float] = None) -> Extrapolatable:; r""""""Extrapolation scheme using root-power form for reference energies with two adjacent; zeta-level bases. Used by :py:func:`~psi4.driver.cbs`. Parameters; ----------; functionname; Name of the CBS component (e.g.,",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver_cbs_helper.html:9271,power,power,9271,psi4manual/1.7.x/_modules/psi4/driver/driver_cbs_helper.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver_cbs_helper.html,2,['power'],['power']
Energy Efficiency,"alueHI. elif isinstance(valueHI, np.ndarray):. if verbose > 2:; cbsscheme = f""""""\n ==> {functionname.upper()} <==\n\n""""""; cbsscheme += f"""""" HI-zeta ({zHI}) Data\n""""""; cbsscheme += nppp(valueHI); core.print_out(cbsscheme); logger.debug(cbsscheme). return valueHI. [docs]def scf_xtpl_helgaker_2(functionname: str, zLO: int, valueLO: Extrapolatable, zHI: int, valueHI: Extrapolatable, verbose: int = 1, alpha: Optional[float] = None) -> Extrapolatable:; r""""""Extrapolation scheme using exponential form for reference energies with two adjacent; zeta-level bases. Used by :py:func:`~psi4.driver.cbs`. Parameters; ----------; functionname; Name of the CBS component (e.g., 'HF') used in summary printing.; zLO; Zeta number of the smaller basis set in 2-point extrapolation.; valueLO; Energy, gradient, or Hessian value at the smaller basis set in 2-point; extrapolation.; zHI; Zeta number of the larger basis set in 2-point extrapolation.; Must be `zLO + 1`.; valueHI; Energy, gradient, or Hessian value at the larger basis set in 2-point; extrapolation.; verbose; Controls volume of printing.; alpha; Fitted 2-point parameter. Overrides the default :math:`\alpha = 1.63`. Returns; -------; float or ~numpy.ndarray; Eponymous function applied to input zetas and values; type from `valueLO`. Notes; -----; The extrapolation is calculated according to [1]_:; :math:`E_{total}^X = E_{total}^{\infty} + \beta e^{-\alpha X}, \alpha = 1.63`. References; ----------. .. [1] Halkier, Helgaker, Jorgensen, Klopper, & Olsen, Chem. Phys. Lett. 302 (1999) 437-446,; DOI: 10.1016/S0009-2614(99)00179-7. Examples; --------; >>> # [1] Hartree-Fock extrapolation; >>> psi4.energy('cbs', scf_wfn='hf', scf_basis='cc-pV[DT]Z', scf_scheme='scf_xtpl_helgaker_2'). """""". if type(valueLO) != type(valueHI):; raise ValidationError(; f""scf_xtpl_helgaker_2: Inputs must be of the same datatype! ({type(valueLO)}, {type(valueHI)})""). if alpha is None:; alpha = 1.63. beta_division = 1 / (math.exp(-1 * alpha * zLO) * (math.exp(-1 * a",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver_cbs_helper.html:3867,Energy,Energy,3867,psi4manual/1.7.x/_modules/psi4/driver/driver_cbs_helper.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver_cbs_helper.html,1,['Energy'],['Energy']
Energy Efficiency,"alues(ref_energies['TWO-ELECTRON ENERGY'], energies['TWO-ELECTRON ENERGY'], 7,; label + '. 2-electron energy'); pass_scf = compare_values(ref_energies['SCF TOTAL ENERGY'], energies['SCF TOTAL ENERGY'], 10,; label + '. SCF total energy'); pass_mp2 = compare_values(ref_energies['MP2 CORRELATION ENERGY'], energies['MP2 CORRELATION ENERGY'], 10,; label + '. MP2 correlation energy'). compare_integers(True, (pass_1el and pass_2el and pass_scf and pass_mp2), label). [docs]def energies_from_fcidump(intdump) -> Dict[str, float]:; """"""From integrals dictionary generated from :py:func:`fcidump_from_file`,; compute energies. :returns: a dictionary with energies. - 'NUCLEAR REPULSION ENERGY'; - 'ONE-ELECTRON ENERGY'; - 'TWO-ELECTRON ENERGY'; - 'SCF TOTAL ENERGY'; - 'MP2 CORRELATION ENERGY'. """"""; energies = {}; energies['NUCLEAR REPULSION ENERGY'] = intdump['enuc']; epsilon = intdump['epsilon']; Hcore = intdump['hcore']; eri = intdump['eri']. # Compute SCF energy; energies['ONE-ELECTRON ENERGY'], energies['TWO-ELECTRON ENERGY'] = _scf_energy(Hcore, eri,; np.where(epsilon < 0)[0],; intdump['uhf']); # yapf: disable; energies['SCF TOTAL ENERGY'] = energies['ONE-ELECTRON ENERGY'] + energies['TWO-ELECTRON ENERGY'] + energies['NUCLEAR REPULSION ENERGY']; # yapf: enable. # Compute MP2 energy; energies['MP2 CORRELATION ENERGY'] = _mp2_energy(eri, epsilon, intdump['uhf']). return energies. def _scf_energy(Hcore, ERI, occ_sl, unrestricted):; scf_1el_e = np.einsum('ii->', Hcore[np.ix_(occ_sl, occ_sl)]); if not unrestricted:; scf_1el_e *= 2; coulomb = np.einsum('iijj->', ERI[np.ix_(occ_sl, occ_sl, occ_sl, occ_sl)]); exchange = np.einsum('ijij->', ERI[np.ix_(occ_sl, occ_sl, occ_sl, occ_sl)]); if unrestricted:; scf_2el_e = 0.5 * (coulomb - exchange); else:; scf_2el_e = 2.0 * coulomb - exchange. return scf_1el_e, scf_2el_e. def _mp2_energy(ERI, epsilon, unrestricted):; # Occupied and virtual slices; occ_sl = np.where(epsilon < 0)[0]; vir_sl = np.where(epsilon > 0)[0]; eocc = epsilon[occ_sl]; evi",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/fcidump.html:14447,energy,energy,14447,psi4manual/1.7.x/_modules/psi4/driver/p4util/fcidump.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/fcidump.html,4,"['ENERGY', 'energy']","['ENERGY', 'energy']"
Energy Efficiency,"alues: QCHEM, MOLPRO, GAU, GAU_LOOSE, GAU_TIGHT, INTERFRAG_TIGHT, GAU_VERYTIGHT, TURBOMOLE, CFOUR, NWCHEM_LOOSE; Default: QCHEM. FULL_HESS_EVERY¶. Frequency with which to compute the full Hessian in the course of a geometry optimization. 0 means to compute the initial Hessian only, 1 means recompute every step, and N means recompute every N steps. The default (-1) is to never compute the full Hessian. Type: integer; Default: -1. INTCOS_GENERATE_EXIT¶. Do only generate the internal coordinates and then stop?. Type: boolean; Default: false. Optimizing Minima¶; First, define the molecule and basis in the input.; 1; 2; 3; 4; 5; 6; 7molecule h2o {; O; H 1 1.0; H 1 1.0 2 105.0; }. set basis dz. Then the following are examples of various types of calculations that can be completed. Optimize a geometry using default methods (RFO step):; 1optimize('scf'). Optimize using Newton-Raphson steps instead of RFO steps:; 1; 2set step_type nr; optimize('scf'). Optimize using energy points instead of gradients:; 1optimize('scf', dertype='energy'). Optimize while limiting the initial step size to 0.1 au:; 1; 2set intrafrag_step_limit 0.1; optimize('scf'). Optimize while always limiting the step size to 0.1 au:; 1; 2; 3; 4; 5; 6; 7set {; intrafrag_step_limit 0.1; intrafrag_step_limit_min 0.1; intrafrag_step_limit_max 0.1; }. optimize('scf'). Optimize while calculating the Hessian at every step:; 1; 2set full_hess_every 1; optimize('scf'). Hessian¶; If Cartesian second derivatives are available, optking can read them; and transform them into internal coordinates to make an initial Hessian in; internal coordinates. Otherwise, several empirical Hessians are available,; including those of Schlegel [Schlegel:1984:333] and Fischer and Almlof; [Fischer:1992:9770].; Either of these or a simple diagonal Hessian may be selected using the; INTRAFRAG_HESS keyword.; All the common Hessian update schemes are available. For formulas, see; Schlegel [Schlegel:1987:AIMQC] and Bofill [Bofill:1994:1].; The",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/optking-1.html:4394,energy,energy,4394,psi4manual/1.2.1/optking-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/optking-1.html,8,['energy'],['energy']
Energy Efficiency,"alysis from vibrational output. API¶. pydantic model psi4.driver.driver_findif.FiniteDifferenceComputer[source]¶. Show JSON schema{; ""title"": ""FiniteDifferenceComputer"",; ""description"": ""Base class for \""computers\"" that plan, run, and process QC tasks."",; ""type"": ""object"",; ""properties"": {; ""molecule"": {; ""title"": ""Molecule""; },; ""driver"": {; ""$ref"": ""#/definitions/DriverEnum""; },; ""metameta"": {; ""title"": ""Metameta"",; ""default"": {},; ""type"": ""object""; },; ""task_list"": {; ""title"": ""Task List"",; ""default"": {},; ""type"": ""object"",; ""additionalProperties"": {; ""$ref"": ""#/definitions/BaseComputer""; }; },; ""findifrec"": {; ""title"": ""Findifrec"",; ""default"": {},; ""type"": ""object""; },; ""method"": {; ""title"": ""Method"",; ""type"": ""string""; }; },; ""required"": [; ""driver"",; ""method""; ],; ""definitions"": {; ""DriverEnum"": {; ""title"": ""DriverEnum"",; ""description"": ""Allowed computation driver values."",; ""enum"": [; ""energy"",; ""gradient"",; ""hessian"",; ""properties""; ],; ""type"": ""string""; },; ""BaseComputer"": {; ""title"": ""BaseComputer"",; ""description"": ""Base class for \""computers\"" that plan, run, and process QC tasks."",; ""type"": ""object"",; ""properties"": {}; }; }; }. Fields:. driver (qcelemental.models.common_models.DriverEnum); findifrec (Dict[str, Any]); metameta (Dict[str, Any]); method (str); molecule (Any); task_list (Dict[str, psi4.driver.task_base.BaseComputer]). Validators:. set_driver » driver; set_molecule » molecule. field driver: DriverEnum [Required]¶. Validated by:. set_driver. field findifrec: Dict[str, Any] = {}¶. field metameta: Dict[str, Any] = {}¶. field method: str [Required]¶. field molecule: Any = None¶. Validated by:. set_molecule. field task_list: Dict[str, BaseComputer] = {}¶. computer¶; alias of AtomicComputer. build_tasks(obj, **kwargs)[source]¶. compute(client=None)[source]¶; Run each job in task list. Parameters:; client (Optional[FractalClient]) – . get_psi_results(return_wfn=False)[source]¶; Called by driver to assemble results into FiniteDifference-flavored QCS",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/freq.html:8827,energy,energy,8827,psi4manual/1.7.x/freq.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/freq.html,1,['energy'],['energy']
Energy Efficiency,"alysis from vibrational output. API¶. pydantic model psi4.driver.driver_findif.FiniteDifferenceComputer[source]¶. Show JSON schema{; ""title"": ""FiniteDifferenceComputer"",; ""description"": ""Base class for \""computers\"" that plan, run, and process QC tasks."",; ""type"": ""object"",; ""properties"": {; ""molecule"": {; ""title"": ""Molecule""; },; ""driver"": {; ""$ref"": ""#/definitions/DriverEnum""; },; ""metameta"": {; ""title"": ""Metameta"",; ""default"": {},; ""type"": ""object""; },; ""task_list"": {; ""title"": ""Task List"",; ""default"": {},; ""type"": ""object"",; ""additionalProperties"": {; ""$ref"": ""#/definitions/BaseComputer""; }; },; ""findifrec"": {; ""title"": ""Findifrec"",; ""default"": {},; ""type"": ""object""; },; ""method"": {; ""title"": ""Method"",; ""type"": ""string""; }; },; ""required"": [; ""driver"",; ""method""; ],; ""definitions"": {; ""DriverEnum"": {; ""title"": ""DriverEnum"",; ""description"": ""Allowed computation driver values."",; ""enum"": [; ""energy"",; ""gradient"",; ""hessian"",; ""properties""; ],; ""type"": ""string""; },; ""BaseComputer"": {; ""title"": ""BaseComputer"",; ""description"": ""Base class for \""computers\"" that plan, run, and process QC tasks."",; ""type"": ""object"",; ""properties"": {}; }; }; }. Fields:. driver (qcelemental.models.common_models.DriverEnum); findifrec (Dict[str, Any]); metameta (Dict[str, Any]); method (str); molecule (Any); task_list (Dict[str, psi4.driver.task_base.BaseComputer]). Validators:. set_driver » driver; set_molecule » molecule. field driver: DriverEnum [Required]¶. Validated by:. set_driver. field findifrec: Dict[str, Any] = {}¶. field metameta: Dict[str, Any] = {}¶. field method: str [Required]¶. field molecule: Any = None¶. Validated by:. set_molecule. field task_list: Dict[str, BaseComputer] = {}¶. computer¶; alias of AtomicComputer. build_tasks(obj, **kwargs)[source]¶. compute(client=None)[source]¶; Run each job in task list. Parameters:; client (qcportal.FractalClient | None) – . get_psi_results(client=None, *, return_wfn=False)[source]¶; Called by driver to assemble results into FiniteD",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/freq.html:8829,energy,energy,8829,psi4manual/1.8.x/freq.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/freq.html,2,['energy'],['energy']
Energy Efficiency,"alysis from vibrational output. API¶. pydantic model psi4.driver.driver_findif.FiniteDifferenceComputer[source]¶. Show JSON schema{; ""title"": ""FiniteDifferenceComputer"",; ""description"": ""Base class for \""computers\"" that plan, run, and process QC tasks."",; ""type"": ""object"",; ""properties"": {; ""molecule"": {; ""title"": ""Molecule""; },; ""driver"": {; ""$ref"": ""#/definitions/DriverEnum""; },; ""metameta"": {; ""title"": ""Metameta"",; ""default"": {},; ""type"": ""object""; },; ""task_list"": {; ""title"": ""Task List"",; ""default"": {},; ""type"": ""object"",; ""additionalProperties"": {; ""$ref"": ""#/definitions/BaseComputer""; }; },; ""findifrec"": {; ""title"": ""Findifrec"",; ""default"": {},; ""type"": ""object""; },; ""method"": {; ""title"": ""Method"",; ""type"": ""string""; }; },; ""required"": [; ""driver"",; ""method""; ],; ""definitions"": {; ""DriverEnum"": {; ""title"": ""DriverEnum"",; ""description"": ""Allowed computation driver values."",; ""enum"": [; ""energy"",; ""gradient"",; ""hessian"",; ""properties""; ],; ""type"": ""string""; },; ""BaseComputer"": {; ""title"": ""BaseComputer"",; ""description"": ""Base class for \""computers\"" that plan, run, and process QC tasks."",; ""type"": ""object"",; ""properties"": {}; }; }; }. Fields:. driver (qcelemental.models.common_models.DriverEnum); findifrec (Dict[str, Any]); metameta (Dict[str, Any]); method (str); molecule (Any); task_list (Dict[str, psi4.driver.task_base.BaseComputer]). Validators:. set_driver » driver; set_molecule » molecule. field driver: DriverEnum [Required]¶. Validated by:. set_driver. field findifrec: Dict[str, Any] = {}¶. field metameta: Dict[str, Any] = {}¶. field method: str [Required]¶. field molecule: Any = None¶. Validated by:. set_molecule. field task_list: Dict[str, BaseComputer] = {}¶. computer¶; alias of AtomicComputer. build_tasks(obj, **kwargs)[source]¶. compute(client=None)[source]¶; Run each job in task list. Parameters:; client (qcportal.FractalClient | None). get_psi_results(client=None, *, return_wfn=False)[source]¶; Called by driver to assemble results into FiniteDiff",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/freq.html:8836,energy,energy,8836,psi4manual/master/freq.html,https://psicode.org,https://psicode.org/psi4manual/master/freq.html,1,['energy'],['energy']
Energy Efficiency,"am scf_scheme: |dl| ``'xtpl_highest_1'`` |dr| || ``'scf_xtpl_helgaker_3'`` || etc. Indicates the basis set extrapolation scheme to be applied to the reference energy.; Defaults to :py:func:`~psi4.driver.driver_cbs_helper.scf_xtpl_helgaker_3` if three valid basis sets; present in ``psi4.driver.driver_cbs.scf_basis``, :py:func:`~psi4.driver.driver_cbs_helper.scf_xtpl_helgaker_2` if two valid basis; sets present in ``scf_basis``, and :py:func:`~psi4.driver.driver_cbs_helper.xtpl_highest_1` otherwise. .. hlist::; :columns: 1. * :py:func:`~psi4.driver.driver_cbs_helper.xtpl_highest_1`; * :py:func:`~psi4.driver.driver_cbs_helper.scf_xtpl_helgaker_3`; * :py:func:`~psi4.driver.driver_cbs_helper.scf_xtpl_helgaker_2`; * :py:func:`~psi4.driver.driver_cbs_helper.scf_xtpl_truhlar_2`; * :py:func:`~psi4.driver.driver_cbs_helper.scf_xtpl_karton_2`. :type corl_scheme: str; :param corl_scheme: |dl| ``'xtpl_highest_1'`` |dr| || ``'corl_xtpl_helgaker_2'`` || etc. Indicates the basis set extrapolation scheme to be applied to the correlation energy.; Defaults to :py:func:`~psi4.driver.driver_cbs_helper.corl_xtpl_helgaker_2` if two valid basis sets; present in ``corl_basis`` and :py:func:`~psi4.driver.driver_cbs_helper.xtpl_highest_1` otherwise. .. hlist::; :columns: 1. * :py:func:`~psi4.driver.driver_cbs_helper.xtpl_highest_1`; * :py:func:`~psi4.driver.driver_cbs_helper.corl_xtpl_helgaker_2`. :type delta_scheme: str; :param delta_scheme: |dl| ``'xtpl_highest_1'`` |dr| || ``'corl_xtpl_helgaker_2'`` || etc. Indicates the basis set extrapolation scheme to be applied to the delta correction; to the correlation energy.; Defaults to :py:func:`~psi4.driver.driver_cbs_helper.corl_xtpl_helgaker_2` if two valid basis sets; present in ``delta_basis`` and :py:func:`~psi4.driver.driver_cbs_helper.xtpl_highest_1` otherwise. .. hlist::; :columns: 1. * :py:func:`~psi4.driver.driver_cbs_helper.xtpl_highest_1`; * :py:func:`~psi4.driver.driver_cbs_helper.corl_xtpl_helgaker_2`. :type delta2_scheme: str; :pa",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver_cbs.html:28143,energy,energy,28143,psi4manual/1.7.x/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver_cbs.html,8,['energy'],['energy']
Energy Efficiency,"ame in ['sapt2+(3)(ccd)', 'sapt2+(3)(ccd)dmp2']:; psi4.set_local_option('SAPT', 'SAPT_LEVEL', 'SAPT2+3'); psi4.set_local_option('SAPT', 'DO_THIRD_ORDER', False); psi4.set_local_option('SAPT', 'DO_CCD_DISP', True); elif name in ['sapt2+3(ccd)', 'sapt2+3(ccd)dmp2']:; psi4.set_local_option('SAPT', 'SAPT_LEVEL', 'SAPT2+3'); psi4.set_local_option('SAPT', 'DO_THIRD_ORDER', True); psi4.set_local_option('SAPT', 'DO_CCD_DISP', True). psi4.print_out('\n'); p4util.banner(name.upper()); psi4.print_out('\n'); e_sapt = psi4.sapt(dimer_wfn, monomerA_wfn, monomerB_wfn). from qcdb.psivardefs import sapt_psivars; p4util.expand_psivars(sapt_psivars()); optstash.restore(); for term in ['ELST', 'EXCH', 'IND', 'DISP', 'TOTAL']:; psi4.set_variable(' '.join(['SAPT', term, 'ENERGY']), ; psi4.get_variable(' '.join([name.upper(), term, 'ENERGY']))); psi4.set_variable('CURRENT ENERGY', psi4.get_variable('SAPT TOTAL ENERGY')). return dimer_wfn. [docs]def run_sapt_ct(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a charge-transfer SAPT calcuation of any level. """"""; optstash = p4util.OptionsState(; ['SCF', 'SCF_TYPE']). if 'ref_wfn' in kwargs:; psi4.print_out('\nWarning! Argument ref_wfn is not valid for sapt computations\n'). # Alter default algorithm; if not psi4.has_option_changed('SCF', 'SCF_TYPE'):; psi4.set_local_option('SCF', 'SCF_TYPE', 'DF'). # Get the molecule of interest; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; sapt_dimer = kwargs.pop('molecule', psi4.get_active_molecule()); else:; psi4.print_out('Warning! SAPT argument ""ref_wfn"" is only able to use molecule information.'); sapt_dimer = ref_wfn.molecule(); sapt_dimer.update_geometry() # make sure since mol from wfn, kwarg, or P::e. # Shifting to C1 so we need to copy the active molecule; if sapt_dimer.schoenflies_symbol() != 'c1':; psi4.print_out(' SAPT does not make use of molecular symmetry, further calculations in C1 point group.\n'); sapt_dimer = sapt_dimer.clone(); sapt_dimer.reset_poin",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html:84350,charge,charge-transfer,84350,psi4manual/1.0.0/_modules/procedures/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html,1,['charge'],['charge-transfer']
Energy Efficiency,"ame in; molden format. Will write natural orbitals from density (MO basis) if supplied.; Warning! Most post-SCF Wavefunctions do not build the density as this is often; much more costly than the energy. In addition, the Wavefunction density attributes; (Da and Db) return the SO density and must be transformed to the MO basis; to use with this function. New in version 0.5: wfn parameter passed explicitly. Returns:None. Parameters:; wfn (Wavefunction) – set of molecule, basis, orbitals from which to generate cube files; filename (string) – destination file name for MOLDEN file (optional); density_a (Matrix) – density in the MO basis to build alpha NO’s from (optional); density_b (Matrix) – density in the MO basis to build beta NO’s from, assumes restricted if not supplied (optional); dovirtual (bool) – do write all the MOs to the MOLDEN file (true) or discard the unoccupied MOs, not valid for NO’s (false) (optional). Examples:. 1; 2; 3>>> # [1] Molden file for DFT calculation; >>> E, wfn = energy('b3lyp', return_wfn=True); >>> molden(wfn, 'mycalc.molden'). 1; 2; 3>>> # [2] Molden file for CI/MCSCF computation using NO roots; >>> E, wfn = energy('ci', return_wfn=True); >>> molden(wfn, 'no_root1.molden', density_a=wfn.opdm(0, 0, ""A"", True)). 1; 2; 3>>> # [3] The following does NOT work, please see below; >>> E, wfn = energy('ccsd', return_wfn=True); >>> molden(wfn, 'ccsd_no.molden', density_a=wfn.Da()). 1; 2; 3; 4; 5>>> # [4] This WILL work, note the transformation of Da (SO->MO); >>> E, wfn = properties('ccsd', properties=['dipole'], return_wfn=True); >>> Da_so = wfn.Da(); >>> Da_mo = Matrix.triplet(wfn.Ca(), Da_so, wfn.Ca(), True, False, False); >>> molden(wfn, 'ccsd_no.molden', density_a=Da_mo). Options¶. MOLDEN_WRITE¶. Do write a MOLDEN output file? If so, the filename will end in .molden, and the prefix is determined by WRITER_FILE_LABEL (if set), or else by the name of the output file plus the name of the current molecule. Type: boolean; Default: false. WRITER_FIL",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/molden-1.html:2329,energy,energy,2329,psi4manual/1.2.1/molden-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/molden-1.html,2,['energy'],['energy']
Energy Efficiency,"ame in; molden format. Will write natural orbitals from density (MO basis) if supplied.; Warning! Most post-SCF Wavefunctions do not build the density as this is often; much more costly than the energy. In addition, the Wavefunction density attributes; (Da and Db) return the SO density and must be transformed to the MO basis; to use with this function. New in version 0.5: wfn parameter passed explicitly. Returns:None. Parameters:; wfn (Wavefunction) – set of molecule, basis, orbitals from which to generate cube files; filename (string) – destination file name for MOLDEN file (optional); density_a (Matrix) – density in the MO basis to build alpha NO’s from (optional); density_b (Matrix) – density in the MO basis to build beta NO’s from, assumes restricted if not supplied (optional); dovirtual (bool) – do write all the MOs to the MOLDEN file (true) or discard the unoccupied MOs, not valid for NO’s (false) (optional). Examples:. 1; 2; 3>>> # [1] Molden file for DFT calculation; >>> E, wfn = energy('b3lyp', return_wfn=True); >>> molden(wfn, 'mycalc.molden'). 1; 2; 3>>> # [2] Molden file for CI/MCSCF computation using NO roots; >>> E, wfn = energy('ci', return_wfn=True); >>> molden(wfn, 'no_root1.molden', density_a=wfn.opdm(0, 0, ""A"", True)). 1; 2; 3>>> # [3] The following does NOT work, please see below; >>> E, wfn = energy('ccsd', return_wfn=True); >>> molden(wfn, 'ccsd_no.molden', density_a=wfn.Da()). 1; 2; 3; 4; 5>>> # [4] This WILL work, note the transformation of Da (SO->MO); >>> E, wfn = property('ccsd', properties=['dipole'], return_wfn=True); >>> Da_so = wfn.Da(); >>> Da_mo = Matrix.triplet(wfn.Ca(), Da_so, wfn.Ca(), True, False, False); >>> molden(wfn, 'ccsd_no.molden', density_a=Da_mo). Options¶. MOLDEN_WRITE¶. Do write a MOLDEN output file? If so, the filename will end in .molden, and the prefix is determined by WRITER_FILE_LABEL (if set), or else by the name of the output file plus the name of the current molecule. Type: boolean; Default: false. WRITER_FILE_",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/molden-1.html:2334,energy,energy,2334,psi4manual/1.1.0/molden-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/molden-1.html,2,['energy'],['energy']
Energy Efficiency,"ame of functional (func only, func & disp, or disp only) for; which to compute dispersion (e.g., blyp, BLYP-D2, blyp-d3bj,; blyp-d3(bj), hf+d). Any or all parameters initialized; from dashcoeff[dashlvl][func] can be overwritten via; dashparam.; dashlvl (Optional[str]) – Name of dispersion correction to be applied (e.g., d, D2,; d3(bj), das2010). Must be key in dashcoeff or “alias” or; “formal” to one.; dashparam (Optional[Dict]) – Values for the same keys as dashcoeff[dashlvl][‘default’]; used to override any or all values initialized by func.; Extra parameters will error.; dertype (Union[int, str, None]) – Maximum derivative level at which to run DFTD3. For large; molecules, energy-only calculations can be significantly more; efficient. Influences return values, see below.; verbose (int) – Amount of printing. Returns. energy (float) – When dertype=0, energy [Eh].; gradient (ndarray) – When dertype=1, (nat, 3) gradient [Eh/a0].; (energy, gradient) (tuple of float and ndarray) – When dertype=None, both energy [Eh] and (nat, 3) gradient [Eh/a0]. class psi4.driver.procrouting.empirical_dispersion.EmpiricalDispersion(*, name_hint=None, level_hint=None, param_tweaks=None, engine=None, save_pairwise_disp=False)[source]¶; Lightweight unification of empirical dispersion calculation modes. dashlevel¶; {‘d1’, ‘d2’, ‘d3zero’, ‘d3bj’, ‘d3mzero’, ‘d3mbj’, ‘chg’, ‘das2009’, ‘das2010’, ‘nl’, ‘dmp2’}; Name of dispersion correction to be applied. Resolved; from name_hint and/or level_hint into a key of; empirical_dispersion_resources.dashcoeff. Type; str. dashparams¶; Complete set of parameter values defining the flexible parts; of dashlevel. Number and parameter names vary by; dashlevel. Resolved into a complete set (keys of; dashcoeff[dashlevel][‘default’]) from name_hint and/or; dashcoeff_supplement and/or user param_tweaks. Type; dict. fctldash¶; If dashparams for dashlevel corresponds to a defined,; named, untweaked “functional-dashlevel” set, then that; functional. Otherwise, ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/dftd3-1.html:10905,energy,energy,10905,psi4manual/1.4.0/dftd3-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/dftd3-1.html,4,['energy'],['energy']
Energy Efficiency,"ame of functional (func only, func & disp, or disp only) for; which to compute dispersion (e.g., blyp, BLYP-D2, blyp-d3bj,; blyp-d3(bj), hf+d). Any or all parameters initialized; from dashcoeff[dashlvl][func] can be overwritten via; dashparam.; dashlvl (Optional[str]) – Name of dispersion correction to be applied (e.g., d, D2,; d3(bj), das2010). Must be key in dashcoeff or “alias” or; “formal” to one.; dashparam (Optional[Dict]) – Values for the same keys as dashcoeff[dashlvl][‘default’]; used to override any or all values initialized by func.; Extra parameters will error.; dertype (Union[int, str, None]) – Maximum derivative level at which to run DFTD3. For large; molecules, energy-only calculations can be significantly more; efficient. Influences return values, see below.; verbose (int) – Amount of printing. Returns. energy (float) – When dertype=0, energy [Eh].; gradient (ndarray) – When dertype=1, (nat, 3) gradient [Eh/a0].; (energy, gradient) (tuple of float and ndarray) – When dertype=None, both energy [Eh] and (nat, 3) gradient [Eh/a0]. run_gcp(func=None, dertype=None, verbose=1)[source]¶; Compute geometrical BSSE correction via Grimme’s GCP program.; Function to call Grimme’s GCP program; https://www.chemie.uni-bonn.de/pctc/mulliken-center/software/gcp/gcp; to compute an a posteriori geometrical BSSE correction to self for; several HF, generic DFT, and specific HF-3c and PBEh-3c method/basis; combinations, func. Returns energy if dertype is 0, gradient; if dertype is 1, else tuple of energy and gradient if dertype; unspecified. The gcp executable must be independently compiled and; found in PATH or PSIPATH. self may be either a; qcdb.Molecule (sensibly) or a psi4.Molecule (works b/c psi4.Molecule; has been extended by this method py-side and only public interface; fns used) or a string that can be instantiated into a qcdb.Molecule. Parameters. func (str, optional) – Name of method/basis combination or composite method for which to compute the correction; (e.",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/api/psi4.core.molecule.html:28521,energy,energy,28521,psi4manual/1.4.0/api/psi4.core.molecule.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/api/psi4.core.molecule.html,4,['energy'],['energy']
Energy Efficiency,"ame of functional (func only, func & disp, or disp only) for; which to compute dispersion (e.g., blyp, BLYP-D2, blyp-d3bj,; blyp-d3(bj), hf+d). Any or all parameters initialized; from dashcoeff[dashlvl][func] can be overwritten via; dashparam.; dashlvl (Optional[str]) – Name of dispersion correction to be applied (e.g., d, D2,; d3(bj), das2010). Must be key in dashcoeff or “alias” or; “formal” to run.; dashparam (Optional[Dict]) – Values for the same keys as dashcoeff[dashlvl][‘default’]; used to override any or all values initialized by func.; Extra parameters will error.; dertype (Union[int, str, None]) – Maximum derivative level at which to run DFTD3. For large; molecules, energy-only calculations can be significantly more; efficient. Influences return values, see below.; verbose (int) – Amount of printing. Returns. energy (float) – When dertype=0, energy [Eh].; gradient (ndarray) – When dertype=1, (nat, 3) gradient [Eh/a0].; (energy, gradient) (tuple of float and ndarray) – When dertype=None, both energy [Eh] and (nat, 3) gradient [Eh/a0]. class psi4.driver.procrouting.empirical_dispersion.EmpiricalDispersion(*, name_hint=None, level_hint=None, param_tweaks=None, engine=None, save_pairwise_disp=False)[source]¶; Lightweight unification of empirical dispersion calculation modes. dashlevel¶; {‘d1’, ‘d2’, ‘d3zero’, ‘d3bj’, ‘d3mzero’, ‘d3mbj’, ‘chg’, ‘das2009’, ‘das2010’, ‘nl’, ‘dmp2’, “d4bjeeqatm”}; Name of dispersion correction to be applied. Resolved; from name_hint and/or level_hint into a key of; empirical_dispersion_resources.dashcoeff. Type; str. dashparams¶; Complete set of parameter values defining the flexible parts; of dashlevel. Number and parameter names vary by; dashlevel. Resolved into a complete set (keys of; dashcoeff[dashlevel][‘default’]) from name_hint and/or; dashcoeff_supplement and/or user param_tweaks. Type; dict. fctldash¶; If dashparams for dashlevel corresponds to a defined,; named, untweaked “functional-dashlevel” set, then that; functiona",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/dftd3-1.html:11609,energy,energy,11609,psi4manual/1.5.0/dftd3-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/dftd3-1.html,6,['energy'],['energy']
Energy Efficiency,"ame of functional (func only, func & disp, or disp only) for; which to compute dispersion (e.g., blyp, BLYP-D2, blyp-d3bj,; blyp-d3(bj), hf+d). Any or all parameters initialized; from dashcoeff[dashlvl][func] can be overwritten via; dashparam.; dashlvl (Optional[str]) – Name of dispersion correction to be applied (e.g., d, D2,; d3(bj), das2010). Must be key in dashcoeff or “alias” or; “formal” to run.; dashparam (Optional[Dict]) – Values for the same keys as dashcoeff[dashlvl][‘default’]; used to override any or all values initialized by func.; Extra parameters will error.; dertype (Union[int, str, None]) – Maximum derivative level at which to run DFTD3. For large; molecules, energy-only calculations can be significantly more; efficient. Influences return values, see below.; verbose (int) – Amount of printing. Returns. energy (float) – When dertype=0, energy [Eh].; gradient (ndarray) – When dertype=1, (nat, 3) gradient [Eh/a0].; (energy, gradient) (tuple of float and ndarray) – When dertype=None, both energy [Eh] and (nat, 3) gradient [Eh/a0]. run_dftd4(func=None, dashlvl=None, dashparam=None, dertype=None, verbose=1)[source]¶; Compute dispersion correction via Grimme’s DFTD4 program. Parameters. func (str, optional) – Name of functional (func only, func & disp, or disp only) for; which to compute dispersion (e.g., blyp, BLYP-D2, blyp-d3bj,; blyp-d3(bj), hf+d). Unlike run_dftd3, func overwrites any; parameter initialized via dashparam.; dashlvl (str, optional) – Name of dispersion correction to be applied (e.g., d, D2,; d3(bj), das2010). Must be key in dashcoeff or “alias” or; “formal” to run.; dashparam (dict, optional) – Values for the same keys as dashcoeff[dashlvl][‘default’]; used to provide custom values. Unlike run_dftd3, will not have; effect if func given. Must provide all parameters.; Extra parameters will error.; dertype (int or str, optional) – Maximum derivative level at which to run DFTD3. For large; molecules, energy-only calculations can be significa",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/api/psi4.core.molecule.html:28628,energy,energy,28628,psi4manual/1.5.0/api/psi4.core.molecule.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/api/psi4.core.molecule.html,8,['energy'],['energy']
Energy Efficiency,"ame, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; SCF calculations. This is a simple alias to run_scf(); since SCF properties all handled through oeprop. scf_helper(name, **kwargs)[source]¶; Function serving as helper to SCF, choosing whether to cast; up or just run SCF with a standard guess. This preserves; previous SCF options set by other procedures (e.g., SAPT; output file types for SCF). select_ccsd(name, **kwargs)[source]¶; Function selecting the algorithm for a CCSD energy call; and directing to specified or best-performance default modules. select_ccsd_at_(name, **kwargs)[source]¶; Function selecting the algorithm for a CCSD(AT) energy call; and directing to specified or best-performance default modules. select_ccsd_gradient(name, **kwargs)[source]¶; Function selecting the algorithm for a CCSD gradient call; and directing to specified or best-performance default modules. select_ccsd_t_(name, **kwargs)[source]¶; Function selecting the algorithm for a CCSD(T) energy call; and directing to specified or best-performance default modules. select_ccsd_t__gradient(name, **kwargs)[source]¶; Function selecting the algorithm for a CCSD(T) gradient call; and directing to specified or best-performance default modules. select_cisd(name, **kwargs)[source]¶; Function selecting the algorithm for a CISD energy call; and directing to specified or best-performance default modules. select_fnoccsd(name, **kwargs)[source]¶; Function selecting the algorithm for a FNO-CCSD energy call; and directing to specified or best-performance default modules. select_fnoccsd_t_(name, **kwargs)[source]¶; Function selecting the algorithm for a FNO-CCSD(T) energy call; and directing to specified or best-performance default modules. select_lccd(name, **kwargs)[source]¶; Function selecting the algorithm for a LCCD energy call; and directing to specified or best-performance default modules. select_lccd_gradient(name, **kwargs)[source]¶; Function selecting the algorithm for a",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_driver-1.html:166867,energy,energy,166867,psi4manual/1.0.0/autodoc_driver-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_driver-1.html,2,['energy'],['energy']
Energy Efficiency,"ame, *, debug=False, strict_label=True)[source]; Function to write wavefunction information in wfn to filename in; Gaussian FCHK format. New in version 0.6. Returns; None. Parameters. wfn (Wavefunction) – set of molecule, basis, orbitals from which to generate fchk file; filename (str) – destination file name for FCHK file; debug (bool) – returns a dictionary to aid with debugging; strict_label (bool) – If true set a density label compliant with what Gaussian would write. A warning will be printed if this is not possible.; Otherwise set the density label according to the method name. Notes. A description of the FCHK format is http://wild.life.nctu.edu.tw/~jsyu/compchem/g09/g09ur/f_formchk.htm; The allowed headers for methods are general and limited, i.e., “Total SCF|MP2|CI|CC Density”,; PSI4 will try to find the right one for the current calculation. If strict_label=False the PSI4 method name will be used as label.; Not all theory modules in PSI4 are compatible with the FCHK writer.; A warning will be printed if a theory module is not supported.; Caution! For orbital-optimized correlated methods (e.g. DCT, OMP2) the ‘Orbital Energy’ field contains ambiguous data. Examples. Parameters. wfn (psi4.core.Wavefunction) – ; filename (str) – ; debug (bool) – ; strict_label (bool) – . >>> # [1] FCHK file for DFT calculation; >>> E, wfn = energy('b3lyp', return_wfn=True); >>> fchk(wfn, 'mycalc.fchk'). >>> # [2] FCHK file for correlated densities; >>> E, wfn = gradient('ccsd', return_wfn=True); >>> fchk(wfn, 'mycalc.fchk'). >>> # [2] Write FCHK file with non-standard label.; >>> E, wfn = gradient('mp2.5', return_wfn=True); >>> fchk(wfn, 'mycalc.fchk', strict_label=False). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities; Interface to programs through FCHK files — fchk(). © Copyright 2022, The Psi4 Project.; Last updated on Thursday, 19 May 2022 08:57PM.; Created using Sphinx 4.5.0.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/fchk.html:2836,energy,energy,2836,psi4manual/1.6.x/fchk.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/fchk.html,1,['energy'],['energy']
Energy Efficiency,"ame, npoints, deriv):. # Call this first; sup = psi4.SuperFunctional.blank(); sup.set_max_points(npoints); sup.set_deriv(deriv). # => User-Customization <= #. # No spaces, keep it short and according to convention; sup.set_name('M05'); # Tab in, trailing newlines; sup.set_description(' Heavily Parameterized Hybrid Meta-GGA XC Functional\n'); # Tab in, trailing newlines; sup.set_citation(' Zhao et. al., J. Chem. Phys., 123, 161103, 2005\n'). # Add member functionals; X = build_functional('M_X'); X.set_name('M05_X'); X.set_alpha(1.0). # LSDA Exchange type is Slater, no parameters. # GGA Exchange type is PBE, special parameters because Truhlar is lazy; C1 = 3.36116E-3; C2 = 4.49267E-3; K0 = 3.0 / 2.0 * math.pow(3.0 / (math.pi * 4.0), 1.0 / 3.0); k0 = math.pow(6.0 * math.pi * math.pi, 1.0 / 3.0); kp = C1 / (C2 * K0); mu = 4.0 * k0 * k0 * kp * C2; X.set_parameter('PBE_kp', kp) # Different effective kp; X.set_parameter('PBE_mu', mu) # Different effective mu. # Meta Exchange type is insane mess of w power series expansion; X.set_parameter('Meta_a0', 1.0); X.set_parameter('Meta_a1', 0.08151); X.set_parameter('Meta_a2', -0.43956); X.set_parameter('Meta_a3', -3.22422); X.set_parameter('Meta_a4', 2.01819); X.set_parameter('Meta_a5', 8.79431); X.set_parameter('Meta_a6', -0.00295); X.set_parameter('Meta_a7', 9.82029); X.set_parameter('Meta_a8', -4.82351); X.set_parameter('Meta_a9', -48.17574); X.set_parameter('Meta_a10', 3.64802); X.set_parameter('Meta_a11', 34.02248). C = build_functional('M_C'); C.set_name('M05_C'). # LSDA Correlation type is PW92, no parameters. # GGA Correlation type is B97; C.set_parameter('B97_os_gamma', 0.0031 * 2.0); C.set_parameter('B97_os_a0', 1.0); C.set_parameter('B97_os_a1', 3.78569); C.set_parameter('B97_os_a2', -14.15261); C.set_parameter('B97_os_a3', -7.46589); C.set_parameter('B97_os_a4', 17.94491). C.set_parameter('B97_ss_gamma', 0.06); C.set_parameter('B97_ss_a0', 1.0); C.set_parameter('B97_ss_a1', 3.77344); C.set_parameter('B97_ss_a2', -26.04",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/functional.html:62604,power,power,62604,psi4manual/4.0b5/_modules/functional.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/functional.html,3,['power'],['power']
Energy Efficiency,"ame, supp_string)). def check_disk_df(name, optstash):. optstash.add_option(['SCF_TYPE']). # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE') or core.get_global_option('SCF_TYPE') == ""DF"":; core.set_global_option('SCF_TYPE', 'DISK_DF'); core.print_out(f"""""" For method '{name}', SCF Algorithm Type (re)set to DISK_DF.\n""""""); else:; if core.get_global_option('SCF_TYPE') == ""MEM_DF"":; raise ValidationError(; f"" Method '{name}' requires SCF_TYPE = DISK_DF, please use SCF_TYPE = DF to automatically choose the correct DFJK implementation.""; ). def print_ci_results(ciwfn, rname, scf_e, ci_e, print_opdm_no=False):; """"""; Printing for all CI Wavefunctions; """""". # Print out energetics; core.print_out(""\n ==> Energetics <==\n\n""); core.print_out("" SCF energy = %20.15f\n"" % scf_e); if ""CI"" in rname:; core.print_out("" Total CI energy = %20.15f\n"" % ci_e); elif ""MP"" in rname:; core.print_out("" Total MP energy = %20.15f\n"" % ci_e); elif ""ZAPT"" in rname:; core.print_out("" Total ZAPT energy = %20.15f\n"" % ci_e); else:; core.print_out("" Total MCSCF energy = %20.15f\n"" % ci_e). # Nothing to be done for ZAPT or MP; if (""MP"" in rname) or (""ZAPT"" in rname):; core.print_out(""\n""); return. # Initial info; ci_nroots = core.get_option(""DETCI"", ""NUM_ROOTS""); irrep_labels = ciwfn.molecule().irrep_labels(). # Grab the D-vector; dvec = ciwfn.D_vector(); dvec.init_io_files(True). for root in range(ci_nroots):; core.print_out(""\n ==> %s root %d information <==\n\n"" % (rname, root)). # Print total energy; root_e = ciwfn.variable(""CI ROOT %d TOTAL ENERGY"" % (root)); core.print_out("" %s Root %d energy = %20.15f\n"" % (rname, root, root_e)). # Print natural occupations; if print_opdm_no:; core.print_out(""\n Active Space Natural occupation numbers:\n\n""). occs_list = []; r_opdm = ciwfn.get_opdm(root, root, ""SUM"", False); for h in range(len(r_opdm.nph)):; if 0 in r_opdm.nph[h].shape:; continue; nocc, rot = np.linalg.eigh(r_opdm.nph[h]); for e in nocc:; occs_list.append((e, irrep_la",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc_util.html:5112,energy,energy,5112,psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc_util.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc_util.html,6,['energy'],['energy']
Energy Efficiency,"ame.lower(). _filter_renamed_methods(""frequency"", lowername); ; return_wfn = kwargs.pop('return_wfn', False); core.clean_variables(); dertype = 2. # Prevent methods that do not have associated energies; if lowername in energy_only_methods:; raise ValidationError(""hessian('%s') does not have an associated hessian"" % name). optstash = p4util.OptionsState(; ['FINDIF', 'HESSIAN_WRITE'],; ['FINDIF', 'FD_PROJECT'],; ). # Allow specification of methods to arbitrary order; lowername, level = driver_util.parse_arbitrary_order(lowername); if level:; kwargs['level'] = level. dertype = _find_derivative_type('hessian', lowername, kwargs.pop('freq_dertype', kwargs.get('dertype', None))). # Make sure the molecule the user provided is the active one; molecule = kwargs.pop('molecule', core.get_active_molecule()); molecule.update_geometry(). # Set method-dependent scf convergence criteria (test on procedures['energy'] since that's guaranteed); optstash_conv = driver_util._set_convergence_criterion('energy', lowername, 8, 10, 8, 10, 8). # Select certain irreps; irrep = kwargs.get('irrep', -1); if irrep == -1:; pass # do all irreps; else:; irrep = driver_util.parse_cotton_irreps(irrep, molecule.schoenflies_symbol()); irrep -= 1 # A1 irrep is externally 1, internally 0; if dertype == 2:; core.print_out(; """"""hessian() switching to finite difference by gradients for partial Hessian calculation.\n""""""); dertype = 1. # At stationary point?; if 'ref_gradient' in kwargs:; core.print_out(""""""hessian() using ref_gradient to assess stationary point.\n""""""); G0 = kwargs['ref_gradient']; else:; G0 = gradient(lowername, molecule=molecule, **kwargs); translations_projection_sound, rotations_projection_sound = _energy_is_invariant(G0); core.print_out(; '\n Based on options and gradient (rms={:.2E}), recommend {}projecting translations and {}projecting rotations.\n'; .format(G0.rms(), '' if translations_projection_sound else 'not ',; '' if rotations_projection_sound else 'not ')); if not core.has_option_c",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:76959,energy,energy,76959,psi4manual/1.4.0/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html,4,['energy'],['energy']
Energy Efficiency,"ame.lower(); # kwargs = kwargs_lower(kwargs); #; # # Run detci calculation and collect conventional quantities; # energy('mp3', **kwargs); # e_scf = PsiMod.get_variable('SCF TOTAL ENERGY'); # ce_mp2 = PsiMod.get_variable('MP2 CORRELATION ENERGY'); # ce_mp3 = PsiMod.get_variable('MP3 CORRELATION ENERGY'); # e_mp2 = e_scf + ce_mp2; # e_mp3 = e_scf + ce_mp3; #; # # Compute quantities particular to MP2.5; # ce_mp25 = 0.5 * (ce_mp2 + ce_mp3); # e_mp25 = e_scf + ce_mp25; # PsiMod.set_variable('MP2.5 CORRELATION ENERGY', ce_mp25); # PsiMod.set_variable('MP2.5 TOTAL ENERGY', e_mp25); # PsiMod.set_variable('CURRENT CORRELATION ENERGY', ce_mp25); # PsiMod.set_variable('CURRENT ENERGY', e_mp25); #; # # build string of title banner and print results; # banners = ''; # banners += """"""PsiMod.print_out('\\n')\n""""""; # banners += """"""banner(' MP2.5 ')\n""""""; # banners += """"""PsiMod.print_out('\\n')\n\n""""""; # exec(banners); #; # tables = ''; # tables += """""" SCF total energy: %16.8f\n"""""" % (e_scf); # tables += """""" MP2 total energy: %16.8f\n"""""" % (e_mp2); # tables += """""" MP2.5 total energy: %16.8f\n"""""" % (e_mp25); # tables += """""" MP3 total energy: %16.8f\n\n"""""" % (e_mp3); # tables += """""" MP2 correlation energy: %16.8f\n"""""" % (ce_mp2); # tables += """""" MP2.5 correlation energy: %16.8f\n"""""" % (ce_mp25); # tables += """""" MP3 correlation energy: %16.8f\n"""""" % (ce_mp3); # PsiMod.print_out(tables); #; # return e_mp25. # A direct translation of a plugin input file into a function call. Function calls are the only; # way to call plugins in sow/reap mode for db(), opt(), etc. This isn't best practices; # but is an example of what to do for a more complicated procedure where different options ; # are set for different qc steps.; #def run_plugin_omega(name, **kwargs):; # r""""""Function encoding sequence of PSI module and plugin calls, as well; # as typical options, to access Rob Parrish's omega plugin.; #; # >>> energy('plugin_omega'); #; # """"""; # lowername = name.lower(); # kwargs = kwargs_lower(kwargs);",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/_modules/aliases.html:3641,energy,energy,3641,psi4manual/4.0b4/_modules/aliases.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/aliases.html,2,['energy'],['energy']
Energy Efficiency,"ame.lower(); kwargs = kwargs_lower(kwargs). # Wrap any positional arguments into kwargs (for intercalls among wrappers); if not('name' in kwargs) and name:; kwargs['name'] = name.lower(). # Establish function to call (only energy makes sense for cbs); if not('cbs_func' in kwargs):; if ('func' in kwargs):; kwargs['cbs_func'] = kwargs['func']; del kwargs['func']; else:; kwargs['cbs_func'] = energy; func = kwargs['cbs_func']; if not func:; raise ValidationError('Function \'%s\' does not exist to be called by wrapper complete_basis_set.' % (func.__name__)); if not(func is energy):; raise ValidationError('Wrapper complete_basis_set is unhappy to be calling function \'%s\' instead of \'energy\'.' % (func.__name__)). # Define some quantum chemical knowledge, namely what methods are subsumed in others; VARH = {}; VARH['scf'] = { 'scftot': 'SCF TOTAL ENERGY'}; VARH['mp2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY'}; VARH['mp2.5'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY', ; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY', ; 'mp3corl': 'MP3 CORRELATION ENERGY'}; VARH['mp3'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY', ; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY', ; 'mp3corl': 'MP3 CORRELATION ENERGY'}; VARH['mp4(sdq)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY', ; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY', ; 'mp3corl': 'MP3 CORRELATION ENERGY', ; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY'}; VARH['mp4'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY', ; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY', ; 'mp3corl': 'MP3 CORRELATION ENERGY', ; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY', ; 'mp4corl': 'MP4(SDTQ) CORRELATION ENERGY'} ; VARH['omp2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'omp2corl': 'OMP2 CORRELATION ENERGY'}; VARH['omp3'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRE",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:60918,ENERGY,ENERGY,60918,psi4manual/4.0b4/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html,2,['ENERGY'],['ENERGY']
Energy Efficiency,"ame; calls method in Stanton and Gauss’s CFOUR program [manual]. c4-scf; Hartree–Fock (HF). c4-mp2; 2nd-order Møller–Plesset perturbation theory (non-density-fitting) (MP2). c4-mp3; 3rd-order Møller–Plesset perturbation theory (MP3). c4-mp4(sdq); 4th-order MP perturbation theory (MP4) less triples. c4-mp4; full MP4. c4-cc2; approximate coupled cluster singles and doubles (CC2). c4-ccsd; coupled cluster singles and doubles (CCSD). c4-cc3; approximate CC singles, doubles, and triples (CC3). c4-ccsd(t); CCSD with perturbative triples (CCSD(T)). c4-ccsdt; coupled cluster singles, doubles, and triples (CCSDT). cfour; expert full control over cfour program. Examples. >>> # [1] Analytic hf optimization; >>> optimize('hf'). >>> # [2] Finite difference mp5 optimization with gradient; >>> # printed to output file; >>> e, wfn = opt('mp5', return_wfn='yes'); >>> wfn.gradient().print_out(). >>> # [3] Can automatically perform complete basis set extrapolations; >>> optimize('MP2/cc-pV([D,T]+d)Z'). >>> # [4] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> optimize(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). >>> # [5] Get info like geometry, gradient, energy back after an; >>> # optimization fails. Note that the energy and gradient; >>> # correspond to the last optimization cycle, whereas the; >>> # geometry (by default) is the anticipated *next* optimization step.; >>> try:; >>> optimize('hf/cc-pvtz'); >>> except psi4.OptimizationConvergenceError as ex:; >>> next_geom_coords_as_numpy_array = np.asarray(ex.wfn.molecule().geometry()). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. PSI4 API: Linking C++ and Python; optimize. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/api/psi4.driver.optimize-1.html:13456,energy,energy,13456,psi4manual/1.4.0/api/psi4.driver.optimize-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/api/psi4.driver.optimize-1.html,8,['energy'],['energy']
Energy Efficiency,"ame; calls method in Stanton and Gauss’s CFOUR program [manual]. c4-scf; Hartree–Fock (HF). c4-mp2; 2nd-order Møller–Plesset perturbation theory (non-density-fitting) (MP2). c4-mp3; 3rd-order Møller–Plesset perturbation theory (MP3). c4-mp4(sdq); 4th-order MP perturbation theory (MP4) less triples. c4-mp4; full MP4. c4-cc2; approximate coupled cluster singles and doubles (CC2). c4-ccsd; coupled cluster singles and doubles (CCSD). c4-cc3; approximate CC singles, doubles, and triples (CC3). c4-ccsd(t); CCSD with perturbative triples (CCSD(T)). c4-ccsdt; coupled cluster singles, doubles, and triples (CCSDT). cfour; expert full control over cfour program. Examples. >>> # [1] Analytic hf optimization; >>> optimize('hf'). >>> # [2] Finite difference mp5 optimization with gradient; >>> # printed to output file; >>> e, wfn = opt('mp5', return_wfn='yes'); >>> wfn.gradient().print_out(). >>> # [3] Can automatically perform complete basis set extrapolations; >>> optimize('MP2/cc-pV([D,T]+d)Z'). >>> # [4] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> optimize(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). >>> # [5] Get info like geometry, gradient, energy back after an; >>> # optimization fails. Note that the energy and gradient; >>> # correspond to the last optimization cycle, whereas the; >>> # geometry (by default) is the anticipated *next* optimization step.; >>> try:; >>> optimize('hf/cc-pvtz'); >>> except psi4.OptimizationConvergenceError as ex:; >>> next_geom_coords_as_numpy_array = np.asarray(ex.wfn.molecule().geometry()). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.5;  · . PSI4. PSI4 API: Linking C++ and Python; optimize. © Copyright 2021, The Psi4 Project.; Last updated on Sunday, 28 November 2021 02:41AM.; Created using Sphinx 4.3.1.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/api/psi4.driver.optimize-1.html:13456,energy,energy,13456,psi4manual/1.5.0/api/psi4.driver.optimize-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/api/psi4.driver.optimize-1.html,8,['energy'],['energy']
Energy Efficiency,"ames are all lowercase and use dashes (-) to separate; quantifiers like o, n etc.; The full list understood by ddx can be obtained using; import pyddx; print(pyddx.data.solvent_epsilon.keys()). For when an LPB solvent model is selected (DDX_MODEL is LPB); additionally the Debye-Hückel parameter DDX_SOLVENT_KAPPA needs to be provided; (in units of inverse Bohr or inverse Angström, depending on the unit used to define; the molecular geometry). pyddx provides a handy utility function to compute; the Debye-Hückel parameter. For example; import pyddx; from qcelemental import constants. list_of_ions = [(+1, 0.1), (-1, 0.1)]; dielectric_constant = pyddx.data.solvent_epsilon[""water""]; temperature = 298.15 # Kelvin; kappa_invbohr = pyddx.solvent_kappa(list_of_ions, dielectric_constant, temperature); kappa_invang = kappa_invbohr / constants.bohr2angstroms. computes the parameter (in inverse Angström) for a 0.1 mol/l solution of sodium; chloride in water, thus a solution woith 0.1 mol/l of a +1-charged ion; and 0.1 mol/l of a -1-charged ion.; The cavity in ddx is defined as a union of spheres around each atom.; Usually the spehere radii for each atom are determined using a standard; set of tabulated radii per atomic species, determined by the DDX_RADII_SET parameter.; Currently bondi [Bondi:1964:441] and uff [Rappe:1992:114]; are supported for DDX_RADII_SET with uff selected by default.; These radius values are conventionally scaled by an additional factor before use,; conventionally 1.1 for uff and 1.2 for bondi. Customisation of the scaling; is possible using the DDX_RADII_SCALING parameter.; A more fine-grained control over the sphere radii is available by explicitly providing; a list of radii (one per atom, exactly in the order of the input geometry); using the DDX_RADII parameter. Note that the same unit as for the molecular; input is expected for the radii. DDX¶. DDX boolean for ddx module. Type: boolean; Default: false. DDX_MODEL¶. Switch available solvation models. Type",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/ddx.html:4784,charge,charged,4784,psi4manual/1.8.x/ddx.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/ddx.html,3,['charge'],['charged']
Energy Efficiency,"ameters. matrix1; An example of using BLAS and LAPACK calls directly from the Psi input file, demonstrating matrix multiplication, eigendecomposition, Cholesky decomposition and LU decomposition. These operations are performed on vectors and matrices provided from the Psi library. omp2-3; OMP2 cc-pVDZ energy for the NO radical. cc21; ROHF-EOM-CCSD/DZ analytic gradient lowest \(^{2}A_1\) excited state of H2O+ (B1 excitation). opt1-fd; SCF STO-3G geometry optimzation, with Z-matrix input, by finite-differences. casscf-semi; CASSCF/6-31G** energy point. Check energy with frozen core/virtual orbs. after semicanonicalization. opt12; SCF cc-pVDZ geometry optimzation of ketene, starting from bent structure. scf-coverage; Lithium test for coverage. cc27; Single point gradient of 1-1B2 state of H2O with EOM-CCSD. omp2p5-1; OMP2.5 cc-pVDZ energy for the H2O molecule. dft1-alt; DFT Functional Test. x2c-perturb-h; Test SFX2C-1e with a static electric field on He aug-cc-pVTZ. dfcasscf-fzc-sp; CASSCF/6-31G** energy point. nbody-intermediates; HF/cc-pVDZ many body energies of an arbitrary noble gas trimer complex Size vs cost tradeoff is rough here. fd-freq-gradient-large; SCF DZ finite difference frequencies by gradients for C4NH4. dft-jk; DFT JK on-disk test. dct1; DC-06, DC-12, ODC-06 and ODC-12 calculation for the He dimer. This performs a simultaneous update of the orbitals and cumulant, using DIIS extrapolation. Four-virtual integrals are handled in the MO Basis. dft-b2plyp; Double-hybrid density functional B2PYLP. Reproduces portion of Table I in S. Grimme’s J. Chem. Phys 124 034108 (2006) paper defining the functional. cc38; RHF-CC2-LR/cc-pVDZ static polarizabilities of HOF molecule. oremp-grad2; integral conventional OO-REMP/cc-pVDZ engrad single points for the H2O molecule. single point energies were independently checked using the original wavels code. cc37; CC2(UHF)/cc-pVDZ energy of H2O+. scf-uhf-grad-nobeta; UHF gradient for a one-electron system (no beta electrons).",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/autodoc_testsuite_corepsi4.html:8820,energy,energy,8820,psi4manual/1.7.x/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/autodoc_testsuite_corepsi4.html,2,['energy'],['energy']
Energy Efficiency,"ameters; ----------; x_0; Center of the Lorentzian, i.e. its maximum. """"""; return 2.0 / (np.pi * self.gamma(x_0)). [docs]def prefactor_opa() -> float:; r""""""Prefactor for converting microscopic observable to decadic molar; extinction coefficient in one-photon absorption. Notes; -----; This function implements the calculation of the following prefactor:. .. math::. k = \frac{4\pi^{2}N_{\mathrm{A}}}{3\times 1000\times \ln(10) (4 \pi \epsilon_{0}) n \hbar c}. The prefactor is computed in SI units and then adjusted for the fact that; we use atomic units to express microscopic observables: excitation energies; and transition dipole moments.; The refractive index :math:`n` is, in general, frequency-dependent. We; assume it to be constant and equal to 1.; """""". N_A = constants.get(""Avogadro constant""); c = constants.get(""speed of light in vacuum""); hbar = constants.get(""Planck constant over 2 pi""); e_0 = constants.get(""electric constant""); au_to_Coulomb_centimeter = constants.get(""elementary charge"") * constants.get(; ""Bohr radius"") * constants.conversion_factor(""m"", ""cm""). numerator = 4.0 * np.pi**2 * N_A; denominator = 3 * 1000 * np.log(10) * (4 * np.pi * e_0) * hbar * c. return (numerator / denominator) * au_to_Coulomb_centimeter**2. [docs]def prefactor_ecd() -> float:; r""""""Prefactor for converting microscopic observable to decadic molar; extinction coefficient in electronic circular dichroism. Notes; -----; This function implements the calculation of the following prefactor:. .. math::. k = \frac{16\pi^{2}N_{\mathrm{A}}}{3\times 1000\times \ln(10) (4 \pi \epsilon_{0}) n \hbar c^{2}}. The prefactor is computed in SI units and then adjusted for the fact that; we use atomic units to express microscopic observables: excitation energies; and transition dipole moments.; The refractive index :math:`n` is, in general, frequency-dependent. We; assume it to be constant and equal to 1. """""". N_A = constants.get(""Avogadro constant""); c = constants.get(""speed of light in vacuum""); hbar",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/spectrum.html:4939,charge,charge,4939,psi4manual/1.7.x/_modules/psi4/driver/p4util/spectrum.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/spectrum.html,2,['charge'],['charge']
Energy Efficiency,"amiliar from previous test cases. Next comes a slightly; unusual-looking line, ecp = {}. This is Python’s way of initializing; a “dictionary”. We’re going to use this dictionary to store the; counterpoise-corrected energies as they become available. A dictionary is; like an array, but we can index it using strings or floating-point numbers; instead of integers if we want. Here, we will index it using; floating-point numbers, namely, the R values. This winds up being; slightly more elegant than a regular array in later parts of the input; file.; The next section, beginning with for R in Rvals:, loops over the; interatomic distances, R, in our array Rvals. In Python,; loops need to be indented, and each line in the loop has to be indented; by the same amount. The first line in the loop, dimer.R = R,; sets the Z-matrix variable R of the molecule called dimer; to the R value extracted from the Rvals array. The next line,; ecp[R] = energy('ccsd(t)', bsse_type='cp'), computes the counterpoise-corrected; CCSD(T) energy and places it in the ecp dictionary with R as; the index. Note we didn’t need to specify ghost atoms, and we didn’t need; to call the monomer and dimer computations separately. The built-in; Psithon function _nbody_gufunc() does it all for us, automatically.; Near the very end of the output file, the counterpoise correction Python; function will print a nice summary of the results of the counterpoise; computation (the energies of the dimer, of monomer 1 with the ghost functions; of monomer 2, of monomer 2 with the ghost functions of monomer 1, and the; overall counterpoise-corrected interaction energy):; //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>//; // CP Computation: Results. //; //<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<//. ============= Hartree =============; System: Energy (full):; Complex -257.4186740329; Monomer 1 -128.7093240575; Monomer 2 -128.7093240575; Interaction -0.0000259178. =========== kcal*mol^-1 ===========; System: Energy (full):; Complex -161532.66",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/tutorial-1.html:19574,energy,energy,19574,psi4manual/1.0.0/tutorial-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/tutorial-1.html,4,['energy'],['energy']
Energy Efficiency,"amiliar from previous test cases. Next comes a slightly; unusual-looking line, ecp = {}. This is Python’s way of initializing; a “dictionary”. We’re going to use this dictionary to store the; counterpoise-corrected energies as they become available. A dictionary is; like an array, but we can index it using strings or floating-point numbers; instead of integers if we want. Here, we will index it using; floating-point numbers, namely, the R values. This winds up being; slightly more elegant than a regular array in later parts of the input; file.; The next section, beginning with for R in Rvals:, loops over the; interatomic distances, R, in our array Rvals. In Python,; loops need to be indented, and each line in the loop has to be indented; by the same amount. The first line in the loop, dimer.R = R,; sets the Z-matrix variable R of the molecule called dimer; to the R value extracted from the Rvals array. The next line,; ecp[R] = energy('ccsd(t)', bsse_type='cp'), computes the counterpoise-corrected; CCSD(T) energy and places it in the ecp dictionary with R as; the index. Note we didn’t need to specify ghost atoms, and we didn’t need; to call the monomer and dimer computations separately. The built-in; Psithon function nbody() does it all for us, automatically.; Near the very end of the output file, the counterpoise correction Python; function will print a nice summary of the results of the counterpoise; computation (the energies of the dimer, of monomer 1 with the ghost functions; of monomer 2, of monomer 2 with the ghost functions of monomer 1, and the; overall counterpoise-corrected interaction energy):; N-Body: Computing complex (1/2) with fragments (2,) in the basis of fragments (1, 2).; ...; N-Body: Complex Energy (fragments = (2,), basis = (1, 2): -128.70932405488924); ...; N-Body: Computing complex (2/2) with fragments (1,) in the basis of fragments (1, 2).; ...; N-Body: Complex Energy (fragments = (1,), basis = (1, 2): -128.70932405488935); ...; N-Body: Comput",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/tutorial.html:20216,energy,energy,20216,psi4manual/1.6.x/tutorial.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/tutorial.html,10,['energy'],['energy']
Energy Efficiency,"amiliar from previous test cases. Next comes a slightly; unusual-looking line, ecp = {}. This is Python’s way of initializing; a “dictionary”. We’re going to use this dictionary to store the; counterpoise-corrected energies as they become available. A dictionary is; like an array, but we can index it using strings or floating-point numbers; instead of integers if we want. Here, we will index it using; floating-point numbers, namely, the R values. This winds up being; slightly more elegant than a regular array in later parts of the input; file.; The next section, beginning with for R in Rvals:, loops over the; interatomic distances, R, in our array Rvals. In Python,; loops need to be indented, and each line in the loop has to be indented; by the same amount. The first line in the loop, dimer.R = R,; sets the Z-matrix variable R of the molecule called dimer; to the R value extracted from the Rvals array. The next line,; ecp[R] = energy('ccsd(t)', bsse_type='cp'), computes the counterpoise-corrected; CCSD(T) energy and places it in the ecp dictionary with R as; the index. Note we didn’t need to specify ghost atoms, and we didn’t need; to call the monomer and dimer computations separately. The built-in; Psithon function nbody_gufunc() does it all for us, automatically.; Near the very end of the output file, the counterpoise correction Python; function will print a nice summary of the results of the counterpoise; computation (the energies of the dimer, of monomer 1 with the ghost functions; of monomer 2, of monomer 2 with the ghost functions of monomer 1, and the; overall counterpoise-corrected interaction energy):; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17N-Body: Computing complex (1/2) with fragments (2,) in the basis of fragments (1, 2).; ...; N-Body: Complex Energy (fragments = (2,), basis = (1, 2): -128.70932405488924); ...; N-Body: Computing complex (2/2) with fragments (1,) in the basis of fragments (1, 2).; ...; N-Body: Complex Energy (fragments =",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/tutorial-1.html:20323,energy,energy,20323,psi4manual/1.1.0/tutorial-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/tutorial-1.html,12,['energy'],['energy']
Energy Efficiency,"amiliar from previous test cases. Next comes a slightly; unusual-looking line, ecp = {}. This is Python’s way of initializing; a “dictionary”. We’re going to use this dictionary to store the; counterpoise-corrected energies as they become available. A dictionary is; like an array, but we can index it using strings or floating-point numbers; instead of integers if we want. Here, we will index it using; floating-point numbers, namely, the R values. This winds up being; slightly more elegant than a regular array in later parts of the input; file.; The next section, beginning with for R in Rvals:, loops over the; interatomic distances, R, in our array Rvals. In Python,; loops need to be indented, and each line in the loop has to be indented; by the same amount. The first line in the loop, dimer.R = R,; sets the Z-matrix variable R of the molecule called dimer; to the R value extracted from the Rvals array. The next line,; ecp[R] = energy('ccsd(t)', bsse_type='cp'), computes the counterpoise-corrected; CCSD(T) energy and places it in the ecp dictionary with R as; the index. Note we didn’t need to specify ghost atoms, and we didn’t need; to call the monomer and dimer computations separately. The built-in; Psithon function nbody_gufunc() does it all for us, automatically.; Near the very end of the output file, the counterpoise correction Python; function will print a nice summary of the results of the counterpoise; computation (the energies of the dimer, of monomer 1 with the ghost functions; of monomer 2, of monomer 2 with the ghost functions of monomer 1, and the; overall counterpoise-corrected interaction energy):; N-Body: Computing complex (1/2) with fragments (2,) in the basis of fragments (1, 2).; ...; N-Body: Complex Energy (fragments = (2,), basis = (1, 2): -128.70932405488924); ...; N-Body: Computing complex (2/2) with fragments (1,) in the basis of fragments (1, 2).; ...; N-Body: Complex Energy (fragments = (1,), basis = (1, 2): -128.70932405488935); ...; N-Body:",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/tutorial-1.html:20216,energy,energy,20216,psi4manual/1.4.0/tutorial-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/tutorial-1.html,8,['energy'],['energy']
Energy Efficiency,"amination of the noninteracting quasiparticles (the; \(S^2\) metric printed in the output) is usually a severe overestimation; of the spin contamination of the true electrons. These are set in the REFERENCE option.; Note that there are not equivalents to ROHF or CUHF, e.g., no ROKS or CUKS. This; is because ROHF is implicitly assumed to be followed by a correlated method; which can break the positive definiteness of the spin polarization. KS-DFT with; the true functional is expected to be the final step, thus restricting the; solution to positive definite spin polarization is not physical. See the; section in [Szabo:1982] on methyl radical for an example. Functional Selection¶; PSI4 features an extensive list of LSDA, GGA, Meta, Hybrid, LRC, and -D; functionals. These can be specified by a variety of means. Perhaps the simplest; is to use the functional name as the energy procedure call:; 1energy('b3lyp'). Note that if you are running an unrestricted computation, you should set the; REFERENCE option before the call to energy:; 1; 2set reference uks; energy('b3lyp'). The functional may also be manually specified by calling energy (or any driver function); with a dft_functional argument:; 1energy('scf', dft_functional = 'b3lyp'). Another alternative is providing a specially crafted dict-ionary to the dft_functional; argument:; 1; 2custom_functional = { ""name"": ""my_unique_name"", ... }; energy('scf', dft_functional = custom_functional). For further details about this so called dict_func syntax, see; Advanced Functional Use and Manipulation.; For hybrid functionals, the fraction of exact exchange is controlled by the; DFT_ALPHA option. For the LRC functionals, the fraction of long-range; Hartree–Fock and short-range DFA is controlled by the DFT_OMEGA option.; Changing these will override the default behavior of the requested functional.; A brief summary of some of the more notable functionals in PSI4, and links; to the complete listing of all functionals of each class are",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/dft-1.html:14841,energy,energy,14841,psi4manual/1.3.2/dft-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/dft-1.html,4,['energy'],['energy']
Energy Efficiency,"amination of the noninteracting quasiparticles (the; \(S^2\) metric printed in the output) is usually a severe overestimation; of the spin contamination of the true electrons. These are set in the REFERENCE option.; Note that there are not equivalents to ROHF or CUHF, e.g., no ROKS or CUKS. This; is because ROHF is implicitly assumed to be followed by a correlated method; which can break the positive definiteness of the spin polarization. KS-DFT with; the true functional is expected to be the final step, thus restricting the; solution to positive definite spin polarization is not physical. See the; section in [Szabo:1982] on methyl radical for an example. Functional Selection¶; PSI4 features an extensive list of LSDA, GGA, Meta, Hybrid, LRC, and -D; functionals. These can be specified by a variety of means. Perhaps the simplest; is to use the functional name as the energy procedure call:; 1energy('b3lyp'). Note that if you are running an unrestricted computation, you should set the; REFERENCE option before the call to energy:; 1; 2set reference uks; energy('b3lyp'). The functional may also be manually specified by calling energy (or any other keyword); with a dft_functional argument:; 1energy('scf', dft_functional = 'b3lyp'). Another alternative is providing a specially crafted dict-ionary to the dft_functional; argument:; 1; 2custom_functional = { ""name"": ""my_unique_name"", ... }; energy('scf', dft_functional = custom_functional). For further details about this so called dict_func syntax, see; :ref: Advanced Functional Use and Manipulation.; For hybrid functionals, the fraction of exact exchange is controlled by the; DFT_ALPHA option. For the LRC functionals, the fraction of long-range; Hartree–Fock and short-range DFA is controlled by the DFT_OMEGA option.; Changing these will override the default behavior of the requested functional.; A brief summary of some of the more notable functionals in PSI4, and links; to the complete listing of all functionals of each class",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/dft-1.html:14820,energy,energy,14820,psi4manual/1.2.1/dft-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/dft-1.html,4,['energy'],['energy']
Energy Efficiency,"amination of the noninteracting quasiparticles (the; \(S^2\) metric printed in the output) is usually a severe overestimation; of the spin contamination of the true electrons. These are set in the REFERENCE option.; Note that there are not equivalents to ROHF or CUHF, e.g., no ROKS or CUKS. This; is because ROHF is implicitly assumed to be followed by a correlated method; which can break the positive definiteness of the spin polarization. KS-DFT with; the true functional is expected to be the final step, thus restricting the; solution to positive definite spin polarization is not physical. See the; section in [Szabo:1982] on methyl radical for an example. Functional Selection¶; PSI4 features an extensive list of LSDA, GGA, Meta, Hybrid, LRC, and -D; functionals. These can be specified by a variety of means. Perhaps the simplest; is to use the functional name as the energy procedure call:; 1energy('b3lyp'). Note that if you are running an unrestricted computation, you should set the; REFERENCE option before the call to energy:; 1; 2set reference uks; energy('b3lyp'). The functional may also be manually specified by the DFT_FUNCTIONAL; option:; 1; 2set dft_functional b3lyp; energy('scf'). For hybrid functionals, the fraction of exact exchange is controlled by the; DFT_ALPHA option. For the LRC functionals, the fraction of long-range; Hartree–Fock and short-range DFA is controlled by the DFT_OMEGA option.; Changing these will override the default behavior of the requested functional.; A brief summary of some of the more notable functionals in PSI4, and links; to the complete listing of all functionals of each class are presented below:. All Functionals; All functionals, including LSDA-only functionals. Note that here and; throughout, functionals which end in _X or _C are exchange or; correlation only, and should not be used for most production-level; computations. Examples include PBE_X and PBE_C, which contain the; separate definitions of the PBE exchange and correlati",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/dft-1.html:14545,energy,energy,14545,psi4manual/1.1.0/dft-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/dft-1.html,4,['energy'],['energy']
Energy Efficiency,"amination of the true electrons. These are set in the REFERENCE option.; Note that there are not equivalents to ROHF or CUHF, e.g., no ROKS or CUKS. This; is because ROHF is implicitly assumed to be followed by a correlated method; which can break the positive definiteness of the spin polarization. KS-DFT with; the true functional is expected to be the final step, thus restricting the; solution to positive definite spin polarization is not physical. See the; section in [Szabo:1982] on methyl radical for an example. Functional Selection¶; PSI4 features an extensive list of LSDA, GGA, Meta, Hybrid, LRC, and -D; functionals. These can be specified by a variety of means. Perhaps the simplest; is to use the functional name as the energy procedure call:; 1energy('b3lyp'). Note that if you are running an unrestricted computation, you should set the; REFERENCE option before the call to energy:; 1; 2set reference uks; energy('b3lyp'). The functional may also be manually specified by the DFT_FUNCTIONAL; option:; 1; 2set dft_functional b3lyp; energy('scf'). For hybrid functionals, the fraction of exact exchange is controlled by the; DFT_ALPHA option. For the LRC functionals, the fraction of long-range; Hartree–Fock and short-range DFA is controlled by the DFT_OMEGA option.; Changing these will override the default behavior of the requested functional.; A brief summary of some of the more notable functionals in PSI4, and links; to the complete listing of all functionals of each class are presented below:. All Functionals; All functionals, including LSDA-only functionals. Note that here and; throughout, functionals which end in _X or _C are exchange or; correlation only, and should not be used for most production-level; computations. Examples include PBE_X and PBE_C, which contain the; separate definitions of the PBE exchange and correlation holes. In most cases,; the united PBE functional should be used instead.; GGA Functionals; Many common GGA functionals. BLYP and PBE are pro",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/dft-1.html:14702,energy,energy,14702,psi4manual/1.1.0/dft-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/dft-1.html,2,['energy'],['energy']
Energy Efficiency,"an absolute deviation of the database in kcal/mol. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`db_name DATABASE MEAN SIGNED DEVIATION <db_nameDATABASEMEANSIGNEDDEVIATION>`; * :psivar:`db_name DATABASE MEAN ABSOLUTE DEVIATION <db_nameDATABASEMEANABSOLUTEDEVIATION>`; * :psivar:`db_name DATABASE ROOT-MEAN-SQUARE DEVIATION <db_nameDATABASEROOT-MEAN-SQUARESIGNEDDEVIATION>`. .. note:: It is very easy to make a database from a collection of xyz files; using the script :source:`lib/scripts/ixyz2database.pl`.; See :ref:`sec:createDatabase` for details. .. caution:: Some features are not yet implemented. Buy a developer some coffee. - In sow/reap mode, use only global options (e.g., the local option set by ``set scf scf_type df`` will not be respected). :type name: string; :param name: ``'scf'`` || ``'sapt0'`` || ``'ccsd(t)'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; :py:func:`~driver.energy`. :type db_name: string; :param db_name: ``'BASIC'`` || ``'S22'`` || ``'HTBH'`` || etc. Second argument, usually unlabeled. Indicates the requested database; name, matching the name of a python file in ``psi4/lib/databases``.; Consult that directory for available databases and literature citations. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``energy`` |dr| || ``optimize`` || ``cbs``. Indicates the type of calculation to be performed on each database; member. The default performs a single-point ``energy('name')``, while; ``optimize`` perfoms a geometry optimization on each reagent, and; ``cbs`` performs a compound single-point energy. If a nested series; of python functions is intended (see :ref:`sec:intercalls`), use; keyword ``db_func`` instead of ``func``. :type mode: string; :param mode: |dl| ``'continuous'`` |dr| || ``'sow'`` || ``'reap'``. Indicates whether the calculations required to complete the; database are to be run in one file (``'continuous'``) or a",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:23662,energy,energy,23662,psi4manual/4.0b2/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html,2,['energy'],['energy']
Energy Efficiency,"an arbitrary Helium complex Size vs cost tradeoff is rough here. dft-grad-lr1; wB97X-D cc-pVDZ gradient of S22 HCN update df/pk_ref values due to new BraggSlater radii. opt1; SCF STO-3G geometry optimzation, with Z-matrix input. numpy-array-interface; Numpy interface testing. fsaptd-terms; F-SAPT0/jun-cc-pvdz procedure for methane dimer. pywrap-align; apply linear fragmentation algorithm to a water cluster. opt4; SCF cc-pVTZ geometry optimzation, with Z-matrix input. fsapt-ext-abc-au; analog of fsapt-ext-abc with molecule and external potentials in Bohr. psimrcc-ccsd_t-4; Mk-MRCCSD(T) single point. \(^1A_1\) O$_3` state described using the Ms = 0 component of the singlet. Uses TCSCF orbitals. dct-grad1; Various DCT analytic gradients for the O2 molecule with 6-31G basis set. dft3; DFT integral algorithms test, performing w-B97 RKS and UKS computations on water and its cation, using all of the different integral algorithms. This tests both the ERI and ERF integrals. dfcasscf-sp; CASSCF/6-31G** energy point. dft-grad2; DF-BP86-D2 cc-pVDZ frozen core gradient of S22 HCN updated ref gradient due to new BraggSlater radii. olccd-grad2; OLCCD cc-pVDZ gradient for the NO radical. nbody-convergence; Convergence of many-body gradients of different BSSE schemes. sapt-dft2; SAPT(DFT) aug-cc-pVDZ computation for the water dimer interaction energy. cbs-xtpl-dict; Extrapolated water energies. cisd-h2o+-1; 6-31G** H2O+ Test CISD Energy Point. olccd3; OLCCD cc-pVDZ energy with ROHF initial guess for the NO radical. pywrap-freq-g-sowreap; Finite difference of gradients frequency, run in sow/reap mode. cc32; CC3/cc-pVDZ H2O \(R_e\) geom from Olsen et al., JCP 104, 8007 (1996). mints4; A demonstration of mixed Cartesian/ZMatrix geometry specification, using variables, for the benzene-hydronium complex. Atoms can be placed using ZMatrix coordinates, whether they belong to the same fragment or not. Note that the Cartesian specification must come before the ZMatrix entries because the for",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/autodoc_testsuite_corepsi4-1.html:21141,energy,energy,21141,psi4manual/1.5.0/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/autodoc_testsuite_corepsi4-1.html,4,['energy'],['energy']
Energy Efficiency,"an attraction of \(-1.21\) kcal/mol. It is not surprising that the electrostatic contribution is dominant, because the geometry chosen for this example has the acetylene perpendicular to; the ethylene, with the acetylene hydrogen pointing directly at the double bond in ethylene; this will be attractive because the H atoms in acetylene bear a partial positive charge, while the electron rich double bond in ethylene bears a partial negative charge. At the same time, the dispersion interaction should be smaller because the perpendicular geometry does not allow much overlap between the monomers. Hence, the SAPT analysis helps clarify (and quantify) our physical understanding about the; interaction between the two monomers. V. Potential Surface Scans and Counterpoise Correction Made Easy¶; Finally, let’s consider an example which highlights the advantages of being able to interact with Psi4 directly with Python.; Suppose you want to do a limited potential energy surface scan, such as computing the interaction energy between two neon atoms at various interatomic distances. One simple but unappealing way to do this is to generate separate geometries for each distance to be studied. Instead, we can leverage Python loops and string formatting to make our lives simpler. Additionally, let’s suppose you want to do counterpoise (CP) correction to compute interaction energies. Counterpoise correction involves; computing the dimer energy and then subtracting out the energies of the two monomers, each evaluated in the dimer basis. Again, each of these computations could be run in a separate input file, but because counterpoise correction is a fairly standard procedure for intermolecular interactions, Psi4 knows about it and has a built-in routine to perform counterpoise correction. It only needs to know what method you want to do the couterpoise correction on (here, let’s consider CCSD(T)), and it needs; to know what’s monomer A and what’s monomer B. This last issue of specifying the",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/psiapi-1.html:17184,energy,energy,17184,psi4manual/1.3.2/psiapi-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/psiapi-1.html,22,['energy'],['energy']
Energy Efficiency,"an external potential to the private external_potentials list. reference_wavefunction(self); Returns the reference wavefunction. reset_occupation(self); docstring. rotate_orbitals(self, arg0, arg1); docstring. same_a_b_dens(self); Returns true if the alpha and beta densities are the same. same_a_b_orbs(self); Returns true if the alpha and beta orbitals are the same. save_density_and_energy(self); docstring. scalar_variable(self, arg0); Returns the requested (case-insensitive) double QC variable. scalar_variables(self); Returns the dictionary of all double QC variables. scf_type(self); Return the value of scf_type used in the SCF computation. semicanonicalize(self); Semicanonicalizes the orbitals for ROHF. set_array(key, val). Deprecated since version 1.4. set_array_variable(self, arg0, arg1); Sets the requested (case-insensitive) Matrix QC variable. set_basisset(self, arg0, arg1); Sets the requested auxiliary basis. set_energies(self, arg0, arg1); docstring. set_energy(self, arg0); Sets the Wavefunction's energy. set_external_cpscf_perturbation(self, name, ...); Add an external potential/perturbation to the private external_cpscf_perturbations map for CPSCF. set_external_potential(self, arg0); Sets the requested external potential. set_frequencies(val). Deprecated since version 1.4. set_gradient(self, arg0); Sets the Wavefunction's gradient. set_hessian(self, arg0); Sets the Wavefunction's Hessian. set_jk(self, arg0); Sets the internal JK object !expert. set_lagrangian(self, arg0); Sets the orbital Lagrangian matrix. set_legacy_frequencies(self, arg0); Sets the frequencies of the Hessian. set_module(self, module); Sets name of the last/highest level of theory module (internal or external) touching the wavefunction. set_name(self, arg0); Sets the level of theory this wavefunction corresponds to. set_potential_variable(self, arg0, arg1); Sets the requested (case-insensitive) ExternalPotential QC variable. set_print(self, arg0); Sets the print level of the Wavefunction",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/api/psi4.core.cuhf.html:10042,energy,energy,10042,psi4manual/1.5.0/api/psi4.core.cuhf.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/api/psi4.core.cuhf.html,20,['energy'],['energy']
Energy Efficiency,"an or string) – 'on' || 'off' || '3-21g' || 'cc-pVDZ' || etc.; Indicates whether, to accelerate convergence for the scf portion of; the name calculation, a preliminary scf should be performed with a; small basis set (3-21G if a basis name is not supplied as keyword; value) followed by projection into the full target basis. Deprecated since version Sept-2012: Use option BASIS_GUESS instead. Parameters:cast_up_df (boolean or string) – 'on' || 'off' || 'cc-pVDZ-RI' || 'aug-cc-pVDZ-JKFIT' || etc.; Indicates whether, when cast_up is active, to run the preliminary; scf in density-fitted mode or what fitting basis to employ (when; available for all elements, cc-pVDZ-RI is the default). Deprecated since version Sept-2012: Use option DF_BASIS_GUESS instead. Parameters:bypass_scf (boolean) – 'on' || 'off' ; Indicates whether, for name values built atop of scf calculations,; the scf step is skipped. Suitable when special steps are taken to get; the scf to converge in an explicit preceeding scf step. Examples :. >>> # [1] Coupled-cluster singles and doubles calculation with psi code; >>> energy('ccsd'). >>> # [2] Charge-transfer SAPT calculation with scf projection from small into; >>> # requested basis, with specified projection fitting basis; >>> set basis_guess true; >>> set df_basis_guess jun-cc-pVDZ-JKFIT; >>> energy('sapt0-ct'). >>> # [3] Arbitrary-order MPn calculation; >>> energy('mp4'). >>> # [4] Converge scf as singlet, then run detci as triplet upon singlet reference; >>> molecule H2 {\\n0 1\\nH\\nH 1 0.74\\n}; >>> energy('scf'); >>> H2.set_multiplicity(3); >>> energy('detci', bypass_scf=True). Previous topic; Notes on Options; Next topic; Property; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta3] » ; Psithon Functions: Invoking a Calculation ». © Copyright 2012, The Psi4 Project.; Last updated on Nov 02, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/energy-1.html:12383,energy,energy,12383,psi4manual/4.0b3/energy-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/energy-1.html,10,['energy'],['energy']
Energy Efficiency,"an run with a minimal input and set symmetry. cc25; Single point gradient of 1-2B2 state of H2O+ with EOM-CCSD. fd-gradient; SCF STO-3G finite-difference tests. scf6; Tests RHF/ROHF/UHF SCF gradients. psimrcc-ccsd_t-3; Mk-MRCCSD(T) single point. CH2 state described using the Ms = 0 component of the singlet. Uses RHF singlet orbitals. mcscf1; ROHF 6-31G** energy of the state of CH2, with Z-matrix input. The occupations are specified explicitly. sapt5; SAPT0 aug-cc-pVTZ computation of the charge transfer energy of the water dimer. adc2; ADC/aug-cc-pVDZ on two water molecules that are distant from 1000 angstroms from each other. cc40; RHF-CC2-LR/cc-pVDZ optical rotation of H2O2. gauge = length, omega = (589 355 nm). dcft2; DCFT-06 calculation for the He dimer. This performs a two-step update of the orbitals and cumulant, using DIIS extrapolation. Four-virtual integrals are handled in the MO Basis. cc32; CC3/cc-pVDZ H2O geom from Olsen et al., JCP 104, 8007 (1996). tu1-h2o-energy; Sample HF/cc-pVDZ H2O computation. dcft4; DCFT calculation for the HF+ using DCFT-06 functional. This performs both two-step and simultaneous update of the orbitals and cumulant using DIIS extrapolation. Four-virtual integrals are first handled in the MO Basis for the first two energy computations. In the next two the ao_basis=disk algorithm is used, where the transformation of integrals for four-virtual case is avoided. fci-h2o; 6-31G H2O Test FCI Energy Point. psimrcc-pt2; Mk-MRPT2 single point. F2 state described using the Ms = 0 component of the singlet. Uses TCSCF singlet orbitals. cc46; EOM-CC2/cc-pVDZ on H2O2 with two excited states in each irrep. mints4; A demonstration of mixed Cartesian/ZMatrix geometry specification, using variables, for the benzene-hydronium complex. Atoms can be placed using ZMatrix coordinates, whether they belong to the same fragment or not. Note that the Cartesian specification must come before the ZMatrix entries because the former define absolute positions, wh",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/autodoc_testsuite-1.html:1460,energy,energy,1460,psi4manual/4.0b2/autodoc_testsuite-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/autodoc_testsuite-1.html,4,['energy'],['energy']
Energy Efficiency,"an(). molecule h {; H; }. set basis cc-pvdz; set reference uhf; energy('scf') # on H. Here, two separate jobs are performed on two different molecules; the first is; performed on H2, while the second is for H atom. The last molecule to be; specified is the “active” molecule by default. To explicitly activate a named; molecule, the activate command is provided. With it, the above input file can be; equivalently written as follows. Alternatively, the molecule can be specified; directly to the computing function. Below, the third calculation is the same as; the first.; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19; 20; 21; 22; 23; 24; 25; 26; 27; 28molecule h2 {; H; H 1 0.9; }. molecule h {; H; }. activate(h2); set basis cc-pvdz; set reference rhf; energy('scf') # on H2. clean(). activate(h); set basis cc-pvdz; set reference uhf; energy('scf') # on H. # --------------------------------------; # equivalent to previous input ends here. clean(). set reference rhf; energy('scf', molecule=h2) # on H2. Job Control Keywords provides more details about the job control; and calculation keywords used in the above examples. Ghost Atoms¶; While many common computations, particularly SAPT and counterpoise corrections, can; be greatly simplified using the notation described in Non-Covalently Bonded Molecule Fragments,; manual specification of ghost atoms is sometimes required. Either; 1; 2; 3; 4molecule he2 {; He; Gh(He) 1 2.0; }. or; 1; 2; 3; 4molecule he2 {; He; @He 1 2.0; }. will generate a helium dimer with the second atom ghosted, i.e., possessing; basis functions but no electrons or nuclear charge. See dfmp2_1; and ghosts for a demonstration of both mechanisms for specifying; ghost atoms. Isotopic Substitution¶. Caution; Use of isotopic substitution in PSI4 is not well; developed, and the syntax is subject to change. At present, isotopes can only be specified at creation-time of the molecule; The syntax for a deuterium- and tritium-substituted water is below",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/psithonmol-1.html:6033,energy,energy,6033,psi4manual/1.1.0/psithonmol-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/psithonmol-1.html,6,['energy'],['energy']
Energy Efficiency,"an) – 'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return dictionary of lists of geometries,; energies, and gradients at each step in the optimization. engine (str) – \(\Rightarrow\) 'optking' \(\Leftarrow\) || 'geometric'; Indicates the optimization engine to use, which can be either Psi4’s; native Optking optimizer or the GeomeTRIC program. optimizer_keywords (dict) – Options passed to the GeomeTRIC optimizer; Indicates additional options to be passed to the GeomeTRIC optimizer if; chosen as the optimization engine. func (function) – \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. dertype (dertype) – 'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. hessian_with (str) – 'scf' || 'mp2' || etc.; Indicates the computational method with which to perform a hessian; analysis to guide the geometry optimization. Warning; Optimizations where the molecule is specified in Z-matrix format; with dummy atoms will result in the geometry being converted to a Cartesian representation. Note; Analytic gradients area available for all methods in the table; below. Optimizations with other methods in the energy table proceed; by finite differences. name; calls method. efp; efp-only optimizations. scf; Hartree–Fock (HF) or density functional theory (DFT) [manual]. hf; HF self consistent field (SCF) [manual]. dct; density cumulant (functional) theory [manual]. mp2; 2nd-order Møller–Plesset perturbation theory (MP2) [manual] [details]. mp3; 3rd-order Møller–Plesset perturbation theory (MP3) [manual] [details]. mp2.5; average of MP2 and MP3 [manual] [details]. omp2; orbital-optimized se",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/api/psi4.driver.opt-1.html:1989,energy,energy,1989,psi4manual/1.4.0/api/psi4.driver.opt-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/api/psi4.driver.opt-1.html,25,['energy'],['energy']
Energy Efficiency,"an; Default: true. DO_LEVEL_SHIFT (OCC); OCC — Do apply level shifting?. Type: boolean; Default: true. DO_MBPT_DISP (SAPT); SAPT (Expert) — Do MBPT dispersion correction in SAPT2+, SAPT2+(3) or SAPT2+3, if also doing CCD?. Type: boolean; Default: true. DO_SCS (DFOCC); DFOCC — Do perform spin-component-scaled OMP2 (SCS-OMP2)? In all computation, SCS-OMP2 energy is computed automatically. However, in order to perform geometry optimizations and frequency computations with SCS-OMP2, one needs to set ‘DO_SCS’ to true. Type: boolean; Default: false. DO_SCS (OCC); OCC — Do perform spin-component-scaled OMP2 (SCS-OMP2)? In all computation, SCS-OMP2 energy is computed automatically. However, in order to perform geometry optimizations and frequency computations with SCS-OMP2, one needs to set ‘DO_SCS’ to true. Type: boolean; Default: false. DO_SINGLETS (CPHF); CPHF — Do singlet states? Default true. Type: boolean; Default: true. DO_SOS (DFOCC); DFOCC — Do perform spin-opposite-scaled OMP2 (SOS-OMP2)? In all computation, SOS-OMP2 energy is computed automatically. However, in order to perform geometry optimizations and frequency computations with SOS-OMP2, one needs to set ‘DO_SOS’ to true. Type: boolean; Default: false. DO_SOS (OCC); OCC — Do perform spin-opposite-scaled OMP2 (SOS-OMP2)? In all computation, SOS-OMP2 energy is computed automatically. However, in order to perform geometry optimizations and frequency computations with SOS-OMP2, one needs to set ‘DO_SOS’ to true. Type: boolean; Default: false. DO_THIRD_ORDER (SAPT); SAPT (Expert) — Do compute third-order corrections?. Type: boolean; Default: false. DO_TRIPLETS (CPHF); CPHF — Do triplet states? Default true. Type: boolean; Default: true. DOCC (GLOBALS); GLOBALS — An array containing the number of doubly-occupied orbitals per irrep (in Cotton order). Type: array; Default: No Default. DOCC (MCSCF); MCSCF — The number of doubly occupied orbitals, per irrep. Type: array; Default: No Default. DYNAMIC_LEVEL (OPTKING); OP",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/autodoc_glossary_options_c-1.html:112754,energy,energy,112754,psi4manual/1.3.2/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/autodoc_glossary_options_c-1.html,2,['energy'],['energy']
Energy Efficiency,"an; Default: true. EFP_DISP_DAMPING¶. Fragment-fragment dispersion damping type. TT is a damping formula by Tang and Toennies. OVERLAP is overlap-based dispersion damping. Type: string; Possible Values: TT, OVERLAP, OFF; Default: OVERLAP. EFP_ELST¶. Do include electrostatics energy term in EFP computation?. Type: boolean; Default: true. EFP_ELST_DAMPING¶. Fragment-fragment electrostatic damping type. SCREEN is a damping formula based on screen group in the EFP potential. OVERLAP is damping that computes charge penetration energy. Type: string; Possible Values: SCREEN, OVERLAP, OFF; Default: SCREEN. EFP_EXCH¶. Do include exchange repulsion energy term in EFP computation?. Type: boolean; Default: true. EFP_POL¶. Do include polarization energy term in EFP computation?. Type: boolean; Default: true. EFP_POL_DAMPING¶. Fragment-fragment polarization damping type. TT is a damping formula like Tang and Toennies. Type: string; Possible Values: TT, OFF; Default: TT. PRINT¶. The amount of information printed to the output file. Type: integer; Default: 1. QMEFP_ELST¶. Do include electrostatics energy term in QM/EFP computation?. Type: boolean; Default: true. QMEFP_POL¶. Do include polarization energy term in EFP computation?. Type: boolean; Default: true. Expert¶. DERTYPE¶. Do EFP gradient?. Type: string; Possible Values: NONE, FIRST; Default: NONE. QMEFP¶. Do turn on QM/EFP terms?. Type: boolean; Default: false. Table Of Contents. EFP; General; EFP_DISP; EFP_DISP_DAMPING; EFP_ELST; EFP_ELST_DAMPING; EFP_EXCH; EFP_POL; EFP_POL_DAMPING; PRINT; QMEFP_ELST; QMEFP_POL. Expert; DERTYPE; QMEFP. Previous topic; DMRG_UNITARY_WRITE; Next topic; DERTYPE. This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; Psi4 [1.0.0 6a9a71b] » ; Appendices »; Keywords by Module ». © Copyright 2016, The Psi4 Project.; Last updated on Tuesday, 05 July 2016 02:54AM.; Created using Sphinx 1.3.5.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodir_options_c/module__efp-1.html:1448,energy,energy,1448,psi4manual/1.0.0/autodir_options_c/module__efp-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodir_options_c/module__efp-1.html,4,['energy'],['energy']
Energy Efficiency,"an; Default: true. MCSCF_E_CONVERGENCE¶. Convergence criterion for energy. See Table Post-SCF Convergence for default convergence criteria for different calculation types. Type: conv double; Default: 1e-7. MCSCF_GUESS¶. Initial MCSCF starting guess, MP2 natural orbitals only available for DF-RHF reference. Type: string; Possible Values: MP2, SCF; Default: SCF. MCSCF_MAXITER¶. Maximum number MCSCF of iterations. Type: integer; Default: 30. MCSCF_MAX_ROT¶. Maximum value in the rotation matrix. If a value is greater than this number all values are scaled. Type: double; Default: 0.5. MCSCF_ROTATE¶. Apply a list of 2x2 rotation matrices to the orbitals in the form of [irrep, orbital1, orbital2, theta] where an angle of 0 would do nothing and an angle of 90 would switch the two orbitals. Type: array; Default: No Default. MCSCF_R_CONVERGENCE¶. Convergence criterion for the RMS of the orbital gradient. Type: conv double; Default: 1e-5. MCSCF_SO_START_E¶. Start second-order (AH or OS) orbital-orbital MCSCF based on energy convergence. Type: double; Default: 1e-4. MCSCF_SO_START_GRAD¶. Start second-order (AH or OS) orbital-orbital MCSCF based on RMS of orbital gradient. Type: double; Default: 1e-4. MCSCF_TYPE¶. Method to handle the two-electron integrals. Type: string; Possible Values: DF, CONV, AO; Default: CONV. Expert General Options¶. CI_NUM_THREADS¶. Number of threads for DETCI. Type: integer; Default: 1. EX_ALLOW¶. An array of length EX_LEVEL specifying whether each excitation type (S,D,T, etc.) is allowed (1 is allowed, 0 is disallowed). Used to specify non-standard CI spaces such as CIST. Type: array; Default: No Default. MIXED¶. Do allow “mixed” RAS II/RAS III excitations into the CI space? If FALSE, then if there are any electrons in RAS III, then the number of holes in RAS I cannot exceed the given excitation level EX_LEVEL. Type: boolean; Default: true. MIXED4¶. Do allow “mixed” excitations involving RAS IV into the CI space. Useful to specify a split-virtual CISD[",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/autodir_options_c/module__detci-1.html:11552,energy,energy,11552,psi4manual/1.3.2/autodir_options_c/module__detci-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/autodir_options_c/module__detci-1.html,20,['energy'],['energy']
Energy Efficiency,anager method. set_str() psi4.core.Options method. set_str_i() psi4.core.Options method. set_tei_already_presorted() psi4.core.IntegralTransform method. set_title() psi4.core.OEProp method. set_tpdm_already_presorted() psi4.core.IntegralTransform method. set_tpdm_presorted() psi4.core.Deriv method. set_tweak() psi4.core.LibXCFunctional method. set_units() psi4.core.Molecule method. set_variable() in module psi4.core. psi4.core.Molecule method. psi4.core.Wavefunction method. set_view() psi4.driver.p4util.InPsight method. set_vv10_b() psi4.core.SuperFunctional method. set_vv10_c() psi4.core.SuperFunctional method. set_wcombine() psi4.core.JK method. set_write_dpd_so_tpdm() psi4.core.IntegralTransform method. set_x_alpha() psi4.core.SuperFunctional method. set_x_beta() psi4.core.SuperFunctional method. set_x_omega() psi4.core.SuperFunctional method. setName() psi4.core.ExternalPotential method. setting. ; keywords anharmonicity(). keywords cbs(). keywords cp. keywords database(). keywords energy(). keywords frequency(). keywords general. keywords molecule. keywords optimize(). keywords properties(). keywords vmfc. SF_RESTRICT (DETCI). shallow_copy() psi4.core.Wavefunction method. shape psi4.core.Matrix attribute. psi4.core.Vector attribute. shared_object() psi4.core.IO static method. psi4.core.IOManager static method. shell() psi4.core.BasisSet method. shell_extents() psi4.core.BasisExtents method. shell_on_center() psi4.core.BasisSet method. shell_significant() psi4.core.ERISieve method. psi4.core.TwoBodyAOInt method. psi4.core.TwoElectronInt method. shell_to_ao_function() psi4.core.BasisSet method. shell_to_basis_function() psi4.core.BasisSet method. shell_to_center() psi4.core.BasisSet method. ShellInfo class in psi4.core. shells_iterator() psi4.core.IntegralFactory method. shells_local_to_global() psi4.core.BlockOPoints method. sherrill_gold_standard() in module psi4.driver.aliases. shift() psi4.core.CIVector method. sigma() psi4.core.CIWavefunction method. SIGMA_OV,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/genindex.html:113694,energy,energy,113694,psi4manual/1.7.x/genindex.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/genindex.html,1,['energy'],['energy']
Energy Efficiency,"analysis of several water isotopologs. Demonstrates Hessian reuse for different temperatures and pressures but not for different isotopologs. tdscf-1; td-uhf test on triplet states of methylene (rpa). dct6; DCT calculation for the triplet O2 using DC-06 and DC-12. Only two-step algorithm is tested. sapt8; SAPT0(ROHF) open-shell computation of CN - Ne interaction energy First with jun-cc-pVDZ and density fitted integrals with ROHF Then with cc-pVDZ and direct integrals, except for dispersion that is computed with cc-pVDZ-ri density fitting with ROHF. fnocc4; Test FNO-DF-CCSD(T) energy. cdremp-1; Cholesky decomposed REMP/cc-pVDZ energies for the CO2 molecule. opt13; B3LYP cc-pVDZ geometry optimzation of phenylacetylene, starting from not quite linear structure updated reference due to new BraggSlater radii. olccd2; OLCCD cc-pVDZ energy with B3LYP initial guess for the NO radical. scf-uhf-grad-nobeta; UHF gradient for a one-electron system (no beta electrons). dfccsdt1; DF-CCSD(T) cc-pVDZ energy for the H2O molecule. pywrap-align-chiral; testing aligner on enantiomers based on Table 1 of 10.1021/ci100219f aka J Chem Inf Model 2010 50(12) 2129-2140. dft-grad-disk; A range-seperated gradient for SO2 to test disk algorithms by explicitly setting low memory. cc5; RHF CCSD(T) cc-pVDZ frozen-core energy of C4NH4 Anion. cc35; CC3(ROHF)/cc-pVDZ H2O \(R_e\) geom from Olsen et al., JCP 104, 8007 (1996). omp3-4; SCS-OMP3 cc-pVDZ geometry optimization for the H2O molecule. scf-ecp2; Water-Argon complex with ECP present; check of RHF Hessian. cbs-xtpl-gradient; Various gradients for a strained helium dimer and water molecule. scf-response1; Compute the dipole, quadrupole, and traceless quadrupoles for water. dfomp3-grad2; DF-OMP3 cc-pVDZ gradients for the H2O+ cation. cdomp2-1; OMP2 cc-pVDZ energy for the H2O molecule. cc4; RHF-CCSD(T) cc-pVQZ frozen-core energy of the BH molecule, with Cartesian input. After the computation, the checkpoint file is renamed, using the PSIO handler. ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/autodoc_testsuite_corepsi4.html:32201,energy,energy,32201,psi4manual/1.8.x/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/autodoc_testsuite_corepsi4.html,2,['energy'],['energy']
Energy Efficiency,"analytic single-geometry computations. ConvergenceError(eqn_description, iteration); Error called for problems with converging an iterative method. EmpiricalDispersion(*[, name_hint, ...]); Lightweight unification of empirical dispersion calculation modes. ManagedMethodError(circs); Error called when a requested level of theory and derivative level are nominally available but not for the particular conditions (e.g., reference, algorithm, active orbitals, QC module, etc.) requested. MissingMethodError(msg); Error called when requested level or theory or derivative level are not available. OptimizationConvergenceError(...); Error called for problems with geometry optimizer. ParsingError(msg); Error called for problems parsing a text file. PastureRequiredError(option); Error called when the specified value of option requires some module(s) from Psi4Pasture, but could not be imported. PsiException; Error class for PSI4. QMMM(); Hold charges and psi4.core.ExternalPotential. QMMMbohr(); Hold charges and psi4.core.ExternalPotential. SCFConvergenceError(eqn_description, ...); Error called for problems with SCF iterations. TDSCFConvergenceError(iteration, wfn, what, ...); Error called for problems with TDSCF iterations. TestComparisonError(msg); Error called when a compare_values() or other comparison function fails. UpgradeHelper(old, new, version, elaboration); Error called on previously valid syntax that now isn't and a simple syntax transition is possible. ValidationError(msg); Input specification has problems. Class Inheritance Diagram¶. psi4.driver.p4util Package¶; Miscellaneous tools for driver and users. Functions¶. OptionsStateCM(osd); Return a context manager that will collect the state (value and changed :rtype: Iterator[None]. all_casings(input_string); Return a generator of all lettercase permutations of input_string. array_to_matrix(self, arr[, name, dim1, dim2]); Converts a NumPy array or list of NumPy arrays into a PSI4 Matrix or Vector (irrepped if list). ban",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/psi4api.html:21857,charge,charges,21857,psi4manual/1.9.x/psi4api.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/psi4api.html,1,['charge'],['charges']
Energy Efficiency,"analytic single-geometry computations. ConvergenceError(eqn_description, iteration); Error called for problems with converging an iterative method. EmpiricalDispersion(*[, name_hint, ...]); Lightweight unification of empirical dispersion calculation modes. ManagedMethodError(circs); Error called when a requested level of theory and derivative level are nominally available but not for the particular conditions (e.g., reference, algorithm, active orbitals, QC module, etc.) requested. MissingMethodError(msg); Error called when requested level or theory or derivative level are not available. OptimizationConvergenceError(...); Error called for problems with geometry optimizer. ParsingError(msg); Error called for problems parsing a text file. PastureRequiredError(option); Error called when the specified value of option requires some module(s) from Psi4Pasture, but could not be imported. PsiException; Error class for PSI4. QMMM(); Hold charges and psi4.core.ExternalPotential. QMMMbohr(); Hold charges and psi4.core.ExternalPotential. SCFConvergenceError(eqn_description, ...); Error called for problems with SCF iterations. TDSCFConvergenceError(iteration, wfn, what, ...); Error called for problems with TDSCF iterations. TestComparisonError(msg); Error called when a compare_values() or other comparison function fails. UpgradeHelper(old, new, version, elaboration); Error called on previously valid syntax that now isn't and a simple syntax transition is possible. ValidationError(msg); Input specification has problems. Class Inheritance Diagram¶. psi4.driver.p4util Package¶; Miscellaneous tools for driver and users. Functions¶. OptionsStateCM(osd); Return a context manager that will collect the state (value and changed status) of a list of keywords osd that can initialize OptionsState on entry to the with-statement and restore the collected state when exiting the with-statement. all_casings(input_string); Return a generator of all lettercase permutations of input_string. array_to",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/psi4api.html:21852,charge,charges,21852,psi4manual/1.7.x/psi4api.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/psi4api.html,3,['charge'],['charges']
Energy Efficiency,"ance(EXTERN, core.ExternalPotential):; # Well this is probably the worst hack I have done, thats saying something; core.EXTERN = EXTERN; core.set_global_option(""EXTERN"", True); else:; raise ValidationError(""Options: set_global_option_python can either be a NULL or External Potential object""). core.set_global_option_python = _core_set_global_option_python. ## QCvar helps. _qcvar_transitions = {; # old: (replacement, release after next); ""SCSN-MP2 CORRELATION ENERGY"": (""SCS(N)-MP2 CORRELATION ENERGY"", 1.5),; ""SCSN-MP2 TOTAL ENERGY"": (""SCS(N)-MP2 TOTAL ENERGY"", 1.5),; ""MAYER_INDICES"": (""MAYER INDICES"", 1.5),; ""WIBERG_LOWDIN_INDICES"": (""WIBERG LOWDIN INDICES"", 1.5),; ""LOWDIN_CHARGES"": (""LOWDIN CHARGES"", 1.5),; ""MULLIKEN_CHARGES"": (""MULLIKEN CHARGES"", 1.5),; ""(AT) CORRECTION ENERGY"": (""A-(T) CORRECTION ENERGY"", 1.5),; ""CCSD(AT) TOTAL ENERGY"": (""A-CCSD(T) TOTAL ENERGY"", 1.5),; ""CCSD(AT) CORRELATION ENERGY"": (""A-CCSD(T) CORRELATION ENERGY"", 1.5),; ""CP-CORRECTED 2-BODY INTERACTION ENERGY"": (""CP-CORRECTED INTERACTION ENERGY THROUGH 2-BODY"", 1.7),; ""CP-CORRECTED 3-BODY INTERACTION ENERGY"": (""CP-CORRECTED INTERACTION ENERGY THROUGH 3-BODY"", 1.7),; ""CP-CORRECTED 4-BODY INTERACTION ENERGY"": (""CP-CORRECTED INTERACTION ENERGY THROUGH 4-BODY"", 1.7),; ""CP-CORRECTED 5-BODY INTERACTION ENERGY"": (""CP-CORRECTED INTERACTION ENERGY THROUGH 5-BODY"", 1.7),; ""NOCP-CORRECTED 2-BODY INTERACTION ENERGY"": (""NOCP-CORRECTED INTERACTION ENERGY THROUGH 2-BODY"", 1.7),; ""NOCP-CORRECTED 3-BODY INTERACTION ENERGY"": (""NOCP-CORRECTED INTERACTION ENERGY THROUGH 3-BODY"", 1.7),; ""NOCP-CORRECTED 4-BODY INTERACTION ENERGY"": (""NOCP-CORRECTED INTERACTION ENERGY THROUGH 4-BODY"", 1.7),; ""NOCP-CORRECTED 5-BODY INTERACTION ENERGY"": (""NOCP-CORRECTED INTERACTION ENERGY THROUGH 5-BODY"", 1.7),; ""VMFC-CORRECTED 2-BODY INTERACTION ENERGY"": (""VMFC-CORRECTED INTERACTION ENERGY THROUGH 2-BODY"", 1.7),; ""VMFC-CORRECTED 3-BODY INTERACTION ENERGY"": (""VMFC-CORRECTED INTERACTION ENERGY THROUGH 3-BODY"", 1.7),; ""VMFC-CORRECTED 4-BOD",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/p4util/python_helpers.html:19147,ENERGY,ENERGY,19147,psi4manual/1.6.x/_modules/psi4/driver/p4util/python_helpers.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/p4util/python_helpers.html,10,['ENERGY'],['ENERGY']
Energy Efficiency,"ance; with Table Geometry Convergence. Summary of sets of geometry optimization criteria available in Psi4¶. G_CONVERGENCE; Max Energy; Max Force; RMS Force; Max Disp; RMS Disp. NWCHEM_LOOSE [4];  . GAU_LOOSE [6];  . TURBOMOLE [4]. GAU [3] [6];  . CFOUR [4];  ;  .  ;  . QCHEM [1] [5].  .  . MOLPRO [2] [5].  .  . GAU_TIGHT [3] [6];  . GAU_VERYTIGHT [6];  . Footnotes. [1]Default. [2]Baker convergence criteria are the same. [3](1, 2) Counterpart NWCHEM convergence criteria are the same. [4](1, 2, 3) Convergence achieved when all active criteria are fulfilled. [5](1, 2, 3) Convergence achieved when Max Force and one of Max Energy or Max Disp are fulfilled. [6](1, 2, 3, 4, 5) Normal convergence achieved when all four criteria (Max Force, RMS Force,; Max Disp, and RMS Disp) are fulfilled. To help with flat; potential surfaces, alternate convergence achieved when 100rms force is less; than RMS Force criterion. For ultimate control, specifying a value for any of the five monitored options activates that; criterium and overwrites/appends it to the criteria set by G_CONVERGENCE.; Note that this revokes the special convergence arrangements detailed in notes [5] and [6]; and instead requires all active criteria to be fulfilled to; achieve convergence. To avoid this revokation, turn on keyword FLEXIBLE_G_CONVERGENCE. Output¶; The progress of a geometry optimization can be monitored by grepping the output file for the; tilde character (~). This produces a table like the one below that shows; for each iteration the value for each of the five quantities and whether the criterion; is active and fulfilled (*), active and unfulfilled ( ), or inactive (o).; --------------------------------------------------------------------------------------------- ~; Step Total Energy Delta E MAX Force RMS Force MAX Disp RMS Disp ~; --------------------------------------------------------------------------------------------- ~; Convergence Criteria 1.00e-06 * 3.00e-04 * o 1.20e-03 * o ~; -------------",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/optking-1.html:12449,monitor,monitored,12449,psi4manual/1.0.0/optking-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/optking-1.html,2,['monitor'],['monitored']
Energy Efficiency,"and Gauss’s CFOUR program [manual]. c4-scf; Hartree–Fock (HF). c4-mp2; 2nd-order Møller–Plesset perturbation theory (non-density-fitting) (MP2). c4-mp3; 3rd-order Møller–Plesset perturbation theory (MP3). c4-mp4(sdq); 4th-order MP perturbation theory (MP4) less triples. c4-mp4; full MP4. c4-cc2; approximate coupled cluster singles and doubles (CC2). c4-ccsd; coupled cluster singles and doubles (CCSD). c4-cc3; approximate CC singles, doubles, and triples (CC3). c4-ccsd(t); CCSD with perturbative triples (CCSD(T)). c4-ccsdt; coupled cluster singles, doubles, and triples (CCSDT). cfour; expert full control over cfour program. Examples. >>> # [1] Coupled-cluster singles and doubles calculation with psi code; >>> energy('ccsd'). >>> # [2] Charge-transfer SAPT calculation with scf projection from small into; >>> # requested basis, with specified projection fitting basis; >>> set basis_guess true; >>> set df_basis_guess jun-cc-pVDZ-JKFIT; >>> energy('sapt0-ct'). >>> # [3] Arbitrary-order MPn calculation; >>> energy('mp7'). >>> # [4] Converge scf as singlet, then run detci as triplet upon singlet reference; >>> # Note that the integral transformation is not done automatically when detci is run in a separate step.; >>> molecule H2 {\n0 1\nH\nH 1 0.74\n}; >>> set basis cc-pVDZ; >>> set reference rohf; >>> scf_e, scf_wfn = energy('scf', return_wfn=True); >>> H2.set_multiplicity(3); >>> core.MintsHelper(scf_wfn.basisset()).integrals(); >>> energy('detci', ref_wfn=scf_wfn). >>> # [5] Run two CI calculations, keeping the integrals generated in the first one.; >>> molecule ne {\nNe\n}; >>> set basis cc-pVDZ; >>> cisd_e, cisd_wfn = energy('cisd', return_wfn=True); >>> energy('fci', ref_wfn=cisd_wfn). >>> # [6] Can automatically perform complete basis set extrapolations; >>> energy(""CCSD/cc-pV[DT]Z""). >>> # [7] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for mo",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/api/psi4.driver.energy-1.html:21519,energy,energy,21519,psi4manual/1.4.0/api/psi4.driver.energy-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/api/psi4.driver.energy-1.html,15,['energy'],['energy']
Energy Efficiency,"and MP4(SDQ) correlation energies can be obtained as a free; by-product of a CCSD or QCISD computation. The following is an; example of the results for a computation run with the call; energy('fno-qcisd') to energy():; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19; 20; 21; 22; 23; 24; 25; 26; 27; 28; 29; 30QCISD iterations converged!. OS MP2 FNO correction: -0.000819116338; SS MP2 FNO correction: -0.000092278158; MP2 FNO correction: -0.000911394496. OS MP2 correlation energy: -0.166478414245; SS MP2 correlation energy: -0.056669079827; MP2 correlation energy: -0.223147494072; * MP2 total energy: -76.258836941658. OS MP2.5 correlation energy: -0.171225850256; SS MP2.5 correlation energy: -0.054028401038; MP2.5 correlation energy: -0.225254251294; * MP2.5 total energy: -76.260943698880. OS MP3 correlation energy: -0.175973286267; SS MP3 correlation energy: -0.051387722248; MP3 correlation energy: -0.227361008515; * MP3 total energy: -76.263050456101. OS MP4(SDQ) correlation energy: -0.180324322304; SS MP4(SDQ) correlation energy: -0.048798468084; MP4(SDQ) correlation energy: -0.230995119324; * MP4(SDQ) total energy: -76.266684566910. OS QCISD correlation energy: -0.181578117924; SS QCISD correlation energy: -0.049853548145; QCISD correlation energy: -0.231431666069; * QCISD total energy: -76.267121113654. The first set of energies printed corresponds to the second-order FNO; correction mentioned previously. Results for many-body perturbation; theory through partial fourth order are then provided.; The notation MP4(SDQ) indicates that we have included all contributions to; the correlation energy through fourth order, with the exception of that; from connected triple excitations.; One need not run a full QCISD or CCSD computation to obtain these; perturbation theory results. The keywords for invoking perturbation; theory computations are given below in; Table FNOCC Methods. Full MP4 correlation; energies are also available. Coupled electron pair appr",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/fnocc-1.html:6001,energy,energy,6001,psi4manual/1.1.0/fnocc-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/fnocc-1.html,6,['energy'],['energy']
Energy Efficiency,"and PsiAPI refer to two modes of interacting with Psi4. In Psithon mode, you write an input file in our domain-specific language (not quite Python) where commands don’t have psi4. in front, then submit it to the executable psi4 which processes the Psithon into pure Python and runs it internally. In PsiAPI mode, you write a pure Python script with import psi4 at the top and commands are behind the psi4. namespace, then submit it to the python interpreter.; Both modes are equally powerful. This tutorial covers the PsiAPI mode. Warning: Although the developers have been using PsiAPI mode stably for months before the 1.1 release and while we believe we’ve gotten everything nicely arranged within the psi4. namespace, the API should not be considered completely stable. Most importantly, as we someday deprecate the last of the global variables, options will be added to the method calls (e.g., energy('scf', molecule=mol, options=opt)); Note: Consult How to run Psi4 as Python module after compilation or How to run Psi4 as a Python module from conda installation for assistance in setting up Psi4. Unlike in the past, where Psi4 was executable software which could only be called via input files like input.dat, it is now interactive, able to be loaded directly as a Python module. Here, we will explore the basics of using Psi4 in this new style by reproducing the section A Psi4 Tutorial from the Psi4 manual in an interactive Jupyter Notebook.; Note: If the newest version of Psi4 (v.1.1a2dev42 or newer) is in your path, feel free to execute each cell as you read along by pressing Shift+Enter when the cell is selected. I. Basic Input Structure¶; Psi4 is now a Python module; so, we need to import it into our Python environment:. [1]:. try:; import os, sys; sys.path.insert(1, os.path.abspath('/scratch/psilocaluser/conda-builds/psi4-docs-multiout_1557966099526/work/build/stage//opt/anaconda1anaconda2anaconda3/lib/python3.6/site-packages')); except ImportError:; pass. import psi4. Psi4",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/psiapi-1.html:1131,energy,energy,1131,psi4manual/1.3.2/psiapi-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/psiapi-1.html,2,['energy'],['energy']
Energy Efficiency,"and an example see CFOUR_OCCUPATION. Type: array; Default: No Default. CFOUR_CPHF_CONVER¶. Specifies the convergence criterion for the iterative solution of the CPHF and Z-vector equations. The solutions are considered to be converged when the residual norm of the error vector falls below \(10^N\). Type: integer; Default: 12. CFOUR_CPHF_MAXCYC¶. Specifies the maximum number of cycles allowed for the solution of the CPHF- and/or Z-vector equations. Type: integer; Default: 64. CFOUR_CURVILINEAR¶. Specifies whether or not Hessian matrix is transformed (nonlinearly) to curvilinear internal coordinates. A value of 0 (or OFF) turns the transformation off if the analytic force constants are not available, while it is always performed if CURVILINEAR=1 (or ON). Values higher than 1 (or NO) unconditionally turn the transformation off.(Default: ON if analytic Hessian is available, OFF otherwise). Type: boolean; Default: true. CFOUR_DBOC¶. Specifies whether the diagonal Born-Oppenheimer correction (DBOC) to the energy is evaluated (ON =1) or not (OFF =0). DBOC calculations are currently only available for HF-SCF and CCSD using RHF or UHF reference functions. Type: boolean; Default: false. CFOUR_DCT¶. Specifies whether the Dipole Coupling Tensor (DCT) is calculated (ON =1) or not (OFF =0). Type: boolean; Default: false. CFOUR_DERIV_LEVEL¶. Specifies whether or not energy derivatives are to be calculated and if so whether first or second derivatives are computed. ZERO (= 0) derivatives are not calculated, FIRST (=1) first derivatives are calculated, SECOND (=2) second derivatives are calculated. Note that this keyword usually needs not be set in any calculation since it is automatically set if the appropriate other options in the CFOUR namelist are turned on. Psi4 Interface: Keyword set from type of computation command: ZERO if energy(), FIRST if gradient() or optimization(), etc. Type: string; Possible Values: ZERO, FIRST, SECOND; Default: ZERO. CFOUR_DIFF_TYPE¶. Specifies wheth",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/autodir_options_c/module__cfour-1.html:13737,energy,energy,13737,psi4manual/1.3.2/autodir_options_c/module__cfour-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/autodir_options_c/module__cfour-1.html,6,['energy'],['energy']
Energy Efficiency,"and an example see CFOUR_OCCUPATION. Type: array; Default: No Default. CFOUR_CPHF_CONVER¶. Specifies the convergence criterion for the iterative solution of the CPHF and Z-vector equations. The solutions are considered to be converged when the residual norm of the error vector falls below \(10^N\). Type: integer; Default: 12. CFOUR_CPHF_MAXCYC¶. Specifies the maximum number of cycles allowed for the solution of the CPHF- and/or Z-vector equations. Type: integer; Default: 64. CFOUR_CURVILINEAR¶. Specifies whether or not Hessian matrix is transformed (nonlinearly) to curvilinear internal coordinates. A value of 0 (or OFF) turns the transformation off if the analytic force constants are not available, while it is always performed if CURVILINEAR=1 (or ON). Values higher than 1 (or NO) unconditionally turn the transformation off.(Default: ON if analytic Hessian is available, OFF otherwise). Type: boolean; Default: true. CFOUR_DBOC¶. Specifies whether the diagonal Born-Oppenheimer correction (DBOC) to the energy is evaluated (ON =1) or not (OFF =0). DBOC calculations are currently only available for HF-SCF and CCSD using RHF or UHF reference functions. Type: boolean; Default: false. CFOUR_DCT¶. Specifies whether the Dipole Coupling Tensor (DCT) is calculated (ON =1) or not (OFF =0). Type: boolean; Default: false. CFOUR_DERIV_LEVEL¶. Specifies whether or not energy derivatives are to be calculated and if so whether first or second derivatives are computed. ZERO (= 0) derivatives are not calculated, FIRST (=1) first derivatives are calculated, SECOND (=2) second derivatives are calculated. Note that this keyword usually needs not be set in any calculation since it is automatically set if the appropriate other options in the CFOUR namelist are turned on. Psi4 Interface: Keyword set from type of computation command: ZERO if energy(), FIRST if gradient() or optimize(), etc. Type: string; Possible Values: ZERO, FIRST, SECOND; Default: ZERO. CFOUR_DIFF_TYPE¶. Specifies whether o",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/autodir_options_c/module__cfour-1.html:13742,energy,energy,13742,psi4manual/1.4.0/autodir_options_c/module__cfour-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/module__cfour-1.html,18,['energy'],['energy']
Energy Efficiency,"and is prepended to any; globals variables set during the computation. The unnamed arguments are the; properties to be computed. These can appear in any order, and multiple; properties may be requested, as in the example above. Note that, due to Python; syntax restrictions, the title argument must appear after the list of; properties to compute. The available properties are shown in the table below. Current one-electron property capabilities of PSI4. Feature; Keyword; Notes. Electric dipole moment; DIPOLE;  . Electric quadrupole moment; QUADRUPOLE; Raw (traced) moments and traceless multipoles. All moments up order N; MULTIPOLE(N); Only raw (traced) moments. Sets global variables e.g. “DIPOLE X”, “32-POLE XYYZZ”. Transition dipole moment; TRANSITION_DIPOLE;  . Transition quadrupole moment; TRANSITION_QUADRUPOLE;  . Electrostatic potential, at nuclei; ESP_AT_NUCLEI; Sets global variables “ESP AT CENTER n”, n = 1 to natoms. Molecular orbital extents; MO_EXTENTS;  . Mulliken atomic charges; MULLIKEN_CHARGES;  . Löwdin atomic charges; LOWDIN_CHARGES;  . Wiberg bond indices; WIBERG_LOWDIN_INDICES; Uses (Löwdin) symmetrically orthogonalized orbitals. Mayer bond indices; MAYER_INDICES;  . Natural orbital occupations; NO_OCCUPATIONS;  . Basic Keywords¶; Multipole moments may be computed at any origin, which is controlled by the; global PROPERTIES_ORIGIN keyword. The keyword takes an array with; the following possible values:. Allowed origin specifications. Keyword; Interpretation. [x, y, z]; Origin is at the coordinates, in the same units as the geometry specification. [“COM”]; Origin is at the center of mass. [“NUCLEAR_CHARGE”]; Origin is at the center of nuclear charge. Table Of Contents. Evaluation of One-Electron Properties; Basic Keywords. Previous topic; Geometry Optimization; Next topic; Interfaces: Enhancing PSI4 Capabilities; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . nex",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/oeprop-1.html:1625,charge,charges,1625,psi4manual/4.0b4/oeprop-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/oeprop-1.html,4,['charge'],['charges']
Energy Efficiency,"and is prepended to any; globals variables set during the computation. The unnamed arguments are the; properties to be computed. These can appear in any order, and multiple; properties may be requested, as in the example above. Note that, due to Python; syntax restrictions, the title argument must appear after the list of; properties to compute. The available properties are shown in the table below. Current one-electron property capabilities of PSI4. Feature; Keyword; Notes. Electric dipole moment; DIPOLE;  . Electric quadrupole moment; QUADRUPOLE; Raw (traced) moments and traceless multipoles. All moments up order N; MULTIPOLE(N); Only raw (traced) moments. Sets global variables e.g. “DIPOLE X”, “32-POLE XYYZZ”. Transition dipole moment; TRANSITION_DIPOLE;  . Transition quadrupole moment; TRANSITION_QUADRUPOLE;  . Electrostatic potential, at nuclei; ESP_AT_NUCLEI; Sets global variables “ESP AT CENTER n”, n = 1 to natoms. Molecular orbital extents; MO_EXTENTS;  . Mulliken atomic charges; MULLIKEN_CHARGES;  . Löwdin atomic charges; LOWDIN_CHARGES;  . Wiberg bond indices; WIBERG_LOWDIN_INDICES; Uses (Löwdin) symmetrically orthogonalized orbitals. Mayer bond indices; MAYER_INDICES;  . Natural orbital occupations; NO_OCCUPATIONS;  . Basic Keywords¶; Multipole moments may be computed at any origin, which is controlled by the; global PROPERTIES_ORIGIN keyword. The keyword takes an array with; the following possible values:. Allowed origin specifications. Keyword; Interpretation. [x, y, z]; Origin is at the coordinates, in the same units as the geometry specification. [“COM”]; Origin is at the center of mass. [“NUCLEAR_CHARGE”]; Origin is at the center of nuclear charge. Table Of Contents. Evaluation of One-Electron Properties; Basic Keywords. Previous topic; Geometry Optimization; Next topic; Psithon Functions: Invoking a Calculation; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . n",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/oeprop-1.html:1625,charge,charges,1625,psi4manual/4.0b3/oeprop-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/oeprop-1.html,2,['charge'],['charges']
Energy Efficiency,"and matrices provided from the Psi library. fci-coverage; 6-31G H2O Test for coverage. psithon1; Spectroscopic constants of H2, and the full ci cc-pVTZ level of theory. cc18; RHF-CCSD-LR/cc-pVDZ static polarizability of HOF. omp3-1; OMP3 cc-pVDZ energy for the H2O molecule. tdscf-1; td-uhf test on triplet states of methylene (rpa). sad-scf-type; Test SAD SCF guesses on noble gas atom. dft-custom-hybrid; DFT (hybrids) test of implementations in: hybrid_superfuncs.py. props4; Electrostatic potential and electric field evaluated on a grid around water. cc31; CCSD/sto-3g optical rotation calculation (both gauges) at two frequencies on methyloxirane. cc3; cc3: RHF-CCSD/6-31G** H2O geometry optimization and vibrational frequency analysis by finite-differences of gradients. x2c1; Test of SFX2C-1e on water uncontracted cc-pVDZ-DK The reference numbers are from Lan Cheng’s implementation in Cfour. scf-bz2; Benzene Dimer Out-of-Core HF/cc-pVDZ. pywrap-checkrun-uhf; This checks that all energy methods can run with a minimal input and set symmetry. psimrcc-ccsd_t-1; Mk-MRCCSD(T) single point. \(^1A_1\) CH2 state described using the Ms = 0 component of the singlet. Uses RHF singlet orbitals. tdscf-2; td-uhf test on triplet states of methylene (tda), wfn passing. scf11-freq-from-energies; Test frequencies by finite differences of energies for planar C4NH4 TS. dfcasscf-sa-sp; Example of state-averaged CASSCF for the C2 molecule. dft1-alt; DFT Functional Test. cc14; ROHF-CCSD/cc-pVDZ \(^{3}B_1\) CH2 geometry optimization via analytic gradients. cc4; RHF-CCSD(T) cc-pVQZ frozen-core energy of the BH molecule, with Cartesian input. After the computation, the checkpoint file is renamed, using the PSIO handler. ghosts; Density fitted MP2 cc-PVDZ/cc-pVDZ-RI computation of formic acid dimer binding energy using explicit specification of ghost atoms. This is equivalent to the dfmp2_1 sample but uses both (equivalent) specifications of ghost atoms in a manual counterpoise correction. phi-ao",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/autodoc_testsuite_corepsi4-1.html:25745,energy,energy,25745,psi4manual/1.5.0/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/autodoc_testsuite_corepsi4-1.html,4,['energy'],['energy']
Energy Efficiency,"and matrices provided from the Psi library. mints-helper; A general test of the MintsHelper function. cc10; ROHF-CCSD cc-pVDZ energy for the \(^2\Sigma^+\) state of the CN radical. olccd3; OLCCD cc-pVDZ energy with ROHF initial guess for the NO radical. pywrap-freq-e-sowreap; Finite difference of energies frequency, run in sow/reap mode. dfmp2-3; DF-MP2 cc-pVDZ frozen core gradient of benzene, computed at the DF-SCF cc-pVDZ geometry. cepa2; cc-pvdz H2O Test ACPF Energy/Properties. cc34; RHF-CCSD/cc-pVDZ energy of H2O partitioned into pair energy contributions. mints8; Patch of a glycine with a methyl group, to make alanine, then DF-SCF energy calculation with the cc-pVDZ basis set. psimrcc-sp1; Mk-MRCCSD single point. \(^3 \Sigma ^-\) O2 state described using the Ms = 0 component of the triplet. Uses ROHF triplet orbitals. density-screen-1; RHF Density Matrix based-Integral Screening Test for water. fnocc7; Test fnocc with linear dependencies. sapt5; SAPT0 aug-cc-pVTZ computation of the charge transfer energy of the water dimer. fsapt-ext-abc; FSAPT with external charge on trimer. isapt1; This test case shows an example of running and analyzing an FI-SAPT0/jun-cc-pvdz computation for 2,4-pentanediol (targeting the intramolecular hydrogen bond between the two hydroxyl groups). mints2; A test of the basis specification. A benzene atom is defined using a ZMatrix containing dummy atoms and various basis sets are assigned to different atoms. The symmetry of the molecule is automatically lowered to account for the different basis sets. olccd-grad1; OLCCD cc-pVDZ gradient for the H2O molecule. scf-level-shift-uhf; SCF level shift on a UHF computation. pywrap-checkrun-rhf; This checks that all energy methods can run with a minimal input and set symmetry. omp3-2; OMP3 cc-pCVDZ energy with ROHF initial guess for the NO radical. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Appendices; Test Suite and Sample Inputs. © Copyr",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/testsuite.html:46637,charge,charge,46637,psi4manual/1.6.x/testsuite.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/testsuite.html,2,"['charge', 'energy']","['charge', 'energy']"
Energy Efficiency,"and matrices provided from the Psi library. mints-helper; A general test of the MintsHelper function. cc10; ROHF-CCSD cc-pVDZ energy for the \(^2\Sigma^+\) state of the CN radical. olccd3; OLCCD cc-pVDZ energy with ROHF initial guess for the NO radical. pywrap-freq-e-sowreap; Finite difference of energies frequency, run in sow/reap mode. dfmp2-3; DF-MP2 cc-pVDZ frozen core gradient of benzene, computed at the DF-SCF cc-pVDZ geometry. cepa2; cc-pvdz H2O Test ACPF Energy/Properties. cc34; RHF-CCSD/cc-pVDZ energy of H2O partitioned into pair energy contributions. mints8; Patch of a glycine with a methyl group, to make alanine, then DF-SCF energy calculation with the cc-pVDZ basis set. psimrcc-sp1; Mk-MRCCSD single point. \(^3 \Sigma ^-\) O2 state described using the Ms = 0 component of the triplet. Uses ROHF triplet orbitals. density-screen-1; RHF Density Matrix based-Integral Screening Test for water. fnocc7; Test fnocc with linear dependencies. sapt5; SAPT0 aug-cc-pVTZ computation of the charge transfer energy of the water dimer. fsapt-ext-abc; FSAPT with external charge on trimer. isapt1; This test case shows an example of running and analyzing an FI-SAPT0/jun-cc-pvdz computation for 2,4-pentanediol (targeting the intramolecular hydrogen bond between the two hydroxyl groups). mints2; A test of the basis specification. A benzene atom is defined using a ZMatrix containing dummy atoms and various basis sets are assigned to different atoms. The symmetry of the molecule is automatically lowered to account for the different basis sets. olccd-grad1; OLCCD cc-pVDZ gradient for the H2O molecule. scf-level-shift-uhf; SCF level shift on a UHF computation. pywrap-checkrun-rhf; This checks that all energy methods can run with a minimal input and set symmetry. omp3-2; OMP3 cc-pCVDZ energy with ROHF initial guess for the NO radical. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Appendices; Test Suite and Sample Inputs; <no tit",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/autodoc_testsuite_corepsi4.html:45915,charge,charge,45915,psi4manual/1.6.x/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/autodoc_testsuite_corepsi4.html,2,"['charge', 'energy']","['charge', 'energy']"
Energy Efficiency,"and ndarray) – When dertype=None, both energy [Eh] and (nat, 3) gradient [Eh/a0]. run_dftd4(func=None, dashlvl=None, dashparam=None, dertype=None, verbose=1)[source]¶; Compute dispersion correction via Grimme’s DFTD4 program. Parameters. func (str, optional) – Name of functional (func only, func & disp, or disp only) for; which to compute dispersion (e.g., blyp, BLYP-D2, blyp-d3bj,; blyp-d3(bj), hf+d). Unlike run_dftd3, func overwrites any; parameter initialized via dashparam.; dashlvl (str, optional) – Name of dispersion correction to be applied (e.g., d, D2,; d3(bj), das2010). Must be key in dashcoeff or “alias” or; “formal” to run.; dashparam (dict, optional) – Values for the same keys as dashcoeff[dashlvl][‘default’]; used to provide custom values. Unlike run_dftd3, will not have; effect if func given. Must provide all parameters.; Extra parameters will error.; dertype (int or str, optional) – Maximum derivative level at which to run DFTD3. For large; molecules, energy-only calculations can be significantly more; efficient. Influences return values, see below.; verbose (int, optional) – Amount of printing. Returns. energy (float) – When dertype=0, energy [Eh].; gradient (ndarray) – When dertype=1, (nat, 3) gradient [Eh/a0].; (energy, gradient) (tuple of float and ndarray) – When dertype=None, both energy [Eh] and (nat, 3) gradient [Eh/a0]. Notes; This function wraps the QCEngine dftd4 harness which wraps the internal DFTD4 Python API.; As such, the upstream convention of func trumping dashparam holds, rather than the; run_dftd3() behavior of dashparam extending or overriding func. run_gcp(func=None, dertype=None, verbose=1)[source]¶; Compute geometrical BSSE correction via Grimme’s GCP program.; Function to call Grimme’s GCP program; https://www.chemie.uni-bonn.de/pctc/mulliken-center/software/gcp/gcp; to compute an a posteriori geometrical BSSE correction to self for; several HF, generic DFT, and specific HF-3c and PBEh-3c method/basis; combinations, func. Retur",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/api/psi4.core.molecule.html:29643,energy,energy-only,29643,psi4manual/1.5.0/api/psi4.core.molecule.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/api/psi4.core.molecule.html,8,"['efficient', 'energy']","['efficient', 'energy-only']"
Energy Efficiency,"and not bsse == 'on' and not bsse == 'both':; raise ValidationError('n_body: bsse argument is one of on, off, or both'); if max_n_body < 1:; raise ValidationError('n_body: max_n_body must be at least 1'); if max_n_body > molecule.nfragments():; raise ValidationError('n_body: max_n_body must be <= to the number of fragments in the molecule'). # Set to save RI integrals for repeated full-basis computations; ri_ints_io = PsiMod.get_global_option('DF_INTS_IO'); # inquire if above at all applies to dfmp2 or just scf; PsiMod.set_global_option('DF_INTS_IO', 'SAVE'); psioh = PsiMod.IOManager.shared_object(); psioh.set_specific_retention(97, True). # Tell 'em what you're gonna tell 'em; has_external = 'No'; if (external):; has_external = 'Yes'; PsiMod.print_out('\n'); PsiMod.print_out(' ==> N-Body Interaction Energy Analysis <==\n\n'); PsiMod.print_out(' BSSE Treatment: %s\n' % (bsse)); PsiMod.print_out(' Maximum N-Body Interactions: %d\n' % (max_n_body)); PsiMod.print_out(' Compute Total Energy: %s\n' % (do_total)); PsiMod.print_out(' External Field: %s\n' % (has_external)); if (external):; PsiMod.print_out(' External Field Monomers: '); for k in external_indices:; PsiMod.print_out('%-3d ' % (k)); PsiMod.print_out('\n'); PsiMod.print_out('\n'). # Run the total molecule, if required; energies_full = {}; energies_mon = {}; N = molecule.nfragments(); Etotal = 0.0; if do_total or max_n_body == molecule.nfragments():; PsiMod.print_out(' => Total Cluster Energy <=\n'); # Full cluster always gets the external field; if (external):; PsiMod.set_global_option_python(""EXTERN"", external); Etotal = call_function_in_1st_argument(func, **kwargs); if (external):; PsiMod.set_global_option_python(""EXTERN"", None); energies_full[N] = []; energies_full[N].append(Etotal); energies_mon[N] = []; energies_mon[N].append(Etotal); PsiMod.set_global_option('DF_INTS_IO', 'LOAD'); PsiMod.clean(). max_effective = max_n_body; if (max_effective == N):; max_effective = N - 1. # Build the combos for indexing ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/_modules/wrappers.html:6328,Energy,Energy,6328,psi4manual/4.0b3/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/_modules/wrappers.html,2,['Energy'],['Energy']
Energy Efficiency,"and not procedures['energy'][lowername] == run_dft:; PsiMod.set_global_option('E_CONVERGENCE', 10). # Obtain list of displacements; displacements = PsiMod.fd_geoms_freq_0(irrep); molecule.fix_orientation(True); molecule.reinterpret_coordentry(False); # Make a note of the undisplaced molecule's symmetry; PsiMod.set_parent_symmetry(molecule.schoenflies_symbol()). ndisp = len(displacements). # This version is pretty dependent on the reference geometry being last (as it is now); print(' %d displacements needed.' % ndisp); energies = []; for n, displacement in enumerate(displacements):; # Print information to output.dat; PsiMod.print_out('\n'); banner('Loading displacement %d of %d' % (n + 1, ndisp)). # Print information to the screen; print(' %d' % (n + 1), end=""""); if (n + 1) == ndisp:; print('\n', end=''); sys.stdout.flush(). # Load in displacement into the active molecule; molecule.set_geometry(displacement). # Perform the energy calculation; E = func(lowername, **kwargs). # Save the energy; energies.append(E). # clean may be necessary when changing irreps of displacements; PsiMod.clean(). # Obtain the gradient. This function stores the gradient in the wavefunction.; PsiMod.fd_freq_0(energies, irrep). print(' Computation complete.'). # Clear the ""parent"" symmetry now; PsiMod.set_parent_symmetry(""""). # TODO: These need to be restored to the user specified setting; PsiMod.get_active_molecule().fix_orientation(False); # But not this one, it always goes back to True; PsiMod.get_active_molecule().reinterpret_coordentry(True). # The last item in the list is the reference energy, return it; optstash.restore(). # Clear the ""parent"" symmetry now; PsiMod.set_parent_symmetry(""""). # call thermo module; PsiMod.thermo(). optstash.restore(); return energies[-1]. ## Aliases ##; frequencies = frequency; freq = frequency. # hessian to be changed later to compute force constants; [docs]def hessian(name, **kwargs):; r""""""Function to compute force constants. Presently identical to frequenc",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/_modules/driver.html:66714,energy,energy,66714,psi4manual/4.0b4/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/driver.html,2,['energy'],['energy']
Energy Efficiency,"and ptype; if 'cp' in metadata['bsse_type_list']:; for n in nbody_range:; if n == metadata['max_frag']:; cp_energy_body_dict[n] = cp_energy_by_level[n] - bsse; if metadata['ptype'] != 'energy':; cp_ptype_body_dict[n][:] = cp_ptype_by_level[n] - bsse_ptype; continue. for k in range(1, n + 1):; take_nk = nCr(metadata['max_frag'] - k - 1, n - k); sign = ((-1)**(n - k)); value = cp_energy_by_level[k]; cp_energy_body_dict[n] += take_nk * sign * value. if metadata['ptype'] != 'energy':; value = cp_ptype_by_level[k]; cp_ptype_body_dict[n] += take_nk * sign * value. if n == 1:; bsse = cp_energy_body_dict[n] - monomer_energies; cp_energy_body_dict[n] = monomer_energies; if metadata['ptype'] != 'energy':; bsse_ptype = cp_ptype_body_dict[n] - monomer_ptype; cp_ptype_body_dict[n] = monomer_ptype.copy(). else:; cp_energy_body_dict[n] -= bsse; if metadata['ptype'] != 'energy':; cp_ptype_body_dict[n] -= bsse_ptype. cp_interaction_energy = cp_energy_body_dict[metadata['max_nbody']] - cp_energy_body_dict[1]; nbody_dict['Counterpoise Corrected Interaction Energy'] = cp_interaction_energy. for n in nbody_range[1:]:; var_key = 'CP-CORRECTED %d-BODY INTERACTION ENERGY' % n; nbody_dict[var_key] = cp_energy_body_dict[n] - cp_energy_body_dict[1]. _print_nbody_energy(cp_energy_body_dict, ""Counterpoise Corrected (CP)"", metadata['embedding_charges']); cp_interaction_energy = cp_energy_body_dict[metadata['max_nbody']] - cp_energy_body_dict[1]; if monomer_energies != 0.0:; nbody_dict['Counterpoise Corrected Total Energy'] = cp_energy_body_dict[metadata['max_nbody']]; nbody_dict['Counterpoise Corrected Interaction Energy'] = cp_interaction_energy. # Compute nocp energy and ptype; if 'nocp' in metadata['bsse_type_list']:; for n in nbody_range:; if n == metadata['max_frag']:; nocp_energy_body_dict[n] = nocp_energy_by_level[n]; if metadata['ptype'] != 'energy':; nocp_ptype_body_dict[n][:] = nocp_ptype_by_level[n]; continue. for k in range(1, n + 1):; take_nk = nCr(metadata['max_frag'] - k - 1, n - ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_nbody.html:26257,Energy,Energy,26257,psi4manual/1.4.0/_modules/psi4/driver/driver_nbody.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_nbody.html,2,['Energy'],['Energy']
Energy Efficiency,"and rebuild PSI4 to detect PCMSolver and activate dependent code. To remove a conda installation, conda remove pcmsolver. Source. If using PSI4 built from source and you want PCMSolver built from; from source also,; enable it as a feature with ENABLE_PCMSolver,; and let the build system fetch and build it and activate dependent code. Using the polarizable continuum model¶; The inclusion of a PCM description of the solvent into your calculation; is achieved by setting PCM true in your input file.; PSI4 understands the additional option PCM_SCF_TYPE with possible values total; (the default) or separate.; The latter forces the separate handling of nuclear and electronic electrostatic potentials and; polarization charges. It is mainly useful for debugging.; For the calculation of vertical excitation energies with PCM non-equilibrium solvation should be included with:; pcm = {; Medium {; Nonequilibrium = True; }; }. Note; At present PCM can only be used for energy calculations with SCF; wavefunctions and CC wavefunctions in the PTE approximation [Cammi:2009:164104].; All ERI algorithms (PK, OUT_OF_CORE, DIRECT, DF, CD) are supported. Note; linear response calculations (static polarisabilities, TD-SCF) are supported for RHF/UHF if available. Warning; The PCMSolver library cannot exploit molecular point group symmetry. Warning; ROHF with PCM is known not to work. See issue #999 on GitHub.; For the adventurous, a fix is available in pull request #953 on GitHub. Warning; Analytic gradients and Hessians are not available with PCM. Finite differences will be used; regardless of the dertype passed to the optimize function.; See pcmsolver/opt-fd for a sample input. The PCM model and molecular cavity are specified in a pcm section that has; to be explicitly typed in by the user. This additional section follows a syntax; that is slightly different from that of PSI4 and is fully documented; here; A typical input for a Hartree–Fock calculation with PCM would look like the following:;",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/pcmsolver-1.html:2176,energy,energy,2176,psi4manual/1.4.0/pcmsolver-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/pcmsolver-1.html,5,['energy'],['energy']
Energy Efficiency,"and reference types for SCF, on singlet and triplet O2, using the cc-pVTZ basis set. fnocc4; Test FNO-DF-CCSD(T) energy. cc40; RHF-CC2-LR/cc-pVDZ optical rotation of H2O2. gauge = length, omega = (589 355 nm). dfccsdat1; DF-CCSD(AT) cc-pVDZ energy for the H2O molecule. opt10; 6-31G MP2 transition-state optimization with initial, computed Hessian. dcft5; DC-06 calculation for the O2 molecule (triplet ground state). This performs geometry optimization using two-step and simultaneous solution of the response equations for the analytic gradient. stability2; ROHF stability analysis check for CN with cc-pVDZ. This test corresponds to the rohf-stab test from Psi3. cc42; RHF-CC2-LR/STO-3G optical rotation of (S)-methyloxirane. gauge = length, omega = (589 355 nm). scf2; RI-SCF cc-pVTZ energy of water, with Z-matrix input and cc-pVTZ-RI auxilliary basis. cbs-xtpl-opt; Various extrapolated optimization methods for the H2 molecule. dfmp2-2; Density fitted MP2 energy of H2, using density fitted reference and automatic looping over cc-pVDZ and cc-pVTZ basis sets. Results are tabulated using the built in table functions by using the default options and by specifiying the format. cbs-xtpl-wrapper; RHF aug-cc-pVQZ energy for the BH molecule, with Cartesian input. Various gradients for a strained helium dimer and water molecule. cc5; RHF CCSD(T) aug-cc-pvtz frozen-core energy of C4NH4 Anion. opt-freeze-coords; SCF/cc-pVDZ optimization example with frozen cartesian. psimrcc-ccsd_t-4; Mk-MRCCSD(T) single point. O$_3` state described using the Ms = 0 component of the singlet. Uses TCSCF orbitals. dfmp2-grad2; DF-MP2 cc-pVDZ gradient for the NO molecule. fnocc3; Test FNO-QCISD(T) computation. omp2-5; SOS-OMP2 cc-pVDZ geometry optimization for the H2O molecule. dft-dldf; Dispersionless density functional (dlDF+D) internal match to Psi4 Extensive testing has been done to match supplemental info of Szalewicz et. al., Phys. Rev. Lett., 103, 263201 (2009) and Szalewicz et. al., J. Phys. Chem",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_testsuite_corepsi4-1.html:3737,energy,energy,3737,psi4manual/1.0.0/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_testsuite_corepsi4-1.html,4,['energy'],['energy']
Energy Efficiency,"and return_history:; return (return_energy, wfn, history); elif return_wfn and not return_history:; return (return_energy, wfn); elif return_history and not return_wfn:; return (return_energy, history); else:; return return_energy. [docs]def optimize(name, **kwargs):; r""""""Function to perform a geometry optimization. :aliases: opt(). :returns: *float* |w--w| Total electronic energy of optimized structure in Hartrees. :returns: (*float*, :py:class:`~psi4.core.Wavefunction`) |w--w| energy and wavefunction when **return_wfn** specified. :raises: :py:class:`psi4.driver.OptimizationConvergenceError` if :term:`GEOM_MAXITER <GEOM_MAXITER (OPTKING)>` exceeded without reaching geometry convergence. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`CURRENT ENERGY`. :type name: str; :param name: ``'scf'`` || ``'mp2'`` || ``'ci5'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; :py:func:`psi4.driver.energy`. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :type return_wfn: :ref:`boolean <op_py_boolean>`; :param return_wfn: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return the :py:class:`~psi4.core.Wavefunction`; calculation result as the second element (after *float* energy) of a tuple. :type return_history: :ref:`boolean <op_py_boolean>`; :param return_history: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return dictionary of lists of geometries,; energies, and gradients at each step in the optimization. :type engine: str; :param engine: |dl| ``'optking'`` |dr| || ``'geometric'``. Indicates the optimization engine to use, which can be either Psi4's; native Optking optimizer or the GeomeTRIC program. :type optimizer_keywords: dict; :param optimizer_keywords: Extra options passed to the GeomeTRIC or optking optimizers. Indicates additional options to be passed to the Ge",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver.html:61635,energy,energy,61635,psi4manual/1.7.x/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver.html,2,['energy'],['energy']
Energy Efficiency,"and scf_basis; keywords to be specified for reference-step only jobs and name and; corl_basis keywords for correlated jobs.; The following energy methods have been set up for cbs(). scf; df-scf. mp2; df-mp2. cc2; ccsd. bccd; cc3. ccsd(t); fci. Parameters:; name (string) – 'scf' || 'ccsd' || etc.; First argument, usually unlabeled. Indicates the computational method; for the correlation energy, unless only reference step to be performed,; in which case should be 'scf'. Overruled if stage_wfn keywords supplied. corl_wfn (string) – 'mp2' || 'ccsd(t)' || etc.; Indicates the energy method for which the correlation energy is to be; obtained. Can also be specified with name or as the unlabeled; first argument to the function. delta_wfn (string) – 'ccsd' || 'ccsd(t)' || etc.; Indicates the (superior) energy method for which a delta correction; to the correlation energy is to be obtained. delta_wfn_lesser (string) – 'mp2' || 'ccsd' || etc.; Indicates the inferior energy method for which a delta correction; to the correlation energy is to be obtained. delta2_wfn (string) – 'ccsd' || 'ccsd(t)' || etc.; Indicates the (superior) energy method for which a second delta correction; to the correlation energy is to be obtained. delta2_wfn_lesser (string) – 'mp2' || 'ccsd(t)' || etc.; Indicates the inferior energy method for which a second delta correction; to the correlation energy is to be obtained. Basis Sets; Currently, the basis set set through set commands have no influence; on a cbs calculation. Parameters:; scf_basis (basis string) – corl_basis || 'cc-pV[TQ]Z' || 'jun-cc-pv[tq5]z' || '6-31G*' || etc.; Indicates the sequence of basis sets employed for the reference energy.; If any correlation method is specified, scf_basis can default; to corl_basis. corl_basis (basis string) – 'cc-pV[TQ]Z' || 'jun-cc-pv[tq5]z' || '6-31G*' || etc.; Indicates the sequence of basis sets employed for the correlation energy. delta_basis (basis string) – 'cc-pV[TQ]Z' || 'jun-cc-pv[tq5]z' || '6-31G*' ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/cbs-1.html:3312,energy,energy,3312,psi4manual/4.0b2/cbs-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/cbs-1.html,4,['energy'],['energy']
Energy Efficiency,"and screen; core.print_out('\n'); p4util.banner('Loading displacement %d of %d' % (n + 1, ndisp)); print("""""" %d"""""" % (n + 1), end=('\n' if (n + 1 == ndisp) else '')); sys.stdout.flush(). # Load in displacement into the active molecule; moleculeclone.set_geometry(displacement). # Perform the energy calculation; E, wfn = energy(lowername, return_wfn=True, molecule=moleculeclone, **kwargs); energies.append(core.get_variable('CURRENT ENERGY')). # S/R: Write each displaced geometry to an input file; elif opt_mode == 'sow':; moleculeclone.set_geometry(displacement). # S/R: Prepare molecule, options, and kwargs; with open('%s.in' % (rfile), 'wb') as freagent:; freagent.write('# This is a psi4 input file auto-generated from the gradient() wrapper.\n\n'.encode('utf-8')); freagent.write(p4util.format_molecule_for_input(moleculeclone).encode('utf-8')); freagent.write(p4util.format_options_for_input().encode('utf-8')); p4util.format_kwargs_for_input(freagent, **kwargs). # S/R: Prepare function call and energy save; freagent.write((""""""electronic_energy = energy('%s', **kwargs)\n\n"""""" % (lowername)).encode('utf-8')); freagent.write((""""""core.print_out('\\nGRADIENT RESULT: computation %d for item %d """""" % (os.getpid(), n + 1)).encode('utf-8')); freagent.write(""""""yields electronic energy %20.12f\\n' % (electronic_energy))\n\n"""""".encode('utf-8')). # S/R: Read energy from each displaced geometry output file and save in energies array; elif opt_mode == 'reap':; exec(banners); core.set_variable('NUCLEAR REPULSION ENERGY', moleculeclone.nuclear_repulsion_energy()); energies.append(p4util.extract_sowreap_from_output(rfile, 'GRADIENT', n, opt_linkage, True)). # S/R: Quit sow after writing files. Initialize skeleton wfn to receive grad for reap; if opt_mode == 'sow':; optstash.restore(); if return_wfn:; return (None, None) # any point to building a dummy wfn here?; else:; return None; elif opt_mode == 'reap':; core.set_variable('CURRENT ENERGY', energies[-1]); wfn = core.Wavefunction.build(",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/driver.html:43204,energy,energy,43204,psi4manual/1.1.0/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/driver.html,2,['energy'],['energy']
Energy Efficiency,"and screen; psi4.print_out('\n'); p4util.banner('Loading displacement %d of %d' % (n + 1, ndisp)); print("""""" %d"""""" % (n + 1), end=('\n' if (n + 1 == ndisp) else '')); sys.stdout.flush(). # Load in displacement into the active molecule; moleculeclone.set_geometry(displacement). # Perform the energy calculation; E, wfn = energy(lowername, return_wfn=True, molecule=moleculeclone, **kwargs); energies.append(psi4.get_variable('CURRENT ENERGY')). # S/R: Write each displaced geometry to an input file; elif opt_mode == 'sow':; moleculeclone.set_geometry(displacement). # S/R: Prepare molecule, options, and kwargs; with open('%s.in' % (rfile), 'wb') as freagent:; freagent.write('# This is a psi4 input file auto-generated from the gradient() wrapper.\n\n'.encode('utf-8')); freagent.write(p4util.format_molecule_for_input(moleculeclone).encode('utf-8')); freagent.write(p4util.format_options_for_input().encode('utf-8')); p4util.format_kwargs_for_input(freagent, **kwargs). # S/R: Prepare function call and energy save; freagent.write((""""""electronic_energy = energy('%s', **kwargs)\n\n"""""" % (lowername)).encode('utf-8')); freagent.write((""""""psi4.print_out('\\nGRADIENT RESULT: computation %d for item %d """""" % (os.getpid(), n + 1)).encode('utf-8')); freagent.write(""""""yields electronic energy %20.12f\\n' % (electronic_energy))\n\n"""""".encode('utf-8')). # S/R: Read energy from each displaced geometry output file and save in energies array; elif opt_mode == 'reap':; exec(banners); psi4.set_variable('NUCLEAR REPULSION ENERGY', moleculeclone.nuclear_repulsion_energy()); energies.append(p4util.extract_sowreap_from_output(rfile, 'GRADIENT', n, opt_linkage, True)). # S/R: Quit sow after writing files. Initialize skeleton wfn to receive grad for reap; if opt_mode == 'sow':; optstash.restore(); if return_wfn:; return (None, None) # any point to building a dummy wfn here?; else:; return None; elif opt_mode == 'reap':; psi4.set_variable('CURRENT ENERGY', energies[-1]); wfn = psi4.new_wavefunction(mo",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/driver.html:41870,energy,energy,41870,psi4manual/1.0.0/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver.html,1,['energy'],['energy']
Energy Efficiency,"and the; MP2, MP3, and MP4(SDQ) correlation energies can be obtained as a free; by-product of a CCSD or QCISD computation. The following is an; example of the results for a computation run with the call; energy('fno-qcisd') to energy():; QCISD iterations converged!. OS MP2 FNO correction: -0.000819116338; SS MP2 FNO correction: -0.000092278158; MP2 FNO correction: -0.000911394496. OS MP2 correlation energy: -0.166478414245; SS MP2 correlation energy: -0.056669079827; MP2 correlation energy: -0.223147494072; * MP2 total energy: -76.258836941658. OS MP2.5 correlation energy: -0.171225850256; SS MP2.5 correlation energy: -0.054028401038; MP2.5 correlation energy: -0.225254251294; * MP2.5 total energy: -76.260943698880. OS MP3 correlation energy: -0.175973286267; SS MP3 correlation energy: -0.051387722248; MP3 correlation energy: -0.227361008515; * MP3 total energy: -76.263050456101. OS MP4(SDQ) correlation energy: -0.180324322304; SS MP4(SDQ) correlation energy: -0.048798468084; MP4(SDQ) correlation energy: -0.230995119324; * MP4(SDQ) total energy: -76.266684566910. OS QCISD correlation energy: -0.181578117924; SS QCISD correlation energy: -0.049853548145; QCISD correlation energy: -0.231431666069; * QCISD total energy: -76.267121113654. The first set of energies printed corresponds to the second-order FNO; correction mentioned previously. Results for many-body perturbation; theory through partial fourth order are then provided.; The notation MP4(SDQ) indicates that we have included all contributions to; the correlation energy through fourth order, with the exception of that; from connected triple excitations.; One need not run a full QCISD or CCSD computation to obtain these; perturbation theory results. The keywords for invoking perturbation; theory computations are given below in; Table FNOCC Methods. Full MP4 correlation; energies are also available. Coupled electron pair approximation¶; Coupled-pair methods can be viewed as approximations to CCSD or as; size-exten",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/fnocc-1.html:6055,energy,energy,6055,psi4manual/1.4.0/fnocc-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/fnocc-1.html,15,['energy'],['energy']
Energy Efficiency,"and thermo analysis of several water isotopologs. Demonstrates Hessian reuse for different temperatures and pressures but not for different isotopologs. dft-pbe0-2; Internal match to psi4, test to match to literature values in litref.in/litref.out. dft-grad-meta; meta-GGA gradients of water and ssh molecules reference gradients updated due to new BraggSlater radii. dft-freq; Frequencies for H2O B3LYP/6-31G* at optimized geometry. pywrap-cbs1; Various basis set extrapolation tests. mp2p5-grad2; MP2.5 cc-pVDZ gradient for the NO radical. dct10; The multiple guesses for DCT amplitudes for ODC-12. tu6-cp-ne2; Example potential energy surface scan and CP-correction for Ne2. dct-grad4; Unrestricted DF-DCT ODC-12 gradient for O2 with cc-pVTZ/cc-pVTZ-RI standard/auxiliary basis set. fsapt-ext; Quick test of external potential in F-SAPT (see fsapt1 for a real example). props4; Electrostatic potential and electric field evaluated on a grid around water. cc4; RHF-CCSD(T) cc-pVQZ frozen-core energy of the BH molecule, with Cartesian input. After the computation, the checkpoint file is renamed, using the PSIO handler. cc38; RHF-CC2-LR/cc-pVDZ static polarizabilities of HOF molecule. cc5; RHF CCSD(T) aug-cc-pvtz frozen-core energy of C4NH4 Anion. ghosts; Density fitted MP2 cc-PVDZ/cc-pVDZ-RI computation of formic acid dimer binding energy using explicit specification of ghost atoms. This is equivalent to the dfmp2_1 sample but uses both (equivalent) specifications of ghost atoms in a manual counterpoise correction. mom-h2o-3; MOM excitation from LUMO HOMO+3. psimrcc-ccsd_t-4; Mk-MRCCSD(T) single point. \(^1A_1\) O$_3` state described using the Ms = 0 component of the singlet. Uses TCSCF orbitals. rasscf-sp; 6-31G** H2O Test RASSCF Energy Point will default to only singles and doubles in the active space. sapt10; usapt example with empty beta due to frozen core. tu5-sapt; Example SAPT computation for ethene*ethine (i.e., ethylene*acetylene), test case 16 from the S22 database. cc3",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/autodoc_testsuite_corepsi4.html:11295,energy,energy,11295,psi4manual/1.6.x/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/autodoc_testsuite_corepsi4.html,2,['energy'],['energy']
Energy Efficiency,"and triples (CC3). c4-ccsd(t); CCSD with perturbative triples (CCSD(T)). c4-ccsdt; coupled cluster singles, doubles, and triples (CCSDT). cfour; expert full control over cfour program. Examples:. 1; 2>>> # [1] Coupled-cluster singles and doubles calculation with psi code; >>> energy('ccsd'). 1; 2; 3; 4; 5>>> # [2] Charge-transfer SAPT calculation with scf projection from small into; >>> # requested basis, with specified projection fitting basis; >>> set basis_guess true; >>> set df_basis_guess jun-cc-pVDZ-JKFIT; >>> energy('sapt0-ct'). 1; 2>>> # [3] Arbitrary-order MPn calculation; >>> energy('mp7'). 1; 2; 3; 4; 5; 6; 7; 8; 9>>> # [4] Converge scf as singlet, then run detci as triplet upon singlet reference; >>> # Note that the integral transformation is not done automatically when detci is run in a separate step.; >>> molecule H2 {\n0 1\nH\nH 1 0.74\n}; >>> set basis cc-pVDZ; >>> set reference rohf; >>> scf_e, scf_wfn = energy('scf', return_wfn=True); >>> H2.set_multiplicity(3); >>> core.MintsHelper(scf_wfn.basisset()).integrals(); >>> energy('detci', ref_wfn=scf_wfn). 1; 2; 3; 4; 5>>> # [5] Run two CI calculations, keeping the integrals generated in the first one.; >>> molecule ne {\nNe\n}; >>> set basis cc-pVDZ; >>> cisd_e, cisd_wfn = energy('cisd', return_wfn=True); >>> energy('fci', ref_wfn=cisd_wfn). 1; 2>>> # [6] Can automatically perform complete basis set extrapolations; >>> energy(""CCSD/cc-pV[DT]Z""). 1; 2; 3; 4>>> # [7] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> energy(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. PSI4 API: Linking C++ and Python. © Copyright 2018, The Psi4 Project.; Last updated on Wednesday, 25 July 2018 04:21AM.; Created using Sphinx 1.7.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/api/psi4.driver.energy-1.html:21179,energy,energy,21179,psi4manual/1.2.1/api/psi4.driver.energy-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/api/psi4.driver.energy-1.html,10,['energy'],['energy']
Energy Efficiency,"and without symmetry, test PK without symmetry. dfomp2-2; OMP2 cc-pVDZ energy for the NO molecule. dfcasscf-sa-sp; Example of state-averaged CASSCF for the C2 molecule. cc9; UHF-CCSD(T) cc-pVDZ frozen-core energy for the state of the CN radical, with Z-matrix input. adc1; ADC/6-31G** on H2O. cc37; CC2(UHF)/cc-pVDZ energy of H2O+. omp2p5-grad1; OMP2.5 cc-pVDZ gradient for the H2O molecule. rasscf-sp; 6-31G** H2O Test RASSCF Energy Point will default to only singles and doubles in the active space. psithon2; Accesses basis sets, databases, plugins, and executables in non-install locations. x2c1; Test of SFX2C-1e on water uncontracted cc-pVDZ-DK The reference numbers are from Lan Cheng’s implementation in Cfour. dft2; DFT Functional Test. scf4; RHF cc-pVDZ energy for water, automatically scanning the symmetric stretch and bending coordinates using Python’s built-in loop mechanisms. The geometry is specified using a Z-matrix with variables that are updated during the potential energy surface scan, and then the same procedure is performed using polar coordinates, converted to Cartesian coordinates. dfomp2-1; OMP2 cc-pVDZ energy for the H2O molecule. cisd-sp; 6-31G** H2O Test CISD Energy Point. dft-psivar; HF and DFT variants single-points on zmat methane, mostly to test that PSI variables are set and computed correctly. Now also testing that CSX harvesting PSI variables correctly. sad1; Test of the superposition of atomic densities (SAD) guess, using a highly distorted water geometry with a cc-pVDZ basis set. This is just a test of the code and the user need only specify guess=sad to the SCF module’s (or global) options in order to use a SAD guess. The test is first performed in C2v symmetry, and then in C1. mp3-grad1; MP3 cc-pVDZ gradient for the H2O molecule. mp2-def2; Test case for Binding Energy of C4H5N (Pyrrole) with CO2 using MP2/def2-TZVPP. scf3; File retention, docc, socc, and bond distances specified explicitly. dfscf-bz2; Benzene Dimer DF-HF/cc-pVDZ. dfomp3-gra",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_testsuite_corepsi4-1.html:30565,energy,energy,30565,psi4manual/1.0.0/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_testsuite_corepsi4-1.html,4,['energy'],['energy']
Energy Efficiency,"and/or the extended method syntax like; 'mp3/aug-cc-pv[dt]z' to energy(), opt(), etc., respectively.; For many of the PSI4 Python functions described above, it makes scientific; sense that they could be called in combination. For instance, one could; optimize all the reagents in a database or compute a; counterpoise-corrected interaction energy with an extrapolated method. The; table below outlines permitted intercalls between functions, showing that; db(opt(cbs(energy()))) is allowed, while db(cp(energy())) is not. This; table is not yet validated for calls with cp(). Permitted nesting of Psithon functions¶. Caller; Callee. cp; db; opt; cbs; energy. Basis Set Superposition Corrections. —; Y; Y; Y. Database — database(); —. Y; Y; Y. Geometry Optimization — optimize() and gradient(); —; —. Y; Y. Complete Basis Set; —; —; —. Y. Single-Point Energy — energy(); —; —; —; —. The command db(opt(cbs(energy()))) is actually expressed as db(...,; db_func=opt, opt_func=cbs). The perhaps expected final argument of; cbs_func=energy is not necessary since energy() is always the function; called by default. Also, the outermost internal function call (db_func; above can be called as just func. Several examples of intercalls; between Python functions can be found in sample input pywrap-all.; All keyword arguments are passed along to each function traversed in the; Python driver, so there should be no concern for separating them, grouping; them, or designating them for a particular function when undertaking a; nested calculation. Where the same keyword is used by multiple functions,; prefixes are added, e.g., db_mode and opt_mode.; Function intercalls should not be used in sow/reap mode. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Psithon Functions: Invoking a Calculation; Function Intercalls. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/intercalls.html:1361,energy,energy,1361,psi4manual/master/intercalls.html,https://psicode.org,https://psicode.org/psi4manual/master/intercalls.html,2,['energy'],['energy']
Energy Efficiency,"andard Python syntax.; Having named our molecule h2o we can then set the values of R and A within; the loops. Note that we do not need the dollar sign to access the Python; variable in this example; that is required only when using Python variables; with the set keyword.; Cartesian geometries, because of details of the geometry update process,; need to be specified within the loop(s) along with their basis set when; geometry scans are performed. See scf4 for analogous Z-matrix; and Cartiesian scans. Tables of Results¶; The Psithon function psi4.driver.p4util.Table has been removed,; as the Python ecosystem provides many more flexible alternatives. An; example tabulating a potential energy surface scan for water with Pandas; is shown below:; molecule h2o {; O; H 1 R; H 1 R 2 A; }. Rvals=[0.9,1.0,1.1]; Avals=range(100,103,2). rows = []; table = []. set basis cc-pvdz. for R in Rvals:; h2o.R = R; for A in Avals:; h2o.A = A; energy('mp2'); escf = variable('SCF TOTAL ENERGY'); edfmp2 = variable('MP2 TOTAL ENERGY'); escsmp2 = variable('SCS-MP2 TOTAL ENERGY'); rows.append((R, A)); table.append([escf, escsmp2, edfmp2]). import pandas as pd; df = pd.DataFrame(table, columns = [""E(SCF)"", ""E(SCS)"", ""E(DFMP2)""], index=rows); print(df). # E(SCF) E(SCS) E(DFMP2); # (0.9, 100) -76.020680 -76.217006 -76.221189; # (0.9, 102) -76.021305 -76.217439 -76.221605; # (1.0, 100) -76.021264 -76.224987 -76.228727; # (1.0, 102) -76.021460 -76.224946 -76.228668; # (1.1, 100) -75.990195 -76.201891 -76.205087; # (1.1, 102) -75.990085 -76.201498 -76.204676. Python Wrappers¶; The Python foundations of the PSI4 driver and Psithon syntax permit; many commonly performed post-processing procedures to be integrated into; the PSI4 suite.; As seen in the neon dimer example from the tutorial section,; the nbody() wrapper provides automatic computation of; counterpoise-corrected interaction energies between two molecules. For; example,; energy('mp2', bsse_type='cp'). will compute the counterpoise-corrected de",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/psithoninput.html:12327,energy,energy,12327,psi4manual/1.7.x/psithoninput.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/psithoninput.html,3,['energy'],['energy']
Energy Efficiency,"aneous solution of the response equations for the analytic gradient. opt-irc-1; Compute the IRC for HOOH torsional rotation at the RHF/DZP level of theory. sapt-ecp; sapt0 of charged system in ECP basis set. mints10; H2 with tiny basis set, to test basis set parser’s handling of integers. dcft2; DC-06 calculation for the He dimer. This performs a two-step update of the orbitals and cumulant, using DIIS extrapolation. Four-virtual integrals are handled in the MO Basis. fci-tdm-2; BH-H2+ FCI/cc-pVDZ Transition Dipole Moment. dfcasscf-fzc-sp; CASSCF/6-31G** energy point. cepa2; cc-pvdz H2O Test ACPF Energy/Properties. cc24; Single point gradient of 1-2B1 state of H2O+ with EOM-CCSD. castup1; Test of SAD/Cast-up (mainly not dying due to file weirdness). dfomp3-grad1; DF-OMP3 cc-pVDZ gradients for the H2O molecule. pywrap-alias; Test parsed and exotic calls to energy() like zapt4, mp2.5, and cisd are working. fci-dipole; 6-31G H2O Test FCI Energy Point. sapt-dft1; SAPT(DFT) aug-cc-pVDZ interaction energy between Ne and Ar atoms. cc2; 6-31G** H2O CCSD optimization by energies, with Z-Matrix input. dft1; DFT Functional Test. nbody-intermediates; HF/cc-pVDZ many body energies of an arbitrary noble gas trimer complex Size vs cost tradeoff is rough here. cc11; Frozen-core CCSD(ROHF)/cc-pVDZ on CN radical with disk-based AO algorithm. pywrap-cbs1; Various basis set extrapolation tests. x2c3; Test of SFX2C-1e on Water uncontracted cc-pVDZ The reference numbers are from Lan Cheng’s implementation in Cfour. cubeprop-esp; RHF orbitals and density for water. cc49; EOM-CC3(UHF) on CH radical with user-specified basis and properties for particular root. opt-multi-dimer-c1; Multi-fragment opt of C2h methane dimer with user-combined reference points. pywrap-checkrun-uhf; This checks that all energy methods can run with a minimal input and set symmetry. cc13c; Tests RHF CCSD(T)gradients. mom; Maximum Overlap Method (MOM) Test. MOM is designed to stabilize SCF convergence and to target ex",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/autodoc_testsuite_corepsi4-1.html:12777,energy,energy,12777,psi4manual/1.3.2/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/autodoc_testsuite_corepsi4-1.html,4,['energy'],['energy']
Energy Efficiency,"ange (0,nirrep):; nfzc += frzcpi[i]; nalpha = ref.nalpha() - nfzc; nbeta = ref.nbeta() - nfzc; # hlc of gaussian-2; hlc = -0.00481 * nalpha -0.00019 * nbeta; # hlc of gaussian-1; hlc1 = -0.00614 * nalpha. eqci_6311gdp = PsiMod.get_variable(""QCISD(T) TOTAL ENERGY""); emp4_6311gd = PsiMod.get_variable(""MP4 TOTAL ENERGY""); emp2_6311gd = PsiMod.get_variable(""MP2 TOTAL ENERGY""); PsiMod.clean(). # correction for diffuse functions; PsiMod.set_global_option('BASIS',""6-311+G(D_P)""); energy('mp4'); emp4_6311pg_dp = PsiMod.get_variable(""MP4 TOTAL ENERGY""); emp2_6311pg_dp = PsiMod.get_variable(""MP2 TOTAL ENERGY""); PsiMod.clean(). # correction for polarization functions; PsiMod.set_global_option('BASIS',""6-311G(2DF_P)""); energy('mp4'); emp4_6311g2dfp = PsiMod.get_variable(""MP4 TOTAL ENERGY""); emp2_6311g2dfp = PsiMod.get_variable(""MP2 TOTAL ENERGY""); PsiMod.clean(). # big basis mp2; PsiMod.set_global_option('BASIS',""6-311+G(3DF_2P)""); run_fnocc('_mp2',**kwargs); emp2_big = PsiMod.get_variable(""MP2 TOTAL ENERGY""); PsiMod.clean(). eqci = eqci_6311gdp; e_delta_g2 = emp2_big + emp2_6311gd - emp2_6311g2dfp - emp2_6311pg_dp; e_plus = emp4_6311pg_dp - emp4_6311gd; e_2df = emp4_6311g2dfp - emp4_6311gd. eg2 = eqci + e_delta_g2 + e_plus + e_2df; eg2_mp2_0k = eqci + (emp2_big - emp2_6311gd) + hlc + zpe. PsiMod.print_out('\n'); PsiMod.print_out(' ==> G1/G2 Energy Components <==\n'); PsiMod.print_out('\n'); PsiMod.print_out(' QCISD(T): %20.12lf\n' % eqci); PsiMod.print_out(' E(Delta): %20.12lf\n' % e_delta_g2); PsiMod.print_out(' E(2DF): %20.12lf\n' % e_2df); PsiMod.print_out(' E(+): %20.12lf\n' % e_plus); PsiMod.print_out(' E(G1 HLC): %20.12lf\n' % hlc1); PsiMod.print_out(' E(G2 HLC): %20.12lf\n' % hlc); PsiMod.print_out(' E(ZPE): %20.12lf\n' % zpe); PsiMod.print_out('\n'); PsiMod.print_out(' ==> 0 Kelvin Results <==\n'); PsiMod.print_out('\n'); eg2_0k = eg2 + zpe + hlc; PsiMod.print_out(' G1: %20.12lf\n' % (eqci + e_plus + e_2df + hlc1 + zpe)); PsiMod.print_out(' G2(MP2): %20.12lf\n' % eg2_mp",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/_modules/gaussian_n.html:2958,ENERGY,ENERGY,2958,psi4manual/4.0b4/_modules/gaussian_n.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/gaussian_n.html,1,['ENERGY'],['ENERGY']
Energy Efficiency,"ange-scaling with F-SAPT. Type: boolean; Default: false. STABILITY_ADD_VECTORS (DCFT); DCFT (Expert) — The number of vectors that can be added simultaneously into the subspace for Davidson’s diagonalization in stability check. Type: integer; Default: 20. STABILITY_ANALYSIS (SCF); SCF — Whether to perform stability analysis after convergence. NONE prevents analysis being performed. CHECK will print out the analysis of the wavefunction stability at the end of the computation. FOLLOW will perform the analysis and, if a totally symmetric instability is found, will attemp to follow the eigenvector and re-run the computations to find a stable solution. Type: string; Possible Values: NONE, CHECK, FOLLOW; Default: NONE. STABILITY_AUGMENT_SPACE_TOL (DCFT); DCFT (Expert) — The value of the rms of the residual in Schmidt orthogonalization which is used as a threshold for augmenting the vector subspace in stability check. Type: conv double; Default: 0.1. STABILITY_CHECK (DCFT); DCFT (Expert) — Performs stability analysis of the DCFT energy. Type: boolean; Default: false. STABILITY_CONVERGENCE (DCFT); DCFT (Expert) — Controls the convergence of the Davidson’s diagonalization in stability check. Type: conv double; Default: 1e-4. STABILITY_MAX_SPACE_SIZE (DCFT); DCFT (Expert) — The maximum size of the subspace for the stability check. The program will terminate if this parameter is exceeded and the convergence (STABILITY_CONVERGENCE) is not satisfied. Type: integer; Default: 200. STABILITY_N_EIGENVALUES (DCFT); DCFT (Expert) — The number of Hessian eigenvalues computed during the stability check. Type: integer; Default: 3. STABILITY_N_GUESS_VECTORS (DCFT); DCFT (Expert) — The number of guess vectors used for Davidson’s diagonalization in stability check. Type: integer; Default: 20. STEP_TYPE (OPTKING); OPTKING — Geometry optimization step type, either Newton-Raphson or Rational Function Optimization. Type: string; Possible Values: RFO, NR, SD, LINESEARCH_STATIC; Default: RFO. SYMM",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_glossary_options_c-1.html:210584,energy,energy,210584,psi4manual/1.0.0/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_glossary_options_c-1.html,2,['energy'],['energy']
Energy Efficiency,"anged! (%s <-- %s) You should restart """"""; """"""using the last geometry in the output, after """"""; """"""carefully making sure all symmetry-dependent """"""; """"""input, such as DOCC, is correct."""""" % (current_sym, initial_sym)); kwargs['opt_iter'] = n; core.set_variable('GEOMETRY ITERATIONS', n). # Use orbitals from previous iteration as a guess; # set within loop so that can be influenced by fns to optimize (e.g., cbs); if (n > 1) and (not core.get_option('SCF', 'GUESS_PERSIST')):; core.set_local_option('SCF', 'GUESS', 'READ'). # Before computing gradient, save previous molecule and wavefunction if this is an IRC optimization; if (n > 1) and (core.get_option('OPTKING', 'OPT_TYPE') == 'IRC'):; old_thisenergy = core.variable('CURRENT ENERGY'). # Compute the gradient - preserve opt data despite core.clean calls in gradient; core.IOManager.shared_object().set_specific_retention(1, True); G, wfn = gradient(lowername, return_wfn=True, molecule=moleculeclone, **kwargs); thisenergy = core.variable('CURRENT ENERGY'). # above, used to be getting energy as last of energy list from gradient(); # thisenergy below should ultimately be testing on wfn.energy(). # Record optimization steps; # Add wavefunctions later; if return_history:; step_energies.append(thisenergy); step_coordinates.append(moleculeclone.geometry()); step_gradients.append(G.clone()). core.set_legacy_gradient(G). # opt_func = kwargs.get('opt_func', kwargs.get('func', energy)); # if opt_func.__name__ == 'complete_basis_set':; # core.IOManager.shared_object().set_specific_retention(1, True). if full_hess_every > -1:; core.set_global_option('HESSIAN_WRITE', True). # compute Hessian as requested; frequency wipes out gradient so stash it; if ((full_hess_every > -1) and (n == 1)) or (steps_since_last_hessian + 1 == full_hess_every):; G = core.get_legacy_gradient() # TODO; core.IOManager.shared_object().set_specific_retention(1, True); core.IOManager.shared_object().set_specific_path(1, './'); frequencies(hessian_with_method, mole",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver.html:65523,ENERGY,ENERGY,65523,psi4manual/1.6.x/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver.html,1,['ENERGY'],['ENERGY']
Energy Efficiency,"angian Matrix. alpha_orbital_space(self: psi4.core.Wavefunction, arg0: str, arg1: str, arg2: str) → psi4.core.OrbitalSpace; docstring. aotoso(self: psi4.core.Wavefunction) → psi4.core.Matrix; Returns the Atomic Orbital to Symmetry Orbital transformer. arrays(self: psi4.core.Wavefunction) → Dict[str, psi4.core.Matrix]; Returns the map of all internal arrays. atomic_point_charges(self: psi4.core.Wavefunction) → psi4.core.Vector; Returns the set atomic point charges. basis_projection(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix, arg1: psi4.core.Dimension, arg2: psi4.core.BasisSet, arg3: psi4.core.BasisSet) → psi4.core.Matrix; Projects a orbital matrix from one basis to another. basisset(self: psi4.core.Wavefunction) → psi4.core.BasisSet; Returns the current orbital basis. beta_orbital_space(self: psi4.core.Wavefunction, arg0: str, arg1: str, arg2: str) → psi4.core.OrbitalSpace; docstring. static build(mol, basis=None). compute_energy(self: psi4.core.Wavefunction) → float; Computes the energy of the Wavefunction. compute_gradient(self: psi4.core.Wavefunction) → psi4.core.Matrix; Computes the gradient of the Wavefunction. compute_hessian(self: psi4.core.Wavefunction) → psi4.core.Matrix; Computes the Hessian of the Wavefunction. deep_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None; Deep copies the internal data. doccpi(self: psi4.core.Wavefunction) → psi4.core.Dimension; Returns the number of doubly occupied orbitals per irrep. energy(self: psi4.core.Wavefunction) → float; Returns the Wavefunctions energy. epsilon_a(self: psi4.core.Wavefunction) → psi4.core.Vector; Returns the Alpha Eigenvalues. epsilon_a_subset(self: psi4.core.Wavefunction, arg0: str, arg1: str) → psi4.core.Vector; Returns the requested Alpha Eigenvalues subset. epsilon_b(self: psi4.core.Wavefunction) → psi4.core.Vector; Returns the Beta Eigenvalues. epsilon_b_subset(self: psi4.core.Wavefunction, arg0: str, arg1: str) → psi4.core.Vector; Returns the requested Beta Eigenvalu",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/api/psi4.core.wavefunction.html:14489,energy,energy,14489,psi4manual/1.1.0/api/psi4.core.wavefunction.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.wavefunction.html,1,['energy'],['energy']
Energy Efficiency,"angle\)). fnocc2; Test G2 method for H2O. opt4; SCF cc-pVTZ geometry optimzation, with Z-matrix input. dfmp2-grad1; DF-MP2 cc-pVDZ gradients for the H2O molecule. props4; Electrostatic potential and electric field evaluated on a grid around water. psimrcc-ccsd_t-2; Mk-MRCCSD(T) single point. \(^1A_1\) CH2 state described using the Ms = 0 component of the singlet. Uses RHF singlet orbitals. cbs-xtpl-freq; Various gradients for a strained helium dimer and water molecule. cisd-h2o-clpse; 6-31G** H2O Test CISD Energy Point with subspace collapse. rasci-h2o; RASCI/6-31G** H2O Energy Point. opt8; Various constrained energy minimizations of HOOH with cc-pvdz RHF. Cartesian-coordinate constrained optimizations of HOOH in Cartesians. opt6; Various constrained energy minimizations of HOOH with cc-pvdz RHF Internal-coordinate constraints in internal-coordinate optimizations. dfmp2-3; DF-MP2 cc-pVDZ frozen core gradient of benzene, computed at the DF-SCF cc-pVDZ geometry. cdomp2-1; OMP2 cc-pVDZ energy for the H2O molecule. fsapt-diff1; This test case shows an example of running and analyzing a difference F-SAPT0/jun-cc-pvdz procedure for phenol dimer from the S22 database. freq-isotope; Vibrational and thermo analysis of several water isotopologs. Demonstrates Hessian reuse for different temperatures and pressures but not for different isotopologs. cc13a; UHF-CCSD(T)/cc-pVDZ \(^{3}B_1\) CH2 geometry optimization via analytic gradients. cc8c; ROHF-CCSD cc-pVDZ frozen-core energy for the \(^2\Sigma^+\) state of the CN radical, with Cartesian input. props1; RHF STO-3G dipole moment computation, performed by applying a finite electric field and numerical differentiation. cc45; RHF-EOM-CC2/cc-pVDZ lowest two states of each symmetry of H2O. fnocc4; Test FNO-DF-CCSD(T) energy. tu3-h2o-opt; Optimize H2O HF/cc-pVDZ. cc9; UHF-CCSD(T) cc-pVDZ frozen-core energy for the \(^2\Sigma^+\) state of the CN radical, with Z-matrix input. mcscf3; RHF 6-31G** energy of water, using the MCSCF module ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/testsuite-1.html:26792,energy,energy,26792,psi4manual/1.1.0/testsuite-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/testsuite-1.html,4,['energy'],['energy']
Energy Efficiency,"anners); core.set_variable('NUCLEAR REPULSION ENERGY', moleculeclone.nuclear_repulsion_energy()); pygrad = p4util.extract_sowreap_from_output(rfile, 'HESSIAN', n, freq_linkage, True, label='electronic gradient'); p4mat = core.Matrix.from_list(pygrad); p4mat.print_out(); gradients.append(p4mat); energies.append(p4util.extract_sowreap_from_output(rfile, 'HESSIAN', n, freq_linkage, True)). # S/R: Quit sow after writing files. Initialize skeleton wfn to receive grad for reap; if freq_mode == 'sow':; optstash.restore(); optstash_conv.restore(); if return_wfn:; return (None, None); else:; return None; elif freq_mode == 'reap':; wfn = core.Wavefunction.build(molecule, core.get_global_option('BASIS')). # Assemble Hessian from gradients; # Final disp is undisp, so wfn has mol, G, H general to freq calc; H = core.fd_freq_1(molecule, gradients, irrep) # TODO or moleculeclone?; wfn.set_hessian(H); wfn.set_gradient(G0); wfn.set_frequencies(core.get_frequencies()). # The last item in the list is the reference energy, return it; core.set_variable('CURRENT ENERGY', energies[-1]). core.set_parent_symmetry(''); optstash.restore(); optstash_conv.restore(). _hessian_write(wfn). if return_wfn:; return (wfn.hessian(), wfn); else:; return wfn.hessian(). else:; core.print_out(""""""hessian() will perform frequency computation by finite difference of analytic energies.\n""""""). # Set method-dependent scf convergence criteria (test on procedures['energy'] since that's guaranteed); optstash.restore(); optstash_conv.restore(); optstash_conv = driver_util._set_convergence_criterion('energy', lowername, 10, 11, 10, 11, 10). # Shifting the geometry so need to copy the active molecule; moleculeclone = molecule.clone(). # Obtain list of displacements; displacements = core.fd_geoms_freq_0(moleculeclone, irrep); moleculeclone.fix_orientation(True); moleculeclone.reinterpret_coordentry(False). # Record undisplaced symmetry for projection of diplaced point groups; core.set_parent_symmetry(molecule.schoenfli",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/driver.html:77616,energy,energy,77616,psi4manual/1.2.1/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/driver.html,1,['energy'],['energy']
Energy Efficiency,"ansfer computations are not available with open-shell SAPT0.; A SAPT charge-transfer analysis will perform 5 HF computations: the dimer; in the dimer basis, monomer A in the dimer basis, monomer B in the dimer; basis, monomer A in the monomer A basis, and monomer B in the monomer B; basis. Next, it performs two SAPT computations, one in the dimer basis and; one in the monomer basis. Finally, it will print a summary of the; charge-transfer results:; SAPT Charge Transfer Analysis; ------------------------------------------------------------------------------------------------; SAPT Induction (Dimer Basis) -2.0970 [mEh] -1.3159 [kcal/mol] -5.5057 [kJ/mol]; SAPT Induction (Monomer Basis) -1.1396 [mEh] -0.7151 [kcal/mol] -2.9920 [kJ/mol]; SAPT Charge Transfer -0.9574 [mEh] -0.6008 [kcal/mol] -2.5137 [kJ/mol]. These results are for the water dimer geometry shown above computed with; SAPT0/aug-cc-pVDZ. Monomer-Centered Basis Computations¶; The charge-transfer analysis above is carried out by taking the; difference between SAPT induction as calculated in the dimer-centered; basis (i.e., each monomer sees the basis functions on both monomers); vs. the monomer-centered basis (i.e., each monomer utilizes only its; own basis set). It is also possible to run a closed-shell SAPT computation at any; level using only the monomer-centered basis. To do this, simply add; sapt_basis='monomer' to the energy function, such as; energy('sapt2',sapt_basis='monomer'). This procedure leads to faster compuations, but it converges more slowly; towards the complete basis set limit than the default procedure, which uses; the dimer-centered basis set. Hence, monomer-centered basis SAPT; computations are not recommended. The open-shell SAPT0 code is not; compatible yet with monomer-centered computations. Computations with Mid-bonds¶; SAPT computations with midbonds can be accomplished by adding a third ghost; monomer to the computation. For example; molecule dimer {; 0 1; He 0 0 5; --; 0 1; He 0 0 ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/sapt-1.html:31776,charge,charge-transfer,31776,psi4manual/1.4.0/sapt-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/sapt-1.html,9,['charge'],['charge-transfer']
Energy Efficiency,"ant matrix FCMFINAL, which is written to disk during the course of both analytic and finite-difference vibrational frequency calculations. No such transformation is performed if OFF (=0); while ON (=1) directs the program to evaluate the gradient and transform it to the chosen set of normal coordinates. A warning message is printed if the force constant matrix is unavailable. Type: boolean; Default: false. CFOUR_RESTART_CC (CFOUR)¶CFOUR — Offers the possibility to restart a CC calculation which stopped for various reasons, e.g. time limit, in the correlation part. However, note that a restart which is specified by ON (= 1) needs the following files of the previous unfinished calculation: JOBARC, JAINDX, MOINTS, and MOABCD. Type: boolean; Default: false. CFOUR_ROT_EVEC (CFOUR)¶CFOUR — Specifies which eigenvector of the orbital rotation Hessian is to be used to rotate the original SCF orbitals. By default, it will use that associated with the lowest eigenvalue of the totally symmetric part of the block-factored Hessian, as this choice often leads to the lowest energy SCF solution. For RHF stability checks, only those instabilities which correspond to RHF solutions will be considered. It is important to understand that following non-symmetric eigenvectors lowers the symmetry of the wavefunction and that following RHF –> UHF stabilities leads to a UHF solution. To converge the SCF roots associated with such instabilities, one must run the calculation in reduced symmetry and as a closed-shell UHF case, respectively. Value n directs the program to follow the vector associated with the nth lowest eigenvalue having the proper symmetry (totally symmetric) and spin (RHF–>RHF or UHF–>UHF) properties. 0 means use the lowest eigenvalue. Type: integer; Default: 0. CFOUR_SAVE_INTS (CFOUR)¶CFOUR — Tells CFOUR whether to delete large files (AO integrals and MOINTS file for now) when they are no longer needed. OFF (=0) They will not be saved, ON (=1) they will be saved. Type: boolean",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/autodoc_glossary_options_c-1.html:73702,energy,energy,73702,psi4manual/1.4.0/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodoc_glossary_options_c-1.html,9,['energy'],['energy']
Energy Efficiency,"ant; (). As a result, the energy functional is Hermitian,; which is important for the evaluation of the molecular properties. The additive; separability of the density cumulant guarantees that all of the DCFT methods; are size-extensive and size-consistent. Furthermore, the N-representability; problem is now greatly simplified, because the idempotent part of is; N-representable by construction. One only needs to worry about the; N-representability of the density cumulant, which is a relatively small part of; .; In order to obtain the DCFT energy, two conditions must be satisfied:; 1) The energy must be stationary with respect to a set of orbitals. This can be done by; diagonalizing the generalized Fock operator (as in the DC-06 and DC-12 methods, see below),; which introduces partial orbital relaxation, or by fully relaxing the orbitals and minimizing the entire energy expression; (as in the ODC-06 and ODC-12 methods).; 2) The energy must be stationary with respect to the variation of the density; cumulant , constrained to N-representability conditions.; Making the energy stationary requires solution of two sets of coupled; equations for orbitals and density cumulant, respectively (also known as; residual equations). At the present moment, three different algorithms for the; solution of the system of coupled equations are available (see section; Iterative Algorithms for details).; Publications resulting from the use of the DCFT code should cite contributions; listed here. Methods¶; Currently five DCFT methods (functionals) are available: DC-06, DC-12, ODC-06, ODC-12, and ODC-13. The first four; methods use approximate N-representability conditions derived from; second-order perturbation theory and differ in the description of the; correlated (non-idempotent) part of the one-particle density; matrix and orbital optimization. While in the DC-06 and ODC-06 methods is derived from the density cumulant; in an approximate way (labelled by ‘06’), the DC-12 and ODC-12 method",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/dcft-1.html:3233,energy,energy,3233,psi4manual/1.0.0/dcft-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/dcft-1.html,2,['energy'],['energy']
Energy Efficiency,"ant; \(| \Phi_0 \rangle\). The CISD wavefunction has fallen out of favor; because truncated CI wavefunctions are not size-extensive, meaning; that their quality degrades for larger molecules. MP2 is a less; expensive alternative giving results similar to those of CISD for small; molecules, but the quality of MP2 does not degrade for larger molecules.; Coupled-cluster singles and doubles (CCSD) is another size-extensive; alternative; it is only slightly more costly computationally than CISD,; but it typically provides significantly more accurate results.; The CI code in PSI4 is described in detail in; [Sherrill:1999:CI]. For the reasons stated above, the CI code in; PSI4 is not optimized for CISD computations, and it uses data structures; that are particularly inefficient for CISD and may result in the program; running out of memory and crashing for CISD except on very small molecules.; Instead, DETCI was designed to be efficient; in handling more highly correlated CI wavefunctions that can be helpful in more; challenging cases such as highly strained molecules or bond breaking reactions. The CI; code is based on the fast, determinant-based string formalism; of Handy [Handy:1980]. It can solve for restricted active space; configuration interaction (RAS CI) wavefunctions as described by Olsen,; Roos, Jorgensen, and Aa. Jensen [Olsen:1988]. Excitation-class; selected multi-reference CI wavefunctions, such as second-order CI,; can be formulated as RAS CI’s. A RAS CI selects determinants for the; model space as those which have no more than \(n\) holes in the lowest set; of orbitals (called RAS I) and no more than \(m\) electrons in the highest; set of orbitals (called RAS III). An intermediate set of orbitals, if; present (RAS II), has no restrictions placed upon it. All determinants; satisfying these rules are included in the RAS CI.; The DETCI module is also very efficient at computing full configuration; interaction; wavefunctions, and it is used in this capacity in t",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/detci-1.html:2371,efficient,efficient,2371,psi4manual/1.4.0/detci-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/detci-1.html,9,['efficient'],['efficient']
Energy Efficiency,"antities; energy('mp3', **kwargs); e_scf = PsiMod.get_variable('SCF TOTAL ENERGY'); ce_mp2 = PsiMod.get_variable('MP2 CORRELATION ENERGY'); ce_mp3 = PsiMod.get_variable('MP3 CORRELATION ENERGY'); e_mp2 = e_scf + ce_mp2 # reform mp2 and mp3 total energies for printing; e_mp3 = e_scf + ce_mp3. # Compute quantities particular to MP2.5; ce_mp25 = 0.5 * (ce_mp2 + ce_mp3); e_mp25 = e_scf + ce_mp25; PsiMod.set_variable('MP2.5 CORRELATION ENERGY', ce_mp25) # add new method's important results; PsiMod.set_variable('MP2.5 TOTAL ENERGY', e_mp25) # to PSI variable repository; PsiMod.set_variable('CURRENT CORRELATION ENERGY', ce_mp25); PsiMod.set_variable('CURRENT ENERGY', e_mp25) # geometry optimizer tracks this variable, permits; # MP2.5 finite difference optimizations; # build string of title banner and print results; banners = ''; banners += """"""PsiMod.print_out('\\n')\n""""""; banners += """"""banner(' MP2.5 ')\n""""""; banners += """"""PsiMod.print_out('\\n')\n\n""""""; exec banners. tables = ''; tables += """""" SCF total energy: %16.8f\n"""""" % (e_scf); tables += """""" MP2 total energy: %16.8f\n"""""" % (e_mp2); tables += """""" MP2.5 total energy: %16.8f\n"""""" % (e_mp25); tables += """""" MP3 total energy: %16.8f\n\n"""""" % (e_mp3); tables += """""" MP2 correlation energy: %16.8f\n"""""" % (ce_mp2); tables += """""" MP2.5 correlation energy: %16.8f\n"""""" % (ce_mp25); tables += """""" MP3 correlation energy: %16.8f\n"""""" % (ce_mp3); PsiMod.print_out(tables) # prints nice header and table of all involved quantities to output file. return e_mp25. One final step is necessary. At the end of the aliases.py file, add; the following line.; procedures['energy']['mp2.5'] = run_mp2_5. This permits the newly defined MP2.5 method to be called in the input file; with the following command.; energy('mp2.5'). Previous topic; User-Defined Basis Sets; Next topic; Creating a Database; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules |. next |. previous |; PSI4 [b",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/quickaddalias-1.html:2730,energy,energy,2730,psi4manual/4.0b2/quickaddalias-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/quickaddalias-1.html,2,['energy'],['energy']
Energy Efficiency,"antities; energy('mp3', **kwargs); e_scf = PsiMod.get_variable('SCF TOTAL ENERGY'); ce_mp2 = PsiMod.get_variable('MP2 CORRELATION ENERGY'); ce_mp3 = PsiMod.get_variable('MP3 CORRELATION ENERGY'); e_mp2 = e_scf + ce_mp2 # reform mp2 and mp3 total energies for printing; e_mp3 = e_scf + ce_mp3. # Compute quantities particular to MP2.5; ce_mp25 = 0.5 * (ce_mp2 + ce_mp3); e_mp25 = e_scf + ce_mp25; PsiMod.set_variable('MP2.5 CORRELATION ENERGY', ce_mp25) # add new method's important results; PsiMod.set_variable('MP2.5 TOTAL ENERGY', e_mp25) # to PSI variable repository; PsiMod.set_variable('CURRENT CORRELATION ENERGY', ce_mp25); PsiMod.set_variable('CURRENT ENERGY', e_mp25) # geometry optimizer tracks this variable, permits; # MP2.5 finite difference optimizations; # build string of title banner and print results; banners = ''; banners += """"""PsiMod.print_out('\\n')\n""""""; banners += """"""banner(' MP2.5 ')\n""""""; banners += """"""PsiMod.print_out('\\n')\n\n""""""; exec banners. tables = ''; tables += """""" SCF total energy: %16.8f\n"""""" % (e_scf); tables += """""" MP2 total energy: %16.8f\n"""""" % (e_mp2); tables += """""" MP2.5 total energy: %16.8f\n"""""" % (e_mp25); tables += """""" MP3 total energy: %16.8f\n\n"""""" % (e_mp3); tables += """""" MP2 correlation energy: %16.8f\n"""""" % (ce_mp2); tables += """""" MP2.5 correlation energy: %16.8f\n"""""" % (ce_mp25); tables += """""" MP3 correlation energy: %16.8f\n"""""" % (ce_mp3); PsiMod.print_out(tables) # prints nice header and table of all involved quantities to output file. return e_mp25. One final step is necessary. At the end of the aliases.py file, add; the following line.; procedures['energy']['mp2.5'] = run_mp2_5. This permits the newly defined MP2.5 method to be called in the input file; with the following command.; energy('mp2.5'). Previous topic; User-Defined Basis Sets; Next topic; Creating a Database; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previo",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/quickaddalias-1.html:2745,energy,energy,2745,psi4manual/4.0b3/quickaddalias-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/quickaddalias-1.html,4,['energy'],['energy']
Energy Efficiency,"antity in Eq. (4). QCISD TOTAL ENERGY¶. QCISD CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the quadratic configuration interaction singles and doubles level; of theory. QCISD(T) TOTAL ENERGY¶. QCISD(T) CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the quadratic configuration interaction singles and doubles with; perturbative triples correction level of theory. SAPT DISP ENERGY¶. SAPT ELST ENERGY¶. SAPT EXCH ENERGY¶. SAPT IND ENERGY¶; Respectively, the dispersion, electrostatics, exchange, and induction; components of the total electronic interaction energy [H] for the the; requested SAPT level of theory. The sum of these four components yields; SAPT ENERGY. SAPT ENERGY¶; The total electronic interaction energy [H] for the requested SAPT; level of theory. SAPT SAPT0 ENERGY¶. SAPT SAPT2 ENERGY¶. SAPT SAPT2+ ENERGY¶. SAPT SAPT2+(3) ENERGY¶. SAPT SAPT2+3 ENERGY¶; The total electronic interaction energy [H] for the labeled SAPT level; of theory. SAPT SAPT2+(CCD) ENERGY¶. SAPT SAPT2+(3)(CCD) ENERGY¶. SAPT SAPT2+3(CCD) ENERGY¶; The total electronic interaction energy [H] for the labeled SAPT level; of theory that incorporates coupled-cluster dispersion. SCF DIPOLE X¶. SCF DIPOLE Y¶. SCF DIPOLE Z¶; The three components of the SCF dipole [Debye]. SCF QUADRUPOLE XX¶. SCF QUADRUPOLE XY¶. SCF QUADRUPOLE XZ¶. SCF QUADRUPOLE YY¶. SCF QUADRUPOLE YZ¶. SCF QUADRUPOLE ZZ¶; The six components of the SCF quadrupole [Debye Ang]. SCF TOTAL ENERGY¶; The total electronic energy [H] of the SCF stage of the calculation.; The CORRELATION ENERGY variables from subsequent stages of a; calculation are often the corresponding TOTAL ENERGY; variables less this quantity. Constructed from Eq. (4),; where this quantity is . (4); Unless the method includes a dispersion correction, this quantity is; equal to HF TOTAL ENERGY (for HF) or; DFT FUNCTIONAL TOTAL ENERGY (for; DFT). Unless the method is a DFT dou",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/glossary_psivariables-1.html:14656,energy,energy,14656,psi4manual/4.0b4/glossary_psivariables-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/glossary_psivariables-1.html,4,['energy'],['energy']
Energy Efficiency,"ants are; available only through the DFTD3 or DFTD4 programs. Once installed, the; dftd3/PSI4 and dftd4/PSI4 interfaces are transparent, and all corrections are; interfaced exactly alike.; The -D3 interface can use classic or simple-dftd3 programs interchangeably and will prefer the latter.; Starting in v1.9, the classic program is no longer supported or tested, though it isn’t deliberately disabled.; Despite different defaults in these programs when run independently,; when run through PSI4 as EmpiricalDispersion engine, each should; produce the same result. Moreover, PSI4‘s own defaults and aliases; are unchanged by the new engines, so -D continues to mean -D2,; -D3 continues to mean zero-damping without 3-body correction,; and input files should continue producing the same results. Please file; an issue if found otherwise.; Dispersion corrections are built into DFT functionals, so appending an a; posteriori correction to a computation is as simple as; energy('b2plyp-d') vs. energy('b2plyp'). For example, the; following input file computes (with much redundant work) for water a; B3LYP, a B3LYP-D2, a B3LYP-D3 (zero-damping), and a B3LYP-D4 (Becke-Johnson damping) energy.; molecule h2o {; O; H 1 1.0; H 1 1.0 2 104.5; }; set {; basis cc-pVDZ; }; energy('b3lyp'); energy('b3lyp-d'); energy('b3lyp-d3'); energy('b3lyp-d4'). Consult the table -D Functionals to see for each; functional what corrections are available and what default parameters; define them. The dispersion correction is available after a calculation in; the PSI variable DISPERSION CORRECTION ENERGY.; By default, the output from the dftd3; program is suppressed; to see it in the output file, set print > 2.; No text output is available from the dftd4 or s-dftd3 programs. Variants of dispersion corrections¶. Extension [1] and Aliases; Variant; Computing Program (engine); DFT_DISPERSION_PARAMETERS [11]. -D; alias to -D2. -D1; -D1 [2]; PSI4‘s libdisp; [\(s_6\)]. -D2; -D2 [3]; PSI4‘s libdisp OR dftd3; [\(s_6\), \",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/dftd3.html:7239,energy,energy,7239,psi4manual/1.9.x/dftd3.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/dftd3.html,2,['energy'],['energy']
Energy Efficiency,"ants.hartree2kcalmol; print("" {:3.1f} {:1.6f}"".format(R, e)). # Prints to output.dat; psi4.core.print_out(""CP-corrected CCSD(T)/aug-cc-pVDZ Interaction Energies\n\n""); psi4.core.print_out("" R [Ang] E_int [kcal/mol] \n""); psi4.core.print_out(""---------------------------------------------------------\n""); for R in Rvals:; e = ecp[R] * psi4.constants.hartree2kcalmol; psi4.core.print_out("" {:3.1f} {:1.6f}\n"".format(R, e)). CP-corrected CCSD(T)/aug-cc-pVDZ Interaction Energies. R [Ang] E_int [kcal/mol]; ---------------------------------------------------------; 2.5 0.758605; 3.0 0.015968; 4.0 -0.016215. First, you can see the geometry string ne2_geometry has a two dashes to separate the monomers from each other. Also note we’ve used a Z-matrix to specify the geometry, and we’ve used a variable (R) as the interatomic distance. We have not specified the value of R in the ne2_geometry string like we normally would. That’s because we are going to vary it during the scan across the potential energy surface, by using a Python loop over the list of interatomic distances Rvals.; Before we are able to pass our molecule to Psi4, we need to do two things. First, we must set the value of the intermolecular separation in our Z-matrix (by using Python 3 string formatting) to the particular value of R. Second, we need to turn the Z-matrix string into a Psi4 molecule, by passing it to `psi4.geometry() <http://psicode.org/psi4manual/master/api/psi4.driver.geometry.html#psi4.driver.geometry>`__. The; argument bsse_type='cp' tells Psi4 to perform counterpoise (CP) correction on the dimer to compute the CCSD(T)/aug-cc-pVDZ interaction energy, which is stored in our ecp dictionary at each iteration of our Python loop. Note that we didn’t need to specify ghost atoms, and we didn’t need to call the monomer and dimer computations separately. Psi4 does it all for us, automatically.; Near the very end of the output file output.dat, the counterpoise correction Python function will print a nice summ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/psiapi-1.html:20344,energy,energy,20344,psi4manual/1.3.2/psiapi-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/psiapi-1.html,11,['energy'],['energy']
Energy Efficiency,"ap between the right-hand coupled coupled cluster eigenvector and the; left-hand eigenvector from the coupled cluster lambda (response) equations. LOWDIN CHARGES¶; Property of partial atomic charges [e] by the method of Löwdin, (nat,). MAYER INDICES¶; Property of Mayer bond indices, (nat, nat). MBIS CHARGES¶. MBIS DIPOLES¶. MBIS OCTUPOLES¶. MBIS QUADRUPOLES¶; Per-atom charges [e], dipoles [e a0], quadrupoles [e a0^2], and octupoles [e a0^3]; resulting from partitioning the total electron density through the Minimal Basis; Iterative Stockholder (MBIS) Charge Partitioning Scheme. MBIS FREE ATOM n VOLUME¶; Free-atom volume [a0^3] for atom n, computed using the MBIS charge; partitioning scheme. Free atom densities are computed at the same; level of theory as the parent MBIS calculation, with UHF turned on; as needed. MBIS RADIAL MOMENTS <R^3>¶; Per-atom expectation value of r^3 [a0^3], equivalent to the volume; of the MBIS-partitioned density. MBIS VALENCE CHARGES¶; Per-atom valence charges [e] computed from an MBIS partitioned density. MBIS VALENCE WIDTHS¶; Per-atom density width [a0] of the associated valence charge computed; from an MBIS partitioned density. Equivalent to the inverse of the; linear decay rate of the atomic density. MBIS VOLUME RATIOS¶; Per-atom ratio between the atomic volume (<R^3>) and the free-atomic; volume, unitless. MCSCF TOTAL ENERGY¶; Multiconfigurational self-consistent-field energy [E_h] in the course of; a configuration interaction computation. May be single-root or state-averaged. mtd DIPOLE¶; Dipole array [e a0] for the named method, (3,). mtd QUADRUPOLE¶; Redundant quadrupole array [e a0^2] for the named method, (3, 3). mtd OCTUPOLE¶; Redundant octupole array [e a0^3] for the named method, (3, 3, 3). mtd HEXADECAPOLE¶; Redundant hexadecapole array [e a0^4] for the named method, (3, 3, 3, 3). mtd 32-POLE¶; Redundant 32-pole array [e a0^5] for the named method, (3, 3, 3, 3, 3). mtd 64-POLE¶; Redundant 64-pole array [e a0^6] for the named m",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/glossary_psivariables.html:34811,charge,charges,34811,psi4manual/master/glossary_psivariables.html,https://psicode.org,https://psicode.org/psi4manual/master/glossary_psivariables.html,1,['charge'],['charges']
Energy Efficiency,"ap integrals: returns (3 * natoms) matrices. ao_potential(*args, **kwargs); Overloaded function. ao_pvp(self); AO pvp integrals. ao_quadrupole(self); Vector AO quadrupole integrals. ao_tei_deriv1(self, atom[, omega, factory]); Gradient of AO basis TEI integrals: returns (3 * natoms) matrices. ao_tei_deriv2(self, atom1, atom2); Hessian of AO basis TEI integrals: returns (3 * natoms)^2 matrices. ao_traceless_quadrupole(self); Vector AO traceless quadrupole integrals. basisset(self); Returns the basis set being used. cdsalcs(self, arg0, arg1, arg2); Returns a CdSalcList object. core_hamiltonian_grad(self, arg0); First nuclear derivative T + V + Perturb integrals. dipole_grad(self, arg0); First nuclear derivative dipole integrals. electric_field(self, origin[, deriv]); Vector electric field integrals. electric_field_value(self, arg0, arg1); Electric field expectation value at given sites. electrostatic_potential_value(self, charges, ...); Electrostatic potential values at given sites with associated charge, specified as an (n_sites, 4) matrix. f12_cgtg(self[, exponent]); F12 Fitted Slater Correlation Factor. factory(self); Returns the Matrix factory being used. induction_operator(self, arg0, arg1); Induction operator, formed by contracting electric field integrals with dipole moments at given coordinates (needed for EFP and PE). integral(self); Integral factory being used. integrals(self); Molecular integrals. integrals_erf(self[, w]); ERF integrals. integrals_erfc(self[, w]); ERFC integrals. kinetic_grad(self, arg0); First nuclear derivative kinetic integrals. mo_elec_dip_deriv1(self, atom, C1, C2); Gradient of MO basis electric dipole integrals: returns (3 * natoms) matrices. mo_erf_eri(self, omega, C1, C2, C3, C4); MO ERFC Omega Integrals. mo_eri(self, C1, C2, C3, C4); MO ERI Integrals. mo_f12(self, corr, C1, C2, C3, C4); MO F12 Integrals. mo_f12_double_commutator(self, corr, C1, C2, ...); MO F12 double commutator integrals. mo_f12_squared(self, corr, C1, C2, C3, C4);",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/api/psi4.core.MintsHelper.html:2859,charge,charge,2859,psi4manual/1.7.x/api/psi4.core.MintsHelper.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.MintsHelper.html,6,['charge'],['charge']
Energy Efficiency,"ap; Finite difference of energies frequency, run in sow/reap mode. fnocc3; Test FNO-QCISD(T) computation. tu4-h2o-freq; Frequencies for H2O HF/cc-pVDZ at optimized geometry. dcft3; DC-06 calculation for the He dimer. This performs a simultaneous update of the orbitals and cumulant, using DIIS extrapolation. Four-virtual integrals are handled in the AO Basis, using integrals stored on disk. cc4a; RHF-CCSD(T) cc-pVQZ frozen-core energy of the BH molecule, with Cartesian input. This version tests the FROZEN_DOCC option explicitly. cisd-h2o+-1; 6-31G** H2O+ Test CISD Energy Point. dft-psivar; HF and DFT variants single-points on zmat methane, mostly to test that PSI variables are set and computed correctly. pywrap-alias; Test parsed and exotic calls to energy() like zapt4, mp2.5, and cisd are working. cc8b; ROHF-CCSD cc-pVDZ frozen-core energy for the state of the CN radical, with Cartesian input. mints3; Test individual integral objects for correctness. omp3-2; OMP3 cc-pVDZ energy with ROHF initial guess for the NO radical. cc2; 6-31G** H2O CCSD optimization by energies, with Z-Matrix input. pywrap-checkrun-convcrit; Advanced python example sets different sets of scf/post-scf conv crit and check to be sure computation has actually converged to the expected accuracy. cepa0-grad2; CEPA cc-pVDZ gradient for the NO radical. cc45; RHF-EOM-CC2/cc-pVDZ lowest two states of each symmetry of H2O. fci-tdm-2; BH-H2+ FCI/cc-pVDZ Transition Dipole Moment. psimrcc-ccsd_t-2; Mk-MRCCSD(T) single point. CH2 state described using the Ms = 0 component of the singlet. Uses RHF singlet orbitals. sad1; Test of the superposition of atomic densities (SAD) guess, using a highly distorted water geometry with a cc-pVDZ basis set. This is just a test of the code and the user need only specify guess=sad to the SCF module’s (or global) options in order to use a SAD guess. The test is first performed in C2v symmetry, and then in C1. psimrcc-fd-freq1; Mk-MRCCSD single point. O2 state described using ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/autodoc_testsuite-1.html:14376,energy,energy,14376,psi4manual/4.0b5/autodoc_testsuite-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodoc_testsuite-1.html,4,['energy'],['energy']
Energy Efficiency,"apolation scheme for correlation energies with two adjacent zeta-level bases.; Used by cbs(). Parameters. functionname (str) – Name of the CBS component.; zLO (int) – Lower zeta level.; valueLO (float) – Lower value used for extrapolation.; zHI (int) – Higher zeta level. Should be equal to zLO + 1.; valueHI (float) – Higher value used for extrapolation.; alpha (Optional[float]) – Overrides the default \(\alpha = 3.0\); verbose (bool) – . Returns; Returns \(E_{total}^{\infty}\), see below. Return type; float. Notes; The extrapolation is calculated according to 5:; \(E_{corl}^X = E_{corl}^{\infty} + \beta X^{-alpha}\); References. 5; Halkier, Helgaker, Jorgensen, Klopper, Koch, Olsen, & Wilson,; Chem. Phys. Lett. 286 (1998) 243-252,; DOI: 10.1016/S0009-2614(99)00179-7. psi4.driver.driver_cbs._get_default_xtpl(nbasis, xtpl_type)[source]¶; A helper function to determine default extrapolation type. Parameters. nbasis (int) – Number of basis sets; xtpl_type (str) – {‘scf’, ‘corl’}; Extrapolation type: ‘scf’ for the total energy, ‘corl’ for just the; correlation component. Returns; Extrapolation function to be used. Return type; Callable. Aliases¶; When a particular composite method or its functional form is going to be; reused often, it is convenient to define an alias to it. A convenient; place for such Python code to reside is in psi4/psi4/driver/aliases.py; (source location) or psi4/lib/psi4/driver/aliases.py (installed; location). No recompilation is necessary after defining an alias. Some; existing examples are below. psi4.driver.aliases.sherrill_gold_standard(func, label, **kwargs)[source]¶; Function to call the quantum chemical method known as ‘Gold Standard’; in the Sherrill group. Uses cbs() to evaluate; the following expression. Two-point extrapolation of the correlation energy; performed according to corl_xtpl_helgaker_2(). \[E_{total}^{\text{Au\_std}} = E_{total,\; \text{SCF}}^{\text{aug-cc-pVQZ}} \; + E_{corl,\; \text{MP2}}^{\text{aug-cc-pV[TQ]Z}} \; + \delta",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/cbs-1.html:25759,energy,energy,25759,psi4manual/1.4.0/cbs-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/cbs-1.html,4,['energy'],['energy']
Energy Efficiency,"appended to an underlying functional; when a DFT-D method is requested. Quantity ; in Eqs. (1) and (2). (1). FCI TOTAL ENERGY¶. FCI CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the full configuration interaction level of theory. LCC2 (+LMP2) TOTAL ENERGY¶; The total electronic energy [H] for the local CC2 level of theory. LCCSD (+LMP2) TOTAL ENERGY¶; The total electronic energy [H] for the local CCSD level of theory. MP2 TOTAL ENERGY¶. MP2 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the MP2 level of theory. MP2.5 TOTAL ENERGY¶. MP2.5 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the MP2.5 level of theory. MP3 TOTAL ENERGY¶. MP3 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the MP3 level of theory. MPn TOTAL ENERGY¶. MPn CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the labeled Möller–Plesset perturbation theory level.; n is MP perturbation order. NUCLEAR REPULSION ENERGY¶; The nuclear repulsion energy contribution [H] to the total SCF energy.; Quantity in Eq. (2). ONE-ELECTRON ENERGY¶; The one-electron energy contribution [H] to the total SCF energy.; Quantity in Eq. (2). SAPT DISP ENERGY¶. SAPT ELST ENERGY¶. SAPT EXCH ENERGY¶. SAPT IND ENERGY¶; Respectively, the dispersion, electrostatics, exchange, and induction; components of the total electronic interaction energy [H] for the the; requested SAPT level of theory. The sum of these four components yields; SAPT ENERGY. SAPT ENERGY¶; The total electronic interaction energy [H] for the requested SAPT; level of theory. SAPT SAPT0 ENERGY¶. SAPT SAPT2 ENERGY¶. SAPT SAPT2+ ENERGY¶. SAPT SAPT2+(3) ENERGY¶. SAPT SAPT2+3 ENERGY¶; The total electronic interaction energy [H] for the labeled SAPT level; of theory. SCF TOTAL ENERGY¶; The total electronic energy [H] of the SCF stage of t",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/glossary_psivariables-1.html:7357,energy,energy,7357,psi4manual/4.0b2/glossary_psivariables-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/glossary_psivariables-1.html,4,['energy'],['energy']
Energy Efficiency,"appers” available in Psi4 are; _nbody_gufunc(),; database(), and; complete_basis_set(); read their respective sections; for details, but an overview is provided here. _nbody_gufunc(); computes the interaction energy of a bimolecular complex (counterpoise-corrected,; not, or both).; molecule dimer {; Ne; --; Ne 1 R; symmetry c1; }. Rvals=[2.5, 3.0, 4.0]; set basis aug-cc-pVDZ. for R in Rvals:; dimer.R = R; ecp = cp('c4-mp2'); print_stdout('R [A] = %.1f IE [kcal/mol] = %.3f\n' % (R, psi_hartree2kcalmol * ecp)). yields; R [A] = 2.5 IE [kcal/mol] = 0.804; R [A] = 3.0 IE [kcal/mol] = 0.030; R [A] = 4.0 IE [kcal/mol] = -0.014. Next, the database() wrapper allows any computational; model chemistry to be applied a predefined collection of molecules. Thus; an input; set {; basis jun-cc-pvdz; d_convergence 9; }. database('c4-mp2','nbc10',cp='on',subset='MeMe'). yields the counterpoise-corrected interaction energy for several points; along the dissociation curve of methane dimer, which is a member of the; NBC10 database:; //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>//; // Database nbc10 Results //; //<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<//. For each VARIABLE requested by tabulate, a 'Reaction Value' will be formed from; 'Reagent' values according to weightings 'Wt', as for the REQUESTED ENERGY below.; Depending on the nature of the variable, this may or may not make any physical sense. ==> Requested Energy <==. ----------------------------------------------------------------------------------------------; Reaction Reaction Energy Error Reagent 1 Reagent 2; Ref Calc [kcal/mol] [H] Wt [H] Wt; ----------------------------------------------------------------------------------------------; NBC1-MeMe-3.2 0.0690 1.1639 1.0949 -80.72700202 1 -40.36442840 -2; NBC1-MeMe-3.3 -0.2390 0.6709 0.9099 -80.72764911 1 -40.36435916 -2; NBC1-MeMe-3.4 -0.4170 0.3407 0.7577 -80.72806043 1 -40.36430165 -2; NBC1-MeMe-3.5 -0.5080 0.1244 0.6324 -80.72831099 1 -40.36425461 -2; NBC1-MeMe-3.6 -0.5410 -0.0129 0.5281",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/cfour-1.html:13533,energy,energy,13533,psi4manual/1.0.0/cfour-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/cfour-1.html,2,['energy'],['energy']
Energy Efficiency,"approximate N-representability conditions derived from; second-order perturbation theory and differ in the description of the; correlated (non-idempotent) part \(\boldsymbol{\tau}\) of the one-particle density; matrix and orbital optimization. While in the DC-06 and ODC-06 methods \(\boldsymbol{\tau}\) is derived from the density cumulant; in an approximate way (labelled by ‘06’), the DC-12 and ODC-12 methods derive this contribution exactly, and; take full advantage of the N-representability conditions (which is denoted by ‘12’). The corresponding DC and ODC methods; have similar description of the \(\boldsymbol{\gamma_1}\) N-representability, but differ in describing the orbital relaxation:; the former methods account for the relaxation only partially, while the latter fully relax the orbitals.; Both DC-06 and DC-12 methods have similar computational cost, same is true when comparing ODC-06 and ODC-12.; Meanwhile, the DC methods are generally more efficient than their ODC analogs, due to a more expensive orbital update step; needed for the full orbital optimization. In the ODC-13 method, the third- and; fourth-order N-representability conditions are used for the density cumulant; and the correlated contribution \(\boldsymbol{\tau}\), respectively,; and the orbitals are variationally optimized.; For most of the applications, it is recommended to use the ODC-12 method, which; provides an optimal balance between accuracy and efficiency, especially for; molecules with open-shell character. If highly accurate results are desired, a; combination of the ODC-13 method with a three-particle energy correction; [\(\mbox{ODC-13$(\lambda_3)$}\)] can be used (see below).; For the detailed comparison of the quality of these methods we refer; users to our publications.; The DCFT functional can be specified by the DCFT_FUNCTIONAL option. The; default choice is the ODC-12 functional. In addition to five methods listed; above, DCFT_FUNCTIONAL option can be set to CEPA0 (coupled elect",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/dcft-1.html:5733,efficient,efficient,5733,psi4manual/1.2.1/dcft-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/dcft-1.html,6,['efficient'],['efficient']
Energy Efficiency,"approximate N-representability conditions derived from; second-order perturbation theory and differ in the description of the; correlated (non-idempotent) part \(\boldsymbol{\tau}\) of the one-particle density; matrix and orbital optimization. While in the DC-06 and ODC-06 methods \(\boldsymbol{\tau}\) is derived from the density cumulant; in an approximate way (labelled by ‘06’), the DC-12 and ODC-12 methods derive this contribution exactly, and; take full advantage of the N-representability conditions (which is denoted by ‘12’). The corresponding DC and ODC methods; have similar description of the \(\boldsymbol{\gamma_1}\) N-representability, but differ in describing the orbital relaxation:; the former methods account for the relaxation only partially, while the latter fully relax the orbitals.; Both DC-06 and DC-12 methods have similar computational cost, same is true when comparing ODC-06 and ODC-12.; Meanwhile, the DC methods are generally more efficient than their ODC analogs, due to a more expensive orbital update step; needed for the full orbital optimization. In the ODC-13 method, the third- and; fourth-order N-representability conditions are used for the density cumulant; and the correlated contribution \(\boldsymbol{\tau}\), respectively,; and the orbitals are variationally optimized.; For most of the applications, it is recommended to use the ODC-12 method, which; provides an optimal balance between accuracy and efficiency, especially for; molecules with open-shell character. If highly accurate results are desired, a; combination of the ODC-13 method with a three-particle energy correction; [\(\mbox{ODC-13$(\lambda_3)$}\)] can be used (see below).; For the detailed comparison of the quality of these methods, we refer; users to our publications.; The DCT functional can be specified by the DCT_FUNCTIONAL option. The; default choice is the ODC-12 functional. The DCT code can also be used to; compute the \((\lambda_3)\) energy correction that perturbatively a",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/dct-1.html:5717,efficient,efficient,5717,psi4manual/1.4.0/dct-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/dct-1.html,9,['efficient'],['efficient']
Energy Efficiency,"apt1 for full details. sapt5; SAPT0 aug-cc-pVTZ computation of the charge transfer energy of the water dimer. omp2p5-grad2; OMP2.5 cc-pVDZ gradient for the NO radical. cc9; UHF-CCSD(T) cc-pVDZ frozen-core energy for the \(^2\Sigma^+\) state of the CN radical, with Z-matrix input. mcscf1; ROHF 6-31G** energy of the \(^{3}B_1\) state of CH2, with Z-matrix input. The occupations are specified explicitly. dfcasscf-fzc-sp; CASSCF/6-31G** energy point. mp2p5-grad2; MP2.5 cc-pVDZ gradient for the NO radical. pywrap-basis; SAPT calculation on bimolecular complex where monomers are unspecified so driver auto-fragments it. Basis set and auxiliary basis sets are assigned by atom type. cepa1; cc-pvdz H2O Test CEPA(1) Energy. dft-psivar; HF and DFT variants single-points on zmat methane, mostly to test that PSI variables are set and computed correctly. Now also testing that CSX harvesting PSI variables correctly update ref_dft_2e/xc due to new BraggSlater radii. ghosts; Density fitted MP2 cc-PVDZ/cc-pVDZ-RI computation of formic acid dimer binding energy using explicit specification of ghost atoms. This is equivalent to the dfmp2_1 sample but uses both (equivalent) specifications of ghost atoms in a manual counterpoise correction. nbody-hessian; Computation of VMFC-corrected HF dimer Hessian. castup3; SCF with various combinations of pk/density-fitting, castup/no-castup, and spherical/cartesian settings. Demonstrates that puream setting is getting set by orbital basis for all df/castup parts of calc. Demonstrates that answer doesn’t depend on presence/absence of castup. Demonstrates (by comparison to castup2) that output file doesn’t depend on options (scf_type) being set global or local. This input uses local. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. Appendices; Test Suite and Sample Inputs. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/testsuite.html:48795,energy,energy,48795,psi4manual/1.8.x/testsuite.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/testsuite.html,1,['energy'],['energy']
Energy Efficiency,"apt8; SAPT0(ROHF) open-shell computation of CN - Ne interaction energy First with jun-cc-pVDZ and density fitted integrals with ROHF Then with cc-pVDZ and direct integrals, except for dispersion that is computed with cc-pVDZ-ri density fitting with ROHF. fnocc4; Test FNO-DF-CCSD(T) energy. cdremp-1; Cholesky decomposed REMP/cc-pVDZ energies for the CO2 molecule. opt13; B3LYP cc-pVDZ geometry optimzation of phenylacetylene, starting from not quite linear structure updated reference due to new BraggSlater radii. olccd2; OLCCD cc-pVDZ energy with B3LYP initial guess for the NO radical. scf-uhf-grad-nobeta; UHF gradient for a one-electron system (no beta electrons). dfccsdt1; DF-CCSD(T) cc-pVDZ energy for the H2O molecule. pywrap-align-chiral; testing aligner on enantiomers based on Table 1 of 10.1021/ci100219f aka J Chem Inf Model 2010 50(12) 2129-2140. dft-grad-disk; A range-seperated gradient for SO2 to test disk algorithms by explicitly setting low memory. cc5; RHF CCSD(T) cc-pVDZ frozen-core energy of C4NH4 Anion. cc35; CC3(ROHF)/cc-pVDZ H2O \(R_e\) geom from Olsen et al., JCP 104, 8007 (1996). omp3-4; SCS-OMP3 cc-pVDZ geometry optimization for the H2O molecule. scf-ecp2; Water-Argon complex with ECP present; check of RHF Hessian. cbs-xtpl-gradient; Various gradients for a strained helium dimer and water molecule. scf-response1; Compute the dipole, quadrupole, and traceless quadrupoles for water. dfomp3-grad2; DF-OMP3 cc-pVDZ gradients for the H2O+ cation. cdomp2-1; OMP2 cc-pVDZ energy for the H2O molecule. cc4; RHF-CCSD(T) cc-pVQZ frozen-core energy of the BH molecule, with Cartesian input. After the computation, the checkpoint file is renamed, using the PSIO handler. dct7; DCT calculation for the triplet O2 using ODC-06 and ODC-12 functionals. Only simultaneous algorithm is tested. sad1; Test of the superposition of atomic densities (SAD) guess, using a highly distorted water geometry with a cc-pVDZ basis set. This is just a test of the code and the user need onl",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/autodoc_testsuite_corepsi4.html:32509,energy,energy,32509,psi4manual/1.8.x/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/autodoc_testsuite_corepsi4.html,2,['energy'],['energy']
Energy Efficiency,"apt_basis='monomer'). This procedure leads to faster compuations, but it converges more slowly; towards the complete basis set limit than the default procedure, which uses; the dimer-centered basis set. Hence, monomer-centered basis SAPT; computations are not recommended. The open-shell SAPT0 code is not; compatible yet with monomer-centered computations. Interpreting SAPT Results¶; We will examine the results of a SAPT2+3/aug-cc-pVDZ computation on the; water dimer. This computation can be performed with the following; input:; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19; 20; 21; 22; 23; 24; 25; 26molecule water_dimer {; 0 1; O -1.551007 -0.114520 0.000000; H -1.934259 0.762503 0.000000; H -0.599677 0.040712 0.000000; --; 0 1; O 1.350625 0.111469 0.000000; H 1.680398 -0.373741 -0.758561; H 1.680398 -0.373741 0.758561; units angstrom; }. set globals {; basis aug-cc-pvdz; guess sad; scf_type df; }. set sapt {; print 1; nat_orbs_t2 true; freeze_core true; }. energy('sapt2+3'). To reiterate some of the options mentioned above: the; NAT_ORBS_T2 option will compute MP2 natural orbitals and use; them in the evaluation of the triples correction to dispersion, and the; FREEZE_CORE option will freeze the core throughout the SAPT; computation. This SAPT2+3/aug-cc-pVDZ computation produces the following; results:; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19; 20; 21; 22; 23; 24; 25; 26; 27; 28; 29; 30; 31; 32; 33; 34; 35; 36; 37; 38; 39; 40; 41; 42; 43; 44; 45; 46; 47; 48; 49 SAPT Results; --------------------------------------------------------------------------------------------------------; Electrostatics -13.06509118 [mEh] -8.19846883 [kcal/mol] -34.30239689 [kJ/mol]; Elst10,r -13.37542977 [mEh] -8.39320925 [kcal/mol] -35.11719087 [kJ/mol]; Elst12,r 0.04490350 [mEh] 0.02817737 [kcal/mol] 0.11789413 [kJ/mol]; Elst13,r 0.26543510 [mEh] 0.16656305 [kcal/mol] 0.69689985 [kJ/mol]. Exchange 13.41768202 [mEh] 8.41972294 [kcal/mol] 35.22812",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/sapt-1.html:27272,energy,energy,27272,psi4manual/1.1.0/sapt-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/sapt-1.html,2,['energy'],['energy']
Energy Efficiency,"aptd-terms; F-SAPT0/jun-cc-pvdz procedure for methane dimer. cc4a; RHF-CCSD(T) cc-pVQZ frozen-core energy of the BH molecule, with Cartesian input. This version tests the FROZEN_DOCC option explicitly. sapt-exch-disp-inf; SAPT0 with S^inf exch-disp20. pywrap-opt-sowreap; Finite difference optimization, run in sow/reap mode. tu1-h2o-energy; Sample HF/cc-pVDZ H2O computation. mbis-5; MBIS calculation on ZnO. mbis-2; MBIS calculation on OH- (Expanded Arrays). nbody-he-cluster; MP2/aug-cc-pv[DT]Z many body energies of an arbitrary Helium complex Size vs cost tradeoff is rough here. pywrap-basis; SAPT calculation on bimolecular complex where monomers are unspecified so driver auto-fragments it. Basis set and auxiliary basis sets are assigned by atom type. mp2-property; MP2 cc-pvDZ properties for Nitrogen oxide. dft-freq-analytic; Analytic SVWN frequencies, compared to finite difference values. cc10; ROHF-CCSD cc-pVDZ energy for the \(^2\Sigma^+\) state of the CN radical. casscf-sp; CASSCF/6-31G** energy point. extern3; External potential calculation with one Ghost atom and one point charge at the same position. mints10; H2 with tiny basis set, to test basis set parser’s handling of integers. omp2-5; SOS-OMP2 cc-pVDZ geometry optimization for the H2O molecule. pywrap-db3; Test that Python Molecule class processes geometry like psi4 Molecule class. tu2-ch2-energy; Sample UHF/6-31G** CH2 computation. dft-ghost; DFT Functional Test for Range-Seperated Hybrids and Ghost atoms. tu6-cp-ne2; Example potential energy surface scan and CP-correction for Ne2. dft-omega; Test omega is setable updated wb97x_20,wb97x_03 to account for new BraggSlater radii. fd-freq-gradient-large; SCF DZ finite difference frequencies by gradients for C4NH4. mints12; test roundtrip-ness of dict repr for psi4.core.Molecule and qcdb.Molecule. cc49; EOM-CC3(UHF) on CH radical with user-specified basis and properties for particular root. dct-grad1; Various DCT analytic gradients for the O2 molecule with 6-3",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/autodoc_testsuite_corepsi4-1.html:7520,energy,energy,7520,psi4manual/1.4.0/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodoc_testsuite_corepsi4-1.html,4,['energy'],['energy']
Energy Efficiency,"aptd_name == ""FISAPT0""). from .proc import build_disp_functor; _, _disp_functor = build_disp_functor('hf-' + disp_name, restricted=True, save_pairwise_disp=save_pair, **kwargs). ## Dimer dispersion; dimer_disp_energy = _disp_functor.compute_energy(dimer_wfn.molecule(), dimer_wfn); ## Monomer dispersion; mon_disp_energy = _disp_functor.compute_energy(monomerA); mon_disp_energy += _disp_functor.compute_energy(monomerB). disp_interaction_energy = dimer_disp_energy - mon_disp_energy; core.set_variable(saptd_name + ""-D DISP ENERGY"", disp_interaction_energy); core.set_variable(""SAPT DISP ENERGY"", disp_interaction_energy); core.set_variable(""DISPERSION CORRECTION ENERGY"", disp_interaction_energy); core.set_variable(saptd_name + ""DISPERSION CORRECTION ENERGY"", disp_interaction_energy). ## Set SAPT0-D3 variables; total = disp_interaction_energy; saptd_en = {}; saptd_en['DISP'] = disp_interaction_energy; for term in ['ELST', 'EXCH', 'IND']:; en = core.variable(' '.join([sapt0_name, term, 'ENERGY'])); saptd_en[term] = en; core.set_variable(' '.join([saptd_name + '-D', term, 'ENERGY']), en); core.set_variable(' '.join(['SAPT', term, 'ENERGY']), en); total += en. core.set_variable(saptd_name + '-D TOTAL ENERGY', total); core.set_variable('SAPT TOTAL ENERGY', total); core.set_variable('CURRENT ENERGY', total). ## Print Energy Summary; units = (1000.0, constants.hartree2kcalmol, constants.hartree2kJmol); core.print_out(f"" => {saptd_name +'-D'} Energy Summary <=\n""). core.print_out("" "" + ""-"" * 104 + ""\n""); core.print_out(; "" %-25s % 16.8f [mEh] % 16.8f [kcal/mol] % 16.8f [kJ/mol]\n"" %; (""Electrostatics"", saptd_en['ELST'] * units[0], saptd_en['ELST'] * units[1], saptd_en['ELST'] * units[2])); core.print_out("" %-25s % 16.8f [mEh] % 16.8f [kcal/mol] % 16.8f [kJ/mol]\n"" %; (""Exchange"", saptd_en['EXCH'] * units[0], saptd_en['EXCH'] * units[1], saptd_en['EXCH'] * units[2])); core.print_out("" %-25s % 16.8f [mEh] % 16.8f [kcal/mol] % 16.8f [kJ/mol]\n"" %; (""Induction"", saptd_en['IND'] * unit",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc_util.html:9680,ENERGY,ENERGY,9680,psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc_util.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc_util.html,3,['ENERGY'],['ENERGY']
Energy Efficiency,"ar charge; self.PYmolecular_charge = 0; # Whether the charge was given by the user UNUSED; self.PYcharge_specified = False; # The multiplicity (defined as 2Ms + 1); self.PYmultiplicity = 1; # Whether the multiplicity was specified by the user UNUSED; self.PYmultiplicity_specified = False; # The units used to define the geometry; self.PYunits = 'Angstrom'; # The conversion factor to take input units to Bohr; self.input_units_to_au = 1.0 / psi_bohr2angstroms. # <<< Coordinates >>>. # Atom info vector (no knowledge of dummy atoms); self.atoms = []; # Atom info vector (includes dummy atoms); self.full_atoms = []; # A list of all variables known, whether they have been set or not.; self.all_variables = []; # A listing of the variables used to define the geometries; self.geometry_variables = {}. # <<< Fragmentation >>>. # The list of atom ranges defining each fragment from parent molecule; self.fragments = []; # A list describing how to handle each fragment; self.fragment_types = []; # The charge of each fragment; self.fragment_charges = []; # The multiplicity of each fragment; self.fragment_multiplicities = []. # <<< Frame >>>. # Move to center of mass or not?; self.PYmove_to_com = True; # Reorient or not? UNUSED; self.PYfix_orientation = False; # Reinterpret the coord entries or not (Default is true, except for findif); self.PYreinterpret_coordentries = True; # Nilpotence boolean (flagged upon first determination of symmetry frame,; # reset each time a substantiative change is made); self.lock_frame = False. # <<< Symmetry >>>. # Point group to use with this molecule UNUSED; self.pg = None; # Full point group UNUSED; self.full_pg = 'PG_C1'; # n of the highest rotational axis Cn UNUSED; self.full_pg_n = 1; # Symmetry string from geometry specification; self.PYsymmetry_from_input = 'C1'; # Number of unique atoms; self.PYnunique = 0; # Number of equivalent atoms per unique atom (length nunique); self.nequiv = 0; # Equivalent atom mapping array; self.equiv = 0; # Atom to uni",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/_modules/qcdb/libmintsmolecule.html:2690,charge,charge,2690,psi4manual/4.0b3/_modules/qcdb/libmintsmolecule.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/_modules/qcdb/libmintsmolecule.html,4,['charge'],['charge']
Energy Efficiency,"ar potentials V and interaction energies. overlap(self); Build the overlap integrals S. partition(self); Partition the nuclei and electrons. print_header(self); Print header, bases, sizes, etc. print_trailer(self); Print SAPT results. raw_plot(self, arg0); Plot some analysis files. scalars(self); Return the interally computed scalars (not copied). scf(self); Solve the relaxed SCF equations for A0 and B0. sinf_disp(self, arg0, arg1, arg2); Computes the MP2-based DispE20 and Exch-DispE20 energy without S^2. unify(self); Produce unified matrices for A', B', and C'. unify_part2(self); Finish producing unified matrices for A', B', and C'. vectors(self); Return the interally computed vectors (not copied). Methods Documentation. coulomb(self: psi4.core.FISAPT) → None¶; Build the J/K potentials for C, D, and E. dHF(self: psi4.core.FISAPT) → None¶; SAPT0 delta HF. disp(self: psi4.core.FISAPT, arg0: Dict[str, psi4.core.Matrix], arg1: Dict[str, psi4.core.Vector], arg2: bool) → None¶; Computes the MP2-based DispE20 and Exch-DispE20 energy. do_cubes(self: psi4.core.FISAPT) → None¶; Prepare cube files for orbital/density pictures. elst(self: psi4.core.FISAPT) → None¶; SAPT0 electrostatics. exch(self: psi4.core.FISAPT) → None¶; SAPT0 exchange. fdisp(self: psi4.core.FISAPT) → None¶; F-SAPT0 dispersion. felst(self: psi4.core.FISAPT) → None¶; F-SAPT0 electrostatics. fexch(self: psi4.core.FISAPT) → None¶; F-SAPT0 exchange. find(self: psi4.core.FISAPT) → None¶; F-SAPT0 induction. flocalize(self: psi4.core.FISAPT) → None¶; F-SAPT0 localize. freeze_core(self: psi4.core.FISAPT) → None¶; Freeze the core orbitals. ind(self: psi4.core.FISAPT) → None¶; SAPT0 induction. kinetic(self: psi4.core.FISAPT) → None¶; Build the kinetic integrals T. localize(self: psi4.core.FISAPT) → None¶; Localize the active occupied orbitals via IBO2. matrices(self: psi4.core.FISAPT) → Dict[str, psi4.core.Matrix]¶; Return the interally computed matrices (not copied). molecule(self: psi4.core.FISAPT) → psi4.core.Molec",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/api/psi4.core.FISAPT.html:2057,energy,energy,2057,psi4manual/1.9.x/api/psi4.core.FISAPT.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.FISAPT.html,2,['energy'],['energy']
Energy Efficiency,"ar potentials V and interaction energies. overlap(self); Build the overlap integrals S. partition(self); Partition the nuclei and electrons. print_header(self); Print header, bases, sizes, etc. print_trailer(self); Print SAPT results. raw_plot(self, arg0); Plot some analysis files. scalars(self); Return the interally computed scalars (not copied). scf(self); Solve the relaxed SCF equations for A0 and B0. sinf_disp(self, arg0, arg1, arg2); Computes the MP2-based DispE20 and Exch-DispE20 energy without S^2. unify(self); Produce unified matrices for A', B', and C'. unify_part2(self); Finish producing unified matrices for A', B', and C'. vectors(self); Return the interally computed vectors (not copied). Methods Documentation. coulomb(self: psi4.core.FISAPT) → None¶; Build the J/K potentials for C, D, and E. dHF(self: psi4.core.FISAPT) → None¶; SAPT0 delta HF. disp(self: psi4.core.FISAPT, arg0: dict[str, psi4.core.Matrix], arg1: dict[str, psi4.core.Vector], arg2: bool) → None¶; Computes the MP2-based DispE20 and Exch-DispE20 energy. do_cubes(self: psi4.core.FISAPT) → None¶; Prepare cube files for orbital/density pictures. elst(self: psi4.core.FISAPT) → None¶; SAPT0 electrostatics. exch(self: psi4.core.FISAPT) → None¶; SAPT0 exchange. fdisp(self: psi4.core.FISAPT) → None¶; F-SAPT0 dispersion. felst(self: psi4.core.FISAPT) → None¶; F-SAPT0 electrostatics. fexch(self: psi4.core.FISAPT) → None¶; F-SAPT0 exchange. find(self: psi4.core.FISAPT) → None¶; F-SAPT0 induction. flocalize(self: psi4.core.FISAPT) → None¶; F-SAPT0 localize. freeze_core(self: psi4.core.FISAPT) → None¶; Freeze the core orbitals. ind(self: psi4.core.FISAPT) → None¶; SAPT0 induction. kinetic(self: psi4.core.FISAPT) → None¶; Build the kinetic integrals T. localize(self: psi4.core.FISAPT) → None¶; Localize the active occupied orbitals via IBO2. matrices(self: psi4.core.FISAPT) → dict[str, psi4.core.Matrix]¶; Return the interally computed matrices (not copied). molecule(self: psi4.core.FISAPT) → psi4.core.Molec",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/api/psi4.core.FISAPT.html:2064,energy,energy,2064,psi4manual/master/api/psi4.core.FISAPT.html,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.FISAPT.html,2,['energy'],['energy']
Energy Efficiency,"ar root. dct-grad1; Various DCT analytic gradients for the O2 molecule with 6-31G basis set. cbs-xtpl-dict; Extrapolated water energies. molden2; Test of the superposition of atomic densities (SAD) guess, using a highly distorted water geometry with a cc-pVDZ basis set. This is just a test of the code and the user need only specify guess=sad to the SCF module’s (or global) options in order to use a SAD guess. The test is first performed in C2v symmetry, and then in C1. cbs-delta-energy; Extrapolated energies with delta correction. sapt-dft1; SAPT(DFT) aug-cc-pVDZ interaction energy between Ne and Ar atoms. dfrasscf-sp; 6-31G** H2O Test RASSCF Energy Point will default to only singles and doubles in the active space. pywrap-db1; Database calculation, so no molecule section in input file. Portions of the full databases, restricted by subset keyword, are computed by sapt0 and dfmp2 methods. frac-ip-fitting; Omega optimization for LRC functional wB97 on water. dfccsdat1; DF-CCSD(AT) cc-pVDZ energy for the H2O molecule. dfomp2-grad1; DF-OMP2 cc-pVDZ gradients for the H2O molecule. tdscf-2; td-uhf test on triplet states of methylene (tda), wfn passing. opt6; Various constrained energy minimizations of HOOH with cc-pvdz RHF Internal-coordinate constraints in internal-coordinate optimizations. scf-freq1; Analytic vs. finite difference DF-SCF frequency test for water. cc51; EOM-CC3/cc-pVTZ on H2O. opt7; Various constrained energy minimizations of HOOH with cc-pvdz RHF. For “fixed” coordinates, the final value is provided by the user. nbody-freq; Vibrational and thermo analysis of water trimer (geometry from J. Chem. Theory Comput. 11, 2126-2136 (2015)). gibbs; Test Gibbs free energies at 298 K of N2, H2O, and CH4. mints5; Tests to determine full point group symmetry. Currently, these only matter for the rotational symmetry number in thermodynamic computations. stability2; ROHF stability analysis check for CN with cc-pVDZ. This test corresponds to the rohf-stab test from Psi3",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/autodoc_testsuite_corepsi4-1.html:9436,energy,energy,9436,psi4manual/1.4.0/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodoc_testsuite_corepsi4-1.html,4,['energy'],['energy']
Energy Efficiency,"ar:`CBS CORRELATION ENERGY <CBSCORRELATIONENERGY>`; * :psivar:`CURRENT ENERGY <CURRENTENERGY>`; * :psivar:`CURRENT REFERENCE ENERGY <CURRENTREFERENCEENERGY>`; * :psivar:`CURRENT CORRELATION ENERGY <CURRENTCORRELATIONENERGY>`. .. caution:: Some features are not yet implemented. Buy a developer a coffee. - No way to tell function to boost fitting basis size for all calculations. - No way to extrapolate def2 family basis sets. - Need to add more extrapolation schemes. As represented in the equation below, a CBS energy method is defined in several; sequential stages (scf, corl, delta, delta2, delta3, delta4, delta5) covering treatment; of the reference total energy, the correlation energy, a delta correction to the; correlation energy, and a second delta correction, etc.. Each is activated by its; stage_wfn keyword and is only allowed if all preceding stages are active. .. include:: cbs_eqn.rst. * Energy Methods; The presence of a stage_wfn keyword is the indicator to incorporate; (and check for stage_basis and stage_scheme keywords) and compute; that stage in defining the CBS energy. The cbs() function requires, at a minimum, ``name='scf'`` and ``scf_basis``; keywords to be specified for reference-step only jobs and ``name`` and; ``corl_basis`` keywords for correlated jobs. The following energy methods have been set up for cbs(). .. hlist::; :columns: 5. * scf; * mp2; * mp2.5; * mp3; * mp4(sdq); * mp4; * mp\ *n*; * omp2; * omp2.5; * omp3; * olccd; * lccd; * lccsd; * cepa(0); * cepa(1); * cepa(3); * acpf; * aqcc; * qcisd; * cc2; * ccsd; * fno-ccsd; * bccd; * cc3; * qcisd(t); * ccsd(t); * fno-ccsd(t); * bccd(t); * cisd; * cisdt; * cisdtq; * ci\ *n*; * fci; * mrccsd; * mrccsd(t); * mrccsdt; * mrccsdt(q). :type name: string; :param name: ``'scf'`` || ``'ccsd'`` || etc. First argument, usually unlabeled. Indicates the computational method; for the correlation energy, unless only reference step to be performed,; in which case should be ``'scf'``. Overruled if stage_wfn keywor",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html:19178,energy,energy,19178,psi4manual/1.0.0/_modules/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html,1,['energy'],['energy']
Energy Efficiency,"ar_charge(self: psi4.core.Molecule) → int; Gets the molecular charge. move_to_com(self: psi4.core.Molecule) → None; Moves molecule to center of mass. multiplicity(self: psi4.core.Molecule) → int; Gets the multiplicity (defined as 2Ms + 1). nallatom(self: psi4.core.Molecule) → int; Number of real and dummy atoms. name(self: psi4.core.Molecule) → str; Gets molecule name. natom(self: psi4.core.Molecule) → int; Number of real atoms. nfragments(self: psi4.core.Molecule) → int; Gets the number of fragments in the molecule. nuclear_dipole(*args, **kwargs); Overloaded function. nuclear_dipole(self: psi4.core.Molecule, arg0: psi4.core.Vector3) -> psi4.core.Vector3. Gets the nuclear contribution to the dipole, withe respect to a specified origin. nuclear_dipole(self: psi4.core.Molecule) -> psi4.core.Vector3. Gets the nuclear contribution to the dipole, withe respect to the origin. nuclear_repulsion_energy(self: psi4.core.Molecule, dipole_field: List[float[3]]=[0.0, 0.0, 0.0]) → float; Computes nuclear repulsion energy. nuclear_repulsion_energy_deriv1(self: psi4.core.Molecule, arg0: List[float[3]]) → psi4.core.Matrix; Returns first derivative of nuclear repulsion energy as a matrix (natom, 3). nuclear_repulsion_energy_deriv2(self: psi4.core.Molecule) → psi4.core.Matrix; Returns second derivative of nuclear repulsion energy as a matrix (natom X 3, natom X 3). orientation_fixed(self: psi4.core.Molecule) → bool; Get whether or not orientation is fixed. point_group(self: psi4.core.Molecule) → psi4.core.PointGroup; Returns the current point group object. print_bond_angles(self: psi4.core.Molecule) → None; Print the bond angle geometrical parameters. print_cluster(self: psi4.core.Molecule) → None; Prints the molecule in Cartesians in input units adding fragment separators. print_distances(self: psi4.core.Molecule) → None; Print the interatomic distance geometrical parameters. print_in_input_format(self: psi4.core.Molecule) → None; Prints the molecule as Cartesian or ZMatrix entries, ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/api/psi4.core.molecule.html:45201,energy,energy,45201,psi4manual/1.2.1/api/psi4.core.molecule.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/api/psi4.core.molecule.html,1,['energy'],['energy']
Energy Efficiency,"aram filename: destination file name for file11 file. :param wfn: set of molecule, gradient from which to generate file11. :examples:. >>> # [1] file11 for CISD calculation; >>> G, wfn = gradient('cisd', return_wfn=True); >>> fake_file11(wfn, 'mycalc.11'). """"""; molecule = wfn.molecule(); molecule.update_geometry(); gradient = wfn.gradient(). with open(filename, 'w') as handle:; handle.write('%d\n' % (molecule.natom())). for at in range(molecule.natom()):; handle.write('%6s %16.8f %16.8f %16.8f\n' % (molecule.symbol(; at), molecule.x(at), molecule.y(at), molecule.z(at))). for at in range(molecule.natom()):; handle.write('%6s %16.8f %16.8f %16.8f\n' % (; '', gradient.get(at, 0), gradient.get(at, 1), gradient.get(at, 2))). [docs]; def sherrill_gold_standard(**kwargs) -> CBSMetadata:; r""""""Function to call the quantum chemical method known as 'Gold Standard'; in the Sherrill group. Uses the composite wrapper to evaluate; the following expression. Two-point extrapolation of the correlation energy; performed according to :py:func:`~psi4.driver.driver_cbs_helper.corl_xtpl_helgaker_2`. .. math:: E_{total}^{\text{Au\_std}} = E_{total,\; \text{SCF}}^{\text{aug-cc-pVQZ}} \; + E_{corl,\; \text{MP2}}^{\text{aug-cc-pV[TQ]Z}} \; + \delta_{\text{MP2}}^{\text{CCSD(T)}}\big\vert_{\text{aug-cc-pVTZ}}. >>> # [1] single-point energy by this composite method; >>> energy('sherrill_gold_standard'). >>> # [2] finite-difference geometry optimization; >>> optimize('sherrill_gold_standard'). >>> # [3] finite-difference geometry optimization, overwriting some pre-defined sherrill_gold_standard options; >>> optimize('sherrill_gold_standard', corl_basis='cc-pV[DT]Z', delta_basis='3-21g'). """"""; scf = {; 'wfn': 'hf',; 'basis': kwargs.pop('scf_basis', 'aug-cc-pVQZ'),; 'scheme': kwargs.pop('scf_scheme', 'xtpl_highest_1'),; 'options': kwargs.pop('scf_options', {}),; }; corl = {; 'wfn': kwargs.pop('corl_wfn', 'mp2'),; 'basis': kwargs.pop('corl_basis', 'aug-cc-pV[TQ]Z'),; 'scheme': kwargs.pop('corl_scheme",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/aliases.html:2948,energy,energy,2948,psi4manual/1.8.x/_modules/psi4/driver/aliases.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/aliases.html,6,['energy'],['energy']
Energy Efficiency,"arameters, updated parameters, and separate charge/multiplicity specifiers for each monomer. One-electron properties computed for dimer and one monomer. opt2; SCF DZ allene geometry optimization, with Cartesian input, first in c2v symmetry, then in Cs symmetry from a starting point with a non-linear central bond angle. dft1; DFT Functional Test all values update for new BraggSlater radii. fd-freq-energy; SCF STO-3G finite-difference frequencies from energies for H2O. cc-module; check that CC is returning the same values btwn CC*, FNOCC, and DFOCC modules. omp3-grad2; OMP3 cc-pVDZ gradient for the NO radical. scf2; RI-SCF cc-pVTZ energy of water, with Z-matrix input and cc-pVTZ-RI auxilliary basis. sapt9; usapt example with empty beta. nbody-multi-level; Multilevel computation of water trimer energy (geometry from J. Chem. Theory Comput. 11, 2126-2136 (2015)). pubchem1; Benzene vertical singlet-triplet energy difference computation, using the PubChem database to obtain the initial geometry, which is optimized at the HF/STO-3G level, before computing single point energies at the RHF, UHF and ROHF levels of theory. dft-jk; DFT JK on-disk test. omp2-2; OMP2 cc-pVDZ energy with ROHF initial guess orbitals for the NO radical. scf-response2; Compute the dipole polarizability for water with custom basis set. fcidump; test FCIDUMP functionality for rhf/uhf. pywrap-checkrun-rohf; This checks that all energy methods can run with a minimal input and set symmetry. fsapt-ext; Quick test of external potential in F-SAPT (see fsapt1 for a real example). psimrcc-fd-freq1; Mk-MRCCSD single point. \(^3 \Sigma ^-\) O2 state described using the Ms = 0 component of the triplet. Uses ROHF triplet orbitals. dft-grad-lr2; Tests CAM gradients with and without XC pieces to narrow grid error. dfomp2p5-grad2; DF-OMP2.5 cc-pVDZ gradients for the H2O+ cation. dft2; DFT Functional Test. fd-gradient; SCF STO-3G finite-difference tests. scf-hess3; CONV SCF 6-31G analytical vs finite-difference tests ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/autodoc_testsuite_corepsi4-1.html:26325,energy,energy,26325,psi4manual/1.4.0/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodoc_testsuite_corepsi4-1.html,4,['energy'],['energy']
Energy Efficiency,"arameters. adcc reports: ""; ""{}"".format(str(ex))); core.print_out(""\n""). # TODO Should a non-converged calculation throw?. #; # Interpret results; #; # Note: This wavefunction is not consistent ... the density; # is e.g. not the proper one (i.e. not the MP(n) one); adc_wfn = core.Wavefunction(ref_wfn.molecule(), ref_wfn.basisset()); adc_wfn.shallow_copy(ref_wfn); adc_wfn.set_reference_wavefunction(ref_wfn); adc_wfn.set_name(name); adc_wfn.set_module(""adcc""). # MP(3) energy for CVS-ADC(3) calculations is still a missing feature in adcc; # ... we store this variant here to be able to fall back to MP(2) energies.; is_cvs_adc3 = state.method.level >= 3 and state.ground_state.has_core_occupied_space. # Ground-state energies; mp = state.ground_state; mp_energy = mp.energy(state.method.level if not is_cvs_adc3 else 2); mp_corr = 0.0; if state.method.level > 1:; core.print_out(""Ground state energy breakdown:\n""); core.print_out("" Energy SCF {0:15.8g} [Eh]\n"".format(ref_wfn.energy())); for level in range(2, state.method.level + 1):; if level >= 3 and is_cvs_adc3:; continue; energy = mp.energy_correction(level); mp_corr += energy; adc_wfn.set_variable(f""MP{level} CORRELATION ENERGY"", energy); adc_wfn.set_variable(f""MP{level} TOTAL ENERGY"", mp.energy(level)); core.print_out(f"" Energy correlation MP{level} {energy:15.8g} [Eh]\n""); core.print_out("" Energy total {0:15.8g} [Eh]\n"".format(mp_energy)); adc_wfn.set_variable(""CURRENT CORRELATION ENERGY"", mp_corr) # P::e ADC; adc_wfn.set_variable(""CURRENT ENERGY"", mp_energy) # P::e ADC. # Set results of excited-states computation; # TODO Does not work: Can't use strings; # adc_wfn.set_variable(""excitation kind"", state.kind); adc_wfn.set_variable(""ADC ITERATIONS"", state.n_iter) # P::e ADC; adc_wfn.set_variable(name + "" excitation energies"",; core.Matrix.from_array(state.excitation_energy.reshape(-1, 1))); adc_wfn.set_variable(""number of excited states"", len(state.excitation_energy)). core.print_out(""\n\n ==> Excited states summary <== \",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html:115670,energy,energy,115670,psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,4,['energy'],['energy']
Energy Efficiency,"arate nbody_results dictionaries and processes them into a final return that; is a small subset of the table below. Return type:; nbody_results. ptype_size = (1,)/(nat, 3)/(3 * nat, 3 * nat)e/g/h := energy or gradient or Hessian; rtd := return_total_data. item; size; present / zeroed; contents / interpretation. ret_ptype; ptype_size; always. interaction data requested: IE or total (depending on return_total_data) e/g/h (depending on driver)with cp/nocp/vmfc treatment (depending on 1st of bsse_type). ret_energy; 1; always; interaction energy: IE or total (depending on return_total_data) w/ cp/nocp/vmfc treat. (dep. on 1st of bsse_type). ret_gradient; (nat, 3); when driver is g/h; interaction gradient: IE or total (depending on return_total_data) w/ cp/nocp/vmfc treat. (dep. on 1st of bsse_type. ret_hessian; (nat * 3, nat * 3); when driver is h; interaction Hessian: IE or total (depending on return_total_data) w/ cp/nocp/vmfc treat. (dep. on 1st of bsse_type). nbody; >=1; always; energy n-body QCVariables to be set.   CP-CORRECTED TOTAL ENERGY THROUGH 1-BODY;   1; when cp in bsse_type; MBE sum of subsystems of 1-body. summed are total energies with cp treatment.   CP-CORRECTED TOTAL ENERGY THROUGH 2-BODY;   1; when cp in bsse_type & max_nbody>=2; MBE sum of subsystems of 2-body or fewer (cumulative); summed are total energies with cp treatment.   CP-CORRECTED TOTAL ENERGY THROUGH {nb}-BODY;   1; when cp in bsse_type; MBE sum of subsystems of {max_nbody}-body or fewer (cumulative); summed are total energies w/ cp treatment.   CP-CORRECTED TOTAL ENERGY;   1; when cp in bsse_type & rtd=T; best available total energy with cp treatment: CP-CORRECTED TOTAL ENERGY THROUGH {max_nbody}-BODY.   CP-CORRECTED INTERACTION ENERGY THROUGH 2-BODY;   1; when cp in bsse_type & max_nbody>=2; 2-body total data less 1-body total data for cumulative IE; inputs are total energies with cp treatment.   CP-CORRECTED INTERACTION ENERGY THROUGH {nb}-BODY;   1; when cp in bsse_type; {max_nbody}-bo",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/nbody.html:19363,energy,energy,19363,psi4manual/1.7.x/nbody.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/nbody.html,4,['energy'],['energy']
Energy Efficiency,"are Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #; """"""Module with utility functions for use in input files."""""". __all__ = [; ""copy_file_to_scratch"",; ""copy_file_from_scratch"",; ""cubeprop"",; ""get_memory"",; ""oeprop"",; ""set_memory"",; ]. import os; import re; import sys; import warnings; from typing import List, Union. from psi4 import core; from psi4.driver.procrouting import *; from .exceptions import ValidationError; from .prop_util import *. [docs]def oeprop(wfn: core.Wavefunction, *args: List[str], **kwargs):; """"""Evaluate one-electron properties. :returns: None. :param wfn: set of molecule, basis, orbitals from which to compute properties. :param args:. Arbitrary-number of properties to be computed from *wfn*.; See :ref:`Available One-Electron Properties <table:oe_features>`. :type title: str; :param title: label prepended to all psivars computed. :examples:. >>> # [1] Moments with specific label; >>> E, wfn = energy('hf', return_wfn=True); >>> oeprop(wfn, 'DIPOLE', 'QUADRUPOLE', title='H3O+ SCF'). """"""; oe = core.OEProp(wfn); if 'title' in kwargs:; oe.set_title(kwargs['title']); for prop in args:; oe.add(prop); ; # If we're doing MBIS, we want the free-atom volumes; # in order to compute volume ratios,; # but only if we're calling oeprop as the whole molecule; free_atom = kwargs.get('free_atom',False); if ""MBIS_VOLUME_RATIOS"" in prop.upper() and not free_atom:; core.print_out("" Computing free-atom volumes\n""); free_atom_volumes(wfn) . oe.compute(). [docs]def cubeprop(wfn: core.Wavefunction, **kwargs):; """"""Evaluate properties on a grid and generate cube files. .. versionadded:: 0.5; *wfn* parameter passed explicitly. :returns: None. :param wfn: set of molecule, basis, orbitals from which to generate cube files. :examples:. >>> # [1] Cube files for all orbitals; >>> E, wfn = energy('b3lyp', return_wfn=True); >>> cubeprop(wfn). >>> # [2] Cube files for density (alpha, beta, total, spin) and four orbitals; >>> # ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/util.html:1978,energy,energy,1978,psi4manual/1.7.x/_modules/psi4/driver/p4util/util.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/util.html,2,['energy'],['energy']
Energy Efficiency,"are assigned by atom type. cc17; Single point energies of multiple excited states with EOM-CCSD. dfmp2-freq2; DF-MP2 frequency by difference of energies for H2O. castup3; SCF with various combinations of pk/density-fitting, castup/no-castup, and spherical/cartesian settings. Demonstrates that puream setting is getting set by orbital basis for all df/castup parts of calc. Demonstrates that answer doesn’t depend on presence/absence of castup. Demonstrates (by comparison to castup2) that output file doesn’t depend on options (scf_type) being set global or local. This input uses local. scf4; RHF cc-pVDZ energy for water, automatically scanning the symmetric stretch and bending coordinates using Python’s built-in loop mechanisms. The geometry is specified using a Z-matrix with variables that are updated during the potential energy surface scan, and then the same procedure is performed using polar coordinates, converted to Cartesian coordinates. cc15; RHF-B-CCD(T)/6-31G** H2O single-point energy (fzc, MO-basis \(\langle ab|cd \rangle\)). fnocc2; Test G2 method for H2O. opt4; SCF cc-pVTZ geometry optimzation, with Z-matrix input. dfmp2-grad1; DF-MP2 cc-pVDZ gradients for the H2O molecule. props4; Electrostatic potential and electric field evaluated on a grid around water. psimrcc-ccsd_t-2; Mk-MRCCSD(T) single point. \(^1A_1\) CH2 state described using the Ms = 0 component of the singlet. Uses RHF singlet orbitals. dft-grac; Gradient regularized asymptotic correction (GRAC) test. cbs-xtpl-freq; Various gradients for a strained helium dimer and water molecule. cisd-h2o-clpse; 6-31G** H2O Test CISD Energy Point with subspace collapse. rasci-h2o; RASCI/6-31G** H2O Energy Point. opt8; Various constrained energy minimizations of HOOH with cc-pvdz RHF. Cartesian-coordinate constrained optimizations of HOOH in Cartesians. dft-grad-disk; A range-seperated gradient for SO2 to test disk algorithms by explicitly setting low memory. opt6; Various constrained energy minimizations of HOO",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/autodoc_testsuite_corepsi4-1.html:30155,energy,energy,30155,psi4manual/1.3.2/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/autodoc_testsuite_corepsi4-1.html,4,['energy'],['energy']
Energy Efficiency,"are functionals with these extensions (e.g., wB97X-D) that,; not being Grimme corrections, won’t follow this table exactly. 2; [Grimme:2004:1463]. 3; [Grimme:2006:1787]. 4; [Grimme:2010:154104]. 5; [Grimme:2011:1456]. 6(1,2); [Smith:2016:2197]. 7; [Hujo:2011:3866]. 8; [Chai:2010:6615]. 9; [Pernal:2009:263201]. 10; [Podeszwa:2010:550]. 11; Keyword not used for user-defined functionals where the dft_dict[""dispersion""][""params""]; is easily editable for this purpose. See Advanced Functional Use and Manipulation. A few practical examples:. DFT-D2 single point with default parameters (dftd3 not called); energy('bp86-d'). DFT-D3BJ optimization with default parameters; optimize('pbe-d3bj'). DFT-D2 optimization with custom s6 parameter; set dft_dispersion_parameters [1.20]; optimize('b3lyp-d2'). DFT-D3ZERO single point (b3lyp) with custom s8 parameter (reset all four values); set dft_dispersion_parameters [1.0, 2.0, 1.261, 14.0]; energy('b3lyp-d3'). DFT-D2 single point with dftd3 instead of PSI4‘s libdisp; energy('pbe-d2', engine='dftd3'). If only dispersion corrections (rather than total energies) are of; interest, the dftd3 program can be run independently of the scf; through the python function run_dftd3(). (This function; is the same PSI4/dftd3 interface that is called during an scf job.); This route is much faster than running a DFT-D energy. Some set-up:; molecule nene {; Ne; Ne 1 2.0; }. nene.update_geometry(). The same four dispersion corrections/gradients as the section above:; >>> print nene.run_dftd3('bp86', 'd', dertype=0); -7.735e-05. >>> E, G = nene.run_dftd3('pbe', 'd3bj'); >>> print G; [[0.0, 0.0, -1.1809087569358e-05], [0.0, 0.0, 1.1809087569358e-05]]. >>> E, G = nene.run_dftd3('b3lyp', 'd2', {'s6': 1.20}); >>> print E; -8.84e-05. >>> E, G = nene.run_dftd3(dashlvl='d3', dashparam={'s8': 2.0, 'alpha6': 14.0, 'sr6': 1.261, 's6': 1.0}); >>> print E; -0.00024762. qcdb.Molecule.run_dftd3(self, func=None, dashlvl=None, dashparam=None, dertype=None, verbose=1)¶; Co",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/dftd3-1.html:8882,energy,energy,8882,psi4manual/1.4.0/dftd3-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/dftd3-1.html,2,['energy'],['energy']
Energy Efficiency,"are of the right size and checks that symmetry of the Molecule observes the basis assignment to atoms. dfccdl1; DF-CCDL cc-pVDZ energy for the H2O molecule. stability1; UHF->UHF stability analysis test for BH with cc-pVDZ Test direct SCF with and without symmetry, test PK without symmetry. ddd-function-kwargs; check distributed driver is correctly passing function kwargs. sapt-compare; SAPT0 aug-cc-pVDZ computation of the water-water interaction energy, using the three SAPT codes. mints3; Test individual integral objects for correctness. mcscf3; RHF 6-31G** energy of water, using the MCSCF module and Z-matrix input. sapt7; SAPT0 open-shell computation of H2O-HO2 interaction energy First with cc-pVDZ and density fitted integrals with UHF Then with 6-31g and direct integrals, except for dispersion that is computed with cc-pVDZ-ri density fitting with UHF. dft-grad-lr2; Tests CAM gradients with and without XC pieces to narrow grid error. pywrap-checkrun-rohf; This checks that all energy methods can run with a minimal input and set symmetry. cepa1; cc-pvdz H2O Test CEPA(1) Energy. dfcasscf-fzc-sp; CASSCF/6-31G** energy point. dft-grac; Gradient regularized asymptotic correction (GRAC) test. mbis-5; MBIS calculation on ZnO. soscf-large; Second-order SCF convergnece: Benzene. scf-property; UFH and B3LYP cc-pVQZ properties for the CH2 molecule. cc13c; Tests RHF CCSD(T)gradients. x2c-perturb-h; Test SFX2C-1e with a static electric field on He aug-cc-pVTZ. opt12; SCF cc-pVDZ geometry optimzation of ketene, starting from bent structure. cisd-sp-2; 6-31G** H2O Test CISD Energy Point. fsapt2; A very quick correctness test of F-SAPT (see fsapt1 for a real example). scf-dipder; Test SCF dipole derivatives against old Psi3 reference values. scf-uhf-grad-nobeta; UHF gradient for a one-electron system (no beta electrons). pywrap-align; apply linear fragmentation algorithm to a water cluster. dft-b2plyp; Double-hybrid density functional B2PYLP. Reproduces portion of Table I in S. Grim",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/autodoc_testsuite_corepsi4.html:36498,energy,energy,36498,psi4manual/1.9.x/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/autodoc_testsuite_corepsi4.html,2,['energy'],['energy']
Energy Efficiency,"are performed on vectors and matrices provided from the Psi library. cc36; CC2(RHF)/cc-pVDZ energy of H2O. castup2; SCF with various combinations of pk/density-fitting, castup/no-castup, and spherical/cartesian settings. Demonstrates that puream setting is getting set by orbital basis for all df/castup parts of calc. Demonstrates that answer doesn’t depend on presence/absence of castup. Demonstrates (by comparison to castup3) that output file doesn’t depend on options (scf_type) being set global or local. This input uses global. cc37; CC2(UHF)/cc-pVDZ energy of H2O+. omp2-1; OMP2 cc-pVDZ energy for the H2O molecule. psimrcc-ccsd_t-4; Mk-MRCCSD(T) single point. O$_3` state described using the Ms = 0 component of the singlet. Uses TCSCF orbitals. gibbs; Test Gibbs free energies at 298 K of N2, H2O, and CH4. dft-pbe0-2; Internal match to psi4, test to match to literature values in litref.in/litref.out. zaptn-nh2; ZAPT(n)/6-31G NH2 Energy Point, with n=2-25. cc5; RHF CCSD(T) aug-cc-pvtz frozen-core energy of C4NH4 Anion. mints1; Symmetry tests for a range of molecules. This doesn’t actually compute any energies, but serves as an example of the many ways to specify geometries in Psi4. props2; DF-SCF cc-pVDZ of benzene-hydronium ion, scanning the dissociation coordinate with Python’s built-in loop mechanism. The geometry is specified by a Z-matrix with dummy atoms, fixed parameters, updated parameters, and separate charge/multiplicity specifiers for each monomer. One-electron properties computed for dimer and one monomer. mints5; Tests to determine full point group symmetry. Currently, these only matter for the rotational symmetry number in thermodynamic computations. omp3-1; OMP3 cc-pVDZ energy for the H2O molecule. tu5-sapt; Example SAPT computation for ethene*ethine (i.e., ethylene*acetylene), test case 16 from the S22 database. dcft1; DCFT-06 calculation for the He dimer. This performs a simultaneous update of the orbitals and cumulant, using DIIS extrapolation. Four-",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/autodoc_testsuite-1.html:19466,energy,energy,19466,psi4manual/4.0b3/autodoc_testsuite-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodoc_testsuite-1.html,4,['energy'],['energy']
Energy Efficiency,"are should be taken to not turn MOM on; until the oscillatory behavior begins.; Damping [Off by Default]; In some cases, a static mixing of Fock Matrices from adjacent iterations can; quench oscillations. This mixing, known as “damping” can be activated by setting; the DAMPING_PERCENTAGE keyword to a nonzero percent. ERI Algorithms¶; The key difficulty in the SCF procedure is treatment of the four-index ERI; contributions to the Fock Matrix. A number of algorithms are available in; PSI4 for these terms. The algorithm is selected by the SCF_TYPE; keyword, which may be one of the following. PK [Default]; An out-of-core, presorted algorithm using exact ERIs. Quite fast; for a zero-error algorithm if enough memory is available. Integrals are; generated only once, and symmetry is utilized to reduce number of integrals.; OUT_OF_CORE; An out-of-core, unsorted algorithm using exact; ERIs. Overcomes the memory bottleneck of the current PK algorithm. Integrals are; generated only once, and symmetry is utilized to reduce number of integrals.; DIRECT; A threaded, sieved, integral-direct algorithm, with full permutational; symmetry. This algorithm is brand new, but seems to be reasonably fast up to; 1500 basis function, uses zero disk, and can obtain significant speedups with; negligible error loss if the INTS_TOLERANCE value is set to 1.0E-8 or so.; DF [Default]; A density-fitted algorithm designed for computations with thousands of basis; functions. This algorithm is highly optimized, and is threaded with a mixture of; parallel BLAS and OpenMP. Note that this algorithm should use the -JKFIT series; of auxiliary bases, not the -RI or -MP2FIT bases. The default guess for; auxiliary basis set should work for all Dunning bases, otherwise the; DF_BASIS_SCF keyword can be used to manually specify the auxiliary basis.; This algorithm is preferred unless either absolute accuracy is required; [CCSD(T)] or a -JKFIT auxiliary basis is unavailable for the; primary basis/atoms involved. Fo",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/scf-1.html:19043,reduce,reduce,19043,psi4manual/4.0b4/scf-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/scf-1.html,2,['reduce'],['reduce']
Energy Efficiency,"are unchanged beyond a prepended “cfour_”. (Though be aware that common; abbreviations like CALC and REF must be fully spelled out as; CFOUR_CALC_LEVEL and CFOUR_REFERENCE when used in; PSI4.); In limited trial cases, keywords nominally directed at non-Cfour modules; are translated into their Cfour counterparts. For example, setting; REFERENCE will appropriately set CFOUR_REFERENCE. For a; list of applicable keywords, see source of; qcdb.cfour.muster_psi4options().; Consult Functionality for information on what Cfour; functionality is accessible through PSI4. PSI4 for Cfour Users¶; In the simplest use of the Psi4/Cfour interface, a PSI4 input file; can simply “wrap” a ZMAT file and execute xcfour. This is; illustrated in the following example:; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17cfour {; UHF-SCF energy calculation; N; H 1 R; H 1 R 2 A. R=1.008; A=105.0. *ACES2(CALC=HF,BASIS=qz2p; MULT=2,REF=UHF; OCCUPATION=3-1-1-0/3-0-1-0; SCF_CONV=12; MEMORY=20000000); }. energy('cfour'). Here, the contents of the cfour {...} block are written directly to a; ZMAT file. This is joined by a default GENBAS file; (psi4/share/basis/GENBAS). To preferentially use your own GENBAS,; place it in PATH or PSIPATH. The line calling; energy() with argument 'cfour' invokes; xcfour.; After execution of the energy('cfour') line completes, Cfour results; are read back into PSI4 format and are thereafter accessible for; further processing in the input file. See Output for; details. This storage of results in variables and arrays in memory for; the duration of the PSI4 instance (as opposed to solely in files); is the only advantage thus far incurred by the P4C4 interface. We’ll call; this mode of basic utility the “sandwich” mode.; Molecule specification in PSI4 allows Cartesians, Z-matrices, mixed; Cartesian/Z-matrix, negation of variables, delayed specification of; variables, specification of fragments, etc., all in a whitespace-tolerant; format. See Molecule and Geometry Speci",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/cfour-1.html:3274,energy,energy,3274,psi4manual/1.2.1/cfour-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/cfour-1.html,6,['energy'],['energy']
Energy Efficiency,"are; possible due to heavy utilization of matrix-multiplication kernels and minimal; storage requirements in a DF approach. The method has been found to be quite; robust and accurate, and it should be preferred unless extreme accuracy is required; or a fitting basis is not defined for the primary basis and atom type; encountered. In particular, we have found excellent efficiency and tractability; gains when using DF-MP2 in concert with a DF-SCF reference. An efficient,; threaded, disk-based DF-MP2 code is available in PSI4 for all single; reference types available in the SCF module.; MP2 defaults in PSI4 to the density-fitted code. See; MP2_TYPE for performing a MP2 with conventional integrals.; An example utilization of the code is:; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12molecule h2o {; 0 1; O; H 1 1.0; H 1 1.0 2 104.5; }. set basis cc-pvdz; set scf_type df; set freeze_core True. energy('mp2'). The energy('mp2') call to energy() executes; the predefined DF-MP2 procedure, first calling; the SCF module with a default RHF reference and DF algorithm for the; two-electron integrals. When the orbitals are converged, the DF-MP2 module is; launched, which forms the density-fitted \((Q|ov)\) integrals and then builds the; full \((ov|ov)\) tensor in blocks, evaluating the contributions to the MP2 energy; as it goes. A RHF-MP2 wavefunction is selected automatically due to the RHF; reference. In this example, we freeze the core, both for efficiency and; because split-valence bases like cc-pVDZ do not contain core correlation; functions. The result looks something like:; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19-----------------------------------------------------------; ==================> DF-MP2 Energies <====================; -----------------------------------------------------------; Reference Energy = -76.0213974638823942 [Eh]; Singles Energy = -0.0000000000000001 [Eh]; Same-Spin Energy = -0.0512503270216563 [Eh]; Opposite-Spin Energy = -0.1534098175",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/dfmp2-1.html:2025,energy,energy,2025,psi4manual/1.2.1/dfmp2-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/dfmp2-1.html,12,['energy'],['energy']
Energy Efficiency,"are_recursive; from psi4.driver.procrouting.proc_util import check_iwl_file_from_scf_type. from psi4 import core; from .exceptions import ValidationError, TestComparisonError. [docs]def fcidump(wfn: core.Wavefunction, fname: str = 'INTDUMP', oe_ints: Optional[List] = None):; """"""Save integrals to file in FCIDUMP format as defined in Comp. Phys. Commun. 54 75 (1989),; https://doi.org/10.1016/0010-4655(89)90033-7 .; Additional one-electron integrals, including orbital energies, can also be saved.; This latter format can be used with the HANDE QMC code but is not standard. Parameters; ----------; wfn; Set of molecule, basis, orbitals from which to generate FCIDUMP file.; fname; Name of the integrals file, defaults to INTDUMP.; oe_ints; List of additional one-electron integrals to save to file. So far only; EIGENVALUES is a valid option. Raises; ------; ValidationError; When SCF wavefunction is not RHF. Examples; --------. >>> # [1] Save one- and two-electron integrals to standard FCIDUMP format; >>> E, wfn = energy('scf', return_wfn=True); >>> fcidump(wfn). >>> # [2] Save orbital energies, one- and two-electron integrals.; >>> E, wfn = energy('scf', return_wfn=True); >>> fcidump(wfn, oe_ints=['EIGENVALUES']). """"""; # Get some options; reference = core.get_option('SCF', 'REFERENCE'); ints_tolerance = core.get_global_option('INTS_TOLERANCE'); # Some sanity checks; if reference not in ['RHF', 'UHF']:; raise ValidationError('FCIDUMP not implemented for {} references\n'.format(reference)); if oe_ints is None:; oe_ints = []. molecule = wfn.molecule(); docc = wfn.doccpi(); frzcpi = wfn.frzcpi(); frzvpi = wfn.frzvpi(); active_docc = docc - frzcpi; active_socc = wfn.soccpi(); active_mopi = wfn.nmopi() - frzcpi - frzvpi. nbf = active_mopi.sum() if wfn.same_a_b_orbs() else 2 * active_mopi.sum(); nirrep = wfn.nirrep(); nelectron = 2 * active_docc.sum() + active_socc.sum(); irrep_map = _irrep_map(wfn). wfn_irrep = 0; for h, n_socc in enumerate(active_socc):; if n_socc % 2 == 1:; wfn_",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/fcidump.html:2506,energy,energy,2506,psi4manual/1.7.x/_modules/psi4/driver/p4util/fcidump.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/fcidump.html,2,['energy'],['energy']
Energy Efficiency,"arg1, (int)arg2) -> None :. Sets the specified fragment arg2 to be Ghost; C++ signature :. void set_ghost_fragment(N3psi8MoleculeE {lvalue},i). psi4.Molecule.set_ghost_fragments()¶; Python Library Documentation: method set_ghost_fragments; set_ghost_fragments(...) unbound psi4.Molecule method. set_ghost_fragments( (Molecule)arg1, (list)arg2) -> None :. Sets the specified list arg2 of fragments to be Ghost; C++ signature :. void set_ghost_fragments(N3psi8MoleculeE {lvalue},N5boost6python4listE). psi4.Molecule.set_mass()¶; Python Library Documentation: method set_mass; set_mass(...) unbound psi4.Molecule method. set_mass( (Molecule)arg1, (int)arg2, (float)arg3) -> None :. Gets mass of atom arg2; C++ signature :. void set_mass(N3psi8MoleculeE {lvalue},i,d). psi4.Molecule.set_molecular_charge()¶; Python Library Documentation: method set_molecular_charge; set_molecular_charge(...) unbound psi4.Molecule method. set_molecular_charge( (Molecule)arg1, (int)arg2) -> None :. Sets the molecular charge; C++ signature :. void set_molecular_charge(N3psi8MoleculeE {lvalue},i). psi4.Molecule.set_multiplicity()¶; Python Library Documentation: method set_multiplicity; set_multiplicity(...) unbound psi4.Molecule method. set_multiplicity( (Molecule)arg1, (int)arg2) -> None :. Sets the multiplicity (defined as 2Ms + 1); C++ signature :. void set_multiplicity(N3psi8MoleculeE {lvalue},i). psi4.Molecule.set_name()¶; Python Library Documentation: method set_name; set_name(...) unbound psi4.Molecule method. set_name( (Molecule)arg1, (str)arg2) -> None :. Sets molecule name; C++ signature :. void set_name(N3psi8MoleculeE {lvalue},Ss). psi4.Molecule.set_point_group()¶; Python Library Documentation: method set_point_group; set_point_group(...) unbound psi4.Molecule method. set_point_group( (Molecule)arg1, (PointGroup)arg2) -> None :. Sets the molecular point group to the point group object arg2; C++ signature :. void set_point_group(N3psi8MoleculeE {lvalue},N5boost10shared_ptrIN3psi10PointGroupE",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html:254515,charge,charge,254515,psi4manual/1.0.0/autodoc_psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html,2,['charge'],['charge']
Energy Efficiency,"arg1, arg2, ...); Quick testing capabilities. value(self, arg0); Returns a given internal value. values(self); Return all internal values. vv10_b(self); The VV10 b parameter. vv10_c(self); The VV10 c parameter. x_alpha(self); Amount of exact HF exchange. x_beta(self); Amount of exact HF exchange. x_functional(self, arg0); Returns the desired X Functional. x_functionals(self); Returns all X Functionals. x_omega(self); Range-seperated exchange parameter. xclib_description(self); LibXC version and citation string. Methods Documentation. static XC_build(name: str, unpolarized: bool, tweak: Dict[str, float] | None = {}) → psi4.core.SuperFunctional¶; Builds a SuperFunctional from a XC string. add_c_functional(self: psi4.core.SuperFunctional, arg0: psi4.core.Functional) → None¶; Add a correlation Functional. add_x_functional(self: psi4.core.SuperFunctional, arg0: psi4.core.Functional) → None¶; Add a exchange Functional. allocate(self: psi4.core.SuperFunctional) → None¶; Allocates the vectors, should be called after ansatz or npoint changes. ansatz(self: psi4.core.SuperFunctional) → int¶; SuperFunctional rung. static blank() → psi4.core.SuperFunctional¶; Initialize a blank SuperFunctional. c_alpha(self: psi4.core.SuperFunctional) → float¶; Amount of MP2 correlation. c_functional(self: psi4.core.SuperFunctional, arg0: str) → psi4.core.Functional¶; Returns the desired C Functional. c_functionals(self: psi4.core.SuperFunctional) → List[psi4.core.Functional]¶; Returns all C Functionals. c_omega(self: psi4.core.SuperFunctional) → float¶; Range-seperated correlation parameter. c_os_alpha(self: psi4.core.SuperFunctional) → float¶; Amount of SS MP2 correlation. c_ss_alpha(self: psi4.core.SuperFunctional) → float¶; Amount of OS MP2 correlation. citation(self: psi4.core.SuperFunctional) → str¶; SuperFunctional citation. compute_functional(self: psi4.core.SuperFunctional, vals: Dict[str, psi4.core.Vector], npoints: int = -1, singlet: bool = True) → Dict[str, psi4.core.Vector]¶; Compute",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/api/psi4.core.SuperFunctional.html:4511,Allocate,Allocates,4511,psi4manual/1.9.x/api/psi4.core.SuperFunctional.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.SuperFunctional.html,1,['Allocate'],['Allocates']
Energy Efficiency,"arg1, arg2, ...); Quick testing capabilities. value(self, arg0); Returns a given internal value. values(self); Return all internal values. vv10_b(self); The VV10 b parameter. vv10_c(self); The VV10 c parameter. x_alpha(self); Amount of exact HF exchange. x_beta(self); Amount of exact HF exchange. x_functional(self, arg0); Returns the desired X Functional. x_functionals(self); Returns all X Functionals. x_omega(self); Range-seperated exchange parameter. xclib_description(self); LibXC version and citation string. Methods Documentation. static XC_build(name: str, unpolarized: bool, tweak: dict[str, float] | None = {}) → psi4.core.SuperFunctional¶; Builds a SuperFunctional from a XC string. add_c_functional(self: psi4.core.SuperFunctional, arg0: psi4.core.Functional) → None¶; Add a correlation Functional. add_x_functional(self: psi4.core.SuperFunctional, arg0: psi4.core.Functional) → None¶; Add a exchange Functional. allocate(self: psi4.core.SuperFunctional) → None¶; Allocates the vectors, should be called after ansatz or npoint changes. ansatz(self: psi4.core.SuperFunctional) → int¶; SuperFunctional rung. static blank() → psi4.core.SuperFunctional¶; Initialize a blank SuperFunctional. c_alpha(self: psi4.core.SuperFunctional) → float¶; Amount of MP2 correlation. c_functional(self: psi4.core.SuperFunctional, arg0: str) → psi4.core.Functional¶; Returns the desired C Functional. c_functionals(self: psi4.core.SuperFunctional) → list[psi4.core.Functional]¶; Returns all C Functionals. c_omega(self: psi4.core.SuperFunctional) → float¶; Range-seperated correlation parameter. c_os_alpha(self: psi4.core.SuperFunctional) → float¶; Amount of SS MP2 correlation. c_ss_alpha(self: psi4.core.SuperFunctional) → float¶; Amount of OS MP2 correlation. citation(self: psi4.core.SuperFunctional) → str¶; SuperFunctional citation. compute_functional(self: psi4.core.SuperFunctional, vals: dict[str, psi4.core.Vector], npoints: int = -1, singlet: bool = True) → dict[str, psi4.core.Vector]¶; Compute",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/api/psi4.core.SuperFunctional.html:4518,Allocate,Allocates,4518,psi4manual/master/api/psi4.core.SuperFunctional.html,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.SuperFunctional.html,1,['Allocate'],['Allocates']
Energy Efficiency,"arg2) -> None :. docstring; C++ signature :. void benchmark_disk(i,d). psi4.benchmark_integrals()¶; Python Library Documentation: built-in function benchmark_integrals in module psi4; benchmark_integrals(...). benchmark_integrals( (int)arg1, (float)arg2) -> None :. docstring; C++ signature :. void benchmark_integrals(i,d). psi4.benchmark_math()¶; Python Library Documentation: built-in function benchmark_math in module psi4; benchmark_math(...). benchmark_math( (float)arg1) -> None :. docstring; C++ signature :. void benchmark_math(d). psi4.ccdensity()¶; Python Library Documentation: built-in function ccdensity in module psi4; ccdensity(...). ccdensity( (Wavefunction)arg1) -> float :. Runs the code to compute coupled cluster density matrices.; C++ signature :. d ccdensity(N5boost10shared_ptrIN3psi12WavefunctionEEE). psi4.ccenergy()¶; Python Library Documentation: built-in function ccenergy in module psi4; ccenergy(...). ccenergy( (Wavefunction)arg1) -> Wavefunction :. Runs the coupled cluster energy code.; C++ signature :. N5boost10shared_ptrIN3psi12WavefunctionEEE ccenergy(N5boost10shared_ptrIN3psi12WavefunctionEEE). psi4.cceom()¶; Python Library Documentation: built-in function cceom in module psi4; cceom(...). cceom( (Wavefunction)arg1) -> float :. Runs the equation of motion coupled cluster code, for excited states.; C++ signature :. d cceom(N5boost10shared_ptrIN3psi12WavefunctionEEE). psi4.cchbar()¶; Python Library Documentation: built-in function cchbar in module psi4; cchbar(...). cchbar( (Wavefunction)arg1) -> None :. Runs the code to generate the similarity transformed Hamiltonian.; C++ signature :. void cchbar(N5boost10shared_ptrIN3psi12WavefunctionEEE). psi4.cclambda()¶; Python Library Documentation: built-in function cclambda in module psi4; cclambda(...). cclambda( (Wavefunction)arg1) -> Wavefunction :. Runs the coupled cluster lambda equations code.; C++ signature :. N5boost10shared_ptrIN3psi12WavefunctionEEE cclambda(N5boost10shared_ptrIN3psi12Wavefunc",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html:15704,energy,energy,15704,psi4manual/1.0.0/autodoc_psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html,2,['energy'],['energy']
Energy Efficiency,"arg2) -> None :; docstring; ; C++ signature :; void benchmark_blas1(i,d); ; benchmark_blas2(...); benchmark_blas2( (int)arg1, (float)arg2) -> None :; docstring; ; C++ signature :; void benchmark_blas2(i,d); ; benchmark_blas3(...); benchmark_blas3( (int)arg1, (float)arg2, (int)arg3) -> None :; docstring; ; C++ signature :; void benchmark_blas3(i,d,i); ; benchmark_disk(...); benchmark_disk( (int)arg1, (float)arg2) -> None :; docstring; ; C++ signature :; void benchmark_disk(i,d); ; benchmark_integrals(...); benchmark_integrals( (int)arg1, (float)arg2) -> None :; docstring; ; C++ signature :; void benchmark_integrals(i,d); ; benchmark_math(...); benchmark_math( (float)arg1) -> None :; docstring; ; C++ signature :; void benchmark_math(d); ; ccdensity(...); ccdensity( (Wavefunction)arg1) -> float :; Runs the code to compute coupled cluster density matrices.; ; C++ signature :; d ccdensity(N5boost10shared_ptrIN3psi12WavefunctionEEE); ; ccenergy(...); ccenergy( (Wavefunction)arg1) -> Wavefunction :; Runs the coupled cluster energy code.; ; C++ signature :; N5boost10shared_ptrIN3psi12WavefunctionEEE ccenergy(N5boost10shared_ptrIN3psi12WavefunctionEEE); ; cceom(...); cceom( (Wavefunction)arg1) -> float :; Runs the equation of motion coupled cluster code, for excited states.; ; C++ signature :; d cceom(N5boost10shared_ptrIN3psi12WavefunctionEEE); ; cchbar(...); cchbar( (Wavefunction)arg1) -> None :; Runs the code to generate the similarity transformed Hamiltonian.; ; C++ signature :; void cchbar(N5boost10shared_ptrIN3psi12WavefunctionEEE); ; cclambda(...); cclambda( (Wavefunction)arg1) -> Wavefunction :; Runs the coupled cluster lambda equations code.; ; C++ signature :; N5boost10shared_ptrIN3psi12WavefunctionEEE cclambda(N5boost10shared_ptrIN3psi12WavefunctionEEE); ; ccresponse(...); ccresponse( (Wavefunction)arg1) -> float :; Runs the coupled cluster response theory code.; ; C++ signature :; d ccresponse(N5boost10shared_ptrIN3psi12WavefunctionEEE); ; ccsort(...); ccsort() ->",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html:676061,energy,energy,676061,psi4manual/1.0.0/autodoc_psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html,2,['energy'],['energy']
Energy Efficiency,"arg2); Sets basis set arg1 to all atoms with label (e.g., H4) arg0. set_basis_by_number(self, arg0, arg1, arg2); Sets basis set arg1 to all atoms with number arg0. set_basis_by_symbol(self, arg0, arg1, arg2); Sets basis set arg1 to all atoms with symbol (e.g., H) arg0. set_comment(self, arg0); Sets molecule comment. set_connectivity(self, arg0); Sets molecule connectivity. set_full_geometry(self, arg0); Sets the geometry, given a (Natom X 3) matrix arg0 of coordinates (in Bohr) (including dummies. set_geometry(self, arg0); Sets the geometry, given a (Natom X 3) matrix arg0 of coordinates [a0] (excluding dummies). set_ghost_fragment(self, arg0); Sets the specified fragment arg0 to be Ghost. set_ghost_fragments(self, arg0); Sets the specified list arg0 of fragments to be Ghost. set_input_units_to_au(self, arg0); Sets unit conversion to [a0] for geometry. set_mass(self, atom, mass); Sets mass of atom (0-indexed) to mass (good for isotopic substitutions). set_molecular_charge(self, arg0); Change the overall molecular charge. set_multiplicity(self, arg0); Change the multiplicity (defined as 2S + 1). set_name(self, arg0); Sets molecule name. set_nuclear_charge(self, arg0, arg1); Set the nuclear charge of the given atom arg0 to the value arg1 (primarily for ECP). set_point_group(self, arg0); Sets the molecular point group to the point group object arg0. set_provenance(self, arg0); Sets molecule provenance. set_units(self, arg0); Sets units (Angstrom or Bohr) used to define the geometry. set_variable(self, arg0, arg1); Sets the value arg1 to the variable arg0 in the list of structure variables, then calls update_geometry(). symbol(self, atom); Gets the cleaned up label of atom (C2 => C, H4 = H) (0-indexed without dummies). symmetrize(self, arg0); Finds the highest point Abelian point group within the specified tolerance, and forces the geometry to have that symmetry. symmetry_from_input(self); Returns the symmetry specified in the input. to_arrays([dummy, ghost_as_dummy]); E",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/api/psi4.core.molecule.html:9139,charge,charge,9139,psi4manual/1.5.0/api/psi4.core.molecule.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/api/psi4.core.molecule.html,12,['charge'],['charge']
Energy Efficiency,"arge(); -2. move_to_com()[source]¶; Moves molecule to center of mass. multiplicity()[source]¶; Get the multiplicity (defined as 2Ms + 1); >>> print H2OH2O.multiplicity(). multiplicity_specified()[source]¶; Whether the multiplicity was given by the user; >>> print H2OH2O.multiplicity_specified(); True. nactive_fragments()[source]¶; The number of active fragments in the molecule.; >>> print H2OH2O.nactive_fragments(); 2. nallatom()[source]¶; Number of all atoms (includes dummies); >>> print H2OH2O.nallatom(); 7. name()[source]¶; Get molecule name; >>> print H2OH2O.name(); water_dimer. natom()[source]¶; Number of atoms; >>> print H2OH2O.natom(); 6. nequivalent(iuniq)[source]¶; NYI Returns the number of atoms equivalent to iuniq. nfragments()[source]¶; The number of fragments in the molecule.; >>> print H2OH2O.nfragments(); 2. nfrozen_core(depth=False)[source]¶; Number of frozen core for molecule given freezing state.; >>> print H2OH2O.nfrozen_core(); 2. nuclear_repulsion_energy()[source]¶; Computes nuclear repulsion energy.; >>> print H2OH2O.nuclear_repulsion_energy(); 36.6628478528. nuclear_repulsion_energy_deriv1()[source]¶; Computes nuclear repulsion energy derivatives; >>> print H2OH2O.nuclear_repulsion_energy_deriv1(); [[3.9020946901323774, 2.76201566471991, 0.0], [1.3172905807089021, -2.3486366050337293, 0.0], [-1.8107598525022435, -0.32511212499256564, 0.0], [-1.217656141385739, -2.6120090867576717, 0.0], [-1.0954846384766488, 1.2618710760320282, 2.1130743287465603], [-1.0954846384766488, 1.2618710760320282, -2.1130743287465603]]. nuclear_repulsion_energy_deriv2()[source]¶; NYI Computes nuclear repulsion energy second derivatives. nunique()[source]¶; NYI Return the number of unique atoms. orientation_fixed()[source]¶; Get whether or not orientation is fixed.; >>> H2OH2O.orientation_fixed(); True. point_group()[source]¶; NYI Returns the point group (object) if set. print_bond_angles()[source]¶; Print the geometrical parameters (bond_angles) of the molecule.; >>> ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/autodoc_driver-1.html:54280,energy,energy,54280,psi4manual/4.0b5/autodoc_driver-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodoc_driver-1.html,2,['energy'],['energy']
Energy Efficiency,"arge(self.molecule.Z(A), self.molecule.x(A), self.molecule.y(A), self.molecule.z(A)). [docs]; class QMMM():; """"""Hold charges and :py:class:`psi4.core.ExternalPotential`. Use :py:class:`psi4.driver.QMMMbohr` instead."""""". def __init__(self):; raise UpgradeHelper(self.__class__.__name__, ""QMMMbohr"", 1.6, ' Replace object with a list of charges and locations in Bohr passed as keyword argument, e.g., `energy(..., external_potentials=[[0.5, [0, 0, 1]], [-0.5, [0, 0, -1]]])`.'). [docs]; class QMMMbohr():; """"""Hold charges and :py:class:`psi4.core.ExternalPotential`. To add external charges to a calculation, prefer; passing the array of charges with kwarg ``external_potentials``, as in extern2 example."""""". def __init__(self):; self.charges = []; self.diffuses = []; self.extern = core.ExternalPotential(). [docs]; def addDiffuse(self, diffuse):; """"""Function to add a diffuse charge field *diffuse*.""""""; self.diffuses.append(diffuse). [docs]; def addChargeBohr(self, Q, x, y, z):; """"""Function to add a point charge of magnitude *Q* at; position (*x*, *y*, *z*) Bohr. """"""; self.charges.append([Q, x, y, z]). [docs]; def addChargeAngstrom(self, Q, x, y, z):; """"""Function to add a point charge of magnitude *Q* at; position (*x*, *y*, *z*) Angstroms. """"""; self.charges.append([Q, x / constants.bohr2angstroms, y / constants.bohr2angstroms, z / constants.bohr2angstroms]). def __str__(self):. s = ' ==> QMMM <==\n\n'. s = s + ' => Charges (a.u.) <=\n\n'; s = s + ' %11s %11s %11s %11s\n' % ('Z', 'x', 'y', 'z'); for k in range(0, len(self.charges)):; s = s + ' %11.7f %11.3E %11.3E %11.3E\n' % (self.charges[k][0], self.charges[k][1], self.charges[k][2], self.charges[k][3]); s = s + '\n'. s = s + ' => Diffuses <=\n\n'. for k in range(0, len(self.diffuses)):; s = s + str(self.diffuses[k]). return s. [docs]; def populateExtern(self):; """"""Function to define a charge field external to the; molecule through point and diffuse charges. """"""; # Charges; for charge in self.charges:; self.extern.addCharge(ch",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qmmm.html:4377,charge,charge,4377,psi4manual/1.8.x/_modules/psi4/driver/qmmm.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qmmm.html,6,['charge'],['charge']
Energy Efficiency,"arge0 + 1;; mult1 = Na1 - Nb1 + 1. omegas = [];; E0s = [];; E1s = [];; kIPs = [];; IPs = [];; types = [];. # Right endpoint; psi4.set_global_option('DFT_OMEGA',omega_r). # Neutral; if (read):; psi4.set_global_option(""GUESS"", ""READ""); p4util.copy_file_to_scratch(read180, 'psi', 'ot', 180). mol.set_molecular_charge(charge0); mol.set_multiplicity(mult0); psi4.print_out('\n\t==> IP Fitting SCF: Neutral, Right Endpoint <==\n'); E0r = energy('scf'); ref = psi4.wavefunction(); eps_a = ref.epsilon_a(); eps_b = ref.epsilon_b(); E_HOMO = 0.0;; if (Nb == 0):; E_HOMO = eps_a[int(Na-1)]; else:; E_a = eps_a[int(Na - 1)]; E_b = eps_b[int(Nb - 1)]; if (E_a >= E_b):; E_HOMO = E_a;; else:; E_HOMO = E_b;; E_HOMOr = E_HOMO;; psi4.IO.change_file_namespace(180,""ot"",""neutral""). # Cation; if (read):; psi4.set_global_option(""GUESS"", ""READ""); p4util.copy_file_to_scratch(read180, 'psi', 'ot', 180). mol.set_molecular_charge(charge1); mol.set_multiplicity(mult1); psi4.print_out('\n\t==> IP Fitting SCF: Cation, Right Endpoint <==\n'); E1r = energy('scf'); psi4.IO.change_file_namespace(180,""ot"",""cation""). IPr = E1r - E0r;; kIPr = -E_HOMOr;; delta_r = IPr - kIPr;. if (IPr > kIPr):; psi4.print_out('\n***IP Fitting Error: Right Omega limit should have kIP > IP'); sys.exit(1). omegas.append(omega_r); types.append('Right Limit'); E0s.append(E0r); E1s.append(E1r); IPs.append(IPr); kIPs.append(kIPr). # Use previous orbitals from here out; psi4.set_global_option(""GUESS"",""READ""). # Left endpoint; psi4.set_global_option('DFT_OMEGA',omega_l). # Neutral; psi4.IO.change_file_namespace(180,""neutral"",""ot""); mol.set_molecular_charge(charge0); mol.set_multiplicity(mult0); psi4.print_out('\n\t==> IP Fitting SCF: Neutral, Left Endpoint <==\n'); E0l = energy('scf'); ref = psi4.wavefunction(); eps_a = ref.epsilon_a(); eps_b = ref.epsilon_b(); E_HOMO = 0.0;; if (Nb == 0):; E_HOMO = eps_a[int(Na-1)]; else:; E_a = eps_a[int(Na - 1)]; E_b = eps_b[int(Nb - 1)]; if (E_a >= E_b):; E_HOMO = E_a;; else:; E_HOMO = E_b;; E_HOMOl",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/frac.html:14130,energy,energy,14130,psi4manual/4.0b5/_modules/frac.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/frac.html,2,['energy'],['energy']
Energy Efficiency,"arge; SCF DZ finite difference frequencies by energies for C4NH4. cisd-h2o+-0; 6-31G** H2O+ Test CISD Energy Point. psimrcc-ccsd_t-4; Mk-MRCCSD(T) single point. \(^1A_1\) O$_3` state described using the Ms = 0 component of the singlet. Uses TCSCF orbitals. mp2-grad1; MP2 cc-pVDZ gradient for the H2O molecule. omp3-grad2; OMP3 cc-pVDZ gradient for the NO radical. fsapt1; This test case shows an example of running and analyzing a standard F-SAPT0/jun-cc-pvdz procedure for phenol dimer from the S22 database. extern1; External potential calculation involving a TIP3P water and a QM water. Finite different test of the gradient is performed to validate forces. cisd-h2o+-2; 6-31G** H2O+ Test CISD Energy Point. sapt1; SAPT0 cc-pVDZ computation of the ethene-ethyne interaction energy, using the cc-pVDZ-JKFIT RI basis for SCF and cc-pVDZ-RI for SAPT. Monomer geometries are specified using Cartesian coordinates. cc52; CCSD Response for H2O2. decontract; RHF/cc-pvdz-decontract HCl single-point energy Testing the in line -decontract option for basis sets. cc55; EOM-CCSD/6-31g excited state transition data for water with two excited states per irrep. dft-b2plyp; Double-hybrid density functional B2PYLP. Reproduces portion of Table I in S. Grimme’s J. Chem. Phys 124 034108 (2006) paper defining the functional. stability2; ROHF stability analysis check for CN with cc-pVDZ. This test corresponds to the rohf-stab test from Psi3. psimrcc-ccsd_t-1; Mk-MRCCSD(T) single point. \(^1A_1\) CH2 state described using the Ms = 0 component of the singlet. Uses RHF singlet orbitals. cc44; Test case for some of the PSI4 out-of-core codes. The code is given only 2.0 MB of memory, which is insufficient to hold either the A1 or B2 blocks of an ovvv quantity in-core, but is sufficient to hold at least two copies of an oovv quantity in-core. soscf2; Triple and Singlet Oxygen energy SOSCF, also tests non-symmetric density matrices. psithon2; Accesses basis sets, databases, plugins, and executables in non",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/testsuite-1.html:3608,energy,energy,3608,psi4manual/1.1.0/testsuite-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/testsuite-1.html,4,['energy'],['energy']
Energy Efficiency,"args = kwargs_lower(kwargs). # Run detci calculation and collect conventional quantities; energy('mp3', **kwargs); e_scf = PsiMod.get_variable('SCF TOTAL ENERGY'); ce_mp2 = PsiMod.get_variable('MP2 CORRELATION ENERGY'); ce_mp3 = PsiMod.get_variable('MP3 CORRELATION ENERGY'); e_mp2 = e_scf + ce_mp2; e_mp3 = e_scf + ce_mp3. # Compute quantities particular to MP2.5; ce_mp25 = 0.5 * (ce_mp2 + ce_mp3); e_mp25 = e_scf + ce_mp25; PsiMod.set_variable('MP2.5 CORRELATION ENERGY', ce_mp25); PsiMod.set_variable('MP2.5 TOTAL ENERGY', e_mp25); PsiMod.set_variable('CURRENT CORRELATION ENERGY', ce_mp25); PsiMod.set_variable('CURRENT ENERGY', e_mp25). # build string of title banner and print results; banners = ''; banners += """"""PsiMod.print_out('\\n')\n""""""; banners += """"""banner(' MP2.5 ')\n""""""; banners += """"""PsiMod.print_out('\\n')\n\n""""""; exec banners. tables = ''; tables += """""" SCF total energy: %16.8f\n"""""" % (e_scf); tables += """""" MP2 total energy: %16.8f\n"""""" % (e_mp2); tables += """""" MP2.5 total energy: %16.8f\n"""""" % (e_mp25); tables += """""" MP3 total energy: %16.8f\n\n"""""" % (e_mp3); tables += """""" MP2 correlation energy: %16.8f\n"""""" % (ce_mp2); tables += """""" MP2.5 correlation energy: %16.8f\n"""""" % (ce_mp25); tables += """""" MP3 correlation energy: %16.8f\n"""""" % (ce_mp3); PsiMod.print_out(tables). return e_mp25. # A direct translation of a plugin input file into a function call. Function calls are the only; # way to call plugins in sow/reap mode for db(), opt(), etc. This isn't best practices; # but is an example of what to do for a more complicated procedure where different options ; # are set for different qc steps.; [docs]def run_plugin_omega(name, **kwargs):; r""""""Function encoding sequence of PSI module and plugin calls, as well; as typical options, to access Rob Parrish's omega plugin. >>> energy('plugin_omega'). """"""; lowername = name.lower(); kwargs = kwargs_lower(kwargs). plugfile = PsiMod.Process.environment[""PSIDATADIR""] + ""/../tests/plugin_omega/plugin_omega.so""; PsiMod.pl",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/_modules/aliases.html:3606,energy,energy,3606,psi4manual/4.0b2/_modules/aliases.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/aliases.html,2,['energy'],['energy']
Energy Efficiency,"args):; kwargs['delta4_wfn'] = 'mrccsdt(q)'; if not ('delta4_wfn_lesser' in kwargs):; kwargs['delta4_wfn_lesser'] = 'mrccsdt'; if not ('delta4_basis' in kwargs):; kwargs['delta4_basis'] = 'cc-pVDZ'; if not ('delta4_scheme' in kwargs):; kwargs['delta4_scheme'] = highest_1. return cbs(name, **kwargs). #def run_mp2_5(name, **kwargs):; # r""""""Function that computes MP2.5 energy from results of a FNOCC; # MP3 calculation.; #; # .. math:: E_{total}^{\text{MP2.5}} = E_{total,\; \text{SCF}} \; + E_{corl,\; \text{MP2}} + E_{corl, \; \text{MP3}}; #; # :PSI variables:; #; # .. hlist::; # :columns: 1; #; # * :psivar:`MP2.5 TOTAL ENERGY <MP2.5TOTALENERGY>`; # * :psivar:`MP2.5 CORRELATION ENERGY <MP2.5CORRELATIONENERGY>`; #; # >>> energy('mp2.5'); #; # """"""; # lowername = name.lower(); # kwargs = kwargs_lower(kwargs); #; # # Run detci calculation and collect conventional quantities; # energy('mp3', **kwargs); # e_scf = psi4.get_variable('SCF TOTAL ENERGY'); # ce_mp2 = psi4.get_variable('MP2 CORRELATION ENERGY'); # ce_mp3 = psi4.get_variable('MP3 CORRELATION ENERGY'); # e_mp2 = e_scf + ce_mp2; # e_mp3 = e_scf + ce_mp3; #; # # Compute quantities particular to MP2.5; # ce_mp25 = 0.5 * (ce_mp2 + ce_mp3); # e_mp25 = e_scf + ce_mp25; # psi4.set_variable('MP2.5 CORRELATION ENERGY', ce_mp25); # psi4.set_variable('MP2.5 TOTAL ENERGY', e_mp25); # psi4.set_variable('CURRENT CORRELATION ENERGY', ce_mp25); # psi4.set_variable('CURRENT ENERGY', e_mp25); #; # # build string of title banner and print results; # banners = ''; # banners += """"""psi4.print_out('\\n')\n""""""; # banners += """"""banner(' MP2.5 ')\n""""""; # banners += """"""psi4.print_out('\\n')\n\n""""""; # exec(banners); #; # tables = ''; # tables += """""" SCF total energy: %16.8f\n"""""" % (e_scf); # tables += """""" MP2 total energy: %16.8f\n"""""" % (e_mp2); # tables += """""" MP2.5 total energy: %16.8f\n"""""" % (e_mp25); # tables += """""" MP3 total energy: %16.8f\n\n"""""" % (e_mp3); # tables += """""" MP2 correlation energy: %16.8f\n"""""" % (ce_mp2); # tables += """""" MP2",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/aliases.html:7036,ENERGY,ENERGY,7036,psi4manual/4.0b5/_modules/aliases.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/aliases.html,1,['ENERGY'],['ENERGY']
Energy Efficiency,"args):; sapt_dimer = dimer_wfn.molecule(); sapt_dimer, monomerA, monomerB = prepare_sapt_molecule(sapt_dimer, ""dimer""); disp_name = name.split(""-"")[1]. # Get the names right between SAPT0 and FISAPT0; saptd_name = name.split('-')[0].upper(); if saptd_name == ""SAPT0"":; sapt0_name = ""SAPT0""; else:; sapt0_name = ""SAPT"". save_pair = (saptd_name == ""FISAPT0""). from .proc import build_disp_functor; _, _disp_functor = build_disp_functor('hf-' + disp_name, restricted=True, save_pairwise_disp=save_pair, **kwargs). ## Dimer dispersion; dimer_disp_energy = _disp_functor.compute_energy(dimer_wfn.molecule(), dimer_wfn); ## Monomer dispersion; mon_disp_energy = _disp_functor.compute_energy(monomerA); mon_disp_energy += _disp_functor.compute_energy(monomerB). disp_interaction_energy = dimer_disp_energy - mon_disp_energy; core.set_variable(saptd_name + ""-D DISP ENERGY"", disp_interaction_energy); core.set_variable(""SAPT DISP ENERGY"", disp_interaction_energy); core.set_variable(""DISPERSION CORRECTION ENERGY"", disp_interaction_energy); core.set_variable(saptd_name + ""DISPERSION CORRECTION ENERGY"", disp_interaction_energy). ## Set SAPT0-D3 variables; total = disp_interaction_energy; saptd_en = {}; saptd_en['DISP'] = disp_interaction_energy; for term in ['ELST', 'EXCH', 'IND']:; en = core.variable(' '.join([sapt0_name, term, 'ENERGY'])); saptd_en[term] = en; core.set_variable(' '.join([saptd_name + '-D', term, 'ENERGY']), en); core.set_variable(' '.join(['SAPT', term, 'ENERGY']), en); total += en. core.set_variable(saptd_name + '-D TOTAL ENERGY', total); core.set_variable('SAPT TOTAL ENERGY', total); core.set_variable('CURRENT ENERGY', total). ## Print Energy Summary; units = (1000.0, constants.hartree2kcalmol, constants.hartree2kJmol); core.print_out(f"" => {saptd_name +'-D'} Energy Summary <=\n""). core.print_out("" "" + ""-"" * 104 + ""\n""); core.print_out(; "" %-25s % 16.8f [mEh] % 16.8f [kcal/mol] % 16.8f [kJ/mol]\n"" %; (""Electrostatics"", saptd_en['ELST'] * units[0], saptd_en['ELST'] * uni",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc_util.html:9351,ENERGY,ENERGY,9351,psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc_util.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc_util.html,3,['ENERGY'],['ENERGY']
Energy Efficiency,"args['restart_file'] # Option still available for procedure-specific action; if restartfile != list(restartfile):; restartfile = [restartfile]; # Rename the files to be read to be consistent with psi4's file system; for item in restartfile:; name_split = re.split(r'\.', item); filenum = name_split[len(name_split) - 1]; try:; filenum = int(filenum); except ValueError:; filenum = 32 # Default file number is the checkpoint one; psioh = core.IOManager.shared_object(); psio = core.IO.shared_object(); filepath = psioh.get_file_path(filenum); namespace = psio.get_default_namespace(); pid = str(os.getpid()); prefix = 'psi'; targetfile = filepath + prefix + '.' + pid + '.' + namespace + '.' + str(filenum); shutil.copy(item, targetfile). wfn = procedures['energy'][lowername](lowername, molecule=molecule, **kwargs). for postcallback in hooks['energy']['post']:; postcallback(lowername, wfn=wfn, **kwargs). optstash.restore(); if return_wfn: # TODO current energy safer than wfn.energy() for now, but should be revisited. # TODO place this with the associated call, very awkward to call this in other areas at the moment; if lowername in ['efp', 'mrcc', 'dmrg', 'psimrcc']:; core.print_out(""\n\nWarning! %s does not have an associated derived wavefunction."" % name); core.print_out(""The returned wavefunction is the incoming reference wavefunction.\n\n""); elif 'sapt' in lowername:; core.print_out(""\n\nWarning! %s does not have an associated derived wavefunction."" % name); core.print_out(""The returned wavefunction is the dimer SCF wavefunction.\n\n""). return (core.get_variable('CURRENT ENERGY'), wfn); else:; return core.get_variable('CURRENT ENERGY'). [docs]def gradient(name, **kwargs):; r""""""Function complementary to :py:func:~driver.optimize(). Carries out one gradient pass,; deciding analytic or finite difference. :returns: :py:class:`~psi4.core.Matrix` |w--w| Total electronic gradient in Hartrees/Bohr. :returns: (:py:class:`~psi4.core.Matrix`, :py:class:`~psi4.core.Wavefunction`) |w--w",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/driver.html:32172,energy,energy,32172,psi4manual/1.1.0/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/driver.html,1,['energy'],['energy']
Energy Efficiency,"args['restart_file'] # Option still available for procedure-specific action; if restartfile != list(restartfile):; restartfile = [restartfile]; # Rename the files to be read to be consistent with psi4's file system; for item in restartfile:; name_split = re.split(r'\.', item); filenum = name_split[len(name_split) - 1]; try:; filenum = int(filenum); except ValueError:; filenum = 32 # Default file number is the checkpoint one; psioh = psi4.IOManager.shared_object(); psio = psi4.IO.shared_object(); filepath = psioh.get_file_path(filenum); namespace = psio.get_default_namespace(); pid = str(os.getpid()); prefix = 'psi'; targetfile = filepath + prefix + '.' + pid + '.' + namespace + '.' + str(filenum); shutil.copy(item, targetfile). wfn = procedures['energy'][lowername](lowername, molecule=molecule, **kwargs). for postcallback in hooks['energy']['post']:; postcallback(lowername, wfn=wfn, **kwargs). optstash.restore(); if return_wfn: # TODO current energy safer than wfn.energy() for now, but should be revisited. # TODO place this with the associated call, very awkward to call this in other areas at the moment; if lowername in ['efp', 'mrcc', 'dmrg', 'psimrcc']:; psi4.print_out(""\n\nWarning! %s does not have an associated derived wavefunction."" % name); psi4.print_out(""The returned wavefunction is the incoming reference wavefunction.\n\n""); elif 'sapt' in lowername:; psi4.print_out(""\n\nWarning! %s does not have an associated derived wavefunction."" % name); psi4.print_out(""The returned wavefunction is the dimer SCF wavefunction.\n\n""). return (psi4.get_variable('CURRENT ENERGY'), wfn); else:; return psi4.get_variable('CURRENT ENERGY'). [docs]def gradient(name, **kwargs):; r""""""Function complementary to :py:func:~driver.optimize(). Carries out one gradient pass,; deciding analytic or finite difference. :returns: :ref:`Matrix<sec:psimod_Matrix>` |w--w| Total electronic gradient in Hartrees/Bohr. :returns: (:ref:`Matrix<sec:psimod_Matrix>`, :ref:`Wavefunction<sec:psimod_Wavefu",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/driver.html:30926,energy,energy,30926,psi4manual/1.0.0/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver.html,1,['energy'],['energy']
Energy Efficiency,"arguments are minimum omega, maximum omega, molecule object; omega = ip_fitting('wb97', 0.4, 2.0, molecule=h2o). This performs IP fitting on water for wB97/cc-pVDZ with density fitting. A; number of neutral and cation single-point computations are run at various values; of \(\omega\), though the later iterations are much faster due to reuse of; the DF tensors, and starting from the neutral/cation orbitals of the previous; \(\omega\). The procedure can also be assisted by providing a tighter guess; for the bounds of \(\omega\). This small test case has a tuned; \(\omega\) of 1.700, hence the bounds of 0.4 and 2.0. Larger systems,; particularly conjugated systems, will typically have an optimized \(\omega\); between 0.1 and 0.5. Fractional Particle Curves¶; The behavior of the electronic energy and HOMO energy across fractional numbers; of electrons is extremely useful for elucidating the MSIE behavior of various; functional technologies. PSI4 features an efficient fractional-particle DFT; code, written into the UKS spin specialization. Due to a combination of DIIS and; reuse of integrals/guess orbitals across a range of fractional occupations, this; code is able to perform fractional occupation curves for systems with up to 60; atoms, across a wide range of the particle number \(N\).; Two python macros exist for this code. The first is frac_traverse(), which is; used to investigate the fractional occupation behavior within one electron above; and below the neutral. An example is:; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17molecule h2o {; 0 1 # must be neutral; O; H 1 1.0; H 1 1.0 2 104.5; # FRAC jobs will be be run in C1 symmetry; }. set {; reference uks # UKS, as we need to do all kinds of weird stuff; basis aug-cc-pvdz # Augmented functions are very important on the anion side; scf_type df; }. # Argument is functional.; # Many optional arguments are available, see the python file; frac_traverse('wb97', molecule=h2o). The other macro is frac_nuke(), w",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/dft-1.html:24349,efficient,efficient,24349,psi4manual/1.2.1/dft-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/dft-1.html,4,['efficient'],['efficient']
Energy Efficiency,"arguments are minimum omega, maximum omega, molecule object; omega = ip_fitting('wb97', 0.4, 2.0, molecule=h2o). This performs IP fitting on water for wB97/cc-pVDZ with density fitting. A; number of neutral and cation single-point computations are run at various values; of \(\omega\), though the later iterations are much faster due to reuse of; the DF tensors, and starting from the neutral/cation orbitals of the previous; \(\omega\). The procedure can also be assisted by providing a tighter guess; for the bounds of \(\omega\). This small test case has a tuned; \(\omega\) of 1.700, hence the bounds of 0.4 and 2.0. Larger systems,; particularly conjugated systems, will typically have an optimized \(\omega\); between 0.1 and 0.5. Fractional Particle Curves¶; The behavior of the electronic energy and HOMO energy across fractional numbers; of electrons is extremely useful for elucidating the MSIE behavior of various; functional technologies. PSI4 features an efficient fractional-particle DFT; code, written into the UKS spin specialization. Due to a combination of DIIS and; reuse of integrals/guess orbitals across a range of fractional occupations, this; code is able to perform fractional occupation curves for systems with up to 60; atoms, across a wide range of the particle number \(N\).; Two python macros exist for this code. The first is frac_traverse(), which is; used to investigate the fractional occupation behavior within one electron above; and below the neutral. An example is:; molecule h2o {; 0 1 # must be neutral; O; H 1 1.0; H 1 1.0 2 104.5; # FRAC jobs will be be run in C1 symmetry; }. set {; reference uks # UKS, as we need to do all kinds of weird stuff; basis aug-cc-pvdz # Augmented functions are very important on the anion side; scf_type df; }. # Argument is functional.; # Many optional arguments are available, see the python file; frac_traverse('wb97', molecule=h2o). The other macro is frac_nuke(), which strips several electrons out of the; system to gathe",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/dft-1.html:25709,efficient,efficient,25709,psi4manual/1.4.0/dft-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/dft-1.html,9,['efficient'],['efficient']
Energy Efficiency,"ariable(""MP3 CORRELATION ENERGY""); psi4.set_variable(""CURRENT ENERGY"",emp3); psi4.set_variable(""CURRENT CORRELATION ENERGY"",cemp3); elif ( lowername == 'mp4(sdq)'):; emp4sdq = psi4.get_variable(""MP4(SDQ) TOTAL ENERGY""); cemp4sdq = psi4.get_variable(""MP4(SDQ) CORRELATION ENERGY""); psi4.set_variable(""CURRENT ENERGY"",emp4sdq); psi4.set_variable(""CURRENT CORRELATION ENERGY"",cemp4sdq); elif ( lowername == 'fno-mp4(sdq)'):; emp4sdq = psi4.get_variable(""MP4(SDQ) TOTAL ENERGY""); cemp4sdq = psi4.get_variable(""MP4(SDQ) CORRELATION ENERGY""); psi4.set_variable(""CURRENT ENERGY"",emp4sdq); psi4.set_variable(""CURRENT CORRELATION ENERGY"",cemp4sdq); elif ( lowername == 'fno-mp4'):; emp4 = psi4.get_variable(""MP4 TOTAL ENERGY""); cemp4 = psi4.get_variable(""MP4 CORRELATION ENERGY""); psi4.set_variable(""CURRENT ENERGY"",emp4); psi4.set_variable(""CURRENT CORRELATION ENERGY"",cemp4); elif (lowername == 'fnocc-mp') and (level == 4):; emp4 = psi4.get_variable(""MP4 TOTAL ENERGY""); cemp4 = psi4.get_variable(""MP4 CORRELATION ENERGY""); psi4.set_variable(""CURRENT ENERGY"",emp4); psi4.set_variable(""CURRENT CORRELATION ENERGY"",cemp4). # restore options; optstash.restore(). return psi4.get_variable(""CURRENT ENERGY""). [docs]def run_cepa(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a cepa-like calculation. >>> energy('cepa(1)'). """"""; lowername = name.lower(); uppername = name.upper(); kwargs = p4util.kwargs_lower(kwargs). # save user options; optstash = p4util.OptionsState(; ['TRANSQT2', 'WFN'],; ['FNOCC', 'NAT_ORBS'],; ['FNOCC', 'RUN_CEPA'],; ['FNOCC', 'USE_DF_INTS'],; ['FNOCC', 'CEPA_NO_SINGLES']). psi4.set_local_option('FNOCC','RUN_CEPA', True); psi4.set_local_option('FNOCC','USE_DF_INTS', False). # what type of cepa?; cepa_level = uppername; if (lowername == 'cepa(2)'):; raise ValidationError(""Error: %s not implemented\n"" % lowername); if (lowername == 'dci'):; cepa_level = 'CISD'; if (lowername == 'sdci'):; cepa_level = 'CISD'. if (lowername == 'fno-cepa(0)'):; cepa_level = ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/proc.html:71954,ENERGY,ENERGY,71954,psi4manual/4.0b5/_modules/proc.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/proc.html,1,['ENERGY'],['ENERGY']
Energy Efficiency,"ariable('CURRENT ENERGY'). for ssuper in superfunctional_list():; if ssuper.name().lower() == name.lower():; dfun = ssuper. if dfun.is_c_hybrid():. # if the df_basis_mp2 basis is not set, pick a sensible one.; if psi4.get_global_option('DF_BASIS_MP2') == '':; ribasis = p4util.corresponding_rifit(psi4.get_global_option('BASIS')); if ribasis:; psi4.set_global_option('DF_BASIS_MP2', ribasis); psi4.print_out(' No DF_BASIS_MP2 auxiliary basis selected, defaulting to %s\n' % (ribasis)); else:; raise ValidationError('Keyword DF_BASIS_MP2 is required.'). if dfun.is_c_scs_hybrid():; psi4.set_local_option('DFMP2', 'MP2_OS_SCALE', dfun.c_os_alpha()); psi4.set_local_option('DFMP2', 'MP2_SS_SCALE', dfun.c_ss_alpha()); psi4.dfmp2(); vdh = dfun.c_alpha() * psi4.get_variable('SCS-MP2 CORRELATION ENERGY'). else:; psi4.dfmp2(); vdh = dfun.c_alpha() * psi4.get_variable('MP2 CORRELATION ENERGY'). psi4.set_variable('DOUBLE-HYBRID CORRECTION ENERGY', vdh); returnvalue += vdh; psi4.set_variable('DFT TOTAL ENERGY', returnvalue); psi4.set_variable('CURRENT ENERGY', returnvalue). optstash.restore(). [docs]def run_dft_gradient(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a density-functional-theory gradient calculation. """"""; optstash = p4util.OptionsState(; ['SCF', 'DFT_FUNCTIONAL'],; ['SCF', 'REFERENCE'],; ['SCF', 'SCF_TYPE']). # Alter default algorithm; if not psi4.has_option_changed('SCF', 'SCF_TYPE'):; psi4.set_local_option('SCF', 'SCF_TYPE', 'DF'). psi4.set_local_option('SCF', 'DFT_FUNCTIONAL', name). user_ref = psi4.get_option('SCF', 'REFERENCE'); if (user_ref == 'RHF'):; psi4.set_local_option('SCF', 'REFERENCE', 'RKS'); elif (user_ref == 'UHF'):; psi4.set_local_option('SCF', 'REFERENCE', 'UKS'); elif (user_ref == 'ROHF'):; raise ValidationError('ROHF reference for DFT is not available.'); elif (user_ref == 'CUHF'):; raise ValidationError('CUHF reference for DFT is not available.'). run_scf_gradient(name, **kwargs). optstash.restore(). [docs]def run_detci(nam",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/proc.html:39284,ENERGY,ENERGY,39284,psi4manual/4.0b5/_modules/proc.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/proc.html,1,['ENERGY'],['ENERGY']
Energy Efficiency,"ariable(self: psi4.core.Wavefunction, arg0: str) → int¶; Removes the requested (case-insensitive) Matrix QC variable. del_potential_variable(self: psi4.core.Wavefunction, arg0: str) → int¶; Removes the requested (case-insensitive) ExternalPotential QC variable. (This function is provisional and might be removed in the future.). del_scalar_variable(self: psi4.core.Wavefunction, arg0: str) → int¶; Removes the requested (case-insensitive) double QC variable. del_variable(key)¶; Removes scalar or array QCVariable key from cls if present. Return type; None. Parameters. cls (psi4.core.Wavefunction) – ; key (str) – . density_fitted(self: psi4.core.Wavefunction) → bool¶; Returns whether this wavefunction was obtained using density fitting or not. diag_h(self: psi4.core.CIWavefunction, arg0: float, arg1: float) → int¶; docstring. doccpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of doubly occupied orbitals per irrep. efzc(self: psi4.core.Wavefunction) → float¶; Returns the frozen-core energy. energy(self: psi4.core.Wavefunction) → float¶; Returns the Wavefunction’s energy. epsilon_a(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the Alpha Eigenvalues. epsilon_a_subset(self: psi4.core.Wavefunction, arg0: str, arg1: str) → psi4.core.Vector¶; Returns the requested Alpha Eigenvalues subset. epsilon_b(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the Beta Eigenvalues. epsilon_b_subset(self: psi4.core.Wavefunction, arg0: str, arg1: str) → psi4.core.Vector¶; Returns the requested Beta Eigenvalues subset. esp_at_nuclei(self: psi4.core.Wavefunction) → psi4.core.Vector¶; returns electrostatic potentials at nuclei. external_pot(self: psi4.core.Wavefunction) → psi4.core.ExternalPotential¶; Gets the requested external potential. force_doccpi(self: psi4.core.Wavefunction, arg0: psi4.core.Dimension) → None¶; Specialized expert use only. Sets the number of doubly occupied oribtals per irrep. Note that this results in inconsistent Wavefun",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/api/psi4.core.ciwavefunction.html:15686,energy,energy,15686,psi4manual/1.4.0/api/psi4.core.ciwavefunction.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/api/psi4.core.ciwavefunction.html,1,['energy'],['energy']
Energy Efficiency,"ariable(self: psi4.core.Wavefunction, arg0: str) → int¶; Removes the requested (case-insensitive) Matrix QC variable. del_potential_variable(self: psi4.core.Wavefunction, arg0: str) → int¶; Removes the requested (case-insensitive) ExternalPotential QC variable. (This function is provisional and might be removed in the future.). del_scalar_variable(self: psi4.core.Wavefunction, arg0: str) → int¶; Removes the requested (case-insensitive) double QC variable. del_variable(key)¶; Removes scalar or array QCVariable key from cls if present. Return type; None. Parameters. cls (psi4.core.Wavefunction) – ; key (str) – . density_fitted(self: psi4.core.Wavefunction) → bool¶; Returns whether this wavefunction was obtained using density fitting or not. diag_h(self: psi4.core.CIWavefunction, arg0: float, arg1: float) → int¶; docstring. doccpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of doubly occupied orbitals per irrep. efzc(self: psi4.core.Wavefunction) → float¶; Returns the frozen-core energy. energy(self: psi4.core.Wavefunction) → float¶; Returns the Wavefunction’s energy. epsilon_a(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the Alpha Eigenvalues. epsilon_a_subset(self: psi4.core.Wavefunction, basis: str, subset: str) → psi4.core.Vector¶; Returns the requested Alpha orbital energies subset. Parameters. basis – {‘AO’, ‘SO’, ‘MO’}; MO or SO select for Pitzer-ordering the return vector in the full computational point group symmetry.; AO selects for Pitzer-ordering the return vector without point group symmetry.; subset – {‘ALL’, ‘ACTIVE’, ‘FROZEN’, ‘OCC’, ‘VIR’, ‘FROZEN_OCC’, ‘ACTIVE_OCC’, ‘ACTIVE_VIR’, ‘FROZEN_VIR’}; Which subspace of orbital energies should be returned?. Returns; A Pitzer-ordered vector of the orbitals. Return type; Vector. epsilon_b(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the Beta Eigenvalues. epsilon_b_subset(self: psi4.core.Wavefunction, basis: str, subset: str) → psi4.core.Vector¶; Returns th",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/api/psi4.core.ciwavefunction.html:15797,energy,energy,15797,psi4manual/1.5.0/api/psi4.core.ciwavefunction.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/api/psi4.core.ciwavefunction.html,4,['energy'],['energy']
Energy Efficiency,"ariable. Syncs with Wavefunction.energy_ if CURRENT ENERGY. set_variable(key, val)¶; Sets scalar or array QCVariable key to val on cls. Return type; None. Parameters. cls (psi4.core.Wavefunction) – ; key (str) – ; val (Union[psi4.core.Matrix, numpy.ndarray, float]) – . shallow_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; Copies the pointers to the internal data. sobasisset(self: psi4.core.Wavefunction) → psi4.core.SOBasisSet¶; Returns the symmetry orbitals basis. soccpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of singly occupied orbitals per irrep. to_file(filename=None)¶; Converts a Wavefunction object to a base class. Parameters. wfn (Wavefunction) – A Wavefunction or inherited class; filename (Optional[str]) – An optional filename to write the data to. Returns; A dictionary and NumPy representation of the Wavefunction. Return type; dict. total_index(self: psi4.core.CCWavefunction, i: int, h: int) → int¶; Map an index (i) within irrep (h) to its energy-sorted index among all roots. variable(key)¶; Return copy of scalar or array QCVariable key from self psi4.core.Wavefunction. Returns; Scalar variables are returned as floats.; Array variables not naturally 2D (like multipoles) are returned as numpy.ndarray of natural dimensionality.; Other array variables are returned as Matrix and may have an extra dimension with symmetry information. Return type; float or numpy.ndarray or Matrix. Parameters. cls (psi4.core.Wavefunction) – ; key (str) – . Example; >>> g, wfn = psi4.gradient(""hf/cc-pvdz"", return_wfn=True); >>> wfn.variable(""CURRENT ENERGY""); -100.00985995185668; >>> wfn.variable(""CURRENT DIPOLE""); array([ 0. , 0. , -0.83217802]); >>> wfn.variable(""CURRENT GRADIENT""); <psi4.core.Matrix object at 0x12d884fc0>; >>> wfn.variable(""CURRENT GRADIENT"").np; array([[ 6.16297582e-33, 6.16297582e-33, -9.41037138e-02],; [-6.16297582e-33, -6.16297582e-33, 9.41037138e-02]]). variables(include_deprecated_keys=False)¶; Ret",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/api/psi4.core.CCWavefunction.html:25664,energy,energy-sorted,25664,psi4manual/1.6.x/api/psi4.core.CCWavefunction.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/api/psi4.core.CCWavefunction.html,2,['energy'],['energy-sorted']
Energy Efficiency,"ariables:. .. hlist::; :columns: 1. * :psivar:`CBS TOTAL ENERGY`; * :psivar:`CBS REFERENCE ENERGY`; * :psivar:`CBS CORRELATION ENERGY`; * :psivar:`CURRENT ENERGY`; * :psivar:`CURRENT REFERENCE ENERGY`; * :psivar:`CURRENT CORRELATION ENERGY`. .. caution:: Some features are not yet implemented. Buy a developer a coffee. - No way to tell function to boost fitting basis size for all calculations. - Need to add more extrapolation schemes. As represented in the equation below, a CBS energy method is defined in several; sequential stages (scf, corl, delta1, delta2, ... ) covering treatment; of the reference total energy, the correlation energy, a delta correction to the; correlation energy, and a second delta correction, etc.. Each is activated by its; stage_wfn keyword, or as a field in the ```cbs_metadata``` list, and is only; allowed if all preceding stages are active. .. include:: /cbs_eqn.rst. * Energy Methods; The presence of a stage_wfn keyword is the indicator to incorporate; (and check for stage_basis and stage_scheme keywords) and compute; that stage in defining the CBS energy. The cbs() function requires, at a minimum, ``name='scf'`` and ``scf_basis``; keywords to be specified for reference-step only jobs and ``name`` and; ``corl_basis`` keywords for correlated jobs. The following energy methods have been set up for cbs(). .. hlist::; :columns: 5. * scf; * hf; * mp2; * mp2.5; * mp3; * mp4(sdq); * mp4; * mp\ *n*; * omp2; * omp2.5; * omp3; * olccd; * lccd; * lccsd; * cepa(0); * cepa(1); * cepa(3); * acpf; * aqcc; * qcisd; * cc2; * ccsd; * fno-ccsd; * bccd; * cc3; * qcisd(t); * ccsd(t); * fno-ccsd(t); * bccd(t); * cisd; * cisdt; * cisdtq; * ci\ *n*; * fci; * mrccsd; * mrccsd(t); * mrccsdt; * mrccsdt(q). :type name: str; :param name: ``'scf'`` || ``'ccsd'`` || etc. First argument, usually unlabeled. Indicates the computational method; for the correlation energy, unless only reference step to be performed,; in which case should be ``'scf'``. Overruled if stage_wfn key",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html:35440,energy,energy,35440,psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html,21,"['Energy', 'energy']","['Energy', 'energy']"
Energy Efficiency,"arizability at two frequencies. casscf-fzc-sp; CASSCF/6-31G** energy point. omp2p5-grad2; OMP2.5 cc-pVDZ gradient for the NO radical. rasci-c2-active; 6-31G* C2 Test RASCI Energy Point, testing two different ways of specifying the active space, either with the ACTIVE keyword, or with RAS1, RAS2, RESTRICTED_DOCC, and RESTRICTED_UOCC. sapt4; SAPT2+(3) aug-cc-pVDZ computation of the formamide dimer interaction energy, using the aug-cc-pVDZ-JKFIT DF basis for SCF and aug-cc-pVDZ-RI for SAPT. This example uses frozen core as well as MP2 natural orbital approximations. omp3-grad2; OMP3 cc-pVDZ gradient for the NO radical. cc31; CCSD/sto-3g optical rotation calculation (both gauges) at two frequencies on methyloxirane. cc50; EOM-CC3(ROHF) on CH radical with user-specified basis and properties for particular root. dfccsd-grad1; DF-CCSD cc-pVDZ gradients for the H2O molecule. cc8b; ROHF-CCSD cc-pVDZ frozen-core energy for the state of the CN radical, with Cartesian input. cbs-xtpl-energy; Extrapolated water energies. mp2p5-grad2; MP2.5 cc-pVDZ gradient for the NO radical. props3; DF-SCF cc-pVDZ multipole moments of benzene, up to 7th order and electrostatic potentials evaluated at the nuclear coordinates. omp2p5-2; OMP2 cc-pVDZ energy for the H2O molecule. opt14; 6-31G(d) optimization of SF4 starting from linear bond angle that is not linear in the optimized structure but is in a symmetry plane of the molecule. scf-bz2; Benzene Dimer Out-of-Core HF/cc-pVDZ. frac; Carbon/UHF Fractionally-Occupied SCF Test Case. ocepa2; OCEPA cc-pVDZ energy with B3LYP initial guess for the NO radical. soscf1; Second-order SCF convergnece: Benzene. omp2-4; SCS-OMP2 cc-pVDZ geometry optimization for the H2O molecule. cc13; UHF-CCSD/cc-pVDZ CH2 geometry optimization via analytic gradients. cc8a; ROHF-CCSD(T) cc-pVDZ frozen-core energy for the state of the CN radical, with Cartesian input. molden1; Test of the superposition of atomic densities (SAD) guess, using a highly distorted water geometry w",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_testsuite_corepsi4-1.html:15285,energy,energy,15285,psi4manual/1.0.0/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_testsuite_corepsi4-1.html,4,['energy'],['energy']
Energy Efficiency,"arrow grid error. dfccsd1; DF-CCSD cc-pVDZ energy for the H2O molecule. adc1; ADC(2)/6-31G** on H2O using builtin ADC module. cc5; RHF CCSD(T) aug-cc-pvtz frozen-core energy of C4NH4 Anion. scf-uhf-grad-nobeta; UHF gradient for a one-electron system (no beta electrons). cc24; Single point gradient of 1-2B1 state of H2O+ with EOM-CCSD. cc46; EOM-CC2/cc-pVDZ on H2O2 with two excited states in each irrep. dfccdl1; DF-CCDL cc-pVDZ energy for the H2O molecule. omp2-5; SOS-OMP2 cc-pVDZ geometry optimization for the H2O molecule. dft-grad-meta; meta-GGA gradients of water and ssh molecules reference gradients updated due to new BraggSlater radii. cc2; 6-31G** H2O CCSD optimization by energies, with Z-Matrix input. dfomp3-2; DF-OMP3 cc-pVDZ energy for the H2O+ cation. freq-isotope2; Vibrational and thermo analysis of several water isotopologs. Demonstrates Hessian reuse for different temperatures, pressures, and isotopologs. fci-h2o-2; 6-31G H2O Test FCI Energy Point. tu2-ch2-energy; Sample UHF/6-31G** CH2 computation. nbody-intermediates; HF/cc-pVDZ many body energies of an arbitrary noble gas trimer complex Size vs cost tradeoff is rough here. dft-freq; Frequencies for H2O B3LYP/6-31G* at optimized geometry. fnocc7; Test fnocc with linear dependencies. cisd-h2o+-2; 6-31G** H2O+ Test CISD Energy Point. scf-response1; Compute the dipole, quadrupole, and traceless quadrupoles for water. opt8; Various constrained energy minimizations of HOOH with cc-pvdz RHF. Cartesian-coordinate constrained optimizations of HOOH in Cartesians. extern1; External potential calculation involving a TIP3P water and a QM water. Finite different test of the gradient is performed to validate forces. nbody-vmfc-gradient; Computation of VMFC-corrected water trimer gradient (geometry from J. Chem. Theory Comput. 11, 2126-2136 (2015)). dft-custom-mgga; updated dldf reference to new BraggSlater radii Dispersionless density functional (dlDF+D) internal match to Psi4 Extensive testing has been done to matc",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/autodoc_testsuite_corepsi4-1.html:10494,energy,energy,10494,psi4manual/1.5.0/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/autodoc_testsuite_corepsi4-1.html,4,['energy'],['energy']
Energy Efficiency,"arrow\infty} v_{\mathrm{x}}^{\mathrm{Local}} (r) = 0\]; IP-tuned LRC functionals effectively pin the chemical potential at \(N\); electrons to the correct value determined by the ionization potential. This; often cleans up the MSIE problem for a surprisingly large number of high-lying; occupied orbitals, as determined by fractional particle curves. Other gap; fitting techniques involving the electron affinity or band gap are sometimes; also used. IP-fitting is found to be particularly critical for the qualitative; determination of excited state ordering in many low band-gap systems.; For dispersion-bound complexes, a very simple additive empirical dispersion; potential, based on a damped Lennard-Jones potential can often produce; remarkably accurate results with KS-DFT. This approach was championed by Grimme,; whose “-D2” and more modern “-D3” approaches are a de facto industry standards. Minimal Input¶; Minimal input for a KS-DFT computation is a molecule block, basis set; option, and a call to energy('b3lyp') (or other valid functional name):; 1; 2; 3; 4; 5; 6; 7molecule {; He; }. set basis sto-3g. energy('b3lyp'). This will run a B3LYP Restricted Kohn–Sham (RKS) on neutral singlet Helium in; \(D_{2h}\) spatial symmetry with a minimal STO-3G basis, 1.0E-6 energy; and density convergence criteria, a DF ERI algorithm, symmetric; orthogonalization, DIIS, and a core Hamiltonian guess (because single atom). For more information on; any of these options, see the relevant section below, or in the preceding; Hartree–Fock section. Spin/Symmetry Treatment¶; PSI4 implements the most popular spin specializations of KS-DFT, including:. Restricted Kohn–Sham (RKS) [Default]; Appropriate only for closed-shell singlet systems, but twice as efficient; as the other flavors, as the alpha and beta densities are constrained to be; identical.; Unrestricted Kohn–Sham (UKS); Appropriate for most open-shell systems and fairly easy to converge.; The spatial parts of the alpha and beta orbit",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/dft-1.html:12436,energy,energy,12436,psi4manual/1.2.1/dft-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/dft-1.html,6,['energy'],['energy']
Energy Efficiency,"arry out coupled cluster calculations within PSI4.; For higher-order coupled-cluster methods like CCSDT and CCSDTQ, PSI4; can interface to Kállay’s MRCC code (see MRCC).; Solvent effects on energies can be taken into account using the polarizable; continuum model (PCM) in the PTE approximation [Cammi:2009:164104], see; PCM. Current coupled cluster capabilities of PSI4¶. Method; Reference; Energy; Gradient; Exc. Energies; LR Props. CC2; RHF; Y; Y; Y; Y. UHF; Y; —; N; —. ROHF; Y; —; N; —. CCSD; RHF; Y; Y; Y; Y. UHF; Y; Y; Y; —. ROHF; Y; Y; Y; —. CCSD(T); RHF; Y; Y; n/a; n/a. UHF; Y; Y; n/a; n/a. ROHF; Y; —; n/a; n/a. A-CCSD(T) 1; RHF; Y; —; n/a; n/a. CC3; RHF; Y; —; Y; —. UHF; Y; —; Y; —. ROHF; Y; —; Y; —. CCD; Brueckner; Y; N; N; N. CCD(T); Brueckner; Y; N; n/a; n/a. Footnotes. 1; Also known as CCSD(AT), Lambda-CCSD(T), CCSD(T)_L. The following wavefunctions are currently recognized by PSI4 as arguments; to functions like energy(): 'ccsd', 'ccsd(t)', 'a-ccsd(t)', 'cc2',; 'cc3', 'bccd' (CCD with Brueckner orbitals), 'bccd(t)' (CCD(T) with; Brueckner orbitals), 'eom-ccsd', 'eom-cc2' (CC2 for excited states),; 'eom-cc3' (CC3 for excited states). Response properties can be obtained; by calling the function properties() (instead of, for example, energy(),; e.g., properties('ccsd'). There are many sample; coupled cluster inputs provided in psi4/samples. Basic Keywords¶; A complete list of keywords related to coupled-cluster computations is; provided in the appendices, with the majority of the relevant; keywords appearing in Appendix CCENERGY. For a standard ground-state; CCSD or CCSD(T) computation, the following keywords are common:. REFERENCE¶. Reference wavefunction type. Type: string; Possible Values: RHF, ROHF, UHF; Default: RHF. R_CONVERGENCE¶. Convergence criterion for wavefunction (change) in CC amplitude equations. Type: conv double; Default: 1e-7. MAXITER¶. Maximum number of iterations to solve the CC equations. Type: integer; Default: 50. BRUECKNER_ORBS_R_CONVER",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/cc-1.html:3962,energy,energy,3962,psi4manual/1.5.0/cc-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/cc-1.html,3,['energy'],['energy']
Energy Efficiency,"arser; mtd/basis syntax examples. casscf-fzc-sp; CASSCF/6-31G** energy point. scf-hess4; DF SCF 6-31G UHFl vs RHF test Tests DF UHF hessian code for Ca = Cb. dft-pruning; Tests all grid pruning options available and screening of small weights. Check against grid size. dft-custom-hybrid; DFT (hybrids) test of implementations in: hybrid_superfuncs.py. nbody-intermediates; HF/cc-pVDZ many body energies of an arbitrary noble gas trimer complex Size vs cost tradeoff is rough here. isapt2; This is a shorter version if isapt1 - does not do cube plots. See isapt1 for full details. cbs-xtpl-func; optimization with method defined via cbs. extern2; External potential calculation involving a TIP3P water and a QM water for DFMP2. Finite different test of the gradient is performed to validate forces. x2c1; Test of SFX2C-1e on water uncontracted cc-pVDZ-DK The reference numbers are from Lan Cheng’s implementation in Cfour. fci-h2o-2; 6-31G H2O Test FCI Energy Point. cbs-xtpl-energy; Extrapolated water energies - density-fitted version. nbody-convergence; Convergence of many-body gradients of different BSSE schemes. cc2; 6-31G** H2O CCSD optimization by energies, with Z-Matrix input. tu3-h2o-opt; Optimize H2O HF/cc-pVDZ. tdscf-4; td-wb97x singlet excitation energies of methylene (tda). nbody-multi-level; Multilevel computation of water trimer energy (geometry from J. Chem. Theory Comput. 11, 2126-2136 (2015)). pywrap-all; Intercalls among python wrappers- database, cbs, optimize, energy, etc. Though each call below functions individually, running them all in sequence or mixing up the sequence is aspirational at present. Also aspirational is using the intended types of gradients. tdscf-6; td-camb3lyp with DiskDF and method/basis specification. dfccsd-grad2; DF-CCSD cc-pVDZ gradient for the NH molecule. cubeprop; RHF orbitals and density for water. dft-smoke; DFT Functional Smoke Test. nbody-freq; Vibrational and thermo analysis of water trimer (geometry from J. Chem. Theory Comput. 1",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/autodoc_testsuite_corepsi4.html:5531,energy,energy,5531,psi4manual/1.9.x/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/autodoc_testsuite_corepsi4.html,2,['energy'],['energy']
Energy Efficiency,"art """"""; """"""using the last geometry in the output, after """"""; """"""carefully making sure all symmetry-dependent """"""; """"""input, such as DOCC, is correct."""""" % (current_sym, initial_sym)); kwargs['opt_iter'] = n. # Use orbitals from previous iteration as a guess; # set within loop so that can be influenced by fns to optimize (e.g., cbs); if (n > 1) and (not core.get_option('SCF', 'GUESS_PERSIST')):; core.set_local_option('SCF', 'GUESS', 'READ'). # Before computing gradient, save previous molecule and wavefunction if this is an IRC optimization; if (n > 1) and (core.get_option('OPTKING', 'OPT_TYPE') == 'IRC'):; old_thisenergy = core.variable('CURRENT ENERGY'). # Compute the gradient - preserve opt data despite core.clean calls in gradient; core.IOManager.shared_object().set_specific_retention(1, True); G, wfn = gradient(lowername, return_wfn=True, molecule=moleculeclone, **kwargs); thisenergy = core.variable('CURRENT ENERGY'). # above, used to be getting energy as last of energy list from gradient(); # thisenergy below should ultimately be testing on wfn.energy(). # Record optimization steps; # Add wavefunctions later; if return_history:; step_energies.append(thisenergy); step_coordinates.append(moleculeclone.geometry()); step_gradients.append(G.clone()). core.set_legacy_gradient(G). # opt_func = kwargs.get('opt_func', kwargs.get('func', energy)); # if opt_func.__name__ == 'complete_basis_set':; # core.IOManager.shared_object().set_specific_retention(1, True). if full_hess_every > -1:; core.set_global_option('HESSIAN_WRITE', True). # compute Hessian as requested; frequency wipes out gradient so stash it; if ((full_hess_every > -1) and (n == 1)) or (steps_since_last_hessian + 1 == full_hess_every):; G = core.get_legacy_gradient() # TODO; core.IOManager.shared_object().set_specific_retention(1, True); core.IOManager.shared_object().set_specific_path(1, './'); frequencies(hessian_with_method, molecule=moleculeclone, **kwargs); steps_since_last_hessian = 0; core.set_legacy_gr",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver.html:57663,energy,energy,57663,psi4manual/1.3.2/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver.html,2,['energy'],['energy']
Energy Efficiency,"art """"""; """"""using the last geometry in the output, after """"""; """"""carefully making sure all symmetry-dependent """"""; """"""input, such as DOCC, is correct."""""" % (current_sym, initial_sym)); kwargs['opt_iter'] = n. # Use orbitals from previous iteration as a guess; # set within loop so that can be influenced by fns to optimize (e.g., cbs); if (n > 1) and (not core.get_option('SCF', 'GUESS_PERSIST')):; core.set_local_option('SCF', 'GUESS', 'READ'). # Before computing gradient, save previous molecule and wavefunction if this is an IRC optimization; if (n > 1) and (core.get_option('OPTKING', 'OPT_TYPE') == 'IRC'):; old_thisenergy = core.variable('CURRENT ENERGY'). # Compute the gradient - preserve opt data despite core.clean calls in gradient; core.IOManager.shared_object().set_specific_retention(1, True); G, wfn = gradient(lowername, return_wfn=True, molecule=moleculeclone, **kwargs); thisenergy = core.variable('CURRENT ENERGY'). # above, used to be getting energy as last of energy list from gradient(); # thisenergy below should ultimately be testing on wfn.energy(). # Record optimization steps; # Add wavefunctions later; if return_history:; step_energies.append(thisenergy); step_coordinates.append(moleculeclone.geometry()); step_gradients.append(G.clone()). core.set_legacy_gradient(G). # opt_func = kwargs.get('opt_func', kwargs.get('func', energy)); # if opt_func.__name__ == 'complete_basis_set':; # core.IOManager.shared_object().set_specific_retention(1, True). if full_hess_every > -1:; core.set_global_option('HESSIAN_WRITE', True). # compute Hessian as requested; frequency wipes out gradient so stash it; if ((full_hess_every > -1) and (n == 1)) or (steps_since_last_hessian + 1 == full_hess_every):; G = core.get_legacy_gradient() # TODO; core.IOManager.shared_object().set_specific_retention(1, True); core.IOManager.shared_object().set_specific_path(1, './'); frequencies(hessian_with_method, molecule=moleculeclone, ref_gradient = G, **kwargs); steps_since_last_hessian = 0; ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:70259,energy,energy,70259,psi4manual/1.4.0/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html,8,['energy'],['energy']
Energy Efficiency,"art using DIIS. Type: integer; Default: 1. DIPMOM (DETCI)¶DETCI — Do compute the dipole moment?. Type: boolean; Default: false. DIPMOM (FNOCC)¶FNOCC — Compute the dipole moment? Note that dipole moments are only available in the FNOCC module for the ACPF, AQCC, CISD, and CEPA(0) methods. Type: boolean; Default: false. DISP_SIZE (FINDIF)¶FINDIF — Displacement size in au for finite-differences. Type: double; Default: 0.005. DISTRIBUTED_MATRIX (SCF)¶SCF (Expert) — The dimension sizes of the distributed matrix. Type: array; Default: No Default. DKH_ORDER (GLOBALS)¶GLOBALS (Expert) — Order of Douglas-Kroll-Hess. Type: integer; Default: 2. DMRG_CASPT2_CALC (DMRG)¶DMRG — Do calculate the DMRG-CASPT2 energy after the DMRGSCF calculations are done?. Type: boolean; Default: false. DMRG_CASPT2_IMAG (DMRG)¶DMRG — CASPT2 Imaginary shift. Type: double; Default: 0.0. DMRG_CASPT2_IPEA (DMRG)¶DMRG — CASPT2 IPEA shift. Type: double; Default: 0.0. DMRG_CASPT2_ORBS (DMRG)¶DMRG — Whether to calculate the DMRG-CASPT2 energy after the DMRGSCF calculations are done. Type: string; Possible Values: PSEUDOCANONICAL, ACTIVE; Default: PSEUDOCANONICAL. DMRG_DIIS (DMRG)¶DMRG — Whether or not to use DIIS for DMRG. Type: boolean; Default: false. DMRG_DIIS_WRITE (DMRG)¶DMRG — Whether or not to store the DIIS checkpoint on disk (convenient for restarting). Type: boolean; Default: true. DMRG_EXCITATION (DMRG)¶DMRG — Which root is targeted: 0 means ground state, 1 first excited state, etc. Type: integer; Default: 0. DMRG_IRREP (DMRG)¶DMRG — The DMRG wavefunction irrep uses the same conventions as PSI4. How convenient :-). Just to avoid confusion, it’s copied here. It can also be found on http://sebwouters.github.io/CheMPS2/doxygen/classCheMPS2_1_1Irreps.html . Symmetry Conventions Irrep Number & Name Group Number & Name 0 1 2 3 4 5 6 7 0: c1 A 1: ci Ag Au 2: c2 A B 3: cs A’ A’’ 4: d2 A B1 B2 B3 5: c2v A1 A2 B1 B2 6: c2h Ag Bg Au Bu 7: d2h Ag B1g B2g B3g Au B1u B2u B3u. Type: integer; Default: -1. DMRG_",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/autodoc_glossary_options_c-1.html:110411,energy,energy,110411,psi4manual/1.4.0/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodoc_glossary_options_c-1.html,2,['energy'],['energy']
Energy Efficiency,"artesian coordinates. cisd-h2o-clpse; 6-31G** H2O Test CISD Energy Point with subspace collapse. dfmp2_2; Density fitted MP2 energy of H2, using density fitted reference and automatic looping over cc-pVDZ and cc-pVTZ basis sets. Results are tabulated using the built in table functions by using the default options and by specifiying the format. cc24; Single point gradient of 1-2B1 state of H2O+ with EOM-CCSD. cc14; ROHF-CCSD/cc-pVDZ CH2 geometry optimization via analytic gradients. cc29; CCSD/cc-pVDZ optical rotation calculation (both gauges) on Cartesian H2O2. dfscf-bz2; Benzene Dimer DF-HF/cc-pVDZ. matrix1; An example of using BLAS and LAPACK calls directly from the Psi input file, demonstrating matrix multiplication, eigendecomposition, Cholesky decomposition and LU decomposition. These operations are performed on vectors and matrices provided from the Psi library. cc36; CC2(RHF)/cc-pVDZ energy of H2O. mp2_1; All-electron MP2 6-31G** geometry optimization of water. cc37; CC2(UHF)/cc-pVDZ energy of H2O+. psimrcc-ccsd_t-4; Mk-MRCCSD(T) single point. O$_3` state described using the Ms = 0 component of the singlet. Uses TCSCF orbitals. zaptn-nh2; ZAPT(n)/6-31G NH2 Energy Point, with n=2-25. cc5; RHF CCSD(T) aug-cc-pvtz frozen-core energy of C4NH4 Anion. mints1; Symmetry tests for a range of molecules. This doesn’t actually compute any energies, but serves as an example of the many ways to specify geometries in Psi4. props2; DF-SCF cc-pVDZ of benzene-hydronium ion, scanning the dissociation coordinate with Python’s built-in loop mechanism. The geometry is specified by a Z-matrix with dummy atoms, fixed parameters, updated parameters, and separate charge/multiplicity specifiers for each monomer. One-electron properties computed for dimer and one monomer. tu5-sapt; Example SAPT computation for ethene*ethine (i.e., ethylene*acetylene), test case 16 from the S22 database. dcft1; DCFT-06 calculation for the He dimer. This performs a simultaneous update of the orbitals and cu",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/autodoc_testsuite-1.html:15659,energy,energy,15659,psi4manual/4.0b2/autodoc_testsuite-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/autodoc_testsuite-1.html,4,['energy'],['energy']
Energy Efficiency,"artfile, targetfile); else:; # if the df_basis_scf basis is not set, pick a sensible one.; if PsiMod.get_global_option('DF_BASIS_SCF') == '':; jkbasis = corresponding_jkfit(PsiMod.get_global_option('BASIS')); if jkbasis:; PsiMod.set_global_option('DF_BASIS_SCF', jkbasis); PsiMod.print_out('\nNo DF_BASIS_SCF auxiliary basis selected, defaulting to %s\n\n' % (jkbasis)); else:; raise ValidationError('Keyword DF_BASIS_SCF is required.'). scf_helper(name, **kwargs). PsiMod.print_out('\n'); banner('DFMP2'); PsiMod.print_out('\n'). # if the df_basis_mp2 basis is not set, pick a sensible one.; if PsiMod.get_global_option('DF_BASIS_MP2') == '':; ribasis = corresponding_rifit(PsiMod.get_global_option('BASIS')); if ribasis:; PsiMod.set_global_option('DF_BASIS_MP2', ribasis); PsiMod.print_out('No DF_BASIS_MP2 auxiliary basis selected, defaulting to %s\n' % (ribasis)); else:; raise ValidationError('Keyword DF_BASIS_MP2 is required.'). PsiMod.dfmp2grad(); e_dfmp2 = PsiMod.get_variable('MP2 TOTAL ENERGY'); e_scs_dfmp2 = PsiMod.get_variable('SCS-MP2 TOTAL ENERGY'). optstash.restore(). if (name.upper() == 'SCS-DFMP2') or (name.upper() == 'SCS-DF-MP2'):; return e_scs_dfmp2; elif (name.upper() == 'DF-MP2') or (name.upper() == 'DFMP2') or (name.upper() == 'MP2'):; return e_dfmp2. [docs]def run_eom_cc(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; an EOM-CC calculation, namely EOM-CC2, EOM-CCSD, and EOM-CC3. """"""; optstash = OptionsState(; ['TRANSQT2', 'WFN'],; ['CCSORT', 'WFN'],; ['CCENERGY', 'WFN'],; ['CCHBAR', 'WFN'],; ['CCEOM', 'WFN']). if (name.lower() == 'eom-ccsd'):; PsiMod.set_local_option('TRANSQT2', 'WFN', 'EOM_CCSD'); PsiMod.set_local_option('CCSORT', 'WFN', 'EOM_CCSD'); PsiMod.set_local_option('CCENERGY', 'WFN', 'EOM_CCSD'); PsiMod.set_local_option('CCHBAR', 'WFN', 'EOM_CCSD'); PsiMod.set_local_option('CCEOM', 'WFN', 'EOM_CCSD'); run_ccenergy('ccsd', **kwargs); elif (name.lower() == 'eom-cc2'):; PsiMod.set_local_option('TRANSQT2', 'WFN', 'EOM_CC2'); P",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/_modules/proc.html:31885,ENERGY,ENERGY,31885,psi4manual/4.0b4/_modules/proc.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/proc.html,1,['ENERGY'],['ENERGY']
Energy Efficiency,"arting points for most computations, so this code is called in most cases. DFT FUNCTIONAL TOTAL ENERGY; DFT TOTAL ENERGY; DFT TOTAL GRADIENT; DFT TOTAL HESSIAN; DFT VV10 ENERGY; DFT XC ENERGY; DISPERSION CORRECTION ENERGY; DOUBLE-HYBRID CORRECTION ENERGY; GRID ELECTRONS ALPHA; GRID ELECTRONS BETA; GRID ELECTRONS TOTAL; HF KINETIC ENERGY; HF POTENTIAL ENERGY; HF TOTAL ENERGY; HF TOTAL GRADIENT; HF TOTAL HESSIAN; HF VIRIAL RATIO; NUCLEAR REPULSION ENERGY; ONE-ELECTRON ENERGY; SCF ITERATIONS; SCF STABILITY EIGENVALUES (array); SCF TOTAL ENERGY; SCF TOTAL GRADIENT; SCF TOTAL HESSIAN; TD-fctl ROOT 0 (IN h) -> ROOT n (IN i) EXCITATION ENERGY; TD-fctl ROOT 0 (IN h) -> ROOT n (IN i) OSCILLATOR STRENGTH (LEN); TD-fctl ROOT 0 (IN h) -> ROOT n (IN i) OSCILLATOR STRENGTH (VEL); TD-fctl ROOT 0 (IN h) -> ROOT n (IN i) ROTATORY STRENGTH (LEN); TD-fctl ROOT 0 (IN h) -> ROOT n (IN i) ROTATORY STRENGTH (VEL); TD-fctl ROOT 0 (h) -> ROOT n (i) EXCITATION ENERGY; TD-fctl ROOT 0 (h) -> ROOT n (i) OSCILLATOR STRENGTH (LEN); TD-fctl ROOT 0 (h) -> ROOT n (i) OSCILLATOR STRENGTH (VEL); TD-fctl ROOT 0 (h) -> ROOT n (i) ROTATORY STRENGTH (LEN); TD-fctl ROOT 0 (h) -> ROOT n (i) ROTATORY STRENGTH (VEL); TD-fctl ROOT 0 -> ROOT n EXCITATION ENERGY; TD-fctl ROOT 0 -> ROOT n EXCITATION ENERGY - h TRANSITION; TD-fctl ROOT 0 -> ROOT n OSCILLATOR STRENGTH (LEN); TD-fctl ROOT 0 -> ROOT n OSCILLATOR STRENGTH (LEN) - h TRANSITION; TD-fctl ROOT 0 -> ROOT n OSCILLATOR STRENGTH (VEL); TD-fctl ROOT 0 -> ROOT n OSCILLATOR STRENGTH (VEL) - h TRANSITION; TD-fctl ROOT 0 -> ROOT n ROTATORY STRENGTH (LEN); TD-fctl ROOT 0 -> ROOT n ROTATORY STRENGTH (LEN) - h TRANSITION; TD-fctl ROOT 0 -> ROOT n ROTATORY STRENGTH (VEL); TD-fctl ROOT 0 -> ROOT n ROTATORY STRENGTH (VEL) - h TRANSITION; TD-fctl ROOT n (IN h) TOTAL ENERGY; TD-fctl ROOT n (h) TOTAL ENERGY; TD-fctl ROOT n TOTAL ENERGY; TD-fctl ROOT n TOTAL ENERGY - h TRANSITION; TWO-ELECTRON ENERGY. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .   ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/autodir_psivariables/module__scf.html:326,ENERGY,ENERGY,326,psi4manual/1.7.x/autodir_psivariables/module__scf.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/autodir_psivariables/module__scf.html,84,['ENERGY'],['ENERGY']
Energy Efficiency,"artree2kcalmol * (2*h_energy - h2_energy); print (""De = %f"" % D_e). h2 = psi4.geometry(""""""; H; H 1 0.9; """"""). psi4.set_options({""basis"": ""cc-pvdz"",; ""reference"": ""rhf""}); h2_energy = psi4.energy('scf'). h = psi4.geometry(""""""; H; """"""). psi4.set_options({""basis"": ""cc-pvdz"",; ""reference"": ""uhf""}); h_energy = psi4.energy('scf'). D_e = psi4.constants.hartree2kcalmol * (2*h_energy - h2_energy); print(""De = %f"" % D_e). The energy() function returns the final result of the; computation, the requested total energy in Hartrees, which we assign to a; Python variable. The two energies are then converted to a dissociation; energy and printed to the output file using standard Python notation.; Generally, there are multiple quantities of interest. Appendix; PSI Variables by Module lists PSI variables variables set by each; module, and PSI Variables by Alpha defines them. These can be; accessed through the variable() function. For example, after; performing a density fitted MP2 computation, both the spin component; scaled energy and the unscaled MP2 energy are made available. PSIthonPsiAPIe_mp2 = variable('MP2 TOTAL ENERGY'); e_scs_mp2 = variable('SCS-MP2 TOTAL ENERGY'). e_mp2 = psi4.variable('MP2 TOTAL ENERGY'); e_scs_mp2 = psi4.variable('SCS-MP2 TOTAL ENERGY'). Each module and the Python driver set PSI variables over the course of a; calculation. The values for all can be printed in the output file with; the input file command print_variables(). Note that PSI variables; are cleared at the start of each energy(), etc. in an input; file by clean_variables().; So if you run in a single input file a STO-3G FCI followed by a; aug-cc-pVQZ SCF followed by a print_variables() command, the; last will include SCF TOTAL ENERGY but not; FCI TOTAL ENERGY.; The entire dictionary of PSI variables can be obtained through; get_variables(). Return Values¶; Most of the usual user computation functions (i.e.,; energy(), optimize(), and; frequency()) return simply the current total energy.; Consult t",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/psithoninput.html:9067,energy,energy,9067,psi4manual/master/psithoninput.html,https://psicode.org,https://psicode.org/psi4manual/master/psithoninput.html,2,['energy'],['energy']
Energy Efficiency,"artree2kcalmol; print("" {:3.1f} {:1.6f}"".format(R, e)). # Prints to output.dat; psi4.core.print_out(""CP-corrected CCSD(T)/aug-cc-pVDZ Interaction Energies\n\n""); psi4.core.print_out("" R [Ang] E_int [kcal/mol] \n""); psi4.core.print_out(""---------------------------------------------------------\n""); for R in Rvals:; e = ecp[R] * psi4.constants.hartree2kcalmol; psi4.core.print_out("" {:3.1f} {:1.6f}\n"".format(R, e)). CP-corrected CCSD(T)/aug-cc-pVDZ Interaction Energies. R [Ang] E_int [kcal/mol]; ---------------------------------------------------------; 2.5 0.758605; 3.0 0.015968; 4.0 -0.016215. First, you can see the geometry string ne2_geometry has a two dashes; to separate the monomers from each other. Also note we’ve used a; Z-matrix to specify the geometry, and we’ve used a variable (R) as; the interatomic distance. We have not specified the value of R in; the ne2_geometry string like we normally would. That’s because we; are going to vary it during the scan across the potential energy; surface, by using a Python loop over the list of interatomic distances; Rvals. Before we are able to pass our molecule to Psi4, we need to; do two things. First, we must set the value of the intermolecular; separation in our Z-matrix (by using Python 3 string; formatting); to the particular value of R. Second, we need to turn the Z-matrix; string into a Psi4 molecule, by passing it to; `psi4.geometry() <http://psicode.org/psi4manual/master/api/psi4.driver.geometry.html#psi4.driver.geometry>`__.; The argument bsse_type='cp' tells Psi4 to perform counterpoise (CP); correction on the dimer to compute the CCSD(T)/aug-cc-pVDZ interaction; energy, which is stored in our ecp dictionary at each iteration of; our Python loop. Note that we didn’t need to specify ghost atoms, and we; didn’t need to call the monomer and dimer computations separately. Psi4; does it all for us, automatically.; Near the very end of the output file output.dat, the counterpoise; correction Python function will prin",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/psiapi-1.html:20494,energy,energy,20494,psi4manual/1.1.0/psiapi-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/psiapi-1.html,4,['energy'],['energy']
Energy Efficiency,"artswith(""MBIS""):; if key.upper().endswith(""CHARGES""):; return val.np; elif key.upper().endswith(""DIPOLES""):; reshaper = (-1, 3); return val.np.reshape(reshaper); elif key.upper().endswith(""QUADRUPOLES""):; val = val.np.reshape(-1, 6); val = np.array([_multipole_plumper(val[iat], 2) for iat in range(len(val))]); return val; elif key.upper().endswith(""OCTUPOLES""):; val = val.np.reshape(-1, 10); val = np.array([_multipole_plumper(val[iat], 3) for iat in range(len(val))]); return val; elif key.upper().endswith(""DIPOLE"") or ""DIPOLE -"" in key.upper():; reshaper = (3, ); elif ""QUADRUPOLE POLARIZABILITY TENSOR"" in key.upper():; reshaper = (3, 3, 3); elif any((key.upper().endswith(p) or f""{p} -"" in key.upper()) for p in _multipole_order):; p = [p for p in _multipole_order if (key.upper().endswith(p) or f""{p} -"" in key.upper())]; return _multipole_plumper(val.np.reshape((-1, )), _multipole_order.index(p[0])); elif key.upper() in [""MULLIKEN_CHARGES"", ""LOWDIN_CHARGES"", ""MULLIKEN CHARGES"", ""LOWDIN CHARGES"", ""SCF TOTAL ENERGIES""]:; reshaper = (-1, ); if reshaper:; return val.np.reshape(reshaper); else:; return val. def _multipole_compressor(complete: np.ndarray, order: int) -> np.ndarray:; """"""Form flat unique components multipole array from complete Cartesian array. Parameters; ----------; order; Multipole order. e.g., 1 for dipole, 4 for hexadecapole.; complete; Multipole array, order-dimensional Cartesian array expanded to complete components. Returns; -------; compressed : numpy.ndarray; Multipole array, length (order + 1) * (order + 2) / 2 compressed to unique components. """"""; compressed = []; for ii in range(order + 1):; lx = order - ii; for lz in range(ii + 1):; ly = ii - lz. np_index = []; for xval in range(lx):; np_index.append(0); for yval in range(ly):; np_index.append(1); for zval in range(lz):; np_index.append(2); compressed.append(complete[tuple(np_index)]). assert len(compressed) == ((order + 1) * (order + 2) / 2); return np.array(compressed). def _multipole_plumper",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/p4util/python_helpers.html:32442,CHARGE,CHARGES,32442,psi4manual/1.9.x/_modules/psi4/driver/p4util/python_helpers.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/p4util/python_helpers.html,4,['CHARGE'],['CHARGES']
Energy Efficiency,"ary Helium complex Size vs cost tradeoff is rough here. pywrap-basis; SAPT calculation on bimolecular complex where monomers are unspecified so driver auto-fragments it. Basis set and auxiliary basis sets are assigned by atom type. mp2-property; MP2 cc-pvDZ properties for Nitrogen oxide. dft-freq-analytic; Analytic SVWN frequencies, compared to finite difference values. cc10; ROHF-CCSD cc-pVDZ energy for the \(^2\Sigma^+\) state of the CN radical. casscf-sp; CASSCF/6-31G** energy point. extern3; External potential calculation with one Ghost atom and one point charge at the same position. mints10; H2 with tiny basis set, to test basis set parser’s handling of integers. omp2-5; SOS-OMP2 cc-pVDZ geometry optimization for the H2O molecule. pywrap-db3; Test that Python Molecule class processes geometry like psi4 Molecule class. tu2-ch2-energy; Sample UHF/6-31G** CH2 computation. dft-ghost; DFT Functional Test for Range-Seperated Hybrids and Ghost atoms. tu6-cp-ne2; Example potential energy surface scan and CP-correction for Ne2. dft-omega; Test omega is setable updated wb97x_20,wb97x_03 to account for new BraggSlater radii. fd-freq-gradient-large; SCF DZ finite difference frequencies by gradients for C4NH4. mints12; test roundtrip-ness of dict repr for psi4.core.Molecule and qcdb.Molecule. cc49; EOM-CC3(UHF) on CH radical with user-specified basis and properties for particular root. dct-grad1; Various DCT analytic gradients for the O2 molecule with 6-31G basis set. cbs-xtpl-dict; Extrapolated water energies. molden2; Test of the superposition of atomic densities (SAD) guess, using a highly distorted water geometry with a cc-pVDZ basis set. This is just a test of the code and the user need only specify guess=sad to the SCF module’s (or global) options in order to use a SAD guess. The test is first performed in C2v symmetry, and then in C1. cbs-delta-energy; Extrapolated energies with delta correction. sapt-dft1; SAPT(DFT) aug-cc-pVDZ interaction energy between Ne and Ar at",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/autodoc_testsuite_corepsi4-1.html:8035,energy,energy,8035,psi4manual/1.4.0/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodoc_testsuite_corepsi4-1.html,4,['energy'],['energy']
Energy Efficiency,"ary order; lowername = args[0].lower(); lowername, level = driver_util.parse_arbitrary_order(lowername); if level:; kwargs['level'] = level. if ""/"" in lowername:; return driver_cbs._cbs_gufunc(properties, lowername, ptype='properties', **kwargs). return_wfn = kwargs.pop('return_wfn', False); props = kwargs.get('properties', ['dipole', 'quadrupole']). if len(args) > 1:; props += args[1:]. kwargs['properties'] = p4util.drop_duplicates(props); optstash = driver_util._set_convergence_criterion('properties', lowername, 6, 10, 6, 10, 8); wfn = procedures['properties'][lowername](lowername, **kwargs). optstash.restore(). if return_wfn:; return (core.variable('CURRENT ENERGY'), wfn); else:; return core.variable('CURRENT ENERGY'). [docs]def optimize(name, **kwargs):; r""""""Function to perform a geometry optimization. :aliases: opt(). :returns: *float* |w--w| Total electronic energy of optimized structure in Hartrees. :returns: (*float*, :py:class:`~psi4.core.Wavefunction`) |w--w| energy and wavefunction when **return_wfn** specified. :raises: psi4.OptimizationConvergenceError if |optking__geom_maxiter| exceeded without reaching geometry convergence. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`CURRENT ENERGY <CURRENTENERGY>`. :type name: string; :param name: ``'scf'`` || ``'mp2'`` || ``'ci5'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; :py:func:`~driver.energy`. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :type return_wfn: :ref:`boolean <op_py_boolean>`; :param return_wfn: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return the :py:class:`~psi4.core.Wavefunction`; calculation result as the second element (after *float* energy) of a tuple. :type return_history: :ref:`boolean <op_py_boolean>`; :param return_history: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additional",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver.html:47441,energy,energy,47441,psi4manual/1.3.2/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver.html,1,['energy'],['energy']
Energy Efficiency,"ary to add the test case to the suite. This file should have the following lines:; 1; 2; 3include(TestingMacros). add_regression_test(directory_name ""psi;semicolon_separated-list-of-applicable-test-labels""). The labels specify which groups of tests include the test case. The psi label should always be added, but the other labels are test-specific. The method tested should always be included, and this is often sufficient. If adding a test for an already existing module, the labels for other tests of the module will suggest other labels to add.; A test requiring over 15 minutes should be labeled longtests. A short test used for general bug checking should be labeled quicktests. A test that confirms PSI4 is operational should be labeled smoketests.; The other necessary file is the input file itself, input.dat. The input file should be just a simple input file to run the test, with small modifications.; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19; 20; 21; 22; 23; 24; 25#! RI-SCF cc-pVTZ energy of water, with Z-matrix input and cc-pVTZ-RI auxilliary basis.; #! Also a bit more to force a second line. nucenergy = 8.801466202085710 #TEST; refenergy = -76.05098402733282 #TEST. molecule h2o {; symmetry c1; O; H 1 1.0; H 1 1.0 2 104.5; }. set {; basis cc-pVTZ; scf_type df; df_basis_scf cc-pVTZ-RI; e_convergence 10; }. thisenergy = energy('rhf'). compare_values(nucenergy, h2o.nuclear_repulsion_energy(), 9, ""Nuclear repulsion energy"") #TEST; compare_values(refenergy, thisenergy, 9, ""Reference energy"") #TEST; compare_values(refenergy, get_variable('scf total energy'), 9, ""Reference energy"") #TEST. Of those small modifications, first, note the special comment at the top (starting with the #! comment marker). This should be very descriptive since it is inlined into the manual (unless !nosample is present in this comment) as a sample input.; The reference values are assigned to variables for later use. The compare_values function (along with several relatives i",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/add_tests-1.html:1405,energy,energy,1405,psi4manual/1.2.1/add_tests-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/add_tests-1.html,4,['energy'],['energy']
Energy Efficiency,"ary(self.ribasis); fitter.setD(self.Da); self.da = fitter.fit(); self.da.scale(2.0). def populateExtern(self, extern):; # Electronic Part; extern.addBasis(self.ribasis, self.da); # Nuclear Part; for A in range(0, self.molecule.natom()):; extern.addCharge(self.molecule.Z(A), self.molecule.x(A), self.molecule.y(A), self.molecule.z(A)). [docs]class QMMM(object):. def __init__(self):; self.charges = []; self.diffuses = []; self.extern = core.ExternalPotential(). [docs] def addDiffuse(self, diffuse):; """"""Function to add a diffuse charge field *diffuse*.""""""; self.diffuses.append(diffuse). [docs] def addChargeBohr(self, Q, x, y, z):; """"""Function to add a point charge of magnitude *Q* at; position (*x*, *y*, *z*) Bohr. """"""; self.charges.append([Q, x, y, z]). [docs] def addChargeAngstrom(self, Q, x, y, z):; """"""Function to add a point charge of magnitude *Q* at; position (*x*, *y*, *z*) Angstroms. """"""; self.charges.append([Q, x / constants.bohr2angstroms, y / constants.bohr2angstroms, z / constants.bohr2angstroms]). def __str__(self):. s = ' ==> QMMM <==\n\n'. s = s + ' => Charges (a.u.) <=\n\n'; s = s + ' %11s %11s %11s %11s\n' % ('Z', 'x', 'y', 'z'); for k in range(0, len(self.charges)):; s = s + ' %11.7f %11.3E %11.3E %11.3E\n' % (self.charges[k][0], self.charges[k][1], self.charges[k][2], self.charges[k][3]); s = s + '\n'. s = s + ' => Diffuses <=\n\n'. for k in range(0, len(self.diffuses)):; s = s + str(self.diffuses[k]). return s. [docs] def populateExtern(self):; """"""Function to define a charge field external to the; molecule through point and diffuse charges. """"""; # Charges; for charge in self.charges:; self.extern.addCharge(charge[0], charge[1], charge[2], charge[3]); # Diffuses; for diffuse in self.diffuses:; diffuse.populateExtern(self.extern). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .  · ; 1.2.1;  · . PSI4. Module code. © Copyright 2018, The Psi4 Project.; Last updated on Wednesday, 25 July 2018 04:21AM.; Created using Sphinx 1.7.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/qmmm.html:4335,charge,charges,4335,psi4manual/1.2.1/_modules/psi4/driver/qmmm.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/qmmm.html,13,['charge'],"['charge', 'charges']"
Energy Efficiency,"as a promotion opportunity at; # index 1 to produce [4 3 1]; for k in range(n - 2, -1, -1):; if (reals[k] != reals[k + 1] + 1):; rank = k + 1; break. #do the promotion; reals[rank] = reals[rank] + 1. #demote the right portion of the register; val = 1; for k in range(n - 1, rank, -1):; reals[k] = val; val = val + 1. #boundary condition is promotion into; #[nfrag+1 nfrag-1 ...]; if (reals[0] > N):; break. # Hack for external; externNone = psi4.ExternalPotential(). # Run the clusters in the full basis; if bsse == 'on' or bsse == 'both':; for n in range(max_effective, 0, -1):; energies_full[n] = []; clusters = extract_clusters(molecule, True, n); for k in range(len(clusters)):; activate(clusters[k]); # Do the external field for this cluster or not?; if (external):; do_extern = False; for mon in combos[n][k]:; if (mon in external_indices):; do_extern = True; break; if do_extern:; psi4.set_global_option_python(""EXTERN"", external); psi4.print_out('\n => Cluster (N-Body %4d, Combination %4d) Energy (Full Basis) <=\n' % (n, k + 1)); energies_full[n].append(call_function_in_1st_argument(func, **kwargs)); # Turn the external field off; if (external):; psi4.set_global_option_python(""EXTERN"", externNone); psi4.set_global_option('DF_INTS_IO', 'LOAD'); psi4.clean(). # Run the clusters in the minimal cluster bases; psi4.set_global_option('DF_INTS_IO', 'NONE'); if bsse == 'off' or bsse == 'both':; for n in range(max_effective, 0, -1):; energies_mon[n] = []; clusters = extract_clusters(molecule, False, n); for k in range(len(clusters)):; activate(clusters[k]); # Do the external field for this cluster or not?; if (external):; do_extern = False; for mon in combos[n][k]:; if (mon in external_indices):; do_extern = True; break; if do_extern:; psi4.set_global_option_python(""EXTERN"", external); psi4.print_out('\n => Cluster (N-Body %4d, Combination %4d) Energy (Cluster Basis) <=\n' % (n, k + 1)); energies_mon[n].append(call_function_in_1st_argument(func, **kwargs)); # Turn the external fiel",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:9744,Energy,Energy,9744,psi4manual/4.0b5/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html,1,['Energy'],['Energy']
Energy Efficiency,"as built-in shortcuts, so long as the relevant options; (especially EX_LEVEL) are set appropriately. Some; examples of single-refence CI, RASCI, and full CI computations are provided; in psi4/samples. Orbital spaces for CI computations¶. CI (e.g., CISD, FCI); RASCI; CASCI. FROZEN_UOCC; FROZEN_UOCC; FROZEN_UOCC 1. (all orbitals not in; FROZEN_UOCC; or FROZEN_DOCC; are included in CI); RAS4; ACTIVE. RAS3. RAS2. RAS1. FROZEN_DOCC; FROZEN_DOCC; FROZEN_DOCC. 1; FROZEN_UOCC is not required and will be inferred if; ACTIVE is provided. However, if it is easier to specify; FROZEN_UOCC, then this may be provided and ACTIVE can; be inferred. The table above shows the relevant orbitals spaces for CI computations (an; analogous table for MCSCF is also available).; The third column of the; table refers to CASCI, in which a full CI is performed in some smaller; set of active orbitals; it is equivalent to CASSCF except without; any orbital optimization. It can be invoked via energy('fci'); with appropriate values selected for FROZEN_DOCC and; ACTIVE. For CI computations, there is no difference between; FROZEN_DOCC and RESTRICTED_DOCC, or between; FROZEN_UOCC and RESTRICTED_UOCC. There are; differences between these keywords for MCSCF: Multi-Configurational Self-Consistent-Field. Basic DETCI Keywords¶. REFERENCE¶. Reference wavefunction type. Type: string; Possible Values: RHF, ROHF; Default: RHF. R_CONVERGENCE¶. Convergence criterion for CI residual vector in the Davidson algorithm (RMS error). The default is 1e-4 for energies and 1e-7 for gradients. Type: conv double; Default: 1e-4. EX_LEVEL¶. The CI excitation level. Type: integer; Default: 2. FCI¶. Do a full CI (FCI)? If TRUE, overrides the value of EX_LEVEL. Type: boolean; Default: false. FROZEN_DOCC¶. An array containing the number of frozen doubly-occupied orbitals per irrep (these are not excited in a correlated wavefunction, nor can they be optimized in MCSCF. This trumps NUM_FROZEN_DOCC and FREEZE_CORE. Type: array; Default",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/detci-1.html:6575,energy,energy,6575,psi4manual/1.4.0/detci-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/detci-1.html,5,['energy'],['energy']
Energy Efficiency,"as fitting basis for the small basis set. A value of TRUE turns on density fitting with the cc-pVDZ-RI basis set (when available for all elements). Type: string; Possible Values: basis string; Default: FALSE. DIIS¶. Do use DIIS extrapolation to accelerate convergence?. Type: boolean; Default: true. DIIS_MAX_VECS¶. Maximum number of error vectors stored for DIIS extrapolation. Type: integer; Default: 10. DIIS_MIN_VECS¶. Minimum number of error vectors stored for DIIS extrapolation. Type: integer; Default: 2. DIIS_START¶. The minimum iteration to start storing DIIS vectors. Type: integer; Default: 1. D_CONVERGENCE¶. Convergence criterion for SCF density. In practice, the SCF energy will be good to 1-4 more than this number of digits. (This means that D_CONVERGENCE = 11 is overkill and will approach machine precision.) See Table SCF Convergence & Algorithm for default convergence criteria for different calculation types. Type: conv double; Default: 1e-6. E_CONVERGENCE¶. Convergence criterion for SCF energy. See Table SCF Convergence & Algorithm for default convergence criteria for different calculation types. Type: conv double; Default: 1e-8. FAIL_ON_MAXITER¶. Fail if we reach maxiter without converging?. Type: boolean; Default: true. MAXITER¶. Maximum number of iterations. Type: integer; Default: 100. MOM_OCC¶. The absolute indices of orbitals to excite from in MOM (+/- for alpha/beta). Type: array; Default: No Default. MOM_START¶. The iteration to start MOM on (or 0 for no MOM). Type: integer; Default: 0. MOM_VIR¶. The absolute indices of orbitals to excite to in MOM (+/- for alpha/beta). Type: array; Default: No Default. STABILITY_ANALYSIS¶. Whether to perform stability analysis after convergence. NONE prevents analysis being performed. CHECK will print out the analysis of the wavefunction stability at the end of the computation. FOLLOW will perform the analysis and, if a totally symmetric instability is found, will attemp to follow the eigenvector and re-run the co",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/autodir_options_c/module__scf-1.html:3917,energy,energy,3917,psi4manual/4.0b3/autodir_options_c/module__scf-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/module__scf-1.html,4,['energy'],['energy']
Energy Efficiency,"as']['qcvars']['DISPERSION CORRECTION GRADIENT']. [docs] def run_dftd4(self, func=None, dashlvl=None, dashparam=None, dertype=None, verbose=1):; """"""Compute dispersion correction via Grimme's DFTD4 program. Parameters; ----------; func : str, optional; Name of functional (func only, func & disp, or disp only) for; which to compute dispersion (e.g., blyp, BLYP-D2, blyp-d3bj,; blyp-d3(bj), hf+d). Unlike run_dftd3, ``func`` overwrites any; parameter initialized via `dashparam`.; dashlvl : str, optional; Name of dispersion correction to be applied (e.g., d, D2,; d3(bj), das2010). Must be key in `dashcoeff` or ""alias"" or; ""formal"" to run.; dashparam : dict, optional; Values for the same keys as `dashcoeff[dashlvl]['default']`; used to provide custom values. Unlike run_dftd3, will not have; effect if `func` given. Must provide all parameters.; Extra parameters will error.; dertype : int or str, optional; Maximum derivative level at which to run DFTD3. For large; molecules, energy-only calculations can be significantly more; efficient. Influences return values, see below.; verbose : int, optional; Amount of printing. Returns; -------; energy : float; When `dertype=0`, energy [Eh].; gradient : ndarray; When `dertype=1`, (nat, 3) gradient [Eh/a0].; (energy, gradient) : tuple of float and ndarray; When `dertype=None`, both energy [Eh] and (nat, 3) gradient [Eh/a0]. Notes; -----; This function wraps the QCEngine dftd4 harness which wraps the internal DFTD4 Python API.; As such, the upstream convention of `func` trumping `dashparam` holds, rather than the; :py:func:`run_dftd3` behavior of `dashparam` extending or overriding `func`. """"""; import qcengine as qcng. if dertype is None:; derint, derdriver = -1, 'gradient'; else:; derint, derdriver = parse_dertype(dertype, max_derivative=1). resinp = {; 'molecule': self.to_schema(dtype=2),; 'driver': derdriver,; 'model': {; 'method': func,; 'basis': '(auto)',; },; 'keywords': {; 'verbose': verbose,; },; }; if dashlvl:; resinp['keywords'",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/_modules/psi4/driver/qcdb/molecule.html:43161,energy,energy-only,43161,psi4manual/1.5.0/_modules/psi4/driver/qcdb/molecule.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/_modules/psi4/driver/qcdb/molecule.html,8,"['efficient', 'energy']","['efficient', 'energy-only']"
Energy Efficiency,"ase python files for available; molecular systems (case insensitive). [1,2,5] || ['1','2','5'] || ['BzMe-3.5', 'MeMe-5.0'] || etc.; Specify a list of database members to run. Consult the; database python files for available molecular systems. This; is the only portion of database input that is case sensitive;; choices for this keyword must match the database python file. Examples:. >>> # [1] Two-stage SCF calculation on short, equilibrium, and long helium dimer; >>> db('scf','RGC10',cast_up='sto-3g',subset=['HeHe-0.85','HeHe-1.0','HeHe-1.5'], tabulate=['scf total energy','natom']). >>> # [2] Counterpoise-corrected interaction energies for three complexes in S22; >>> # Error statistics computed wrt an old benchmark, S22A; >>> database('mp2','S22',cp=1,subset=[16,17,8],benchmark='S22A'). >>> # [3] SAPT0 on the neon dimer dissociation curve; >>> db('sapt0',subset='NeNe',cp=0,symm=0,db_name='RGC10'). >>> # [4] Optimize system 1 in database S22, producing tables of scf and mp2 energy; >>> db('mp2','S22',db_func=optimize,subset=[1], tabulate=['mp2 total energy','current energy']). >>> # [5] CCSD on the smallest systems of HTBH, a hydrogen-transfer database; >>> database('ccsd','HTBH',subset='small', tabulate=['ccsd total energy', 'mp2 total energy']). Output¶; At the beginning of a database job is printed a listing of the individual system; calculations which will be performed. The output snippet below is from the example job [1]; above. It shows each reagent required for the subset of database reactions requested.; Note that this is an un-counterpoise-corrected example, and the wrapper is smart enough; to compute only once the monomer whose energy will be subtracted from each of the three dimers.; 1; 2; 3; 4RGC1-HeHe-0.85-dimer; RGC1-He-mono-unCP; RGC1-HeHe-1.0-dimer; RGC1-HeHe-1.5-dimer. At the end of the job, the Requested Energy table is printed that gives the total; energies for the requested model chemistry for each reagent and each reaction, as; well as the stoichi",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/db-1.html:5937,energy,energy,5937,psi4manual/1.3.2/db-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/db-1.html,6,['energy'],['energy']
Energy Efficiency,"ase python files for available; molecular systems (case insensitive). [1,2,5] || ['1','2','5'] || ['BzMe-3.5', 'MeMe-5.0'] || etc.; Specify a list of database members to run. Consult the; database python files for available molecular systems. This; is the only portion of database input that is case sensitive;; choices for this keyword must match the database python file. Examples:. >>> # [1] Two-stage SCF calculation on short, equilibrium, and long helium dimer; >>> db('scf','RGC10',cast_up='sto-3g',subset=['HeHe-0.85','HeHe-1.0','HeHe-1.5'], tabulate=['scf total energy','natom']). >>> # [2] Counterpoise-corrected interaction energies for three complexes in S22; >>> # Error statistics computed wrt an old benchmark, S22A; >>> database('mp2','S22',cp=1,subset=[16,17,8],benchmark='S22A'). >>> # [3] SAPT0 on the neon dimer dissociation curve; >>> db('sapt0',subset='NeNe',cp=0,symm=0,db_name='RGC10'). >>> # [4] Optimize system 1 in database S22, producing tables of scf and mp2 energy; >>> db('mp2','S22',db_func=optimize,subset=[1], tabulate=['mp2 total energy','current energy']). >>> # [5] CCSD on the smallest systems of HTBH, a hydrogen-transfer database; >>> database('ccsd','HTBH',subset='small', tabulate=['ccsd total energy', 'mp2 total energy']). Output¶; At the beginning of a database job is printed a listing of the individual system; calculations which will be performed. The output snippet below is from the example job [1]; above. It shows each reagent required for the subset of database reactions requested.; Note that this is an un-counterpoise-corrected example, and the wrapper is smart enough; to compute only once the monomer whose energy will be subtracted from each of the three dimers.; RGC1-HeHe-0.85-dimer; RGC1-He-mono-unCP; RGC1-HeHe-1.0-dimer; RGC1-HeHe-1.5-dimer. At the end of the job, the Requested Energy table is printed that gives the total; energies for the requested model chemistry for each reagent and each reaction, as; well as the stoichoimetric we",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/db-1.html:5703,energy,energy,5703,psi4manual/1.0.0/db-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/db-1.html,6,['energy'],['energy']
Energy Efficiency,"ase, both; those that are placed in set blocks and as Python function arguments.; The few exceptions are documented for the database() function,; where case structure must match the database file. Note; Boolean options can be specified by yes, on, true, or 1; for affirmative and no, off, false, or 0 for negative,; all insensitive to case. Note; Certain convergence and tolerance keywords, of type double (real numbers),; may be specified using either a real number or an integer; and integer X is then; treated as the number of converged decimal digits required. For example, to request; as energy converged to , the user may set the e_convergence; keyword to 0.000001, 1.0e-6, or 6. Alternate Implementations¶; Depending on the reference (RHF, UHF, ROHF) and the integral treatment; (conventional CONV, density-fitted DF, and Cholesky-decomposed CD),; computational methods are sometimes implemented by multiple coders or even; multiple times. Psi4 transparently selects the most efficient; implementation, so one generally needn’t consult this table. However, to; understand the details of what combinations are accessible or what; alternate implementations are available, read on.; Below, “Y” means method available in module, “D” means module is default; for that method, and “” means method not available. HF, DFT, and MP2; default to density-fitted integrals, while all higher methods default to; conventional integrals. Therefore, for a closed-shell molecule:. runs MP2 with default DF with default implementation DFMP2; energy('mp2'). runs MP2 with CONV with default implementation OCC; set mp2_type conv; energy('mp2'). runs MP2 with default DF with implementation OCC; set qc_module occ; energy('mp2'). Overlapping capabilities of Psi4¶. name; _; type select [1]. QC_MODULE; REFERENCE; _. energy(); gradient(). RHF; UHF; ROHF; RHF; UHF; ROHF. CV; DF; CD; CV; DF; CD; CV; DF; CD; CV; DF; CD; CV; DF; CD; CV; DF; CD. mp2; MP2_TYPE. CCENERGY;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ; ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/notes_c-1.html:1474,efficient,efficient,1474,psi4manual/1.0.0/notes_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/notes_c-1.html,2,['efficient'],['efficient']
Energy Efficiency,"ase, where mol is either; the IUPAC molecule name or the CID number. See PubChem Database for; details.; Symmetry; The symmetry can be specified by a line reading symmetry; symbol, where symbol is the Schönflies symbol; of the (Abelian) point group to use for the computation, one of one of; c1, c2, ci, cs, d2, c2h, c2v, or d2h.; This need not be specified, as the molecular symmetry is automatically; detected by Psi4. See Symmetry for details.; Fragments; A line reading -- is interpreted as the separator between two non-covalently; bound molecular fragments. See Non-Covalently Bonded Molecule Fragments for details. Multiple Molecules¶; To facilitate more elaborate computations, it is possible to provide a name for; each molecule and tell Psi4 which one should be used in a given; calculation. For example, consider the following input file:; molecule h2 {; H; H 1 0.9; }. set basis cc-pvdz; set reference rhf; energy('scf') # on H2. clean(). molecule h {; H; }. set basis cc-pvdz; set reference uhf; energy('scf') # on H. Here, two separate jobs are performed on two different molecules; the first is; performed on H2, while the second is for H atom. The last molecule to be; specified is the “active” molecule by default. To explicitly activate a named; molecule, the activate command is provided. With it, the above input file can be; equivalently written as follows. Alternatively, the molecule can be specified; directly to the computing function. Below, the third calculation is the same as; the first.; molecule h2 {; H; H 1 0.9; }. molecule h {; H; }. activate(h2); set basis cc-pvdz; set reference rhf; energy('scf') # on H2. clean(). activate(h); set basis cc-pvdz; set reference uhf; energy('scf') # on H. # --------------------------------------; # equivalent to previous input ends here. clean(). set reference rhf; energy('scf', molecule=h2) # on H2. Job Control Keywords provides more details about the job control; and calculation keywords used in the above examples. Ghost At",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/psithonmol-1.html:4888,energy,energy,4888,psi4manual/1.0.0/psithonmol-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/psithonmol-1.html,2,['energy'],['energy']
Energy Efficiency,"ase-insensitive) Matrix QC variable. del_potential_variable(self: psi4.core.Wavefunction, arg0: str) → int¶; Removes the requested (case-insensitive) ExternalPotential QC variable. (This function is provisional and might be removed in the future.). del_scalar_variable(self: psi4.core.Wavefunction, arg0: str) → int¶; Removes the requested (case-insensitive) double QC variable. del_variable(key)¶; Removes scalar or array QCVariable key from cls if present. Return type; None. Parameters. cls (psi4.core.Wavefunction) – ; key (str) – . density_fitted(self: psi4.core.Wavefunction) → bool¶; Returns whether this wavefunction was obtained using density fitting or not. diag_h(self: psi4.core.CIWavefunction, arg0: float, arg1: float) → int¶; docstring. doccpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of doubly occupied orbitals per irrep. efzc(self: psi4.core.Wavefunction) → float¶; Returns the frozen-core energy. energy(self: psi4.core.Wavefunction) → float¶; Returns the Wavefunction’s energy. epsilon_a(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the Alpha Eigenvalues. epsilon_a_subset(self: psi4.core.Wavefunction, arg0: str, arg1: str) → psi4.core.Vector¶; Returns the requested Alpha Eigenvalues subset. epsilon_b(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the Beta Eigenvalues. epsilon_b_subset(self: psi4.core.Wavefunction, arg0: str, arg1: str) → psi4.core.Vector¶; Returns the requested Beta Eigenvalues subset. esp_at_nuclei(self: psi4.core.Wavefunction) → psi4.core.Vector¶; returns electrostatic potentials at nuclei. external_pot(self: psi4.core.Wavefunction) → psi4.core.ExternalPotential¶; Gets the requested external potential. force_doccpi(self: psi4.core.Wavefunction, arg0: psi4.core.Dimension) → None¶; Specialized expert use only. Sets the number of doubly occupied oribtals per irrep. Note that this results in inconsistent Wavefunction objects for SCF, so caution is advised. force_soccpi(self: psi4.core.Wavef",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/api/psi4.core.ciwavefunction.html:15768,energy,energy,15768,psi4manual/1.4.0/api/psi4.core.ciwavefunction.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/api/psi4.core.ciwavefunction.html,1,['energy'],['energy']
Energy Efficiency,"ase-insensitive) Matrix QC variable. del_potential_variable(self: psi4.core.Wavefunction, arg0: str) → int¶; Removes the requested (case-insensitive) ExternalPotential QC variable. (This function is provisional and might be removed in the future.). del_scalar_variable(self: psi4.core.Wavefunction, arg0: str) → int¶; Removes the requested (case-insensitive) double QC variable. del_variable(key)¶; Removes scalar or array QCVariable key from cls if present. Return type; None. Parameters. cls (psi4.core.Wavefunction) – ; key (str) – . density_fitted(self: psi4.core.Wavefunction) → bool¶; Returns whether this wavefunction was obtained using density fitting or not. diag_h(self: psi4.core.CIWavefunction, arg0: float, arg1: float) → int¶; docstring. doccpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of doubly occupied orbitals per irrep. efzc(self: psi4.core.Wavefunction) → float¶; Returns the frozen-core energy. energy(self: psi4.core.Wavefunction) → float¶; Returns the Wavefunction’s energy. epsilon_a(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the Alpha Eigenvalues. epsilon_a_subset(self: psi4.core.Wavefunction, basis: str, subset: str) → psi4.core.Vector¶; Returns the requested Alpha orbital energies subset. Parameters. basis – {‘AO’, ‘SO’, ‘MO’}; MO or SO select for Pitzer-ordering the return vector in the full computational point group symmetry.; AO selects for Pitzer-ordering the return vector without point group symmetry.; subset – {‘ALL’, ‘ACTIVE’, ‘FROZEN’, ‘OCC’, ‘VIR’, ‘FROZEN_OCC’, ‘ACTIVE_OCC’, ‘ACTIVE_VIR’, ‘FROZEN_VIR’}; Which subspace of orbital energies should be returned?. Returns; A Pitzer-ordered vector of the orbitals. Return type; Vector. epsilon_b(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the Beta Eigenvalues. epsilon_b_subset(self: psi4.core.Wavefunction, basis: str, subset: str) → psi4.core.Vector¶; Returns the requested Beta orbital energies subset. Parameters. basis – {‘AO’, ‘SO’, ‘MO’}",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/api/psi4.core.ciwavefunction.html:15879,energy,energy,15879,psi4manual/1.5.0/api/psi4.core.ciwavefunction.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/api/psi4.core.ciwavefunction.html,4,['energy'],['energy']
Energy Efficiency,"ase: all excitations up to this level are included, e.g., 2 for CCSD, 3 for CCSDT, 4 for CCSDTQ, etc. This becomes ex.lev (option #1) in fort.56. Type: integer; Default: 2. MRCC_NUM_DOUBLET_ROOTS¶. Number of root in case of open shell system. This becomes ndoub (option #13) int fort.56. Type: integer; Default: 0. MRCC_NUM_SINGLET_ROOTS¶. Number of singlet roots. (Strictly speaking number of of roots with M_s=0 and S is even.) Use this option only with closed shell reference determinant, it must be zero otherwise. This becomes nsing (option #2) in fort.56. Type: integer; Default: 1. MRCC_NUM_TRIPLET_ROOTS¶. Number of triplet roots. (Strictly speaking number of of roots with and S is odd.) See notes at option MRCC_NUM_SINGLET_ROOTS This becomes ntrip (option #3) in fort.56. Type: integer; Default: 0. Expert¶. MRCC_METHOD¶. If more than one root is requested and calc=1, LR-CC (EOM-CC) calculation is performed automatically for the excited states. This overrides all automatic determination of method and will only work with energy(). This becomes CC/CI (option #5) in fort.56 .. table:: MRCC methods +——-+————–+————————————————————-+ + Value + Method + Description + +=======+==============+=============================================================+ + 1 + CC + + +——-+————–+————————————————————-+ + 2 + CC(n-1)[n] + + +——-+————–+————————————————————-+ + 3 + CC(n-1)(n) + (CC(n-1)[n] energy is also calculated) + +——-+————–+————————————————————-+ + 4 + CC(n-1)(n)_L + (CC(n-1)[n] and CC(n-1)(n) energies are also calculated) + +——-+————–+————————————————————-+ + 5 + CC(n)-1a + + +——-+————–+————————————————————-+ + 6 + CC(n)-1b + + +——-+————–+————————————————————-+ + 7 + CCn + + +——-+————–+————————————————————-+ + 8 + CC(n)-3 + + +——-+————–+————————————————————-+. Type: integer; Default: 1. MRCC_OMP_NUM_THREADS¶. Sets the OMP_NUM_THREADS environment variable before calling MRCC. If the environment variable OMP_NUM_THREADS is set prior to calling PSI4 then that value is used. When",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/autodir_options_c/module__mrcc-1.html:1708,energy,energy,1708,psi4manual/4.0b5/autodir_options_c/module__mrcc-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/module__mrcc-1.html,4,['energy'],['energy']
Energy Efficiency,"ase: all excitations up to this level are included, e.g., 2 for CCSD, 3 for CCSDT, 4 for CCSDTQ, etc. This becomes ex.lev (option #1) in fort.56. Type: integer; Default: 2. MRCC_NUM_DOUBLET_ROOTS¶. Number of root in case of open shell system. This becomes ndoub (option #13) int fort.56. Type: integer; Default: 0. MRCC_NUM_SINGLET_ROOTS¶. Number of singlet roots. (Strictly speaking number of of roots with M_s=0 and S is even.) Use this option only with closed shell reference determinant, it must be zero otherwise. This becomes nsing (option #2) in fort.56. Type: integer; Default: 1. MRCC_NUM_TRIPLET_ROOTS¶. Number of triplet roots. (Strictly speaking number of of roots with and S is odd.) See notes at option MRCC_NUM_SINGLET_ROOTS This becomes ntrip (option #3) in fort.56. Type: integer; Default: 0. Expert¶. MRCC_METHOD¶. If more than one root is requested and calc=1, LR-CC (EOM-CC) calculation is performed automatically for the excited states. This overrides all automatic determination of method and will only work with energy(). This becomes CC/CI (option #5) in fort.56. See Table MRCC_METHOD for details. Type: integer; Default: 1. MRCC_OMP_NUM_THREADS¶. Sets the OMP_NUM_THREADS environment variable before calling MRCC. If the environment variable OMP_NUM_THREADS is set prior to calling Psi4 then that value is used. When set, this option overrides everything. Be aware the -n command-line option described in section Threading does not affect MRCC. Type: integer; Default: 1. MRCC_RESTART¶. The program restarts from the previously calculated parameters if it is 1. In case it is 2, the program executes automatically the lower-level calculations of the same type consecutively (e.g., CCSD, CCSDT, and CCSDTQ if CCSDTQ is requested) and restarts each calculation from the previous one (rest=2 is available only for energy calculations). Currently, only a value of 0 and 2 are supported. This becomes rest (option #4) in fort.56. Type: integer; Default: 0. Table Of Contents. MRCC",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodir_options_c/module__mrcc-1.html:1715,energy,energy,1715,psi4manual/1.0.0/autodir_options_c/module__mrcc-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodir_options_c/module__mrcc-1.html,2,['energy'],['energy']
Energy Efficiency,"ases: opt(). :returns: *float* |w--w| Total electronic energy of optimized structure in Hartrees. :returns: (*float*, :py:class:`~psi4.core.Wavefunction`) |w--w| energy and wavefunction when **return_wfn** specified. :raises: psi4.OptimizationConvergenceError if |optking__geom_maxiter| exceeded without reaching geometry convergence. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`CURRENT ENERGY <CURRENTENERGY>`. :type name: string; :param name: ``'scf'`` || ``'mp2'`` || ``'ci5'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; :py:func:`~driver.energy`. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :type return_wfn: :ref:`boolean <op_py_boolean>`; :param return_wfn: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return the :py:class:`~psi4.core.Wavefunction`; calculation result as the second element (after *float* energy) of a tuple. :type return_history: :ref:`boolean <op_py_boolean>`; :param return_history: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return dictionary of lists of geometries,; energies, and gradients at each step in the optimization. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``gradient`` |dr| || ``energy`` || ``cbs``. Indicates the type of calculation to be performed on the molecule.; The default dertype accesses ``'gradient'`` or ``'energy'``, while; ``'cbs'`` performs a multistage finite difference calculation.; If a nested series of python functions is intended (see :ref:`sec:intercalls`),; use keyword ``opt_func`` instead of ``func``. :type dertype: :ref:`dertype <op_py_dertype>`; :param dertype: ``'gradient'`` || ``'energy'``. Indicates whether analytic (if available) or finite difference; optimization is to be performed. :type hessian_with: string; :param hessian_with: ``'scf'`` || ``'mp2'`` || etc. Indicates t",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver.html:48305,energy,energy,48305,psi4manual/1.3.2/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver.html,1,['energy'],['energy']
Energy Efficiency,"ases: opt(). :returns: *float* |w--w| Total electronic energy of optimized structure in Hartrees. :returns: (*float*, :py:class:`~psi4.core.Wavefunction`) |w--w| energy and wavefunction when **return_wfn** specified. :raises: psi4.OptimizationConvergenceError if |optking__geom_maxiter| exceeded without reaching geometry convergence. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`CURRENT ENERGY <CURRENTENERGY>`. :type name: string; :param name: ``'scf'`` || ``'mp2'`` || ``'ci5'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; :py:func:`~driver.energy`. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :type return_wfn: :ref:`boolean <op_py_boolean>`; :param return_wfn: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return the :py:class:`~psi4.core.Wavefunction`; calculation result as the second element (after *float* energy) of a tuple. :type return_history: :ref:`boolean <op_py_boolean>`; :param return_history: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return dictionary of lists of geometries,; energies, and gradients at each step in the optimization. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``gradient`` |dr| || ``energy`` || ``cbs``. Indicates the type of calculation to be performed on the molecule.; The default dertype accesses ``'gradient'`` or ``'energy'``, while; ``'cbs'`` performs a multistage finite difference calculation.; If a nested series of python functions is intended (see :ref:`sec:intercalls`),; use keyword ``opt_func`` instead of ``func``. :type mode: string; :param mode: |dl| ``'continuous'`` |dr| || ``'sow'`` || ``'reap'``. For a finite difference of energies optimization, indicates whether; the calculations required to complete the; optimization are to be run in one file (``'continuous'``) or are to be; farmed out ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/driver.html:51557,energy,energy,51557,psi4manual/1.2.1/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/driver.html,1,['energy'],['energy']
Energy Efficiency,"ashes (-) to separate; quantifiers like o, n etc.; The full list understood by ddx can be obtained using; import pyddx; print(pyddx.data.solvent_epsilon.keys()). For when an LPB solvent model is selected (DDX_MODEL is LPB); additionally the Debye-Hückel parameter DDX_SOLVENT_KAPPA needs to be provided; (in units of inverse Bohr or inverse Angström, depending on the unit used to define; the molecular geometry). pyddx provides a handy utility function to compute; the Debye-Hückel parameter. For example; import pyddx; from qcelemental import constants. list_of_ions = [(+1, 0.1), (-1, 0.1)]; dielectric_constant = pyddx.data.solvent_epsilon[""water""]; temperature = 298.15 # Kelvin; kappa_invbohr = pyddx.solvent_kappa(list_of_ions, dielectric_constant, temperature); kappa_invang = kappa_invbohr / constants.bohr2angstroms. computes the parameter (in inverse Angström) for a 0.1 mol/l solution of sodium; chloride in water, thus a solution woith 0.1 mol/l of a +1-charged ion; and 0.1 mol/l of a -1-charged ion.; The cavity in ddx is defined as a union of spheres around each atom.; Usually the spehere radii for each atom are determined using a standard; set of tabulated radii per atomic species, determined by the DDX_RADII_SET parameter.; Currently bondi [Bondi:1964:441] and uff [Rappe:1992:114]; are supported for DDX_RADII_SET with uff selected by default.; These radius values are conventionally scaled by an additional factor before use,; conventionally 1.1 for uff and 1.2 for bondi. Customisation of the scaling; is possible using the DDX_RADII_SCALING parameter.; A more fine-grained control over the sphere radii is available by explicitly providing; a list of radii (one per atom, exactly in the order of the input geometry); using the DDX_RADII parameter. Note that the same unit as for the molecular; input is expected for the radii. DDX¶. DDX boolean for ddx module. Type: boolean; Default: false. DDX_MODEL¶. Switch available solvation models. Type: string; Possible Values: PCM,",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/ddx.html:4819,charge,charged,4819,psi4manual/1.8.x/ddx.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/ddx.html,3,['charge'],['charged']
Energy Efficiency,"ashlvl='d3', dashparam={'s8': 2.0, 'alpha6': 14.0, 'sr6': 1.261, 's6': 1.0}); >>> print E; -0.00024762. qcdb.Molecule.run_dftd3(self, func=None, dashlvl=None, dashparam=None, dertype=None, verbose=1)¶; Compute dispersion correction via Grimme’s DFTD3 program. Parameters. func (Optional[str]) – Name of functional (func only, func & disp, or disp only) for; which to compute dispersion (e.g., blyp, BLYP-D2, blyp-d3bj,; blyp-d3(bj), hf+d). Any or all parameters initialized; from dashcoeff[dashlvl][func] can be overwritten via; dashparam.; dashlvl (Optional[str]) – Name of dispersion correction to be applied (e.g., d, D2,; d3(bj), das2010). Must be key in dashcoeff or “alias” or; “formal” to one.; dashparam (Optional[Dict]) – Values for the same keys as dashcoeff[dashlvl][‘default’]; used to override any or all values initialized by func.; Extra parameters will error.; dertype (Union[int, str, None]) – Maximum derivative level at which to run DFTD3. For large; molecules, energy-only calculations can be significantly more; efficient. Influences return values, see below.; verbose (int) – Amount of printing. Returns. energy (float) – When dertype=0, energy [Eh].; gradient (ndarray) – When dertype=1, (nat, 3) gradient [Eh/a0].; (energy, gradient) (tuple of float and ndarray) – When dertype=None, both energy [Eh] and (nat, 3) gradient [Eh/a0]. class psi4.driver.procrouting.empirical_dispersion.EmpiricalDispersion(*, name_hint=None, level_hint=None, param_tweaks=None, engine=None, save_pairwise_disp=False)[source]¶; Lightweight unification of empirical dispersion calculation modes. dashlevel¶; {‘d1’, ‘d2’, ‘d3zero’, ‘d3bj’, ‘d3mzero’, ‘d3mbj’, ‘chg’, ‘das2009’, ‘das2010’, ‘nl’, ‘dmp2’}; Name of dispersion correction to be applied. Resolved; from name_hint and/or level_hint into a key of; empirical_dispersion_resources.dashcoeff. Type; str. dashparams¶; Complete set of parameter values defining the flexible parts; of dashlevel. Number and parameter names vary by; dashlevel. Reso",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/dftd3-1.html:10646,energy,energy-only,10646,psi4manual/1.4.0/dftd3-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/dftd3-1.html,4,"['efficient', 'energy']","['efficient', 'energy-only']"
Energy Efficiency,"ashlvl='d3', dashparam={'s8': 2.0, 'alpha6': 14.0, 'sr6': 1.261, 's6': 1.0}); >>> print E; -0.00024762. qcdb.Molecule.run_dftd3(self, func=None, dashlvl=None, dashparam=None, dertype=None, verbose=1)¶; Compute dispersion correction via Grimme’s DFTD3 program. Parameters. func (Optional[str]) – Name of functional (func only, func & disp, or disp only) for; which to compute dispersion (e.g., blyp, BLYP-D2, blyp-d3bj,; blyp-d3(bj), hf+d). Any or all parameters initialized; from dashcoeff[dashlvl][func] can be overwritten via; dashparam.; dashlvl (Optional[str]) – Name of dispersion correction to be applied (e.g., d, D2,; d3(bj), das2010). Must be key in dashcoeff or “alias” or; “formal” to run.; dashparam (Optional[Dict]) – Values for the same keys as dashcoeff[dashlvl][‘default’]; used to override any or all values initialized by func.; Extra parameters will error.; dertype (Union[int, str, None]) – Maximum derivative level at which to run DFTD3. For large; molecules, energy-only calculations can be significantly more; efficient. Influences return values, see below.; verbose (int) – Amount of printing. Returns. energy (float) – When dertype=0, energy [Eh].; gradient (ndarray) – When dertype=1, (nat, 3) gradient [Eh/a0].; (energy, gradient) (tuple of float and ndarray) – When dertype=None, both energy [Eh] and (nat, 3) gradient [Eh/a0]. class psi4.driver.procrouting.empirical_dispersion.EmpiricalDispersion(*, name_hint=None, level_hint=None, param_tweaks=None, engine=None, save_pairwise_disp=False)[source]¶; Lightweight unification of empirical dispersion calculation modes. dashlevel¶; {‘d1’, ‘d2’, ‘d3zero’, ‘d3bj’, ‘d3mzero’, ‘d3mbj’, ‘chg’, ‘das2009’, ‘das2010’, ‘nl’, ‘dmp2’, “d4bjeeqatm”}; Name of dispersion correction to be applied. Resolved; from name_hint and/or level_hint into a key of; empirical_dispersion_resources.dashcoeff. Type; str. dashparams¶; Complete set of parameter values defining the flexible parts; of dashlevel. Number and parameter names vary by; d",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/dftd3-1.html:11350,energy,energy-only,11350,psi4manual/1.5.0/dftd3-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/dftd3-1.html,6,"['efficient', 'energy']","['efficient', 'energy-only']"
Energy Efficiency,"asis = core.BasisSet.build(dimer_wfn.molecule(), ""DF_BASIS_SAPT"", core.get_global_option(""DF_BASIS_SAPT""),; ""RIFIT"", core.get_global_option(""BASIS"")); dimer_wfn.set_basisset(""DF_BASIS_SAPT"", aux_basis). aux_basis = core.BasisSet.build(dimer_wfn.molecule(), ""DF_BASIS_ELST"", core.get_global_option(""DF_BASIS_ELST""),; ""JKFIT"", core.get_global_option(""BASIS"")); dimer_wfn.set_basisset(""DF_BASIS_ELST"", aux_basis). core.print_out('\n'); p4util.banner(name.upper()); core.print_out('\n'); e_sapt = core.sapt(dimer_wfn, monomerA_wfn, monomerB_wfn); dimer_wfn.set_module(""sapt""). from psi4.driver.qcdb.psivardefs import sapt_psivars; p4util.expand_psivars(sapt_psivars()); optstash.restore(). # Get the SAPT name right if doing empirical dispersion; if do_empirical_disp:; sapt_name = ""sapt0""; else:; sapt_name = name. # Make sure we got induction, otherwise replace it with uncoupled induction; which_ind = 'IND'; target_ind = 'IND'; if not core.has_variable(' '.join((sapt_name.upper(), which_ind, 'ENERGY'))):; which_ind = 'IND,U'. for term in ['ELST', 'EXCH', 'DISP', 'TOTAL']:; core.set_variable(' '.join(['SAPT', term, 'ENERGY']),; core.variable(' '.join([sapt_name.upper(), term, 'ENERGY']))); # Special induction case; core.set_variable(' '.join(['SAPT', target_ind, 'ENERGY']),; core.variable(' '.join([sapt_name.upper(), which_ind, 'ENERGY']))); core.set_variable('CURRENT ENERGY', core.variable('SAPT TOTAL ENERGY')). # Empirical dispersion; if do_empirical_disp:; proc_util.sapt_empirical_dispersion(name, dimer_wfn). return dimer_wfn. def run_sapt_ct(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a charge-transfer SAPT calcuation of any level. """"""; optstash = p4util.OptionsState(; ['SCF_TYPE']). if 'ref_wfn' in kwargs:; core.print_out('\nWarning! Argument ref_wfn is not valid for sapt computations\n'). # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'). # Get the molecule of interest; ref_wfn",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:147404,ENERGY,ENERGY,147404,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,5,['ENERGY'],['ENERGY']
Energy Efficiency,"asis set extrapolation scheme to be applied to the reference energy.; Defaults to :py:func:`~scf_xtpl_helgaker_3` if three valid basis sets; present in ``scf_basis``, :py:func:`~scf_xtpl_helgaker_2` if two valid basis; sets present in ``scf_basis``, and :py:func:`~xtpl_highest_1` otherwise. .. hlist::; :columns: 1. * xtpl_highest_1; * scf_xtpl_helgaker_3; * scf_xtpl_helgaker_2; * scf_xtpl_truhlar_2; * scf_xtpl_karton_2. :type corl_scheme: function; :param corl_scheme: |dl| ``xtpl_highest_1`` |dr| || ``corl_xtpl_helgaker_2`` || etc. Indicates the basis set extrapolation scheme to be applied to the correlation energy.; Defaults to :py:func:`~corl_xtpl_helgaker_2` if two valid basis sets; present in ``corl_basis`` and :py:func:`~xtpl_highest_1` otherwise. .. hlist::; :columns: 1. * xtpl_highest_1; * corl_xtpl_helgaker_2. :type delta_scheme: function; :param delta_scheme: |dl| ``xtpl_highest_1`` |dr| || ``corl_xtpl_helgaker_2`` || etc. Indicates the basis set extrapolation scheme to be applied to the delta correction; to the correlation energy.; Defaults to :py:func:`~corl_xtpl_helgaker_2` if two valid basis sets; present in ``delta_basis`` and :py:func:`~xtpl_highest_1` otherwise. .. hlist::; :columns: 1. * xtpl_highest_1; * corl_xtpl_helgaker_2. :type delta2_scheme: function; :param delta2_scheme: |dl| ``xtpl_highest_1`` |dr| || ``corl_xtpl_helgaker_2`` || etc. Indicates the basis set extrapolation scheme to be applied to the second delta correction; to the correlation energy.; Defaults to :py:func:`~corl_xtpl_helgaker_2` if two valid basis sets; present in ``delta2_basis`` and :py:func:`~xtpl_highest_1` otherwise. .. hlist::; :columns: 1. * xtpl_highest_1; * corl_xtpl_helgaker_2. :type delta3_scheme: function; :param delta3_scheme: |dl| ``xtpl_highest_1`` |dr| || ``corl_xtpl_helgaker_2`` || etc. Indicates the basis set extrapolation scheme to be applied to the third delta correction; to the correlation energy.; Defaults to :py:func:`~corl_xtpl_helgaker_2` if two valid",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/driver_cbs.html:33022,energy,energy,33022,psi4manual/1.2.1/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/driver_cbs.html,1,['energy'],['energy']
Energy Efficiency,"asis set extrapolation scheme to be applied to the reference energy.; Defaults to :py:func:`~scf_xtpl_helgaker_3` if three valid basis sets; present in ``scf_basis``, :py:func:`~scf_xtpl_helgaker_2` if two valid basis; sets present in ``scf_basis``, and :py:func:`~xtpl_highest_1` otherwise. .. hlist::; :columns: 1. * xtpl_highest_1; * scf_xtpl_helgaker_3; * scf_xtpl_helgaker_2; * scf_xtpl_truhlar_2; * scf_xtpl_karton_2. :type corl_scheme: function; :param corl_scheme: |dl| ``xtpl_highest_1`` |dr| || ``corl_xtpl_helgaker_2`` || etc. Indicates the basis set extrapolation scheme to be applied to the correlation energy.; Defaults to :py:func:`~corl_xtpl_helgaker_2` if two valid basis sets; present in ``corl_basis`` and :py:func:`~xtpl_highest_1` otherwise. .. hlist::; :columns: 1. * xtpl_highest_1; * corl_xtpl_helgaker_2. :type delta_scheme: function; :param delta_scheme: |dl| ``xtpl_highest_1`` |dr| || ``corl_xtpl_helgaker_2`` || etc. Indicates the basis set extrapolation scheme to be applied to the delta correction; to the correlation energy.; Defaults to :py:func:`~corl_xtpl_helgaker_2` if two valid basis sets; present in ``delta_basis`` and :py:func:`~xtpl_highest_1` otherwise. .. hlist::; :columns: 1. * xtpl_highest_1; * corl_xtpl_helgaker_2. :type delta2_scheme: function; :param delta2_scheme: |dl| ``xtpl_highest_1`` |dr| || ``corl_xtpl_helgaker_2`` || etc. Indicates the basis set extrapolation scheme to be applied to the second delta correction; to the correlation energy.; Defaults to :py:func:`~corl_xtpl_helgaker_2` if two valid basis sets; present in ``delta2_basis`` and :py:func:`~xtpl_highest_1` otherwise. .. hlist::; :columns: 1. * xtpl_highest_1; * corl_xtpl_helgaker_2. :type scf_alpha: float. Overrides the default \alpha parameter used in the listed SCF extrapolation procedures.; Has no effect on others, including :py:func:`~xtpl_highest_1` and :py:func:`~scf_xtpl_helgaker_3`. .. hlist::; :columns: 1. * :py:func:`scf_xtpl_helgaker_2`; * :py:func:`scf_xtpl_t",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver_cbs.html:40216,energy,energy,40216,psi4manual/1.3.2/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver_cbs.html,1,['energy'],['energy']
Energy Efficiency,"asis string) – 'cc-pV[TQ]Z' || 'jun-cc-pv[tq5]z' || '6-31G*' || etc.; Indicates the sequence of basis sets employed for the delta correction; to the correlation energy. delta2_basis (basis string) – 'cc-pV[TQ]Z' || 'jun-cc-pv[tq5]z' || '6-31G*' || etc.; Indicates the sequence of basis sets employed for the second delta correction; to the correlation energy. Schemes; Transformations of the energy through basis set extrapolation for each; stage of the CBS definition. A complaint is generated if number of basis; sets in stage_basis does not exactly satisfy requirements of stage_scheme.; An exception is the default, 'highest_1', which uses the best basis; set available. See Extrapolation Schemes for all available schemes. Parameters:; scf_scheme (function) – highest_1 || scf_xtpl_helgaker_3 || etc.; Indicates the basis set extrapolation scheme to be applied to the reference energy. corl_scheme (function) – highest_1 || corl_xtpl_helgaker_2 || etc.; Indicates the basis set extrapolation scheme to be applied to the correlation energy. delta_scheme (function) – highest_1 || corl_xtpl_helgaker_2 || etc.; Indicates the basis set extrapolation scheme to be applied to the delta correction; to the correlation energy. delta2_scheme (function) – highest_1 || corl_xtpl_helgaker_2 || etc.; Indicates the basis set extrapolation scheme to be applied to the second delta correction; to the correlation energy. molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. Examples :. >>> # [1] replicates with cbs() the simple model chemistry scf/cc-pVDZ: set basis cc-pVDZ energy('scf'); >>> cbs('scf', scf_basis='cc-pVDZ'). >>> # [2] replicates with cbs() the simple model chemistry mp2/jun-cc-pVDZ: set basis jun-cc-pVDZ energy('mp2'); >>> cbs('mp2', corl_basis='jun-cc-pVDZ'). >>> # [3] DTQ-zeta extrapolated scf reference energy; >>> cbs('scf', scf_basis='cc-pV[DTQ]Z', scf_scheme=scf_xtpl_helgaker_3). >>> # [4] DT-zeta extrapolated mp2 correlation energy atop a T",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/cbs-1.html:5320,energy,energy,5320,psi4manual/4.0b2/cbs-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/cbs-1.html,6,['energy'],['energy']
Energy Efficiency,"asis'] == mce['f_basis']); and (mc['f_options'] == mce['f_options'])):; mce['f_energy'] = mc['f_energy']; mce['f_gradient'] = mc['f_gradient']; mce['f_hessian'] = mc['f_hessian']; mce['f_dipole'] = mc['f_dipole']; mce['f_dipder'] = mc['f_dipder']. # logger.debug(""MC\n"" + pp.pformat(mc)). cbs_results, self.cbsrec = _assemble_cbs_components(self.metameta, self.trove, self.cbsrec). instructions = _summary_table(self.metadata, self.trove, self.cbsrec); core.print_out(instructions); logger.info(instructions). # logger.debug('CBS_RESULTS\n' + pp.pformat(cbs_results)); # logger.debug('GRAND_NEED\n' + pp.pformat(self.cbsrec)). cbs_results[""module""] = modules; return cbs_results. def get_results(self, client: Optional[""FractalClient""] = None) -> AtomicResult:; """"""Return results as Composite-flavored QCSchema."""""". assembled_results = self._prepare_results(client=client); E0 = assembled_results[""energy""]. # load QCVariables & properties; qcvars = {; 'CBS NUMBER': len(self.compute_list),; 'NUCLEAR REPULSION ENERGY': self.molecule.nuclear_repulsion_energy(),; }. properties = {; ""calcinfo_natom"": self.molecule.natom(),; ""nuclear_repulsion_energy"": self.molecule.nuclear_repulsion_energy(),; ""return_energy"": E0,; }. for qcv in ['CBS', 'CURRENT']:; qcvars[qcv + ' REFERENCE ENERGY'] = self.cbsrec[0]['d_energy']; qcvars[qcv + ' CORRELATION ENERGY'] = E0 - self.cbsrec[0]['d_energy']; qcvars[qcv + ('' if qcv == 'CURRENT' else ' TOTAL') + ' ENERGY'] = E0. for idelta in range(int(len(self.cbsrec) / 2)):; if idelta == 0:; continue; dc = idelta * 2 + 1; qcvars[f""CBS {self.cbsrec[dc]['d_stage'].upper()} TOTAL ENERGY""] = self.cbsrec[dc][""d_energy""] - self.cbsrec[dc + 1][""d_energy""]. G0 = assembled_results[""gradient""]; if np.count_nonzero(G0):; qcvars[""CURRENT GRADIENT""] = G0; qcvars[""CBS TOTAL GRADIENT""] = G0; properties[""return_gradient""] = G0. H0 = assembled_results[""hessian""]; if np.count_nonzero(H0):; qcvars[""CURRENT HESSIAN""] = H0; qcvars[""CBS TOTAL HESSIAN""] = H0; properties[""return_hess",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver_cbs.html:58482,ENERGY,ENERGY,58482,psi4manual/1.6.x/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver_cbs.html,1,['ENERGY'],['ENERGY']
Energy Efficiency,"asis'].lower()); else:; raise ValidationError('DELTA4 basis sets through keyword \'%s\' are required.' % ('delta4_basis')). # Establish list of valid basis sets for fifth delta correction energy; if do_delta5:; if 'delta5_basis' in kwargs:; BSTD5, ZETD5 = validate_bracketed_basis(kwargs['delta5_basis'].lower()); else:; raise ValidationError('DELTA5 basis sets through keyword \'%s\' are required.' % ('delta5_basis')). # Establish treatment for scf energy (validity check useless since python will catch it long before here); cbs_scf_scheme = highest_1; if 'scf_scheme' in kwargs:; cbs_scf_scheme = kwargs['scf_scheme']. # Establish treatment for correlation energy; cbs_corl_scheme = highest_1; if 'corl_scheme' in kwargs:; cbs_corl_scheme = kwargs['corl_scheme']. # Establish treatment for delta correction energy; cbs_delta_scheme = highest_1; if 'delta_scheme' in kwargs:; cbs_delta_scheme = kwargs['delta_scheme']. # Establish treatment for delta2 correction energy; cbs_delta2_scheme = highest_1; if 'delta2_scheme' in kwargs:; cbs_delta2_scheme = kwargs['delta2_scheme']. # Establish treatment for delta3 correction energy; cbs_delta3_scheme = highest_1; if 'delta3_scheme' in kwargs:; cbs_delta3_scheme = kwargs['delta3_scheme']. # Establish treatment for delta4 correction energy; cbs_delta4_scheme = highest_1; if 'delta4_scheme' in kwargs:; cbs_delta4_scheme = kwargs['delta4_scheme']. # Establish treatment for delta5 correction energy; cbs_delta5_scheme = highest_1; if 'delta5_scheme' in kwargs:; cbs_delta5_scheme = kwargs['delta5_scheme']. # Build string of title banner; cbsbanners = ''; cbsbanners += """"""psi4.print_out('\\n')\n""""""; cbsbanners += """"""p4util.banner(' CBS Setup ')\n""""""; cbsbanners += """"""psi4.print_out('\\n')\n\n""""""; exec(cbsbanners). # Call schemes for each portion of total energy to 'place orders' for calculations needed; d_fields = ['d_stage', 'd_scheme', 'd_basis', 'd_wfn', 'd_need', 'd_coef', 'd_energy']; f_fields = ['f_wfn', 'f_portion', 'f_basis', 'f_zeta'",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:77886,energy,energy,77886,psi4manual/4.0b5/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html,2,['energy'],['energy']
Energy Efficiency,"asis. compute_energy(self: psi4.core.Wavefunction) → float; Computes the energy of the Wavefunction. compute_gradient(self: psi4.core.Wavefunction) → psi4.core.Matrix; Computes the gradient of the Wavefunction. compute_hessian(self: psi4.core.Wavefunction) → psi4.core.Matrix; Computes the Hessian of the Wavefunction. deep_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None; Deep copies the internal data. del_array_variable(self: psi4.core.Wavefunction, arg0: str) → int; Removes the requested (case-insensitive) Matrix QC variable. del_scalar_variable(self: psi4.core.Wavefunction, arg0: str) → int; Removes the requested (case-insensitive) double QC variable. del_variable(key). density_fitted(self: psi4.core.Wavefunction) → bool; Returns whether this wavefunction was obtained using density fitting or not. doccpi(self: psi4.core.Wavefunction) → psi4.core.Dimension; Returns the number of doubly occupied orbitals per irrep. efzc(self: psi4.core.Wavefunction) → float; Returns the frozen-core energy. energy(self: psi4.core.Wavefunction) → float; Returns the Wavefunction’s energy. epsilon_a(self: psi4.core.Wavefunction) → psi4.core.Vector; Returns the Alpha Eigenvalues. epsilon_a_subset(self: psi4.core.Wavefunction, arg0: str, arg1: str) → psi4.core.Vector; Returns the requested Alpha Eigenvalues subset. epsilon_b(self: psi4.core.Wavefunction) → psi4.core.Vector; Returns the Beta Eigenvalues. epsilon_b_subset(self: psi4.core.Wavefunction, arg0: str, arg1: str) → psi4.core.Vector; Returns the requested Beta Eigenvalues subset. esp_at_nuclei(self: psi4.core.Wavefunction) → psi4.core.Vector; returns electrostatic potentials at nuclei. force_doccpi(self: psi4.core.Wavefunction, arg0: psi4.core.Dimension) → None; Specialized expert use only. Sets the number of doubly occupied oribtals per irrep. Note that this results in inconsistent Wavefunction objects for SCF, so caution is advised. force_soccpi(self: psi4.core.Wavefunction, arg0: psi4.core.Dimension) → Non",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/api/psi4.core.wavefunction.html:20886,energy,energy,20886,psi4manual/1.3.2/api/psi4.core.wavefunction.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/api/psi4.core.wavefunction.html,1,['energy'],['energy']
Energy Efficiency,"asis_sapt basis is not set, pick a sensible one.; if psi4.get_global_option('DF_BASIS_SAPT') == '':; ribasis = p4util.corresponding_rifit(psi4.get_global_option('BASIS')); if ribasis:; psi4.set_global_option('DF_BASIS_SAPT', ribasis); psi4.print_out(' No DF_BASIS_SAPT auxiliary basis selected, defaulting to %s\n' % (ribasis)); else:; raise ValidationError('Keyword DF_BASIS_SAPT is required.'). psi4.print_out('\n'); p4util.banner('Dimer Basis SAPT'); psi4.print_out('\n'); psi4.IO.change_file_namespace(p4const.PSIF_SAPT_MONOMERA, 'monomerA', 'dimer'); psi4.IO.change_file_namespace(p4const.PSIF_SAPT_MONOMERB, 'monomerB', 'dimer'); e_sapt = psi4.sapt(); CTd = psi4.get_variable('SAPT CT ENERGY'). psi4.print_out('\n'); p4util.banner('Monomer Basis SAPT'); psi4.print_out('\n'); psi4.IO.change_file_namespace(p4const.PSIF_SAPT_MONOMERA, 'monomerAm', 'dimer'); psi4.IO.change_file_namespace(p4const.PSIF_SAPT_MONOMERB, 'monomerBm', 'dimer'); e_sapt = psi4.sapt(); CTm = psi4.get_variable('SAPT CT ENERGY'); CT = CTd - CTm. psi4.print_out('\n\n'); psi4.print_out(' SAPT Charge Transfer Analysis\n'); psi4.print_out(' -----------------------------------------------------------------------------\n'); line1 = ' SAPT Induction (Dimer Basis) %10.4lf mH %10.4lf kcal mol^-1\n' % (CTd * 1000.0, CTd * p4const.psi_hartree2kcalmol); line2 = ' SAPT Induction (Monomer Basis) %10.4lf mH %10.4lf kcal mol^-1\n' % (CTm * 1000.0, CTm * p4const.psi_hartree2kcalmol); line3 = ' SAPT Charge Transfer %10.4lf mH %10.4lf kcal mol^-1\n\n' % (CT * 1000.0, CT * p4const.psi_hartree2kcalmol); psi4.print_out(line1); psi4.print_out(line2); psi4.print_out(line3); psi4.set_variable('SAPT CT ENERGY', CT). molecule.reset_point_group(user_pg); molecule.update_geometry(). optstash.restore(); return e_sapt. [docs]def run_mrcc(name, **kwargs):; """"""Function that prepares environment and input files; for a calculation calling Kallay's MRCC code. """"""; # TODO: Check to see if we really need to run the SCF code.; scf_helper(nam",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/proc.html:58403,ENERGY,ENERGY,58403,psi4manual/4.0b5/_modules/proc.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/proc.html,1,['ENERGY'],['ENERGY']
Energy Efficiency,"asisname, ribasisname):. self.molecule = molecule; self.basisname = basisname; self.ribasisname = ribasisname; self.basis = None; self.ribasis = None; self.da = None; self.Da = None; self.wfn = None. def __str__(self):. s = ' => Diffuse <=\n\n'; s = s + ' ' + str(self.molecule) + '\n'; s = s + ' ' + self.basisname + '\n'; s = s + ' ' + self.ribasisname + '\n'; s = s + '\n'. return s. [docs] def fitScf(self):; """"""Function to run scf and fit a system of diffuse charges to; resulting density. """"""; basisChanged = psi4.has_option_changed(""BASIS""); ribasisChanged = psi4.has_option_changed(""DF_BASIS_SCF""); scftypeChanged = psi4.has_option_changed(""SCF_TYPE""). basis = psi4.get_option(""BASIS""); ribasis = psi4.get_option(""DF_BASIS_SCF""); scftype = psi4.get_option(""SCF_TYPE""). psi4.print_out("" => Diffuse SCF (Determines Da) <=\n\n""); activate(self.molecule). psi4.set_global_option(""BASIS"", self.basisname); psi4.set_global_option(""DF_BASIS_SCF"", self.ribasisname); psi4.set_global_option(""SCF_TYPE"", ""DF""); energy('scf'); psi4.print_out(""\n""). self.fitGeneral(). psi4.clean(). psi4.set_global_option(""BASIS"", basis); psi4.set_global_option(""DF_BASIS_SCF"", ribasis); psi4.set_global_option(""SCF_TYPE"", scftype). if not basisChanged:; psi4.revoke_option_changed(""BASIS""); if not ribasisChanged:; psi4.revoke_option_changed(""DF_BASIS_SCF""); if not scftypeChanged:; psi4.revoke_option_changed(""SCF_TYPE""). [docs] def fitGeneral(self):; """"""Function to perform a general fit of diffuse charges; to wavefunction density. """"""; psi4.print_out("" => Diffuse Charge Fitting (Determines da) <=\n\n""); self.wfn = psi4.wavefunction(); self.Da = self.wfn.Da(); self.basis = self.wfn.basisset(); parser = psi4.Gaussian94BasisSetParser(); self.ribasis = psi4.BasisSet.construct(parser, self.molecule, ""DF_BASIS_SCF""). fitter = psi4.DFChargeFitter(); fitter.setPrimary(self.basis); fitter.setAuxiliary(self.ribasis); fitter.setD(self.Da); self.da = fitter.fit(); self.da.scale(2.0). [docs] def populateExtern(self, ext",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/qmmm.html:2207,energy,energy,2207,psi4manual/4.0b5/_modules/qmmm.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qmmm.html,2,['energy'],['energy']
Energy Efficiency,"asisset().name())); if ref_wfn.basisset().n_ecp_core() != base_wfn.basisset().n_ecp_core():; raise ValidationError(""Projecting from basis ({}) with ({}) ECP electrons to basis ({}) with ({}) ECP electrons will be a disaster. Select a compatible cast-up basis with `set guess_basis YOUR_BASIS_HERE`."".format(; ref_wfn.basisset().name(), ref_wfn.basisset().n_ecp_core(), base_wfn.basisset().name(), base_wfn.basisset().n_ecp_core())). pCa = ref_wfn.basis_projection(ref_wfn.Ca(), ref_wfn.nalphapi(), ref_wfn.basisset(), scf_wfn.basisset()); pCb = ref_wfn.basis_projection(ref_wfn.Cb(), ref_wfn.nbetapi(), ref_wfn.basisset(), scf_wfn.basisset()); scf_wfn.guess_Ca(pCa); scf_wfn.guess_Cb(pCb). # Print basis set info; if core.get_option(""SCF"", ""PRINT_BASIS""):; scf_wfn.basisset().print_detail_out(). # Compute additive correction: dftd3, mp2d, dftd4, etc.; if hasattr(scf_wfn, ""_disp_functor""):; disp_energy = scf_wfn._disp_functor.compute_energy(scf_wfn.molecule(), scf_wfn); scf_wfn.set_variable(""-D Energy"", disp_energy). # PCM preparation; if core.get_option('SCF', 'PCM'):; if core.get_option('SCF', 'PE'):; raise ValidationError(""""""Error: 3-layer QM/MM/PCM not implemented.\n""""""); pcmsolver_parsed_fname = core.get_local_option('PCM', 'PCMSOLVER_PARSED_FNAME'); pcm_print_level = core.get_option('SCF', ""PRINT""); scf_wfn.set_PCM(core.PCM(pcmsolver_parsed_fname, pcm_print_level, scf_wfn.basisset())). # DDPCM preparation; if core.get_option('SCF', 'DDX'):; if not solvent._have_ddx:; raise ModuleNotFoundError('Python module ddx not found. Solve by installing it: `conda install -c conda-forge pyddx` or `pip install pyddx`'); ddx_options = solvent.ddx.get_ddx_options(scf_molecule); scf_wfn.ddx = solvent.ddx.DdxInterface(; molecule=scf_molecule, options=ddx_options,; basisset=scf_wfn.basisset(); ); scf_wfn.ddx_state = None. # PE preparation; if core.get_option('SCF', 'PE'):; if not solvent._have_pe:; raise ModuleNotFoundError('Python module cppe not found. Solve by installing it: `conda insta",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/procrouting/proc.html:55755,Energy,Energy,55755,psi4manual/1.9.x/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/procrouting/proc.html,2,['Energy'],['Energy']
Energy Efficiency,"asisset().name())); if ref_wfn.basisset().n_ecp_core() != base_wfn.basisset().n_ecp_core():; raise ValidationError(""Projecting from basis ({}) with ({}) ECP electrons to basis ({}) with ({}) ECP electrons will be a disaster. Select a compatible cast-up basis with `set guess_basis YOUR_BASIS_HERE`."".format(; ref_wfn.basisset().name(), ref_wfn.basisset().n_ecp_core(), base_wfn.basisset().name(), base_wfn.basisset().n_ecp_core())). pCa = ref_wfn.basis_projection(ref_wfn.Ca(), ref_wfn.nalphapi(), ref_wfn.basisset(), scf_wfn.basisset()); pCb = ref_wfn.basis_projection(ref_wfn.Cb(), ref_wfn.nbetapi(), ref_wfn.basisset(), scf_wfn.basisset()); scf_wfn.guess_Ca(pCa); scf_wfn.guess_Cb(pCb). # Print basis set info; if core.get_option(""SCF"", ""PRINT_BASIS""):; scf_wfn.basisset().print_detail_out(). # Compute additive correction: dftd3, mp2d, dftd4, etc.; if hasattr(scf_wfn, ""_disp_functor""):; disp_energy = scf_wfn._disp_functor.compute_energy(scf_wfn.molecule(), scf_wfn); scf_wfn.set_variable(""-D Energy"", disp_energy). # PCM preparation; if core.get_option('SCF', 'PCM'):; if core.get_option('SCF', 'PE'):; raise ValidationError(""""""Error: 3-layer QM/MM/PCM not implemented.\n""""""); pcmsolver_parsed_fname = core.get_local_option('PCM', 'PCMSOLVER_PARSED_FNAME'); pcm_print_level = core.get_option('SCF', ""PRINT""); scf_wfn.set_PCM(core.PCM(pcmsolver_parsed_fname, pcm_print_level, scf_wfn.basisset())). # DDPCM preparation; if core.get_option('SCF', 'DDX'):; if not solvent._have_ddx:; raise ModuleNotFoundError('Python module ddx not found. Solve by installing it: `pip install pyddx`'); ddx_options = solvent.ddx.get_ddx_options(scf_molecule); scf_wfn.ddx = solvent.ddx.DdxInterface(; molecule=scf_molecule, options=ddx_options,; basisset=scf_wfn.basisset(); ); scf_wfn.ddx_state = None. # PE preparation; if core.get_option('SCF', 'PE'):; if not solvent._have_pe:; raise ModuleNotFoundError('Python module cppe not found. Solve by installing it: `conda install -c psi4 pycppe`'); # PE needs informa",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:55599,Energy,Energy,55599,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,1,['Energy'],['Energy']
Energy Efficiency,"asisset().name())); if ref_wfn.basisset().n_ecp_core() != base_wfn.basisset().n_ecp_core():; raise ValidationError(""Projecting from basis ({}) with ({}) ECP electrons to basis ({}) with ({}) ECP electrons will be a disaster. Select a compatible cast-up basis with `set guess_basis YOUR_BASIS_HERE`."".format(; ref_wfn.basisset().name(), ref_wfn.basisset().n_ecp_core(), base_wfn.basisset().name(), base_wfn.basisset().n_ecp_core())). pCa = ref_wfn.basis_projection(ref_wfn.Ca(), ref_wfn.nalphapi(), ref_wfn.basisset(), scf_wfn.basisset()); pCb = ref_wfn.basis_projection(ref_wfn.Cb(), ref_wfn.nbetapi(), ref_wfn.basisset(), scf_wfn.basisset()); scf_wfn.guess_Ca(pCa); scf_wfn.guess_Cb(pCb). # Print basis set info; if core.get_option(""SCF"", ""PRINT_BASIS""):; scf_wfn.basisset().print_detail_out(). # Compute additive correction: dftd3, mp2d, dftd4, etc.; if hasattr(scf_wfn, ""_disp_functor""):; disp_energy = scf_wfn._disp_functor.compute_energy(scf_wfn.molecule(), scf_wfn); scf_wfn.set_variable(""-D Energy"", disp_energy). # PCM preparation; if core.get_option('SCF', 'PCM'):; if core.get_option('SCF', 'PE'):; raise ValidationError(""""""Error: 3-layer QM/MM/PCM not implemented.\n""""""); pcmsolver_parsed_fname = core.get_local_option('PCM', 'PCMSOLVER_PARSED_FNAME'); pcm_print_level = core.get_option('SCF', ""PRINT""); scf_wfn.set_PCM(core.PCM(pcmsolver_parsed_fname, pcm_print_level, scf_wfn.basisset())). # DDPCM preparation; if core.get_option('SCF', 'DDX'):; if not solvent._have_ddx:; raise ModuleNotFoundError('Python module ddx not found. Solve by installing it: `pip install pyddx`'); ddx_options = solvent.ddx.get_ddx_options(scf_molecule); scf_wfn.ddx_state = solvent.ddx.DdxInterface(; molecule=scf_molecule, options=ddx_options,; basisset=scf_wfn.basisset(); ). # PE preparation; if core.get_option('SCF', 'PE'):; if not solvent._have_pe:; raise ModuleNotFoundError('Python module cppe not found. Solve by installing it: `conda install -c psi4 pycppe`'); # PE needs information about molecule ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:55215,Energy,Energy,55215,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,1,['Energy'],['Energy']
Energy Efficiency,"asisset().name())); if ref_wfn.basisset().n_ecp_core() != base_wfn.basisset().n_ecp_core():; raise ValidationError(""Projecting from basis ({}) with ({}) ECP electrons to basis ({}) with ({}) ECP electrons will be a disaster. Select a compatible cast-up basis with `set guess_basis YOUR_BASIS_HERE`."".format(; ref_wfn.basisset().name(), ref_wfn.basisset().n_ecp_core(), base_wfn.basisset().name(), base_wfn.basisset().n_ecp_core())). pCa = ref_wfn.basis_projection(ref_wfn.Ca(), ref_wfn.nalphapi(), ref_wfn.basisset(), scf_wfn.basisset()); pCb = ref_wfn.basis_projection(ref_wfn.Cb(), ref_wfn.nbetapi(), ref_wfn.basisset(), scf_wfn.basisset()); scf_wfn.guess_Ca(pCa); scf_wfn.guess_Cb(pCb). # Print basis set info; if core.get_option(""SCF"", ""PRINT_BASIS""):; scf_wfn.basisset().print_detail_out(). # Compute additive correction: dftd3, mp2d, dftd4, etc.; if hasattr(scf_wfn, ""_disp_functor""):; disp_energy = scf_wfn._disp_functor.compute_energy(scf_wfn.molecule(), scf_wfn); scf_wfn.set_variable(""-D Energy"", disp_energy). # PCM preparation; if core.get_option('SCF', 'PCM'):; if core.get_option('SCF', 'PE'):; raise ValidationError(""""""Error: 3-layer QM/MM/PCM not implemented.\n""""""); pcmsolver_parsed_fname = core.get_local_option('PCM', 'PCMSOLVER_PARSED_FNAME'); pcm_print_level = core.get_option('SCF', ""PRINT""); scf_wfn.set_PCM(core.PCM(pcmsolver_parsed_fname, pcm_print_level, scf_wfn.basisset())). # PE preparation; if core.get_option('SCF', 'PE'):; if not solvent._have_pe:; raise ModuleNotFoundError('Python module cppe not found. Solve by installing it: `conda install -c psi4 pycppe`'); # PE needs information about molecule and basis set; pol_embed_options = solvent.pol_embed.get_pe_options(); core.print_out(f"""""" Using potential file; {pol_embed_options[""potfile""]}; for Polarizable Embedding calculation.\n""""""); scf_wfn.pe_state = solvent.pol_embed.CppeInterface(; molecule=scf_molecule, options=pol_embed_options,; basisset=scf_wfn.basisset(); ). e_scf = scf_wfn.compute_energy(); for ob",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/_modules/psi4/driver/procrouting/proc.html:47516,Energy,Energy,47516,psi4manual/1.5.0/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/_modules/psi4/driver/procrouting/proc.html,2,['Energy'],['Energy']
Energy Efficiency,"asks is; the product. CBS TOTAL ENERGY¶. CBS CORRELATION ENERGY¶. CBS REFERENCE ENERGY¶; The total electronic energy [Eh] and its breakdown into reference total; energy [Eh] and correlation correction components [Eh] for the compound; method requested through cbs(). CCname ROOT n TOTAL ENERGY¶. TD-fctl ROOT n TOTAL ENERGY¶; The total electronic energy [Eh] for the requested theory and root n (n starts at 0).; DFT functional labeled if canonical. CCname ROOT n (IN h) TOTAL ENERGY¶. TD-fctl ROOT n (IN h) TOTAL ENERGY¶; The total electronic energy [Eh] for the requested theory and root n within irrep h (n starts at 0).; DFT functional labeled if canonical. CCname ROOT n (h) TOTAL ENERGY¶. TD-fctl ROOT n (h) TOTAL ENERGY¶; The total electronic energy [Eh] for the requested theory and root n, which is of irrep h (n starts at 0).; DFT functional labeled if canonical. CCname ROOT n TOTAL ENERGY - h TRANSITION¶. TD-fctl ROOT n TOTAL ENERGY - h TRANSITION¶; The total electronic energy [Eh] for the requested theory and root n, and the transition is of irrep h, (n starts at 0). CCname ROOT n CORRELATION ENERGY¶; The correlation energy [Eh] for the requested coupled cluster level of theory and root n (n starts at 0).; DFT functional labeled if canonical. CCname ROOT n (IN h) CORRELATION ENERGY¶; The correlation energy [Eh] for the requested coupled cluster level of theory and root n within irrep h (n starts at 0). CCname ROOT n (h) CORRELATION ENERGY¶; The correlation energy [Eh] for the requested coupled cluster level of theory and root n, which is of irrep h (n starts at 0). CCname ROOT n CORRELATION ENERGY - h TRANSITION¶; The correlation energy [Eh] for the requested coupled cluster level of theory and root n, and the transition is of irrep h, (n starts at 0). CCname ROOT n DIPOLE¶; Dipole array [e a0] for the requested coupled cluster level of theory and root n (n starts at 0), (3,). CCname ROOT n (IN h) DIPOLE¶; Dipole array [e a0] for the requested coupled cluster level ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/glossary_psivariables.html:9216,energy,energy,9216,psi4manual/1.6.x/glossary_psivariables.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/glossary_psivariables.html,1,['energy'],['energy']
Energy Efficiency,"ass Infile(qcformat.InputFormat2):. def __init__(self, mem, mol, mtd, der, opt):; qcformat.InputFormat2.__init__(self, mem, mol, mtd, der, opt). #print self.method, self.molecule.nactive_fragments(); if 'sapt' in self.method and self.molecule.nactive_fragments() != 2:; raise FragmentCountError(""""""Requested molecule has %d, not 2, fragments."""""" % (self.molecule.nactive_fragments())). # # memory in MB --> MW; # self.memory = int(math.ceil(mem / 8.0)); # # auxiliary basis sets; # [self.unaugbasis, self.augbasis, self.auxbasis] = self.corresponding_aux_basis(). [docs] def format_infile_string(self):; """""". """"""; # Handle memory and comment; memcmd, memkw = """"""# %s\n\nmemory %d mb\n\n"""""" % (self.molecule.tagline, self.memory), {}. # Handle molecule and basis set; molcmd, molkw = self.molecule.format_molecule_for_psi4(), {}. # format global convergence directions; # text += self.format_global_parameters(); _cdscmd, cdskw = muster_cdsgroup_options(). # Handle calc type and quantum chemical method; mdccmd, mdckw = procedures['energy'][self.method](self.method, self.dertype). # # format options; # optcmd = qcdb.options.prepare_options_for_psi4(mdckw). # make options from imdb only user options (currently non-existent). set basis and castup from here.; # Handle driver vs input/default keyword reconciliation; userkw = self.options; # userkw = p4util.prepare_options_for_modules(); #userkw = qcdb.options.reconcile_options(userkw, memkw); #userkw = qcdb.options.reconcile_options(userkw, molkw); #userkw = qcdb.options.reconcile_options(userkw, baskw); #userkw = qcdb.options.reconcile_options(userkw, psikw); userkw = options.reconcile_options2(userkw, cdskw); userkw = options.reconcile_options2(userkw, mdckw). # Handle conversion of psi4 keyword structure into cfour format; optcmd = options.prepare_options_for_psi4(userkw). # Handle text to be passed untouched to psi4; litcmd = """"""\nprint_variables()\n\n"""""". # Assemble infile pieces; return memcmd + molcmd + optcmd + mdccmd + litcmd. ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/psi4.html:3981,energy,energy,3981,psi4manual/1.0.0/_modules/qcdb/psi4.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/psi4.html,1,['energy'],['energy']
Energy Efficiency,ass [kg] uncertainty=0.000 000 062 e-27. helion_mass_energy_equivalent; 4.499539341E-10; helion mass energy equivalent [J] uncertainty=0.000 000 055 e-10. helion_mass_energy_equivalent_in_MeV; 2808.391586; helion mass energy equivalent in MeV [MeV] uncertainty=0.000 017. helion_mass_in_u; 3.01493224673; helion mass in u [u] uncertainty=0.000 000 000 12. helion_molar_mass; 0.00301493224673; helion molar mass [kg mol^{-1}] uncertainty=0.000 000 000 12 e-3. helion_proton_mass_ratio; 2.99315267046; helion-proton mass ratio [] uncertainty=0.000 000 000 29. hertz_atomic_mass_unit_relationship; 4.4398216616E-24; hertz-atomic mass unit relationship [u] uncertainty=0.000 000 0020 e-24. hertz_electron_volt_relationship; 4.135667662E-15; hertz-electron volt relationship [eV] uncertainty=0.000 000 025 e-15. hertz_hartree_relationship; 1.5198298460088E-16; hertz-hartree relationship [E_h] uncertainty=0.000 000 000 0090 e-16. hertz_inverse_meter_relationship; 3.335640951E-9; hertz-inverse meter relationship [m^{-1}] uncertainty=(exact). hertz_joule_relationship; 6.626070040E-34; hertz-joule relationship [J] uncertainty=0.000 000 081 e-34. hertz_kelvin_relationship; 4.7992447E-11; hertz-kelvin relationship [K] uncertainty=0.000 0028 e-11. hertz_kilogram_relationship; 7.372497201E-51; hertz-kilogram relationship [kg] uncertainty=0.000 000 091 e-51. inverse_fine_structure_constant; 137.035999139; inverse fine-structure constant [] uncertainty=0.000 000 031. inverse_meter_atomic_mass_unit_relationship; 1.33102504900E-15; inverse meter-atomic mass unit relationship [u] uncertainty=0.000 000 000 61 e-15. inverse_meter_electron_volt_relationship; 0.0000012398419739; inverse meter-electron volt relationship [eV] uncertainty=0.000 000 0076 e-6. inverse_meter_hartree_relationship; 4.556335252767E-8; inverse meter-hartree relationship [E_h] uncertainty=0.000 000 000 027 e-8. inverse_meter_hertz_relationship; 299792458; inverse meter-hertz relationship [Hz] uncertainty=(exact). inverse_meter,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/autodoc_physconst-1.html:16271,meter,meter,16271,psi4manual/1.3.2/autodoc_physconst-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/autodoc_physconst-1.html,11,['meter'],['meter']
Energy Efficiency,ass in psi4.core. PNO_CONVERGENCE (DLPNO). point_group() psi4.core.Molecule method. point_values() psi4.core.PointFunctions method. psi4.core.RKSFunctions method. psi4.core.UKSFunctions method. PointFunctions class in psi4.core. PointGroup class in psi4.core. POINTS (FINDIF). POLE_MAXITER (ADC). pop() psi4.core.BSVec method. populateExtern() psi4.driver.QMMM method. potential_grad() psi4.core.MintsHelper method. potential_variable() psi4.core.CCWavefunction method. psi4.core.CIWavefunction method. psi4.core.CUHF method. psi4.core.DFEP2Wavefunction method. psi4.core.HF method. psi4.core.RHF method. psi4.core.ROHF method. psi4.core.UHF method. psi4.core.Wavefunction method. potential_variables() psi4.core.CCWavefunction method. psi4.core.CIWavefunction method. psi4.core.CUHF method. psi4.core.DFEP2Wavefunction method. psi4.core.HF method. psi4.core.RHF method. psi4.core.ROHF method. psi4.core.UHF method. psi4.core.Wavefunction method. PotentialInt class in psi4.core. POTFILE (PE). power() psi4.core.Matrix method. PPL_TYPE (DFOCC). PR (ADC). PRECONDITIONER (DETCI). prepare_options_for_module() in module psi4.core. prerequisites. presort_so_tei() psi4.core.IntegralTransform method. PrimitiveType class in psi4.core. PRINT (CPHF). (EFP). (GLOBALS). (SAPT). print() psi4.core.DFTGrid method. psi4.core.MolecularGrid method. psi4.core.PetiteList method. print_atom_vector() psi4.core.Matrix method. PRINT_BASIS (SCF). print_bond_angles() psi4.core.Molecule method. print_cluster() psi4.core.Molecule method. print_density_threshold() psi4.core.SuperFunctional method. print_detail() psi4.core.Functional method. psi4.core.LibXCFunctional method. psi4.core.SuperFunctional method. print_detail_out() psi4.core.BasisSet method. print_distances() psi4.core.Molecule method. print_dpd_lookup() psi4.core.IntegralTransform method. print_energies() psi4.core.CUHF method. psi4.core.HF method. psi4.core.RHF method. psi4.core.ROHF method. psi4.core.UHF method. print_energy() psi4.core.Dispersio,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/genindex-1.html:106080,power,power,106080,psi4manual/1.5.0/genindex-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/genindex-1.html,2,['power'],['power']
Energy Efficiency,"ast_squares_fit_polynomial(xvals, fvals, localization_point, no_factorials=True, weighted=True, polynomial_order=4):; """"""Performs and unweighted least squares fit of a polynomial, with specified order; to an array of input function values (fvals) evaluated at given locations (xvals).; See https://doi.org/10.1063/1.4862157, particularly eqn (7) for details. """"""; xpts = np.array(xvals) - localization_point; if weighted:; R = 1.0; p_nu = 1; epsilon = 1e-3; zvals = np.square(xpts/R); weights = np.exp(-zvals) / (zvals**p_nu + epsilon**p_nu); else:; weights = None; fit = np.polynomial.polynomial.polyfit(xpts, fvals, polynomial_order, w=weights); # Remove the 1/n! coefficients; if no_factorials:; scalefac = 1.0; for n in range(2,polynomial_order+1):; scalefac *= n; fit[n] *= scalefac; return fit. [docs]def anharmonicity(rvals: List, energies: List, plot_fit: str = '', mol = None) -> Dict:; """"""Generates spectroscopic constants for a diatomic molecules.; Fits a diatomic potential energy curve using a weighted least squares approach; (c.f. https://doi.org/10.1063/1.4862157, particularly eqn. 7), locates the minimum; energy point, and then applies second order vibrational perturbation theory to obtain spectroscopic; constants. Any number of points greater than 4 may be provided, and they should bracket the minimum.; The data need not be evenly spaced, and can be provided in any order. The data are weighted such that; those closest to the minimum have highest impact. A dictionary with the following keys, which correspond to spectroscopic constants, is returned:. :param rvals: The bond lengths (in Angstrom) for which energies are; provided, of length at least 5 and equal to the length of the energies array. :param energies: The energies (Eh) computed at the bond lengths in the rvals list. :param plot_fit: A string describing where to save a plot of the harmonic and anharmonic fits, the; inputted data points, re, r0 and the first few energy levels, if matplotlib; is available. Set",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/diatomic.html:2241,energy,energy,2241,psi4manual/1.4.0/_modules/psi4/driver/diatomic.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/diatomic.html,6,['energy'],['energy']
Energy Efficiency,"aster, 2, **kwargs); fmaster.write(""""""%s('%s', **kwargs)\n\n"""""" % (optimize.__name__, lowername)); fmaster.write(instructionsM); fmaster.close(). for n, displacement in enumerate(displacements):; rfile = 'OPT-%s-%s' % (opt_iter, n + 1); #rfile = 'OPT-fd-%s' % (n + 1). # Build string of title banner; banners = ''; banners += """"""PsiMod.print_out('\\n')\n""""""; banners += """"""banner(' Gradient %d Computation: Displacement %d')\n"""""" % (opt_iter, n + 1); banners += """"""PsiMod.print_out('\\n')\n\n"""""". if (opt_mode.lower() == 'continuous'):; # Print information to output.dat; PsiMod.print_out('\n'); banner('Loading displacement %d of %d' % (n + 1, ndisp)). # Print information to the screen; print(' %d' % (n + 1), end=""""); if (n + 1) == ndisp:; print('\n', end=""""). # Load in displacement into the active molecule; PsiMod.get_active_molecule().set_geometry(displacement). # Perform the energy calculation; #E = func(lowername, **kwargs); func(lowername, **kwargs); E = PsiMod.get_variable('CURRENT ENERGY'); #E = func(**kwargs). # Save the energy; energies.append(E). # S/R: Write each displaced geometry to an input file; elif (opt_mode.lower() == 'sow'):; PsiMod.get_active_molecule().set_geometry(displacement). # S/R: Prepare molecule, options, and kwargs; freagent = open('%s.in' % (rfile), 'w'); freagent.write('# This is a psi4 input file auto-generated from the gradient() wrapper.\n\n'); freagent.write(format_molecule_for_input(molecule)); freagent.write(format_options_for_input()); format_kwargs_for_input(freagent, **kwargs). # S/R: Prepare function call and energy save; freagent.write(""""""electronic_energy = %s('%s', **kwargs)\n\n"""""" % (func.__name__, lowername)); freagent.write(""""""PsiMod.print_out('\\nGRADIENT RESULT: computation %d for item %d """""" % (os.getpid(), n + 1)); freagent.write(""""""yields electronic energy %20.12f\\n' % (electronic_energy))\n\n""""""); freagent.close(). # S/R: Read energy from each displaced geometry output file and save in energies array; elif (opt_mode.lo",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/_modules/driver.html:30140,ENERGY,ENERGY,30140,psi4manual/4.0b3/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/_modules/driver.html,2,['ENERGY'],['ENERGY']
Energy Efficiency,"astup. Demonstrates (by comparison to castup3) that output file doesn’t depend on options (scf_type) being set global or local. This input uses global. cc10; ROHF-CCSD cc-pVDZ energy for the \(^2\Sigma^+\) state of the CN radical. opt-freeze-coords; SCF/cc-pVDZ optimization example with frozen cartesian. cc27; Single point gradient of 1-1B2 state of H2O with EOM-CCSD. mpn-bh; MP(n)/aug-cc-pVDZ BH Energy Point, with n=2-19. Compare against M. L. Leininger et al., J. Chem. Phys. 112, 9213 (2000). cbs-delta-energy; Extrapolated energies with delta correction. omp2-5; SOS-OMP2 cc-pVDZ geometry optimization for the H2O molecule. scf-freq1; Analytic vs. finite difference DF-SCF frequency test for water. cc22; ROHF-EOM-CCSD/DZ on the lowest two states of each irrep in \(^{3}B_1\) CH2. cc14; ROHF-CCSD/cc-pVDZ \(^{3}B_1\) CH2 geometry optimization via analytic gradients. mp2-1; All-electron MP2 6-31G** geometry optimization of water. cepa1; cc-pvdz H2O Test CEPA(1) Energy. casscf-fzc-sp; CASSCF/6-31G** energy point. extern2; External potential calculation involving a TIP3P water and a QM water for DFMP2. Finite different test of the gradient is performed to validate forces. opt9; Various constrained energy minimizations of HOOH with cc-pvdz RHF. Cartesian-coordinate constrained optimizations of HOOH in internals. cc9a; ROHF-CCSD(T) cc-pVDZ energy for the \(^2\Sigma^+\) state of the CN radical, with Z-matrix input. mints1; Symmetry tests for a range of molecules. This doesn’t actually compute any energies, but serves as an example of the many ways to specify geometries in Psi4. dfmp2-grad5; Tests DF-MP2 gradient in the presence of a dipole field. pywrap-db3; Test that Python Molecule class processes geometry like psi4 Molecule class. cc16; ROHF and UHF-B-CCD(T)/cc-pVDZ \(^{3}B_1\) CH2 single-point energy (fzc, MO-basis \(\langle ab|cd \rangle\) ). fci-h2o; 6-31G H2O Test FCI Energy Point. ocepa1; OCEPA cc-pVDZ energy for the H2O molecule. opt-multi-dimer-c2h; Multi-fragment o",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/testsuite-1.html:16564,energy,energy,16564,psi4manual/1.1.0/testsuite-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/testsuite-1.html,4,['energy'],['energy']
Energy Efficiency,"astup3) that output file doesn’t depend on options (scf_type) being set global or local. This input uses global. cc10; ROHF-CCSD cc-pVDZ energy for the \(^2\Sigma^+\) state of the CN radical. opt-freeze-coords; SCF/cc-pVDZ optimization example with frozen cartesian. cc27; Single point gradient of 1-1B2 state of H2O with EOM-CCSD. mpn-bh; MP(n)/aug-cc-pVDZ BH Energy Point, with n=2-19. Compare against M. L. Leininger et al., J. Chem. Phys. 112, 9213 (2000). sapt-sf1; Tests the Psi4 SF-SAPT code. cbs-delta-energy; Extrapolated energies with delta correction. omp2-5; SOS-OMP2 cc-pVDZ geometry optimization for the H2O molecule. scf-freq1; Analytic vs. finite difference DF-SCF frequency test for water. cc22; ROHF-EOM-CCSD/DZ on the lowest two states of each irrep in \(^{3}B_1\) CH2. cc14; ROHF-CCSD/cc-pVDZ \(^{3}B_1\) CH2 geometry optimization via analytic gradients. mp2-1; All-electron MP2 6-31G** geometry optimization of water. cepa1; cc-pvdz H2O Test CEPA(1) Energy. casscf-fzc-sp; CASSCF/6-31G** energy point. extern2; External potential calculation involving a TIP3P water and a QM water for DFMP2. Finite different test of the gradient is performed to validate forces. opt9; Various constrained energy minimizations of HOOH with cc-pvdz RHF. Cartesian-coordinate constrained optimizations of HOOH in internals. cc9a; ROHF-CCSD(T) cc-pVDZ energy for the \(^2\Sigma^+\) state of the CN radical, with Z-matrix input. mints1; Symmetry tests for a range of molecules. This doesn’t actually compute any energies, but serves as an example of the many ways to specify geometries in Psi4. dfmp2-grad5; Tests DF-MP2 gradient in the presence of a dipole field. pywrap-db3; Test that Python Molecule class processes geometry like psi4 Molecule class. fcidump; test FCIDUMP functionality for rhf/uhf. cc16; ROHF and UHF-B-CCD(T)/cc-pVDZ \(^{3}B_1\) CH2 single-point energy (fzc, MO-basis \(\langle ab|cd \rangle\) ). fci-h2o; 6-31G H2O Test FCI Energy Point. ocepa1; OCEPA cc-pVDZ energy for the H2",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/autodoc_testsuite_corepsi4-1.html:18042,energy,energy,18042,psi4manual/1.2.1/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/autodoc_testsuite_corepsi4-1.html,4,['energy'],['energy']
Energy Efficiency,"at CCSD computationally, but it retains the; complexity of the original equations. Just as in; the familiar CCSD(T) method, the effects of connected triple excitations; may be included noniteratively to yield the QCISD(T) method. Both the; QCISD(T) and CCSD(T) methods are implemented for closed-shell references; in the FNOCC module. Many-body perturbation theory¶; QCI and CC methods are closely related to perturbation theory, and the; MP2, MP3, and MP4(SDQ) correlation energies can be obtained as a free; by-product of a CCSD or QCISD computation. The following is an; example of the results for a computation run with the call; energy('fno-qcisd') to energy():; QCISD iterations converged!. OS MP2 FNO correction: -0.000819116338; SS MP2 FNO correction: -0.000092278158; MP2 FNO correction: -0.000911394496. OS MP2 correlation energy: -0.166478414245; SS MP2 correlation energy: -0.056669079827; MP2 correlation energy: -0.223147494072; * MP2 total energy: -76.258836941658. OS MP2.5 correlation energy: -0.171225850256; SS MP2.5 correlation energy: -0.054028401038; MP2.5 correlation energy: -0.225254251294; * MP2.5 total energy: -76.260943698880. OS MP3 correlation energy: -0.175973286267; SS MP3 correlation energy: -0.051387722248; MP3 correlation energy: -0.227361008515; * MP3 total energy: -76.263050456101. OS MP4(SDQ) correlation energy: -0.180324322304; SS MP4(SDQ) correlation energy: -0.048798468084; MP4(SDQ) correlation energy: -0.230995119324; * MP4(SDQ) total energy: -76.266684566910. OS QCISD correlation energy: -0.181578117924; SS QCISD correlation energy: -0.049853548145; QCISD correlation energy: -0.231431666069; * QCISD total energy: -76.267121113654. The first set of energies printed corresponds to the second-order FNO; correction mentioned previously. Results for many-body perturbation; theory through partial fourth order are then provided.; The notation MP4(SDQ) indicates that we have included all contributions to; the correlation energy through fourth order,",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/fnocc-1.html:4780,energy,energy,4780,psi4manual/1.0.0/fnocc-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/fnocc-1.html,6,['energy'],['energy']
Energy Efficiency,"at Quick Installation),; the gcp executable can be obtained through conda install gcp -c psi4; or conda install gcp-correction -c conda-forge.; To remove a conda installation, conda remove gcp or conda remove gcp-correction. Source. If using PSI4 built from source and you want to build gCP from; from source also, follow the instructions provided with the source; (essentially, download the freely available tarball, unpack the source,; edit the Makefile to select a Fortran compiler, and run make). To be used by PSI4, the program binary (gcp or mctc-gcp) must be; found in your PATH so that QCEngine can detect it. Check if and where; found through qcengine info. If; PSI4 is unable to execute the binary, an error will be reported.; To preferentially use a particular gcp compilation, simply adjust its; position in the path environment variables. Running gCP¶; At present there is a limited interface to gCP that is used; only to implement the “HF-3c” [Sure:2013:1672], “PBEh-3c”; [Grimme:2015:054107], “B97-3c” [Brandenburg:2018:b973c], “r2SCAN-3c” [Grimme:2021:064103],; and “wB97X-3c” [Muller:2023:014103] methods (both energy and gradient).; The interface can use classic or mctc-gcp executables but only the latter implements “B97-3c” and “r2SCAN-3c”.; The newest wB97X-3c method doesn’t use a gcp correction (it does use ECPs down to first row elements); but is listed here for completeness of the “3c” family.; A DFTD3 executable, classic or simple-dftd3, must also be available for; the HF-3c, PBEh-3c, or B97-3c methods to run.; A DFTD4 python module must also be available for; the r2SCAN-3c or wB97X-3c methods to run.; These method are defined with their own basis set and thus no basis set should be set by the user.; PSI4 will select the intended basis sets: HF-3c/MINIX, PBEh-3c/def2-mSVP, B97-3c/def2-mTZVP, r2SCAN-3c/def2-mTZVPP, wB97X-3c/vDZP.; If a basis has previously been set for another calculation, use the slash syntax to “empty” the basis; option for the scope of the c",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/gcp.html:2251,energy,energy,2251,psi4manual/1.9.x/gcp.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/gcp.html,2,['energy'],['energy']
Energy Efficiency,"at excitation is only allowed if it is a single or double. dft-grad-lr2; Tests CAM gradients with and without XC pieces to narrow grid error. dfccd1; DF-CCD cc-pVDZ energy for the H2O molecule. fsaptd-terms; F-SAPT0/jun-cc-pvdz procedure for methane dimer. cc8; UHF-CCSD(T) cc-pVDZ frozen-core energy for the \(^2\Sigma^+\) state of the CN radical, with Z-matrix input. fnocc3; Test FNO-QCISD(T) computation. cc39; RHF-CC2-LR/cc-pVDZ dynamic polarizabilities of HOF molecule. dfomp2-2; OMP2 cc-pVDZ energy for the NO molecule. cc40; RHF-CC2-LR/cc-pVDZ optical rotation of H2O2. gauge = length, omega= (589 355 nm). dfcasscf-sa-sp; Example of state-averaged CASSCF for the C2 molecule. opt-irc-2; Compute the IRC for HCN <-> NCH interconversion at the RHF/DZP level of theory. cisd-h2o+-1; 6-31G** H2O+ Test CISD Energy Point. aediis-1; ADIIS test case, from 10.1063/1.3304922. scf-response2; Compute the dipole polarizability for water with custom basis set. cbs-xtpl-wrapper; RHF aug-cc-pVQZ energy for the BH molecule, with Cartesian input. Various gradients for a strained helium dimer and water molecule. scf-coverage; Lithium test for coverage. pywrap-checkrun-rhf; This checks that all energy methods can run with a minimal input and set symmetry. cisd-sp; 6-31G** H2O Test CISD Energy Point. tdscf-7; TD-HF test variable access. mbis-2; MBIS calculation on OH- (Expanded Arrays). sapt-dft1; SAPT(DFT) aug-cc-pVDZ interaction energy between Ne and Ar atoms. fci-h2o-fzcv; 6-31G H2O Test FCI Energy Point. mints3; Test individual integral objects for correctness. cbs-xtpl-nbody; RHF interaction energies using nbody and cbs parts of the driver Ne dimer with mp2/v[dt]z + d:ccsd(t)/vdz. cisd-opt-fd; H2O CISD/6-31G** Optimize Geometry by Energies. linK-3; UHF and ROHF Linear Exchange Algorithm test for benzyl cation. pubchem2; Superficial test of PubChem interface. sapt3; SAPT2+3(CCD) aug-cc-pVDZ+midbond computation of the water dimer interaction energy, using the aug-cc-pVDZ-JKFIT DF basis",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/autodoc_testsuite_corepsi4.html:5210,energy,energy,5210,psi4manual/1.8.x/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/autodoc_testsuite_corepsi4.html,2,['energy'],['energy']
Energy Efficiency,"at extrapolation stage as `scf` or `corl`, by default only the first stage is `scf` and every later one is `corl`.; `stage`: tag for the stage used in tables. The next items in the `cbs_metadata` array extrapolate correlation. All of the above parameters are available, with only the `wfn` and `basis` keywords required. Other supported parameters are:. `wfn_lo`: the lower method from which the delta correction is to be calculated. By default, it is set to `wfn` from the previous field in the `cbs_metadata` array.; `basis_lo`: basis set to be used for the delta correction. By default, it is the same as the `basis` specified above. Others. Parameters; molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. Examples. >>> # [1] replicates with cbs() the simple model chemistry scf/cc-pVDZ: set basis cc-pVDZ energy('scf'); >>> energy(cbs, scf_wfn='scf', scf_basis='cc-pVDZ'). >>> # [2] replicates with cbs() the simple model chemistry mp2/jun-cc-pVDZ: set basis jun-cc-pVDZ energy('mp2'); >>> energy(cbs, corl_wfn='mp2', corl_basis='jun-cc-pVDZ'). >>> # [3] DTQ-zeta extrapolated scf reference energy; >>> energy('cbs', scf_wfn='scf', scf_basis='cc-pV[DTQ]Z', scf_scheme='scf_xtpl_helgaker_3'). >>> # [4] DT-zeta extrapolated mp2 correlation energy atop a T-zeta reference; >>> energy('cbs', corl_wfn='mp2', corl_basis='cc-pv[dt]z', corl_scheme='corl_xtpl_helgaker_2'). >>> # [5] a DT-zeta extrapolated coupled-cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference (both equivalent); >>> energy('cbs', corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z'); >>> energy('cbs', corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme='corl_xtpl_helgaker_2', delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z', delta_scheme='corl_xtpl_helgaker_2'). >>> # [6] a D-zeta ccsd(t) correction atop a DT-zeta extrapolated ccsd cluster correction atop a TQ-zeta extrapolated mp2 correlation ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/api/psi4.driver.cbs.html:12701,energy,energy,12701,psi4manual/1.6.x/api/psi4.driver.cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/api/psi4.driver.cbs.html,6,['energy'],['energy']
Energy Efficiency,"at extrapolation stage as `scf` or `corl`, by default only the first stage is `scf` and every later one is `corl`.; `stage`: tag for the stage used in tables. The next items in the `cbs_metadata` array extrapolate correlation. All of the above parameters are available, with only the `wfn` and `basis` keywords required. Other supported parameters are:. `wfn_lo`: the lower method from which the delta correction is to be calculated. By default, it is set to `wfn` from the previous field in the `cbs_metadata` array.; `basis_lo`: basis set to be used for the delta correction. By default, it is the same as the `basis` specified above. Others. Parameters; molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. Examples. >>> # [1] replicates with cbs() the simple model chemistry scf/cc-pVDZ: set basis cc-pVDZ energy('scf'); >>> energy(cbs, scf_wfn='scf', scf_basis='cc-pVDZ'). >>> # [2] replicates with cbs() the simple model chemistry mp2/jun-cc-pVDZ: set basis jun-cc-pVDZ energy('mp2'); >>> energy(cbs, corl_wfn='mp2', corl_basis='jun-cc-pVDZ'). >>> # [3] DTQ-zeta extrapolated scf reference energy; >>> energy(cbs, scf_wfn='scf', scf_basis='cc-pV[DTQ]Z', scf_scheme=scf_xtpl_helgaker_3). >>> # [4] DT-zeta extrapolated mp2 correlation energy atop a T-zeta reference; >>> energy(cbs, corl_wfn='mp2', corl_basis='cc-pv[dt]z', corl_scheme=corl_xtpl_helgaker_2). >>> # [5] a DT-zeta extrapolated coupled-cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference (both equivalent); >>> energy(cbs, corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z'); >>> energy(cbs, corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z', delta_scheme=corl_xtpl_helgaker_2). >>> # [6] a D-zeta ccsd(t) correction atop a DT-zeta extrapolated ccsd cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/api/psi4.driver.cbs-1.html:12693,energy,energy,12693,psi4manual/1.4.0/api/psi4.driver.cbs-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/api/psi4.driver.cbs-1.html,24,['energy'],['energy']
Energy Efficiency,"at order). If; PSI4 is unable to execute the binary, an error will be reported.; To preferentially use a particular gcp compilation, simply adjust its; position in the path environment variables. Running gCP¶; At present there is a limited interface to gCP that is used; only to implement the “HF-3c” [Sure:2013:1672] and “PBEh-3c”; [Grimme:2015:054107] methods (both energy and gradient). The DFTD3 executable must also be available for these methods to; run. Unlike every other method in PSI4, if a basis set has not been; set, these will default to their intended basis sets: MINIX for HF-3c; and def2-mSVP for PBEh-3c. If a basis has previously been set, but you; want to use the default basis, use the slash syntax to “empty” the basis; option for the scope of the current calculation, energy(""hf3c/"").; A few practical examples:. HF-3c single point with default minix basis; energy('hf3c'). PBEh-3c optimization with default def2-mSVP basis; optimize('pbeh3c'). HF-3c with non-standard basis; set basis cc-pvdz; energy('hf3c'). PBEh-3c with default basis after basis set; set basis cc-pvdz; energy('pbeh3c/'). If only BSSE/basis set corrections (rather than total energies) are of; interest, the gcp program can be run independently of the scf; through the python function run_gcp(). (This function; is the same PSI4/gcp interface that is called during an scf job.); This route is much faster than running a HF or DFT energy.; molecule nene {; Ne; Ne 1 2.0; }. nene.update_geometry(). >>> E, G = nene.run_gcp('hf3c'). >>> E, G = nene.run_gcp(func='HF3c', verbose=True). qcdb.Molecule.run_gcp(self, func=None, dertype=None, verbose=1)¶; Compute geometrical BSSE correction via Grimme’s GCP program.; Function to call Grimme’s GCP program; https://www.chemie.uni-bonn.de/pctc/mulliken-center/software/gcp/gcp; to compute an a posteriori geometrical BSSE correction to self for; several HF, generic DFT, and specific HF-3c and PBEh-3c method/basis; combinations, func. Returns energy if dertype is",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/gcp-1.html:2253,energy,energy,2253,psi4manual/1.4.0/gcp-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/gcp-1.html,5,['energy'],['energy']
Energy Efficiency,"at the larger basis set in 2-point; extrapolation.; verbose; Controls volume of printing.; alpha; Overrides the default :math:`\alpha = 3.4`. Returns; -------; float or ndarray; Eponymous function applied to input zetas and values; type from `valueLO`. Notes; -----; The extrapolation is calculated according to [2]_:; :math:`E_{total}^X = E_{total}^{\infty} + \beta X^{-\alpha}, \alpha = 3.4`. References; ----------. .. [2] Truhlar, Chem. Phys. Lett. 294 (1998) 45-48,; DOI: 10.1016/S0009-2614(98)00866-5. """""". if type(valueLO) != type(valueHI):; raise ValidationError(; f""scf_xtpl_truhlar_2: Inputs must be of the same datatype! ({type(valueLO)}, {type(valueHI)})""). if alpha is None:; alpha = 3.40. beta_division = 1 / (zHI**(-1 * alpha) - zLO**(-1 * alpha)); beta_mult = zHI**(-1 * alpha). if isinstance(valueLO, float):; beta = (valueHI - valueLO) * beta_division; value = valueHI - beta * beta_mult. if verbose:; # Output string with extrapolation parameters; cbsscheme = ''; cbsscheme += """"""\n ==> Truhlar 2-point power form SCF extrapolation for method: %s <==\n\n"""""" % (; functionname.upper()); cbsscheme += """""" LO-zeta (%s) Energy: % 16.12f\n"""""" % (str(zLO), valueLO); cbsscheme += """""" HI-zeta (%s) Energy: % 16.12f\n"""""" % (str(zHI), valueHI); cbsscheme += """""" Alpha (exponent) Value: % 16.12f\n"""""" % (alpha); cbsscheme += """""" Beta (coefficient) Value: % 16.12f\n\n"""""" % (beta). name_str = ""%s/(%s,%s)"" % (functionname.upper(), _zeta_val2sym[zLO].upper(), _zeta_val2sym[zHI].upper()); cbsscheme += """""" @Extrapolated """"""; cbsscheme += name_str + ':'; cbsscheme += "" "" * (18 - len(name_str)); cbsscheme += """"""% 16.12f\n\n"""""" % value; core.print_out(cbsscheme); logger.debug(cbsscheme). return value. elif isinstance(valueLO, np.ndarray):. beta = (valueHI - valueLO) * beta_division; value = valueHI - beta * beta_mult. if verbose > 2:; cbsscheme = f""""""\n ==> Truhlar 2-point power SCF extrapolation for method: {functionname.upper()} <==\n""""""; cbsscheme += f""""""\n LO-zeta ({zLO}) Data\n""""""; c",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver_cbs_helper.html:8367,power,power,8367,psi4manual/1.6.x/_modules/psi4/driver/driver_cbs_helper.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver_cbs_helper.html,2,['power'],['power']
Energy Efficiency,"at well bottom at 0 [K] {:15.8f} [Eh]"""""".format(E0). text += """"""\n\n Zero-point energy, ZPE_vib = Sum_i nu_i / 2""""""; for term in terms:; text += format_ZPE_E_H_G.format(terms[term] + ' ZPE', *sm[('ZPE', term)] * uconv); if term in ['vib', 'corr']:; text += """""" {:15.3f} [cm^-1]"""""".format(sm[('ZPE', term)] * qcel.constants.hartree2wavenumbers); text += """"""\n Total ZPE, Electronic energy at 0 [K] {:15.8f} [Eh]"""""".format(; sm[('ZPE', 'tot')]). text += """"""\n\n Thermal Energy, E (includes ZPE)""""""; for term in terms:; text += format_ZPE_E_H_G.format(terms[term] + ' E', *sm[('E', term)] * uconv); text += """"""\n Total E, Electronic energy at {:7.2f} [K] {:15.8f} [Eh]"""""".format(; T, sm[('E', 'tot')]). text += """"""\n\n Enthalpy, H_trans = E_trans + k_B * T""""""; for term in terms:; text += format_ZPE_E_H_G.format(terms[term] + ' H', *sm[('H', term)] * uconv); text += """"""\n Total H, Enthalpy at {:7.2f} [K] {:15.8f} [Eh]"""""".format(; T, sm[('H', 'tot')]). text += """"""\n\n Gibbs free energy, G = H - T * S""""""; for term in terms:; text += format_ZPE_E_H_G.format(terms[term] + ' G', *sm[('G', term)] * uconv); text += """"""\n Total G, Free enthalpy at {:7.2f} [K] {:15.8f} [Eh]\n"""""".format(; T, sm[('G', 'tot')]). return therminfo, text. [docs]; def filter_nonvib(vibinfo: Dict[str, Datum], remove: List[int] = None) -> Dict[str, Datum]:; """"""From a dictionary of vibration Datum, remove normal coordinates. Parameters; ----------; vibinfo; Results of Hessian analysis.; remove; 0-indexed indices of normal modes to remove from `vibinfo`. If; None, non-vibrations (R, T, or TR as labeled in `vibinfo['TRV']`); will be removed. Returns; -------; dict; Copy of input `vibinfo` with the specified modes removed from all; dictionary entries. Examples; --------; >>> # after a harmonic analysis, remove first translations and rotations and then all non-A1 vibs; >>> allnormco = harmonic_analysis(...); >>> allvibs = filter_nonvib(allnormco); >>> a1vibs = filter_nonvib(allvibs, remove=[i for i, d in enumerate(allvi",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qcdb/vib.html:38206,energy,energy,38206,psi4manual/1.8.x/_modules/psi4/driver/qcdb/vib.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qcdb/vib.html,2,['energy'],['energy']
Energy Efficiency,"at well bottom at 0 [K] {:15.8f} [Eh]"""""".format(E0). text += """"""\n\n Zero-point energy, ZPE_vib = Sum_i nu_i / 2""""""; for term in terms:; text += format_ZPE_E_H_G.format(terms[term] + ' ZPE', *sm[('ZPE', term)] * uconv); if term in ['vib', 'corr']:; text += """""" {:15.3f} [cm^-1]"""""".format(sm[('ZPE', term)] * qcel.constants.hartree2wavenumbers); text += """"""\n Total ZPE, Electronic energy at 0 [K] {:15.8f} [Eh]"""""".format(; sm[('ZPE', 'tot')]). text += """"""\n\n Thermal Energy, E (includes ZPE)""""""; for term in terms:; text += format_ZPE_E_H_G.format(terms[term] + ' E', *sm[('E', term)] * uconv); text += """"""\n Total E, Electronic energy at {:7.2f} [K] {:15.8f} [Eh]"""""".format(; T, sm[('E', 'tot')]). text += """"""\n\n Enthalpy, H_trans = E_trans + k_B * T""""""; for term in terms:; text += format_ZPE_E_H_G.format(terms[term] + ' H', *sm[('H', term)] * uconv); text += """"""\n Total H, Enthalpy at {:7.2f} [K] {:15.8f} [Eh]"""""".format(; T, sm[('H', 'tot')]). text += """"""\n\n Gibbs free energy, G = H - T * S""""""; for term in terms:; text += format_ZPE_E_H_G.format(terms[term] + ' G', *sm[('G', term)] * uconv); text += """"""\n Total G, Free enthalpy at {:7.2f} [K] {:15.8f} [Eh]\n"""""".format(; T, sm[('G', 'tot')]). return therminfo, text. [docs]def filter_nonvib(vibinfo: Dict[str, Datum], remove: List[int] = None) -> Dict[str, Datum]:; """"""From a dictionary of vibration Datum, remove normal coordinates. Parameters; ----------; vibinfo; Results of Hessian analysis.; remove; 	 0-indexed indices of normal modes to remove from `vibinfo`. If; 	 None, non-vibrations (R, T, or TR as labeled in `vibinfo['TRV']`); 	 will be removed. Returns; -------; dict; Copy of input `vibinfo` with the specified modes removed from all; dictionary entries. Examples; --------; >>> # after a harmonic analysis, remove first translations and rotations and then all non-A1 vibs; >>> allnormco = harmonic_analysis(...); >>> allvibs = filter_nonvib(allnormco); >>> a1vibs = filter_nonvib(allvibs, remove=[i for i, d in enumerate(a",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/qcdb/vib.html:38192,energy,energy,38192,psi4manual/1.4.0/_modules/psi4/driver/qcdb/vib.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/qcdb/vib.html,4,['energy'],['energy']
Energy Efficiency,"at well bottom at 0 [K] {:15.8f} [Eh]"""""".format(E0). text += """"""\n\n Zero-point energy, ZPE_vib = Sum_i nu_i / 2""""""; for term in terms:; text += format_ZPE_E_H_G.format(terms[term] + ' ZPE', *sm[('ZPE', term)] * uconv); if term in ['vib', 'corr']:; text += """""" {:15.3f} [cm^-1]"""""".format(sm[('ZPE', term)] * qcel.constants.hartree2wavenumbers); text += """"""\n Total ZPE, Electronic energy at 0 [K] {:15.8f} [Eh]"""""".format(; sm[('ZPE', 'tot')]). text += """"""\n\n Thermal Energy, E (includes ZPE)""""""; for term in terms:; text += format_ZPE_E_H_G.format(terms[term] + ' E', *sm[('E', term)] * uconv); text += """"""\n Total E, Electronic energy at {:7.2f} [K] {:15.8f} [Eh]"""""".format(; T, sm[('E', 'tot')]). text += """"""\n\n Enthalpy, H_trans = E_trans + k_B * T""""""; for term in terms:; text += format_ZPE_E_H_G.format(terms[term] + ' H', *sm[('H', term)] * uconv); text += """"""\n Total H, Enthalpy at {:7.2f} [K] {:15.8f} [Eh]"""""".format(; T, sm[('H', 'tot')]). text += """"""\n\n Gibbs free energy, G = H - T * S""""""; for term in terms:; text += format_ZPE_E_H_G.format(terms[term] + ' G', *sm[('G', term)] * uconv); text += """"""\n Total G, Free enthalpy at {:7.2f} [K] {:15.8f} [Eh]\n"""""".format(; T, sm[('G', 'tot')]). return therminfo, text. [docs]def filter_nonvib(vibinfo: Dict[str, Datum], remove: List[int] = None) -> Dict[str, Datum]:; """"""From a dictionary of vibration Datum, remove normal coordinates. Parameters; ----------; vibinfo; Results of Hessian analysis.; remove; 0-indexed indices of normal modes to remove from `vibinfo`. If; None, non-vibrations (R, T, or TR as labeled in `vibinfo['TRV']`); will be removed. Returns; -------; dict; Copy of input `vibinfo` with the specified modes removed from all; dictionary entries. Examples; --------; >>> # after a harmonic analysis, remove first translations and rotations and then all non-A1 vibs; >>> allnormco = harmonic_analysis(...); >>> allvibs = filter_nonvib(allnormco); >>> a1vibs = filter_nonvib(allvibs, remove=[i for i, d in enumerate(allvibs",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qcdb/vib.html:38192,energy,energy,38192,psi4manual/1.6.x/_modules/psi4/driver/qcdb/vib.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qcdb/vib.html,4,['energy'],['energy']
Energy Efficiency,"at well bottom at 0 [K] {:15.8f} [Eh]"""""".format(E0). text += """"""\n\n Zero-point energy, ZPE_vib = Sum_i nu_i / 2""""""; for term in terms:; text += format_ZPE_E_H_G.format(terms[term] + ' ZPE', *sm[('ZPE', term)] * uconv); if term in ['vib', 'corr']:; text += """""" {:15.3f} [cm^-1]"""""".format(sm[('ZPE', term)] * qcel.constants.hartree2wavenumbers); text += """"""\n Total ZPE, Electronic energy at 0 [K] {:15.8f} [Eh]"""""".format(; sm[('ZPE', 'tot')]). text += """"""\n\n Thermal Energy, E (includes ZPE)""""""; for term in terms:; text += format_ZPE_E_H_G.format(terms[term] + ' E', *sm[('E', term)] * uconv); text += """"""\n Total E, Electronic energy at {:7.2f} [K] {:15.8f} [Eh]"""""".format(; T, sm[('E', 'tot')]). text += """"""\n\n Enthalpy, H_trans = E_trans + k_B * T""""""; for term in terms:; text += format_ZPE_E_H_G.format(terms[term] + ' H', *sm[('H', term)] * uconv); text += """"""\n Total H, Enthalpy at {:7.2f} [K] {:15.8f} [Eh]"""""".format(; T, sm[('H', 'tot')]). text += """"""\n\n Gibbs free energy, G = H - T * S""""""; for term in terms:; text += format_ZPE_E_H_G.format(terms[term] + ' G', *sm[('G', term)] * uconv); text += """"""\n Total G, Free enthalpy at {:7.2f} [K] {:15.8f} [Eh]\n"""""".format(; T, sm[('G', 'tot')]). return therminfo, text. def filter_nonvib(vibinfo: Dict[str, Datum], remove: List[int] = None) -> Dict[str, Datum]:; """"""From a dictionary of vibration Datum, remove normal coordinates. Parameters; ----------; vibinfo; Results of Hessian analysis.; remove; 0-indexed indices of normal modes to remove from `vibinfo`. If; None, non-vibrations (R, T, or TR as labeled in `vibinfo['TRV']`); will be removed. Returns; -------; dict; Copy of input `vibinfo` with the specified modes removed from all; dictionary entries. Examples; --------; >>> # after a harmonic analysis, remove first translations and rotations and then all non-A1 vibs; >>> allnormco = harmonic_analysis(...); >>> allvibs = filter_nonvib(allnormco); >>> a1vibs = filter_nonvib(allvibs, remove=[i for i, d in enumerate(allvibs['gamm",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/qcdb/vib.html:38126,energy,energy,38126,psi4manual/1.6.x/_modules/qcdb/vib.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/qcdb/vib.html,6,['energy'],['energy']
Energy Efficiency,"at when employing the X2C relativistic Hamiltonian, that you use a fully; decontracted basis set. This can be done simply in the input by adding “-decon” to the; name of the primary basis you want to use for the calculation as detailed in; Decontracted Basis Sets. Publications resulting from the use; of X2C should cite the following publication: [Verma:2015]. Theory¶; X2C is based on exact decoupling of; positive-energy ( \(h^{FW}_{\rm ++}\); ) and negative-energy (\(h^{FW}_{\rm --}\) ); blocks of the Dirac Hamiltonian (\(h^{D}\)). \[\begin{split}U^\dagger h^{\rm D} U =; U^\dagger; \begin{pmatrix}; h_{LL} & h_{LS} \\; h_{SL} & h_{SS}; \end{pmatrix}; U; =; \begin{pmatrix}; h^{\rm FW}_{++} & 0 \\; 0 & h^{\rm FW}_{--}; \end{pmatrix}\end{split}\]; The transformation ( \(U\) ) is obtained from the solutions of the Dirac equation in kinetically balanced basis [Kutzelnigg:1984] treatment.; In the X2C treatment, the positive-energy block of the Hamiltonian ( \(h^{FW}_{\rm ++}\) ); is given by the sum; of a transformed kinetic (\(T_{\rm X2C}\)) and potential energy ( \(V_{\rm X2C}\) ) contribution.; Relativistic kinetic energy ( \(T_{\rm X2C}\) ) and nuclear-electron interaction potential ( \(V_{\rm X2C}\) ) is given in terms of non-relativisitc kinetic (\(T=\hat{p}^2/2\)) energy and nuclear-electron interaction potential (\(V\)), coupling matrix ( \(X\)) and renormalization matrix ( \(R\)). \[T_{\rm X2C} = R^{\dagger} (TX + {X}^{\dagger}T - {X}^{\dagger}TX ) R\]. \[V_{\rm X2C} = R^{\dagger}(V + \frac{1}{4c^2} X^{\dagger}W^{\text{SF}}X) R\]; The coupling matrix ( \({X} = C^{S} (C^{L})^{-1}\) ) is obtained from the large (\(C^{\rm L}\)) and small (\(C^{\rm S}\)) components of the \(N\) positive energy solutions of the Dirac equation.; The renormalization matrix; \({R}=S^{-1/2}(S^{-1/2}\tilde{S}S^{-1/2})^{-1/2}S^{1/2}\),; depends on the modified overlap matrix; \(\tilde{S}=S+\frac{1}{2c^2}X^{\dagger}TX\). The integrals \(W^{\rm SF}_{\mu\nu} = \langle {\chi_\mu} | \hat{p}\cdot ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/relativistic-1.html:3526,energy,energy,3526,psi4manual/1.1.0/relativistic-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/relativistic-1.html,30,['energy'],['energy']
Energy Efficiency,"at(; T, sm[('E', 'tot')]). text += """"""\n\n Enthalpy, H_trans = E_trans + k_B * T = E_trans + P * V""""""; for term in terms:; if term in ['elec']:; text += format_ZPE_E_H_G.format(terms[term] + ' contrib to H beyond E_e', *sm[('H', term)] * uconv); elif term in ['corr']:; text += format_ZPE_E_H_G.format(terms[term] + ' H', *sm[('H', term)] * uconv); else:; text += format_ZPE_E_H_G.format(terms[term] + ' contrib to H', *sm[('H', term)] * uconv); text += """"""\n Total H, Enthalpy at {:7.2f} [K] {:15.8f} [Eh]"""""".format(; T, sm[('H', 'tot')]); text += """"""\n *** Absolute enthalpy, not an enthalpy of formation ***"""""". text += """"""\n\n Gibbs free energy, G = H - T * S""""""; for term in terms:; if term in ['elec']:; text += format_ZPE_E_H_G.format(terms[term] + ' contrib to G beyond E_e', *sm[('G', term)] * uconv); elif term in ['corr']:; text += format_ZPE_E_H_G.format(terms[term] + ' G', *sm[('G', term)] * uconv); else:; text += format_ZPE_E_H_G.format(terms[term] + ' contrib to G', *sm[('G', term)] * uconv); text += """"""\n Total G, Gibbs energy at {:7.2f} [K] {:15.8f} [Eh]"""""".format(; T, sm[('G', 'tot')]); text += """"""\n *** Absolute Gibbs energy, not a free energy of formation ***\n\n"""""" . return therminfo, text. [docs]; def filter_nonvib(vibinfo: Dict[str, Datum], remove: List[int] = None) -> Dict[str, Datum]:; """"""From a dictionary of vibration Datum, remove normal coordinates. Parameters; ----------; vibinfo; Results of Hessian analysis.; remove; 0-indexed indices of normal modes to remove from `vibinfo`. If; None, non-vibrations (R, T, or TR as labeled in `vibinfo['TRV']`); will be removed. Returns; -------; dict; Copy of input `vibinfo` with the specified modes removed from all; dictionary entries. Examples; --------; >>> # after a harmonic analysis, remove first translations and rotations and then all non-A1 vibs; >>> allnormco = harmonic_analysis(...); >>> allvibs = filter_nonvib(allnormco); >>> a1vibs = filter_nonvib(allvibs, remove=[i for i, d in enumerate(allvibs['gamma'",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/qcdb/vib.html:39315,energy,energy,39315,psi4manual/1.9.x/_modules/psi4/driver/qcdb/vib.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/qcdb/vib.html,4,['energy'],['energy']
Energy Efficiency,"at(; T, sm[('E', 'tot')]). text += """"""\n\n Enthalpy, H_trans = E_trans + k_B * T = E_trans + P * V""""""; for term in terms:; if term in ['elec']:; text += format_ZPE_E_H_G.format(terms[term] + ' contrib to H beyond E_e', *sm[('H', term)] * uconv); elif term in ['corr']:; text += format_ZPE_E_H_G.format(terms[term] + ' H', *sm[('H', term)] * uconv); else:; text += format_ZPE_E_H_G.format(terms[term] + ' contrib to H', *sm[('H', term)] * uconv); text += """"""\n Total H, Enthalpy at {:7.2f} [K] {:15.8f} [Eh]"""""".format(; T, sm[('H', 'tot')]); text += """"""\n *** Absolute enthalpy, not an enthalpy of formation ***"""""". text += """"""\n\n Gibbs free energy, G = H - T * S""""""; for term in terms:; if term in ['elec']:; text += format_ZPE_E_H_G.format(terms[term] + ' contrib to G beyond E_e', *sm[('G', term)] * uconv); elif term in ['corr']:; text += format_ZPE_E_H_G.format(terms[term] + ' G', *sm[('G', term)] * uconv); else:; text += format_ZPE_E_H_G.format(terms[term] + ' contrib to G', *sm[('G', term)] * uconv); text += """"""\n Total G, Gibbs energy at {:7.2f} [K] {:15.8f} [Eh]"""""".format(; T, sm[('G', 'tot')]); text += """"""\n *** Absolute Gibbs energy, not a free energy of formation ***\n\n"""""" . return therminfo, text. def filter_nonvib(vibinfo: Dict[str, Datum], remove: List[int] = None) -> Dict[str, Datum]:; """"""From a dictionary of vibration Datum, remove normal coordinates. Parameters; ----------; vibinfo; Results of Hessian analysis.; remove; 0-indexed indices of normal modes to remove from `vibinfo`. If; None, non-vibrations (R, T, or TR as labeled in `vibinfo['TRV']`); will be removed. Returns; -------; dict; Copy of input `vibinfo` with the specified modes removed from all; dictionary entries. Examples; --------; >>> # after a harmonic analysis, remove first translations and rotations and then all non-A1 vibs; >>> allnormco = harmonic_analysis(...); >>> allvibs = filter_nonvib(allnormco); >>> a1vibs = filter_nonvib(allvibs, remove=[i for i, d in enumerate(allvibs['gamma'].data) ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/_modules/qcdb/vib.html:39239,energy,energy,39239,psi4manual/1.9.x/_modules/qcdb/vib.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/_modules/qcdb/vib.html,4,['energy'],['energy']
Energy Efficiency,"at_cfour()[source]¶; Prints the updated geometry, in the format provided by the user.; This, for Cfour, not different from regular version. set_coordinates(x, y, z)[source]¶; Given the current set of coordinates, updates the values of this; atom’s coordinates and any variables that may depend on it. type()[source]¶; The type of CoordEntry specialization. class CoordEntry(entry_number, Z, charge, mass, symbol, label='', basis=None, shells=None)[source]¶; Class to store all the attributes associated with an atom, not the; larger Molecule. Specialized into CartesianEntry and ZMatrixEntry. Z()[source]¶; The nuclear charge of the current atom (0 if ghosted). static a(a1, a2, a3)[source]¶; Computes the angle (in rad.) between three sets of coordinates. basisset(role='BASIS')[source]¶; Returns the basis name for the provided type.; * @param type Keyword from input file.; * @returns the value from input. basissets()[source]¶; Returns basisset to atom map. charge()[source]¶; The “atomic charge” of the current atom (for SAD purposes). static d(a1, a2, a3, a4)[source]¶; Computes the dihedral (in rad.) between four sets of coordinates. entry_number()[source]¶; The order in which this appears in the full atom list. everything()[source]¶. is_computed()[source]¶; Whether the current atom’s coordinates are up-to-date. is_equivalent_to(other)[source]¶; Whether this atom has the same mass and ghost status as atom other.; Also compares basis set assignment down to nbf(), has_puream() level; with code borrowed from Robert M. Parrish’s SAD guess in Psi4. is_ghosted()[source]¶; Whether the current atom is ghosted or not. label()[source]¶; The atom label. mass()[source]¶; The atomic mass of the current atom. static r(a1, a2)[source]¶; Computes the distance between two sets of coordinates. set_basisset(name, role='BASIS')[source]¶; Set the basis for this atom; * @param type Keyword from input file, basis, ri_basis, etc.; * @param name Value from input file. set_ghosted(gh)[source]¶; Flag th",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_driver-1.html:114752,charge,charge,114752,psi4manual/1.0.0/autodoc_driver-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_driver-1.html,4,['charge'],['charge']
Energy Efficiency,"at_kwargs_for_input(fmaster, 2, **kwargs); fmaster.write(""""""%s('%s', **kwargs)\n\n"""""" % (frequency.__name__, lowername)); fmaster.write(instructionsM); fmaster.close(); psi4.print_out(instructionsM). for n, displacement in enumerate(displacements):; rfile = 'FREQ-%s' % (n + 1). # Build string of title banner; banners = ''; banners += """"""psi4.print_out('\\n')\n""""""; banners += """"""p4util.banner(' Hessian Computation: Energy Displacement %d ')\n"""""" % (n + 1); banners += """"""psi4.print_out('\\n')\n\n"""""". if (freq_mode.lower() == 'continuous'):; # Print information to output.dat; psi4.print_out('\n'); p4util.banner('Loading displacement %d of %d' % (n + 1, ndisp)). # Print information to the screen; print(' %d' % (n + 1), end=""""); if (n + 1) == ndisp:; print('\n', end=''); sys.stdout.flush(). # Load in displacement into the active molecule; molecule.set_geometry(displacement). # Perform the energy calculation; func(lowername, **kwargs). # Save the energy; energies.append(psi4.get_variable('CURRENT ENERGY')). # clean may be necessary when changing irreps of displacements; psi4.clean(). # S/R: Write each displaced geometry to an input file; elif (freq_mode.lower() == 'sow'):; molecule.set_geometry(displacement). # S/R: Prepare molecule, options, and kwargs; freagent = open('%s.in' % (rfile), 'w'); freagent.write('# This is a psi4 input file auto-generated from the gradient() wrapper.\n\n'); freagent.write(p4util.format_molecule_for_input(molecule)); freagent.write(p4util.format_options_for_input()); p4util.format_kwargs_for_input(freagent, **kwargs). # S/R: Prepare function call and energy save; freagent.write(""""""electronic_energy = %s('%s', **kwargs)\n\n"""""" % (func.__name__, lowername)); freagent.write(""""""psi4.print_out('\\nHESSIAN RESULT: computation %d for item %d """""" % (os.getpid(), n + 1)); freagent.write(""""""yields electronic energy %20.12f\\n' % (electronic_energy))\n\n""""""); freagent.close(). # S/R: Read energy from each displaced geometry output file and save in energ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/driver.html:69165,ENERGY,ENERGY,69165,psi4manual/4.0b5/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/driver.html,1,['ENERGY'],['ENERGY']
Energy Efficiency,"at_molecule_for_cfour_old(self):; """"""Function to print Molecule in a form readable by Cfour. This; version works as long as zmat is composed entirely of variables,; not internal values, while cartesian is all internal values,; no variables. Cutting off this line of development because,; with getting molecules after passing through libmints Molecule,; all zmats with dummies (Cfour's favorite kind) have already been; converted into cartesian. Next step, if this line was pursued; would be to shift any zmat internal values to external and any; cartesian external values to internal. """""". text = ''; text += 'auto-generated by qcdb from molecule %s\n' % (self.tagline). # # append units and any other non-default molecule keywords; # text += "" units %-s\n"" % (""Angstrom"" if self.units() == 'Angstrom' else ""Bohr""); # if not self.PYmove_to_com:; # text += "" no_com\n""; # if self.PYfix_orientation:; # text += "" no_reorient\n"". # append atoms and coordentries and fragment separators with charge and multiplicity; Pfr = 0; isZMat = False; isCart = False; for fr in range(self.nfragments()):; if self.fragment_types[fr] == 'Absent' and not self.has_zmatrix():; continue; # text += ""%s %s%d %d\n"" % (; # """" if Pfr == 0 else "" --\n"",; # ""#"" if self.fragment_types[fr] == 'Ghost' or self.fragment_types[fr] == 'Absent' else """",; # self.fragment_charges[fr], self.fragment_multiplicities[fr]); Pfr += 1; for at in range(self.fragments[fr][0], self.fragments[fr][1] + 1):; if type(self.full_atoms[at]) == ZMatrixEntry:; isZMat = True; elif type(self.full_atoms[at]) == CartesianEntry:; isCart = True; if self.fragment_types[fr] == 'Absent':; text += ""%s"" % (""X""); elif self.fZ(at) or self.fsymbol(at) == ""X"":; text += ""%s"" % (self.fsymbol(at)); else:; text += ""%s"" % (""GH"") # atom info is lost + self.fsymbol(at) + "")""); text += ""%s"" % (self.full_atoms[at].print_in_input_format_cfour()); text += ""\n"". # append any coordinate variables; if len(self.geometry_variables):; for vb, val in self.geometry_variabl",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/molecule.html:23985,charge,charge,23985,psi4manual/1.0.0/_modules/qcdb/molecule.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/molecule.html,2,['charge'],['charge']
Energy Efficiency,"atabase from a collection of xyz files; using the script psi4/lib/scripts/ixyz2database.pl.; See Creating a Database for details. Caution; Some features are not yet implemented. Buy a developer some coffee. In sow/reap mode, use only global options (e.g., the local option set by set scf scf_type df will not be respected). Parameters:; name (string) – 'scf' || 'sapt0' || 'ccsd(t)' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; energy(). db_name (string) – 'BASIC' || 'S22' || 'HTBH' || etc.; Second argument, usually unlabeled. Indicates the requested database; name, matching the name of a python file in psi4/lib/databases.; Consult that directory for available databases and literature citations. func (function) – energy || optimize || cbs; Indicates the type of calculation to be performed on each database; member. The default performs a single-point energy('name'), while; optimize perfoms a geometry optimization on each reagent, and; cbs performs a compound single-point energy. If a nested series; of python functions is intended (see Function Intercalls), use; keyword db_func instead of func. mode (string) – 'continuous' || 'sow' || 'reap'; Indicates whether the calculations required to complete the; database are to be run in one file ('continuous') or are to be; farmed out in an embarrassingly parallel fashion; ('sow'/'reap'). For the latter, run an initial job with; 'sow' and follow instructions in its output file. cp (boolean) – 'on' || 'off' ; Indicates whether counterpoise correction is employed in computing; interaction energies. Use this option and NOT the cp(); function for BSSE correction in database(). Option available; (See Available Databases) only for databases of bimolecular complexes. rlxd (boolean) – 'on' || 'off' ; Indicates whether correction for deformation energy is; employed in computing interaction energies. Option available; (See Available Databases) onl",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/db-1.html:1631,energy,energy,1631,psi4manual/4.0b2/db-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/db-1.html,4,['energy'],['energy']
Energy Efficiency,"atch to Psi4 Extensive testing has been done to match supplemental info of Szalewicz et. al., Phys. Rev. Lett., 103, 263201 (2009) and Szalewicz et. al., J. Phys. Chem. Lett., 1, 550-555 (2010). cc3; cc3: RHF-CCSD/6-31G** H2O geometry optimization and vibrational frequency analysis by finite-differences of gradients. dft-freq; Frequencies for H2O B3LYP/6-31G* at optimized geometry. cc23; ROHF-EOM-CCSD/DZ analytic gradient lowest \(^{2}B_1\) state of H2O+ (A1 excitation). fnocc3; Test FNO-QCISD(T) computation. scf3; File retention, docc, socc, and bond distances specified explicitly. adc2; ADC/aug-cc-pVDZ on two water molecules that are distant from 1000 angstroms from each other. dfcasscf-sp; CASSCF/6-31G** energy point. opt10; 6-31G MP2 transition-state optimization with initial, computed Hessian. scf1; RHF cc-pVQZ energy for the BH molecule, with Cartesian input. pubchem2; Superficial test of PubChem interface. omp2p5-1; OMP2 cc-pVDZ energy for the H2O molecule. ao-dfcasscf-sp; CASSCF/6-31G** energy point. mints12; test roundtrip-ness of dict repr for psi4.core.Molecule and qcdb.Molecule. omp2-grad2; OMP2 cc-pVDZ gradient for the NO radical. dcft7; DCFT calculation for the triplet O2 using ODC-06 and ODC-12 functionals. Only simultaneous algorithm is tested. scf-guess-read1; Sample UHF/cc-pVDZ H2O computation on a doublet cation, using RHF/cc-pVDZ orbitals for the closed-shell neutral as a guess. pywrap-align-chiral; testing aligner on enantiomers based on Table 1 of 10.1021/ci100219f aka J Chem Inf Model 2010 50(12) 2129-2140. cc43; RHF-CC2-LR/STO-3G optical rotation of (S)-methyloxirane. gauge = both, omega = (589 355 nm). cc41; RHF-CC2-LR/cc-pVDZ optical rotation of H2O2. gauge = both, omega = (589 355 nm). molden2; Test of the superposition of atomic densities (SAD) guess, using a highly distorted water geometry with a cc-pVDZ basis set. This is just a test of the code and the user need only specify guess=sad to the SCF module’s (or global) options in order to ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/autodoc_testsuite_corepsi4-1.html:23976,energy,energy,23976,psi4manual/1.2.1/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/autodoc_testsuite_corepsi4-1.html,8,['energy'],['energy']
Energy Efficiency,"ate described using the Ms = 0 component of the singlet. Uses TCSCF orbitals. casscf-semi; CASSCF/6-31G** energy point. Check energy with frozen core/virtual orbs. after semicanonicalization. mp2-grad1; MP2 cc-pVDZ gradient for the H2O molecule. omp3-grad2; OMP3 cc-pVDZ gradient for the NO radical. fsapt1; This test case shows an example of running and analyzing a standard F-SAPT0/jun-cc-pvdz procedure for phenol dimer from the S22 database. extern1; External potential calculation involving a TIP3P water and a QM water. Finite different test of the gradient is performed to validate forces. cisd-h2o+-2; 6-31G** H2O+ Test CISD Energy Point. sapt1; SAPT0 cc-pVDZ computation of the ethene-ethyne interaction energy, using the cc-pVDZ-JKFIT RI basis for SCF and cc-pVDZ-RI for SAPT. Monomer geometries are specified using Cartesian coordinates. scf-upcast-custom-basis; test scf castup with custom basis sets. cc52; CCSD Response for H2O2. decontract; RHF/cc-pvdz-decontract HCl single-point energy Testing the in line -decontract option for basis sets. cc55; EOM-CCSD/6-31g excited state transition data for water with two excited states per irrep. dft-ghost; DFT Functional Test for Range-Seperated Hybrids and Ghost atoms. dft-b2plyp; Double-hybrid density functional B2PYLP. Reproduces portion of Table I in S. Grimme’s J. Chem. Phys 124 034108 (2006) paper defining the functional. stability2; ROHF stability analysis check for CN with cc-pVDZ. This test corresponds to the rohf-stab test from Psi3. psimrcc-ccsd_t-1; Mk-MRCCSD(T) single point. \(^1A_1\) CH2 state described using the Ms = 0 component of the singlet. Uses RHF singlet orbitals. cc44; Test case for some of the PSI4 out-of-core codes. The code is given only 2.0 MB of memory, which is insufficient to hold either the A1 or B2 blocks of an ovvv quantity in-core, but is sufficient to hold at least two copies of an oovv quantity in-core. psithon2; Accesses basis sets, databases, plugins, and executables in non-install locati",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/autodoc_testsuite_corepsi4-1.html:3584,energy,energy,3584,psi4manual/1.2.1/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/autodoc_testsuite_corepsi4-1.html,4,['energy'],['energy']
Energy Efficiency,"ate described using the Ms = 0 component of the singlet. Uses TCSCF orbitals. casscf-semi; CASSCF/6-31G** energy point. Check energy with frozen core/virtual orbs. after semicanonicalization. mp2-grad1; MP2 cc-pVDZ gradient for the H2O molecule. omp3-grad2; OMP3 cc-pVDZ gradient for the NO radical. fsapt1; This test case shows an example of running and analyzing a standard F-SAPT0/jun-cc-pvdz procedure for phenol dimer from the S22 database. extern1; External potential calculation involving a TIP3P water and a QM water. Finite different test of the gradient is performed to validate forces. cisd-h2o+-2; 6-31G** H2O+ Test CISD Energy Point. sapt1; SAPT0 cc-pVDZ computation of the ethene-ethyne interaction energy, using the cc-pVDZ-JKFIT RI basis for SCF and cc-pVDZ-RI for SAPT. Monomer geometries are specified using Cartesian coordinates. scf-upcast-custom-basis; test scf castup with custom basis sets. cc52; CCSD Response for H2O2. decontract; RHF/cc-pvdz-decontract HCl single-point energy Testing the in line -decontract option for basis sets. nbody-multi-level; Multilevel computation of water trimer energy (geometry from J. Chem. Theory Comput. 11, 2126-2136 (2015)). cc55; EOM-CCSD/6-31g excited state transition data for water with two excited states per irrep. dft-ghost; DFT Functional Test for Range-Seperated Hybrids and Ghost atoms. dft-b2plyp; Double-hybrid density functional B2PYLP. Reproduces portion of Table I in S. Grimme’s J. Chem. Phys 124 034108 (2006) paper defining the functional. stability2; ROHF stability analysis check for CN with cc-pVDZ. This test corresponds to the rohf-stab test from Psi3. psimrcc-ccsd_t-1; Mk-MRCCSD(T) single point. \(^1A_1\) CH2 state described using the Ms = 0 component of the singlet. Uses RHF singlet orbitals. cc44; Test case for some of the PSI4 out-of-core codes. The code is given only 2.0 MB of memory, which is insufficient to hold either the A1 or B2 blocks of an ovvv quantity in-core, but is sufficient to hold at least t",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/autodoc_testsuite_corepsi4-1.html:4082,energy,energy,4082,psi4manual/1.3.2/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/autodoc_testsuite_corepsi4-1.html,4,['energy'],['energy']
Energy Efficiency,"ate ref_dft_2e/xc due to new BraggSlater radii. fci-tdm-2; BH-H2+ FCI/cc-pVDZ Transition Dipole Moment. mints-benchmark; run some BLAS benchmarks. mp2-grad1; MP2 cc-pVDZ gradient for the H2O molecule. mints12; test roundtrip-ness of dict repr for psi4.core.Molecule and qcdb.Molecule. cc13c; Tests RHF CCSD(T)gradients. ao-casscf-sp; CASSCF/6-31G** energy point. x2c2; Test of SFX2C-1e on Water cc-pVDZ-DK. In this test the Dirac equation is solved in the uncontracted cc-pVDZ-DK basis. The reference numbers are from Lan Cheng’s implementation in Cfour. dft-freq-analytic; Analytic SVWN frequencies, compared to finite difference values. cc55; EOM-CCSD/6-31g excited state transition data for water with two excited states per irrep. dct5; DC-06 calculation for the O2 molecule (triplet ground state). This performs geometry optimization using two-step and simultaneous solution of the response equations for the analytic gradient. fnocc1; Test QCISD(T) for H2O/cc-pvdz Energy. ao-dfcasscf-sp; CASSCF/6-31G** energy point. opt5; 6-31G** UHF CH2 3B1 optimization. Uses a Z-Matrix with dummy atoms, just for demo and testing purposes. cc-module; check that CC is returning the same values btwn CC*, FNOCC, and DFOCC modules. tu4-h2o-freq; Optimization followed by frequencies H2O HF/cc-pVDZ. dct10; The multiple guesses for DCT amplitudes for ODC-12. pubchem2; Superficial test of PubChem interface. dfmp2-grad3; DF-MP2 cc-pVDZ gradients for the H2O molecule. cc26; Single-point gradient, analytic and via finite-differences of 2-1A1 state of H2O with EOM-CCSD. dfomp2-2; OMP2 cc-pVDZ energy for the NO molecule. fnocc5; Test FNO-DF-CCSD(T) energy. cc29; CCSD/cc-pVDZ optical rotation calculation (both gauges) on Cartesian H2O2. props2; DF-SCF cc-pVDZ of benzene-hydronium ion, scanning the dissociation coordinate with Python’s built-in loop mechanism. The geometry is specified by a Z-matrix with dummy atoms, fixed parameters, updated parameters, and separate charge/multiplicity specifiers for eac",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/autodoc_testsuite_corepsi4-1.html:16445,energy,energy,16445,psi4manual/1.5.0/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/autodoc_testsuite_corepsi4-1.html,4,['energy'],['energy']
Energy Efficiency,"ate; (and check for stage_basis and stage_scheme keywords) and compute; that stage in defining the CBS energy.; The cbs() function requires, at a minimum, name='scf' and scf_basis; keywords to be specified for reference-step only jobs and name and; corl_basis keywords for correlated jobs.; The following energy methods have been set up for cbs(). scf; df-scf. mp2; df-mp2. cc2; ccsd. bccd; cc3. ccsd(t); fci. Parameters:; name (string) – 'scf' || 'ccsd' || etc.; First argument, usually unlabeled. Indicates the computational method; for the correlation energy, unless only reference step to be performed,; in which case should be 'scf'. Overruled if stage_wfn keywords supplied. corl_wfn (string) – 'mp2' || 'ccsd(t)' || etc.; Indicates the energy method for which the correlation energy is to be; obtained. Can also be specified with name or as the unlabeled; first argument to the function. delta_wfn (string) – 'ccsd' || 'ccsd(t)' || etc.; Indicates the (superior) energy method for which a delta correction; to the correlation energy is to be obtained. delta_wfn_lesser (string) – 'mp2' || 'ccsd' || etc.; Indicates the inferior energy method for which a delta correction; to the correlation energy is to be obtained. delta2_wfn (string) – 'ccsd' || 'ccsd(t)' || etc.; Indicates the (superior) energy method for which a second delta correction; to the correlation energy is to be obtained. delta2_wfn_lesser (string) – 'mp2' || 'ccsd(t)' || etc.; Indicates the inferior energy method for which a second delta correction; to the correlation energy is to be obtained. Basis Sets; Currently, the basis set set through set commands have no influence; on a cbs calculation. Parameters:; scf_basis (basis string) – corl_basis || 'cc-pV[TQ]Z' || 'jun-cc-pv[tq5]z' || '6-31G*' || etc.; Indicates the sequence of basis sets employed for the reference energy.; If any correlation method is specified, scf_basis can default; to corl_basis. corl_basis (basis string) – 'cc-pV[TQ]Z' || 'jun-cc-pv[tq5]z' || '",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/cbs-1.html:3147,energy,energy,3147,psi4manual/4.0b2/cbs-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/cbs-1.html,4,['energy'],['energy']
Energy Efficiency,"ate_geometry(). natoms = molecule.natom(); if natoms != 2:; raise Exception(""The current molecule must be a diatomic for this code to work!""); m1 = molecule.mass(0); m2 = molecule.mass(1). maxit = 30; thres = 1.0e-9; for i in range(maxit):; if (npoints == 5):; grad= first_deriv_5pt(rvals, energies, optx); secd = second_deriv_5pt(rvals, energies, optx); energy = function_5pt(rvals, energies, optx); elif (npoints == 9):; grad = first_deriv_9pt(rvals, energies, optx); secd = second_deriv_9pt(rvals, energies, optx); energy = function_9pt(rvals, energies, optx); psi4.print_out("" E = %20.14f, x = %14.7f, grad = %20.14f\n"" % (energy, optx, grad)); if abs(grad) < thres:; break; optx -= grad / secd;; psi4.print_out("" Final E = %20.14f, x = %14.7f, grad = %20.14f\n"" % (function_5pt(rvals, energies, optx), optx, grad));. if optx < min(rvals):; raise Exception(""Minimum energy point is outside range of points provided. Use a lower range of r values.""); if optx > max(rvals):; raise Exception(""Minimum energy point is outside range of points provided. Use a higher range of r values.""). if (npoints == 5):; energy = function_5pt(rvals, energies, optx); first = first_deriv_5pt(rvals, energies, optx); secd = second_deriv_5pt(rvals, energies, optx) * p4const.psi_hartree2aJ; third = third_deriv_5pt(rvals, energies, optx) * p4const.psi_hartree2aJ; fourth = fourth_deriv_5pt(rvals, energies, optx) * p4const.psi_hartree2aJ; elif (npoints == 9):; energy = function_9pt(rvals, energies, optx); first = first_deriv_9pt(rvals, energies, optx); secd = second_deriv_9pt(rvals, energies, optx) * p4const.psi_hartree2aJ; third = third_deriv_9pt(rvals, energies, optx) * p4const.psi_hartree2aJ; fourth = fourth_deriv_9pt(rvals, energies, optx) * p4const.psi_hartree2aJ. psi4.print_out(""\nEquilibrium Energy %20.14f Hartrees\n"" % energy); psi4.print_out(""Gradient %20.14f\n"" % first); psi4.print_out(""Quadratic Force Constant %14.7f MDYNE/A\n"" % secd); psi4.print_out(""Cubic Force Constant %14.7f MDYNE/A**2\n"" % ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/diatomic.html:3890,energy,energy,3890,psi4manual/1.0.0/_modules/diatomic.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/diatomic.html,1,['energy'],['energy']
Energy Efficiency,"ated from Python; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class SuperFunctional(Boost.Python.instance); | docstring; | ; | Method resolution order:; | SuperFunctional; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | add_c_functional(...); | add_c_functional( (SuperFunctional)arg1, (Functional)arg2) -> None :; | docstring; | ; | add_x_functional(...); | add_x_functional( (SuperFunctional)arg1, (Functional)arg2) -> None :; | docstring; | ; | allocate(...); | allocate( (SuperFunctional)arg1) -> None :; | docstring; | ; | ansatz(...); | ansatz( (SuperFunctional)arg1) -> int :; | docstring; | ; | c_alpha(...); | c_alpha( (SuperFunctional)arg1) -> float :; | docstring; | ; | c_functional(...); | c_functional( (SuperFunctional)arg1, (str)arg2) -> Functional :; | docstring; | ; | c_omega(...); | c_omega( (SuperFunctional)arg1) -> float :; | docstring; | ; | c_os_alpha(...); | c_os_alpha( (SuperFunctional)arg1) -> float :; | docstring; | ; | c_ss_alpha(...); | c_ss_alpha( (SuperFunctional)arg1) -> float :; | docstring; | ; | citation(...); | citation( (SuperFunctional)arg1) -> str :; | docstring; | ; | deriv(...); | deriv( (SuperFunctional)arg1) -> int :; | docstring; | ; | description(...); | description( (SuperFunctional)arg1) -> str :; | docstring; | ; | dispersion(...); | dispersion( (SuperFunctional)arg1) -> Dispersion :; | docstring; | ; | is_c_hybrid(...); | is_c_hybrid( (SuperFunctional)arg1) -> bool :; | docstring; | ; | is_c_lrc(...); | is_c_lrc( (SuperFunctional)arg1)",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/psimod-1.html:81177,allocate,allocate,81177,psi4manual/4.0b3/psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod-1.html,6,['allocate'],['allocate']
Energy Efficiency,"ated from Python; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class SuperFunctional(Boost.Python.instance); | docstring; | ; | Method resolution order:; | SuperFunctional; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | add_c_functional(...); | add_c_functional( (SuperFunctional)arg1, (Functional)arg2) -> None :; | docstring; | ; | add_x_functional(...); | add_x_functional( (SuperFunctional)arg1, (Functional)arg2) -> None :; | docstring; | ; | allocate(...); | allocate( (SuperFunctional)arg1) -> None :; | docstring; | ; | ansatz(...); | ansatz( (SuperFunctional)arg1) -> int :; | docstring; | ; | c_alpha(...); | c_alpha( (SuperFunctional)arg1) -> float :; | docstring; | ; | c_functional(...); | c_functional( (SuperFunctional)arg1, (str)arg2) -> Functional :; | docstring; | ; | c_omega(...); | c_omega( (SuperFunctional)arg1) -> float :; | docstring; | ; | citation(...); | citation( (SuperFunctional)arg1) -> str :; | docstring; | ; | deriv(...); | deriv( (SuperFunctional)arg1) -> int :; | docstring; | ; | description(...); | description( (SuperFunctional)arg1) -> str :; | docstring; | ; | dispersion(...); | dispersion( (SuperFunctional)arg1) -> Dispersion :; | docstring; | ; | is_c_hybrid(...); | is_c_hybrid( (SuperFunctional)arg1) -> bool :; | docstring; | ; | is_c_lrc(...); | is_c_lrc( (SuperFunctional)arg1) -> bool :; | docstring; | ; | is_gga(...); | is_gga( (SuperFunctional)arg1) -> bool :; | docstring; | ; | is_meta(...); | is_meta( (SuperFunctional)arg1) -> bool :; | do",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/psimod-1.html:70841,allocate,allocate,70841,psi4manual/4.0b2/psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psimod-1.html,2,['allocate'],['allocate']
Energy Efficiency,"ated mp2 correlation energy atop a T-zeta reference; >>> energy(cbs, corl_wfn='mp2', corl_basis='cc-pv[dt]z', corl_scheme=corl_xtpl_helgaker_2). >>> # [5] a DT-zeta extrapolated coupled-cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference (both equivalent); >>> energy(cbs, corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z'); >>> energy(cbs, corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z', delta_scheme=corl_xtpl_helgaker_2). >>> # [6] a D-zeta ccsd(t) correction atop a DT-zeta extrapolated ccsd cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference; >>> energy(cbs, corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd', delta_basis='aug-cc-pv[dt]z', delta_scheme=corl_xtpl_helgaker_2, delta2_wfn='ccsd(t)', delta2_wfn_lesser='ccsd', delta2_basis='aug-cc-pvdz'). >>> # [7] a Q5-zeta MP2 calculation, corrected by CCSD(T) at the TQ-zeta extrapolated level, and all-electron CCSD(T) correlation at T-zeta level; >>> energy(cbs, cbs_metadata=[{""wfn"": ""hf"", ""basis"": ""cc-pv5z""}, {""wfn"": ""mp2"", ""basis"": ""cc-pv[q5]z""}, {""wfn"": ""ccsd(t)"", ""basis"": ""cc-pv[tq]z""}, {""wfn"": ""ccsd(t)"", ""basis"": ""cc-pvtz"", ""options"": {""freeze_core"": ""False""}}]). >>> # [8] cbs() coupled with database(); >>> TODO database('mp2', 'BASIC', subset=['h2o','nh3'], symm='on', func=cbs, corl_basis='cc-pV[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd(t)', delta_basis='sto-3g'). >>> # [9] cbs() coupled with optimize(); >>> TODO optimize('mp2', corl_basis='cc-pV[DT]Z', corl_scheme=corl_xtpl_helgaker_2, func=cbs). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.3.2;  · . PSI4. PSI4 API: Linking C++ and Python. © Copyright 2019, The Psi4 Project.; Last updated on Wednesday, 15 May 2019 08:49PM.; Created using Sphinx 1.8.5.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/api/psi4.driver.cbs-1.html:11172,energy,energy,11172,psi4manual/1.3.2/api/psi4.driver.cbs-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/api/psi4.driver.cbs-1.html,2,['energy'],['energy']
Energy Efficiency,"ated since version 1.4: Use psi4.core.Wavefunction.variables() instead. atomic_point_charges(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the set atomic point charges. basis_projection(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix, arg1: psi4.core.Dimension, arg2: psi4.core.BasisSet, arg3: psi4.core.BasisSet) → psi4.core.Matrix¶; Projects a orbital matrix from one basis to another. basisset(self: psi4.core.Wavefunction) → psi4.core.BasisSet¶; Returns the current orbital basis. beta_orbital_space(self: psi4.core.Wavefunction, arg0: str, arg1: str, arg2: str) → psi4.core.OrbitalSpace¶; docstring. static build(mol, basis=None, *, quiet=False)¶. Parameters; quiet (bool) – . c1_deep_copy(self: psi4.core.Wavefunction, basis: psi4.core.BasisSet) → psi4.core.Wavefunction¶; Returns a new wavefunction with internal data converted to \(C_1\) symmetry, using pre-c1-constructed basis. compute(self: psi4.core.DFEP2Wavefunction, arg0: List[List[int]]) → List[List[Tuple[float, float]]]¶; Computes the density-fitted EP2 energy for the input orbitals. compute_energy(self: psi4.core.Wavefunction) → float¶; Computes the energy of the Wavefunction. compute_gradient(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Computes the gradient of the Wavefunction. compute_hessian(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Computes the Hessian of the Wavefunction. deep_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; Deep copies the internal data. del_array_variable(self: psi4.core.Wavefunction, arg0: str) → int¶; Removes the requested (case-insensitive) Matrix QC variable. del_potential_variable(self: psi4.core.Wavefunction, arg0: str) → int¶; Removes the requested (case-insensitive) ExternalPotential QC variable. (This function is provisional and might be removed in the future.). del_scalar_variable(self: psi4.core.Wavefunction, arg0: str) → int¶; Removes the requested (case-insensitive) double QC variable. del_variable(key)¶; Removes scal",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/api/psi4.core.DFEP2Wavefunction.html:12808,energy,energy,12808,psi4manual/1.6.x/api/psi4.core.DFEP2Wavefunction.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/api/psi4.core.DFEP2Wavefunction.html,2,['energy'],['energy']
Energy Efficiency,"ater molecule using a cc-pVDZ basis set. We will specify the; geometry of our water molecule using a standard Z-matrix.; # Any line starting with the # character is a comment line; #! Sample HF/cc-pVDZ H2O computation. memory 600 mb. molecule h2o {; O ; H 1 0.96; H 1 0.96 2 104.5; }. set basis cc-pVDZ; energy('scf'). Note; The memory and basis set specifications are placed before the; energy function is called. Any user options need to; be set before the procedure they are meant to affect. For your convenience, the above example can be found in; tu1-h2o-energy.; You can run it if you wish.; Once PSI4 is in your path (see the; User Configuration; section of the installation instructions), you can run this computation by typing; 1>>> psi4 input.dat output.dat. If everything goes well, the computation should complete and should report; a final restricted Hartree–Fock energy in a section like this:; 1; 2; 3Energy converged. @RHF Final Energy: -76.02663273410671. By default, the energy should be converged to about \(1.0 \times 10^{-6}\), so agreement; is only expected for about the first 6 digits after the decimal. If the; computation does not complete, there is probably a problem with the; compilation or installation of the program (see the installation; instructions in Sec. Compiling and Installing from Source).; This very simple input is sufficient to run the requested information.; Notice that we didn’t tell the program some otherwise useful information; like the charge on the molecule (0, it’s neutral), the spin multiplicity; (1 for a closed-shell molecule with all electrons paired), or the reference; wavefunction to use (restricted Hartree–Fock, or RHF, is usually; appropriate for a closed-shell molecule). The program correctly guessed; all of these options for us. We can change the default behavior through; additional keywords.; Let’s consider what we would do for an open-shell molecule, where; not all electrons are paired. For example, let’s run a computation; on ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/tutorial-1.html:2872,energy,energy,2872,psi4manual/1.1.0/tutorial-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/tutorial-1.html,4,['energy'],['energy']
Energy Efficiency,"ater. cc49; EOM-CC3(UHF) on CH radical with user-specified basis and properties for particular root. opt-multi-dimer-c1; Multi-fragment opt of C2h methane dimer with user-combined reference points. pywrap-checkrun-uhf; This checks that all energy methods can run with a minimal input and set symmetry. cc13c; Tests RHF CCSD(T)gradients. mom; Maximum Overlap Method (MOM) Test. MOM is designed to stabilize SCF convergence and to target excited Slater determinants directly. zaptn-nh2; ZAPT(n)/6-31G NH2 Energy Point, with n=2-25. omp2-grad1; OMP2 cc-pVDZ gradient for the H2O molecule. pywrap-checkrun-convcrit; Advanced python example sets different sets of scf/post-scf conv crit and check to be sure computation has actually converged to the expected accuracy. dfrasscf-sp; 6-31G** H2O Test RASSCF Energy Point will default to only singles and doubles in the active space. frac-traverse; Scan fractional occupation of electrons. ao-casscf-sp; CASSCF/6-31G** energy point. tu2-ch2-energy; Sample UHF/6-31G** CH2 computation. opt13; B3LYP cc-pVDZ geometry optimzation of phenylacetylene, starting from not quite linear structure. dft-b3lyp; Check flavors of B3LYP (b3lyp3/b3lyp5) against other programs. dfomp2-grad1; DF-OMP2 cc-pVDZ gradients for the H2O molecule. psimrcc-fd-freq1; Mk-MRCCSD single point. \(^3 \Sigma ^-\) O2 state described using the Ms = 0 component of the triplet. Uses ROHF triplet orbitals. cbs-xtpl-energy; Extrapolated water energies. mints6; Patch of a glycine with a methyl group, to make alanine, then DF-SCF energy calculation with the cc-pVDZ basis set. basis-ecp; check mixing ECP and non-ECP orbital/fitting basis sets in a session. isapt2; This is a shorter version if isapt1 - does not do cube plots. See isapt1 for full details. casscf-sa-sp; Example of state-averaged CASSCF for the C2 molecule see C. D. Sherrill and P. Piecuch, J. Chem. Phys. 122, 124104 (2005). cbs-xtpl-wrapper; RHF aug-cc-pVQZ energy for the BH molecule, with Cartesian input. Various gradi",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/autodoc_testsuite_corepsi4-1.html:14315,energy,energy,14315,psi4manual/1.3.2/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/autodoc_testsuite_corepsi4-1.html,4,['energy'],['energy']
Energy Efficiency,"ater. cc49; EOM-CC3(UHF) on CH radical with user-specified basis and properties for particular root. opt-multi-dimer-c1; Multi-fragment opt of C2h methane dimer with user-combined reference points. pywrap-checkrun-uhf; This checks that all energy methods can run with a minimal input and set symmetry. cc13c; Tests RHF CCSD(T)gradients. mom; Maximum Overlap Method (MOM) Test. MOM is designed to stabilize SCF convergence and to target excited Slater determinants directly. zaptn-nh2; ZAPT(n)/6-31G NH2 Energy Point, with n=2-25. omp2-grad1; OMP2 cc-pVDZ gradient for the H2O molecule. pywrap-checkrun-convcrit; Advanced python example sets different sets of scf/post-scf conv crit and check to be sure computation has actually converged to the expected accuracy. dfrasscf-sp; 6-31G** H2O Test RASSCF Energy Point will default to only singles and doubles in the active space. frac-traverse; Scan fractional occupation of electrons. ao-casscf-sp; CASSCF/6-31G** energy point. tu2-ch2-energy; Sample UHF/6-31G** CH2 computation. opt13; B3LYP cc-pVDZ geometry optimzation of phenylacetylene, starting from not quite linear structure. dft-bench-ionization; functionals ionization energies vs. other programs. dft-b3lyp; Check flavors of B3LYP (b3lyp3/b3lyp5) against other programs. dfomp2-grad1; DF-OMP2 cc-pVDZ gradients for the H2O molecule. psimrcc-fd-freq1; Mk-MRCCSD single point. \(^3 \Sigma ^-\) O2 state described using the Ms = 0 component of the triplet. Uses ROHF triplet orbitals. cbs-xtpl-energy; Extrapolated water energies. mints6; Patch of a glycine with a methyl group, to make alanine, then DF-SCF energy calculation with the cc-pVDZ basis set. isapt2; This is a shorter version if isapt1 - does not do cube plots. See isapt1 for full details. casscf-sa-sp; Example of state-averaged CASSCF for the C2 molecule see C. D. Sherrill and P. Piecuch, J. Chem. Phys. 122, 124104 (2005). cbs-xtpl-wrapper; RHF aug-cc-pVQZ energy for the BH molecule, with Cartesian input. Various gradients fo",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/autodoc_testsuite_corepsi4-1.html:13573,energy,energy,13573,psi4manual/1.2.1/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/autodoc_testsuite_corepsi4-1.html,4,['energy'],['energy']
Energy Efficiency,"ater. scf-ecp; Water-Argon complex with ECP present; check of energies and forces. cc9; UHF-CCSD(T) cc-pVDZ frozen-core energy for the \(^2\Sigma^+\) state of the CN radical, with Z-matrix input. gibbs; Test Gibbs free energies at 298 K of N2, H2O, and CH4. scf-guess-read2; Test if the the guess read in the same basis converges. nbody-he-cluster; MP2/aug-cc-pv[DT]Z many body energies of an arbitrary Helium complex Size vs cost tradeoff is rough here. omp2-grad1; OMP2 cc-pVDZ gradient for the H2O molecule. dfomp2-3; OMP2 cc-pVDZ energy for the H2O molecule. dfcasscf-sa-sp; Example of state-averaged CASSCF for the C2 molecule. dfmp2-fc; Kr–Kr nocp energies with all-electron basis set to check frozen core. dft-grad-lr3; wB97X-D test for a large UKS molecule update ref gradient due to new BraggSlater radii. fcidump; test FCIDUMP functionality for rhf/uhf. dfomp2p5-2; DF-OMP2.5 cc-pVDZ energy for the H2O+ cation. sapt4; SAPT2+(3) aug-cc-pVDZ computation of the formamide dimer interaction energy, using the aug-cc-pVDZ-JKFIT DF basis for SCF and aug-cc-pVDZ-RI for SAPT. This example uses frozen core as well as MP2 natural orbital approximations. omp3-3; OMP3 cc-pCVDZ energy with B3LYP initial guess for the NO radical. olccd2; OLCCD cc-pVDZ energy with B3LYP initial guess for the NO radical. nbody-convergence; Convergence of many-body gradients of different BSSE schemes. sapt-dft-api; SAPT(DFT) aug-cc-pVDZ interaction energy between Ne and Ar atoms. cc46; EOM-CC2/cc-pVDZ on H2O2 with two excited states in each irrep. pubchem1; Benzene vertical singlet-triplet energy difference computation, using the PubChem database to obtain the initial geometry, which is optimized at the HF/STO-3G level, before computing single point energies at the RHF, UHF and ROHF levels of theory. cc13a; UHF-CCSD(T)/cc-pVDZ \(^{3}B_1\) CH2 geometry optimization via analytic gradients. sad1; Test of the superposition of atomic densities (SAD) guess, using a highly distorted water geometry with a cc-pVD",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/autodoc_testsuite_corepsi4.html:46073,energy,energy,46073,psi4manual/1.7.x/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/autodoc_testsuite_corepsi4.html,2,['energy'],['energy']
Energy Efficiency,"ates psi4's libmints; Molecule class, developed by Justin M. Turney with incremental; improvements by other psi4 developers. Major differences from the C++; class are: no basisset handling, no symmetry, no pubchem. This class; translated so that databases can function independently of psi4. >>> H2OH2O = qcdb.Molecule(\""\""\""; 0 1; O1 -1.551007 -0.114520 0.000000; H1 -1.934259 0.762503 0.000000; H2 -0.599677 0.040712 0.000000; --; 0 1; X 0.000000 0.000000 0.000000; O2 1.350625 0.111469 0.000000; H3 1.680398 -0.373741 -0.758561; H4 1.680398 -0.373741 0.758561; no_com; no_reorient; units angstrom; \""\""\""). >>> H2O = qcdb.Molecule.init_with_xyz('h2o.xyz'); """"""; FullPointGroupList = [""ATOM"", ""C_inf_v"", ""D_inf_h"", ""C1"", ""Cs"", ""Ci"", \; ""Cn"", ""Cnv"", ""Cnh"", ""Sn"", ""Dn"", ""Dnd"", ""Dnh"", ""Td"", ""Oh"", ""Ih""]. def __init__(self, psi4molstr=None):; """"""Initialize Molecule object from string in psi4 format"""""". # <<< Basic Molecule Information >>>. # Molecule (or fragment) name; self.PYname = 'default'; # The molecular charge; self.PYmolecular_charge = 0; # Whether the charge was given by the user UNUSED; self.PYcharge_specified = False; # The multiplicity (defined as 2Ms + 1); self.PYmultiplicity = 1; # Whether the multiplicity was specified by the user UNUSED; self.PYmultiplicity_specified = False; # The units used to define the geometry; self.PYunits = 'Angstrom'; # The conversion factor to take input units to Bohr; self.input_units_to_au = 1.0 / psi_bohr2angstroms. # <<< Coordinates >>>. # Atom info vector (no knowledge of dummy atoms); self.atoms = []; # Atom info vector (includes dummy atoms); self.full_atoms = []; # A list of all variables known, whether they have been set or not.; self.all_variables = []; # A listing of the variables used to define the geometries; self.geometry_variables = {}. # <<< Fragmentation >>>. # The list of atom ranges defining each fragment from parent molecule; self.fragments = []; # A list describing how to handle each fragment; self.fragment_types = [];",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/_modules/qcdb/libmintsmolecule.html:1694,charge,charge,1694,psi4manual/4.0b3/_modules/qcdb/libmintsmolecule.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/_modules/qcdb/libmintsmolecule.html,4,['charge'],['charge']
Energy Efficiency,"ates the sequence of basis sets employed for the third delta correction; to the correlation energy. delta4_basis (basis string) – 'cc-pV[TQ]Z' || 'jun-cc-pv[tq5]z' || '6-31G*' || etc.; Indicates the sequence of basis sets employed for the fourth delta correction; to the correlation energy. delta5_basis (basis string) – 'cc-pV[TQ]Z' || 'jun-cc-pv[tq5]z' || '6-31G*' || etc.; Indicates the sequence of basis sets employed for the fifth delta correction; to the correlation energy. Schemes; Transformations of the energy through basis set extrapolation for each; stage of the CBS definition. A complaint is generated if number of basis; sets in stage_basis does not exactly satisfy requirements of stage_scheme.; An exception is the default, 'xtpl_highest_1', which uses the best basis; set available. See sec:cbs_xtpl for all available schemes. Parameters:; scf_scheme (function) – \(\Rightarrow\) xtpl_highest_1 \(\Leftarrow\) || scf_xtpl_helgaker_3 || etc.; Indicates the basis set extrapolation scheme to be applied to the reference energy.; Defaults to scf_xtpl_helgaker_3() if three valid basis sets; present in scf_basis, scf_xtpl_helgaker_2() if two valid basis; sets present in scf_basis, and xtpl_highest_1() otherwise. corl_scheme (function) – \(\Rightarrow\) xtpl_highest_1 \(\Leftarrow\) || corl_xtpl_helgaker_2 || etc.; Indicates the basis set extrapolation scheme to be applied to the correlation energy.; Defaults to corl_xtpl_helgaker_2() if two valid basis sets; present in corl_basis and xtpl_highest_1() otherwise. delta_scheme (function) – \(\Rightarrow\) xtpl_highest_1 \(\Leftarrow\) || corl_xtpl_helgaker_2 || etc.; Indicates the basis set extrapolation scheme to be applied to the delta correction; to the correlation energy.; Defaults to corl_xtpl_helgaker_2() if two valid basis sets; present in delta_basis and xtpl_highest_1() otherwise. delta2_scheme (function) – \(\Rightarrow\) xtpl_highest_1 \(\Leftarrow\) || corl_xtpl_helgaker_2 || etc.; Indicates the basis set extra",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/cbs-1.html:8030,energy,energy,8030,psi4manual/1.1.0/cbs-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/cbs-1.html,3,['energy'],['energy']
Energy Efficiency,"ates the sequence of basis sets employed for the third delta correction; to the correlation energy. delta4_basis (basis string) – 'cc-pV[TQ]Z' || 'jun-cc-pv[tq5]z' || '6-31G*' || etc.; Indicates the sequence of basis sets employed for the fourth delta correction; to the correlation energy. delta5_basis (basis string) – 'cc-pV[TQ]Z' || 'jun-cc-pv[tq5]z' || '6-31G*' || etc.; Indicates the sequence of basis sets employed for the fifth delta correction; to the correlation energy. Schemes; Transformations of the energy through basis set extrapolation for each; stage of the CBS definition. A complaint is generated if number of basis; sets in stage_basis does not exactly satisfy requirements of stage_scheme.; An exception is the default, 'xtpl_highest_1', which uses the best basis; set available. See sec:cbs_xtpl for all available schemes. Parameters:; scf_scheme (function) – \(\Rightarrow\) xtpl_highest_1 \(\Leftarrow\) || scf_xtpl_helgaker_3 || etc.; Indicates the basis set extrapolation scheme to be applied to the reference energy.; Defaults to scf_xtpl_helgaker_3() if three valid basis sets; present in scf_basis, scf_xtpl_helgaker_2() if two valid basis; sets present in scf_basis, and xtpl_highest_1() otherwise. xtpl_highest_1; scf_xtpl_helgaker_3; scf_xtpl_helgaker_2; scf_xtpl_truhlar_2; scf_xtpl_karton_2. corl_scheme (function) – \(\Rightarrow\) xtpl_highest_1 \(\Leftarrow\) || corl_xtpl_helgaker_2 || etc.; Indicates the basis set extrapolation scheme to be applied to the correlation energy.; Defaults to corl_xtpl_helgaker_2() if two valid basis sets; present in corl_basis and xtpl_highest_1() otherwise. xtpl_highest_1; corl_xtpl_helgaker_2. delta_scheme (function) – \(\Rightarrow\) xtpl_highest_1 \(\Leftarrow\) || corl_xtpl_helgaker_2 || etc.; Indicates the basis set extrapolation scheme to be applied to the delta correction; to the correlation energy.; Defaults to corl_xtpl_helgaker_2() if two valid basis sets; present in delta_basis and xtpl_highest_1() otherwise. ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/cbs-1.html:8032,energy,energy,8032,psi4manual/1.2.1/cbs-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/cbs-1.html,4,['energy'],['energy']
Energy Efficiency,"ates the type of calculation to be performed on the molecule.; The default dertype accesses ``'gradient'`` or ``'energy'``, while; ``'cbs'`` performs a multistage finite difference calculation.; If a nested series of python functions is intended (see :ref:`sec:intercalls`),; use keyword ``opt_func`` instead of ``func``. :type dertype: :ref:`dertype <op_py_dertype>`; :param dertype: ``'gradient'`` || ``'energy'``. Indicates whether analytic (if available) or finite difference; optimization is to be performed. :type hessian_with: string; :param hessian_with: ``'scf'`` || ``'mp2'`` || etc. Indicates the computational method with which to perform a hessian; analysis to guide the geometry optimization. .. warning:: Optimizations where the molecule is specified in Z-matrix format; with dummy atoms will result in the geometry being converted to a Cartesian representation. .. note:: Analytic gradients area available for all methods in the table; below. Optimizations with other methods in the energy table proceed; by finite differences. .. _`table:grad_gen`:. +-------------------------+---------------------------------------------------------------------------------------------------------------+; | name | calls method |; +=========================+===============================================================================================================+; | efp | efp-only optimizations |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | scf | Hartree--Fock (HF) or density functional theory (DFT) :ref:`[manual] <sec:scf>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | hf | HF self consistent field (SCF) :ref:`[manual] <sec:scf>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | dcft | den",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver.html:49673,energy,energy,49673,psi4manual/1.3.2/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver.html,1,['energy'],['energy']
Energy Efficiency,"atetime. import numpy as np. from psi4.driver import constants; from psi4.driver.p4util.util import compare_values, success; from psi4.driver.procrouting.proc_util import check_iwl_file_from_scf_type. from .exceptions import *. [docs]def fcidump(wfn, fname='INTDUMP', oe_ints=None):; """"""Save integrals to file in FCIDUMP format as defined in Comp. Phys. Commun. 54 75 (1989); Additional one-electron integrals, including orbital energies, can also be saved.; This latter format can be used with the HANDE QMC code but is not standard. :returns: None. :raises: ValidationError when SCF wavefunction is not RHF. :type wfn: :py:class:`~psi4.core.Wavefunction`; :param wfn: set of molecule, basis, orbitals from which to generate cube files; :param fname: name of the integrals file, defaults to INTDUMP; :param oe_ints: list of additional one-electron integrals to save to file.; So far only EIGENVALUES is a valid option. :examples:. >>> # [1] Save one- and two-electron integrals to standard FCIDUMP format; >>> E, wfn = energy('scf', return_wfn=True); >>> fcidump(wfn). >>> # [2] Save orbital energies, one- and two-electron integrals.; >>> E, wfn = energy('scf', return_wfn=True); >>> fcidump(wfn, oe_ints=['EIGENVALUES']). """"""; # Get some options; reference = core.get_option('SCF', 'REFERENCE'); ints_tolerance = core.get_global_option('INTS_TOLERANCE'); # Some sanity checks; if reference not in ['RHF', 'UHF']:; raise ValidationError('FCIDUMP not implemented for {} references\n'.format(reference)); if oe_ints is None:; oe_ints = []. molecule = wfn.molecule(); docc = wfn.doccpi(); frzcpi = wfn.frzcpi(); frzvpi = wfn.frzvpi(); active_docc = docc - frzcpi; active_socc = wfn.soccpi(); active_mopi = wfn.nmopi() - frzcpi - frzvpi. nbf = active_mopi.sum() if wfn.same_a_b_orbs() else 2 * active_mopi.sum(); nirrep = wfn.nirrep(); nelectron = 2 * active_docc.sum() + active_socc.sum(). core.print_out('Writing integrals in FCIDUMP format to ' + fname + '\n'); # Generate FCIDUMP header; header = '",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/p4util/fcidump.html:2253,energy,energy,2253,psi4manual/1.2.1/_modules/psi4/driver/p4util/fcidump.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/p4util/fcidump.html,1,['energy'],['energy']
Energy Efficiency,"atic cases as the result of the improved; convergence. For the comparison of the quality of these methods we refer; user to the recent publications.; The DCFT functional can be specified by the DCFT_FUNCTIONAL option. The; default choice is the DC-06 functional. In addition to the two methods listed; above, DCFT_FUNCTIONAL option can be set to CEPA0 (coupled electron; pair approximation zero, equivalent to linearized coupled cluster doubles; method, LCCD). CEPA0 can be considered as a particular case of the DC-06 and DC-12; methods in the limit of zero non-idempotency of OPDM. This option has a limited; functionality and should only be used for the test purposes.; At the present moment DCFT computations can only be run with the unrestricted; orbitals. If the REFERENCE option is not specified in the input file,; the PSI4 Python driver will conveniently set it to UHF for the DCFT; computations. Iterative Algorithms¶; As explained in the Theory section, in order to obtain the DCFT energy one; needs to solve the system of coupled equations for the orbitals and the density; cumulant. At the present moment three iterative algorithms for the solution of the; equations are available. The choice of the algorithm is controlled using the; ALGORITHM option.; 1) Two-step algorithm (can be invoked by setting ALGORITHM option to; TWOSTEP and is currently the default). In two-step algorithm the DCFT equations; are solved in macroiterations. Each macroiteration consists of two sets of; microiterations. In the first set the density cumulant equations are solved; iteratively, while the orbitals are kept fixed. After the density cumulant is; converged, the second set of microiterations is performed for the; self-consistent update of the orbitals with the fixed density cumulant. Each; macroiteration is completed by performing the orbital transformation of the; integrals. The convergence of the two-step algorithm is accelerated using the; DIIS extrapolation technique.; 2) Simultaneous al",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/dcft-1.html:5512,energy,energy,5512,psi4manual/4.0b4/dcft-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/dcft-1.html,4,['energy'],['energy']
Energy Efficiency,"atically if the memory requirements of the conventional algorithm would exceed the available resources. The low memory algorithm is faster in general and has been turned on by default starting September 2020. Type: boolean; Default: true. Expert¶. CEPA_LEVEL¶. Which coupled-pair method is called? This parameter is used internally by the python driver. Changing its value won’t have any effect on the procedure. Type: string; Default: CEPA(0). COMPUTE_MP4_TRIPLES¶. Do compute MP4 triples contribution?. Type: boolean; Default: false. COMPUTE_TRIPLES¶. Do compute triples contribution?. Type: boolean; Default: true. RUN_CCSD¶. do ccsd rather than qcisd?. Type: boolean; Default: false. RUN_CEPA¶. Is this a CEPA job? This parameter is used internally by the pythond driver. Changing its value won’t have any effect on the procedure. Type: boolean; Default: false. RUN_MP2¶. do only evaluate mp2 energy?. Type: boolean; Default: false. RUN_MP3¶. do only evaluate mp3 energy?. Type: boolean; Default: false. RUN_MP4¶. do only evaluate mp4 energy?. Type: boolean; Default: false. USE_DF_INTS¶. Use 3-index integrals to generate 4-index ERI’s? This keyword is used for testing purposes only. Changing its value will have no effect on the computation. Type: boolean; Default: false. table of contents. FNOCC; General; ACTIVE_NAT_ORBS; BRUECKNER_MAXITER; CC_SCALE_OS; CC_SCALE_SS; CC_TIMINGS; CEPA_NO_SINGLES; CHOLESKY_TOLERANCE; DFCC; DF_BASIS_CC; DIIS_MAX_VECS; DIPMOM; E_CONVERGENCE; MAXITER; MP2_SCALE_OS; MP2_SCALE_SS; NAT_ORBS; OCC_PERCENTAGE; OCC_TOLERANCE; R_CONVERGENCE; SCS_CCSD; SCS_CEPA; SCS_MP2; TRIPLES_LOW_MEMORY. Expert; CEPA_LEVEL; COMPUTE_MP4_TRIPLES; COMPUTE_TRIPLES; RUN_CCSD; RUN_CEPA; RUN_MP2; RUN_MP3; RUN_MP4; USE_DF_INTS. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Appendices; Keywords by Module; FNOCC. © Copyright 2022, The Psi4 Project.; Last updated on Thursday, 19 May 2022 08:57PM.; Created using Sphinx 4.5.0.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/autodir_options_c/module__fnocc.html:4362,energy,energy,4362,psi4manual/1.6.x/autodir_options_c/module__fnocc.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/autodir_options_c/module__fnocc.html,2,['energy'],['energy']
Energy Efficiency,"ating a Database. Navigation. Index. modules    .    .    .    .  · ; 1.1;  · . PSI4. Customization: Adding Simple Extensions. Creating a Database¶. Note; No recompile of the PSI program is necessary for changes made to; files in $PSIDATADIR, including those described below. A necessary consideration in constructing a database is the distinction; between reagents and reactions. A reagent is a single molecular system; (may be a dimer) whose geometry you are possession of and whose electronic; energy may be of interest. A reaction is a combination of one or more; reagent energies whose value you are interested in and a reference value; for which you may or may not be in possession of. A few examples follow.; In a database of interaction energies, the reagents are dimers and their; component monomers (usually derived from the dimer geometry), and the; reactions are the dimer less monomers energies. In a database of barrier; heights, the reagents are reactants, products, and transition-state; structures, and the reactions are the transition-states less; minimum-energy structures. Possibly you may have a collection of; structures to simply be acted upon in parallel, in which case the; structures are both the reagents and the reactions. The role of the; database.py file is to collect arrays and dictionaries that define the; geometries of reagents (GEOS), their combination into reactions (RXNM &; ACTV), available reference values for reactions (BIND), and brief comments; for reagents and reactions (TAGL). The journey from reagent geometries to; functional database.py file is largely automated, in a process described; below. Prepare geometry files; Assemble xyz files for all intended reagent systems in a directory.; Follow the rules below for best results. The filename for each xyz; file should be the name of the system. lowercase or MixedCase is; preferable (according to Sherrill lab convention). Avoid dashes and; dots in the name as python won’t allow them. If you’re dete",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/quickadddatabase-1.html:1080,energy,energy,1080,psi4manual/1.1.0/quickadddatabase-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/quickadddatabase-1.html,2,['energy'],['energy']
Energy Efficiency,"ating energies or gradients.; molecule; The target molecule, if not the last molecule defined.; kwargs; Any additional arguments to pass to :func:`psi4.driver.energy` or; :func:`psi4.driver.gradient` computation. """""". # Method used when the SCF command is received; self.scf_method = scf_method. # Additional arguments for energy, gradient, or optimization calculations; self.kwargs = kwargs. # Molecule all MDI operations are performed on; input_molecule = kwargs.pop('molecule', psi4.core.get_active_molecule()); self.molecule = input_molecule.clone(); psi4.core.set_active_molecule(self.molecule). # Most recent SCF energy; self.energy = 0.0. # Variables used when MDI sets a lattice of point charges; self.nlattice = 0 # number of lattice point charges; self.clattice = [] # list of lattice coordinates; self.lattice = [] # list of lattice charges; self.lattice_field = psi4.QMMMbohr() # Psi4 chargefield. # MPI variables; self.mpi_world = None; self.world_rank = 0. # Flag for if a lattice of point charges has been set; self.set_lattice = False. # Get correct intra-code MPI communicator; if use_mpi4py:; self.mpi_world = MDI_MPI_get_world_comm(); self.world_rank = self.mpi_world.Get_rank(). # Psi4 does not currently support multiple MPI ranks; if self.mpi_world.Get_size() != 1:; MPI.COMM_WORLD.Abort(). # Accept a communicator to the driver code; self.comm = MDI_Accept_Communicator(). # Ensure that the molecule is using c1 symmetry; self.molecule.reset_point_group('c1'); self.molecule.fix_orientation(True); self.molecule.fix_com(True); self.molecule.reinterpret_coordentry(False); self.molecule.update_geometry(). # Flag to stop listening for MDI commands; self.stop_listening = False. # Dictionary of all supported MDI commands; self.commands = {; ""<NATOMS"": self.send_natoms,; ""<COORDS"": self.send_coords,; ""<CHARGES"": self.send_charges,; ""<ELEMENTS"": self.send_elements,; ""<MASSES"": self.send_masses,; ""<ENERGY"": self.send_energy,; ""<FORCES"": self.send_forces,; "">COORDS"": self.recv_c",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/mdi_engine.html:2931,charge,charges,2931,psi4manual/1.7.x/_modules/psi4/driver/mdi_engine.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/mdi_engine.html,2,['charge'],['charges']
Energy Efficiency,"ating non-covalent; intermolecular forces, including counterpoise corrections and symmetry adapted; perturbation theory methods. These require the definition of which fragments; are interacting within the complex. PSI4 provides a very simple mechanism; for doing so: simply define the complex’s geometry using the standard; Cartesian, Z-matrix, or mixture thereof, specifications and then place two; dashes between nonbonded fragments. For example, to study the interaction; energy of ethane and ethyne molecules, we can use the following molecule; block:; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15molecule eneyne {; 0 1; C 0.000000 -0.667578 -2.124659; C 0.000000 0.667578 -2.124659; H 0.923621 -1.232253 -2.126185; H -0.923621 -1.232253 -2.126185; H -0.923621 1.232253 -2.126185; H 0.923621 1.232253 -2.126185; --; 0 1; C 0.000000 0.000000 2.900503; C 0.000000 0.000000 1.693240; H 0.000000 0.000000 0.627352; H 0.000000 0.000000 3.963929; }. In this case, the charge and multiplicity of each interacting fragment is; explicitly specified. If the charge and multiplicity are specified for the; first fragment, it is assumed to be the same for all fragments. When; considering interacting fragments, the overall charge is simply the sum of all; fragment charges, and any unpaired electrons are assumed to be coupled to; yield the highest possible \(M_s\) value.; Having defined a molecule containing fragments like eneyne above, it; is a simple matter to perform calculations on only a subset of the; fragments. For instance, the commands below run a scf first on the ethene; fragment alone (extract_subsets(1) pulls out fragment 1 as Real atoms; and discards remaining fragments) and next on the ethene fragment with the; ethyne fragment ghosted (extract_subsets(1,2) pulls out fragment 1 as; Real atoms and sets fragment 2 as Ghost atoms). For beyond bimolecular; complexes, arrays can be used, e.g. extract_subsets(2,[1,3]):; 1; 2; 3; 4; 5; 6; 7mA = eneyne.extract_subsets(1); energy('scf'",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/psithonmol-1.html:15451,charge,charge,15451,psi4manual/1.1.0/psithonmol-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/psithonmol-1.html,6,['charge'],['charge']
Energy Efficiency,"ation (0=nondynamic, higher=>more conservative). Type: integer; Default: 0. E3_SCALE (DFOCC)¶DFOCC — CEPA opposite-spin scaling value from SCS-CCSD. Type: double; Default: 0.25. E3_SCALE (OCC)¶OCC — Scaling value for 3rd order energy correction (S. Grimme, Vol. 24, pp. 1529, J. Comput. Chem.). Type: double; Default: 0.25. E_CONVERGENCE (CCENERGY)¶CCENERGY — Convergence criterion for energy. See Table Post-SCF Convergence for default convergence criteria for different calculation types. Type: conv double; Default: 1e-6. E_CONVERGENCE (CCEOM)¶CCEOM — Convergence criterion for excitation energy (change) in the Davidson algorithm for CC-EOM. See Table Post-SCF Convergence for default convergence criteria for different calculation types. Type: conv double; Default: 1e-6. E_CONVERGENCE (DCT)¶DCT — Convergence criterion for energy. See Table Post-SCF Convergence for default convergence criteria for different calculation types. Type: conv double; Default: 1e-10. E_CONVERGENCE (DETCI)¶DETCI — Convergence criterion for energy. See Table Post-SCF Convergence for default convergence criteria for different calculation types. Type: conv double; Default: 1e-6. E_CONVERGENCE (DFOCC)¶DFOCC — Convergence criterion for energy. See Table Post-SCF Convergence for default convergence criteria for different calculation types. Type: conv double; Default: 1e-6. E_CONVERGENCE (DLPNO)¶DLPNO — Energy convergence criteria for local MP2 iterations. Type: conv double; Default: 1e-6. E_CONVERGENCE (FNOCC)¶FNOCC — Convergence criterion for CC energy. See Table Post-SCF Convergence for default convergence criteria for different calculation types. Note that convergence is met only when E_CONVERGENCE and R_CONVERGENCE are satisfied. Type: conv double; Default: 1.0e-6. E_CONVERGENCE (MCSCF)¶MCSCF — Convergence criterion for energy. Type: conv double; Default: 1e-6. E_CONVERGENCE (MRCC)¶MRCC — Convergence criterion for energy. See Table Post-SCF Convergence for default convergence criteria for different",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/autodoc_glossary_options_c-1.html:117357,energy,energy,117357,psi4manual/1.5.0/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/autodoc_glossary_options_c-1.html,7,['energy'],['energy']
Energy Efficiency,"ation (0=nondynamic, higher=>more conservative). Type: integer; Default: 0. E3_SCALE (DFOCC)¶DFOCC — CEPA opposite-spin scaling value from SCS-CCSD. Type: double; Default: 0.25. E3_SCALE (OCC)¶OCC — Scaling value for 3rd order energy correction (S. Grimme, Vol. 24, pp. 1529, J. Comput. Chem.). Type: double; Default: 0.25. E_CONVERGENCE (CCENERGY)¶CCENERGY — Convergence criterion for energy. See Table Post-SCF Convergence for default convergence criteria for different calculation types. Type: conv double; Default: 1e-6. E_CONVERGENCE (CCEOM)¶CCEOM — Convergence criterion for excitation energy (change) in the Davidson algorithm for CC-EOM. See Table Post-SCF Convergence for default convergence criteria for different calculation types. Type: conv double; Default: 1e-6. E_CONVERGENCE (DCT)¶DCT — Convergence criterion for energy. See Table Post-SCF Convergence for default convergence criteria for different calculation types. Type: conv double; Default: 1e-10. E_CONVERGENCE (DETCI)¶DETCI — Convergence criterion for energy. See Table Post-SCF Convergence for default convergence criteria for different calculation types. Type: conv double; Default: 1e-6. E_CONVERGENCE (DFOCC)¶DFOCC — Convergence criterion for energy. See Table Post-SCF Convergence for default convergence criteria for different calculation types. Type: conv double; Default: 1e-6. E_CONVERGENCE (FNOCC)¶FNOCC — Convergence criterion for CC energy. See Table Post-SCF Convergence for default convergence criteria for different calculation types. Note that convergence is met only when E_CONVERGENCE and R_CONVERGENCE are satisfied. Type: conv double; Default: 1.0e-6. E_CONVERGENCE (MCSCF)¶MCSCF — Convergence criterion for energy. Type: conv double; Default: 1e-6. E_CONVERGENCE (MRCC)¶MRCC — Convergence criterion for energy. See Table Post-SCF Convergence for default convergence criteria for different calculation types. This becomes tol (option #16) in fort.56. Type: conv double; Default: 1e-6. E_CONVERGENCE (OCC)¶OC",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/autodoc_glossary_options_c-1.html:117220,energy,energy,117220,psi4manual/1.4.0/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodoc_glossary_options_c-1.html,2,['energy'],['energy']
Energy Efficiency,"ation (both gauges) at two frequencies on methyloxirane. cc3; cc3: RHF-CCSD/6-31G** H2O geometry optimization and vibrational frequency analysis by finite-differences of gradients. x2c1; Test of SFX2C-1e on water uncontracted cc-pVDZ-DK The reference numbers are from Lan Cheng’s implementation in Cfour. scf-bz2; Benzene Dimer Out-of-Core HF/cc-pVDZ. pywrap-checkrun-uhf; This checks that all energy methods can run with a minimal input and set symmetry. psimrcc-ccsd_t-1; Mk-MRCCSD(T) single point. \(^1A_1\) CH2 state described using the Ms = 0 component of the singlet. Uses RHF singlet orbitals. tdscf-2; td-uhf test on triplet states of methylene (tda), wfn passing. scf11-freq-from-energies; Test frequencies by finite differences of energies for planar C4NH4 TS. dfcasscf-sa-sp; Example of state-averaged CASSCF for the C2 molecule. dft1-alt; DFT Functional Test. cc14; ROHF-CCSD/cc-pVDZ \(^{3}B_1\) CH2 geometry optimization via analytic gradients. cc4; RHF-CCSD(T) cc-pVQZ frozen-core energy of the BH molecule, with Cartesian input. After the computation, the checkpoint file is renamed, using the PSIO handler. ghosts; Density fitted MP2 cc-PVDZ/cc-pVDZ-RI computation of formic acid dimer binding energy using explicit specification of ghost atoms. This is equivalent to the dfmp2_1 sample but uses both (equivalent) specifications of ghost atoms in a manual counterpoise correction. phi-ao; Test computing values of basis functions (puream and non-puream) at points. fd-freq-energy; SCF STO-3G finite-difference frequencies from energies for H2O. cisd-opt-fd; H2O CISD/6-31G** Optimize Geometry by Energies. mbis-6; MBIS calculation on H2O. scf-hess1; RHF STO-3G (Cartesian) and cc-pVDZ (spherical) water Hessian test, against Psi3 reference values. scf-guess-read1; Sample UHF/cc-pVDZ H2O computation on a doublet cation, using RHF/cc-pVDZ orbitals for the closed-shell neutral as a guess. cc13b; Tests RHF CCSD(T)gradients. soscf-large; Second-order SCF convergnece: Benzene. mints-he",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/autodoc_testsuite_corepsi4-1.html:26346,energy,energy,26346,psi4manual/1.5.0/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/autodoc_testsuite_corepsi4-1.html,4,['energy'],['energy']
Energy Efficiency,"ation according; to :py:func:`~wrappers.scf_xtpl_helgaker_3`. MP2, CCSD, and; CCSD(T) employ two-point extrapolation performed according to; :py:func:`~wrappers.corl_xtpl_helgaker_2`. CCSDT and CCSDT(Q); are plain deltas. This wrapper requires :ref:`Kallay's MRCC code <sec:mrcc>`. .. math:: E_{total}^{\text{FPA}} = E_{total,\; \text{SCF}}^{\text{cc-pV[Q56]Z}} \; + E_{corl,\; \text{MP2}}^{\text{cc-pV[56]Z}} \; + \delta_{\text{MP2}}^{\text{CCSD}}\big\vert_{\text{cc-pV[56]Z}} \; + \delta_{\text{CCSD}}^{\text{CCSD(T)}}\big\vert_{\text{cc-pV[56]Z}} \; + \delta_{\text{CCSD(T)}}^{\text{CCSDT}}\big\vert_{\text{cc-pVTZ}} \; + \delta_{\text{CCSDT}}^{\text{CCSDT(Q)}}\big\vert_{\text{cc-pVDZ}}. >>> # [1] single-point energy by this composite method; >>> energy('allen_focal_point'). >>> # [2] finite-difference geometry optimization embarrasingly parallel; >>> optimize('allen_focal_point', mode='sow'). """"""; lowername = name.lower(); kwargs = p4util.kwargs_lower(kwargs). if not ('func_cbs' in kwargs):; kwargs['func_cbs'] = energy. # SCF; if not ('scf_basis' in kwargs):; kwargs['scf_basis'] = 'cc-pV[Q56]Z'; if not ('scf_scheme' in kwargs):; kwargs['scf_scheme'] = scf_xtpl_helgaker_3. # delta MP2 - SCF; if not ('corl_wfn' in kwargs):; kwargs['corl_wfn'] = 'mp2'; name = 'mp2'; if not ('corl_basis' in kwargs):; kwargs['corl_basis'] = 'cc-pV[56]Z'; if not ('corl_scheme' in kwargs):; kwargs['corl_scheme'] = corl_xtpl_helgaker_2. # delta CCSD - MP2; if not ('delta_wfn' in kwargs):; kwargs['delta_wfn'] = 'mrccsd'; if not ('delta_wfn_lesser' in kwargs):; kwargs['delta_wfn_lesser'] = 'mp2'; if not ('delta_basis' in kwargs):; kwargs['delta_basis'] = 'cc-pV[56]Z'; if not ('delta_scheme' in kwargs):; kwargs['delta_scheme'] = corl_xtpl_helgaker_2. # delta CCSD(T) - CCSD; if not ('delta2_wfn' in kwargs):; kwargs['delta2_wfn'] = 'mrccsd(t)'; if not ('delta2_wfn_lesser' in kwargs):; kwargs['delta2_wfn_lesser'] = 'mrccsd'; if not ('delta2_basis' in kwargs):; kwargs['delta2_basis'] = 'cc-pV[56]Z'; if",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/aliases.html:4599,energy,energy,4599,psi4manual/4.0b5/_modules/aliases.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/aliases.html,2,['energy'],['energy']
Energy Efficiency,"ation coordinate with Python’s built-in loop mechanism. The geometry is specified by a Z-matrix with dummy atoms, fixed parameters, updated parameters, and separate charge/multiplicity specifiers for each monomer. One-electron properties computed for dimer and one monomer. castup1; Test of SAD/Cast-up (mainly not dying due to file weirdness). fcidump; test FCIDUMP functionality for rhf/uhf. fnocc5; Test FNO-DF-CCSD(T) energy. cepa3; cc-pvdz H2O Test coupled-pair CISD against DETCI CISD. cc12; Single point energies of multiple excited states with EOM-CCSD. extern1; External potential calculation involving a TIP3P water and a QM water. Finite different test of the gradient is performed to validate forces. fnocc4; Test FNO-DF-CCSD(T) energy. fd-freq-energy-large; SCF DZ finite difference frequencies by energies for C4NH4. cc54; CCSD dipole with user-specified basis set. dft-grad-lr2; Tests CAM gradients with and without XC pieces to narrow grid error. sapt-dft1; SAPT(DFT) aug-cc-pVDZ interaction energy between Ne and Ar atoms. fci-h2o-fzcv; 6-31G H2O Test FCI Energy Point. pywrap-alias; Test parsed and exotic calls to energy() like zapt4, mp2.5, and cisd are working. cc4a; RHF-CCSD(T) cc-pVQZ frozen-core energy of the BH molecule, with Cartesian input. This version tests the FROZEN_DOCC option explicitly. sad1; Test of the superposition of atomic densities (SAD) guess, using a highly distorted water geometry with a cc-pVDZ basis set. This is just a test of the code and the user need only specify guess=sad to the SCF module’s (or global) options in order to use a SAD guess. The test is first performed in C2v symmetry, and then in C1. psimrcc-pt2; Mk-MRPT2 single point. \(^1A_1\) F2 state described using the Ms = 0 component of the singlet. Uses TCSCF singlet orbitals. dfmp2-freq1; DF-MP2 frequency by difference of energies for H2O. cc51; EOM-CC3/cc-pVTZ on H2O. rasci-h2o; RASCI/6-31G** H2O Energy Point. ddd-deriv; Sample HF/cc-pVDZ H2O computation all derivatives. scf-au",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/autodoc_testsuite_corepsi4.html:8550,energy,energy,8550,psi4manual/1.6.x/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/autodoc_testsuite_corepsi4.html,2,['energy'],['energy']
Energy Efficiency,"ation energies from [E. Soydas and U. Bozkaya, JCTC, 9, 1452-1460 (2013)] at CCSD(T)/cc-pCVTZ level. benchmark. 'RSE42' [E. Soydas and U. Bozkaya, JCTC, 9, 1452-1460 (2013)].; \(\Rightarrow\) 'RSE42' \(\Leftarrow\) [E. Soydas and U. Bozkaya, JCTC, 9, 1452-1460 (2013)]. subset. 'small' <members_description>; 'large' <members_description>; 'RSE30' smaller systems in RSE42; '<subset>' <members_description>. A24alt¶. Database (Hobza) of interaction energies for bimolecular complexes.; Geometries from <Reference>.; Reference interaction energies from Rezac and Hobza, JCTC (in press). cp 'off' <erase this comment and after unless on is a valid option> || 'on'; rlxd 'off' <erase this comment and after unless on is valid option> || 'on'; benchmark. '<benchmark_name>' <Reference>.; \(\Rightarrow\) '<default_benchmark_name>' \(\Leftarrow\) <Reference>. subset. 'small' <members_description>; 'large' <members_description>; '<subset>' <members_description>. BENCH12¶. Database of <description of members and reference energy type>.; Geometries from <Reference>.; Reference interaction energies from <Reference>. benchmark. '<benchmark_name>' <Reference>.; \(\Rightarrow\) '<default_benchmark_name>' \(\Leftarrow\) <Reference>. subset. 'small'; 'large'; 'alkenes'; 'alkanes'; 'acenes'; 'thiophenes'; 'h2o_size'; 'h2o_shape'; 'atoms'; 'S22_HB'; 'S22_MX'; 'S22_DD'. CORE¶. Database of Pulay corannulene structures. Subsumed into CFLOW. cp 'off' || 'on'; rlxd 'off'. SSI¶. Database (Merz) of interaction energies for protein sidechain-sidechain interactions.; Geometries from Kenneth Merz Group, Univ. of Florida.; Reference interaction energies from <Reference>.; Part of the BioFragment Database (BFDb). cp 'off' || 'on'; rlxd 'off'. BASIC¶. Database of simple molecules, mostly for testing.; Geometries from nowhere special, and no reference energies defined. cp 'off'; rlxd 'off'; subset ['h2o', 'nh3', 'ch4']. S66by8¶. Database (Hobza) of interaction energies for bimolecular complexes.; Geometries",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/autodoc_available_databases-1.html:1865,energy,energy,1865,psi4manual/1.4.0/autodoc_available_databases-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodoc_available_databases-1.html,4,['energy'],['energy']
Energy Efficiency,"ation energies.; These are expected in atomic units of angular frequency.; residues (Union[List[float], ndarray]) – Residues of the linear response functions, i.e. transition dipole moments (OPA) and rotatory strengths (ECD).; These are expected in atomic units.; kind (str) – {“opa”, “ecd”}; Which kind of spectrum to generate, one-photon absorption (“opa”) or electronic circular dichroism (“ecd”).; Default is opa.; lineshape (str) – {“gaussian”, “lorentzian”}; The lineshape function to use in the fitting. Default is gaussian.; gamma (float) – Full width at half maximum of the lineshape function.; Default is 0.2 au of angular frequency.; This value is expected in atomic units of angular frequency.; npoints (int) – How many points to generate for the x axis. Default is 5000.; out_units (str) – Units for the output array x, the x axis of the spectrum plot.; Default is wavelengths in nanometers.; Valid (and case-insensitive) values for the units are:. au atomic units of angular frequency; Eh atomic units of energy; eV; nm; THz. Returns:; spectrum – The fitted electronic absorption spectrum, with units for the x axis specified by the out_units parameter.; This is a dictionary containing the convoluted (key: convolution) and the infinitely narrow spectra (key: sticks).; {""convolution"": {""x"": np.ndarray, ""y"": np.ndarray},; ""sticks"": {""poles"": np.ndarray, ""residues"": np.ndarray}}. Return type:; Dict[str, numpy.ndarray]. Notes. Conversion of the broadening parameter \(\gamma\).; The lineshape functions are formulated as functions of the angular frequency \(\omega\).; When converting to other physical quantities, the broadening parameter has to be modified accordingly.; If \(\gamma_{\omega}\) is the chosen broadening parameter then:. Wavelength: \(gamma_{\lambda} = \frac{\lambda_{ij}^{2}}{2\pi c}\gamma_{\omega}\); Frequency: \(gamma_{\nu} = \frac{\gamma_{\omega}}{2\pi}\); Energy: \(gamma_{E} = \gamma_{\omega}\hbar\). References; A. Rizzo, S. Coriani, K. Ruud, “Response Functi",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/api/psi4.driver.p4util.spectrum.html:2261,energy,energy,2261,psi4manual/1.7.x/api/psi4.driver.p4util.spectrum.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.driver.p4util.spectrum.html,8,['energy'],['energy']
Energy Efficiency,"ation energy component [H]; for the perturbatively corrected coupled-cluster (CCSD(T), CCSDT(Q),; up to CC(n-1)(n) level of theory. CCSDT-1a TOTAL ENERGY¶. CCSDT-1a CORRELATION ENERGY¶. CCSDTQ-1a TOTAL ENERGY¶. CCSDTQ-1a CORRELATION ENERGY¶. CCn-1a TOTAL ENERGY¶. CCn-1a CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the approximate coupled-cluster (CCSD(T)-1a, CCSDT(Q)-1a,; up to CCn-1a) level of theory. CCSDT-1b TOTAL ENERGY¶. CCSDT-1b CORRELATION ENERGY¶. CCSDTQ-1b TOTAL ENERGY¶. CCSDTQ-1b CORRELATION ENERGY¶. CCn-1b TOTAL ENERGY¶. CCn-1b CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the approximate coupled-cluster (CCSD(T)-1b, CCSDT(Q)-1b,; up to CCn-1b) level of theory. CCSDT-3 TOTAL ENERGY¶. CCSDT-3 CORRELATION ENERGY¶. CCSDTQ-3 TOTAL ENERGY¶. CCSDTQ-3 CORRELATION ENERGY¶. CCn-3 TOTAL ENERGY¶. CCn-3 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the approximate coupled-cluster (CCSD(T)-3, CCSDT(Q)-3,; up to CCn-3) level of theory. CCSD(T)_L TOTAL ENERGY¶. CCSD(T)_L CORRELATION ENERGY¶. CCSDT(Q)_L TOTAL ENERGY¶. CCSDT(Q)_L CORRELATION ENERGY¶. CC(n-1)(n)_L TOTAL ENERGY¶. CC(n-1)(n)_L CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the approximate coupled-cluster (CCSD(T)_L, CCSDT(Q)_L,; up to CC(n-1)(n)L level of theory. CEPA(0) DIPOLE X¶. CEPA(0) DIPOLE Y¶. CEPA(0) DIPOLE Z¶; The three components of the dipole [Debye] for the; coupled electron pair approximation variant 0 level of theory. CEPA(0) QUADRUPOLE XX¶. CEPA(0) QUADRUPOLE XY¶. CEPA(0) QUADRUPOLE XZ¶. CEPA(0) QUADRUPOLE YY¶. CEPA(0) QUADRUPOLE YZ¶. CEPA(0) QUADRUPOLE ZZ¶; The six components of the quadrupole [Debye Ang] for the; coupled electron pair approximation variant 0 level of theory. CEPA(0) TOTAL ENERGY¶. CEPA(0) CORRELATION ENERGY¶. CEPA(1) TOTAL ENERGY¶. CEPA(1) CORRELATION ENERGY¶. CEPA(2) TOTAL ENERGY¶.",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/glossary_psivariables-1.html:4463,energy,energy,4463,psi4manual/4.0b3/glossary_psivariables-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/glossary_psivariables-1.html,8,['energy'],['energy']
Energy Efficiency,"ation energy correction [E_h] appended to an; underlying functional when a DH-DFT method is requested.; Quantity \(E_{\text{DH}}\) in Eq. (1). DMA DISTRIBUTED MULTIPOLES¶; Distributed multipoles in units given by GDMA_MULTIPOLE_UNITS; with the row index corresponding to the site and the column index; referencing the multipole component. Both indices are zero based,; and the Qlm components of the multipoles are ordered as Q00, Q10,; Q11c, Q11s, Q20, Q21c, Q21s, Q22c, Q22s, etc. DMA TOTAL MULTIPOLES¶; Distributed multipoles as a single row, whose columns are the total; multipoles, translated to GDMA_ORIGIN, and summed. DMRG-SCF TOTAL ENERGY¶; The total DMRG total electonic energy [E_h]. Not unique because oribital spaces vary. DMRG-CASPT2 TOTAL ENERGY¶; The total DMRG plus CASPT2 total electonic energy [E_h] . Not unique because orbital spaces vary. EFP DISP ENERGY¶. EFP ELST ENERGY¶. EFP EXCH ENERGY¶. EFP IND ENERGY¶; Respectively, the dispersion, electrostatics, exchange, and induction; components of the total electronic interaction energy [E_h] for EFP/EFP; computations. The sum of these four components yields; EFP TOTAL ENERGY. EFP TOTAL ENERGY¶; The total electronic interaction energy [E_h] for EFP/EFP computations. EFP TORQUE¶; The torque, not gradient for EFP/EFP computations. ENTHALPY¶; Total enthalpy H [E_h] at given temperature. ENTHALPY CORRECTION¶; Sum of electronic, translational, rotational, and vibrational corrections [E_h] to the enthalpy at given temperature. ESP AT CENTER n¶; Property of electrostatic potential [E_h / e] at location, usually atom center, n. FCI TOTAL ENERGY¶. FCI CORRELATION ENERGY¶; The total electronic energy [E_h] and correlation energy component [E_h]; for the full configuration interaction level of theory. GIBBS FREE ENERGY¶; Total Gibbs free energy [E_h], free enthalpy at given temperature. GIBBS FREE ENERGY CORRECTION¶; Sum of electronic, translational, rotational, and vibrational corrections [E_h] to the free enthalpy at given",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/glossary_psivariables.html:31031,energy,energy,31031,psi4manual/1.7.x/glossary_psivariables.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/glossary_psivariables.html,4,['energy'],['energy']
Energy Efficiency,"ation interaction singles and doubles level of theory, (3,). CISD QUADRUPOLE¶; Redundant quadrupole array [e a0^2] for the configuration interaction singles and doubles level of theory, (3, 3). CISD TOTAL ENERGY¶. CISD CORRELATION ENERGY¶. CISDT TOTAL ENERGY¶. CISDT CORRELATION ENERGY¶. CISDTQ CORRELATION ENERGY¶. CISDTQ TOTAL ENERGY¶. CIn CORRELATION ENERGY¶. CIn TOTAL ENERGY¶; The total electronic energy [E_h] and correlation energy component [E_h]; for the labeled configuration interaction level of theory and root.; n is CI order for n > 4. CP-CORRECTED 2-BODY INTERACTION ENERGY¶; The interaction energy [E_h] considering only two-body interactions,; computed with counterpoise correction.; Related variable UNCP-CORRECTED 2-BODY INTERACTION ENERGY. \[E_{\text{IE}} = E_{dimer} - \sum_{monomer}^{n}{E_{monomer}^{\text{CP}}}\]. CURRENT CORRELATION ENERGY¶; The correlation energy [E_h] corresponding to the CURRENT ENERGY variable. CURRENT ENERGY¶; The total electronic energy [E_h] of the most recent stage of a; calculation (frequently overwritten). This is the quantity tracked by; the geometry optimizer. CURRENT REFERENCE ENERGY¶; The total electronic energy [E_h] of the reference stage corresponding to; the CURRENT ENERGY variable. CURRENT DIPOLE¶; The total dipole [e a0] of the most recent stage of a calculation (frequently overwritten), (3,). CURRENT GRADIENT¶; The total electronic gradient [E_h/a0] of the most recent stage of a; calculation (frequently overwritten). This is the quantity tracked by; the geometry optimizer, ({nat}, 3). CURRENT DIPOLE GRADIENT¶; The derivative of the dipole with respect to nuclear perturbations [E_h a0/u] = [(e a0/a0)^2/u]; as a degree-of-freedom by dipole component array, (3 * {nat}, 3). CURRENT HESSIAN¶; The total electronic Hessian [E_h/a0/a0] of the most recent stage of a; calculation, (3 * {nat}, 3 * {nat}). CUSTOM SCS-MP2 TOTAL ENERGY¶. CUSTOM SCS-MP2 CORRELATION ENERGY¶; Changeable quantities based on options.; The total electro",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/glossary_psivariables.html:23661,energy,energy,23661,psi4manual/1.7.x/glossary_psivariables.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/glossary_psivariables.html,4,['energy'],['energy']
Energy Efficiency,"ation level to print. CC analog to NUM_DETS_PRINT. Type: integer; Default: 10. MCSCF¶. DF_BASIS_MCSCF¶. Auxiliary basis set for MCSCF density fitted ERI computations. This only effects the “Q” matrix in Helgaker’s language. Defaults to a JKFIT basis. Type: string; Possible Values: basis string; Default: No Default. MCSCF_ALGORITHM¶. Convergence algorithm to utilize. Two-Step, Augmented Hessian, or One-Step. Defaults to TS for RASSCF. Type: string; Possible Values: TS, AH; Default: TS. MCSCF_DIIS_ERROR_TYPE¶. DIIS error vector type either, the AO orbital gradient or the orbital rotation update matrix. Type: string; Possible Values: GRAD, UPDATE; Default: GRAD. MCSCF_DIIS_FREQ¶. How often to do a DIIS extrapolation for TS convergence. Type: integer; Default: 1. MCSCF_DIIS_MAX_VECS¶. Maximum number of DIIS vectors for TS convergence. Type: integer; Default: 8. MCSCF_DIIS_START¶. Iteration to turn on DIIS for TS convergence. Type: integer; Default: 3. MCSCF_E_CONVERGENCE¶. Convergence criterion for energy. See Table Post-SCF Convergence for default convergence criteria for different calculation types. Type: conv double; Default: 1e-7. MCSCF_GUESS¶. Initial MCSCF starting guess, MP2 natural orbitals only available for DF-RHF reference. Type: string; Possible Values: MP2, SCF; Default: SCF. MCSCF_MAXITER¶. Maximum number MCSCF of iterations. Type: integer; Default: 30. MCSCF_MAX_ROT¶. Maximum value in the rotation matrix. If a value is greater than this number all values are scaled. Type: double; Default: 0.5. MCSCF_ROTATE¶. Apply a list of 2x2 rotation matrices to the orbitals in the form of [irrep, orbital1, orbital2, theta] where an angle of 0 would do nothing and an angle of 90 would switch the two orbitals. Type: array; Default: No Default. MCSCF_R_CONVERGENCE¶. Convergence criterion for the RMS of the orbital gradient. Type: conv double; Default: 1e-5. MCSCF_SO_START_E¶. Start second-order (AH or OS) orbital-orbital MCSCF based on energy convergence. Type: double; D",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/autodir_options_c/module__detci-1.html:10434,energy,energy,10434,psi4manual/1.1.0/autodir_options_c/module__detci-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/autodir_options_c/module__detci-1.html,4,['energy'],['energy']
Energy Efficiency,"ation of the formamide dimer interaction energy, using the aug-cc-pVDZ-JKFIT DF basis for SCF and aug-cc-pVDZ-RI for SAPT. This example uses frozen core as well as MP2 natural orbital approximations. tu5-sapt; Example SAPT computation for ethene*ethine (i.e., ethylene*acetylene), test case 16 from the S22 database. mp2-1; All-electron MP2 6-31G** geometry optimization of water. dfccsd-grad1; DF-CCSD cc-pVDZ gradients for the H2O molecule. casscf-semi; CASSCF/6-31G** energy point. Check energy with frozen core/virtual orbs. after semicanonicalization. cc48; reproduces dipole moments in J.F. Stanton’s “biorthogonal” JCP paper. lccd-grad2; LCCD cc-pVDZ gradient for the NO radical. cdomp2-2; OMP2 cc-pVDZ energy for the NO molecule. olccd2; OLCCD cc-pVDZ energy with B3LYP initial guess for the NO radical. scf-hess4; DF SCF 6-31G UHFl vs RHF test Tests DF UHF hessian code for Ca = Cb. x2c-perturb-h; Test SFX2C-1e with a static electric field on He aug-cc-pVTZ. cc5; RHF CCSD(T) aug-cc-pvtz frozen-core energy of C4NH4 Anion. mp2p5-grad2; MP2.5 cc-pVDZ gradient for the NO radical. cubeprop-frontier; ROHF frontier orbitals of CH2(s) and CH2(t). pywrap-freq-g-sowreap; Finite difference of gradients frequency, run in sow/reap mode. dfccsdt1; DF-CCSD(T) cc-pVDZ energy for the H2O molecule. opt-freeze-coords; SCF/cc-pVDZ optimization example with frozen cartesian. dfomp2-grad2; OMP2 cc-pVDZ energy for the NO molecule. isapt1; This test case shows an example of running and analyzing an FI-SAPT0/jun-cc-pvdz computation for 2,4-pentanediol (targeting the intramolecular hydrogen bond between the two hydroxyl groups). cbs-xtpl-opt; Various extrapolated optimization methods for the H2 molecule. isapt2; This is a shorter version if isapt1 - does not do cube plots. See isapt1 for full details. scf-hess5; DF SCF 6-31G analytical vs finite-difference tests Tests DF UHF hessian code for Ca != Cb. cc43; RHF-CC2-LR/STO-3G optical rotation of (S)-methyloxirane. gauge = both, omega = (589 355 n",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/autodoc_testsuite_corepsi4-1.html:32788,energy,energy,32788,psi4manual/1.4.0/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodoc_testsuite_corepsi4-1.html,4,['energy'],['energy']
Energy Efficiency,"ation of the; HJS model. Double-Hybrid FunctionalsDouble hybrids are percolating into PSI4. Note that these are; only available with density-fitted, not conventional, MP2 algorithms. -D FunctionalsWe have several -D2 functionals implemented. -D3 functionls are available; with the installation of Grimme’s DFTD3 program.; For now, the pure-GGA B97-D; functional of Grimme is remarkably accurate, and the hybrid B3LYP-D; functional is also quite reliable. Note: we have made a sincere effort to rigorously test all functionals; implemented in PSI4 for correctness. If you find an error in a DFT; functional or have a request for a new functional, please let us know on our; forum or GitHub page. Grid Selection¶; PSI4 uses the standard Lebedev-Laikov spherical quadratures in concert with a; number of radial quadratures and atomic partitioning schemes.; The default grid in PSI4 is a Lebedev-Treutler (75,302) grid with a Treutler; partition of the atomic weights.; Spherical grids are all of the extremely efficient Lebedev-Laikov type.; Spherical grid resolution is controlled by the DFT_SPHERICAL_POINTS; option, which may take one of the following values:. DFT_SPHERICAL_POINTS; Order. 6; 3. 14; 5. 26; 7. 38; 9. 50; 11. 74; 13. 86; 15. 110; 17. 146; 19. 170; 21. 194; 23. 230; 25. 266; 27. 302; 29. 350; 31. 434; 35. 590; 41. 770; 47. 974; 53. 1202; 59. 1454; 65. 1730; 71. 2030; 77. 2354; 83. 2702; 89. 3074; 95. 3470; 101. 3890; 107. 4334; 113. 4802; 119. 5294; 125. 5810; 131. The spherical grids are rotated according to a common set of rules developed; during the implementation of SG1. At the moment, the rules for tetrahedral,; octohedral, and icosohedral systems are not complete, so there may be some; ambiguity in the grid orientation for these systems.; Radial grid types are controlled by the DFT_RADIAL_SCHEME option, which; at the moment may be either TREUTLER or BECKE, while the number of radial; points are controlled by the DFT_RADIAL_POINTS option, which is any positive; integ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/dft-1.html:19355,efficient,efficient,19355,psi4manual/1.4.0/dft-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/dft-1.html,9,['efficient'],['efficient']
Energy Efficiency,"ation run with the call; energy('fno-qcisd') to energy():; QCISD iterations converged!. OS MP2 FNO correction: -0.000819116338; SS MP2 FNO correction: -0.000092278158; MP2 FNO correction: -0.000911394496. OS MP2 correlation energy: -0.166478414245; SS MP2 correlation energy: -0.056669079827; MP2 correlation energy: -0.223147494072; * MP2 total energy: -76.258836941658. OS MP2.5 correlation energy: -0.171225850256; SS MP2.5 correlation energy: -0.054028401038; MP2.5 correlation energy: -0.225254251294; * MP2.5 total energy: -76.260943698880. OS MP3 correlation energy: -0.175973286267; SS MP3 correlation energy: -0.051387722248; MP3 correlation energy: -0.227361008515; * MP3 total energy: -76.263050456101. OS MP4(SDQ) correlation energy: -0.180324322304; SS MP4(SDQ) correlation energy: -0.048798468084; MP4(SDQ) correlation energy: -0.230995119324; * MP4(SDQ) total energy: -76.266684566910. OS QCISD correlation energy: -0.181578117924; SS QCISD correlation energy: -0.049853548145; QCISD correlation energy: -0.231431666069; * QCISD total energy: -76.267121113654. The first set of energies printed corresponds to the second-order FNO; correction mentioned previously. Results for many-body perturbation; theory through partial fourth order are then provided.; The notation MP4(SDQ) indicates that we have included all contributions to; the correlation energy through fourth order, with the exception of that; from connected triple excitations.; One need not run a full QCISD or CCSD computation to obtain these; perturbation theory results. The keywords for invoking perturbation; theory computations are given below in; Table FNOCC Methods. Full MP4 correlation; energies are also available. Coupled electron pair approximation¶; Coupled-pair methods can be viewed as approximations to CCSD or as; size-extensive modifications of CISD. The methods have the same; complexity as CISD, and solving the CISD or coupled-pair equations; requires fewer floating point operations than solving the",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/fnocc-1.html:6233,energy,energy,6233,psi4manual/1.4.0/fnocc-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/fnocc-1.html,15,['energy'],['energy']
Energy Efficiency,"ation to file. class psi4.core.FDDS_Dispersion¶; Bases: pybind11_builtins.pybind11_object; docstring. aux_overlap(self: psi4.core.FDDS_Dispersion) → psi4.core.Matrix¶; Obtains the FDDS aux_overlap. form_unc_amplitude(self: psi4.core.FDDS_Dispersion, arg0: str, arg1: float) → psi4.core.Matrix¶; Forms the uncoupled amplitudes for either monomer. metric(self: psi4.core.FDDS_Dispersion) → psi4.core.Matrix¶; Obtains the FDDS metric. metric_inv(self: psi4.core.FDDS_Dispersion) → psi4.core.Matrix¶; Obtains the FDDS metric_inv. project_densities(self: psi4.core.FDDS_Dispersion, arg0: List[psi4.core.Matrix]) → List[psi4.core.Matrix]¶; Projects a density from the primary AO to auxiliary AO space. class psi4.core.FISAPT¶; Bases: pybind11_builtins.pybind11_object; A Fragment-SAPT Wavefunction. compute_energy(self: psi4.core.FISAPT) → None¶; Computes the FSAPT energy. disp(self: psi4.core.FISAPT, arg0: Dict[str, psi4.core.Matrix], arg1: Dict[str, psi4.core.Vector], arg2: bool) → None¶; Computes the MP2-based DispE20 and Exch-DispE20 energy. scalars(self: psi4.core.FISAPT) → Dict[str, float]¶; Return the interally computed scalars. class psi4.core.FittedSlaterCorrelationFactor¶; Bases: psi4.core.CorrelationFactor; docstring. exponent(self: psi4.core.FittedSlaterCorrelationFactor) → float¶. set_params(self: psi4.core.CorrelationFactor, coeff: psi4.core.Vector, exponent: psi4.core.Vector) → None¶; Set coefficient and exponent. class psi4.core.FittingMetric¶; Bases: pybind11_builtins.pybind11_object; docstring. form_QR_inverse(self: psi4.core.FittingMetric, arg0: float) → None¶; docstring. form_cholesky_inverse(self: psi4.core.FittingMetric) → None¶; docstring. form_eig_inverse(self: psi4.core.FittingMetric, arg0: float) → None¶; docstring. form_fitting_metric(self: psi4.core.FittingMetric) → None¶; docstring. form_full_inverse(self: psi4.core.FittingMetric) → None¶; docstring. get_algorithm(self: psi4.core.FittingMetric) → str¶; docstring. get_metric(self: psi4.core.FittingMetric) →",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/psi4api-1.html:64246,energy,energy,64246,psi4manual/1.2.1/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html,2,['energy'],['energy']
Energy Efficiency,"ation(' S. Grimme, J. Comput. Chem., 27, 1787-1799, 2006\n'). # Add member functionals; X = build_functional('B97_X'); X.set_name('B97-D_X'); X.set_alpha(1.0). X.set_parameter('B97_gamma', 0.004); X.set_parameter('B97_a0', 1.08662); X.set_parameter('B97_a1', -0.52127); X.set_parameter('B97_a2', 3.25429). C = build_functional('B_C'); C.set_name('B97-D_C'). C.set_parameter('B97_os_gamma', 0.006); C.set_parameter('B97_os_a0', 0.69041); C.set_parameter('B97_os_a1', 6.30270); C.set_parameter('B97_os_a2', -14.9712). C.set_parameter('B97_ss_gamma', 0.2); C.set_parameter('B97_ss_a0', 0.22340); C.set_parameter('B97_ss_a1', -1.56208); C.set_parameter('B97_ss_a2', 3.25429). sup.add_x_functional(X); sup.add_c_functional(C). # => -D2 (s = 1.25) <= #; sup.set_dispersion(PsiMod.Dispersion.build('-D2', 1.25)). # Set GKS up after adding functionals; sup.set_x_omega(0.0); sup.set_c_omega(0.0); sup.set_x_alpha(0.0); sup.set_c_alpha(0.0). # => End User-Customization <= #. # Call this last; sup.allocate(); return sup. [docs]def build_hcth_superfunctional(name, npoints, deriv):. # Call this first; sup = PsiMod.SuperFunctional.blank(); sup.set_max_points(npoints); sup.set_deriv(deriv). # => User-Customization <= #. # No spaces, keep it short and according to convention; sup.set_name('HCTH'); # Tab in, trailing newlines; sup.set_description(' HCTH Pure-GGA Exchange-Correlation Functional\n'); # Tab in, trailing newlines; sup.set_citation(' F.A. Hamprecht et. al., J. Chem. Phys., 109(15), 6264-6271\n'). # Add member functionals; X = build_functional('B97_X'); X.set_name('HCTH_X'); X.set_alpha(1.0). X.set_parameter('B97_gamma', 0.004); X.set_parameter('B97_a0', 1.09320); X.set_parameter('B97_a1', -0.744056); X.set_parameter('B97_a2', 5.59920); X.set_parameter('B97_a3', -6.78549); X.set_parameter('B97_a4', 4.49357). C = build_functional('B_C'); C.set_name('HCTH_C'). C.set_parameter('B97_os_gamma', 0.006); C.set_parameter('B97_os_a0', 0.729974); C.set_parameter('B97_os_a1', 3.35287); C.set_para",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/_modules/functional.html:32488,allocate,allocate,32488,psi4manual/4.0b2/_modules/functional.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/functional.html,4,['allocate'],['allocate']
Energy Efficiency,"ation, from energy points.; ; fd_freq_0(...); fd_freq_0( (list)arg1, (int)arg2) -> PsiReturnType :; Performs a finite difference frequency computation, from energy points, for a given irrep.; ; fd_freq_1(...); fd_freq_1( (list)arg1, (int)arg2) -> PsiReturnType :; Performs a finite difference frequency computation, from gradients, for a given irrep.; ; fd_geoms_1_0(...); fd_geoms_1_0() -> matrix_vector :; Gets the list of displacements needed for a finite difference gradient computation, from energy points.; ; fd_geoms_freq_0(...); fd_geoms_freq_0( (int)arg1) -> matrix_vector :; Gets the list of displacements needed for a finite difference frequency computation, from energy points, for a given irrep.; ; fd_geoms_freq_1(...); fd_geoms_freq_1( (int)arg1) -> matrix_vector :; Gets the list of displacements needed fof a finite difference frequency computation, from gradients, for a given irrep; ; fd_geoms_hessian_0(...); fd_geoms_hessian_0() -> matrix_vector :; Gets the list of displacements needed fof a finite difference frequency computation, from energy points.; ; fd_hessian_0(...); fd_hessian_0( (list)arg1) -> PsiReturnType :; Performs a finite difference frequency computation, from energy points.; ; flush_outfile(...); flush_outfile() -> None :; Flushes the output file.; ; fnocc(...); fnocc() -> float :; Runs the fno-ccsd(t)/qcisd(t)/mp4/cepa energy code; ; get_active_molecule(...); get_active_molecule() -> Molecule :; Returns the currently active molecule object.; ; get_frequencies(...); get_frequencies() -> Vector :; Returns the most recently computed frequencies, as a 3N-6 Vector object.; ; get_global_option(...); get_global_option( (str)arg1) -> object :; Given a string of a keyword name, returns the value associated with the keyword from the global options. Returns error if keyword is not recognized.; ; get_global_option_list(...); get_global_option_list() -> list :; Returns a list of all global options.; ; get_gradient(...); get_gradient() -> Matrix :; Returns ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/psimod-1.html:157032,energy,energy,157032,psi4manual/4.0b5/psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/psimod-1.html,2,['energy'],['energy']
Energy Efficiency,"ation, from energy points.; ; fd_freq_0(...); fd_freq_0( (list)arg1, (int)arg2) -> PsiReturnType :; Performs a finite difference frequency computation, from energy points, for a given irrep.; ; fd_freq_1(...); fd_freq_1( (list)arg1, (int)arg2) -> PsiReturnType :; Performs a finite difference frequency computation, from gradients, for a given irrep.; ; fd_geoms_1_0(...); fd_geoms_1_0() -> matrix_vector :; Gets the list of displacements needed for a finite difference gradient computation, from energy points.; ; fd_geoms_freq_0(...); fd_geoms_freq_0( (int)arg1) -> matrix_vector :; Gets the list of displacements needed for a finite difference frequency computation, from energy points, for a given irrep.; ; fd_geoms_freq_1(...); fd_geoms_freq_1( (int)arg1) -> matrix_vector :; Gets the list of displacements needed fof a finite difference frequency computation, from gradients, for a given irrep; ; fd_geoms_hessian_0(...); fd_geoms_hessian_0() -> matrix_vector :; Gets the list of displacements needed fof a finite difference frequency computation, from energy points.; ; fd_hessian_0(...); fd_hessian_0( (list)arg1) -> PsiReturnType :; Performs a finite difference frequency computation, from energy points.; ; flush_outfile(...); flush_outfile() -> None :; Flushes the output file.; ; fnocc(...); fnocc() -> float :; Runs the fno-ccsd(t)/qcisd(t)/mp4/cepa energy code; ; get_active_molecule(...); get_active_molecule() -> Molecule :; Returns the currently active molecule object.; ; get_global_option(...); get_global_option( (str)arg1) -> object :; Given a string of a keyword name, returns the value associated with the keyword from the global options. Returns error if keyword is not recognized.; ; get_global_option_list(...); get_global_option_list() -> list :; Returns a list of all global options.; ; get_gradient(...); get_gradient() -> Matrix :; Returns the most recently computed gradient, as a N by 3 Matrix object.; ; get_input_directory(...); get_input_directory() -> str :; Retu",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/psimod-1.html:107279,energy,energy,107279,psi4manual/4.0b4/psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod-1.html,2,['energy'],['energy']
Energy Efficiency,"ation, from energy points.; ; fd_freq_0(...); fd_freq_0( (list)arg1, (int)arg2) -> PsiReturnType :; Performs a finite difference frequency computation, from energy points, for a given irrep.; ; fd_freq_1(...); fd_freq_1( (list)arg1, (int)arg2) -> PsiReturnType :; Performs a finite difference frequency computation, from gradients, for a given irrep.; ; fd_geoms_1_0(...); fd_geoms_1_0() -> matrix_vector :; Gets the list of displacements needed for a finite difference gradient computation, from energy points.; ; fd_geoms_freq_0(...); fd_geoms_freq_0( (int)arg1) -> matrix_vector :; Gets the list of displacements needed for a finite difference frequency computation, from energy points, for a given irrep.; ; fd_geoms_freq_1(...); fd_geoms_freq_1( (int)arg1) -> matrix_vector :; Gets the list of displacements needed fof a finite difference frequency computation, from gradients, for a given irrep; ; fd_geoms_hessian_0(...); fd_geoms_hessian_0() -> matrix_vector :; Gets the list of displacements needed fof a finite difference frequency computation, from energy points.; ; fd_hessian_0(...); fd_hessian_0( (list)arg1) -> PsiReturnType :; Performs a finite difference frequency computation, from energy points.; ; flush_outfile(...); flush_outfile() -> None :; Flushes the output file.; ; get_active_molecule(...); get_active_molecule() -> Molecule :; Returns the currently active molecule object.; ; get_global_option(...); get_global_option( (str)arg1) -> object :; Given a string of a keyword name, returns the value associated with the keyword from the global options. Returns error if keyword is not recognized.; ; get_global_option_list(...); get_global_option_list() -> list :; Returns a list of all global options.; ; get_gradient(...); get_gradient() -> Matrix :; Returns the most recently computed gradient, as a N by 3 Matrix object.; ; get_input_directory(...); get_input_directory() -> str :; Returns the location of the input file.; ; get_local_option(...); get_local_option( (str)a",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/psimod-1.html:106819,energy,energy,106819,psi4manual/4.0b3/psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod-1.html,2,['energy'],['energy']
Energy Efficiency,"ation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. Customization: Adding Simple Extensions; Creating a Database. Creating a Database¶. Note; No recompile of the PSI program is necessary for changes made to; files in $PSIDATADIR, including those described below. A necessary consideration in constructing a database is the distinction; between reagents and reactions. A reagent is a single molecular system; (may be a dimer) whose geometry you are possession of and whose electronic; energy may be of interest. A reaction is a combination of one or more; reagent energies whose value you are interested in and a reference value; for which you may or may not be in possession of. A few examples follow.; In a database of interaction energies, the reagents are dimers and their; component monomers (usually derived from the dimer geometry), and the; reactions are the dimer less monomers energies. In a database of barrier; heights, the reagents are reactants, products, and transition-state; structures, and the reactions are the transition-states less; minimum-energy structures. Possibly you may have a collection of; structures to simply be acted upon in parallel, in which case the; structures are both the reagents and the reactions. The role of the; database.py file is to collect arrays and dictionaries that define the; geometries of reagents (GEOS), their combination into reactions (RXNM &; ACTV), available reference values for reactions (BIND), and brief comments; for reagents and reactions (TAGL). The journey from reagent geometries to; functional database.py file is largely automated, in a process described; below. Prepare geometry filesAssemble xyz files for all intended reagent systems in a directory.; Follow the rules below for best results. The filename for each xyz; file should be the name of the system. lowercase or MixedCase is; preferable (according to Sherrill lab convention). Avoid dashes and; dots in the name as python won’t allow them. If you’re determ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/quickadddatabase.html:1103,energy,energy,1103,psi4manual/1.8.x/quickadddatabase.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/quickadddatabase.html,1,['energy'],['energy']
Energy Efficiency,"ation. Index. modules    .    .    .    .  · ; 1.9.1;  · . PSI4. Customization: Adding Simple Extensions; Creating a Database. Creating a Database¶. Note; No recompile of the PSI program is necessary for changes made to; files in $PSIDATADIR, including those described below. A necessary consideration in constructing a database is the distinction; between reagents and reactions. A reagent is a single molecular system; (may be a dimer) whose geometry you are possession of and whose electronic; energy may be of interest. A reaction is a combination of one or more; reagent energies whose value you are interested in and a reference value; for which you may or may not be in possession of. A few examples follow.; In a database of interaction energies, the reagents are dimers and their; component monomers (usually derived from the dimer geometry), and the; reactions are the dimer less monomers energies. In a database of barrier; heights, the reagents are reactants, products, and transition-state; structures, and the reactions are the transition-states less; minimum-energy structures. Possibly you may have a collection of; structures to simply be acted upon in parallel, in which case the; structures are both the reagents and the reactions. The role of the; database.py file is to collect arrays and dictionaries that define the; geometries of reagents (GEOS), their combination into reactions (RXNM &; ACTV), available reference values for reactions (BIND), and brief comments; for reagents and reactions (TAGL). The journey from reagent geometries to; functional database.py file is largely automated, in a process described; below. Prepare geometry filesAssemble xyz files for all intended reagent systems in a directory.; Follow the rules below for best results. The filename for each xyz; file should be the name of the system. lowercase or MixedCase is; preferable (according to Sherrill lab convention). Avoid dashes and; dots in the name as python won’t allow them. If you’re determ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/quickadddatabase.html:1103,energy,energy,1103,psi4manual/1.9.x/quickadddatabase.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/quickadddatabase.html,1,['energy'],['energy']
Energy Efficiency,"ation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta3] » . A PSI4 Tutorial¶. Basic Input File Structure¶; PSI4 reads input from a text file, which can be prepared in any standard; text editor. The default input file name is input.dat and the; default output file name is output.dat. So that you can give your; files meaningful names, these defaults can be changed by specifying; the input file name and output file name on the the command line.; The syntax is:; >>> psi4 input-name output-name. Running a Basic Hartree–Fock Calculation¶; In our first example, we will consider a Hartree–Fock SCF computation; for the water molecule using a cc-pVDZ basis set. We will specify the; geometry of our water molecule using a standard Z-matrix.; # Any line starting with the # character is a comment line; #! Sample HF/cc-pVDZ H2O computation. memory 250 mb. molecule h2o {; O ; H 1 0.96; H 1 0.96 2 104.5; }. set basis cc-pVDZ; energy('scf'). For your convenience, this example can be found in; tu1-h2o-energy.; You can run it if you wish.; Once PSI4 is in your path (see the User Configuration; section of the installation instructions), you can run this computation by typing; >>> psi4 input.dat output.dat. If everything goes well, the computation should complete and should report; a final restricted Hartree–Fock energy in a section like this:; Energy converged. @RHF Final Energy: -76.02663273410671. By default, the energy should be converged to about , so agreement; is only expected for about the first 6 digits after the decimal. If the; computation does not complete, there is probably a problem with the; compilation or installation of the program (see the installation; instructions in Sec. Compiling and Installing).; This very simple input is sufficient to run the requested information.; Notice that we didn’t tell the program some otherwise useful information; like the charge on the molecule (0, it’s neutral), the spin multiplicity; (1 for a closed-shell mo",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/tutorial-1.html:1069,energy,energy,1069,psi4manual/4.0b3/tutorial-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/tutorial-1.html,2,['energy'],['energy']
Energy Efficiency,"ation. S(self); Returns the One-electron Overlap Matrix. alpha_orbital_space(self, id, basis, subset); Creates OrbitalSpace with information about the requested alpha orbital space. aotoso(self); Returns the Atomic Orbital to Symmetry Orbital transformer. array_variable(self, arg0); Returns copy of the requested (case-insensitive) Matrix QC variable. array_variables(self); Returns the dictionary of all Matrix QC variables. arrays(). Deprecated since version 1.4. atomic_point_charges(self); Returns the set atomic point charges. basis_projection(self, arg0, arg1, arg2, arg3); Projects a orbital matrix from one basis to another. basisset(self); Returns the current orbital basis. beta_orbital_space(self, arg0, arg1, arg2); docstring. build(mol[, basis, quiet]); Build a wavefunction from minimal inputs, molecule and basis set. c1_deep_copy(self, basis); Returns a new wavefunction with internal data converted to \(C_1\) symmetry, using pre-c1-constructed basis. compute_energy(self); Computes the energy of the Wavefunction. compute_gradient(self); Computes the gradient of the Wavefunction. compute_hessian(self); Computes the Hessian of the Wavefunction. deep_copy(self, arg0); Deep copies the internal data. del_array_variable(self, arg0); Removes the requested (case-insensitive) Matrix QC variable. del_potential_variable(self, arg0); Removes the requested (case-insensitive) ExternalPotential QC variable. del_scalar_variable(self, arg0); Removes the requested (case-insensitive) double QC variable. del_variable(key); Removes scalar or array QCVariable key from self if present. doccpi(self[, assume_socc_alpha]); Returns the number of doubly occupied orbitals per irrep. efzc(self); Returns the frozen-core energy. energy(self); Returns the Wavefunction's energy. epsilon_a(self); Returns the Alpha Eigenvalues. epsilon_a_subset(self, basis, subset); Returns the requested Alpha orbital energies subset. epsilon_b(self); Returns the Beta Eigenvalues. epsilon_b_subset(self, basis, subs",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/api/psi4.core.Wavefunction.html:2041,energy,energy,2041,psi4manual/1.7.x/api/psi4.core.Wavefunction.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.Wavefunction.html,6,['energy'],['energy']
Energy Efficiency,"ation. cdomp2-2; OMP2 cc-pVDZ energy for the NO molecule. cc13; UHF-CCSD/cc-pVDZ \(^{3}B_1\) CH2 geometry optimization via analytic gradients. casscf-sp; CASSCF/6-31G** energy point. cc13a; UHF-CCSD(T)/cc-pVDZ \(^{3}B_1\) CH2 geometry optimization via analytic gradients. cbs-xtpl-func; optimization with method defined via cbs. omp3-2; OMP3 cc-pCVDZ energy with ROHF initial guess for the NO radical. dfmp2-fc; Kr–Kr nocp energies with all-electron basis set to check frozen core. scf-occ; force occupations in scf. cdoremp-energy2; density fitted OO-REMP/cc-pVDZ engrad single points for the H2O+ molecule. dft-b2plyp; Double-hybrid density functional B2PYLP. Reproduces portion of Table I in S. Grimme’s J. Chem. Phys 124 034108 (2006) paper defining the functional. cc5; RHF CCSD(T) cc-pVDZ frozen-core energy of C4NH4 Anion. aediis-2; EDIIS test case from 10.1063/1.1470195. sapt7; SAPT0 open-shell computation of H2O-HO2 interaction energy First with cc-pVDZ and density fitted integrals with UHF Then with 6-31g and direct integrals, except for dispersion that is computed with cc-pVDZ-ri density fitting with UHF. isapt2; This is a shorter version if isapt1 - does not do cube plots. See isapt1 for full details. dfccsd1; DF-CCSD cc-pVDZ energy for the H2O molecule. nbody-freq; Vibrational and thermo analysis of water trimer (geometry from J. Chem. Theory Comput. 11, 2126-2136 (2015)). fci-coverage; 6-31G H2O Test for coverage. dlpnomp2-1; comparison of DF-MP2 and DLPNO-MP2. opt5; 6-31G** UHF CH2 3B1 optimization. Uses a Z-Matrix with dummy atoms, just for demo and testing purposes. dfmp2-ecp; Ne-Xe dimer MP2 energies with ECP, with electrons correlated then frozen. sapt-exch-ind-inf; SAPT(DFT) aug-cc-pVDZ interaction energy between Ne and Ar atoms. mbis-4; MBIS calculation on NaCl. cisd-opt-fd; H2O CISD/6-31G** Optimize Geometry by Energies. dfmp2-grad2; DF-MP2 cc-pVDZ gradient for the NO molecule. dfomp3-grad1; DF-OMP3 cc-pVDZ gradients for the H2O molecule. dfomp2-3; OMP2 cc",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/autodoc_testsuite_corepsi4.html:35283,energy,energy,35283,psi4manual/master/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/master/autodoc_testsuite_corepsi4.html,2,['energy'],['energy']
Energy Efficiency,"ation. index. modules |. next |. previous |; PSI4 [beta2] » ; Theoretical Methods: SCF to FCI ». Hartree–Fock Theory¶; Code author: Justin M. Turney, Robert M. Parrish, and Andrew C. Simmonett; Section author: Robert M. Parrish; Module: Keywords, PSI Variables, LIBSCF_SOLVER, LIBMINTS, LIBFOCK, LIBDIIS. Introduction¶; Self-Consistent-Field (SCF) theory forms the cornerstone of ab initio quantum; chemistry. Here SCF refers both to conventional Hartree–Fock (HF) molecular; orbital theory and also to generalized Kohn–Sham Density Functional Theory; (KS-DFT). PSI4 contains a wholly rewritten SCF code, including many of the; most popular spin specializations, several efficient numerical methods for; treating Fock Matrix construction, and a brand new KS-DFT code featuring many of; the most popular DFT functional technologies.; An illustrative example of using the SCF module is as follows:; molecule {; 0 3; O; O 1 1.21; }. set {; basis cc-pvdz; guess sad; reference uhf; scf_type pk; }. energy('scf'). This will run a UHF computation for triplet molecular oxygen (the ground state); using a PK algorithm for the Electron Repulsion Integrals (ERI) and starting; from a Superposition of Atomic Densities (SAD) guess. After printing all manner; of titles, geometries, sizings, and algorithm choices, the SCF finally reaches; the iterations:; Total Energy Delta E Density RMS. @UHF iter 0: -149.76856421865352 -4.69109e+01 0.00000e+00; @UHF iter 1: -149.59793338958522 1.70631e-01 5.72371e-02; @UHF iter 2: -149.62408782458331 -2.61544e-02 8.04195e-03 DIIS; @UHF iter 3: -149.62679515182390 -2.70733e-03 2.51542e-03 DIIS; @UHF iter 4: -149.62726459105770 -4.69439e-04 1.06897e-03 DIIS; @UHF iter 5: -149.62730549814114 -4.09071e-05 2.70311e-04 DIIS; @UHF iter 6: -149.62730736371790 -1.86558e-06 5.94924e-05 DIIS; @UHF iter 7: -149.62730740227752 -3.85596e-08 9.93250e-06 DIIS; @UHF iter 8: -149.62730740325136 -9.73841e-10 1.88088e-06 DIIS; @UHF iter 9: -149.62730740326214 -1.07718e-11 1.80706e-0",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/scf-1.html:1052,energy,energy,1052,psi4manual/4.0b2/scf-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/scf-1.html,2,['energy'],['energy']
Energy Efficiency,"ation.; #! Sample UHF/6-31G** CH2 computation. molecule ch2 {; 0 3; C ; H 1 R; H 1 R 2 A. R = 1.075; A = 133.93; }. set basis 6-31G**; set reference uhf; energy ('scf'). This sample input can be found in; tu2-ch2-energy and as; before it can be run through the command psi4 input.dat output.dat; (actually, because psi4 by default looks for an input file named; input.dat and writes by default to a file called output.dat, in this; case one could also just type psi4). If it works, it should print; the final energy as; 1@UHF Final Energy: -38.92533462456894. Notice we added a new keyword, set reference uhf, to the input. For; open-shell molecules, we have a choice of unrestricted orbitals; (unrestricted Hartree–Fock, or UHF), or restricted orbitals (restricted; open-shell Hartree–Fock, or ROHF). Usually, UHF is a little easier to; converge (although it may be more susceptible to spin contamination than; ROHF). Geometry Optimization and Vibrational Frequency Analysis¶; The above examples were simple single-point energy computations; (as specified by the energy() function). Of course there are other; kinds of computations to perform, such as geometry optimizations and; vibrational frequency computations. These can be specified by replacing; energy() with optimize() or frequency(), respectively.; Here’s an example of optimizing the H2O molecule using Hartree–Fock with; a cc-pVDZ basis set (located in; tu3-h2o-opt).; #! Optimize H2O HF/cc-pVDZ. molecule h2o {; O ; H 1 0.96; H 1 0.96 2 104.5; }. set basis cc-pVDZ; optimize('scf'). This should perform a series of gradient computations. The gradient points; which way is downhill in energy, and the optimizer then modifies the; geometry to follow the gradient. After a few cycles, the geometry should; converge with a message like Optimization is complete!. As indicated; in the following table (printed by the optimizer at the end of the; computation and grep-able with ~), the energy decreases with each step,; and the maximum force o",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/tutorial-1.html:5507,energy,energy,5507,psi4manual/1.1.0/tutorial-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/tutorial-1.html,12,['energy'],['energy']
Energy Efficiency,"ation; of FOLLOW_STEP_SCALE is recommended over increasing MAX_ATTEMPTS. Note; Setting the option STABILITY_ANALYSIS to FOLLOW is only avalible for UHF. When using; RHF and ROHF instabilities can be checked, but not followed. If you want to attempt to find a lower energy solution; you should re-run the calculation with REFERENCE set to UHF. The main algorithm available in PSI4 is the Direct Inversion algorithm. It can only; work with SCF_TYPE PK, and it explicitly builds the full electronic Hessian; matrix before explicitly inverting it. As such, this algorithm is very slow and it should; be avoided whenever possible. Direct Inversion is automatically invoked if the newer algorithm; is not available.; The Davidson algorithm for stability analysis was implemented recently.; Only the lowest eigenvalues of the electronic Hessian are computed, and Hessian-vector; products are computed instead of the full Hessian. This algorithm is thus; much more efficient than the Direct Inversion, but at present, it is only available for UHF \(\rightarrow\) UHF stability; analysis. The capabilities of both algorithms are summarized below:. Stability analysis methods available in PSI4¶. Algorithm; REFERENCE; Stability checked; STABILITY_ANALYSIS; SCF_TYPE. Direct Inversion; RHF; Internal, External (\(\rightarrow\) UHF); CHECK; PK only. ROHF; Internal; CHECK; PK only. Davidson; UHF; Internal; CHECK or FOLLOW; Anything. The best algorithm is automatically selected, i.e. Davidson for UHF \(\rightarrow\) UHF and Direct Inversion otherwise.; In addition to the options available for Direct Inversion, the Davidson algorithm can automatically; adapt FOLLOW_STEP_SCALE to find a new SCF minimum. If MAX_ATTEMPTS > 1, additional attempts; will automatically increment FOLLOW_STEP_SCALE by 0.2 every time the SCF falls back to the previously; found unstable minimum. The increment can be adjusted by setting FOLLOW_STEP_INCREMENT.; The default value is 0.2; adjust if needed to try different values of FO",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/scf-1.html:30138,efficient,efficient,30138,psi4manual/1.2.1/scf-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/scf-1.html,13,['efficient'],['efficient']
Energy Efficiency,"ation?. Type: boolean; Default: true. DO_DIIS (OCC)¶OCC — Do apply DIIS extrapolation?. Type: boolean; Default: true. DO_DISP_EXCH_SINF (SAPT)¶SAPT (Expert) — For SAPT0 or SAPT(DFT), compute the non-approximated second-order exchange-dispersion term. Type: boolean; Default: false. DO_IND30_EXCH_SINF (SAPT)¶SAPT (Expert) — For SAPT2+3, compute the non-approximated third-order exchange-induction term. Type: boolean; Default: false. DO_IND_EXCH_SINF (SAPT)¶SAPT (Expert) — For SAPT0 or SAPT(DFT), compute the non-approximated second-order exchange-induction term. Type: boolean; Default: false. DO_LEVEL_SHIFT (DFOCC)¶DFOCC — Do apply level shifting?. Type: boolean; Default: true. DO_LEVEL_SHIFT (OCC)¶OCC — Removed in 1.4. Will raise an error in 1.5. Type: boolean; Default: true. DO_MBPT_DISP (SAPT)¶SAPT (Expert) — Do MBPT dispersion correction in SAPT2+, SAPT2+(3) or SAPT2+3, if also doing CCD?. Type: boolean; Default: true. DO_SCS (DFOCC)¶DFOCC — Do perform spin-component-scaled OMP2 (SCS-OMP2)? In all computation, SCS-OMP2 energy is computed automatically. However, in order to perform geometry optimizations and frequency computations with SCS-OMP2, one needs to set ‘DO_SCS’ to true. Type: boolean; Default: false. DO_SCS (OCC)¶OCC — Removed in 1.4. Will raise an error in 1.5. Pass the method name, like scs-mp2, to energy instead. Type: boolean; Default: false. DO_SOS (DFOCC)¶DFOCC — Do perform spin-opposite-scaled OMP2 (SOS-OMP2)? In all computation, SOS-OMP2 energy is computed automatically. However, in order to perform geometry optimizations and frequency computations with SOS-OMP2, one needs to set ‘DO_SOS’ to true. Type: boolean; Default: false. DO_SOS (OCC)¶OCC — Removed in 1.4. Will raise an error in 1.5. Pass the method name, like scs-mp2, to energy instead. Type: boolean; Default: false. DO_THIRD_ORDER (SAPT)¶SAPT (Expert) — Do compute third-order corrections?. Type: boolean; Default: false. DOCC (GLOBALS)¶GLOBALS — An array containing the number of doubly-occupi",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/autodoc_glossary_options_c.html:119278,energy,energy,119278,psi4manual/1.7.x/autodoc_glossary_options_c.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/autodoc_glossary_options_c.html,4,['energy'],['energy']
Energy Efficiency,"ations alike SAD, see; [Lehtola:2019:1593]. This variant employs an updated rule for the; generalized Wolfsberg-Helmholz formula from [Ammeter:1978:3686]. READRead the previous orbitals from a wfn file, casting from; one basis to another if needed. Useful for starting anion; computations from neutral orbitals, or after small geometry; changes. At present, casting from a different molecular point; group is not supported. This becomes the default for the second; and later iterations of geometry optimizations. SAPSuperposition of Atomic Potentials. This is essentially a; modification of the core Hamiltonian, which includes screening; effects by using a radially screened effective atomic charge. The; screening effects have been calculated at the complete basis set; limit with finite-element calculations, see [Lehtola:2019:25945]; and [Lehtola:2020:012516]. The guess and its implementation have; been described in [Lehtola:2019:1593]. The guess is evaluated on a; DFT quadrature grid, so the guess energy depends slightly on the; used DFT quadrature. The current implementation is based on; exchange-only local density calculations that are but nanohartree; away from the complete basis set limit [Lehtola:2020:012516]. SAPGAUSuperposition of Atomic Potentials, but using error function based; fits to the atomic radial potentials as discussed in; [Lehtola:2020:144105]. The main difference to the SAP guess; discussed above [Lehtola:2019:25945] is that the SAPGAU scheme is; analytic, and can be efficiently formed in terms of three-center; two-electron integrals [Lehtola:2020:144105]. The potential in; the SAPGAU scheme is passed with the SAPGAU_BASIS; keyword. The default potential is given by the large fit to the; HelFEM potential, sap_helfem_large, described in; [Lehtola:2020:144105]. Note that this guess is known in the DIRAC; program as .SCRPOT and in the ERKALE program as SAPFIT. These are all set by the GUESS keyword. Also, an automatic Python; procedure has been developed f",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/scf.html:19107,energy,energy,19107,psi4manual/1.9.x/scf.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/scf.html,2,['energy'],['energy']
Energy Efficiency,"ations and delta corrections and condense the; components into a minimum number of calculations. Aliases:cbs(). Returns:(float) – Total electronic energy in Hartrees. PSI variables:. CBS TOTAL ENERGY; CBS REFERENCE ENERGY; CBS CORRELATION ENERGY; CURRENT ENERGY; CURRENT REFERENCE ENERGY; CURRENT CORRELATION ENERGY. Caution; Some features are not yet implemented. Buy a developer a coffee. No way to tell function to boost fitting basis size for all calculations.; No way to extrapolate def2 family basis sets; Need to add more extrapolation schemes. As represented in the equation below, a CBS energy method is defined in several; sequential stages (scf, corl, delta, delta2, delta3, delta4, delta5) covering treatment; of the reference total energy, the correlation energy, a delta correction to the; correlation energy, and a second delta correction, etc.. Each is activated by its; stage_wfn keyword and is only allowed if all preceding stages are active. Here, is an energy or energy extrapolation scheme, and the following also hold. A translation of this ungainly equation to example [5] below is as; follows. In words, this is a double- and triple-zeta 2-point; Helgaker-extrapolated CCSD(T) coupled-cluster correlation correction; appended to a triple- and quadruple-zeta 2-point; Helgaker-extrapolated MP2 correlation energy appended to a SCF/aug-cc-pVQZ; reference energy. Energy Methods; The presence of a stage_wfn keyword is the indicator to incorporate; (and check for stage_basis and stage_scheme keywords) and compute; that stage in defining the CBS energy.; The cbs() function requires, at a minimum, name='scf' and scf_basis; keywords to be specified for reference-step only jobs and name and; corl_basis keywords for correlated jobs.; The following energy methods have been set up for cbs(). scf; mp2; mp2.5; mp3; mp4(sdq); mp4; mpn; omp2. omp2.5; omp3; olccd; lccd; lccsd; cepa(0); cepa(1); cepa(3). acpf; aqcc; qcisd; cc2; ccsd; fno-ccsd; bccd. cc3; qcisd(t); ccsd(t); fno-ccsd",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/cbs-1.html:1716,energy,energy,1716,psi4manual/1.0.0/cbs-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/cbs-1.html,4,['energy'],['energy']
Energy Efficiency,"ations that are; performed as part of the SAPT. We can specify that with; scf_type DF.; Density fitting procedures require the use of auxiliary basis sets that; pair with the primary basis set. Fortunately, PSI4 is usually smart; enough to figure out what auxiliary basis sets are needed for a given; computation. In this case, jun-cc-pVDZ is a standard enough basis set; (just a simple truncation of the very popular aug-cc-pVDZ basis set); that PSI4 correctly guesses that we want the jun-cc-pVDZ-JKFIT; auxiliary basis for the Hartree–Fock, and the jun-cc-pVDZ-RI basis set; for the SAPT procedure.; To speed up the computation a little, we also tell the SAPT procedure to; freeze the core electrons with freeze_core True. The SAPT; procedure is invoked with the simple call, energy('sapt0'). This; call knows to automatically run two monomer computations and a dimer; computation and then use these results to perform the SAPT analysis. The; various energy components are printed at the end of the output, in addition; to the total SAPT0 interaction energy. An explanation of the various; energy components can be found in the review by Jeziorski, Moszynski, and; Szalewicz [Jeziorski:1994:1887], and this is discussed in more detail; in the SAPT section later in this manual. For now, we’ll note that most of; the SAPT energy components are negative; this means those are attractive; contributions (the zero of energy in a SAPT computation is defined as; non-interacting monomers). The exchange contributions are positive; (repulsive). In this example, the most attractive contribution between; ethylene and acetylene is an electrostatic term of -2.12 kcal mol-1; (Elst10,r where the 1 indicates the first-order; perturbation theory result with respect to the intermolecular interaction,; and the 0 indicates zeroth-order with respect to intramolecular electron; correlation). The next most attractive contribution is the Disp20; term (2nd order intermolecular dispersion, which looks like an MP2",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/tutorial-1.html:13779,energy,energy,13779,psi4manual/1.1.0/tutorial-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/tutorial-1.html,42,['energy'],['energy']
Energy Efficiency,"ations that are; performed as part of the SAPT. We can specify that with; scf_type DF.; Density fitting procedures require the use of auxiliary basis sets that; pair with the primary basis set. Fortunately, Psi4 is usually smart; enough to figure out what auxiliary basis sets are needed for a given; computation. In this case, jun-cc-pVDZ is a standard enough basis set; (just a simple truncation of the very popular aug-cc-pVDZ basis set); that Psi4 correctly guesses that we want the jun-cc-pVDZ-JKFIT; auxiliary basis for the Hartree–Fock, and the jun-cc-pVDZ-RI basis set; for the SAPT procedure.; To speed up the computation a little, we also tell the SAPT procedure to; freeze the core electrons with freeze_core True. The SAPT; procedure is invoked with the simple call, energy('sapt0'). This; call knows to automatically run two monomer computations and a dimer; computation and then use these results to perform the SAPT analysis. The; various energy components are printed at the end of the output, in addition; to the total SAPT0 interaction energy. An explanation of the various; energy components can be found in the review by Jeziorski, Moszynski, and; Szalewicz [Jeziorski:1994:1887], and this is discussed in more detail; in the SAPT section later in this manual. For now, we’ll note that most of; the SAPT energy components are negative; this means those are attractive; contributions (the zero of energy in a SAPT computation is defined as; non-interacting monomers). The exchange contributions are positive; (repulsive). In this example, the most attractive contribution between; ethylene and acetylene is an electrostatic term of -2.12 kcal mol-1; (Elst10,r where the 1 indicates the first-order; perturbation theory result with respect to the intermolecular interaction,; and the 0 indicates zeroth-order with respect to intramolecular electron; correlation). The next most attractive contribution is the Disp20; term (2nd order intermolecular dispersion, which looks like an MP2",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/tutorial-1.html:13039,energy,energy,13039,psi4manual/1.0.0/tutorial-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/tutorial-1.html,4,['energy'],['energy']
Energy Efficiency,"ations to existing methods. """"""; import re; import os; import math; import warnings; import psi4; import p4util; from driver import *; from wrappers import *; #from extend_Molecule import *; from molutil import *. # Python procedures like these can be run directly from the input file or integrated; # with the energy(), etc. routines by means of lines like those at the end of this file. [docs]def sherrill_gold_standard(name='mp2', **kwargs):; r""""""Function to call the quantum chemical method known as 'Gold Standard'; in the Sherrill group. Uses :py:func:`~wrappers.complete_basis_set` to evaluate; the following expression. Two-point extrapolation of the correlation energy; performed according to :py:func:`~wrappers.corl_xtpl_helgaker_2`. .. math:: E_{total}^{\text{Au\_std}} = E_{total,\; \text{SCF}}^{\text{aug-cc-pVQZ}} \; + E_{corl,\; \text{MP2}}^{\text{aug-cc-pV[TQ]Z}} \; + \delta_{\text{MP2}}^{\text{CCSD(T)}}\big\vert_{\text{aug-cc-pVTZ}}. >>> # [1] single-point energy by this composite method; >>> energy('sherrill_gold_standard'). >>> # [2] finite-difference geometry optimization; >>> optimize('sherrill_gold_standard'). >>> # [3] finite-difference geometry optimization, overwriting some pre-defined sherrill_gold_standard options; >>> optimize('sherrill_gold_standard', corl_basis='cc-pV[DT]Z', delta_basis='3-21g'). """"""; lowername = name.lower(); kwargs = p4util.kwargs_lower(kwargs). if not ('func_cbs' in kwargs):; kwargs['func_cbs'] = energy. if not ('scf_basis' in kwargs):; kwargs['scf_basis'] = 'aug-cc-pVQZ'; if not ('scf_scheme' in kwargs):; kwargs['scf_scheme'] = highest_1. if not ('corl_wfn' in kwargs):; kwargs['corl_wfn'] = 'mp2'; name = 'mp2'; if not ('corl_basis' in kwargs):; kwargs['corl_basis'] = 'aug-cc-pV[TQ]Z'; if not ('corl_scheme' in kwargs):; kwargs['corl_scheme'] = corl_xtpl_helgaker_2. if not ('delta_wfn' in kwargs):; kwargs['delta_wfn'] = 'ccsd(t)'; if not ('delta_wfn_lesser' in kwargs):; kwargs['delta_wfn_lesser'] = 'mp2'; if not ('delta_basis' i",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/aliases.html:2154,energy,energy,2154,psi4manual/4.0b5/_modules/aliases.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/aliases.html,4,['energy'],['energy']
Energy Efficiency,"ations_projection_sound, rotations_projection_sound = _energy_is_invariant(G0); core.print_out(; '\n Based on options and gradient (rms={:.2E}), recommend {}projecting translations and {}projecting rotations.\n'; .format(G0.rms(), '' if translations_projection_sound else 'not ',; '' if rotations_projection_sound else 'not ')); if not core.has_option_changed('FINDIF', 'FD_PROJECT'):; core.set_local_option('FINDIF', 'FD_PROJECT', rotations_projection_sound). # Does an analytic procedure exist for the requested method?; if dertype == 2:; core.print_out(""""""hessian() will perform analytic frequency computation.\n""""""). # We have the desired method. Do it.; wfn = procedures['hessian'][lowername](lowername, molecule=molecule, **kwargs); wfn.set_gradient(G0); optstash.restore(); optstash_conv.restore(). # TODO: check that current energy's being set to the right figure when this code is actually used; core.set_variable('CURRENT ENERGY', wfn.energy()); wfn.set_variable('CURRENT ENERGY', wfn.energy()). elif dertype == 1:; core.print_out(; """"""hessian() will perform frequency computation by finite difference of analytic gradients.\n""""""). # Obtain list of displacements; findif_meta_dict = driver_findif.hessian_from_gradients_geometries(molecule, irrep). # Record undisplaced symmetry for projection of displaced point groups; core.set_global_option(""PARENT_SYMMETRY"", molecule.schoenflies_symbol()). ndisp = len(findif_meta_dict[""displacements""]) + 1. print("""""" %d displacements needed."""""" % ndisp). wfn = _process_displacement(gradient, lowername, molecule, findif_meta_dict[""reference""], 1, ndisp,; **kwargs); var_dict = core.variables(); # ensure displacement calculations do not use restart_file orbitals.; kwargs.pop('restart_file', None). for n, displacement in enumerate(findif_meta_dict[""displacements""].values(), start=2):; _process_displacement(; gradient, lowername, molecule, displacement, n, ndisp, write_orbitals=False, **kwargs). # Reset variables; for key, val in var_dict.items(",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:78606,energy,energy,78606,psi4manual/1.4.0/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html,4,['energy'],['energy']
Energy Efficiency,"atom(N5boost10shared_ptrIN3psi6MatrixEEE,i,i,i,d). psi4.dmrg()¶; Python Library Documentation: built-in function dmrg in module psi4; dmrg(...). dmrg( (Wavefunction)arg1) -> Wavefunction :. Runs the DMRG code.; C++ signature :. N5boost10shared_ptrIN3psi12WavefunctionEEE dmrg(N5boost10shared_ptrIN3psi12WavefunctionEEE). psi4.efp_init()¶; Python Library Documentation: built-in function efp_init in module psi4; efp_init(...). efp_init() -> EFP :. Initializes the EFP library and returns an EFP object.; C++ signature :. N5boost10shared_ptrIN3psi3efp3EFPEEE efp_init(). psi4.efp_set_options()¶; Python Library Documentation: built-in function efp_set_options in module psi4; efp_set_options(...). efp_set_options() -> None :. Set EFP options from environment options object.; C++ signature :. void efp_set_options(). psi4.fd_1_0()¶; Python Library Documentation: built-in function fd_1_0 in module psi4; fd_1_0(...). fd_1_0( (Molecule)arg1, (list)arg2) -> Matrix :. Performs a finite difference gradient computation, from energy points.; C++ signature :. N5boost10shared_ptrIN3psi6MatrixEEE fd_1_0(N5boost10shared_ptrIN3psi8MoleculeEEE,N5boost6python4listE). psi4.fd_freq_0()¶; Python Library Documentation: built-in function fd_freq_0 in module psi4; fd_freq_0(...). fd_freq_0( (Molecule)arg1, (list)arg2, (int)arg3) -> Matrix :. Performs a finite difference frequency computation, from energy points, for a given irrep.; C++ signature :. N5boost10shared_ptrIN3psi6MatrixEEE fd_freq_0(N5boost10shared_ptrIN3psi8MoleculeEEE,N5boost6python4listE,i). psi4.fd_freq_1()¶; Python Library Documentation: built-in function fd_freq_1 in module psi4; fd_freq_1(...). fd_freq_1( (Molecule)arg1, (list)arg2, (int)arg3) -> Matrix :. Performs a finite difference frequency computation, from gradients, for a given irrep.; C++ signature :. N5boost10shared_ptrIN3psi6MatrixEEE fd_freq_1(N5boost10shared_ptrIN3psi8MoleculeEEE,N5boost6python4listE,i). psi4.fd_geoms_1_0()¶; Python Library Documentation: built-in funct",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html:21313,energy,energy,21313,psi4manual/1.0.0/autodoc_psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html,2,['energy'],['energy']
Energy Efficiency,"atom:; raise ValidationError(""Error on geometry input line %s. Atom %s has not been defined yet.\n"" % (line, entries[1])); aTo = self.get_anchor_atom(entries[3], line); if aTo >= iatom:; raise ValidationError(""Error on geometry input line %s. Atom %s has not been defined yet.\n"" % (line, entries[3])); dTo = self.get_anchor_atom(entries[5], line); if dTo >= iatom:; raise ValidationError(""Error on geometry input line %s. Atom %s has not been defined yet.\n"" % (line, entries[5])); if aTo == rTo or rTo == dTo or aTo == dTo: # for you star wars fans; raise ValidationError(""Atom used multiple times on line %s"" % (line)). rval = self.get_coord_value(entries[2]); aval = self.get_coord_value(entries[4]); dval = self.get_coord_value(entries[6]). if self.full_atoms[rTo].symbol() == 'X':; rval.set_fixed(True); if self.full_atoms[aTo].symbol() == 'X':; aval.set_fixed(True); if self.full_atoms[dTo].symbol() == 'X':; dval.set_fixed(True). self.full_atoms.append(ZMatrixEntry(iatom, zVal, charge, \; el2masses[atomSym], atomSym, atomLabel, \; self.full_atoms[rTo], rval, \; self.full_atoms[aTo], aval, \; self.full_atoms[dTo], dval)). else:; raise ValidationError('Illegal geometry specification line : %s. \; You should provide either Z-Matrix or Cartesian input' % (line)). iatom += 1. self.fragments.append([tempfrag[0], tempfrag[-1]]); self.fragment_types.append('Real'). [docs] def init_with_checkpoint(self, chkpt):; """""" **NYI** Pull information from the *chkpt* object passed; (method name in libmints is init_with_chkpt). """"""; raise FeatureNotImplemented('Molecule::init_with_checkpoint') # FINAL. [docs] def init_with_io(self, psio):; """""" **NYI** Pull information from a chkpt object created from psio; (method name in libmints is init_with_psio). """"""; raise FeatureNotImplemented('Molecule::init_with_io') # FINAL. @classmethod; [docs] def init_with_xyz(cls, xyzfilename):; """"""Pull information from an XYZ file. No fragment or chg/mult info detected. >>> H2O = qcdb.Molecule.init_with_xyz('h2",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/_modules/qcdb/libmintsmolecule.html:19843,charge,charge,19843,psi4manual/4.0b3/_modules/qcdb/libmintsmolecule.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/_modules/qcdb/libmintsmolecule.html,4,['charge'],['charge']
Energy Efficiency,"atom:; raise ValidationError(""Error on geometry input line %s. Atom %s has not been defined yet.\n"" % (line, entries[1])); aTo = self.get_anchor_atom(entries[3], line); if aTo >= iatom:; raise ValidationError(""Error on geometry input line %s. Atom %s has not been defined yet.\n"" % (line, entries[3])); dTo = self.get_anchor_atom(entries[5], line); if dTo >= iatom:; raise ValidationError(""Error on geometry input line %s. Atom %s has not been defined yet.\n"" % (line, entries[5])); if aTo == rTo or rTo == dTo or aTo == dTo: # for you star wars fans; raise ValidationError(""Atom used multiple times on line %s"" % (line)). rval = self.get_coord_value(entries[2]); aval = self.get_coord_value(entries[4]); dval = self.get_coord_value(entries[6]). if self.full_atoms[rTo].symbol() == 'X':; rval.set_fixed(True); if self.full_atoms[aTo].symbol() == 'X':; aval.set_fixed(True); if self.full_atoms[dTo].symbol() == 'X':; dval.set_fixed(True). self.full_atoms.append(ZMatrixEntry(iatom, zVal, charge, \; el2masses[atomSym], atomSym, atomLabel, \; self.full_atoms[rTo], rval, \; self.full_atoms[aTo], aval, \; self.full_atoms[dTo], dval)). else:; raise ValidationError('Illegal geometry specification line : %s. \; You should provide either Z-Matrix or Cartesian input' % (line)). iatom += 1. self.fragments.append([tempfrag[0], tempfrag[-1]]); self.fragment_types.append('Real'); self.set_has_zmatrix(zmatrix). [docs] def init_with_checkpoint(self, chkpt):; """""" **NYI** Pull information from the *chkpt* object passed; (method name in libmints is init_with_chkpt). """"""; raise FeatureNotImplemented('Molecule::init_with_checkpoint') # FINAL. [docs] def init_with_io(self, psio):; """""" **NYI** Pull information from a chkpt object created from psio; (method name in libmints is init_with_psio). """"""; raise FeatureNotImplemented('Molecule::init_with_io') # FINAL. @classmethod; [docs] def init_with_xyz(cls, xyzfilename):; """"""Pull information from an XYZ file. No fragment or chg/mult info detected. >>> H2O = ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html:21146,charge,charge,21146,psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html,2,['charge'],['charge']
Energy Efficiency,"atomic densities (SAD) guess, using a highly distorted water geometry with a cc-pVDZ basis set. This is just a test of the code and the user need only specify guess=sad to the SCF module’s (or global) options in order to use a SAD guess. The test is first performed in C2v symmetry, and then in C1. pywrap-db3; Test that Python Molecule class processes geometry like psi4 Molecule class. casscf-sa-sp; Example of state-averaged CASSCF for the C2 molecule see C. D. Sherrill and P. Piecuch, J. Chem. Phys. 122, 124104 (2005). fsapt-terms; F-SAPT0/jun-cc-pvdz procedure for methane dimer. dct-grad1; Various DCT analytic gradients for the O2 molecule with 6-31G basis set. opt11; Transition-state optimizations of HOOH to both torsional transition states. tu3-h2o-opt; Optimize H2O HF/cc-pVDZ. scf-occ; force occupations in scf. cisd-h2o-clpse; 6-31G** H2O Test CISD Energy Point with subspace collapse. dfccsdt2; DF-CCSD(T) cc-pVDZ energy for the NH molecule. mcscf2; TCSCF cc-pVDZ energy of asymmetrically displaced ozone, with Z-matrix input. scf6; Tests RHF/ROHF/UHF SCF gradients. props3; DF-SCF cc-pVDZ multipole moments of benzene, up to 7th order and electrostatic potentials evaluated at the nuclear coordinates. linK-3; UHF and ROHF Linear Exchange Algorithm test for benzyl cation. opt1; SCF STO-3G geometry optimzation, with Z-matrix input. dft-b3lyp; Check flavors of B3LYP (b3lyp3/b3lyp5) against other programs. cc2; 6-31G** H2O CCSD optimization by energies, with Z-Matrix input. opt-irc-1; Compute the IRC for HOOH torsional rotation at the RHF/DZP level of theory. opt6; Various constrained energy minimizations of HOOH with cc-pvdz RHF Internal-coordinate constraints in internal-coordinate optimizations. dft-freq-analytic; Analytic SVWN frequencies, compared to finite difference values. rasci-h2o; RASCI/6-31G** H2O Energy Point. dfomp3-grad2; DF-OMP3 cc-pVDZ gradients for the H2O+ cation. dfmp2-freq1; DF-MP2 frequency by difference of energies for H2O. dft-reference; MP2 with a",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/autodoc_testsuite_corepsi4.html:39239,energy,energy,39239,psi4manual/1.7.x/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/autodoc_testsuite_corepsi4.html,2,['energy'],['energy']
Energy Efficiency,"atomic point charges. basis_projection(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix, arg1: psi4.core.Dimension, arg2: psi4.core.BasisSet, arg3: psi4.core.BasisSet) → psi4.core.Matrix¶; Projects a orbital matrix from one basis to another. basisset(self: psi4.core.Wavefunction) → psi4.core.BasisSet¶; Returns the current orbital basis. beta_orbital_space(self: psi4.core.Wavefunction, arg0: str, arg1: str, arg2: str) → psi4.core.OrbitalSpace¶; docstring. static build(mol, basis=None, *, quiet=False)¶. Parameters; quiet (bool) – . c1_deep_copy(self: psi4.core.Wavefunction, basis: psi4.core.BasisSet) → psi4.core.Wavefunction¶; Returns a new wavefunction with internal data converted to \(C_1\) symmetry, using pre-c1-constructed basis. ci_nat_orbs(self: psi4.core.CIWavefunction) → None¶; docstring. cleanup_ci(self: psi4.core.CIWavefunction) → None¶; docstring. cleanup_dpd(self: psi4.core.CIWavefunction) → None¶; docstring. compute_energy(self: psi4.core.Wavefunction) → float¶; Computes the energy of the Wavefunction. compute_gradient(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Computes the gradient of the Wavefunction. compute_hessian(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Computes the Hessian of the Wavefunction. compute_state_transfer(self: psi4.core.CIWavefunction, arg0: psi4.core.CIVector, arg1: int, arg2: psi4.core.Matrix, arg3: psi4.core.CIVector) → None¶; docstring. deep_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; Deep copies the internal data. del_array_variable(self: psi4.core.Wavefunction, arg0: str) → int¶; Removes the requested (case-insensitive) Matrix QC variable. del_potential_variable(self: psi4.core.Wavefunction, arg0: str) → int¶; Removes the requested (case-insensitive) ExternalPotential QC variable. (This function is provisional and might be removed in the future.). del_scalar_variable(self: psi4.core.Wavefunction, arg0: str) → int¶; Removes the requested (case-insensitive) double QC variable. del_",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/api/psi4.core.CIWavefunction.html:14337,energy,energy,14337,psi4manual/1.6.x/api/psi4.core.CIWavefunction.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/api/psi4.core.CIWavefunction.html,2,['energy'],['energy']
Energy Efficiency,"atoms to use for reference points in interfragment coordinates. Type: array; Default: No Default. FREEZE_ALL_DIHEDRALS (OPTKING)¶OPTKING — Freeze ALL dihedral angles. Type: boolean; Default: false. FREEZE_CORE (GLOBALS)¶GLOBALS — Specifies how many core orbitals to freeze in correlated computations. TRUE or 1 will default to freezing the previous noble gas shell on each atom. In case of positive charges on fragments, an additional shell may be unfrozen, to ensure there are valence electrons in each fragment. With FALSE or 0, no electrons are frozen (with the exception of electrons treated by an ECP). With -1, -2, and -3, the user might request strict freezing of the previous first/second/third noble gas shell on every atom. In this case, when there are no valence electrons, the code raises an exception. More precise control over the number of frozen orbitals can be attained by using the keywords NUM_FROZEN_DOCC (gives the total number of orbitals to freeze, program picks the lowest-energy orbitals) or FROZEN_DOCC (gives the number of orbitals to freeze per irreducible representation) or by the option POLICY in combination with appropriate inputs to FREEZE_CORE_POLICY. At present, POLICY is an experimental option and is subject to change. Type: string; Possible Values: FALSE, TRUE, 1, 0, -1, -2, -3, POLICY; Default: FALSE. FREEZE_CORE (SAPT)¶SAPT — The scope of core orbitals to freeze in evaluation of SAPT \(E_{disp}^{(20)}\) and \(E_{exch-disp}^{(20)}\) terms. Recommended true for all SAPT computations. Type: string; Possible Values: FALSE, TRUE; Default: FALSE. FREEZE_CORE_POLICY (GLOBALS)¶GLOBALS — NOTE: This is an experimental feature and subject to change! Specifies a custom frozen-core policy on a per-element basis. Input should be a list of integers representing the number of orbitals to freeze for each atomic number MINUS one (so H is 0, He is 1, etc). For example, to specify that elements H-Be should have 0 frozen orbitals, B-Mg should have 1, and Al should ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/autodoc_glossary_options_c.html:141223,energy,energy,141223,psi4manual/master/autodoc_glossary_options_c.html,https://psicode.org,https://psicode.org/psi4manual/master/autodoc_glossary_options_c.html,1,['energy'],['energy']
Energy Efficiency,atoms() LibmintsMolecule method. set_basis_by_label() LibmintsMolecule method. set_basis_by_number() LibmintsMolecule method. set_basis_by_symbol() LibmintsMolecule method. set_com_fixed() LibmintsMolecule method. set_coordinates() CartesianEntry method. ZMatrixEntry method. set_fixed() CoordValue method. set_full_geometry() LibmintsMolecule method. set_full_point_group() LibmintsMolecule method. set_geometry() LibmintsMolecule method. set_ghost_fragment() LibmintsMolecule method. set_ghost_fragments() LibmintsMolecule method. set_ghosted() CoordEntry method. set_memory() in module util. set_molecular_charge() LibmintsMolecule method. set_multiplicity() LibmintsMolecule method. set_name() LibmintsMolecule method. set_num_threads() in module util. set_point_group() LibmintsMolecule method. set_units() LibmintsMolecule method. set_variable() LibmintsMolecule method. setting; . keywords C-side. keywords cbs(). keywords cp(). keywords database(). keywords diatomic_anharmonicity(). keywords energy(). keywords molecule. keywords optimize(). keywords property(). SF_RESTRICT (DETCI). sherrillgroup_gold_standard() in module aliases. show() in module qcdb.vecutil. SIGMA_OVERLAP (DETCI). single-point. SINGLES_PRINT (CCEOM). SMALL_CUTOFF (PSIMRCC). SO_S_FILE (TRANSQT). SO_T_FILE (TRANSQT). SO_TEI_FILE (TRANSQT). SO_V_FILE (TRANSQT). SOCC (GLOBALS). (MCSCF). SOLVER_CONVERGENCE (CPHF). SOLVER_EXACT_DIAGONAL (CPHF). SOLVER_MAX_SUBSPACE (CPHF). SOLVER_MAXITER (CPHF). SOLVER_MIN_SUBSPACE (CPHF). SOLVER_N_GUESS (CPHF). SOLVER_N_ROOT (CPHF). SOLVER_NORM (CPHF). SOLVER_PRECONDITION (CPHF). SOLVER_PRECONDITION_MAXITER (CPHF). SOLVER_PRECONDITION_STEPS (CPHF). SOLVER_QUANTITY (CPHF). SOLVER_TYPE (CPHF). SORTED_TEI_FILE (TRANSQT). SOS_SCALE (OMP2). (OMP3). SOS_SCALE2 (OMP2). (OMP3). SOS_TYPE (OMP2). (OMP3). SPINADAPT_ENERGIES (CCENERGY). split_menial() in module wrappers. SS_E_CONVERGENCE (CCEOM). SS_R_CONVERGENCE (CCEOM). SS_SKIP_DIAG (CCEOM). SS_VECS_PER_ROOT (CCEOM). STABILITY_ADD_VECTO,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/genindex.html:40071,energy,energy,40071,psi4manual/4.0b3/genindex.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/genindex.html,1,['energy'],['energy']
Energy Efficiency,atoms() LibmintsMolecule method. set_basis_by_label() LibmintsMolecule method. set_basis_by_number() LibmintsMolecule method. set_basis_by_symbol() LibmintsMolecule method. set_com_fixed() LibmintsMolecule method. set_coordinates() CartesianEntry method. ZMatrixEntry method. set_fixed() CoordValue method. set_full_geometry() LibmintsMolecule method. set_full_point_group() LibmintsMolecule method. set_geometry() LibmintsMolecule method. set_ghost_fragment() LibmintsMolecule method. set_ghost_fragments() LibmintsMolecule method. set_ghosted() CoordEntry method. set_memory() in module util. set_molecular_charge() LibmintsMolecule method. set_multiplicity() LibmintsMolecule method. set_name() LibmintsMolecule method. set_num_threads() in module util. set_point_group() LibmintsMolecule method. set_units() LibmintsMolecule method. set_variable() LibmintsMolecule method. setting; . keywords C-side. keywords cbs(). keywords cp(). keywords database(). keywords diatomic_anharmonicity(). keywords energy(). keywords molecule. keywords optimize(). keywords property(). SF_RESTRICT (DETCI). sherrillgroup_gold_standard() in module aliases. show() in module qcdb.vecutil. SIGMA_OVERLAP (DETCI). single-point. SINGLES_PRINT (CCEOM). SMALL_CUTOFF (PSIMRCC). SO_S_FILE (TRANSQT). SO_T_FILE (TRANSQT). SO_TEI_FILE (TRANSQT). SO_V_FILE (TRANSQT). SOCC (GLOBALS). (MCSCF). SOLVER_CONVERGENCE (CPHF). SOLVER_EXACT_DIAGONAL (CPHF). SOLVER_MAX_SUBSPACE (CPHF). SOLVER_MAXITER (CPHF). SOLVER_MIN_SUBSPACE (CPHF). SOLVER_N_GUESS (CPHF). SOLVER_N_ROOT (CPHF). SOLVER_NORM (CPHF). SOLVER_PRECONDITION (CPHF). SOLVER_PRECONDITION_MAXITER (CPHF). SOLVER_PRECONDITION_STEPS (CPHF). SOLVER_QUANTITY (CPHF). SOLVER_TYPE (CPHF). SORTED_TEI_FILE (TRANSQT). SOS_TYPE (OCC). SPINADAPT_ENERGIES (CCENERGY). split_menial() in module wrappers. SS_E_CONVERGENCE (CCEOM). SS_R_CONVERGENCE (CCEOM). SS_SKIP_DIAG (CCEOM). SS_VECS_PER_ROOT (CCEOM). STABILITY_ADD_VECTORS (DCFT). STABILITY_ANALYSIS (SCF). STABILITY_AUGMENT_SPACE_T,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/genindex.html:42366,energy,energy,42366,psi4manual/4.0b4/genindex.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/genindex.html,1,['energy'],['energy']
Energy Efficiency,"atory behavior begins.; Damping [Off by Default]; In some cases, a static mixing of Fock Matrices from adjacent iterations can; quench oscillations. This mixing, known as “damping” can be activated by setting; the DAMPING_PERCENTAGE keyword to a nonzero percent.; SOSCF [Off by Default]; See Second-order Convergence. ERI Algorithms¶; The key difficulty in the SCF procedure is treatment of the four-index ERI; contributions to the Fock Matrix. A number of algorithms are available in; PSI4 for these terms. The algorithm is selected by the SCF_TYPE; keyword, which may be one of the following. PK [Default]; An out-of-core, presorted algorithm using exact ERIs. Quite fast for a; zero-error algorithm if enough memory is available. Integrals are; generated only once, and symmetry is utilized to reduce number of; integrals.; OUT_OF_CORE; An out-of-core, unsorted algorithm using exact ERIs. Overcomes the; memory bottleneck of the current PK algorithm. Integrals are generated; only once, and symmetry is utilized to reduce number of integrals.; DIRECT; A threaded, sieved, integral-direct algorithm, with full permutational; symmetry. This algorithm is brand new, but seems to be reasonably fast; up to 1500 basis functions, uses zero disk (if DF pre-iterations are; turned off), and can obtain significant; speedups with negligible error loss if INTS_TOLERANCE; is set to 1.0E-8 or so.; DF [Default]; A density-fitted algorithm designed for computations with thousands of; basis functions. This algorithm is highly optimized, and is threaded; with a mixture of parallel BLAS and OpenMP. Note that this algorithm; should use the -JKFIT series of auxiliary bases, not the -RI or; -MP2FIT bases. The default guess for auxiliary basis set should work; for most bases, otherwise the DF_BASIS_SCF keyword can; be used to manually specify the auxiliary basis. This algorithm is; preferred unless either absolute accuracy is required; [\(\gtrsim\)CCSD(T)] or a -JKFIT auxiliary basis is unavailable; for ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/scf-1.html:21073,reduce,reduce,21073,psi4manual/1.1.0/scf-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/scf-1.html,6,['reduce'],['reduce']
Energy Efficiency,"atrix (Potential + Kinetic) Integrals. Hd_vector(self: psi4.core.CIWavefunction, arg0: int) → psi::detci::CIvect; docstring. PCM_enabled(self: psi4.core.Wavefunction) → bool¶; Whether running a PCM calculation. S(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the One-electron Overlap Matrix. X(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Lagrangian Matrix. alpha_orbital_space(self: psi4.core.Wavefunction, arg0: str, arg1: str, arg2: str) → psi4.core.OrbitalSpace¶; docstring. aotoso(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Atomic Orbital to Symmetry Orbital transformer. array_variable(self: psi4.core.Wavefunction, arg0: str) → psi4.core.Matrix¶; Returns copy of the requested (case-insensitive) Matrix QC variable. array_variables(self: psi4.core.Wavefunction) → Dict[str, psi4.core.Matrix]¶; Returns the dictionary of all Matrix QC variables. arrays()¶. atomic_point_charges(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the set atomic point charges. basis_projection(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix, arg1: psi4.core.Dimension, arg2: psi4.core.BasisSet, arg3: psi4.core.BasisSet) → psi4.core.Matrix¶; Projects a orbital matrix from one basis to another. basisset(self: psi4.core.Wavefunction) → psi4.core.BasisSet¶; Returns the current orbital basis. beta_orbital_space(self: psi4.core.Wavefunction, arg0: str, arg1: str, arg2: str) → psi4.core.OrbitalSpace¶; docstring. static build(mol, basis=None)¶. c1_deep_copy(self: psi4.core.Wavefunction, basis: psi4.core.BasisSet) → psi4.core.Wavefunction¶; Returns a new wavefunction with internal data converted to C_1 symmetry, using pre-c1-constructed BasisSet basis. ci_nat_orbs(self: psi4.core.CIWavefunction) → None; docstring. cleanup_ci(self: psi4.core.CIWavefunction) → None; docstring. cleanup_dpd(self: psi4.core.CIWavefunction) → None; docstring. compute_energy(self: psi4.core.Wavefunction) → float¶; Computes the energy of the Wavefunction. compute_",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/api/psi4.core.ciwavefunction.html:6871,charge,charges,6871,psi4manual/1.3.2/api/psi4.core.ciwavefunction.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/api/psi4.core.ciwavefunction.html,1,['charge'],['charges']
Energy Efficiency,"atrix used in the DF-CCSD(T) procedure. The second; auxiliary set is used to approximate all other ERIs in the DF-CCSD(T); procedure. The choice of auxiliary basis is controlled by the keyword; DF_BASIS_CC. By default, DF_BASIS_CC is the RI set; (optimized for DFMP2) most appropriate for use with the primary basis.; For example, if the primary basis is aug-cc-pVDZ, the default; DF_BASIS_CC will be aug-cc-pVDZ-RI.; Alternatively, the user can request that the DF-CCSD(T) procedure use a; set of vectors defined by the Cholesky decomposition of the ERI tensor as; the auxiliary basis. This feature is enabled by specifying CC_TYPE CD.; CD methods can be enabled in the SCF; procedure as well, by specifying the SCF_TYPE as CD. The; accuracy of the decomposition can be controlled through the keyword; CHOLESKY_TOLERANCE.; The following input file sets up a DF-CCSD(T); computation using CD integrals; molecule h2o {; 0 1; O; H 1 1.0; H 1 1.0 2 104.5; }. set {; scf_type cd; cc_type cd; basis aug-cc-pvdz; freeze_core true; }; energy('ccsd(t)'). The resulting CCSD(T) correlation energy will be equivalent to that; obtained from a conventional computation if CHOLESKY_TOLERANCE is; sufficiently small (e.g. 1e-9). Gn theory¶; The FNOCC module contains all the components that comprise the Gn family; of composite methods. Currently, only the G2 method is supported; [Curtiss:1991:7221]. The G2 procedure may be called through the; energy() wrapper:; energy('gaussian-2'). Supported methods¶; The various methods supported by the FNOCC module in PSI4 are detailed; in Table FNOCC Methods. Note that these methods; are implemented for closed-shell references only. For open-shell references,; the calls energy('mp2.5'), energy('mp3'), and energy('mp4') will; default to implementations of these methods in other modules. name; calls method; type select. qcisd; quadratic configuration interaction singles doubles; CI_TYPE CONV. qcisd(t); qcisd with perturbative triples; CI_TYPE CONV. mp2.5; average of",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/fnocc-1.html:12131,energy,energy,12131,psi4manual/1.4.0/fnocc-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/fnocc-1.html,5,['energy'],['energy']
Energy Efficiency,"atrix used in the DF-CCSD(T) procedure. The second; auxiliary set is used to approximate all other ERIs in the DF-CCSD(T); procedure. The choice of auxiliary basis is controlled by the keyword; DF_BASIS_CC. By default, DF_BASIS_CC is the RI set; (optimized for DFMP2) most appropriate for use with the primary basis.; For example, if the primary basis is aug-cc-pVDZ, the default; DF_BASIS_CC will be aug-cc-pVDZ-RI.; Alternatively, the user can request that the DF-CCSD(T) procedure use a; set of vectors defined by the Cholesky decomposition of the ERI tensor as; the auxiliary basis. This feature is enabled by specifying CC_TYPE CD.; CD methods can be enabled in the SCF; procedure as well, by specifying the SCF_TYPE as CD. The; accuracy of the decomposition can be controlled through the keyword; CHOLESKY_TOLERANCE.; The following input file sets up a DF-CCSD(T); computation using CD integrals; molecule h2o {; 0 1; O; H 1 1.0; H 1 1.0 2 104.5; }. set {; scf_type cd; cc_type cd; basis aug-cc-pvdz; freeze_core true; }; energy('ccsd(t)'). The resulting CCSD(T) correlation energy will be equivalent to that; obtained from a conventional computation if CHOLESKY_TOLERANCE is; sufficiently small (e.g. 1e-9). Gn theory¶; The FNOCC module contains all the components that comprise the Gn family; of composite methods. Currently, only the G2 method is supported; [Curtiss:1991:7221]. The G2 procedure may be called through the; energy() wrapper:; energy('gaussian-2'). Supported methods¶; The various methods supported by the FNOCC module in PSI4 are; summarized in Table FNOCC Methods; and detailed (except FNO) in Table FNOCC Capabilities. Note that these methods are implemented; for closed-shell reference only. Without set qc_module fnocc,; these methods may default to implementations in other modules. Theoretical methods accessible through FNOCC¶. name; calls method; plain; FNO. mp3; third-order MP perturbation theory; E; E. mp4(sdq); fourth-order MP perturbation theory, less triples; E",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/fnocc.html:12131,energy,energy,12131,psi4manual/1.7.x/fnocc.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/fnocc.html,4,['energy'],['energy']
Energy Efficiency,"atrix with variables that are updated during the potential energy surface scan, and then the same procedure is performed using polar coordinates, converted to Cartesian coordinates. cfour/pywrap-db1; Database calculation, so no molecule section in input file. Portions of the full databases, restricted by subset keyword, are computed by sapt0 and dfmp2 methods. cfour/sp-rohf-ccsd_t_-ao-ecc; single-point CCSD(T)/qz2p on NH2 with ecc, aobasis. cfour/kw-5; Basis set spherical/Cartesian with basis and cfour_spherical. cfour/sp-rhf-ccsd; single point CCSD/qz2p on water. cfour/kw-6; Basis set spherical/Cartesian with cfour_basis and puream. cfour/opt-rhf-scf; optimization HF/svp on water. cfour/opt-rhf-ccsd_t_; optimization CCSD(T)/dzp on water. cfour/sp-rhf-ccsd_t_; single-point CCSD(T)/qz2p on water. cfour/sp-uhf-ccsd; single-point CCSD/qz2p on NH2. cfour/sp-rhf-scf; single-point HF/qz2p on water. cfour/sp-rhf-ccsd_t_-ao; single-point CCSD(T)/qz2p on water with aobasis. cfour/psi-rhf-mp3; MP3 energy components. Checks that computed identically between cfour and psi4. cfour/pywrap-cbs1; Various basis set extrapolation tests only in Cfour instead of Psi4. cfour/psi-uhf-scsmp2; UHF MP2 energy components. Checks that computed identically between cfour and psi4. cfour/dfmp2-1; MP2/cc-PVDZ computation of formic acid dimer binding energy using automatic counterpoise correction. Monomers are specified using Cartesian coordinates. cfour/opt-rhf-mp2; optimization MP2/cc-pvtz on water. cfour/sp-rhf-ccsd_t_-ao-ecc; single-point CCSD(T)/qc2p on water with ecc, aobasis. cfour/sp-rohf-ccsd_t_-ao; single-point CCSD(T)/qz2p on NH2 with aobasis. cfour/sp-rohf-mp2-sc; single-point MP2/qz2p on NH2. cfour/psi-a24-grad; geometry after three optimization cycles on A24 database, cfour matches psi4. cfour/kw-8; Translating psi4 options to cfour, part ii. cfour/kw-1; testing best practices options, part i. cfour/sp-uhf-ccsdt; single-point CCSDT/qz2p on NH2. cfour/sp-uhf-cc3; single-point CC3/qz2p",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/autodoc_testsuite_cfour.html:3391,energy,energy,3391,psi4manual/master/autodoc_testsuite_cfour.html,https://psicode.org,https://psicode.org/psi4manual/master/autodoc_testsuite_cfour.html,1,['energy'],['energy']
Energy Efficiency,"atrix. Fa_subset(self, arg0); Returns the Alpha Fock Matrix in the requested basis (AO,SO). Fb(self); Returns the Beta Fock Matrix. Fb_subset(self, arg0); Returns the Beta Fock Matrix in the requested basis (AO,SO). H(self); Returns the 'Core' Matrix (Potential + Kinetic) Integrals. PCM_enabled(self); Whether running a PCM calculation. S(self); Returns the One-electron Overlap Matrix. V_potential(self); Returns the internal DFT V object. Va(self); Returns the Alpha Kohn-Sham Potential Matrix. Vb(self); Returns the Beta Kohn-Sham Potential Matrix. X(). alpha_orbital_space(self, id, basis, subset); Creates OrbitalSpace with information about the requested alpha orbital space. aotoso(self); Returns the Atomic Orbital to Symmetry Orbital transformer. array_variable(self, arg0); Returns copy of the requested (case-insensitive) Matrix QC variable. array_variables(self); Returns the dictionary of all Matrix QC variables. arrays(). Deprecated since version 1.4. atomic_point_charges(self); Returns the set atomic point charges. basis_projection(self, arg0, arg1, arg2, arg3); Projects a orbital matrix from one basis to another. basisset(self); Returns the current orbital basis. beta_orbital_space(self, arg0, arg1, arg2); docstring. build(mol[, basis, quiet]). c1_deep_copy(self, basis); Returns a new wavefunction with internal data converted to C_1 symmetry, using pre-c1-constructed BasisSet basis. check_phases(self); docstring. clear_external_cpscf_perturbations(self); Clear private external_cpscf_perturbations map. clear_external_potentials(self); Clear private external_potentials list. compute_E(self); docstring. compute_energy(); Base class Wavefunction requires this function. compute_fvpi(self); Update number of frozen virtuals. compute_gradient(self); Computes the gradient of the Wavefunction. compute_hessian(self); Computes the Hessian of the Wavefunction. compute_initial_E(self); docstring. compute_orbital_gradient(save_fock, ...); docstring. compute_spin_contamination(",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/api/psi4.core.CUHF.html:2293,charge,charges,2293,psi4manual/1.6.x/api/psi4.core.CUHF.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/api/psi4.core.CUHF.html,8,['charge'],['charges']
Energy Efficiency,"atrix. Fa_subset(self, arg0); Returns the Alpha Fock Matrix in the requested basis (AO,SO). Fb(self); Returns the Beta Fock Matrix. Fb_subset(self, arg0); Returns the Beta Fock Matrix in the requested basis (AO,SO). H(self); Returns the 'Core' Matrix (Potential + Kinetic) Integrals. PCM_enabled(self); Whether running a PCM calculation. S(self); Returns the One-electron Overlap Matrix. V_potential(self); Returns the internal DFT V object. Va(self); Returns the Alpha Kohn-Sham Potential Matrix. Vb(self); Returns the Beta Kohn-Sham Potential Matrix. X(). alpha_orbital_space(self, id, basis, subset); Creates OrbitalSpace with information about the requested alpha orbital space. aotoso(self); Returns the Atomic Orbital to Symmetry Orbital transformer. array_variable(self, arg0); Returns copy of the requested (case-insensitive) Matrix QC variable. array_variables(self); Returns the dictionary of all Matrix QC variables. arrays(). Deprecated since version 1.4. atomic_point_charges(self); Returns the set atomic point charges. basis_projection(self, arg0, arg1, arg2, arg3); Projects a orbital matrix from one basis to another. basisset(self); Returns the current orbital basis. beta_orbital_space(self, arg0, arg1, arg2); docstring. build(mol[, basis, quiet]). c1_deep_copy(self, basis); Returns a new wavefunction with internal data converted to \(C_1\) symmetry, using pre-c1-constructed basis. check_phases(self); docstring. clear_external_cpscf_perturbations(self); Clear private external_cpscf_perturbations map. clear_external_potentials(self); Clear private external_potentials list. compute_E(self); docstring. compute_energy(); Base class Wavefunction requires this function. compute_fvpi(self); Update number of frozen virtuals. compute_gradient(self); Computes the gradient of the Wavefunction. compute_hessian(self); Computes the Hessian of the Wavefunction. compute_initial_E(self); docstring. compute_orbital_gradient(self, arg0, arg1); docstring. compute_spin_contamination(sel",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/api/psi4.core.HF.html:2295,charge,charges,2295,psi4manual/1.6.x/api/psi4.core.HF.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/api/psi4.core.HF.html,2,['charge'],['charges']
Energy Efficiency,"atrix. Fa_subset(self, arg0); Returns the Alpha Fock Matrix in the requested basis (AO,SO). Fb(self); Returns the Beta Fock Matrix. Fb_subset(self, arg0); Returns the Beta Fock Matrix in the requested basis (AO,SO). H(self); Returns the 'Core' Matrix (Potential + Kinetic) Integrals. PCM_enabled(self); Whether running a PCM calculation. S(self); Returns the One-electron Overlap Matrix. V_potential(self); Returns the internal DFT V object. Va(self); Returns the Alpha Kohn-Sham Potential Matrix. Vb(self); Returns the Beta Kohn-Sham Potential Matrix. X(). alpha_orbital_space(self, id, basis, subset); Creates OrbitalSpace with information about the requested alpha orbital space. aotoso(self); Returns the Atomic Orbital to Symmetry Orbital transformer. array_variable(self, arg0); Returns copy of the requested (case-insensitive) Matrix QC variable. array_variables(self); Returns the dictionary of all Matrix QC variables. arrays(). Deprecated since version 1.4. atomic_point_charges(self); Returns the set atomic point charges. basis_projection(self, arg0, arg1, arg2, arg3); Projects a orbital matrix from one basis to another. basisset(self); Returns the current orbital basis. beta_orbital_space(self, arg0, arg1, arg2); docstring. build(mol[, basis]). c1_deep_copy(self, basis); Returns a new wavefunction with internal data converted to C_1 symmetry, using pre-c1-constructed BasisSet basis. check_phases(self); docstring. clear_external_cpscf_perturbations(self); Clear private external_cpscf_perturbations map. clear_external_potentials(self); Clear private external_potentials list. compute_E(self); docstring. compute_energy(); Base class Wavefunction requires this function. compute_fvpi(self); Update number of frozen virtuals. compute_gradient(self); Computes the gradient of the Wavefunction. compute_hessian(self); Computes the Hessian of the Wavefunction. compute_initial_E(self); docstring. compute_orbital_gradient(save_fock, ...); docstring. compute_spin_contamination(self); ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/api/psi4.core.cuhf.html:2293,charge,charges,2293,psi4manual/1.5.0/api/psi4.core.cuhf.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/api/psi4.core.cuhf.html,8,['charge'],['charges']
Energy Efficiency,"atrix. Fa_subset(self, arg0); Returns the Alpha Fock Matrix in the requested basis (AO,SO). Fb(self); Returns the Beta Fock Matrix. Fb_subset(self, arg0); Returns the Beta Fock Matrix in the requested basis (AO,SO). H(self); Returns the 'Core' Matrix (Potential + Kinetic) Integrals. PCM_enabled(self); Whether running a PCM calculation. S(self); Returns the One-electron Overlap Matrix. V_potential(self); Returns the internal DFT V object. Va(self); Returns the Alpha Kohn-Sham Potential Matrix. Vb(self); Returns the Beta Kohn-Sham Potential Matrix. X(). alpha_orbital_space(self, id, basis, subset); Creates OrbitalSpace with information about the requested alpha orbital space. aotoso(self); Returns the Atomic Orbital to Symmetry Orbital transformer. array_variable(self, arg0); Returns copy of the requested (case-insensitive) Matrix QC variable. array_variables(self); Returns the dictionary of all Matrix QC variables. arrays(). Deprecated since version 1.4. atomic_point_charges(self); Returns the set atomic point charges. basis_projection(self, arg0, arg1, arg2, arg3); Projects a orbital matrix from one basis to another. basisset(self); Returns the current orbital basis. beta_orbital_space(self, arg0, arg1, arg2); docstring. build(mol[, basis]). c1_deep_copy(self, basis); Returns a new wavefunction with internal data converted to \(C_1\) symmetry, using pre-c1-constructed basis. check_phases(self); docstring. clear_external_cpscf_perturbations(self); Clear private external_cpscf_perturbations map. clear_external_potentials(self); Clear private external_potentials list. compute_E(self); docstring. compute_energy(); Base class Wavefunction requires this function. compute_fvpi(self); Update number of frozen virtuals. compute_gradient(self); Computes the gradient of the Wavefunction. compute_hessian(self); Computes the Hessian of the Wavefunction. compute_initial_E(self); docstring. compute_orbital_gradient(self, arg0, arg1); docstring. compute_spin_contamination(self); doc",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/api/psi4.core.hf.html:2295,charge,charges,2295,psi4manual/1.5.0/api/psi4.core.hf.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/api/psi4.core.hf.html,2,['charge'],['charges']
Energy Efficiency,"atrix. Fa_subset(self, arg0); Returns the Alpha Fock Matrix in the requested basis (AO,SO). Fb(self); Returns the Beta Fock Matrix. Fb_subset(self, arg0); Returns the Beta Fock Matrix in the requested basis (AO,SO). H(self); Returns the ‘Core’ Matrix (Potential + Kinetic) Integrals. PCM_enabled(self); Whether running a PCM calculation. S(self); Returns the One-electron Overlap Matrix. V_potential(self); Returns the internal DFT V object. Va(self); Returns the Alpha Kohn-Sham Potential Matrix. Vb(self); Returns the Beta Kohn-Sham Potential Matrix. X(). alpha_orbital_space(self, id, basis, subset); Creates OrbitalSpace with information about the requested alpha orbital space. aotoso(self); Returns the Atomic Orbital to Symmetry Orbital transformer. array_variable(self, arg0); Returns copy of the requested (case-insensitive) Matrix QC variable. array_variables(self); Returns the dictionary of all Matrix QC variables. arrays(). Deprecated since version 1.4. atomic_point_charges(self); Returns the set atomic point charges. basis_projection(self, arg0, arg1, arg2, arg3); Projects a orbital matrix from one basis to another. basisset(self); Returns the current orbital basis. beta_orbital_space(self, arg0, arg1, arg2); docstring. build(mol[, basis]). c1_deep_copy(self, basis); Returns a new wavefunction with internal data converted to C_1 symmetry, using pre-c1-constructed BasisSet basis. check_phases(self); docstring. clear_external_cpscf_perturbations(self); Clear private external_cpscf_perturbations map. clear_external_potentials(self); Clear private external_potentials list. compute_E(self); docstring. compute_energy(); Base class Wavefunction requires this function. compute_fvpi(self); Update number of frozen virtuals. compute_gradient(self); Computes the gradient of the Wavefunction. compute_hessian(self); Computes the Hessian of the Wavefunction. compute_initial_E(self); docstring. compute_orbital_gradient(self, arg0, arg1); docstring. compute_spin_contamination(self)",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/api/psi4.core.cuhf.html:2210,charge,charges,2210,psi4manual/1.4.0/api/psi4.core.cuhf.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/api/psi4.core.cuhf.html,7,['charge'],['charges']
Energy Efficiency,"atrix. Fa_subset(self, arg0); Returns the Alpha Fock Matrix in the requested basis (AO,SO). Fb(self); Returns the Beta Fock Matrix. Fb_subset(self, arg0); Returns the Beta Fock Matrix in the requested basis (AO,SO). H(self); Returns the ‘Core’ Matrix (Potential + Kinetic) Integrals. PCM_enabled(self); Whether running a PCM calculation. S(self); Returns the One-electron Overlap Matrix. V_potential(self); Returns the internal DFT V object. Va(self); Returns the Alpha Kohn-Sham Potential Matrix. Vb(self); Returns the Beta Kohn-Sham Potential Matrix. X(). alpha_orbital_space(self, id, basis, subset); Creates OrbitalSpace with information about the requested alpha orbital space. aotoso(self); Returns the Atomic Orbital to Symmetry Orbital transformer. array_variable(self, arg0); Returns copy of the requested (case-insensitive) Matrix QC variable. array_variables(self); Returns the dictionary of all Matrix QC variables. arrays(). Deprecated since version 1.4. atomic_point_charges(self); Returns the set atomic point charges. basis_projection(self, arg0, arg1, arg2, arg3); Projects a orbital matrix from one basis to another. basisset(self); Returns the current orbital basis. beta_orbital_space(self, arg0, arg1, arg2); docstring. build(mol[, basis]). c1_deep_copy(self, basis); Returns a new wavefunction with internal data converted to \(C_1\) symmetry, using pre-c1-constructed basis. check_phases(self); docstring. clear_external_cpscf_perturbations(self); Clear private external_cpscf_perturbations map. clear_external_potentials(self); Clear private external_potentials list. compute_E(self); docstring. compute_energy(); Base class Wavefunction requires this function. compute_fvpi(self); Update number of frozen virtuals. compute_gradient(self); Computes the gradient of the Wavefunction. compute_hessian(self); Computes the Hessian of the Wavefunction. compute_initial_E(self); docstring. compute_orbital_gradient(self, arg0, arg1); docstring. compute_spin_contamination(self); doc",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/api/psi4.core.hf.html:2212,charge,charges,2212,psi4manual/1.4.0/api/psi4.core.hf.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/api/psi4.core.hf.html,1,['charge'],['charges']
Energy Efficiency,"atrix. H(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the ‘Core’ Matrix (Potential + Kinetic) Integrals. S(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the One-electron Overlap Matrix. V_potential(self: psi4.core.HF) → psi4.core.VBase¶; Returns the internal DFT V object. Va(self: psi4.core.HF) → psi4.core.Matrix¶; Returns the Alpha Kohn-Shame Potential Matrix. Vb(self: psi4.core.HF) → psi4.core.Matrix¶; Returns the Alpha Kohn-Shame Potential Matrix. X(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Lagrangian Matrix. alpha_orbital_space(self: psi4.core.Wavefunction, arg0: str, arg1: str, arg2: str) → psi4.core.OrbitalSpace¶; docstring. aotoso(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Atomic Orbital to Symmetry Orbital transformer. arrays(self: psi4.core.Wavefunction) → Dict[str, psi4.core.Matrix]¶; Returns the map of all internal arrays. atomic_point_charges(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the set atomic point charges. basis_projection(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix, arg1: psi4.core.Dimension, arg2: psi4.core.BasisSet, arg3: psi4.core.BasisSet) → psi4.core.Matrix¶; Projects a orbital matrix from one basis to another. basisset(self: psi4.core.Wavefunction) → psi4.core.BasisSet¶; Returns the current orbital basis. beta_orbital_space(self: psi4.core.Wavefunction, arg0: str, arg1: str, arg2: str) → psi4.core.OrbitalSpace¶; docstring. build(mol, basis=None)¶. compute_energy(self: psi4.core.Wavefunction) → float¶; Computes the energy of the Wavefunction. compute_gradient(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Computes the gradient of the Wavefunction. compute_hessian(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Computes the Hessian of the Wavefunction. deep_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; Deep copies the internal data. doccpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of d",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/psi4api-1.html:18666,charge,charges,18666,psi4manual/1.1.0/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/psi4api-1.html,14,['charge'],['charges']
Energy Efficiency,"atrix. H(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the ‘Core’ Matrix (Potential + Kinetic) Integrals. S(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the One-electron Overlap Matrix. V_potential(self: psi4.core.HF) → psi4.core.VBase¶; Returns the internal DFT V object. Va(self: psi4.core.HF) → psi4.core.Matrix¶; Returns the Alpha Kohn-Shame Potential Matrix. Vb(self: psi4.core.HF) → psi4.core.Matrix¶; Returns the Alpha Kohn-Shame Potential Matrix. X(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Lagrangian Matrix. alpha_orbital_space(self: psi4.core.Wavefunction, arg0: str, arg1: str, arg2: str) → psi4.core.OrbitalSpace¶; docstring. aotoso(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Atomic Orbital to Symmetry Orbital transformer. arrays(self: psi4.core.Wavefunction) → Dict[str, psi4.core.Matrix]¶; Returns the map of all internal arrays. atomic_point_charges(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the set atomic point charges. basis_projection(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix, arg1: psi4.core.Dimension, arg2: psi4.core.BasisSet, arg3: psi4.core.BasisSet) → psi4.core.Matrix¶; Projects a orbital matrix from one basis to another. basisset(self: psi4.core.Wavefunction) → psi4.core.BasisSet¶; Returns the current orbital basis. beta_orbital_space(self: psi4.core.Wavefunction, arg0: str, arg1: str, arg2: str) → psi4.core.OrbitalSpace¶; docstring. static build(mol, basis=None)¶. c1_deep_copy(self: psi4.core.CUHF, basis: psi4.core.BasisSet) → psi4.core.CUHF; Returns a new wavefunction with internal data converted to C_1 symmetry, using pre-c1-constructed BasisSet basis. compute_energy(self: psi4.core.Wavefunction) → float¶; Computes the energy of the Wavefunction. compute_gradient(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Computes the gradient of the Wavefunction. compute_hessian(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Computes the Hessian of the Wavefun",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/api/psi4.core.cuhf.html:2550,charge,charges,2550,psi4manual/1.2.1/api/psi4.core.cuhf.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/api/psi4.core.cuhf.html,1,['charge'],['charges']
Energy Efficiency,"atrix. H(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the ‘Core’ Matrix (Potential + Kinetic) Integrals. S(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the One-electron Overlap Matrix. V_potential(self: psi4.core.HF) → psi4.core.VBase¶; Returns the internal DFT V object. Va(self: psi4.core.HF) → psi4.core.Matrix¶; Returns the Alpha Kohn-Shame Potential Matrix. Vb(self: psi4.core.HF) → psi4.core.Matrix¶; Returns the Alpha Kohn-Shame Potential Matrix. X(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Lagrangian Matrix. alpha_orbital_space(self: psi4.core.Wavefunction, arg0: str, arg1: str, arg2: str) → psi4.core.OrbitalSpace¶; docstring. aotoso(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Atomic Orbital to Symmetry Orbital transformer. arrays(self: psi4.core.Wavefunction) → Dict[str, psi4.core.Matrix]¶; Returns the map of all internal arrays. atomic_point_charges(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the set atomic point charges. basis_projection(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix, arg1: psi4.core.Dimension, arg2: psi4.core.BasisSet, arg3: psi4.core.BasisSet) → psi4.core.Matrix¶; Projects a orbital matrix from one basis to another. basisset(self: psi4.core.Wavefunction) → psi4.core.BasisSet¶; Returns the current orbital basis. beta_orbital_space(self: psi4.core.Wavefunction, arg0: str, arg1: str, arg2: str) → psi4.core.OrbitalSpace¶; docstring. static build(mol, basis=None)¶. c1_deep_copy(self: psi4.core.CUHF, basis: psi4.core.BasisSet) → psi4.core.CUHF¶; Returns a new wavefunction with internal data converted to C_1 symmetry, using pre-c1-constructed BasisSet basis. compute_energy(self: psi4.core.Wavefunction) → float¶; Computes the energy of the Wavefunction. compute_gradient(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Computes the gradient of the Wavefunction. compute_hessian(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Computes the Hessian of the Wavefu",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/psi4api-1.html:23023,charge,charges,23023,psi4manual/1.2.1/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html,2,['charge'],['charges']
Energy Efficiency,"atrix. H(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the ‘Core’ Matrix (Potential + Kinetic) Integrals. S(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the One-electron Overlap Matrix. V_potential(self: psi4.core.HF) → psi4.core.VBase¶; Returns the internal DFT V object. Va(self: psi4.core.HF) → psi4.core.Matrix¶; Returns the Alpha Kohn-Shame Potential Matrix. Vb(self: psi4.core.HF) → psi4.core.Matrix¶; Returns the Alpha Kohn-Shame Potential Matrix. X(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Lagrangian Matrix. alpha_orbital_space(self: psi4.core.Wavefunction, arg0: str, arg1: str, arg2: str) → psi4.core.OrbitalSpace¶; docstring. aotoso(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Atomic Orbital to Symmetry Orbital transformer. arrays(self: psi4.core.Wavefunction) → Dict[str, psi4.core.Matrix]¶; Returns the map of all internal arrays. atomic_point_charges(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the set atomic point charges. basis_projection(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix, arg1: psi4.core.Dimension, arg2: psi4.core.BasisSet, arg3: psi4.core.BasisSet) → psi4.core.Matrix¶; Projects a orbital matrix from one basis to another. basisset(self: psi4.core.Wavefunction) → psi4.core.BasisSet¶; Returns the current orbital basis. beta_orbital_space(self: psi4.core.Wavefunction, arg0: str, arg1: str, arg2: str) → psi4.core.OrbitalSpace¶; docstring. static build(mol, basis=None)¶. c1_deep_copy(self: psi4.core.RHF, basis: psi4.core.BasisSet) → psi4.core.RHF; Returns a new wavefunction with internal data converted to C_1 symmetry, using pre-c1-constructed BasisSet basis. compute_energy(self: psi4.core.Wavefunction) → float¶; Computes the energy of the Wavefunction. compute_gradient(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Computes the gradient of the Wavefunction. compute_hessian(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Computes the Hessian of the Wavefunct",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/api/psi4.core.rhf.html:2545,charge,charges,2545,psi4manual/1.2.1/api/psi4.core.rhf.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/api/psi4.core.rhf.html,1,['charge'],['charges']
Energy Efficiency,"atrix. H(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the ‘Core’ Matrix (Potential + Kinetic) Integrals. S(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the One-electron Overlap Matrix. V_potential(self: psi4.core.HF) → psi4.core.VBase¶; Returns the internal DFT V object. Va(self: psi4.core.HF) → psi4.core.Matrix¶; Returns the Alpha Kohn-Shame Potential Matrix. Vb(self: psi4.core.HF) → psi4.core.Matrix¶; Returns the Alpha Kohn-Shame Potential Matrix. X(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Lagrangian Matrix. alpha_orbital_space(self: psi4.core.Wavefunction, arg0: str, arg1: str, arg2: str) → psi4.core.OrbitalSpace¶; docstring. aotoso(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Atomic Orbital to Symmetry Orbital transformer. arrays(self: psi4.core.Wavefunction) → Dict[str, psi4.core.Matrix]¶; Returns the map of all internal arrays. atomic_point_charges(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the set atomic point charges. basis_projection(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix, arg1: psi4.core.Dimension, arg2: psi4.core.BasisSet, arg3: psi4.core.BasisSet) → psi4.core.Matrix¶; Projects a orbital matrix from one basis to another. basisset(self: psi4.core.Wavefunction) → psi4.core.BasisSet¶; Returns the current orbital basis. beta_orbital_space(self: psi4.core.Wavefunction, arg0: str, arg1: str, arg2: str) → psi4.core.OrbitalSpace¶; docstring. static build(mol, basis=None)¶. c1_deep_copy(self: psi4.core.RHF, basis: psi4.core.BasisSet) → psi4.core.RHF¶; Returns a new wavefunction with internal data converted to C_1 symmetry, using pre-c1-constructed BasisSet basis. compute_energy(self: psi4.core.Wavefunction) → float¶; Computes the energy of the Wavefunction. compute_gradient(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Computes the gradient of the Wavefunction. compute_hessian(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Computes the Hessian of the Wavefunc",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/psi4api-1.html:161268,charge,charges,161268,psi4manual/1.2.1/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html,2,['charge'],['charges']
Energy Efficiency,"atrix. H(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the ‘Core’ Matrix (Potential + Kinetic) Integrals. S(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the One-electron Overlap Matrix. V_potential(self: psi4.core.HF) → psi4.core.VBase¶; Returns the internal DFT V object. Va(self: psi4.core.HF) → psi4.core.Matrix¶; Returns the Alpha Kohn-Shame Potential Matrix. Vb(self: psi4.core.HF) → psi4.core.Matrix¶; Returns the Alpha Kohn-Shame Potential Matrix. X(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Lagrangian Matrix. alpha_orbital_space(self: psi4.core.Wavefunction, arg0: str, arg1: str, arg2: str) → psi4.core.OrbitalSpace¶; docstring. aotoso(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Atomic Orbital to Symmetry Orbital transformer. arrays(self: psi4.core.Wavefunction) → Dict[str, psi4.core.Matrix]¶; Returns the map of all internal arrays. atomic_point_charges(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the set atomic point charges. basis_projection(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix, arg1: psi4.core.Dimension, arg2: psi4.core.BasisSet, arg3: psi4.core.BasisSet) → psi4.core.Matrix¶; Projects a orbital matrix from one basis to another. basisset(self: psi4.core.Wavefunction) → psi4.core.BasisSet¶; Returns the current orbital basis. beta_orbital_space(self: psi4.core.Wavefunction, arg0: str, arg1: str, arg2: str) → psi4.core.OrbitalSpace¶; docstring. static build(mol, basis=None)¶. c1_deep_copy(self: psi4.core.ROHF, basis: psi4.core.BasisSet) → psi4.core.ROHF; Returns a new wavefunction with internal data converted to C_1 symmetry, using pre-c1-constructed BasisSet basis. compute_energy(self: psi4.core.Wavefunction) → float¶; Computes the energy of the Wavefunction. compute_gradient(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Computes the gradient of the Wavefunction. compute_hessian(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Computes the Hessian of the Wavefun",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/api/psi4.core.rohf.html:2800,charge,charges,2800,psi4manual/1.2.1/api/psi4.core.rohf.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/api/psi4.core.rohf.html,1,['charge'],['charges']
Energy Efficiency,"atrix. H(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the ‘Core’ Matrix (Potential + Kinetic) Integrals. S(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the One-electron Overlap Matrix. V_potential(self: psi4.core.HF) → psi4.core.VBase¶; Returns the internal DFT V object. Va(self: psi4.core.HF) → psi4.core.Matrix¶; Returns the Alpha Kohn-Shame Potential Matrix. Vb(self: psi4.core.HF) → psi4.core.Matrix¶; Returns the Alpha Kohn-Shame Potential Matrix. X(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Lagrangian Matrix. alpha_orbital_space(self: psi4.core.Wavefunction, arg0: str, arg1: str, arg2: str) → psi4.core.OrbitalSpace¶; docstring. aotoso(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Atomic Orbital to Symmetry Orbital transformer. arrays(self: psi4.core.Wavefunction) → Dict[str, psi4.core.Matrix]¶; Returns the map of all internal arrays. atomic_point_charges(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the set atomic point charges. basis_projection(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix, arg1: psi4.core.Dimension, arg2: psi4.core.BasisSet, arg3: psi4.core.BasisSet) → psi4.core.Matrix¶; Projects a orbital matrix from one basis to another. basisset(self: psi4.core.Wavefunction) → psi4.core.BasisSet¶; Returns the current orbital basis. beta_orbital_space(self: psi4.core.Wavefunction, arg0: str, arg1: str, arg2: str) → psi4.core.OrbitalSpace¶; docstring. static build(mol, basis=None)¶. c1_deep_copy(self: psi4.core.ROHF, basis: psi4.core.BasisSet) → psi4.core.ROHF¶; Returns a new wavefunction with internal data converted to C_1 symmetry, using pre-c1-constructed BasisSet basis. compute_energy(self: psi4.core.Wavefunction) → float¶; Computes the energy of the Wavefunction. compute_gradient(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Computes the gradient of the Wavefunction. compute_hessian(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Computes the Hessian of the Wavefu",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/psi4api-1.html:173857,charge,charges,173857,psi4manual/1.2.1/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html,2,['charge'],['charges']
Energy Efficiency,"atrix. H(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the ‘Core’ Matrix (Potential + Kinetic) Integrals. S(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the One-electron Overlap Matrix. V_potential(self: psi4.core.HF) → psi4.core.VBase¶; Returns the internal DFT V object. Va(self: psi4.core.HF) → psi4.core.Matrix¶; Returns the Alpha Kohn-Shame Potential Matrix. Vb(self: psi4.core.HF) → psi4.core.Matrix¶; Returns the Alpha Kohn-Shame Potential Matrix. X(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Lagrangian Matrix. alpha_orbital_space(self: psi4.core.Wavefunction, arg0: str, arg1: str, arg2: str) → psi4.core.OrbitalSpace¶; docstring. aotoso(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Atomic Orbital to Symmetry Orbital transformer. arrays(self: psi4.core.Wavefunction) → Dict[str, psi4.core.Matrix]¶; Returns the map of all internal arrays. atomic_point_charges(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the set atomic point charges. basis_projection(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix, arg1: psi4.core.Dimension, arg2: psi4.core.BasisSet, arg3: psi4.core.BasisSet) → psi4.core.Matrix¶; Projects a orbital matrix from one basis to another. basisset(self: psi4.core.Wavefunction) → psi4.core.BasisSet¶; Returns the current orbital basis. beta_orbital_space(self: psi4.core.Wavefunction, arg0: str, arg1: str, arg2: str) → psi4.core.OrbitalSpace¶; docstring. static build(mol, basis=None)¶. c1_deep_copy(self: psi4.core.UHF, basis: psi4.core.BasisSet) → psi4.core.UHF; Returns a new wavefunction with internal data converted to C_1 symmetry, using pre-c1-constructed BasisSet basis. compute_energy(self: psi4.core.Wavefunction) → float¶; Computes the energy of the Wavefunction. compute_gradient(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Computes the gradient of the Wavefunction. compute_hessian(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Computes the Hessian of the Wavefunct",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/api/psi4.core.uhf.html:2545,charge,charges,2545,psi4manual/1.2.1/api/psi4.core.uhf.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/api/psi4.core.uhf.html,1,['charge'],['charges']
Energy Efficiency,"atrix. H(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the ‘Core’ Matrix (Potential + Kinetic) Integrals. S(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the One-electron Overlap Matrix. V_potential(self: psi4.core.HF) → psi4.core.VBase¶; Returns the internal DFT V object. Va(self: psi4.core.HF) → psi4.core.Matrix¶; Returns the Alpha Kohn-Shame Potential Matrix. Vb(self: psi4.core.HF) → psi4.core.Matrix¶; Returns the Alpha Kohn-Shame Potential Matrix. X(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Lagrangian Matrix. alpha_orbital_space(self: psi4.core.Wavefunction, arg0: str, arg1: str, arg2: str) → psi4.core.OrbitalSpace¶; docstring. aotoso(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Atomic Orbital to Symmetry Orbital transformer. arrays(self: psi4.core.Wavefunction) → Dict[str, psi4.core.Matrix]¶; Returns the map of all internal arrays. atomic_point_charges(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the set atomic point charges. basis_projection(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix, arg1: psi4.core.Dimension, arg2: psi4.core.BasisSet, arg3: psi4.core.BasisSet) → psi4.core.Matrix¶; Projects a orbital matrix from one basis to another. basisset(self: psi4.core.Wavefunction) → psi4.core.BasisSet¶; Returns the current orbital basis. beta_orbital_space(self: psi4.core.Wavefunction, arg0: str, arg1: str, arg2: str) → psi4.core.OrbitalSpace¶; docstring. static build(mol, basis=None)¶. c1_deep_copy(self: psi4.core.UHF, basis: psi4.core.BasisSet) → psi4.core.UHF¶; Returns a new wavefunction with internal data converted to C_1 symmetry, using pre-c1-constructed BasisSet basis. compute_energy(self: psi4.core.Wavefunction) → float¶; Computes the energy of the Wavefunction. compute_gradient(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Computes the gradient of the Wavefunction. compute_hessian(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Computes the Hessian of the Wavefunc",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/psi4api-1.html:197342,charge,charges,197342,psi4manual/1.2.1/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html,2,['charge'],['charges']
Energy Efficiency,"atrix. H(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the ‘Core’ Matrix (Potential + Kinetic) Integrals. S(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the One-electron Overlap Matrix. V_potential(self: psi4.core.HF) → psi4.core.VBase¶; Returns the internal DFT V object. Va(self: psi4.core.HF) → psi4.core.Matrix¶; Returns the Alpha Kohn-Shame Potential Matrix. Vb(self: psi4.core.HF) → psi4.core.Matrix¶; Returns the Alpha Kohn-Shame Potential Matrix. X(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Lagrangian Matrix. alpha_orbital_space(self: psi4.core.Wavefunction, arg0: str, arg1: str, arg2: str) → psi4.core.OrbitalSpace¶; docstring. aotoso(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Atomic Orbital to Symmetry Orbital transformer. arrays(self: psi4.core.Wavefunction) → Dict[str, psi4.core.Matrix]¶; Returns the map of all internal arrays. atomic_point_charges(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the set atomic point charges. basis_projection(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix, arg1: psi4.core.Dimension, arg2: psi4.core.BasisSet, arg3: psi4.core.BasisSet) → psi4.core.Matrix¶; Projects a orbital matrix from one basis to another. basisset(self: psi4.core.Wavefunction) → psi4.core.BasisSet¶; Returns the current orbital basis. beta_orbital_space(self: psi4.core.Wavefunction, arg0: str, arg1: str, arg2: str) → psi4.core.OrbitalSpace¶; docstring. static build(mol, basis=None)¶. c1_deep_copy(self: psi4.core.Wavefunction, basis: psi4.core.BasisSet) → psi4.core.Wavefunction¶; Returns a new wavefunction with internal data converted to C_1 symmetry, using pre-c1-constructed BasisSet *basis. compute_energy(self: psi4.core.Wavefunction) → float¶; Computes the energy of the Wavefunction. compute_gradient(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Computes the gradient of the Wavefunction. compute_hessian(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Computes the Hess",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/psi4api-1.html:71140,charge,charges,71140,psi4manual/1.2.1/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html,2,['charge'],['charges']
Energy Efficiency,"atrix; \(K^{\alpha}\) dominate the computational effort of the SCF procedure. For; very large systems, diagonalization of the Fock matrix can also present a; significant hurdle. Minimal Input¶; Minimal input for a Hartree–Fock computation is a molecule block, basis set; option, and a call to energy('scf'):; 1; 2; 3; 4; 5; 6; 7molecule {; He; }. set basis sto-3g. energy('scf'). This will run a Restricted Hartree–Fock (RHF) on neutral singlet Helium in; \(D_{2h}\) spatial symmetry with a minimal STO-3G basis, 1.0E-6; energy and density convergence criteria (since single-point, see; SCF Convergence & Algorithm), a DF ERI algorithm, symmetric; orthogonalization, DIIS, and a core Hamiltonian guess. For more; information on any of these options, see the relevant section below. Spin/Symmetry Treatment¶; PSI4 implements the most popular spin specializations of Hartree–Fock; theory, including:. Restricted Hartree–Fock (RHF) [Default]; Appropriate only for closed-shell singlet systems, but twice as efficient; as the other flavors, as the alpha and beta densities are constrained to be; identical.; Unrestricted Hartree–Fock (UHF); Appropriate for most open-shell systems and fairly easy to converge.; The spatial parts of the alpha and beta orbitals are fully independent of each; other, which allows a considerable amount of flexibility in the wavefunction.; However, this flexibility comes at the cost of spin symmetry; UHF wavefunctions; need not be eigenfunctions of the \(\hat S^2\) operator. The deviation of; this operator from its expectation value is printed on the output file. If the; deviation is greater than a few hundredths, it is advisable to switch to a; ROHF to avoid this “spin-contamination” problem.; Restricted Open-Shell Hartree–Fock (ROHF); Appropriate for open-shell systems where spin-contamination is problem.; Sometimes more difficult to converge, and assumes uniformly positive spin; polarization (the alpha and beta doubly-occupied orbitals are identical).; Constr",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/scf-1.html:8293,efficient,efficient,8293,psi4manual/1.1.0/scf-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/scf-1.html,6,['efficient'],['efficient']
Energy Efficiency,"attribute attr from module if attr; is available in any possible lettercase permutation. Returns; attribute if available, None if not. import_ignorecase(module)[source]¶; Function to import module in any possible lettercase; permutation. Returns module object if available, None if not. query_yes_no(question, default=True)[source]¶; Ask a yes/no question via raw_input() and return their answer.; question is a string that is presented to the user.; default is the presumed answer if the user just hits <Enter>.; It must be yes (the default), no or None (meaning; an answer is required of the user).; The return value is one of True or False. search_file(filename, search_path)[source]¶; Given an os.pathsep divided search_path, find first occurance of; filename. Returns full path to file if found or None if unfound. Class to. class GaussianShell(am, nprimitive, oc, c, ec, e, pure, nc, center, start)[source]¶; Class with same information as ShellInfo. In C++,; class uses more efficient data structures, but in Python differences; minimal. nprimitive()[source]¶; The number of primitive Gaussians. INT_CARTINDEX(am, i, j)[source]¶; Computes offset index for cartesian function.; #define INT_CARTINDEX(am,i,j) (((i) == (am))? 0 : (((((am) - (i) + 1)*((am) - (i)))>>1) + (am) - (i) - (j))). INT_ICART(a, b, c)[source]¶; Given a, b, and c compute a cartesian offset.; #define INT_ICART(a, b, c) (((((((a)+(b)+(c)+1)<<1)-(a))*((a)+1))>>1)-(b)-1). INT_IPURE(l, m)[source]¶; Given l and m compute a pure function offset.; #define INT_IPURE(l, m) ((l)+(m)). INT_NCART(am)[source]¶; Gives the number of cartesian functions for an angular momentum.; define INT_NCART(am) ((am>=0) ? ((((am)+2)*((am)+1))>>1) : 0). INT_NFUNC(pu, am)[source]¶; Gives the number of functions for an angular momentum based on pu.; #define INT_NFUNC(pu,am) ((pu)?INT_NPURE(am):INT_NCART(am)). INT_NPURE(am)[source]¶; Gives the number of spherical functions for an angular momentum.; #define INT_NPURE(am) (2*(am)+1). class Shel",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_driver-1.html:98366,efficient,efficient,98366,psi4manual/1.0.0/autodoc_driver-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_driver-1.html,2,['efficient'],['efficient']
Energy Efficiency,"atural orbital approximations for the \(v^4\) block of two-electron integrals in the evaluation of CCD T2 amplitudes? Recommended true for all SAPT computations. Type: boolean; Default: true. OCC_TOLERANCE¶. Minimum occupation (eigenvalues of the MP2 OPDM) below which virtual natural orbitals are discarded for in each of the above three truncations. Type: conv double; Default: 1.0e-6. Charge-Transfer in SAPT¶; It is possible to obtain the stabilization energy of a complex due to; charge-transfer effects from a SAPT computation. The charge-transfer energy; can be computed with the SAPT module as described by Stone; and Misquitta [Misquitta:2009:201].; Charge-transfer energies can be obtained from the following calls to the; energy function.; 1; 2; 3; 4; 5; 6; 7; 8energy('sapt0-ct'); energy('sapt2-ct'); energy('sapt2+-ct'); energy('sapt2+(3)-ct'); energy('sapt2+3-ct'); energy('sapt2+(ccd)-ct'); energy('sapt2+(3)(ccd)-ct'); energy('sapt2+3(ccd)-ct'). For now, charge transfer computations are not available with open-shell SAPT0.; A SAPT charge-transfer analysis will perform 5 HF computations: the dimer; in the dimer basis, monomer A in the dimer basis, monomer B in the dimer; basis, monomer A in the monomer A basis, and monomer B in the monomer B; basis. Next, it performs two SAPT computations, one in the dimer basis and; one in the monomer basis. Finally, it will print a summary of the; charge-transfer results:; 1; 2; 3; 4; 5 SAPT Charge Transfer Analysis; ------------------------------------------------------------------------------------------------; SAPT Induction (Dimer Basis) -2.0970 [mEh] -1.3159 [kcal/mol] -5.5057 [kJ/mol]; SAPT Induction (Monomer Basis) -1.1396 [mEh] -0.7151 [kcal/mol] -2.9920 [kJ/mol]; SAPT Charge Transfer -0.9574 [mEh] -0.6008 [kcal/mol] -2.5137 [kJ/mol]. These results are for the water dimer geometry shown above computed with; SAPT0/aug-cc-pVDZ. Monomer-Centered Basis Computations¶; The charge-transfer analysis above is carried out by taking ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/sapt-1.html:24811,charge,charge,24811,psi4manual/1.1.0/sapt-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/sapt-1.html,6,['charge'],['charge']
Energy Efficiency,"au; analog of fsapt-ext-abc with molecule and external potentials in Bohr. psimrcc-ccsd_t-4; Mk-MRCCSD(T) single point. \(^1A_1\) O$_3` state described using the Ms = 0 component of the singlet. Uses TCSCF orbitals. dct-grad1; Various DCT analytic gradients for the O2 molecule with 6-31G basis set. dft3; DFT integral algorithms test, performing w-B97 RKS and UKS computations on water and its cation, using all of the different integral algorithms. This tests both the ERI and ERF integrals. dfcasscf-sp; CASSCF/6-31G** energy point. dft-grad2; DF-BP86-D2 cc-pVDZ frozen core gradient of S22 HCN updated ref gradient due to new BraggSlater radii. olccd-grad2; OLCCD cc-pVDZ gradient for the NO radical. nbody-convergence; Convergence of many-body gradients of different BSSE schemes. sapt-dft2; SAPT(DFT) aug-cc-pVDZ computation for the water dimer interaction energy. cbs-xtpl-dict; Extrapolated water energies. cisd-h2o+-1; 6-31G** H2O+ Test CISD Energy Point. olccd3; OLCCD cc-pVDZ energy with ROHF initial guess for the NO radical. pywrap-freq-g-sowreap; Finite difference of gradients frequency, run in sow/reap mode. cc32; CC3/cc-pVDZ H2O \(R_e\) geom from Olsen et al., JCP 104, 8007 (1996). mints4; A demonstration of mixed Cartesian/ZMatrix geometry specification, using variables, for the benzene-hydronium complex. Atoms can be placed using ZMatrix coordinates, whether they belong to the same fragment or not. Note that the Cartesian specification must come before the ZMatrix entries because the former define absolute positions, while the latter are relative. dfcasscf-fzc-sp; CASSCF/6-31G** energy point. tu5-sapt; Example SAPT computation for ethene*ethine (i.e., ethylene*acetylene), test case 16 from the S22 database. sapt2; SAPT0 aug-cc-pVDZ computation of the benzene-methane interaction energy, using the aug-pVDZ-JKFIT DF basis for SCF, the aug-cc-pVDZ-RI DF basis for SAPT0 induction and dispersion, and the aug-pVDZ-JKFIT DF basis for SAPT0 electrostatics and induction. Thi",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/autodoc_testsuite_corepsi4-1.html:21606,energy,energy,21606,psi4manual/1.5.0/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/autodoc_testsuite_corepsi4-1.html,4,['energy'],['energy']
Energy Efficiency,"aug-cc-pVQZ'; if not ('scf_scheme' in kwargs):; kwargs['scf_scheme'] = highest_1. if not ('corl_wfn' in kwargs):; kwargs['corl_wfn'] = 'mp2'; if not ('corl_basis' in kwargs):; kwargs['corl_basis'] = 'aug-cc-pV[TQ]Z'; if not ('corl_scheme' in kwargs):; kwargs['corl_scheme'] = corl_xtpl_helgaker_2. if not ('delta_wfn' in kwargs):; kwargs['delta_wfn'] = 'ccsd(t)'; if not ('delta_wfn_lesser' in kwargs):; kwargs['delta_wfn_lesser'] = 'mp2'; if not ('delta_basis' in kwargs):; kwargs['delta_basis'] = 'aug-cc-pVTZ'; if not ('delta_scheme' in kwargs):; kwargs['delta_scheme'] = highest_1. return cbs(name, **kwargs). #def run_mp2_5(name, **kwargs):; # r""""""Function that computes MP2.5 energy from results of a FNOCC; # MP3 calculation.; #; # .. math:: E_{total}^{\text{MP2.5}} = E_{total,\; \text{SCF}} \; + E_{corl,\; \text{MP2}} + E_{corl, \; \text{MP3}}; #; # :PSI variables: ; #; # .. hlist:: ; # :columns: 1 ; # ; # * :psivar:`MP2.5 TOTAL ENERGY <MP2.5TOTALENERGY>` ; # * :psivar:`MP2.5 CORRELATION ENERGY <MP2.5CORRELATIONENERGY>` ; #; # >>> energy('mp2.5'); #; # """"""; # lowername = name.lower(); # kwargs = kwargs_lower(kwargs); #; # # Run detci calculation and collect conventional quantities; # energy('mp3', **kwargs); # e_scf = PsiMod.get_variable('SCF TOTAL ENERGY'); # ce_mp2 = PsiMod.get_variable('MP2 CORRELATION ENERGY'); # ce_mp3 = PsiMod.get_variable('MP3 CORRELATION ENERGY'); # e_mp2 = e_scf + ce_mp2; # e_mp3 = e_scf + ce_mp3; #; # # Compute quantities particular to MP2.5; # ce_mp25 = 0.5 * (ce_mp2 + ce_mp3); # e_mp25 = e_scf + ce_mp25; # PsiMod.set_variable('MP2.5 CORRELATION ENERGY', ce_mp25); # PsiMod.set_variable('MP2.5 TOTAL ENERGY', e_mp25); # PsiMod.set_variable('CURRENT CORRELATION ENERGY', ce_mp25); # PsiMod.set_variable('CURRENT ENERGY', e_mp25); #; # # build string of title banner and print results; # banners = ''; # banners += """"""PsiMod.print_out('\\n')\n""""""; # banners += """"""banner(' MP2.5 ')\n""""""; # banners += """"""PsiMod.print_out('\\n')\n\n""""""; # exec(banners",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/_modules/aliases.html:2538,ENERGY,ENERGY,2538,psi4manual/4.0b4/_modules/aliases.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/aliases.html,1,['ENERGY'],['ENERGY']
Energy Efficiency,"aug-cc-pV[DT]Z}}\right) - \mathcal{F}_{\text{corl_xtpl_helgaker_2}} \left(E_{\text{corl},\; \text{MP2}}^{\text{aug-cc-pV[DT]Z}}\right)\]. Energy Methods; The presence of a stage_wfn keyword is the indicator to incorporate; (and check for stage_basis and stage_scheme keywords) and compute; that stage in defining the CBS energy.; The cbs() function requires, at a minimum, name='scf' and scf_basis; keywords to be specified for reference-step only jobs and name and; corl_basis keywords for correlated jobs.; The following energy methods have been set up for cbs(). scf; hf; mp2; mp2.5; mp3; mp4(sdq); mp4; mpn. omp2; omp2.5; omp3; olccd; lccd; lccsd; cepa(0); cepa(1). cepa(3); acpf; aqcc; qcisd; cc2; ccsd; fno-ccsd; bccd. cc3; qcisd(t); ccsd(t); fno-ccsd(t); bccd(t); cisd; cisdt. cisdtq; cin; fci; mrccsd; mrccsd(t); mrccsdt; mrccsdt(q). Parameters:; name (string) – 'scf' || 'ccsd' || etc.; First argument, usually unlabeled. Indicates the computational method; for the correlation energy, unless only reference step to be performed,; in which case should be 'scf'. Overruled if stage_wfn keywords supplied. scf_wfn (string) – \(\Rightarrow\) 'scf' \(\Leftarrow\) || 'c4-scf' || etc.; Indicates the energy method for which the reference energy is to be; obtained. Generally unnecessary, as ‘scf’ is the scf in PSI4 but; can be used to direct lone scf components to run in PSI4 or Cfour; in a mixed-program composite method. corl_wfn (string) – 'mp2' || 'ccsd(t)' || etc.; Indicates the energy method for which the correlation energy is to be; obtained. Can also be specified with name or as the unlabeled; first argument to the function. delta_wfn (string) – 'ccsd' || 'ccsd(t)' || etc.; Indicates the (superior) energy method for which a delta correction; to the correlation energy is to be obtained. delta_wfn_lesser (string) – \(\Rightarrow\) corl_wfn \(\Leftarrow\) || 'mp2' || etc.; Indicates the inferior energy method for which a delta correction; to the correlation energy is to be obtai",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.cbs.html:5124,energy,energy,5124,psi4manual/1.1.0/api/psi4.driver.cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.cbs.html,3,['energy'],['energy']
Energy Efficiency,"ault for cc_program; set cfour_calc_level ccsd; energy('cfour'). runs in ecc since Cfour’s default overwritten by keyword; set cfour_calc_level ccsd; set cfour_cc_program ecc; energy('cfour'). runs in ecc since that’s best practice for the requested ccsd; energy('c4-ccsd'). runs in vcc since hidden default overwritten by keyword; set cfour_cc_program vcc; energy('c4-ccsd'). Specifying certain keywords that are nominally applicable for pure-Psi4 modules directs them to fulfil analogous roles; in the Cfour program (e.g., MAXITER is used to set; CFOUR_SCF_MAXCYC). This keyword translation only takes place; if the keywords are explicitly set in the input file (part of that; contract that you mean it), meaning that Psi4‘s defaults don’t; get imposed on Cfour. Also, in the case where a translatable pure-Psi4 keyword and its translation Cfour keyword are both set,; the value attached to the latter is always used. Below are a few; clarifying examples. uses SCF conv crit since that’s Cfour’s default; for CFOUR_SCF_CONV; energy('c4-scf'). uses SCF conv crit since default overwritten by; keyword; set cfour_scf_conv 6; energy('c4-scf'). uses SCF conv crit since default overwritten by; SCF module keyword; set d_convergence 5; energy('c4-scf'). uses SCF conv crit since default overwritten by; SCF module keyword (local scope works, too) where; the Psi4‘s more flexible float input has been rounded down to; the integer required by Cfour; set scf d_convergence 5e-6; energy('c4-scf'). uses SCF conv crit since default overwritten; and Cfour module keyword trumps Psi4 SCF module keyword; set cfour_scf_conv 6; set d_convergence 8; energy('c4-scf'). The keyword translation feature is still in the proof-of-principle; stage, so only a handful (found here) of keywords participate. Note; Longtime Cfour users who may consider this keyword; translation a flaw rather than a feature can avoid it entirely by; confining keywords to the Cfour module along with; BASIS and PUREAM (opt, too?). Misc. Run",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/cfour-1.html:33172,energy,energy,33172,psi4manual/1.0.0/cfour-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/cfour-1.html,2,['energy'],['energy']
Energy Efficiency,"ault is ``'off'`` for energies,; ``'on'`` for gradients and Hessians. Note that the calculation of total; counterpoise corrected energies implies the calculation of the energies of; monomers in the monomer basis, hence specifying ``return_total_data = True``; may carry out more computations than ``return_total_data = False``. :type levels: dict; :param levels: ``{1: 'ccsd(t)', 2: 'mp2', 'supersystem': 'scf'}`` || ``{1: 2, 2: 'ccsd(t)', 3: 'mp2'}`` || etc. Dictionary of different levels of theory for different levels of expansion; Note that method_string is not used in this case. ``supersystem`` computes; all higher order n-body effects up to the number of fragments. :type embedding_charges: dict; :param embedding_charges: ``{1: [-0.834, 0.417, 0.417], ..}``. Dictionary of atom-centered point charges. keys: 1-based index of fragment, values: list of charges for each fragment. :type charge_method: str; :param charge_method: ``scf/6-31g`` || ``b3lyp/6-31g*`` || etc. Method to compute point charges for monomers. Overridden by ``embedding_charges``; if both are provided. :type charge_type: str; :param charge_type: ``MULLIKEN_CHARGES`` || ``LOWDIN_CHARGES``. Default is ``MULLIKEN_CHARGES``; """""". # Initialize dictionaries for easy data passing; metadata, component_results, nbody_results = {}, {}, {}. # Parse some kwargs; kwargs = p4util.kwargs_lower(kwargs); if kwargs.get('levels', False):; return driver_nbody_helper.multi_level(func, **kwargs); metadata['ptype'] = kwargs.pop('ptype', None); metadata['return_wfn'] = kwargs.pop('return_wfn', False); metadata['return_total_data'] = kwargs.pop('return_total_data', None); metadata['molecule'] = kwargs.pop('molecule', core.get_active_molecule()); metadata['molecule'].update_geometry(); metadata['molecule'].fix_com(True); metadata['molecule'].fix_orientation(True); metadata['embedding_charges'] = kwargs.get('embedding_charges', False); metadata['kwargs'] = kwargs; core.clean_variables(). if metadata['ptype'] not in ['energy', 'g",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_nbody.html:6914,charge,charges,6914,psi4manual/1.4.0/_modules/psi4/driver/driver_nbody.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_nbody.html,4,['charge'],['charges']
Energy Efficiency,"ault modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); mtd_type = core.get_global_option('MP_TYPE') if core.has_global_option_changed(""MP_TYPE"") else ""DF""; module = core.get_global_option('QC_MODULE'); all_electron = (core.get_global_option('FREEZE_CORE') == ""FALSE""); # Considering only [df]occ. func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if all_electron:; if module in ['', 'OCC']:; func = run_occ_gradient; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc_gradient; elif reference == 'UHF':; if mtd_type == 'CONV':; if all_electron:; if module in ['', 'OCC']:; func = run_occ_gradient; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc_gradient. if func is None:; raise ManagedMethodError(['select_mp3_gradient', name, 'MP_TYPE', mtd_type, reference, module, all_electron]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_omp3(name, **kwargs):; """"""Function selecting the algorithm for an OMP3 energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); mtd_type = core.get_global_option('MP_TYPE'); module = core.get_global_option('QC_MODULE'); # Considering only [df]occ. func = None; if reference in ['RHF', 'UHF', 'ROHF', 'RKS', 'UKS']:; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc. if func is None:; raise ManagedMethodError(['select_omp3', name, 'MP_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_omp3_gradient(name, **kwargs):; """"""Function selecting the algorithm for an OMP3 gradient call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); mtd_type = core.get_global_option('MP_TYPE'); module = core.get_gl",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html:12870,energy,energy,12870,psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,6,['energy'],['energy']
Energy Efficiency,"ault. ACTIVE (PSIMRCC); PSIMRCC — The number of active orbitals per irrep. Type: array; Default: No Default. ADD_AUXILIARY_BONDS (OPTKING); OPTKING — Do add bond coordinates at nearby atoms for non-bonded systems?. Type: boolean; Default: false. AEL (CCDENSITY); CCDENSITY (Expert) — Do compute the approximate excitation level? See Stanton and Bartlett, JCP, 98, 1993, 7034. Type: boolean; Default: false. AIO_CPHF (SAPT); SAPT — Do use asynchronous disk I/O in the solution of the CPHF equations? Use may speed up the computation slightly at the cost of spawning an additional thread. Type: boolean; Default: false. AIO_DF_INTS (SAPT); SAPT — Do use asynchronous disk I/O in the formation of the DF integrals? Use may speed up the computation slightly at the cost of spawning an additional thread. Type: boolean; Default: false. ALGORITHM (DCFT); DCFT — The algorithm to use for the density cumulant and orbital updates in the energy computation. Two-step algorithm (default) is generally more efficient and shows better convergence than simultaneous. Type: string; Possible Values: TWOSTEP, SIMULTANEOUS, QC; Default: TWOSTEP. ANALYZE (CCENERGY); CCENERGY — Do analyze T2 amplitudes. Type: boolean; Default: false. ANALYZE (CCRESPONSE); CCRESPONSE — Do analyze X2 amplitudes. Type: boolean; Default: false. AO_BASIS (CCDENSITY); CCDENSITY — The algorithm to use for the terms. Type: string; Possible Values: NONE, DISK, DIRECT; Default: NONE. AO_BASIS (CCENERGY); CCENERGY (Expert) — The algorithm to use for the terms If AO_BASIS is NONE, the MO-basis integrals will be used; if AO_BASIS is DISK, the AO-basis integrals stored on disk will be used; if AO_BASIS is DIRECT, the AO-basis integrals will be computed on the fly as necessary. NB: The DIRECT option is not fully implemented and should only be used by experts. Default is NONE. Note: The developers recommend use of this keyword only as a last resort because it significantly slows the calculation. The current algorithms for handling the",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/autodoc_glossary_options_c-1.html:2137,efficient,efficient,2137,psi4manual/4.0b3/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodoc_glossary_options_c-1.html,2,['efficient'],['efficient']
Energy Efficiency,"ault. ACTIVE (PSIMRCC); PSIMRCC — The number of active orbitals per irrep. Type: array; Default: No Default. ADD_AUXILIARY_BONDS (OPTKING); OPTKING — Do add bond coordinates at nearby atoms for non-bonded systems?. Type: boolean; Default: false. AEL (CCDENSITY); CCDENSITY (Expert) — Do compute the approximate excitation level? See Stanton and Bartlett, JCP, 98, 1993, 7034. Type: boolean; Default: false. AIO_CPHF (SAPT); SAPT — Do use asynchronous disk I/O in the solution of the CPHF equations? Use may speed up the computation slightly at the cost of spawning an additional thread. Type: boolean; Default: false. AIO_DF_INTS (SAPT); SAPT — Do use asynchronous disk I/O in the formation of the DF integrals? Use may speed up the computation slightly at the cost of spawning an additional thread. Type: boolean; Default: false. ALGORITHM (DCFT); DCFT — The algorithm to use for the density cumulant and orbital updates in the energy computation. Two-step algorithm (default) is generally more efficient and shows better convergence than simultaneous. Type: string; Possible Values: TWOSTEP, SIMULTANEOUS; Default: TWOSTEP. ANALYZE (CCENERGY); CCENERGY — Do ?. Type: boolean; Default: false. ANALYZE (CCRESPONSE); CCRESPONSE — Do ?. Type: boolean; Default: false. AO_BASIS (CCDENSITY); CCDENSITY — The algorithm to use for the terms. Type: string; Possible Values: NONE, DISK, DIRECT; Default: NONE. AO_BASIS (CCENERGY); CCENERGY (Expert) — The algorithm to use for the terms If AO_BASIS is NONE, the MO-basis integrals will be used; if AO_BASIS is DISK, the AO-basis integrals stored on disk will be used; if AO_BASIS is DIRECT, the AO-basis integrals will be computed on the fly as necessary. NB: The DIRECT option is not fully implemented and should only be used by experts. Default is NONE. Note: The developers recommend use of this keyword only as a last resort because it significantly slows the calculation. The current algorithms for handling the MO-basis four-virtual-index integrals have ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/autodoc_glossary_options_c-1.html:1878,efficient,efficient,1878,psi4manual/4.0b2/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/autodoc_glossary_options_c-1.html,2,['efficient'],['efficient']
Energy Efficiency,"ault: NONE. Expert¶. CACHELEVEL¶. Controls how to cache quantities within the DPD library. Type: integer; Default: 2. DAMPING_PERCENTAGE¶. The amount (percentage) of damping to apply to the orbital update procedure: 0 will result in a full update, 100 will completely stall the update. A value around 20 (which corresponds to 20% of the previous iteration’s density being mixed into the current iteration) can help in cases where oscillatory convergence is observed. Type: double; Default: 0.0. DCT_GUESS¶. Whether to read the orbitals from a previous computation, or to compute an MP2 guess. Type: string; Possible Values: CC, BCC, MP2, DCT; Default: MP2. DIIS_MAX_VECS¶. Maximum number of error vectors stored for DIIS extrapolation. Type: integer; Default: 6. DIIS_MIN_VECS¶. Minimum number of error vectors stored for DIIS extrapolation. Type: integer; Default: 3. ENERGY_LEVEL_SHIFT¶. Level shift applied to the diagonal of the density-weighted Fock operator. While this shift can improve convergence, it does change the DCT energy. Type: double; Default: 0.0. INTS_TOLERANCE¶. Schwarz screening threshold. Mininum absolute value below which TEI are neglected. Type: conv double; Default: 1e-14. ORBITAL_LEVEL_SHIFT¶. The shift applied to the denominator in the orbital update iterations. Type: double; Default: 0.0. RELAX_GUESS_ORBITALS¶. Controls whether to relax the guess orbitals by taking the guess density cumulant and performing orbital update on the first macroiteration (for ALOGRITHM = TWOSTEP only). Type: boolean; Default: false. STABILITY_ADD_VECTORS¶. The number of vectors that can be added simultaneously into the subspace for Davidson’s diagonalization in stability check. Type: integer; Default: 20. STABILITY_AUGMENT_SPACE_TOL¶. The value of the rms of the residual in Schmidt orthogonalization which is used as a threshold for augmenting the vector subspace in stability check. Type: conv double; Default: 0.1. STABILITY_CHECK¶. Performs stability analysis of the DCT energy.",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/autodir_options_c/module__dct-1.html:5053,energy,energy,5053,psi4manual/1.4.0/autodir_options_c/module__dct-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/module__dct-1.html,18,['energy'],['energy']
Energy Efficiency,"ault: No Default. PROPERTIES_ORIGIN¶. Either a set of 3 coordinates, or a string (see manual) describing the origin about which one-electron properties are computed. Type: array; Default: No Default. PUREAM¶. Do use pure angular momentum basis functions? If not explicitly set, the default comes from the basis set. Type: boolean; Default: true. SOCC¶. An array containing the number of singly-occupied orbitals per irrep (in Cotton order). The value of DOCC should also be set. Type: array; Default: No Default. UNITS¶. Units used in geometry specification. Type: string; Possible Values: BOHR, AU, A.U., ANGSTROMS, ANG, ANGSTROM; Default: ANGSTROMS. WRITER_FILE_LABEL¶. Base filename for text files written by PSI, such as the MOLDEN output file, the Hessian file, the internal coordinate file, etc. Use the add_str_i function to make this string case sensitive. Type: string; Default: No Default. Expert¶. DEBUG¶. The amount of information to print to the output file. Type: integer; Default: 0. DERTYPE¶. Derivative level. Type: string; Possible Values: NONE, FIRST, SECOND, RESPONSE; Default: NONE. DIE_IF_NOT_CONVERGED¶. PSI4 dies if energy does not converge. Type: boolean; Default: true. MAT_NUM_COLUMN_PRINT¶. Number of columns to print in calls to Matrix::print_mat. Type: integer; Default: 5. WFN¶. Wavefunction type. Type: string; Default: SCF. Table Of Contents. GLOBALS; General; BENCH; DOCC; FREEZE_CORE; FROZEN_DOCC; FROZEN_UOCC; NUM_FROZEN_DOCC; NUM_FROZEN_UOCC; PRINT; PROPERTIES; PROPERTIES_ORIGIN; PUREAM; SOCC; UNITS; WRITER_FILE_LABEL. Expert; DEBUG; DERTYPE; DIE_IF_NOT_CONVERGED; MAT_NUM_COLUMN_PRINT; WFN. Previous topic; Keywords by Module; Next topic; BENCH; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » ; Appendices »; Keywords by Module ». © Copyright 2013, The Psi4 Project.; Last updated on Apr 25, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/autodir_options_c/module__globals-1.html:3221,energy,energy,3221,psi4manual/4.0b4/autodir_options_c/module__globals-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/autodir_options_c/module__globals-1.html,4,['energy'],['energy']
Energy Efficiency,"ault: No Default. PROPERTIES_ORIGIN¶. Either a set of 3 coordinates, or a string (see manual) describing the origin about which one-electron properties are computed. Type: array; Default: No Default. PUREAM¶. Do use pure angular momentum basis functions? If not explicitly set, the default comes from the basis set. Type: boolean; Default: true. SOCC¶. An array containing the number of singly-occupied orbitals per irrep (in Cotton order). The value of DOCC should also be set. Type: array; Default: No Default. UNITS¶. Units used in geometry specification. Type: string; Possible Values: BOHR, AU, A.U., ANGSTROMS, ANG, ANGSTROM; Default: ANGSTROMS. WRITER_FILE_LABEL¶. Base filename for text files written by PSI, such as the MOLDEN output file, the Hessian file, the internal coordinate file, etc. Use the add_str_i function to make this string case sensitive. Type: string; Default: No Default. Expert¶. DEBUG¶. The amount of information to print to the output file. Type: integer; Default: 0. DERTYPE¶. Derivative level. Type: string; Possible Values: NONE, FIRST, SECOND, RESPONSE; Default: NONE. DIE_IF_NOT_CONVERGED¶. PSI4 dies if energy does not converge. Type: boolean; Default: true. MAT_NUM_COLUMN_PRINT¶. Number of columns to print in calls to Matrix::print_mat. Type: integer; Default: 5. WFN¶. Wavefunction type. Type: string; Default: SCF. Table Of Contents. GLOBALS; General; BENCH; DOCC; FREEZE_CORE; FROZEN_DOCC; FROZEN_UOCC; NUM_FROZEN_DOCC; NUM_FROZEN_UOCC; PRINT; PROPERTIES; PROPERTIES_ORIGIN; PUREAM; SOCC; UNITS; WRITER_FILE_LABEL. Expert; DEBUG; DERTYPE; DIE_IF_NOT_CONVERGED; MAT_NUM_COLUMN_PRINT; WFN. Previous topic; Keywords by Module; Next topic; BENCH; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta5] » ; Appendices »; Keywords by Module ». © Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/autodir_options_c/module__globals-1.html:3221,energy,energy,3221,psi4manual/4.0b5/autodir_options_c/module__globals-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/module__globals-1.html,4,['energy'],['energy']
Energy Efficiency,"ault: RHF. RESTART_EOM_CC3¶. Do ?. Type: boolean; Default: false. RHF_TRIPLETS¶. Do ?. Type: boolean; Default: false. ROOTS_PER_IRREP¶. Number of excited states per irreducible representation for EOM-CC and CC-LR calculations. Irreps denote the final state symmetry, not the symmetry of the transition. Type: array; Default: No Default. R_CONVERGENCE¶. Convergence criterion for norm of the residual vector in the Davidson algorithm for CC-EOM. Type: conv double; Default: 1e-6. SCHMIDT_ADD_RESIDUAL_TOLERANCE¶. Minimum absolute value above which a guess vector to a root is added to the Davidson algorithm in the EOM-CC iterative procedure. Type: conv double; Default: 1e-3. SEMICANONICAL¶. Convert ROHF MOs to semicanonical MOs. Type: boolean; Default: true. SINGLES_PRINT¶. Do print information on the iterative solution to the single-excitation EOM-CC problem used as a guess to full EOM-CC?. Type: boolean; Default: false. SS_E_CONVERGENCE¶. Convergence criterion for excitation energy (change) in the Davidson algorithm for the CIS guess to CC-EOM. Type: conv double; Default: 1e-6. SS_R_CONVERGENCE¶. Convergence criterion for norm of the residual vector in the Davidson algorithm for the CIS guess to CC-EOM. Type: conv double; Default: 1e-6. SS_SKIP_DIAG¶. Do ?. Type: boolean; Default: false. SS_VECS_PER_ROOT¶. Type: integer; Default: 5. T3_WS_INCORE¶. Do ?. Type: boolean; Default: false. VECS_CC3¶. Type: integer; Default: 10. VECS_PER_ROOT¶. Type: integer; Default: 12. Expert¶. EXCITATION_RANGE¶. The depth into the occupied and valence spaces from which one-electron excitations are seeded into the Davidson guess to the CIS (the default of 2 includes all single excitations between HOMO-1, HOMO, LUMO, and LUMO+1). This CIS is in turn the Davidson guess to the EOM-CC. Expand to capture more exotic excited states in the EOM-CC calculation. Type: integer; Default: 2. WFN¶. Wavefunction type. Type: string; Possible Values: EOM_CCSD, EOM_CC2, EOM_CC3; Default: EOM_CCSD. Table Of Con",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/autodir_options_c/module__cceom-1.html:3433,energy,energy,3433,psi4manual/4.0b2/autodir_options_c/module__cceom-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/autodir_options_c/module__cceom-1.html,4,['energy'],['energy']
Energy Efficiency,"ault: false. CFOUR_ESTATE_CONV¶. Specifies the threshold used in converging CC-LR/EOM-CC calculations. The iterative diagonalization is continued until the RMS residual falls below \(10^{-N}\) with \(N\) as the value specified with this keyword. Type: integer; Default: 5. CFOUR_ESTATE_MAXCYC¶. The maximum number of expansion vectors used in the solution of EOMCC equations (Default: 20, hard-coded to 4 in triples calculations). Type: integer; Default: 20. CFOUR_ESTATE_PROP¶. This keyword applies only to EOM-CC calculations and specifies whether any excited or ionized state one-electron properties are to be calculated. Proper use of this keyword requires a relatively advanced knowledge of quantum chemistry and the available options are discussed here. The options are: OFF (=0) [no properties or transition moments are calculated]; EXPECTATION (=1) [transition moments and dipole strengths are calculated along with selected one-electron properties which are evaluated as expectation values]; UNRELAXED (=2) [selected one-electron properties are calculated in an approximation that neglects relaxation of molecular orbitals]; RESPONSE (=3) [selected one-electron properties are calculated as analytic first derivatives of the energy]. Except for EOMCC calculations on two-electron systems (which are exact), properties obtained by the three approaches will not be equivalent. The default value for this keyword is slightly complicated. For TDA calculations, the default is EXPECTATION since the evaluation of transition moments involves only a negligible amount of additional computation relative to the evaluation of the excitation energies. For EOMCC, the default is OFF since evaluation of any transition moments or properties requires approximately twice the computational time. Transition moments and dipole strengths are evaluated by default for all values of ESTATE_PROP other than OFF. Type: string; Possible Values: OFF, EXPECTATION, UNRELAXED, RESPONSE; Default: No Default. CFOUR_ES",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/autodir_options_c/module__cfour-1.html:18159,energy,energy,18159,psi4manual/1.3.2/autodir_options_c/module__cfour-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/autodir_options_c/module__cfour-1.html,24,['energy'],['energy']
Energy Efficiency,"ause; CI wavefunctions which go beyond CISD (such as RAS CI) are fairly complex,; typically the DETCI code will be used in cases where the; tradeoffs between computational expense and completeness of the; model space are nontrivial. Hence, the user is advised to develop; a good working knowledge of multi-reference and RAS CI methods before; attempting to use the program for a production-level project. This user’s; manual will provide only an elementary introduction to the most; important keywords. Additional information is available in the complete; list of keywords for DETCI provided in Appendix DETCI.; For single-reference CI computations, the easiest way to invoke a CI; computation with DETCI is simply to call energy(), optimize(), etc.,; with the common name for that CI wavefunction, like energy('cisd'); for a CISD single-point energy. The Python driver; recognizes cisd, cisdt, and cisdtq. As mentioned above, codes; written specifically for CISD will be more efficient than DETCI for a; CISD computation, and energy('cisd') by default will call other,; more efficient modules. To force a CISD computation with DETCI,; set QC_MODULE = DETCI.; Higher order single-reference CI wavefunctions, like those including singles through; 6-fold excitations, can be invoked using numbers, like ci6. A full; CI can be specified by fci. More complicated CI computations, like; RASCI, can be performed by setting the appropriate keywords and calling the; module generically like energy('detci'). The latter approach; will also work for any of the previously-mentioned CI wavefunctions for; which the driver has built-in shortcuts, so long as the relevant options; (especially EX_LEVEL) are set appropriately. Some; examples of single-refence CI, RASCI, and full CI computations are provided; in psi4/samples. Orbital spaces for CI computations¶. CI (e.g., CISD, FCI); RASCI; CASCI. FROZEN_UOCC; FROZEN_UOCC; FROZEN_UOCC 1. (all orbitals not in; FROZEN_UOCC; or FROZEN_DOCC; are included in CI); R",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/detci-1.html:4966,efficient,efficient,4966,psi4manual/1.4.0/detci-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/detci-1.html,15,"['efficient', 'energy']","['efficient', 'energy']"
Energy Efficiency,"ause; CI wavefunctions which go beyond CISD (such as RAS CI) are fairly complex,; typically the DETCI code will be used in cases where the; tradeoffs between computational expense and completeness of the; model space are nontrivial. Hence, the user is advised to develop; a good working knowledge of multi-reference and RAS CI methods before; attempting to use the program for a production-level project. This user’s; manual will provide only an elementary introduction to the most; important keywords. Additional information is available in the complete; list of keywords for DETCI provided in Appendix DETCI.; For single-reference CI computations, the easiest way to invoke a CI; computation with DETCI is simply to call energy(), optimize(), etc.,; with the common name for that CI wavefunction, like energy('cisd'); for a CISD single-point energy. The Python driver; recognizes cisd, cisdt, and cisdtq. As mentioned above, codes; written specifically for CISD will be more efficient than DETCI for a; CISD computation, and energy('cisd') by default will call other,; more efficient modules. To force a CISD computation with DETCI,; set QC_MODULE = DETCI.; Higher order single-reference CI wavefunctions, like those including singles through; 6-fold excitations, can be invoked using numbers, like ci6. A full; CI can be specified by fci. More complicated CI computations, like; RASCI, can be performed by setting the appropriate keywords and calling the; module generically like energy('detci'). The latter approach; will also work for any of the previously-mentioned CI wavefunctions for; which the driver has built-in shortcuts, so long as the relevant options; (especially EX_LEVEL) are set appropriately. Some; examples of single-refence CI, RASCI, and full CI computations are provided; in psi4/samples. Orbital spaces for CI computations¶. CI (e.g., CISD, FCI); RASCI; CASCI. FROZEN_UOCC; FROZEN_UOCC; FROZEN_UOCC [1]. (all orbitals not in; FROZEN_UOCC; or FROZEN_DOCC; are included in CI);",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/detci.html:4966,efficient,efficient,4966,psi4manual/1.7.x/detci.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/detci.html,12,"['efficient', 'energy']","['efficient', 'energy']"
Energy Efficiency,"automatically. However, in order to perform geometry optimizations and frequency computations with SOS-OMP2, one needs to set ‘DO_SOS’ to true. Type: boolean; Default: false. E3_SCALE¶. Scaling value for 3rd order energy correction (S. Grimme, Vol. 24, pp. 1529, J. Comput. Chem.). Type: double; Default: 0.25. EA_POLES¶. Do compute OCC poles for electron affinities? Only valid for OMP2. Type: boolean; Default: false. EKT_EA¶. Do compute virtual orbital energies based on extended Koopmans’ theorem?. Type: boolean; Default: false. EKT_IP¶. Do compute occupied orbital energies based on extended Koopmans’ theorem?. Type: boolean; Default: false. EP_EA_POLES¶. Do compute EP-OCC poles for electron affinities? Only valid for OMP2. Type: boolean; Default: false. EP_IP_POLES¶. Do compute EP-OCC poles for ionization potentials? Only valid OMP2. Type: boolean; Default: false. EP_MAXITER¶. Maximum number of electron propagator iterations. Type: integer; Default: 30. E_CONVERGENCE¶. Convergence criterion for energy. See Table Post-SCF Convergence for default convergence criteria for different calculation types. Type: conv double; Default: 1e-6. IP_POLES¶. Do compute OCC poles for ionization potentials? Only valid OMP2. Type: boolean; Default: false. LEVEL_SHIFT¶. Level shift to aid convergence. Type: double; Default: 0.02. LINEQ_SOLVER¶. The solver will be used for simultaneous linear equations. Type: string; Possible Values: CDGESV, FLIN, POPLE; Default: CDGESV. MAX_MOGRAD_CONVERGENCE¶. Convergence criterion for maximum orbital gradient. Type: conv double; Default: 1e-3. MOGRAD_DAMPING¶. Damping factor for the orbital gradient (Rendell et al., JCP, vol. 87, pp. 5976, 1987). Type: double; Default: 1.0. MO_DIIS_NUM_VECS¶. Number of vectors used in orbital DIIS. Type: integer; Default: 6. MO_MAXITER¶. Maximum number of iterations to determine the orbitals. Type: integer; Default: 50. MO_READ¶. Do read coefficient matrices from external files of a previous OMP2 or OMP3 computation?.",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/autodir_options_c/module__occ-1.html:3209,energy,energy,3209,psi4manual/1.3.2/autodir_options_c/module__occ-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/autodir_options_c/module__occ-1.html,12,['energy'],['energy']
Energy Efficiency,"automatically. However, in order to perform geometry optimizations and frequency computations with SOS-OMP2, one needs to set ‘DO_SOS’ to true. Type: boolean; Default: false. E3_SCALE¶. Scaling value for 3rd order energy correction (S. Grimme, Vol. 24, pp. 1529, J. Comput. Chem.). Type: double; Default: 0.25. EA_POLES¶. Do compute OCC poles for electron affinities? Only valid for OMP2. Type: boolean; Default: false. EKT_EA¶. Do compute virtual orbital energies based on extended Koopmans’ theorem?. Type: boolean; Default: false. EKT_IP¶. Do compute occupied orbital energies based on extended Koopmans’ theorem?. Type: boolean; Default: false. EP_EA_POLES¶. Do compute EP-OCC poles for electron affinities? Only valid for OMP2. Type: boolean; Default: false. EP_IP_POLES¶. Do compute EP-OCC poles for ionization potentials? Only valid OMP2. Type: boolean; Default: false. EP_MAXITER¶. Maximum number of electron propagator iterations. Type: integer; Default: 30. E_CONVERGENCE¶. Convergence criterion for energy. See Table Post-SCF Convergence for default convergence criteria for different calculation types. Type: conv double; Default: 1e-8. IP_POLES¶. Do compute OCC poles for ionization potentials? Only valid OMP2. Type: boolean; Default: false. LEVEL_SHIFT¶. Level shift to aid convergence. Type: double; Default: 0.02. LINEQ_SOLVER¶. The solver will be used for simultaneous linear equations. Type: string; Possible Values: CDGESV, FLIN, POPLE; Default: CDGESV. MAX_MOGRAD_CONVERGENCE¶. Convergence criterion for maximum orbital gradient. Type: conv double; Default: 1e-3. MOGRAD_DAMPING¶. Damping factor for the orbital gradient (Rendell et al., JCP, vol. 87, pp. 5976, 1987). Type: double; Default: 1.0. MO_DIIS_NUM_VECS¶. Number of vectors used in orbital DIIS. Type: integer; Default: 6. MO_MAXITER¶. Maximum number of iterations to determine the orbitals. Type: integer; Default: 50. MO_READ¶. Do read coefficient matrices from external files of a previous OMP2 or OMP3 computation?.",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/autodir_options_c/module__occ-1.html:3224,energy,energy,3224,psi4manual/4.0b4/autodir_options_c/module__occ-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/autodir_options_c/module__occ-1.html,4,['energy'],['energy']
Energy Efficiency,"auxiliary functions iwth Df coefficients. addCharge(self, Z, x, y, z); Add a charge Z at (x,y,z). appendCharges(self, arg0); Append a vector of charge tuples to a current ExternalPotential. clear(self); Reset the field to zero (eliminates all entries). computeExternExternInteraction(self, arg0, arg1); Compute the interaction between this potential and other external potential. computeNuclearEnergy(self, arg0); Compute the contribution to the nuclear repulsion energy for the given molecule. computePotentialMatrix(self, basis); Compute the external potential matrix in the given basis set. getCharges(self); Get the vector of charge tuples. print_out(self); Print python print helper to the outfile. setName(self, arg0); Sets the name. Methods Documentation. addBasis(self: psi4.core.ExternalPotential, basis: psi4.core.BasisSet, coefs: psi4.core.Vector) → None¶; Add a basis of S auxiliary functions iwth Df coefficients. addCharge(self: psi4.core.ExternalPotential, Z: float, x: float, y: float, z: float) → None¶; Add a charge Z at (x,y,z). appendCharges(self: psi4.core.ExternalPotential, arg0: List[Tuple[float, float, float, float]]) → None¶; Append a vector of charge tuples to a current ExternalPotential. clear(self: psi4.core.ExternalPotential) → None¶; Reset the field to zero (eliminates all entries). computeExternExternInteraction(self: psi4.core.ExternalPotential, arg0: psi4.core.ExternalPotential, arg1: bool) → float¶; Compute the interaction between this potential and other external potential. computeNuclearEnergy(self: psi4.core.ExternalPotential, arg0: psi4.core.Molecule) → float¶; Compute the contribution to the nuclear repulsion energy for the given molecule. computePotentialMatrix(self: psi4.core.ExternalPotential, basis: psi4.core.BasisSet) → psi4.core.Matrix¶; Compute the external potential matrix in the given basis set. getCharges(self: psi4.core.ExternalPotential) → List[Tuple[float, float, float, float]]¶; Get the vector of charge tuples. print_out(self: ps",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/api/psi4.core.externalpotential.html:1401,charge,charge,1401,psi4manual/1.5.0/api/psi4.core.externalpotential.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/api/psi4.core.externalpotential.html,2,['charge'],['charge']
Energy Efficiency,"avefunction, arg0: str) → int¶; Removes the requested (case-insensitive) Matrix QC variable. Prefer del_variable(). del_potential_variable(self: psi4.core.Wavefunction, arg0: str) → int¶; Removes the requested (case-insensitive) ExternalPotential QC variable. (This function is provisional and might be removed in the future.). del_scalar_variable(self: psi4.core.Wavefunction, arg0: str) → int¶; Removes the requested (case-insensitive) double QC variable. Prefer del_variable(). del_variable(key)¶; Removes scalar or array QCVariable key from self if present. Parameters:. self (Wavefunction) – Wavefunction instance.; key (str) – Case-insensitive key to instance’s double or; Matrix storage maps. Return type:; None. doccpi(self: psi4.core.Wavefunction, assume_socc_alpha: bool = True) → psi4.core.Dimension¶; Returns the number of doubly occupied orbitals per irrep. efzc(self: psi4.core.Wavefunction) → float¶; Returns the frozen-core energy. energy(self: psi4.core.Wavefunction) → float¶; Returns the Wavefunction’s energy. epsilon_a(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the Alpha Eigenvalues. epsilon_a_subset(self: psi4.core.Wavefunction, basis: str, subset: str) → psi4.core.Vector¶; Returns the requested Alpha orbital energies subset. Parameters:. basis – {‘AO’, ‘SO’, ‘MO’}; MO or SO select for Pitzer-ordering the return vector in the full computational point group symmetry.; AO selects for Pitzer-ordering the return vector without point group symmetry.; subset – {‘ALL’, ‘ACTIVE’, ‘FROZEN’, ‘OCC’, ‘VIR’, ‘FROZEN_OCC’, ‘ACTIVE_OCC’, ‘ACTIVE_VIR’, ‘FROZEN_VIR’}; Which subspace of orbital energies should be returned?. Returns:; A Pitzer-ordered vector of the orbitals. Return type:; Vector. epsilon_b(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the Beta Eigenvalues. epsilon_b_subset(self: psi4.core.Wavefunction, basis: str, subset: str) → psi4.core.Vector¶; Returns the requested Beta orbital energies subset. Parameters:. basis – {‘AO’, ‘SO’, ‘",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/api/psi4.core.Wavefunction.html:14238,energy,energy,14238,psi4manual/master/api/psi4.core.Wavefunction.html,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.Wavefunction.html,2,['energy'],['energy']
Energy Efficiency,"avefunction. same_a_b_dens(self: psi4.core.Wavefunction) → bool¶; Returns true if the alpha and beta densities are the same. same_a_b_orbs(self: psi4.core.Wavefunction) → bool¶; Returns true if the alpha and beta orbitals are the same. scalar_variable(self: psi4.core.Wavefunction, arg0: str) → float¶; Returns the requested (case-insensitive) double QC variable. scalar_variables(self: psi4.core.Wavefunction) → Dict[str, float]¶; Returns the dictionary of all double QC variables. set_array(key, val)¶. Deprecated since version 1.4: Use psi4.core.Wavefunction.set_variable() instead. set_array_variable(self: psi4.core.Wavefunction, arg0: str, arg1: psi4.core.Matrix) → None¶; Sets the requested (case-insensitive) Matrix QC variable. Syncs with Wavefunction.gradient_ or hessian_ if CURRENT GRADIENT or HESSIAN. set_basisset(self: psi4.core.Wavefunction, arg0: str, arg1: psi4.core.BasisSet) → None¶; Sets the requested auxiliary basis. set_energy(self: psi4.core.Wavefunction, arg0: float) → None¶; Sets the Wavefunction’s energy. Syncs with Wavefunction’s QC variable CURRENT ENERGY. set_external_potential(self: psi4.core.Wavefunction, arg0: psi4.core.ExternalPotential) → None¶; Sets the requested external potential. set_frequencies(val)¶. Deprecated since version 1.4. set_gradient(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix) → None¶; Sets the Wavefunction’s gradient. Syncs with Wavefunction’s QC variable CURRENT GRADIENT. set_hessian(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix) → None¶; Sets the Wavefunction’s Hessian. Syncs with Wavefunction’s QC variable CURRENT HESSIAN. set_lagrangian(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix) → None¶; Sets the orbital Lagrangian matrix. set_legacy_frequencies(self: psi4.core.Wavefunction, arg0: psi4.core.Vector) → None¶; Sets the frequencies of the Hessian. set_module(self: psi4.core.Wavefunction, module: str) → None¶; Sets name of the last/highest level of theory module (internal or external) touching the wavef",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/api/psi4.core.ccwavefunction.html:21566,energy,energy,21566,psi4manual/1.4.0/api/psi4.core.ccwavefunction.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/api/psi4.core.ccwavefunction.html,16,['energy'],['energy']
Energy Efficiency,avigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; PSI Variables by Module; FNOCC. FNOCC¶. (T) CORRECTION ENERGY; ACPF CORRELATION ENERGY; ACPF OPPOSITE-SPIN CORRELATION ENERGY; ACPF SAME-SPIN CORRELATION ENERGY; ACPF TOTAL ENERGY; AQCC CORRELATION ENERGY; AQCC OPPOSITE-SPIN CORRELATION ENERGY; AQCC SAME-SPIN CORRELATION ENERGY; AQCC TOTAL ENERGY; CC D1 DIAGNOSTIC; CC T1 DIAGNOSTIC; CCSD CORRELATION ENERGY; CCSD DOUBLES ENERGY; CCSD ITERATIONS; CCSD OPPOSITE-SPIN CORRELATION ENERGY; CCSD PAIR ENERGIES (array); CCSD SAME-SPIN CORRELATION ENERGY; CCSD SINGLES ENERGY; CCSD TOTAL ENERGY; CCSD(T) CORRELATION ENERGY; CCSD(T) TOTAL ENERGY; CEPA(0) CORRELATION ENERGY; CEPA(0) DOUBLES ENERGY; CEPA(0) OPPOSITE-SPIN CORRELATION ENERGY; CEPA(0) SAME-SPIN CORRELATION ENERGY; CEPA(0) SINGLES ENERGY; CEPA(0) TOTAL ENERGY; CEPA(1) CORRELATION ENERGY; CEPA(1) OPPOSITE-SPIN CORRELATION ENERGY; CEPA(1) SAME-SPIN CORRELATION ENERGY; CEPA(1) TOTAL ENERGY; CEPA(2) CORRELATION ENERGY; CEPA(2) OPPOSITE-SPIN CORRELATION ENERGY; CEPA(2) SAME-SPIN CORRELATION ENERGY; CEPA(2) TOTAL ENERGY; CEPA(3) CORRELATION ENERGY; CEPA(3) OPPOSITE-SPIN CORRELATION ENERGY; CEPA(3) SAME-SPIN CORRELATION ENERGY; CEPA(3) TOTAL ENERGY; CISD CORRELATION ENERGY; CISD OPPOSITE-SPIN CORRELATION ENERGY; CISD SAME-SPIN CORRELATION ENERGY; CISD TOTAL ENERGY; CURRENT CORRELATION ENERGY; CURRENT ENERGY; LCCD CORRELATION ENERGY; LCCD DOUBLES ENERGY; LCCD OPPOSITE-SPIN CORRELATION ENERGY; LCCD SAME-SPIN CORRELATION ENERGY; LCCD SINGLES ENERGY; LCCD TOTAL ENERGY; LCCSD CORRELATION ENERGY; LCCSD DOUBLES ENERGY; LCCSD OPPOSITE-SPIN CORRELATION ENERGY; LCCSD SAME-SPIN CORRELATION ENERGY; LCCSD SINGLES ENERGY; LCCSD TOTAL ENERGY; MP2 CORRELATION ENERGY; MP2 DOUBLES ENERGY; MP2 OPPOSITE-SPIN CORRELATION ENERGY; MP2 SAME-SPIN CORRELATION ENERGY; MP2 SINGLES ENERGY; MP2 TOTAL ENERGY; MP2.5 CORRELATION ENERGY; MP2.5 DOUBLES ENERGY; MP2.5 OPPOSITE-SPIN CORRELATION ENERGY; MP2.5 SAME-SPIN CORRELATION ENERGY,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/autodir_psivariables/module__fnocc-1.html:145,ENERGY,ENERGY,145,psi4manual/1.4.0/autodir_psivariables/module__fnocc-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_psivariables/module__fnocc-1.html,118,['ENERGY'],['ENERGY']
Energy Efficiency,avigation. Index. modules    .    .    .    .  · ; 1.5;  · . PSI4. Appendices; PSI Variables by Module; FNOCC. FNOCC¶. (T) CORRECTION ENERGY; ACPF CORRELATION ENERGY; ACPF OPPOSITE-SPIN CORRELATION ENERGY; ACPF SAME-SPIN CORRELATION ENERGY; ACPF TOTAL ENERGY; AQCC CORRELATION ENERGY; AQCC OPPOSITE-SPIN CORRELATION ENERGY; AQCC SAME-SPIN CORRELATION ENERGY; AQCC TOTAL ENERGY; CC D1 DIAGNOSTIC; CC T1 DIAGNOSTIC; CCSD CORRELATION ENERGY; CCSD DOUBLES ENERGY; CCSD ITERATIONS; CCSD OPPOSITE-SPIN CORRELATION ENERGY; CCSD PAIR ENERGIES (array); CCSD SAME-SPIN CORRELATION ENERGY; CCSD SINGLES ENERGY; CCSD TOTAL ENERGY; CCSD(T) CORRELATION ENERGY; CCSD(T) TOTAL ENERGY; CEPA(0) CORRELATION ENERGY; CEPA(0) DOUBLES ENERGY; CEPA(0) OPPOSITE-SPIN CORRELATION ENERGY; CEPA(0) SAME-SPIN CORRELATION ENERGY; CEPA(0) SINGLES ENERGY; CEPA(0) TOTAL ENERGY; CEPA(1) CORRELATION ENERGY; CEPA(1) OPPOSITE-SPIN CORRELATION ENERGY; CEPA(1) SAME-SPIN CORRELATION ENERGY; CEPA(1) TOTAL ENERGY; CEPA(2) CORRELATION ENERGY; CEPA(2) OPPOSITE-SPIN CORRELATION ENERGY; CEPA(2) SAME-SPIN CORRELATION ENERGY; CEPA(2) TOTAL ENERGY; CEPA(3) CORRELATION ENERGY; CEPA(3) OPPOSITE-SPIN CORRELATION ENERGY; CEPA(3) SAME-SPIN CORRELATION ENERGY; CEPA(3) TOTAL ENERGY; CISD CORRELATION ENERGY; CISD OPPOSITE-SPIN CORRELATION ENERGY; CISD SAME-SPIN CORRELATION ENERGY; CISD TOTAL ENERGY; CURRENT CORRELATION ENERGY; CURRENT ENERGY; LCCD CORRELATION ENERGY; LCCD DOUBLES ENERGY; LCCD OPPOSITE-SPIN CORRELATION ENERGY; LCCD SAME-SPIN CORRELATION ENERGY; LCCD SINGLES ENERGY; LCCD TOTAL ENERGY; LCCSD CORRELATION ENERGY; LCCSD DOUBLES ENERGY; LCCSD OPPOSITE-SPIN CORRELATION ENERGY; LCCSD SAME-SPIN CORRELATION ENERGY; LCCSD SINGLES ENERGY; LCCSD TOTAL ENERGY; MP2 CORRELATION ENERGY; MP2 DOUBLES ENERGY; MP2 OPPOSITE-SPIN CORRELATION ENERGY; MP2 SAME-SPIN CORRELATION ENERGY; MP2 SINGLES ENERGY; MP2 TOTAL ENERGY; MP2.5 CORRELATION ENERGY; MP2.5 DOUBLES ENERGY; MP2.5 OPPOSITE-SPIN CORRELATION ENERGY; MP2.5 SAME-SPIN CORRELATION ENERGY,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/autodir_psivariables/module__fnocc-1.html:145,ENERGY,ENERGY,145,psi4manual/1.5.0/autodir_psivariables/module__fnocc-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/autodir_psivariables/module__fnocc-1.html,118,['ENERGY'],['ENERGY']
Energy Efficiency,"avigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Appendices; PSI Variables by Module; DFOCC. DFOCC¶; Performs density-fitted orbital-optimized MPn and CC computations and conventional MPn computations. (AT) CORRECTION ENERGY; (T) CORRECTION ENERGY; CCD CORRELATION ENERGY; CCD TOTAL ENERGY; CCSD CORRELATION ENERGY; CCSD DOUBLES ENERGY; CCSD SINGLES ENERGY; CCSD TOTAL ENERGY; CCSD(AT) TOTAL ENERGY; CCSD(T) CORRELATION ENERGY; CCSD(T) TOTAL ENERGY; CURRENT CORRELATION ENERGY; CURRENT ENERGY; CURRENT REFERENCE ENERGY; LCCD CORRELATION ENERGY; LCCD DOUBLES ENERGY; LCCD OPPOSITE-SPIN CORRELATION ENERGY; LCCD SAME-SPIN CORRELATION ENERGY; LCCD SINGLES ENERGY; LCCD TOTAL ENERGY; MP2 CORRELATION ENERGY; MP2 DOUBLES ENERGY; MP2 OPPOSITE-SPIN CORRELATION ENERGY; MP2 SAME-SPIN CORRELATION ENERGY; MP2 SINGLES ENERGY; MP2 TOTAL ENERGY; MP2.5 CORRELATION ENERGY; MP2.5 DOUBLES ENERGY; MP2.5 OPPOSITE-SPIN CORRELATION ENERGY; MP2.5 SAME-SPIN CORRELATION ENERGY; MP2.5 SINGLES ENERGY; MP2.5 TOTAL ENERGY; MP3 CORRELATION ENERGY; MP3 DOUBLES ENERGY; MP3 OPPOSITE-SPIN CORRELATION ENERGY; MP3 SAME-SPIN CORRELATION ENERGY; MP3 SINGLES ENERGY; MP3 TOTAL ENERGY; NAUX (SCF); OLCCD CORRELATION ENERGY; OLCCD TOTAL ENERGY; OMP2 CORRELATION ENERGY; OMP2 TOTAL ENERGY; OMP2.5 CORRELATION ENERGY; OMP2.5 TOTAL ENERGY; OMP3 CORRELATION ENERGY; OMP3 TOTAL ENERGY; SCS(N)-MP2 CORRELATION ENERGY; SCS(N)-MP2 TOTAL ENERGY; SCS(N)-OMP2 CORRELATION ENERGY; SCS(N)-OMP2 TOTAL ENERGY; SCS-MP2 CORRELATION ENERGY; SCS-MP2 TOTAL ENERGY; SCS-OMP2 CORRELATION ENERGY; SCS-OMP2 TOTAL ENERGY; SCSN-OMP2 CORRELATION ENERGY; SCSN-OMP2 TOTAL ENERGY; SOS-MP2 CORRELATION ENERGY; SOS-MP2 TOTAL ENERGY; SOS-OMP2 CORRELATION ENERGY; SOS-OMP2 TOTAL ENERGY. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Appendices; PSI Variables by Module; DFOCC. © Copyright 2022, The Psi4 Project.; Last updated on Thursday, 19 May 2022 08:57PM.; Created using Sphinx 4.5.0.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/autodir_psivariables/module__dfocc.html:1021,ENERGY,ENERGY,1021,psi4manual/1.6.x/autodir_psivariables/module__dfocc.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/autodir_psivariables/module__dfocc.html,29,['ENERGY'],['ENERGY']
Energy Efficiency,"avigation. index. modules    . toc    . next    . previous    ; Psi4 [1.0.0 6a9a71b] » ; Customization: Adding Simple Extensions ». Note; No recompile of the PSI program is necessary for changes made to; files in $PSIDATADIR aka psi4/share, including those described below. Defining a Method Alias¶; Since quantum chemical methods in Psi4 are accessed through Python functions, and; most important quantities are available as PSI variables, it is straightforward; to create aliases to commonly run calculations or to define hybrid methods. The; psi4/share/python/aliases.py file is intended for editing by the user for; this purpose.; As an example, the MP2.5 method; (which admittedly is already built in to Psi4); is the average of MP2 and MP3. The latter is; available through the arbitrary order MPn code and returns all lower energies; along with it in PSI variables. The following is basic code that will compute; and return the MP2.5 energy.; def run_mp2_5(name, **kwargs):. energy('mp3', **kwargs); e_scf = psi4.get_variable('SCF TOTAL ENERGY'); ce_mp2 = psi4.get_variable('MP2 CORRELATION ENERGY'); ce_mp3 = psi4.get_variable('MP3 CORRELATION ENERGY'). ce_mp25 = 0.5 * (ce_mp2 + ce_mp3); e_mp25 = e_scf + ce_mp25. print """""" MP2.5 total energy: %16.8f\n"""""" % (e_mp25); print """""" MP2.5 correlation energy: %16.8f\n"""""" % (ce_mp25). return e_mp25. Compare the above to the method that resides in psi4/share/python/aliases.py.; The rationale for the changes is indicated in the comments below.; def run_mp2_5(name, **kwargs):; lowername = name.lower() # handy variable with name keyword in lowercase; kwargs = kwargs_lower(kwargs) # removes case sensitivity in keyword names. # Run detci calculation and collect conventional quantities; energy('mp3', **kwargs); e_scf = psi4.get_variable('SCF TOTAL ENERGY'); ce_mp2 = psi4.get_variable('MP2 CORRELATION ENERGY'); ce_mp3 = psi4.get_variable('MP3 CORRELATION ENERGY'); e_mp2 = e_scf + ce_mp2 # reform mp2 and mp3 total energies for printing; e_mp3 =",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/quickaddalias-1.html:1039,energy,energy,1039,psi4manual/1.0.0/quickaddalias-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/quickaddalias-1.html,2,['energy'],['energy']
Energy Efficiency,"avigation. index. modules    . toc    . next    . previous    ; Psi4 [1.0.0 6a9a71b] » ; Psithon Functions: Invoking a Calculation ». Single-Point Energy, energy()¶. Psi4 Native Energy Methods; Psi4 Native DFT Energy Methods; MRCC Interfaced Energy Methods; CFOUR Interfaced Energy Methods. energy(name[, molecule, return_wfn, restart_file])[source]¶; Function to compute the single-point electronic energy. Returns:float – Total electronic energy in Hartrees. SAPT & EFP return interaction energy. Returns:(float, Wavefunction) – energy and wavefunction when return_wfn specified. PSI variables:. CURRENT ENERGY; CURRENT REFERENCE ENERGY; CURRENT CORRELATION ENERGY. Parameters:; name (string) – 'scf' || 'mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the system. molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. return_wfn (boolean) – 'on' || 'off' ; Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple. restart_file (string) – ['file.1, file.32] || ./file || etc.; Binary data files to be renamed for calculation restart. name; calls method. efp; effective fragment potential (EFP) [manual]. scf; Hartree–Fock (HF) or density functional theory (DFT) [manual]. hf; HF self consistent field (SCF) [manual]. dcft; density cumulant functional theory [manual]. mp2; 2nd-order Moller-Plesset perturbation theory (MP2) [manual] [details]. mp3; 3rd-order Moller-Plesset perturbation theory (MP3) [manual] [details]. fno-mp3; MP3 with frozen natural orbitals [manual]. mp2.5; average of MP2 and MP3 [manual] [details]. mp4(sdq); 4th-order MP perturbation theory (MP4) less triples [manual]. fno-mp4(sdq); MP4 (less triples) with frozen natural orbitals [manual]. mp4; full MP4 [manual] [details]. fno-mp4; full MP4 with frozen natural orbitals [manual]. mpn; nth-order Moller–Plesset (MP) perturbation theory [manual]. zaptn; nth-",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/energy-1.html:1126,energy,energy,1126,psi4manual/1.0.0/energy-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/energy-1.html,2,['energy'],['energy']
Energy Efficiency,"avior through; additional keywords.; Let’s consider what we would do for an open-shell molecule, where; not all electrons are paired. For example, let’s run a computation; on methylene (CH2), whose ground electronic state has two unpaired; electrons (triplet electronic state, or a spin multiplicity \(2S+1 = 3\)).; In this case, the default spin multiplicity (1) is not correct, so we; need to tell the program the true value (3). Like many programs, PSI4; can get the charge and multiplicity as the first two integers in the; Z-matrix. Note the line with 0 3 at the beginning of the molecule; specification below. In this example we will also specify the bond length; and bond angle as variables (\(R\) and \(A\)), whose values are given; at the end of the Z-matrix specification.; #! Sample UHF/6-31G** CH2 computation. molecule ch2 {; 0 3; C ; H 1 R; H 1 R 2 A. R = 1.075; A = 133.93; }. set basis 6-31G**; set reference uhf; energy ('scf'). This sample input can be found in; tu2-ch2-energy and as; before it can be run through the command psi4 input.dat output.dat; (actually, because psi4 by default looks for an input file named; input.dat and writes by default to a file called output.dat, in this; case one could also just type psi4). If it works, it should print; the final energy as; 1@UHF Final Energy: -38.92533462456894. Notice we added a new keyword, set reference uhf, to the input. For; open-shell molecules, we have a choice of unrestricted orbitals; (unrestricted Hartree–Fock, or UHF), or restricted orbitals (restricted; open-shell Hartree–Fock, or ROHF). Usually, UHF is a little easier to; converge (although it may be more susceptible to spin contamination than; ROHF). Geometry Optimization and Vibrational Frequency Analysis¶; The above examples were simple single-point energy computations; (as specified by the energy() function). Of course there are other; kinds of computations to perform, such as geometry optimizations and; vibrational frequency computations. These ca",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/tutorial-1.html:4698,energy,energy,4698,psi4manual/1.1.0/tutorial-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/tutorial-1.html,6,['energy'],['energy']
Energy Efficiency,"avior through; additional keywords.; Let’s consider what we would do for an open-shell molecule, where; not all electrons are paired. For example, let’s run a computation; on methylene (CH2), whose ground electronic state has two unpaired; electrons (triplet electronic state, or a spin multiplicity \(2S+1 = 3\)).; In this case, the default spin multiplicity (1) is not correct, so we; need to tell the program the true value (3). Like many programs, PSI4; can get the charge and multiplicity as the first two integers in the; Z-matrix. Note the line with 0 3 at the beginning of the molecule; specification below. In this example we will also specify the bond length; and bond angle as variables (\(R\) and \(A\)), whose values are given; at the end of the Z-matrix specification.; #! Sample UHF/6-31G** CH2 computation. molecule ch2 {; 0 3; C ; H 1 R; H 1 R 2 A. R = 1.075; A = 133.93; }. set basis 6-31G**; set reference uhf; energy ('scf'). This sample input can be found in; tu2-ch2-energy and as; before it can be run through the command psi4 input.dat output.dat; (actually, because psi4 by default looks for an input file named; input.dat and writes by default to a file called output.dat, in this; case one could also just type psi4). If it works, it should print; the final energy as; @UHF Final Energy: -38.92533462456894. Notice we added a new keyword, set reference uhf, to the input. For; open-shell molecules, we have a choice of unrestricted orbitals; (unrestricted Hartree–Fock, or UHF), or restricted orbitals (restricted; open-shell Hartree–Fock, or ROHF). Usually, UHF is a little easier to; converge (although it may be more susceptible to spin contamination than; ROHF). Geometry Optimization and Vibrational Frequency Analysis¶; The above examples were simple single-point energy computations; (as specified by the energy() function). Of course there are other; kinds of computations to perform, such as geometry optimizations and; vibrational frequency computations. These can",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/tutorial-1.html:4736,energy,energy,4736,psi4manual/1.4.0/tutorial-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/tutorial-1.html,9,['energy'],['energy']
Energy Efficiency,"avors of B3LYP (b3lyp3/b3lyp5) against other programs. dfomp2-grad1; DF-OMP2 cc-pVDZ gradients for the H2O molecule. psimrcc-fd-freq1; Mk-MRCCSD single point. \(^3 \Sigma ^-\) O2 state described using the Ms = 0 component of the triplet. Uses ROHF triplet orbitals. cbs-xtpl-energy; Extrapolated water energies. mints6; Patch of a glycine with a methyl group, to make alanine, then DF-SCF energy calculation with the cc-pVDZ basis set. basis-ecp; check mixing ECP and non-ECP orbital/fitting basis sets in a session. isapt2; This is a shorter version if isapt1 - does not do cube plots. See isapt1 for full details. casscf-sa-sp; Example of state-averaged CASSCF for the C2 molecule see C. D. Sherrill and P. Piecuch, J. Chem. Phys. 122, 124104 (2005). cbs-xtpl-wrapper; RHF aug-cc-pVQZ energy for the BH molecule, with Cartesian input. Various gradients for a strained helium dimer and water molecule. pywrap-align; apply linear fragmentation algorithm to a water cluster. dfccsd1; DF-CCSD cc-pVDZ energy for the H2O molecule. cc13b; Tests RHF CCSD(T)gradients. x2c1; Test of SFX2C-1e on water uncontracted cc-pVDZ-DK The reference numbers are from Lan Cheng’s implementation in Cfour. scf-property; UFH and B3LYP cc-pVQZ properties for the CH2 molecule. dfomp2p5-2; DF-OMP2.5 cc-pVDZ energy for the H2O+ cation. soscf-dft; Triple and Singlet Oxygen energy SOSCF, also tests non-symmetric density matrices. opt14; 6-31G(d) optimization of SF4 starting from linear bond angle that is not linear in the optimized structure but is in a symmetry plane of the molecule. dcft-grad1; DCFT DC-06 gradient for the O2 molecule with cc-pVDZ basis set. pywrap-checkrun-rhf; This checks that all energy methods can run with a minimal input and set symmetry. opt5; 6-31G** UHF CH2 3B1 optimization. Uses a Z-Matrix with dummy atoms, just for demo and testing purposes. cc53; Matches Table II a-CCSD(T)/cc-pVDZ H2O @ 2.5 * Re value from Crawford and Stanton, IJQC 98, 601-611 (1998). dfomp3-1; DF-OMP3 cc-pVDZ ener",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/autodoc_testsuite_corepsi4-1.html:15481,energy,energy,15481,psi4manual/1.3.2/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/autodoc_testsuite_corepsi4-1.html,4,['energy'],['energy']
Energy Efficiency,"ax_nbody = nfragments.; nbodies_per_mc_level (List[List[Union[int, ]]], Default: []) – Distribution of active n-body levels among model chemistry levels. All bodies in range [1, self.max_nbody] must be present exactly once. Number of items in outer list is how many different modelchems. Each inner list specifies what n-bodies to be run at the corresponding modelchem (e.g., [[1, 2]] has max_nbody=2 and 1-body and 2-body contributions computed at the same level of theory; [[1], [2]] has max_nbody=2 and 1-body and 2-body contributions computed at different levels of theory. An entry ‘supersystem’ means all higher order n-body effects up to the number of fragments. The n-body levels are effectively sorted in the outer list, and any ‘supersystem’ element is at the end.; embedding_charges (Dict[List[float]], Default: {}) – Atom-centered point charges to be used on molecule fragments whose basis sets are not included in the computation. Keys: 1-based index of fragment. Values: list of atom charges for that fragment.; return_total_data (bool, Optional) – When True, returns the total data (energy/gradient/Hessian) of the system, otherwise returns interaction data. Default is False for energies, True for gradients and Hessians. Note that the calculation of total counterpoise corrected energies implies the calculation of the energies of monomers in the monomer basis, hence specifying return_total_data = True may carry out more computations than return_total_data = False.; quiet (bool, Default: False) – Whether to print/log formatted n-body energy analysis. Presently used by multi to suppress output. Candidate for removal from class once in-class/out-of-class functions sorted.; task_list (Dict[Union[, , ]], Default: {}) – ; extra_data (Any) – . Return type; None. build_tasks(mb_computer, mc_level_idx, **kwargs)[source]¶; Adds to the task_list as many new unique tasks as necessary to treat a single model chemistry level at one or several n-body levels.; New tasks are of type mb_",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/nbody.html:5528,charge,charges,5528,psi4manual/1.6.x/nbody.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/nbody.html,1,['charge'],['charges']
Energy Efficiency,"aximum error allowed (Max error norm in Delta tensor) in the approximate energy denominators employed for most of the and evaluation. Type: double; Default: 1.0e-6. DF_BASIS_ELST¶. Auxiliary basis set for SAPT Elst10 and Exch10 density fitting computations, may be important if heavier elements are involved. Defaults to DF_BASIS_SAPT. Type: string; Possible Values: basis string; Default: No Default. DF_BASIS_SAPT¶. Auxiliary basis set for SAPT density fitting computations. Defaults to a RI basis. Type: string; Possible Values: basis string; Default: No Default. D_CONVERGENCE¶. Convergence criterion for residual of the CPHF coefficients in the SAPT term. Type: conv double; Default: 1e-8. EXCH_SCALE_ALPHA¶. Whether or not to perform exchange scaling for SAPT exchange components. Default is false, i.e. no scaling. If set to true, performs scaling with . If set to a value , performs scaling with . Type: string; Default: FALSE. E_CONVERGENCE¶. Convergence criterion for energy (change) in the SAPT term during solution of the CPHF equations. Type: conv double; Default: 1e-10. FREEZE_CORE¶. The scope of core orbitals to freeze in evaluation of SAPT and terms. Recommended true for all SAPT computations. Type: string; Possible Values: FALSE, TRUE; Default: FALSE. INTS_TOLERANCE¶. Minimum absolute value below which all three-index DF integrals and those contributing to four-index integrals are neglected. The default is conservative, but there isn’t much to be gained from loosening it, especially for higher-order SAPT. Type: conv double; Default: 1.0e-12. MAXITER¶. Maxmum number of CPHF iterations. Type: integer; Default: 50. MAX_CCD_DIISVECS¶. Maximum number of vectors used in CCD-DIIS. Type: integer; Default: 10. MIN_CCD_DIISVECS¶. Minimumnumber of vectors used in CCD-DIIS. Type: integer; Default: 4. NAT_ORBS_T2¶. Do use MP2 natural orbital approximations for the block of two-electron integrals in the evaluation of second-order T2 amplitudes? Recommended true for all SAPT comp",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodir_options_c/module__sapt-1.html:2247,energy,energy,2247,psi4manual/1.0.0/autodir_options_c/module__sapt-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodir_options_c/module__sapt-1.html,2,['energy'],['energy']
Energy Efficiency,"axz; if self.basis.startswith('heavy-aug-'):; text += """"""set,orbital; default,%s,H=%s\n"""""" % (self.basis[6:], self.unaugbasis); # xz, axz, 6-31g*; else:; text += """"""set,orbital; default,%s\n"""""" % (self.basis). if ('df-' in self.method) or ('f12' in self.method) or (self.method in ['mp2c', 'dft-sapt', 'dft-sapt-pbe0acalda']):; if self.unaugbasis and self.auxbasis:. text += """"""set,jkfit; default,%s/jkfit\n"""""" % (self.auxbasis); text += """"""set,jkfitb; default,%s/jkfit\n"""""" % (self.unaugbasis); text += """"""set,mp2fit; default,%s/mp2fit\n"""""" % (self.auxbasis); text += """"""set,dflhf; default,%s/jkfit\n"""""" % (self.auxbasis); else:; raise ValidationError(""""""Auxiliary basis not predictable from orbital basis '%s'"""""" % (self.basis)). text += """"""}\n\n""""""; return text. [docs] def format_infile_string(self):; text = ''. # format comment and memory; text += """"""***, %s %s\n"""""" % (self.index, self.molecule.tagline); text += """"""memory,%d,m\n"""""" % (self.memory). # format molecule, incl. charges and dummy atoms; text += self.molecule.format_molecule_for_molpro(). # format global convergence directions; text += self.format_global_parameters(). # format castup directions; if self.castup is True:; text += """"""basis=sto-3g\n""""""; text += """"""rhf\n""""""; text += '\n'. # format basis set; text += self.format_basis(). # format method; for line in qcmtdIN[self.method]:; text += """"""%s\n"""""" % (line); text += """"""show[1,20f20.12],ee*,ce*,te*\n""""""; text += """"""show[1,60f20.12],_E*\n""""""; text += '\n'. return text. qcmtdIN = {; 'ccsd(t)-f12': [; 'rhf',; 'eehf=energy',; 'ccsd(t)-f12,df_basis=mp2fit,df_basis_exch=jkfitb,ri_basis=jkfitb',; 'eemp2=emp2',; 'cemp2=eemp2-eehf',; 'eemp3=emp3',; 'cemp3=eemp3-eehf',; 'eeccsd=energc',; 'ceccsd=eeccsd-eehf',; 'eeccsdt=energy',; 'ceccsdt=eeccsdt-eehf',; 'temp2=emp2_trip',; 'teccsd=ectrip'],. 'ccsd(t)': [; 'rhf',; 'eehf=energy',; 'ccsd(t)',; 'eemp2=emp2',; 'cemp2=eemp2-eehf',; 'eemp3=emp3',; 'cemp3=eemp3-eehf',; 'eeccsd=energc',; 'ceccsd=eeccsd-eehf',; 'eeccsdt=energy',; ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/molpro.html:3211,charge,charges,3211,psi4manual/1.0.0/_modules/qcdb/molpro.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/molpro.html,1,['charge'],['charges']
Energy Efficiency,"ay (length natom); self.PYatom_to_unique = 0. if psi4molstr:; self.create_molecule_from_string(psi4molstr). # <<< Simple Methods for Basic Molecule Information >>>. [docs] def name(self):; """"""Get molecule name. >>> print H2OH2O.name(); water_dimer. """"""; return self.PYname. [docs] def set_name(self, name):; """"""Set molecule name. >>> H2OH2O.set_name('water_dimer'). """"""; self.PYname = name. [docs] def natom(self):; """"""Number of atoms. >>> print H2OH2O.natom(); 6. """"""; return len(self.atoms). [docs] def nallatom(self):; """"""Number of all atoms (includes dummies). >>> print H2OH2O.nallatom(); 7. """"""; return len(self.full_atoms). [docs] def molecular_charge(self):; """"""Gets the molecular charge. >>> print H2OH2O.molecular_charge(); -2. """"""; return self.PYmolecular_charge. [docs] def set_molecular_charge(self, charge):; """"""Sets the molecular charge. >>> H2OH2O.set_molecular_charge(-2). """"""; self.PYcharge_specified = True; self.PYmolecular_charge = charge. [docs] def charge_specified(self):; """"""Whether the charge was given by the user. >>> print H2OH2O.charge_specified(); True. """"""; return self.PYcharge_specified. [docs] def multiplicity(self):; """"""Get the multiplicity (defined as 2Ms + 1). >>> print H2OH2O.multiplicity(). """"""; return self.PYmultiplicity. [docs] def set_multiplicity(self, mult):; """"""Sets the multiplicity (defined as 2Ms + 1). >>> H2OH2O.set_multiplicity(3). """"""; self.PYmultiplicity_specified = True; self.PYmultiplicity = mult. [docs] def multiplicity_specified(self):; """"""Whether the multiplicity was given by the user. >>> print H2OH2O.multiplicity_specified(); True. """"""; return self.PYmultiplicity_specified. [docs] def units(self):; """"""Gets the geometry units. >>> print H2OH2O.units(); Angstrom. """"""; return self.PYunits. [docs] def set_units(self, units):; """"""Sets the geometry units. >>> H2OH2O.set_units('Angstom'). """"""; if units == 'Angstrom' or units == 'Bohr':; self.PYunits = units; else:; raise ValidationError(""""""Argument to Molecule::set_units must be 'An",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/_modules/qcdb/libmintsmolecule.html:4724,charge,charge,4724,psi4manual/4.0b3/_modules/qcdb/libmintsmolecule.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/_modules/qcdb/libmintsmolecule.html,6,['charge'],['charge']
Energy Efficiency,"ay (length natom); self.PYatom_to_unique = 0. if psi4molstr:; self.create_molecule_from_string(psi4molstr). # <<< Simple Methods for Basic Molecule Information >>>. [docs] def name(self):; """"""Get molecule name. >>> print H2OH2O.name(); water_dimer. """"""; return self.PYname. [docs] def set_name(self, name):; """"""Set molecule name. >>> H2OH2O.set_name('water_dimer'). """"""; self.PYname = name. [docs] def natom(self):; """"""Number of atoms. >>> print H2OH2O.natom(); 6. """"""; return len(self.atoms). [docs] def nallatom(self):; """"""Number of all atoms (includes dummies). >>> print H2OH2O.nallatom(); 7. """"""; return len(self.full_atoms). [docs] def molecular_charge(self):; """"""Gets the molecular charge. >>> print H2OH2O.molecular_charge(); -2. """"""; return self.PYmolecular_charge. [docs] def set_molecular_charge(self, charge):; """"""Sets the molecular charge. >>> H2OH2O.set_molecular_charge(-2). """"""; self.PYcharge_specified = True; self.PYmolecular_charge = charge. [docs] def charge_specified(self):; """"""Whether the charge was given by the user. >>> print H2OH2O.charge_specified(); True. """"""; return self.PYcharge_specified. [docs] def multiplicity(self):; """"""Get the multiplicity (defined as 2Ms + 1). >>> print H2OH2O.multiplicity(). """"""; return self.PYmultiplicity. [docs] def set_multiplicity(self, mult):; """"""Sets the multiplicity (defined as 2Ms + 1). >>> H2OH2O.set_multiplicity(3). """"""; self.PYmultiplicity_specified = True; self.PYmultiplicity = mult. [docs] def multiplicity_specified(self):; """"""Whether the multiplicity was given by the user. >>> print H2OH2O.multiplicity_specified(); True. """"""; return self.PYmultiplicity_specified. [docs] def units(self):; """"""Gets the geometry units. >>> print H2OH2O.units(); Angstrom. """"""; return self.PYunits. [docs] def set_units(self, units):; """"""Sets the geometry units. >>> H2OH2O.set_units('Angstom'). """"""; if units == 'Angstrom' or units == 'Bohr':; self.PYunits = units; else:; raise ValidationError(""""""Molecule::set_units: argument must be 'Angs",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html:6101,charge,charge,6101,psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html,1,['charge'],['charge']
Energy Efficiency,"ay be included noniteratively to yield the QCISD(T) method. Both the; QCISD(T) and CCSD(T) methods are implemented for closed-shell references; in the FNOCC module. Many-body perturbation theory¶; QCI and CC methods are closely related to perturbation theory, and the; MP2, MP3, and MP4(SDQ) correlation energies can be obtained as a free; by-product of a CCSD or QCISD computation. The following is an; example of the results for a computation run with the call; energy('fno-qcisd') to energy():; QCISD iterations converged!. OS MP2 FNO correction: -0.000819116338; SS MP2 FNO correction: -0.000092278158; MP2 FNO correction: -0.000911394496. OS MP2 correlation energy: -0.166478414245; SS MP2 correlation energy: -0.056669079827; MP2 correlation energy: -0.223147494072; * MP2 total energy: -76.258836941658. OS MP2.5 correlation energy: -0.171225850256; SS MP2.5 correlation energy: -0.054028401038; MP2.5 correlation energy: -0.225254251294; * MP2.5 total energy: -76.260943698880. OS MP3 correlation energy: -0.175973286267; SS MP3 correlation energy: -0.051387722248; MP3 correlation energy: -0.227361008515; * MP3 total energy: -76.263050456101. OS MP4(SDQ) correlation energy: -0.180324322304; SS MP4(SDQ) correlation energy: -0.048798468084; MP4(SDQ) correlation energy: -0.230995119324; * MP4(SDQ) total energy: -76.266684566910. OS QCISD correlation energy: -0.181578117924; SS QCISD correlation energy: -0.049853548145; QCISD correlation energy: -0.231431666069; * QCISD total energy: -76.267121113654. The first set of energies printed corresponds to the second-order FNO; correction mentioned previously. Results for many-body perturbation; theory through partial fourth order are then provided.; The notation MP4(SDQ) indicates that we have included all contributions to; the correlation energy through fourth order, with the exception of that; from connected triple excitations.; One need not run a full QCISD or CCSD computation to obtain these; perturbation theory results. The keywo",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/fnocc-1.html:5788,energy,energy,5788,psi4manual/1.4.0/fnocc-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/fnocc-1.html,15,['energy'],['energy']
Energy Efficiency,"ay containing the number of singly-occupied orbitals per irrep (in Cotton order). The value of DOCC should also be set. Type: array; Default: No Default. UNITS¶. Units used in geometry specification. Type: string; Possible Values: BOHR, AU, A.U., ANGSTROMS, ANG, ANGSTROM; Default: ANGSTROMS. WRITER_FILE_LABEL¶. Base filename for text files written by PSI, such as the MOLDEN output file, the Hessian file, the internal coordinate file, etc. Use the add_str_i function to make this string case sensitive. Type: string; Default: No Default. Expert¶. CUBIC_BASIS_TOLERANCE¶. CubicScalarGrid basis cutoff. Type: conv double; Default: 1.0e-12. CUBIC_BLOCK_MAX_POINTS¶. CubicScalarGrid maximum number of grid points per evaluation block. Type: integer; Default: 1000. DEBUG¶. The amount of information to print to the output file. Type: integer; Default: 0. DERTYPE¶. Derivative level. Type: string; Possible Values: NONE, FIRST, SECOND, RESPONSE; Default: NONE. DIE_IF_NOT_CONVERGED¶. Psi4 dies if energy does not converge. Type: boolean; Default: true. DKH_ORDER¶. Order of Douglas-Kroll-Hess. Type: integer; Default: 2. EXTERNAL_POTENTIAL_SYMMETRY¶. Assume external fields are arranged so that they have symmetry. It is up to the user to know what to do here. The code does NOT help you out in any way!. Type: boolean; Default: false. MAT_NUM_COLUMN_PRINT¶. Number of columns to print in calls to Matrix::print_mat. Type: integer; Default: 5. PCM_SCF_TYPE¶. Use total or separate potentials and charges in the PCM-SCF step. Type: string; Possible Values: TOTAL, SEPARATE; Default: TOTAL. RAS1¶. An array giving the number of orbitals per irrep for RAS1. Type: array; Default: No Default. RAS2¶. An array giving the number of orbitals per irrep for RAS2. Type: array; Default: No Default. RAS3¶. An array giving the number of orbitals per irrep for RAS3. Type: array; Default: No Default. RAS4¶. An array giving the number of orbitals per irrep for RAS4. Type: array; Default: No Default. RELATIVISTIC¶.",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodir_options_c/module__globals-1.html:6730,energy,energy,6730,psi4manual/1.0.0/autodir_options_c/module__globals-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodir_options_c/module__globals-1.html,4,['energy'],['energy']
Energy Efficiency,"ay of `val` with natural dimensions of `key`. """"""; if isinstance(val, (np.ndarray, core.Matrix)):; raise TypeError; elif isinstance(val, list):; tgt = np.asarray(val); else:; # presumably scalar. may be string; return float(val). if key.upper().startswith(""MBIS""):; if key.upper().endswith(""CHARGES""):; reshaper = (-1, ); elif key.upper().endswith(""DIPOLES""):; reshaper = (-1, 3); elif key.upper().endswith(""QUADRUPOLES""):; reshaper = (-1, 3, 3); elif key.upper().endswith(""OCTUPOLES""):; reshaper = (-1, 3, 3, 3); elif key.upper().endswith(""DIPOLE"") or ""DIPOLE -"" in key.upper():; reshaper = (3, ); elif ""QUADRUPOLE POLARIZABILITY TENSOR"" in key.upper():; reshaper = (3, 3, 3); elif any((key.upper().endswith(p) or f""{p} -"" in key.upper()) for p in _multipole_order):; p = [p for p in _multipole_order if (key.upper().endswith(p) or f""{p} -"" in key.upper())]; reshaper = tuple([3] * _multipole_order.index(p[0])); elif key.upper() in [""MULLIKEN_CHARGES"", ""LOWDIN_CHARGES"", ""MULLIKEN CHARGES"", ""LOWDIN CHARGES"", ""SCF TOTAL ENERGIES""]:; reshaper = (-1, ); elif ""GRADIENT"" in key.upper():; reshaper = (-1, 3); elif ""HESSIAN"" in key.upper():; ndof = int(math.sqrt(len(tgt))); reshaper = (ndof, ndof); else:; raise ValidationError(f'Uncertain how to reshape array: {key}'). return tgt.reshape(reshaper). _multipole_order = [""dummy"", ""dummy"", ""QUADRUPOLE"", ""OCTUPOLE"", ""HEXADECAPOLE""]; for order in range(5, 10):; _multipole_order.append(f""{int(2**order)}-POLE""). def _qcvar_reshape_set(key: str, val: np.ndarray) -> np.ndarray:; """"""Reverse :py:func:`_qcvar_reshape_get` for internal; :py:class:`psi4.core.Matrix` storage. """"""; reshaper = None; if key.upper().startswith(""MBIS""):; if key.upper().endswith(""CHARGES""):; return val; elif key.upper().endswith(""DIPOLES""):; reshaper = (-1, 3); return val.reshape(reshaper); elif key.upper().endswith(""QUADRUPOLES""):; val = val.reshape(-1, 3, 3); val = np.array([_multipole_compressor(val[iat], 2) for iat in range(len(val))]); return val; elif key.upper().endsw",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/p4util/python_helpers.html:29404,CHARGE,CHARGES,29404,psi4manual/1.9.x/_modules/psi4/driver/p4util/python_helpers.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/p4util/python_helpers.html,4,['CHARGE'],['CHARGES']
Energy Efficiency,"ay(arr).reshape((-1, 4)); self.set_lattice = True. # Respond to the >NLATTICE command; def recv_nlattice(self, nlattice=None):; """""" Receive the number of lattice point charges through MDI. Arguments:; nlattice: New number of point charges. If None, receive through MDI.; """"""; if nlattice is None:; self.nlattice = MDI_Recv(1, MDI_INT, self.comm); else:; self.nlattice = nlattice; self.clattice = [0.0 for ilat in range(3 * self.nlattice)]; self.lattice = [0.0 for ilat in range(self.nlattice)]; self.set_lattice_field(). # Respond to the >CLATTICE command; def recv_clattice(self, clattice=None):; """""" Receive the coordinates of a set of lattice point charges through MDI. Arguments:; clattice: New coordinates of the lattice of point charges. If None, receive through MDI.; """"""; if clattice is None:; self.clattice = MDI_Recv(3 * self.nlattice, MDI_DOUBLE, self.comm); else:; self.clattice = clattice; self.set_lattice_field(). # Respond to the >LATTICE command; def recv_lattice(self, lattice=None):; """""" Receive the charges of a set of lattice point charges through MDI. Arguments:; lattice: New charges of the lattice of point charges. If None, receive through MDI.; """"""; if lattice is None:; self.lattice = MDI_Recv(self.nlattice, MDI_DOUBLE, self.comm); else:; self.lattice = lattice; self.set_lattice_field(). # Respond to the SCF command; def run_scf(self):; """""" Run an energy calculation; """"""; self.energy = psi4.energy(self.scf_method, **self.kwargs). # Respond to the <DIMENSIONS command; def send_dimensions(self):; """""" Send the dimensionality of the system through MDI. :returns: *dimensions* Dimensionality of the system; """"""; dimensions = [1, 1, 1]; MDI_Send(dimensions, 3, MDI_INT, self.comm); return dimensions. # Respond to the <TOTCHARGE command; def send_total_charge(self):; """""" Send the total system charge through MDI. :returns: *charge* Total charge of the system; """"""; charge = self.molecule.molecular_charge(); MDI_Send(charge, 1, MDI_DOUBLE, self.comm); return charge. # Res",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/mdi_engine.html:9862,charge,charges,9862,psi4manual/1.6.x/_modules/psi4/driver/mdi_engine.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/mdi_engine.html,20,['charge'],['charges']
Energy Efficiency,"ay; Default: No Default. CFOUR_CPHF_CONVER (CFOUR); CFOUR — Specifies the convergence criterion for the iterative solution of the CPHF and Z-vector equations. The solutions are considered to be converged when the residual norm of the error vector falls below \(10^N\). Type: integer; Default: 12. CFOUR_CPHF_MAXCYC (CFOUR); CFOUR — Specifies the maximum number of cycles allowed for the solution of the CPHF- and/or Z-vector equations. Type: integer; Default: 64. CFOUR_CURVILINEAR (CFOUR); CFOUR — Specifies whether or not Hessian matrix is transformed (nonlinearly) to curvilinear internal coordinates. A value of 0 (or OFF) turns the transformation off if the analytic force constants are not available, while it is always performed if CURVILINEAR=1 (or ON). Values higher than 1 (or NO) unconditionally turn the transformation off.(Default: ON if analytic Hessian is available, OFF otherwise). Type: boolean; Default: true. CFOUR_DBOC (CFOUR); CFOUR — Specifies whether the diagonal Born-Oppenheimer correction (DBOC) to the energy is evaluated (ON =1) or not (OFF =0). DBOC calculations are currently only available for HF-SCF and CCSD using RHF or UHF reference functions. Type: boolean; Default: false. CFOUR_DCT (CFOUR); CFOUR — Specifies whether the Dipole Coupling Tensor (DCT) is calculated (ON =1) or not (OFF =0). Type: boolean; Default: false. CFOUR_DERIV_LEVEL (CFOUR); CFOUR — Specifies whether or not energy derivatives are to be calculated and if so whether first or second derivatives are computed. ZERO (= 0) derivatives are not calculated, FIRST (=1) first derivatives are calculated, SECOND (=2) second derivatives are calculated. Note that this keyword usually needs not be set in any calculation since it is automatically set if the appropriate other options in the CFOUR namelist are turned on. Psi4 Interface: Keyword set from type of computation command: ZERO if energy(), FIRST if gradient() or optimization(), etc. Type: string; Possible Values: ZERO, FIRST, SECOND; Defa",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/autodoc_glossary_options_c-1.html:31485,energy,energy,31485,psi4manual/1.2.1/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/autodoc_glossary_options_c-1.html,6,['energy'],['energy']
Energy Efficiency,"ay; eHI = NEED['HI']['f_energy']; zHI = NEED['HI']['f_zeta']; eLO = NEED['LO']['f_energy']; zLO = NEED['LO']['f_zeta']. # Compute extrapolated energy; energypiece = (eHI * zHI ** 3 - eLO * zLO ** 3) / (zHI ** 3 - zLO ** 3); beta = (eHI - eLO) / (zHI ** (-3) - zLO ** (-3)). # Output string with extrapolation parameters; cbsscheme = ''; cbsscheme += """"""\n ==> %s <==\n\n"""""" % (functionname); cbsscheme += """""" LO-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(zLO), eLO); cbsscheme += """""" HI-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(zHI), eHI); cbsscheme += """""" Extrapolated Correlation Energy: %16.8f\n"""""" % (energypiece); cbsscheme += """""" Beta (coefficient) Value: %16.8f\n"""""" % (beta); PsiMod.print_out(cbsscheme). return energypiece. [docs]def scf_xtpl_helgaker_3(**largs):; r""""""Extrapolation scheme for reference energies with three adjacent zeta-level bases.; Used by :py:func:`~wrappers.complete_basis_set`. .. math:: E_{total}^X = E_{total}^{\infty} + \beta e^{-\alpha X}. """"""; energypiece = 0.0; functionname = sys._getframe().f_code.co_name; f_fields = ['f_wfn', 'f_portion', 'f_basis', 'f_zeta', 'f_energy']; [mode, NEED, wfnname, BSET, ZSET] = validate_scheme_args(functionname, **largs). if (mode == 'requisition'):. # Impose restrictions on zeta sequence; if (len(ZSET) != 3):; raise ValidationError('Call to \'%s\' not valid with \'%s\' basis sets.' % (functionname, len(ZSET))). # Return array that logs the requisite jobs; NEED = {'HI': dict(zip(f_fields, [wfnname, 'tot', BSET[2], ZSET[2], 0.0])),; 'MD': dict(zip(f_fields, [wfnname, 'tot', BSET[1], ZSET[1], 0.0])),; 'LO': dict(zip(f_fields, [wfnname, 'tot', BSET[0], ZSET[0], 0.0]))}. return NEED. elif (mode == 'evaluate'):. # Extract required energies and zeta integers from array; eHI = NEED['HI']['f_energy']; eMD = NEED['MD']['f_energy']; eLO = NEED['LO']['f_energy']; zHI = NEED['HI']['f_zeta']; zMD = NEED['MD']['f_zeta']; zLO = NEED['LO']['f_zeta']. # Compute extrapolated energy; ratio = (eHI - eMD) / (eMD - eLO",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:80783,energy,energypiece,80783,psi4manual/4.0b2/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html,6,['energy'],['energypiece']
Energy Efficiency,ay_constant_for_conventional_electric_current; 96485.3251; Faraday constant for conventional electric current [C_{90} mol^{-1}] uncertainty=0.0012. Fermi_coupling_constant; 0.000011663787; Fermi coupling constant [GeV^{-2}] uncertainty=0.000 0006 e-5. fine_structure_constant; 0.0072973525664; fine-structure constant [] uncertainty=0.000 000 0017 e-3. first_radiation_constant; 3.741771790E-16; first radiation constant [W m^2] uncertainty=0.000 000 046 e-16. first_radiation_constant_for_spectral_radiance; 1.191042953E-16; first radiation constant for spectral radiance [W m^2 sr^{-1}] uncertainty=0.000 000 015 e-16. hartree_atomic_mass_unit_relationship; 2.9212623197E-8; hartree-atomic mass unit relationship [u] uncertainty=0.000 000 0013 e-8. hartree_electron_volt_relationship; 27.21138602; hartree-electron volt relationship [eV] uncertainty=0.000 000 17. Hartree_energy; 4.359744650E-18; Hartree energy [J] uncertainty=0.000 000 054 e-18. Hartree_energy_in_eV; 27.21138602; Hartree energy in eV [eV] uncertainty=0.000 000 17. hartree_hertz_relationship; 6.579683920711E+15; hartree-hertz relationship [Hz] uncertainty=0.000 000 000 039 e15. hartree_inverse_meter_relationship; 21947463.13702; hartree-inverse meter relationship [m^{-1}] uncertainty=0.000 000 000 013 e7. hartree_joule_relationship; 4.359744650E-18; hartree-joule relationship [J] uncertainty=0.000 000 054 e-18. hartree_kelvin_relationship; 315775.13; hartree-kelvin relationship [K] uncertainty=0.000 0018 e5. hartree_kilogram_relationship; 4.850870129E-35; hartree-kilogram relationship [kg] uncertainty=0.000 000 060 e-35. helion_electron_mass_ratio; 5495.88527922; helion-electron mass ratio [] uncertainty=0.000 000 27. helion_g_factor; -4.255250616; helion g factor [] uncertainty=0.000 000 050. helion_mag_mom; -1.074617522E-26; helion mag. mom. [J T^{-1}] uncertainty=0.000 000 014 e-26. helion_mag_mom_to_Bohr_magneton_ratio; -0.001158740958; helion mag. mom. to Bohr magneton ratio [] uncertainty=0.000 000 014 e,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/autodoc_physconst-1.html:14103,energy,energy,14103,psi4manual/1.3.2/autodoc_physconst-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/autodoc_physconst-1.html,11,['energy'],['energy']
Energy Efficiency,"ay_variable(self: psi4.core.Wavefunction, arg0: str) → int¶; Removes the requested (case-insensitive) Matrix QC variable. Prefer del_variable(). del_potential_variable(self: psi4.core.Wavefunction, arg0: str) → int¶; Removes the requested (case-insensitive) ExternalPotential QC variable. (This function is provisional and might be removed in the future.). del_scalar_variable(self: psi4.core.Wavefunction, arg0: str) → int¶; Removes the requested (case-insensitive) double QC variable. Prefer del_variable(). del_variable(key)¶; Removes scalar or array QCVariable key from self if present.; :rtype: None. Parameters:. self (Wavefunction) – Wavefunction instance.; key (str) – Case-insensitive key to instance’s double or; Matrix storage maps. Return type:; None. doccpi(self: psi4.core.Wavefunction, assume_socc_alpha: bool = True) → psi4.core.Dimension¶; Returns the number of doubly occupied orbitals per irrep. efzc(self: psi4.core.Wavefunction) → float¶; Returns the frozen-core energy. energy(self: psi4.core.Wavefunction) → float¶; Returns the Wavefunction’s energy. epsilon_a(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the Alpha Eigenvalues. epsilon_a_subset(self: psi4.core.Wavefunction, basis: str, subset: str) → psi4.core.Vector¶; Returns the requested Alpha orbital energies subset. Parameters:. basis – {‘AO’, ‘SO’, ‘MO’}; MO or SO select for Pitzer-ordering the return vector in the full computational point group symmetry.; AO selects for Pitzer-ordering the return vector without point group symmetry.; subset – {‘ALL’, ‘ACTIVE’, ‘FROZEN’, ‘OCC’, ‘VIR’, ‘FROZEN_OCC’, ‘ACTIVE_OCC’, ‘ACTIVE_VIR’, ‘FROZEN_VIR’}; Which subspace of orbital energies should be returned?. Returns:; A Pitzer-ordered vector of the orbitals. Return type:; Vector. epsilon_b(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the Beta Eigenvalues. epsilon_b_subset(self: psi4.core.Wavefunction, basis: str, subset: str) → psi4.core.Vector¶; Returns the requested Beta orbital energies ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/api/psi4.core.Wavefunction.html:14315,energy,energy,14315,psi4manual/1.9.x/api/psi4.core.Wavefunction.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.Wavefunction.html,2,['energy'],['energy']
Energy Efficiency,ay_variable; set_datadir; set_datadir; set_efp_torque; set_efp_torque; set_frequencies; set_frequencies; set_global_option; set_global_option; set_gradient; set_gradient; set_legacy_molecule; set_legacy_molecule; set_legacy_wavefunction; set_legacy_wavefunction; set_local_option; set_local_option; set_local_option_python; set_local_option_python; set_memory_bytes; set_memory_bytes; set_num_threads; set_num_threads; set_output_file; set_output_file; set_parent_symmetry; set_parent_symmetry; set_psi_file_prefix; set_psi_file_prefix; set_variable; set_variable; ShellInfo; Slice; SOBasisSet; SOMCSCF; SuperFunctional; SymmetryOperation; ThreeCenterOverlapInt; TracelessQuadrupoleInt; tstart; tstart; tstop; tstop; TwoBodyAOInt; TwoElectronInt; UHF; UKSFunctions; VBase; Vector; Vector3; VectorMatrix; version; version; Wavefunction; activate; activate; ancestor; ancestor; banner; banner; basis_helper; basis_helper; cbs; cbs; check_iwl_file_from_scf_type; check_iwl_file_from_scf_type; compare_arrays; compare_arrays; compare_csx; compare_csx; compare_cubes; compare_cubes; compare_fcidumps; compare_fcidumps; compare_integers; compare_integers; compare_matrices; compare_matrices; compare_strings; compare_strings; compare_values; compare_values; compare_vectors; compare_vectors; ConvergenceError; copy_file_from_scratch; copy_file_from_scratch; copy_file_to_scratch; copy_file_to_scratch; create_plugin; create_plugin; csx2endict; csx2endict; CSXError; cubeprop; cubeprop; Dftd3Error; dynamic_variable_bind; dynamic_variable_bind; EmpericalDispersion; energy; energy; fchk; fchk; fcidump; fcidump; fcidump_from_file; fcidump_from_file; filter_comments; filter_comments; find_approximate_string_matches; find_approximate_string_matches; freq; freq; frequencies; frequencies; frequency; frequency; gdma; gdma; geometry; geometry; get_memory; get_memory; getFromDict; gradient; gradient; hessian; hessian; join_path; join_path; levenshtein; levenshtein; ManagedMethodError; molden; molden; driver.,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/index-wcopy.html:380113,energy,energy,380113,index-wcopy.html,https://psicode.org,https://psicode.org/index-wcopy.html,4,['energy'],['energy']
Energy Efficiency,"aya and Schaefer demonstrated that orbital-optimized coupled cluster based; triple corrections, especially those of asymmetrics, provide significantly better potential energy curves than; CCSD based triples corrections. Theory¶; What follows is a very basic description of orbital-optimized Møller–Plesset perturbation; theory as implemented in PSI4. We will follow our previous presentations ([Bozkaya:2011:omp2],; [Bozkaya:2011:omp3], and [Bozkaya:2012:odtl]); The orbital variations may be expressed by means of an exponential unitary operator. where is the orbital rotation operator. The effect of the orbital rotations on the MO coefficients can be written as. where is the initial MO coefficient matrix and is the new; MO coefficient matrix as a function of .; Now, let us define a variational energy functional (Lagrangian) as a function of . OMP2. OMP3. where , , and defined as. and first and second derivatives of the energy with respect to the parameter at . Then the energy can be expanded up to second-order as follows. where is the MO gradient vector, is the MO rotation vector,; and is the MO Hessian matrix. Therefore, minimizing the energy with respect to ; yields. This final equation corresponds to the usual Newton-Raphson step.; Publications resulting from the use of the OMP2 code should cite the following publication(s):; [Bozkaya:2011:omp2].; Publications resulting from the use of the OMP3 code should cite the following publications:; [Bozkaya:2011:omp2] and [Bozkaya:2011:omp3]. Methods¶; The orbital-optimized MP2 methods currently supported in PSI4 are outlined in Table OMP2 Methods. Name; Calls Method; Energy; Gradient; Reference. omp2; Orbital-Optimized MP2; Y; Y; RHF/UHF/RKS/UKS. scs-omp2; Spin-Component Scaled Orbital-Optimized MP2; Y; N; RHF/UHF/RKS/UKS. sos-omp2; Spin-Opposite Scaled Orbital-Optimized MP2; Y; N; RHF/UHF/RKS/UKS. scsn-omp2; A special version of SCS-OMP2 for nucleobase interactions; Y; N; RHF/UHF/RKS/UKS. scs-mi-omp2; A special version of SCS",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/ompn-1.html:3707,energy,energy,3707,psi4manual/4.0b3/ompn-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/ompn-1.html,2,['energy'],['energy']
Energy Efficiency,"ays.; return_molecules; If True, also return fragments as list of Molecules.; return_molecule; If True, also return one big Molecule with fragmentation encoded. Returns; -------; bfs_map : list of lists; Array of atom indices (0-indexed) of detected fragments.; bfs_arrays : tuple of lists of ndarray, optional; geom, mass, elem info per-fragment.; Only provided if `return_arrays` is True.; bfs_molecules : list of qcdb.Molecule or psi4.core.Molecule, optional; List of molecules, each built from one fragment. Center and; orientation of fragments is fixed so orientation info from `self` is; not lost. Loses chgmult and ghost/dummy info from `self` and contains; default chgmult.; Only provided if `return_molecules` is True.; Returned are of same type as `self`.; bfs_molecule : qcdb.Molecule or psi4.core.Molecule, optional; Single molecule with same number of real atoms as `self` with atoms; reordered into adjacent fragments and fragment markers inserted.; Loses ghost/dummy info from `self`; keeps total charge but not total mult.; Only provided if `return_molecule` is True.; Returned is of same type as `self`. Authors; -------; Original code from Michael S. Marshall, linear-scaling algorithm from; Trent M. Parker, revamped by Lori A. Burns. Notes; -----; Relies upon van der Waals radii and so faulty for close (especially hydrogen-bonded) fragments. See` `seed_atoms``.; Any existing fragmentation info/chgmult encoded in ``self`` is lost. """"""; self.update_geometry(); if self.natom() != self.nallatom():; raise ValidationError(""""""BFS not adapted for dummy atoms""""""). cgeom, cmass, celem, celez, cuniq = self.to_arrays(); frag_pattern = BFS(cgeom, celez, seed_atoms=seed_atoms, bond_threshold=bond_threshold); outputs = [frag_pattern]. if return_arrays:; fgeoms = [cgeom[fr] for fr in frag_pattern]; fmasss = [cmass[fr] for fr in frag_pattern]; felems = [celem[fr] for fr in frag_pattern]; outputs.append((fgeoms, fmasss, felems)). if return_molecules:; molrecs = [; qcel.molparse.from_",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/qcdb/molecule.html:55198,charge,charge,55198,psi4manual/1.4.0/_modules/psi4/driver/qcdb/molecule.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/qcdb/molecule.html,14,['charge'],['charge']
Energy Efficiency,"b = dimer_wfn.basisset().n_ecp_core(); share_df_ints = ((sapt_basis == 'dimer') and (ri == 'DF') and not (necp_ab and (os.name == 'nt'))); if (sapt_basis == 'dimer') and (ri == 'DF') and not share_df_ints:; core.print_out(f""\n Turning off SAPT DF integrals sharing because of ECP: {necp_ab}\n\n""). if do_delta_mp2:; select_mp2(""mp2"", ref_wfn=dimer_wfn, **kwargs); mp2_corl_interaction_e = core.variable('MP2 CORRELATION ENERGY'). optstash2.restore(); if share_df_ints:; core.set_global_option('DF_INTS_IO', 'LOAD'). # Compute Monomer A wavefunction; if share_df_ints:; core.IO.change_file_namespace(97, 'dimer', 'monomerA'). core.IO.set_default_namespace('monomerA'); core.print_out('\n'); p4util.banner('Monomer A HF'); core.print_out('\n'). core.timer_on(""SAPT: Monomer A SCF""); monomerA_wfn = scf_helper('RHF', molecule=monomerA, **kwargs); core.timer_off(""SAPT: Monomer A SCF""). if do_delta_mp2:; select_mp2(""mp2"", ref_wfn=monomerA_wfn, **kwargs); mp2_corl_interaction_e -= core.variable('MP2 CORRELATION ENERGY'). # Compute Monomer B wavefunction; if share_df_ints:; core.IO.change_file_namespace(97, 'monomerA', 'monomerB'); core.IO.set_default_namespace('monomerB'); core.print_out('\n'); p4util.banner('Monomer B HF'); core.print_out('\n'). core.timer_on(""SAPT: Monomer B SCF""); monomerB_wfn = scf_helper('RHF', molecule=monomerB, **kwargs); core.timer_off(""SAPT: Monomer B SCF""). # Delta MP2; if do_delta_mp2:; select_mp2(""mp2"", ref_wfn=monomerB_wfn, **kwargs); mp2_corl_interaction_e -= core.variable('MP2 CORRELATION ENERGY'); core.set_variable(""SAPT MP2 CORRELATION ENERGY"", mp2_corl_interaction_e) # P::e SAPT; core.set_global_option('DF_INTS_IO', df_ints_io). if core.get_option('SCF', 'REFERENCE') == 'RHF':; core.IO.change_file_namespace(psif.PSIF_SAPT_MONOMERA, 'monomerA', 'dimer'); core.IO.change_file_namespace(psif.PSIF_SAPT_MONOMERB, 'monomerB', 'dimer'). core.IO.set_default_namespace('dimer'); # core.set_local_option('SAPT', 'CPHF_R_CONVERGENCE', 10e-10); if name in ['sapt0',",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/_modules/psi4/driver/procrouting/proc.html:149335,ENERGY,ENERGY,149335,psi4manual/master/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/procrouting/proc.html,1,['ENERGY'],['ENERGY']
Energy Efficiency,"b = dimer_wfn.basisset().n_ecp_core(); share_df_ints = ((sapt_basis == 'dimer') and (ri == 'DF') and not (necp_ab and (os.name == 'nt'))); if (sapt_basis == 'dimer') and (ri == 'DF') and not share_df_ints:; core.print_out(f""\n Turning off SAPT DF integrals sharing because of ECP: {necp_ab}\n\n""). if do_delta_mp2:; select_mp2(""mp2"", ref_wfn=dimer_wfn, **kwargs); mp2_corl_interaction_e = core.variable('MP2 CORRELATION ENERGY'). optstash2.restore(); if share_df_ints:; core.set_global_option('DF_INTS_IO', 'LOAD'). # Compute Monomer A wavefunction; if share_df_ints:; core.IO.change_file_namespace(97, 'dimer', 'monomerA'). core.IO.set_default_namespace('monomerA'); core.print_out('\n'); p4util.banner('Monomer A HF'); core.print_out('\n'). core.timer_on(""SAPT: Monomer A SCF""); monomerA_wfn = scf_helper('RHF', molecule=monomerA, **kwargs); core.timer_off(""SAPT: Monomer A SCF""). if do_delta_mp2:; select_mp2(""mp2"", ref_wfn=monomerA_wfn, **kwargs); mp2_corl_interaction_e -= core.variable('MP2 CORRELATION ENERGY'). # Compute Monomer B wavefunction; if share_df_ints:; core.IO.change_file_namespace(97, 'monomerA', 'monomerB'); core.IO.set_default_namespace('monomerB'); core.print_out('\n'); p4util.banner('Monomer B HF'); core.print_out('\n'). core.timer_on(""SAPT: Monomer B SCF""); monomerB_wfn = scf_helper('RHF', molecule=monomerB, **kwargs); core.timer_off(""SAPT: Monomer B SCF""). # Delta MP2; if do_delta_mp2:; select_mp2(""mp2"", ref_wfn=monomerB_wfn, **kwargs); mp2_corl_interaction_e -= core.variable('MP2 CORRELATION ENERGY'); core.set_variable(""SAPT MP2 CORRELATION ENERGY"", mp2_corl_interaction_e) # P::e SAPT; core.set_global_option('DF_INTS_IO', df_ints_io). if core.get_option('SCF', 'REFERENCE') == 'RHF':; core.IO.change_file_namespace(psif.PSIF_SAPT_MONOMERA, 'monomerA', 'dimer'); core.IO.change_file_namespace(psif.PSIF_SAPT_MONOMERB, 'monomerB', 'dimer'). core.IO.set_default_namespace('dimer'); core.set_local_option('SAPT', 'E_CONVERGENCE', 10e-10); core.set_local_option('SAPT",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/procrouting/proc.html:149328,ENERGY,ENERGY,149328,psi4manual/1.9.x/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/procrouting/proc.html,1,['ENERGY'],['ENERGY']
Energy Efficiency,"b M. Parrish and Jérôme F. Gonthier; Section author: Edward G. Hohenstein and Jérôme F. Gonthier; Module: Keywords, PSI Variables, LIBSAPT_SOLVER. Warning; In rare cases with systems having a high degree of symmetry,; PSI4 gives (very obviously) wrong answers for SAPT computations; when the specification is in Z-matrix format. Use a Cartesian representation; to avoid this problem. Caution; In early versions (notably PSI4 alpha circa 2011; and before), frozen core was implemented incompletely and for; only selected terms. Comparisons with papers published using early; PSI4 SAPT code may show discrepancies of 0.01-0.10 kcal/mol in; individual terms, particularly \(E_{exch}^{(11)}\) and \(E_{exch}^{(12)}\). Caution; January 28th 2016, the default for all NAT_ORBS options; was changed to true. Hence the code now by default uses natural; orbital truncation to speed up the evaluation of energy terms; wherever possible, according to literature recommendations.; In early July 2016, some total SAPT energy psivars were renamed. Symmetry-adapted perturbation theory (SAPT) provides a means of directly; computing the noncovalent interaction between two molecules, that is, the; interaction energy is determined without computing the total energy of the; monomers or dimer. In addition, SAPT provides a decomposition of the; interaction energy into physically meaningful components: i.e.,; electrostatic, exchange, induction, and dispersion terms. In SAPT, the; Hamiltonian of the dimer is partitioned into contributions from each; monomer and the interaction. \[H=F_A+W_A+F_B+W_B+V\]; Here, the Hamiltonian is written as a sum of the usual monomer Fock; operators, \(F\), the fluctuation potential of each monomer, \(W\), and the; interaction potential, \(V\). The monomer Fock operators, \(F_A+F_B\), are; treated as the zeroth-order Hamiltonian and the interaction energy is; evaluated through a perturbative expansion of \(V\), \(W_A\), and \(W_B\).; Through first-order in \(V\), electrostat",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/sapt-1.html:1235,energy,energy,1235,psi4manual/1.1.0/sapt-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/sapt-1.html,2,['energy'],['energy']
Energy Efficiency,"b.); This route is much faster than running a DFT-D energy. Some set-up:; 1; 2; 3; 4; 5; 6molecule nene {; Ne; Ne 1 2.0; }. nene.update_geometry(). The same four dispersion corrections/gradients as the section above:; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14>>> print nene.run_dftd3('bp86', 'd', dertype=0); -7.735e-05. >>> E, G = nene.run_dftd3('pbe', 'd3bj'); >>> print G; [[0.0, 0.0, -1.1809087569358e-05], [0.0, 0.0, 1.1809087569358e-05]]. >>> E, G = nene.run_dftd3('b3lyp', 'd2', {'s6': 1.20}); >>> print E; -8.84e-05. >>> E, G = nene.run_dftd3(dashlvl='d3', dashparam={'s8': 2.0, 'alpha6': 14.0, 'sr6': 1.261, 's6': 1.0}); >>> print E; -0.00024762. qcdb.interface_dftd3.run_dftd3(self, func=None, dashlvl=None, dashparam=None, dertype=None, verbose=False)[source]¶; Function to call Grimme’s dftd3 program (http://toc.uni-muenster.de/DFTD3/); to compute the -D correction of level dashlvl using parameters for; the functional func. The dictionary dashparam can be used to supply; a full set of dispersion parameters in the absense of func or to supply; individual overrides in the presence of func. Returns energy if dertype is 0,; gradient if dertype is 1, else tuple of energy and gradient if dertype; unspecified. The dftd3 executable must be independently compiled and found in; PATH or PSIPATH.; self may be either a qcdb.Molecule (sensibly) or a psi4.Molecule; (works b/c psi4.Molecule has been extended by this method py-side and; only public interface fns used) or a string that can be instantiated; into a qcdb.Molecule.; func - functional alias or None; dashlvl - functional type d2gr/d3zero/d3bj/d3mzero/d3mbj; dashparam - dictionary; dertype = derivative level. table of contents. Interface to DFTD3 by S. Grimme; Installation; Theory; Running DFTD3. Navigation. Index. modules    .    .    .    .  · ; 1.1;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities. © Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/dftd3-1.html:8305,energy,energy,8305,psi4manual/1.1.0/dftd3-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/dftd3-1.html,4,['energy'],['energy']
Energy Efficiency,"bXC; ""citation"": """", special reference for the dispersion correction parameters, appended to output; (if defined in driver, not if defined in input file); },. One can also use the dft_functional keyword argument to use the; orbitals generated by DFT for correlated wavefunction methods:; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17# MP2 with a PBE0 reference computation. molecule h2o {; 0 1; O; H 1 1.0; H 1 1.0 2 104.5; }. set {; basis 6-31G; dft_spherical_points 302; dft_radial_points 99; reference rks; }. mp2_dft = energy(""MP2"", dft_functional=""PBE0""). Note that this would only update the generic Psi variables (e.g., “CURRENT ENERGY”) and not the MP2 or DFT variables.; Psi4 also supports easy customization and manipulation of DFT functionals. The values of alpha and omega can be adjusted with the DFT_ALPHA; and DFT_OMEGA keywords. For example, for LRC functionals, one can control the fraction of long-range Hartree-Fock and short-range DFA by changing DFT_OMEGA:; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19; 20; 21; 22molecule ch2 {; 0 3; C; H 1 R; H 1 R 2 A. R = 1.075; A = 133.93; }. set reference uhf; set guess gwh; set basis cc-pvdz; set e_convergence 8. # Override the default value of omega; set dft_omega 2.0. E = energy('wb97x'). # Revoke the change for later computations if needed; revoke_global_option_changed('DFT_OMEGA'). This feature would be useful after finishing the IP fitting procedure, for example. table of contents. DFT: Density Functional Theory; Theory; Minimal Input; Spin/Symmetry Treatment; Functional Selection; Grid Selection; ERI Algorithms; IP Fitting; Fractional Particle Curves; Dispersion Corrections; Recommendations; Advanced Functional Use and Manipulation. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.3.2;  · . PSI4. Theoretical Methods: SCF to FCI. © Copyright 2019, The Psi4 Project.; Last updated on Wednesday, 15 May 2019 08:49PM.; Created using Sphinx 1.8.5.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/dft-1.html:32341,energy,energy,32341,psi4manual/1.3.2/dft-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/dft-1.html,2,['energy'],['energy']
Energy Efficiency,"b] - nocp_body_dict[nb-1]; for nb in nbodies:; nbody_dict[f""NOCP-CORRECTED TOTAL ENERGY THROUGH {nb}-BODY""] = nocp_body_dict[nb]. # Compute vmfc; if 'vmfc' in metadata['bsse_type']:; for nb in nbodies:; if ptype == ""energy"":; for k in range(1, nb + 1):; vmfc_body_dict[nb] += vmfc_by_level[k]. else:; if nb > 1:; vmfc_body_dict[nb] = vmfc_by_level[nb - 1]; vmfc_body_dict[nb] += vmfc_by_level[nb]. if ptype == ""energy"":; if not metadata[""quiet""]:; _print_nbody_energy(vmfc_body_dict, ""Valiron-Mayer Function Counterpoise (VMFC)"", metadata[""nfragments""], metadata['embedding_charges']). vmfc_interaction_energy = vmfc_body_dict[metadata['max_nbody']] - vmfc_body_dict[1]; nbody_dict['VMFC-CORRECTED TOTAL ENERGY'] = vmfc_body_dict[metadata['max_nbody']]; nbody_dict['VMFC-CORRECTED INTERACTION ENERGY'] = vmfc_interaction_energy. for nb in nbodies[1:]:; nbody_dict[f""VMFC-CORRECTED INTERACTION ENERGY THROUGH {nb}-BODY""] = vmfc_body_dict[nb] - vmfc_body_dict[1]; nbody_dict[f""VMFC-CORRECTED {nb}-BODY CONTRIBUTION TO ENERGY""] = vmfc_body_dict[nb] - vmfc_body_dict[nb-1]; for nb in nbodies:; nbody_dict[f""VMFC-CORRECTED TOTAL ENERGY THROUGH {nb}-BODY""] = vmfc_body_dict[nb]. # Collect specific and generalized returns; results = {; f""cp_{ptype}_body_dict"" : {f""{nb}cp"": j for nb, j in cp_body_dict.items()},; f""nocp_{ptype}_body_dict"": {f""{nb}nocp"": j for nb, j in nocp_body_dict.items()},; f""vmfc_{ptype}_body_dict"": {f""{nb}vmfc"": j for nb, j in vmfc_body_dict.items()},; }. if ptype == ""energy"":; results['nbody'] = nbody_dict. return_bsse_type = metadata[""bsse_type""][0]. if return_bsse_type == ""cp"":; results[f""{ptype}_body_dict""] = cp_body_dict; elif return_bsse_type == ""nocp"":; results[f""{ptype}_body_dict""] = nocp_body_dict; elif return_bsse_type == ""vmfc"":; results[f""{ptype}_body_dict""] = vmfc_body_dict; else:; raise ValidationError(; ""N-Body Wrapper: Invalid return type. Should never be here, please post this error on github.""). if ptype == ""energy"":; piece = results[f""{ptype}_body_dict""",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver_nbody.html:29546,ENERGY,ENERGY,29546,psi4manual/1.6.x/_modules/psi4/driver/driver_nbody.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver_nbody.html,15,['ENERGY'],['ENERGY']
Energy Efficiency,"bal. freq-masses; check nonphysical masses possible. stability2; ROHF stability analysis check for CN with cc-pVDZ. This test corresponds to the rohf-stab test from Psi3. dft1; DFT Functional Test all values update for new BraggSlater radii. cepa2; cc-pvdz H2O Test ACPF Energy/Properties. scf-level-shift-rks; SCF level shift on an RKS computation. scf-guess; Test initial SCF guesses on FH and FH+ in cc-pVTZ basis. opt8; Various constrained energy minimizations of HOOH with cc-pvdz RHF. Cartesian-coordinate constrained optimizations of HOOH in Cartesians. ci-property; CI/MCSCF cc-pvDZ properties for Potassium nitrate (rocket fuel!). dfccsd-grad1; DF-CCSD cc-pVDZ gradients for the H2O molecule. cc31; CCSD/sto-3g optical rotation calculation (both gauges) at two frequencies on methyloxirane. mints3; Test individual integral objects for correctness. dft-smoke; DFT Functional Smoke Test. dfmp2-grad4; DF-MP2 cc-pVDZ gradient for the NO molecule. soscf-ref; Triple and Singlet Oxygen energy SOSCF, also tests non-symmetric density matrices. dfomp2-grad2; OMP2 cc-pVDZ energy for the NO molecule. linK-1; RHF Linear Exchange Algorithm test for water. mbis-3; MBIS calculation on OH radical. sapt6; checks that all SAPT physical components (elst, exch, indc, disp) and total IE are being computed correctly for SAPT2+3(CCD)dMP2/aug-cc-pvdz and all lesser methods thereof. dft-grad-lr1; wB97X-D cc-pVDZ gradient of S22 HCN update df/pk_ref values due to new BraggSlater radii. dft2; DFT Functional Test. soscf-large; Second-order SCF convergnece: Benzene. cbs-xtpl-alpha; Extrapolated water energies. cc17; Single point energies of multiple excited states with EOM-CCSD. fd-gradient; SCF STO-3G finite-difference tests. mbis-6; MBIS calculation on H2O. cc14; ROHF-CCSD/cc-pVDZ \(^{3}B_1\) CH2 geometry optimization via analytic gradients. sapt-dft-lrc; SAPT(DFT) aug-cc-pVDZ interaction energy between Ne and Ar atoms. dft-ghost; DFT Functional Test for Range-Seperated Hybrids and Ghost atoms. s",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/autodoc_testsuite_corepsi4.html:31704,energy,energy,31704,psi4manual/1.7.x/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/autodoc_testsuite_corepsi4.html,2,['energy'],['energy']
Energy Efficiency,"bal_option(""BASIS"", PsiMod.get_global_option(""BASIS"")). df_ints_io = PsiMod.get_global_option('DF_INTS_IO'); # inquire if above at all applies to dfmp2 or just scf; PsiMod.set_global_option('DF_INTS_IO', 'SAVE'); psioh = PsiMod.IOManager.shared_object(); psioh.set_specific_retention(97, True). activate(molecule); molecule.update_geometry(). PsiMod.print_out(""\n""); banner(""CP Computation: Complex.\nFull Basis Set.""); PsiMod.print_out(""\n""); e_dimer = call_function_in_1st_argument(func, **kwargs); #e_dimer = energy(name, **kwargs). PsiMod.clean(); PsiMod.set_global_option('DF_INTS_IO', 'LOAD'). # All monomers with ghosts; monomers = extract_clusters(molecule, True, 1); e_monomer_full = []. cluster_n = 0; for cluster in monomers:; activate(cluster); PsiMod.print_out(""\n""); banner((""CP Computation: Monomer %d.\n Full Basis Set."" % (cluster_n + 1))); PsiMod.print_out(""\n""); e_monomer_full.append(call_function_in_1st_argument(func, **kwargs)); #e_monomer_full.append(energy(name,**kwargs)); cluster_n = cluster_n + 1; PsiMod.clean(). PsiMod.set_global_option('DF_INTS_IO', 'NONE'); if (check_bsse):; # All monomers without ghosts; monomers = extract_clusters(molecule, False, 1); e_monomer_bsse = []. cluster_n = 0; for cluster in monomers:; activate(cluster); PsiMod.print_out(""\n""); #cluster.print_to_output(); banner((""CP Computation: Monomer %d.\n Monomer Set."" % (cluster_n + 1))); PsiMod.print_out(""\n""); e_monomer_bsse.append(call_function_in_1st_argument(func, **kwargs)); #e_monomer_bsse.append(energy(name,**kwargs)); cluster_n = cluster_n + 1. PsiMod.set_global_option('DF_INTS_IO', df_ints_io); psioh.set_specific_retention(97, False). activate(molecule). if (check_bsse == False):; cp_table = Table(rows=[""System:""], cols=[""Energy (full):""]); cp_table[""Complex""] = [e_dimer]; for cluster_n in range(0, len(monomers)):; key = ""Monomer %d"" % (cluster_n + 1); cp_table[key] = [e_monomer_full[cluster_n]]. e_full = e_dimer; for cluster_n in range(0, len(monomers)):; e_full = e_full -",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/_modules/wrappers.html:20227,energy,energy,20227,psi4manual/4.0b3/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/_modules/wrappers.html,4,['energy'],['energy']
Energy Efficiency,"bal_option('QC_MODULE'). func = None; if reference in ['RHF', 'UHF', 'ROHF', 'RKS', 'UKS']:; if mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc_property. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_mp3(name, **kwargs):; """"""Function selecting the algorithm for a MP3 energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module == 'DETCI':; func = run_detci; elif module == 'FNOCC':; func = run_fnocc; elif module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc; elif reference == 'UHF':; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc; elif reference == 'ROHF':; if mtd_type == 'CONV':; if module == 'DETCI':; raise UpgradeHelper(""energy('mp3')"", ""energy('zapt3')"", 1.7,; "" Replace method MP with method ZAPT for ROHF reference. DETCI is orders-of-magnitude inefficient for perturbation theory.""). if module == 'DETCI':; core.print_out(""""""\nDETCI is ill-advised for method MP3 as it is available inefficiently as a """"""; """"""byproduct of a CISD computation.\n""""""). if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_mp3_gradient(name, **kwargs):; """"""Function selecting the algorithm for a MP3 gradient call; and directing to specified or best-performance default modules. """"""; reference ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:11999,energy,energy,11999,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,16,['energy'],['energy']
Energy Efficiency,"ball, unpack the source,; edit the Makefile to select a; Fortran compiler, and run make). From version 3.1.0 onwards, DFTD3 can; be used as-is; for earlier versions, patches are available:; psi4/psi4/share/psi4/scripts/patch_grimme_dftd3.3.0.2. To be used by PSI4, the classic program binary (dftd3) must be; found in your PATH or the s-dftd3 module in your PYTHONPATH; so QCEngine can detect it. Check if and where found through qcengine info. If; PSI4 is unable to execute the binary, an error will be reported.; To preferentially use a particular dftd3 compilation, simply adjust its; position in the path environment variables. Theory¶; The local or semilocal character of conventional density functionals; necessarily leads to neglect of the long-range correlation interactions; which capture attractive van der Waals forces. Initially proposed by Yang; [Wu:2002:515] and assiduously developed by Grimme, [Grimme:2004:1463]; [Grimme:2006:1787] [Grimme:2010:154104] the DFT+Dispersion method; appends to the base functional a scaled, damped, and fitted leading term; to the well-known dispersion energy series, \(E_{disp} = -C_6/R^6; -C_8/R^8 -C_{10}/R^{10}-\cdots\). The DFT-D2 [Grimme:2006:1787] variant; takes the explicit form below. Here, dispersion coefficients,; \(C_6^{ij}\), obtained from the geometric mean of tabulated elemental; values, are summed over interatomic distances, \(R_{ij}\), modulated; by a damping function, \(f_{damp}(R_{ij})\), that gradually activates; the dispersion correction (at a rate characterized by \(\alpha_6\)); over a distance characterized by the sum of the two atomic vdW radii,; \(R_{vdW}\), while an overall scaling term, \(s_6\), is optimized; to be unique to each \(E_{xc}\) functional. (\(\alpha_6\) is; sometimes allowed to vary as well.). (1)¶\[E_{disp}^{\text{D2}}=-s_6 \sum_{i,j>i}^{N_{at}} \frac{C_6^{ij}}{(R_{ij})^6} f_{damp}(R_{ij})\]. \[f_{damp}(R_{ij}) = \frac{1}{1 + e^{- \alpha_6 (R_{ij}/R_{vdW} - 1)}}\]; Grimme recently presented a refin",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/dftd3.html:3555,energy,energy,3555,psi4manual/1.7.x/dftd3.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/dftd3.html,4,['energy'],['energy']
Energy Efficiency,"based methods.; PSI4 implements the spin-free one-electron version of X2C, which produces; a modified one-electron Hamiltonian \(H_{\rm X2C}\):. \[H_{\rm X2C} = T_{\rm X2C} + V_{\rm X2C}\]; that is a sum of a kinetic energy (\(T_{\rm X2C}\)) and potential energy; (\(V_{\rm X2C}\)) operator.; Our implementation is equivalent to the one reported by Cheng and Gauss [Cheng:084114].; X2C calculations require the use of special (alternatively fully uncontracted) basis sets designed for relativistic; calculations. Common choices include the Dunning Douglass–Kroll basis sets; (cc-pVXZ-DK, cc-pCVXZ-DK, cc-pwCVXZ-DK) and Roos’ ANO basis sets. Note; See also Interface to DKH by A. Wolf, M. Reiher, and B. A. Hess for another relativistic Hamiltonian. A First Example¶; The following is a simple input that will perform a Hartree–Fock calculation; using the X2C Hamiltonian.; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12molecule {; H; F 1 0.92; }. set {; scf_type pk; basis cc-pvdz; relativistic x2c; }. energy('hf'). This computation yields the following result:; 1; 2; 3; 4; 5; 6; 7; 8@RHF Final Energy: -100.10007984692388. => Energetics <=. Nuclear Repulsion Energy = 5.1767335622934780; One-Electron Energy = -150.7611816259664579; Two-Electron Energy = 45.4843682167491039; Total Energy = -100.1000798469238902. while a non-relativistic calculation yields the following energy:; 1; 2; 3; 4; 5; 6; 7; 8@RHF Final Energy: -100.01928891411315. => Energetics <=. Nuclear Repulsion Energy = 5.1767335622934780; One-Electron Energy = -150.6645256529074572; Two-Electron Energy = 45.4685031765008461; Total Energy = -100.0192889141131474. Basis sets options¶; The X2C module in PSI4 supports different combinations of basis set.; By default, if the input file specifies only BASIS, then the X2C; module will solve the modified Dirac equation in an uncontracted basis and then; recontract the X2C Hamiltonian in the original basis.; Alternatively, the user can use BASIS_RELATIVISTIC to specify a different; basi",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/relativistic-1.html:1434,energy,energy,1434,psi4manual/1.1.0/relativistic-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/relativistic-1.html,6,['energy'],['energy']
Energy Efficiency,"based on options.; The total electronic energy [Eh] and correlation energy component [Eh]; for the MP2-like method formed by any reweighting of MP2 DOUBLES ENERGY; for opposite-spin and same-spin contributions, with; any singles carried along.; Depending on weights, may equal any of MP2, SCS-MP2, SCS(N)-MP2, etc. quantities.; Contrast with SCS-MP2 TOTAL ENERGY. CUSTOM SCS-MP2.5 TOTAL ENERGY¶. CUSTOM SCS-MP2.5 CORRELATION ENERGY¶. CUSTOM SCS-MP3 TOTAL ENERGY¶. CUSTOM SCS-MP3 CORRELATION ENERGY¶. CUSTOM SCS-LCCD TOTAL ENERGY¶. CUSTOM SCS-LCCD CORRELATION ENERGY¶. CUSTOM SCS-OMP2 TOTAL ENERGY¶. CUSTOM SCS-OMP2 CORRELATION ENERGY¶. CUSTOM SCS-OMP2.5 TOTAL ENERGY¶. CUSTOM SCS-OMP2.5 CORRELATION ENERGY¶. CUSTOM SCS-OMP3 TOTAL ENERGY¶. CUSTOM SCS-OMP3 CORRELATION ENERGY¶. CUSTOM SCS-OLCCD TOTAL ENERGY¶. CUSTOM SCS-OLCCD CORRELATION ENERGY¶; Changeable quantities based on options.; The total electronic energy [Eh] and correlation energy component [Eh]; for the method formed by any reweighting of the named method DOUBLES ENERGY; for opposite-spin and same-spin contributions, with; any singles carried along.; Contrast with :samp`SCS-{method} TOTAL ENERGY`. db_name DATABASE MEAN ABSOLUTE DEVIATION¶; The mean absolute deviation [kcal mol-1] of the requested method; name from the stored reference values for the requested reactions in; database db_name. If no reference is available, this will be a large; and nonsensical value. \[\frac{1}{n}\sum_{rxn}^{n}{| \textsf{\textsl{name}}_{rxn}-\text{REF}_{rxn} | }\]. db_name DATABASE MEAN SIGNED DEVIATION¶; The mean deviation [kcal mol-1] of the requested method name; from the stored reference values for the requested reactions in; database db_name. If no reference is available, this will be a large; and nonsensical value. \[\frac{1}{n}\sum_{rxn}^{n}{\textsf{\textsl{name}}_{rxn}-\text{REF}_{rxn}}\]. db_name DATABASE ROOT-MEAN-SQUARE DEVIATION¶; The rms deviation [kcal mol-1] of the requested method name; from the stored reference values f",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/glossary_psivariables-1.html:16788,energy,energy,16788,psi4manual/1.4.0/glossary_psivariables-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/glossary_psivariables-1.html,10,['energy'],['energy']
Energy Efficiency,"bases`) only for databases of bimolecular complexes; with non-frozen monomers, e.g., HBC6. :type symm: :ref:`boolean <op_py_boolean>`; :param symm: |dl| ``'on'`` |dr| || ``'off'``. Indicates whether the native symmetry of the database reagents is; employed (``'on'``) or whether it is forced to :math:`C_1` symmetry; (``'off'``). Some computational methods (e.g., SAPT) require no; symmetry, and this will be set by database(). :type zpe: :ref:`boolean <op_py_boolean>`; :param zpe: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether zero-point-energy corrections are appended to; single-point energy values. Option valid only for certain; thermochemical databases. Disabled until Hessians ready. :type benchmark: str; :param benchmark: |dl| ``'default'`` |dr| || ``'S22A'`` || etc. Indicates whether a non-default set of reference energies, if; available (See :ref:`sec:availableDatabases`), are employed for the; calculation of error statistics. :type tabulate: List[str]; :param tabulate: |dl| ``[]`` |dr| || ``['scf total energy', 'natom']`` || etc. Indicates whether to form tables of variables other than the; primary requested energy. Available for any PSI variable. :type subset: Union[str, List[str]]; :param subset:. Indicates a subset of the full database to run. This is a very; flexible option and can be used in three distinct ways, outlined; below. Note that two take a string and the last takes an array.; See :ref:`sec:availableDatabases` for available values. * ``'small'`` || ``'large'`` || ``'equilibrium'``; Calls predefined subsets of the requested database, either; ``'small'``, a few of the smallest database members,; ``'large'``, the largest of the database members, or; ``'equilibrium'``, the equilibrium geometries for a database; composed of dissociation curves.; * ``'BzBz_S'`` || ``'FaOOFaON'`` || ``'ArNe'`` || ``'HB'`` || etc.; For databases composed of dissociation curves, or otherwise; divided into subsets, individual curves and subsets can be; called by name. Co",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html:5799,energy,energy,5799,psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html,14,['energy'],['energy']
Energy Efficiency,"basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_SCF"",; core.get_option(""SCF"", ""DF_BASIS_SCF""),; ""JKFIT"", core.get_global_option('BASIS'),; puream=ref_wfn.basisset().has_puream()); ref_wfn.set_basisset(""DF_BASIS_SCF"", scf_aux_basis). if core.get_global_option(""RELATIVISTIC"") in [""X2C"", ""DKH""]:; rel_bas = core.BasisSet.build(ref_wfn.molecule(), ""BASIS_RELATIVISTIC"",; core.get_option(""SCF"", ""BASIS_RELATIVISTIC""),; ""DECON"", core.get_global_option('BASIS'),; puream=ref_wfn.basisset().has_puream()); ref_wfn.set_basisset('BASIS_RELATIVISTIC',rel_bas). fnocc_wfn = core.fnocc(ref_wfn). # set current correlation energy and total energy. only need to treat mpn here.; if (lbl := name.replace(""fno-"", """")) in [""mp3"", ""mp4(sdq)"", ""mp4""]:; fnocc_wfn.set_variable(""CURRENT ENERGY"", fnocc_wfn.variable(f""{lbl.upper()} TOTAL ENERGY"")); fnocc_wfn.set_variable(""CURRENT CORRELATION ENERGY"", fnocc_wfn.variable(f""{lbl.upper()} CORRELATION ENERGY"")); if lbl == ""mp4"":; fnocc_wfn.set_variable(""MP4 CORRECTION ENERGY"", fnocc_wfn.variable(""MP4 CORRELATION ENERGY"") - fnocc_wfn.variable(""MP3 CORRELATION ENERGY"")). # Shove variables into global space; for k, v in fnocc_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); return fnocc_wfn. def run_cepa(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a cepa-like calculation. >>> energy('cepa(1)'). """"""; kwargs = p4util.kwargs_lower(kwargs); dtl = docs_table_link(""dummy"", ""fnocc""). # save user options; optstash = p4util.OptionsState(; ['TRANSQT2', 'WFN'],; ['FNOCC', 'NAT_ORBS'],; ['FNOCC', 'DFCC'],; ['FNOCC', 'RUN_CEPA'],; ['FNOCC', 'USE_DF_INTS'],; ['FNOCC', 'CEPA_LEVEL'],; ['FNOCC', 'CEPA_NO_SINGLES']). # AED reinforces default; core.set_local_option('FNOCC', 'USE_DF_INTS', False). director = {; # Note ""nat_orbs"" not set defensively False for non-""fno"" calls; ""lccd"": { ""dfcc"": False, ""run_cepa"": True, ""cepa_level"": ""cepa(0)"", ""cepa_no_singles"": True, },; ""fno-lccd"": {""nat_orbs"": True, ""dfcc"": False, ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:174867,ENERGY,ENERGY,174867,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,4,['ENERGY'],['ENERGY']
Energy Efficiency,"basis and stage_scheme keywords) and compute; that stage in defining the CBS energy.; The cbs() function requires, at a minimum, name='scf' and scf_basis; keywords to be specified for reference-step only jobs and name and; corl_basis keywords for correlated jobs.; The following energy methods have been set up for cbs(). scf; df-scf; mp2. df-mp2; cc2; ccsd. bccd; cc3; ccsd(t). cisd; cisdt; cisdtq. cin; fci. Parameters:; name (string) – 'scf' || 'ccsd' || etc.; First argument, usually unlabeled. Indicates the computational method; for the correlation energy, unless only reference step to be performed,; in which case should be 'scf'. Overruled if stage_wfn keywords supplied. corl_wfn (string) – 'mp2' || 'ccsd(t)' || etc.; Indicates the energy method for which the correlation energy is to be; obtained. Can also be specified with name or as the unlabeled; first argument to the function. delta_wfn (string) – 'ccsd' || 'ccsd(t)' || etc.; Indicates the (superior) energy method for which a delta correction; to the correlation energy is to be obtained. delta_wfn_lesser (string) – 'mp2' || 'ccsd' || etc.; Indicates the inferior energy method for which a delta correction; to the correlation energy is to be obtained. delta2_wfn (string) – 'ccsd' || 'ccsd(t)' || etc.; Indicates the (superior) energy method for which a second delta correction; to the correlation energy is to be obtained. delta2_wfn_lesser (string) – 'mp2' || 'ccsd(t)' || etc.; Indicates the inferior energy method for which a second delta correction; to the correlation energy is to be obtained. Basis Sets; Currently, the basis set set through set commands have no influence; on a cbs calculation. Parameters:; scf_basis (basis string) – corl_basis || 'cc-pV[TQ]Z' || 'jun-cc-pv[tq5]z' || '6-31G*' || etc.; Indicates the sequence of basis sets employed for the reference energy.; If any correlation method is specified, scf_basis can default; to corl_basis. corl_basis (basis string) – 'cc-pV[TQ]Z' || 'jun-cc-pv[tq5]z' || '",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/cbs-1.html:3312,energy,energy,3312,psi4manual/4.0b3/cbs-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/cbs-1.html,4,['energy'],['energy']
Energy Efficiency,"basis for SAPT0 induction and dispersion, and the aug-pVDZ-JKFIT DF basis for SAPT0 electrostatics and induction. This example uses frozen core as well as asyncronous I/O while forming the DF integrals and CPHF coefficients. nbo; Generation of NBO file. frac-traverse; Scan fractional occupation of electrons updated values due to new BraggSlater radii. sapt-dft-lrc; SAPT(DFT) aug-cc-pVDZ interaction energy between Ne and Ar atoms. dfcasscf-sa-sp; Example of state-averaged CASSCF for the C2 molecule. soscf-dft; Triple and Singlet Oxygen energy SOSCF, also tests non-symmetric density matrices. sapt-compare; SAPT0 cc-pVDZ computation of the ethene-ethyne interaction energy, using the cc-pVDZ-JKFIT RI basis for SCF and cc-pVDZ-RI for SAPT. Monomer geometries are specified using Cartesian coordinates. dfomp3-2; DF-OMP3 cc-pVDZ energy for the H2O+ cation. cc7; Tests CCENERGY’s CCSD gradient in the presence of a dipole field. ghosts; Density fitted MP2 cc-PVDZ/cc-pVDZ-RI computation of formic acid dimer binding energy using explicit specification of ghost atoms. This is equivalent to the dfmp2_1 sample but uses both (equivalent) specifications of ghost atoms in a manual counterpoise correction. dfomp2-2; OMP2 cc-pVDZ energy for the NO molecule. olccd-freq1; OLCCD cc-pVDZ freqs for C2H2. opt5; 6-31G** UHF CH2 3B1 optimization. Uses a Z-Matrix with dummy atoms, just for demo and testing purposes. dft-custom-mgga; updated dldf reference to new BraggSlater radii Dispersionless density functional (dlDF+D) internal match to Psi4 Extensive testing has been done to match supplemental info of Szalewicz et. al., Phys. Rev. Lett., 103, 263201 (2009) and Szalewicz et. al., J. Phys. Chem. Lett., 1, 550-555 (2010). dfmp2-grad2; DF-MP2 cc-pVDZ gradient for the NO molecule. cc26; Single-point gradient, analytic and via finite-differences of 2-1A1 state of H2O with EOM-CCSD. mp2p5-grad1; MP2.5 cc-pVDZ gradient for the H2O molecule. sapt-exch-ind-inf; SAPT(DFT) aug-cc-pVDZ interaction energy ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/autodoc_testsuite_corepsi4-1.html:23144,energy,energy,23144,psi4manual/1.4.0/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodoc_testsuite_corepsi4-1.html,4,['energy'],['energy']
Energy Efficiency,"basis set arg1 to all atoms with symbol (e.g., H) arg0. set_comment(self, arg0); Sets molecule comment. set_connectivity(self, arg0); Sets molecule connectivity. set_full_geometry(self, arg0); Sets the geometry, given a (Natom X 3) matrix arg0 of coordinates (in Bohr) (including dummies. set_geometry(self, arg0); Sets the geometry, given a (Natom X 3) matrix arg0 of coordinates [a0] (excluding dummies). set_ghost_fragment(self, arg0); Sets the specified fragment arg0 to be Ghost. set_ghost_fragments(self, arg0); Sets the specified list arg0 of fragments to be Ghost. set_input_units_to_au(self, arg0); Sets unit conversion to [a0] for geometry. set_mass(self, atom, mass); Sets mass of atom (0-indexed) to mass (good for isotopic substitutions). set_molecular_charge(self, arg0); Change the overall molecular charge. set_multiplicity(self, arg0); Change the multiplicity (defined as 2S + 1). set_name(self, arg0); Sets molecule name. set_nuclear_charge(self, arg0, arg1); Set the nuclear charge of the given atom arg0 to the value arg1 (primarily for ECP). set_point_group(self, arg0); Sets the molecular point group to the point group object arg0. set_provenance(self, arg0); Sets molecule provenance. set_units(self, arg0); Sets units (Angstrom or Bohr) used to define the geometry. set_variable(self, arg0, arg1); Sets the value arg1 to the variable arg0 in the list of structure variables, then calls update_geometry(). symbol(self, atom); Gets the cleaned up label of atom (C2 => C, H4 = H) (0-indexed without dummies). symmetrize(self, arg0); Finds the highest point Abelian point group within the specified tolerance, and forces the geometry to have that symmetry. symmetry_from_input(self); Returns the symmetry specified in the input. to_arrays([dummy, ghost_as_dummy]); Exports coordinate info into NumPy arrays. to_dict([force_c1, force_units, np_out]); Serializes instance into Molecule dictionary. to_schema(dtype[, units]); Serializes instance into dictionary according to schema d",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/api/psi4.core.molecule.html:9318,charge,charge,9318,psi4manual/1.5.0/api/psi4.core.molecule.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/api/psi4.core.molecule.html,12,['charge'],['charge']
Energy Efficiency,"basis set library to check; if the basis actually exists. Used by complete_basis_set(). validate_scheme_args(functionname, **largs)[source]¶; Function called by each extrapolation scheme in complete_basis_set().; Checks that all the input arguments are present and suitable so that; the scheme function can focus on defining the extrapolation. qmmm¶; Module with classes to integrate MM charges into; a QM calculation. class Diffuse(molecule, basisname, ribasisname)[source]¶. fitGeneral()[source]¶; Function to perform a general fit of diffuse charges; to wavefunction density. fitScf()[source]¶; Function to run scf and fit a system of diffuse charges to; resulting density. populateExtern(extern)[source]¶. class QMMM[source]¶. addChargeAngstrom(Q, x, y, z)[source]¶; Function to add a point charge of magnitude Q at; position (x, y, z) Angstroms. addChargeBohr(Q, x, y, z)[source]¶; Function to add a point charge of magnitude Q at; position (x, y, z) Bohr. addDiffuse(diffuse)[source]¶; Function to add a diffuse charge field diffuse. populateExtern()[source]¶; Function to define a charge field external to the; molecule through point and diffuse charges. basislistother¶; Module with commands building BasisFamily objects; for Pople and other non-Dunning orbital basis sets. Some; plausible fitting basis sets are supplied as defaults. load_basfam_other()[source]¶. diatomic¶. functional¶; Module to provide lightweight definitions of functionals and; SuperFunctionals. build_b2plyp_superfunctional(name, npoints, deriv)[source]¶. build_b2plypd2gr_superfunctional(name, npoints, deriv)[source]¶. build_b2plypd2p4_superfunctional(name, npoints, deriv)[source]¶. build_b2plypd3bj_superfunctional(name, npoints, deriv)[source]¶. build_b2plypd3zero_superfunctional(name, npoints, deriv)[source]¶. build_b3_x_functional(name)[source]¶. build_b3lyp5_superfunctional(name, npoints, deriv)[source]¶. build_b3lyp5d2gr_superfunctional(name, npoints, deriv)[source]¶. build_b3lyp5d2p4_superfunctional(nam",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/autodoc_driver-1.html:24588,charge,charge,24588,psi4manual/4.0b4/autodoc_driver-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/autodoc_driver-1.html,2,['charge'],['charge']
Energy Efficiency,"basis set library to check; if the basis actually exists. Used by complete_basis_set(). validate_scheme_args(functionname, **largs)[source]¶; Function called by each extrapolation scheme in complete_basis_set().; Checks that all the input arguments are present and suitable so that; the scheme function can focus on defining the extrapolation. qmmm¶; Module with classes to integrate MM charges into; a QM calculation. class Diffuse(molecule, basisname, ribasisname)[source]¶. fitGeneral()[source]¶; Function to perform a general fit of diffuse charges; to wavefunction density. fitScf()[source]¶; Function to run scf and fit a system of diffuse charges to; resulting density. populateExtern(extern)[source]¶. class QMMM[source]¶. addChargeAngstrom(Q, x, y, z)[source]¶; Function to add a point charge of magnitude Q at; position (x, y, z) Angstroms. addChargeBohr(Q, x, y, z)[source]¶; Function to add a point charge of magnitude Q at; position (x, y, z) Bohr. addDiffuse(diffuse)[source]¶; Function to add a diffuse charge field diffuse. populateExtern()[source]¶; Function to define a charge field external to the; molecule through point and diffuse charges. basislistother¶; Module with commands building BasisFamily objects; for Pople and other non-Dunning orbital basis sets. Some; plausible fitting basis sets are supplied as defaults. load_basfam_other()[source]¶. diatomic¶. functional¶; Module to provide lightweight definitions of functionals and; SuperFunctionals. build_b2plyp_superfunctional(name, npoints, deriv)[source]¶. build_b2plypd2gr_superfunctional(name, npoints, deriv)¶. build_b2plypd2p4_superfunctional(name, npoints, deriv)¶. build_b2plypd3bj_superfunctional(name, npoints, deriv)¶. build_b2plypd3zero_superfunctional(name, npoints, deriv)¶. build_b3_x_functional(name)[source]¶. build_b3lyp5_superfunctional(name, npoints, deriv)[source]¶. build_b3lyp5d2gr_superfunctional(name, npoints, deriv)¶. build_b3lyp5d2p4_superfunctional(name, npoints, deriv)¶. build_b3lyp5d3bj_su",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/autodoc_driver-1.html:22416,charge,charge,22416,psi4manual/4.0b3/autodoc_driver-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodoc_driver-1.html,2,['charge'],['charge']
Energy Efficiency,"basis set library to check; if the basis actually exists. Used by complete_basis_set(). validate_scheme_args(functionname, **largs)[source]¶; Function called by each extrapolation scheme in complete_basis_set().; Checks that all the input arguments are present and suitable so that; the scheme function can focus on defining the extrapolation. qmmm¶; Module with classes to integrate MM charges into; a QM calculation. class Diffuse(molecule, basisname, ribasisname)[source]¶. fitGeneral()[source]¶; Function to perform a general fit of diffuse charges; to wavefunction density. fitScf()[source]¶; Function to run scf and fit a system of diffuse charges to; resulting density. populateExtern(extern)[source]¶. class QMMM[source]¶. addChargeAngstrom(Q, x, y, z)[source]¶; Function to add a point charge of magnitude Q at; position (x, y, z) Angstroms. addChargeBohr(Q, x, y, z)[source]¶; Function to add a point charge of magnitude Q at; position (x, y, z) Bohr. addDiffuse(diffuse)[source]¶; Function to add a diffuse charge field diffuse. populateExtern()[source]¶; Function to define a charge field external to the; molecule through point and diffuse charges. diatomic¶. functional¶; Module to provide lightweight definitions of functionals and; SuperFunctionals. build_b2plyp_superfunctional(name, npoints, deriv)[source]¶. build_b2plypd2gr_superfunctional(name, npoints, deriv)[source]¶. build_b2plypd2p4_superfunctional(name, npoints, deriv)[source]¶. build_b2plypd3bj_superfunctional(name, npoints, deriv)[source]¶. build_b2plypd3zero_superfunctional(name, npoints, deriv)[source]¶. build_b3_x_functional(name)[source]¶. build_b3lyp5_superfunctional(name, npoints, deriv)[source]¶. build_b3lyp5d2gr_superfunctional(name, npoints, deriv)[source]¶. build_b3lyp5d2p4_superfunctional(name, npoints, deriv)[source]¶. build_b3lyp5d3bj_superfunctional(name, npoints, deriv)[source]¶. build_b3lyp5d3zero_superfunctional(name, npoints, deriv)[source]¶. build_b3lyp_superfunctional(name, npoints, deriv)[",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/autodoc_driver-1.html:19941,charge,charge,19941,psi4manual/4.0b5/autodoc_driver-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodoc_driver-1.html,2,['charge'],['charge']
Energy Efficiency,"basis set library to check; if the basis actually exists. Used by complete_basis_set(). validate_scheme_args(functionname, **largs)[source]¶; Function called by each extrapolation scheme in complete_basis_set().; Checks that all the input arguments are present and suitable so that; the scheme function can focus on defining the extrapolation. qmmm¶; Module with classes to integrate MM charges into; a QM calculation. class Diffuse(molecule, basisname, ribasisname)[source]¶. fitGeneral()[source]¶; Function to perform a general fit of diffuse charges; to wavefunction density. fitScf()[source]¶; Function to run scf and fit a system of diffuse charges to; resulting density. populateExtern(extern)[source]¶. class QMMM[source]¶. addChargeAngstrom(Q, x, y, z)[source]¶; Function to add a point charge of magnitude Q at; position (x, y, z) Angstroms. addChargeBohr(Q, x, y, z)[source]¶; Function to add a point charge of magnitude Q at; position (x, y, z) Bohr. addDiffuse(diffuse)[source]¶; Function to add a diffuse charge field diffuse. populateExtern()[source]¶; Function to define a charge field external to the; molecule through point and diffuse charges. functional¶; Module to provide lightweight definitions of functionals and; SuperFunctionals. build_b3_x_functional(name)[source]¶. build_b3lyp5_superfunctional(name, npoints, deriv)[source]¶. build_b3lyp5d_superfunctional(name, npoints, deriv)[source]¶. build_b3lyp_superfunctional(name, npoints, deriv)[source]¶. build_b3lypd_superfunctional(name, npoints, deriv)[source]¶. build_b88_x_functional(name)[source]¶. build_b970_superfunctional(name, npoints, deriv)[source]¶. build_b971_superfunctional(name, npoints, deriv)[source]¶. build_b972_superfunctional(name, npoints, deriv)[source]¶. build_b97_x_functional(name)[source]¶. build_b97d_superfunctional(name, npoints, deriv)[source]¶. build_blyp_superfunctional(name, npoints, deriv)[source]¶. build_blypd_superfunctional(name, npoints, deriv)[source]¶. build_bp86_superfunctional(nam",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/autodoc_driver-1.html:14431,charge,charge,14431,psi4manual/4.0b2/autodoc_driver-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/autodoc_driver-1.html,2,['charge'],['charge']
Energy Efficiency,"basis set. We will specify the; geometry of our water molecule using a standard Z-matrix.; # Any line starting with the # character is a comment line; #! Sample HF/cc-pVDZ H2O computation. memory 250 mb. molecule h2o {; O ; H 1 0.96; H 1 0.96 2 104.5; }. set basis cc-pVDZ; energy('scf'). Note; The memory and basis set specifications are placed before the; energy function is called. Any user options need to; be set before the procedure they are meant to affect. For your convenience, the above example can be found in; tu1-h2o-energy.; You can run it if you wish.; Once Psi4 is in your path (see the; User Configuration; section of the installation instructions), you can run this computation by typing; >>> psi4 input.dat output.dat. If everything goes well, the computation should complete and should report; a final restricted Hartree–Fock energy in a section like this:; Energy converged. @RHF Final Energy: -76.02663273410671. By default, the energy should be converged to about , so agreement; is only expected for about the first 6 digits after the decimal. If the; computation does not complete, there is probably a problem with the; compilation or installation of the program (see the installation; instructions in Sec. Compiling and Installing from Source).; This very simple input is sufficient to run the requested information.; Notice that we didn’t tell the program some otherwise useful information; like the charge on the molecule (0, it’s neutral), the spin multiplicity; (1 for a closed-shell molecule with all electrons paired), or the reference; wavefunction to use (restricted Hartree–Fock, or RHF, is usually; appropriate for a closed-shell molecule). The program correctly guessed; all of these options for us. We can change the default behavior through; additional keywords.; Let’s consider what we would do for an open-shell molecule, where; not all electrons are paired. For example, let’s run a computation; on methylene (CH2), whose ground electronic state has two unpai",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/tutorial-1.html:2295,energy,energy,2295,psi4manual/1.0.0/tutorial-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/tutorial-1.html,2,['energy'],['energy']
Energy Efficiency,"basis sets employed for the correlation energy. :type delta_basis: :ref:`basis string <apdx:basisElement>`; :param delta_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the delta correction; to the correlation energy. :type delta2_basis: :ref:`basis string <apdx:basisElement>`; :param delta2_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the second delta correction; to the correlation energy. :type delta3_basis: :ref:`basis string <apdx:basisElement>`; :param delta3_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the third delta correction; to the correlation energy. :type delta4_basis: :ref:`basis string <apdx:basisElement>`; :param delta4_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the fourth delta correction; to the correlation energy. :type delta5_basis: :ref:`basis string <apdx:basisElement>`; :param delta5_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the fifth delta correction; to the correlation energy. * Schemes; Transformations of the energy through basis set extrapolation for each; stage of the CBS definition. A complaint is generated if number of basis; sets in stage_basis does not exactly satisfy requirements of stage_scheme.; An exception is the default, ``'highest_1'``, which uses the best basis; set available. See `Extrapolation Schemes`_ for all available schemes. :type scf_scheme: function; :param scf_scheme: |dl| ``highest_1`` |dr| || ``scf_xtpl_helgaker_3`` || etc. Indicates the basis set extrapolation scheme to be applied to the reference energy. :type corl_scheme: function; :param corl_scheme: |dl| ``highest_1`` |dr| || ``corl_xtpl_helgaker_2`` || etc. Indicates the bas",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:59507,energy,energy,59507,psi4manual/4.0b5/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html,2,['energy'],['energy']
Energy Efficiency,"basis sets employed for the correlation energy. :type delta_basis: :ref:`basis string <apdx:basisElement>`; :param delta_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the delta correction; to the correlation energy. :type delta2_basis: :ref:`basis string <apdx:basisElement>`; :param delta2_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the second delta correction; to the correlation energy. :type delta3_basis: :ref:`basis string <apdx:basisElement>`; :param delta3_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the third delta correction; to the correlation energy. :type delta4_basis: :ref:`basis string <apdx:basisElement>`; :param delta4_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the fourth delta correction; to the correlation energy. :type delta5_basis: :ref:`basis string <apdx:basisElement>`; :param delta5_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the fifth delta correction; to the correlation energy. * Schemes; Transformations of the energy through basis set extrapolation for each; stage of the CBS definition. A complaint is generated if number of basis; sets in stage_basis does not exactly satisfy requirements of stage_scheme.; An exception is the default, ``'xtpl_highest_1'``, which uses the best basis; set available. See :ref:`sec:cbs_xtpl` for all available schemes. :type scf_scheme: function; :param scf_scheme: |dl| ``xtpl_highest_1`` |dr| || ``scf_xtpl_helgaker_3`` || etc. Indicates the basis set extrapolation scheme to be applied to the reference energy.; Defaults to :py:func:`~scf_xtpl_helgaker_3` if three valid basis sets; present in ``scf_basis``, :py:func:`~scf_xtpl_hel",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/driver_cbs.html:24815,energy,energy,24815,psi4manual/1.1.0/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/driver_cbs.html,2,['energy'],['energy']
Energy Efficiency,"basis sets employed for the correlation energy. :type delta_basis: :ref:`basis string <apdx:basisElement>`; :param delta_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the delta correction; to the correlation energy. :type delta2_basis: :ref:`basis string <apdx:basisElement>`; :param delta2_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the second delta correction; to the correlation energy. :type delta3_basis: :ref:`basis string <apdx:basisElement>`; :param delta3_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the third delta correction; to the correlation energy. :type delta4_basis: :ref:`basis string <apdx:basisElement>`; :param delta4_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the fourth delta correction; to the correlation energy. :type delta5_basis: :ref:`basis string <apdx:basisElement>`; :param delta5_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the fifth delta correction; to the correlation energy. * Schemes; Transformations of the energy through basis set extrapolation for each; stage of the CBS definition. A complaint is generated if number of basis; sets in stage_basis does not exactly satisfy requirements of stage_scheme.; An exception is the default, ``'xtpl_highest_1'``, which uses the best basis; set available. See `Extrapolation Schemes`_ for all available schemes. :type scf_scheme: function; :param scf_scheme: |dl| ``xtpl_highest_1`` |dr| || ``scf_xtpl_helgaker_3`` || etc. Indicates the basis set extrapolation scheme to be applied to the reference energy.; Defaults to :py:func:`~scf_xtpl_helgaker_3` if three valid basis sets; present in ``scf_basis``, :py:func:`~scf_xtp",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html:24457,energy,energy,24457,psi4manual/1.0.0/_modules/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html,1,['energy'],['energy']
Energy Efficiency,"basis sets, databases, plugins, and executables in non-install locations. dft-pruning; Tests all grid pruning options available and screening of small weights. Check against grid size. psimrcc-fd-freq2; Mk-MRCCSD frequencies. \(^1A_1\) O$_3` state described using the Ms = 0 component of the singlet. Uses TCSCF orbitals. rasci-c2-active; 6-31G* C2 Test RASCI Energy Point, testing two different ways of specifying the active space, either with the ACTIVE keyword, or with RAS1, RAS2, RESTRICTED_DOCC, and RESTRICTED_UOCC. cbs-xtpl-energy; Extrapolated water energies. dct2; DC-06 calculation for the He dimer. This performs a two-step update of the orbitals and cumulant, using DIIS extrapolation. Four-virtual integrals are handled in the MO Basis. cc25; Single point gradient of 1-2B2 state of H2O+ with EOM-CCSD. dfmp2-grad5; Tests DF-MP2 gradient in the presence of a dipole field. dft-reference; MP2 with a PBE0 reference computation. mbis-1; MBIS calculation on H2O. dfomp3-1; DF-OMP3 cc-pVDZ energy for the H2O molecule. dfomp2p5-2; DF-OMP2.5 cc-pVDZ energy for the H2O+ cation. cc11; Frozen-core CCSD(ROHF)/cc-pVDZ on CN radical with disk-based AO algorithm. dft-b2plyp; Double-hybrid density functional B2PYLP. Reproduces portion of Table I in S. Grimme’s J. Chem. Phys 124 034108 (2006) paper defining the functional. dct5; DC-06 calculation for the O2 molecule (triplet ground state). This performs geometry optimization using two-step and simultaneous solution of the response equations for the analytic gradient. cbs-xtpl-func; optimization with method defined via cbs. pywrap-bfs; apply linear fragmentation algorithm to a water cluster. cc28; CCSD/cc-pVDZ optical rotation calculation (length gauge only) on Z-mat H2O2. fci-tdm-2; BH-H2+ FCI/cc-pVDZ Transition Dipole Moment. fci-h2o; 6-31G H2O Test FCI Energy Point. opt11; Transition-state optimizations of HOOH to both torsional transition states. dft3; DFT integral algorithms test, performing w-B97 RKS and UKS computations on wat",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/autodoc_testsuite_corepsi4-1.html:40669,energy,energy,40669,psi4manual/1.4.0/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodoc_testsuite_corepsi4-1.html,4,['energy'],['energy']
Energy Efficiency,"basis specification. pywrap-checkrun-uhf; This checks that all energy methods can run with a minimal input and set symmetry. omp2p5-1; OMP2.5 cc-pVDZ energy for the H2O molecule. fsapt-ext-abc-au; analog of fsapt-ext-abc with molecule and external potentials in Bohr. dfccsdl1; DF-CCSDL cc-pVDZ energy for the H2O molecule. dfcasscf-sp; CASSCF/6-31G** energy point. cisd-h2o+-1; 6-31G** H2O+ Test CISD Energy Point. scf-level-shift-rohf; SCF level shift on an ROHF computation. scf-hess3; CONV SCF 6-31G analytical vs finite-difference tests Tests UHF hessian code for Ca != Cb. pywrap-alias; Test parsed and exotic calls to energy() like zapt4, mp2.5, and cisd are working. scf-response3; UHF Dipole Polarizability Test. ddd-deriv; Sample HF/cc-pVDZ H2O computation all derivatives. pywrap-db3; Test that Python Molecule class processes geometry like psi4 Molecule class. sapt8; SAPT0(ROHF) open-shell computation of CN - Ne interaction energy First with jun-cc-pVDZ and density fitted integrals with ROHF Then with cc-pVDZ and direct integrals, except for dispersion that is computed with cc-pVDZ-ri density fitting with ROHF. dfccsdat1; DF-CCSD(AT) cc-pVDZ energy for the H2O molecule. scf-coverage; Lithium test for coverage. tdscf-2; td-uhf test on triplet states of methylene (tda), wfn passing. cc9a; ROHF-CCSD(T) cc-pVDZ energy for the \(^2\Sigma^+\) state of the CN radical, with Z-matrix input. cbs-parser; mtd/basis syntax examples. casscf-fzc-sp; CASSCF/6-31G** energy point. scf-hess4; DF SCF 6-31G UHFl vs RHF test Tests DF UHF hessian code for Ca = Cb. dft-pruning; Tests all grid pruning options available and screening of small weights. Check against grid size. dft-custom-hybrid; DFT (hybrids) test of implementations in: hybrid_superfuncs.py. nbody-intermediates; HF/cc-pVDZ many body energies of an arbitrary noble gas trimer complex Size vs cost tradeoff is rough here. isapt2; This is a shorter version if isapt1 - does not do cube plots. See isapt1 for full details. cbs-xtpl-f",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/autodoc_testsuite_corepsi4.html:4084,energy,energy,4084,psi4manual/1.9.x/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/autodoc_testsuite_corepsi4.html,2,['energy'],['energy']
Energy Efficiency,"basis']); and (mc['f_options'] == mce['f_options'])):; mce['f_energy'] = mc['f_energy']; mce['f_gradient'] = mc['f_gradient']; mce['f_hessian'] = mc['f_hessian']; mce['f_dipole'] = mc['f_dipole']; mce['f_dipder'] = mc['f_dipder']. # logger.debug(""MC\n"" + pp.pformat(mc)). cbs_results, self.cbsrec = _assemble_cbs_components(self.metameta, self.trove, self.cbsrec). instructions = _summary_table(self.metadata, self.trove, self.cbsrec); core.print_out(instructions); logger.info(instructions). # logger.debug('CBS_RESULTS\n' + pp.pformat(cbs_results)); # logger.debug('GRAND_NEED\n' + pp.pformat(self.cbsrec)). cbs_results[""module""] = modules; return cbs_results. [docs]; def get_results(self, client: Optional[""qcportal.FractalClient""] = None) -> AtomicResult:; """"""Return results as Composite-flavored QCSchema."""""". assembled_results = self._prepare_results(client=client); E0 = assembled_results[""energy""]. # load QCVariables & properties; qcvars = {; 'CBS NUMBER': len(self.compute_list),; 'NUCLEAR REPULSION ENERGY': self.molecule.nuclear_repulsion_energy(),; }. properties = {; ""calcinfo_natom"": self.molecule.natom(),; ""nuclear_repulsion_energy"": self.molecule.nuclear_repulsion_energy(),; ""return_energy"": E0,; }. for qcv in ['CBS', 'CURRENT']:; qcvars[qcv + ' REFERENCE ENERGY'] = self.cbsrec[0]['d_energy']; qcvars[qcv + ' CORRELATION ENERGY'] = E0 - self.cbsrec[0]['d_energy']; qcvars[qcv + ('' if qcv == 'CURRENT' else ' TOTAL') + ' ENERGY'] = E0. for idelta in range(int(len(self.cbsrec) / 2)):; if idelta == 0:; continue; dc = idelta * 2 + 1; qcvars[f""CBS {self.cbsrec[dc]['d_stage'].upper()} TOTAL ENERGY""] = self.cbsrec[dc][""d_energy""] - self.cbsrec[dc + 1][""d_energy""]. G0 = assembled_results[""gradient""]; if G0 is not None:; qcvars[""CURRENT GRADIENT""] = G0; qcvars[""CBS TOTAL GRADIENT""] = G0; properties[""return_gradient""] = G0. H0 = assembled_results[""hessian""]; if H0 is not None:; qcvars[""CURRENT HESSIAN""] = H0; qcvars[""CBS TOTAL HESSIAN""] = H0; properties[""return_hessian""] = H0. ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html:58931,ENERGY,ENERGY,58931,psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html,3,['ENERGY'],['ENERGY']
Energy Efficiency,"basis'], '', GRAND_NEED[0]['d_energy'],; GRAND_NEED[0]['d_scheme'].__name__); if len(metadata) > 1:; tables += """""" %6s %20s %1s %-27s %2s %16.8f %-s\n"""""" % (; GRAND_NEED[1]['d_stage'], GRAND_NEED[1]['d_wfn'], '/', GRAND_NEED[1]['d_basis'], '',; GRAND_NEED[1]['d_energy'] - GRAND_NEED[2]['d_energy'], GRAND_NEED[1]['d_scheme'].__name__); if len(metadata) > 2:; dc = 3; for delta in metadata[2:]:; deltaE_total = GRAND_NEED[dc]['d_energy'] - GRAND_NEED[dc + 1]['d_energy']; tables += """""" %6s %20s %1s %-27s %2s %16.8f %-s\n"""""" % (; GRAND_NEED[dc]['d_stage'], GRAND_NEED[dc]['d_wfn'] + ' - ' + GRAND_NEED[dc + 1]['d_wfn'], '/',; GRAND_NEED[dc]['d_basis'], '', deltaE_total,; GRAND_NEED[dc]['d_scheme'].__name__); core.set_variable(f""CBS {GRAND_NEED[dc]['d_stage'].upper()} TOTAL ENERGY"", deltaE_total); dc += 2. tables += """""" %6s %20s %1s %-27s %2s %16.8f %-s\n"""""" % ('total', 'CBS', '', '', '', finalenergy, ''); tables += table_delimit. core.print_out(tables). core.set_variable('CBS REFERENCE ENERGY', GRAND_NEED[0]['d_energy']); core.set_variable('CBS CORRELATION ENERGY', finalenergy - GRAND_NEED[0]['d_energy']); core.set_variable('CBS TOTAL ENERGY', finalenergy); core.set_variable('CURRENT REFERENCE ENERGY', GRAND_NEED[0]['d_energy']); core.set_variable('CURRENT CORRELATION ENERGY', finalenergy - GRAND_NEED[0]['d_energy']); core.set_variable('CURRENT ENERGY', finalenergy); core.set_variable('CBS NUMBER', Njobs). # new skeleton wavefunction w/mol, highest-SCF basis (just to choose one), & not energy; basis = core.BasisSet.build(molecule, ""ORBITAL"", 'def2-svp'); wfn = core.Wavefunction(molecule, basis). optstash.restore(). if ptype == 'energy':; finalquantity = finalenergy; elif ptype == 'gradient':; finalquantity = finalgradient; wfn.set_gradient(finalquantity); if finalquantity.rows(0) < 20:; core.print_out('CURRENT GRADIENT'); finalquantity.print_out(); elif ptype == 'hessian':; finalquantity = finalhessian; wfn.set_gradient(finalgradient); wfn.set_hessian(finalquantity); if fin",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html:59497,ENERGY,ENERGY,59497,psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html,2,['ENERGY'],['ENERGY']
Energy Efficiency,"basis'].lower()); else:; raise ValidationError('DELTA basis sets through keyword \'%s\' are required.' % ('delta_basis')). # Establish list of valid basis sets for second delta correction energy; if do_delta2:; if 'delta2_basis' in kwargs:; BSTD2, ZETD2 = validate_bracketed_basis(kwargs['delta2_basis'].lower()); else:; raise ValidationError('DELTA2 basis sets through keyword \'%s\' are required.' % ('delta2_basis')). # Establish treatment for scf energy (validity check useless since python will catch it long before here); cbs_scf_scheme = highest_1; if 'scf_scheme' in kwargs:; cbs_scf_scheme = kwargs['scf_scheme']. # Establish treatment for correlation energy; cbs_corl_scheme = highest_1; if 'corl_scheme' in kwargs:; cbs_corl_scheme = kwargs['corl_scheme']. # Establish treatment for delta correction energy; cbs_delta_scheme = highest_1; if 'delta_scheme' in kwargs:; cbs_delta_scheme = kwargs['delta_scheme']. # Establish treatment for delta2 correction energy; cbs_delta2_scheme = highest_1; if 'delta2_scheme' in kwargs:; cbs_delta2_scheme = kwargs['delta2_scheme']. # Build string of title banner; cbsbanners = ''; cbsbanners += """"""PsiMod.print_out('\\n')\n""""""; cbsbanners += """"""banner(' CBS Setup ')\n""""""; cbsbanners += """"""PsiMod.print_out('\\n')\n\n""""""; exec cbsbanners. # Call schemes for each portion of total energy to 'place orders' for calculations needed; d_fields = ['d_stage', 'd_scheme', 'd_basis', 'd_wfn', 'd_need', 'd_coef', 'd_energy']; f_fields = ['f_wfn', 'f_portion', 'f_basis', 'f_zeta', 'f_energy']; GRAND_NEED = []; MODELCHEM = []; bstring = ''; if do_scf:; NEED = call_function_in_1st_argument(cbs_scf_scheme,; mode='requisition', basisname=BSTR, basiszeta=ZETR, wfnname='scf'); GRAND_NEED.append(dict(zip(d_fields, ['scf', cbs_scf_scheme, reconstitute_bracketed_basis(NEED), 'scf', NEED, +1, 0.0]))). if do_corl:; NEED = call_function_in_1st_argument(cbs_corl_scheme,; mode='requisition', basisname=BSTC, basiszeta=ZETC, wfnname=cbs_corl_wfn); GRAND_NEED.append(d",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:65562,energy,energy,65562,psi4manual/4.0b2/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html,2,['energy'],['energy']
Energy Efficiency,"basis'].lower()); else:; raise ValidationError('DELTA basis sets through keyword \'%s\' are required.' % ('delta_basis')). # Establish list of valid basis sets for second delta correction energy; if do_delta2:; if 'delta2_basis' in kwargs:; BSTD2, ZETD2 = validate_bracketed_basis(kwargs['delta2_basis'].lower()); else:; raise ValidationError('DELTA2 basis sets through keyword \'%s\' are required.' % ('delta2_basis')). # Establish treatment for scf energy (validity check useless since python will catch it long before here); cbs_scf_scheme = highest_1; if 'scf_scheme' in kwargs:; cbs_scf_scheme = kwargs['scf_scheme']. # Establish treatment for correlation energy; cbs_corl_scheme = highest_1; if 'corl_scheme' in kwargs:; cbs_corl_scheme = kwargs['corl_scheme']. # Establish treatment for delta correction energy; cbs_delta_scheme = highest_1; if 'delta_scheme' in kwargs:; cbs_delta_scheme = kwargs['delta_scheme']. # Establish treatment for delta2 correction energy; cbs_delta2_scheme = highest_1; if 'delta2_scheme' in kwargs:; cbs_delta2_scheme = kwargs['delta2_scheme']. # Build string of title banner; cbsbanners = ''; cbsbanners += """"""PsiMod.print_out('\\n')\n""""""; cbsbanners += """"""banner(' CBS Setup ')\n""""""; cbsbanners += """"""PsiMod.print_out('\\n')\n\n""""""; exec(cbsbanners). # Call schemes for each portion of total energy to 'place orders' for calculations needed; d_fields = ['d_stage', 'd_scheme', 'd_basis', 'd_wfn', 'd_need', 'd_coef', 'd_energy']; f_fields = ['f_wfn', 'f_portion', 'f_basis', 'f_zeta', 'f_energy']; GRAND_NEED = []; MODELCHEM = []; bstring = ''; if do_scf:; NEED = call_function_in_1st_argument(cbs_scf_scheme,; mode='requisition', basisname=BSTR, basiszeta=ZETR, wfnname='scf'); GRAND_NEED.append(dict(zip(d_fields, ['scf', cbs_scf_scheme, reconstitute_bracketed_basis(NEED), 'scf', NEED, +1, 0.0]))). if do_corl:; NEED = call_function_in_1st_argument(cbs_corl_scheme,; mode='requisition', basisname=BSTC, basiszeta=ZETC, wfnname=cbs_corl_wfn); GRAND_NEED.append(",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/_modules/wrappers.html:66662,energy,energy,66662,psi4manual/4.0b3/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/_modules/wrappers.html,4,['energy'],['energy']
Energy Efficiency,"basis'].lower().replace('*', 's')); exec(commands). # Stash and set options if any; if mc[""f_options""]:; optionstash = p4util.OptionsState(*[[opt] for opt in list(mc[""f_options""])]); for k, v, in mc[""f_options""].items():; core.set_global_option(k.upper(), v); else:; optionstash = False. # Make energy(), etc. call; response = func(molecule=molecule, **kwargs); if ptype == 'energy':; mc['f_energy'] = response; elif ptype == 'gradient':; mc['f_gradient'] = response; mc['f_energy'] = core.variable('CURRENT ENERGY'); if verbose > 1:; mc['f_gradient'].print_out(); elif ptype == 'hessian':; mc['f_hessian'] = response; mc['f_energy'] = core.variable('CURRENT ENERGY'); if verbose > 1:; mc['f_hessian'].print_out(); Njobs += 1; if verbose > 1:; core.print_out(""\nCURRENT ENERGY: %14.16f\n"" % mc['f_energy']). # Restore modified options; if optionstash:; optionstash.restore(). # Fill in energies for subsumed methods; if ptype == 'energy':; for wfn in VARH[mc['f_wfn']]:; for job in JOBS_EXT:; if (wfn == job['f_wfn']) and (mc['f_basis'] == job['f_basis']) and \; (mc['f_options'] == job['f_options']):; job['f_energy'] = core.variable(VARH[wfn][wfn]). if verbose > 1:; core.print_variables(); core.clean_variables(); core.clean(). # Copy data from 'run' to 'obtained' table; for mce in JOBS_EXT:; if (mc['f_wfn'] == mce['f_wfn']) and (mc['f_basis'] == mce['f_basis']) and \; (mc['f_options'] == mce['f_options']):; mce['f_energy'] = mc['f_energy']; mce['f_gradient'] = mc['f_gradient']; mce['f_hessian'] = mc['f_hessian']. psioh.set_specific_retention(psif.PSIF_SCF_MOS, False). # Build string of title banner; cbsbanners = ''; cbsbanners += """"""core.print_out('\\n')\n""""""; cbsbanners += """"""p4util.banner(' CBS Results: %s ' % label)\n""""""; cbsbanners += """"""core.print_out('\\n')\n\n""""""; exec(cbsbanners). # Insert obtained energies into the array that stores the cbs stages; for stage in GRAND_NEED:; for lvl in stage['d_need'].items():; MODELCHEM.append(lvl[1]). for job in JOBS_EXT:; # Dont ask; if (",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver_cbs.html:53136,energy,energy,53136,psi4manual/1.3.2/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver_cbs.html,1,['energy'],['energy']
Energy Efficiency,"basis'].lower().replace('*', 's')); exec(commands). # Stash and set options if any; if mc[""f_options""]:; optionstash = p4util.OptionsState(*[[opt] for opt in list(mc[""f_options""])]); for k, v, in mc[""f_options""].items():; core.set_global_option(k.upper(), v); else:; optionstash = False. # Make energy(), etc. call; response = func(molecule=molecule, **kwargs); if ptype == 'energy':; mc['f_energy'] = response; elif ptype == 'gradient':; mc['f_gradient'] = response; mc['f_energy'] = core.variable('CURRENT ENERGY'); if verbose > 1:; mc['f_gradient'].print_out(); elif ptype == 'hessian':; mc['f_hessian'] = response; mc['f_energy'] = core.variable('CURRENT ENERGY'); if verbose > 1:; mc['f_hessian'].print_out(); Njobs += 1; if verbose > 1:; core.print_out(""\nCURRENT ENERGY: %14.16f\n"" % mc['f_energy']). # Restore modified options; if optionstash:; optionstash.restore(). # Fill in energies for subsumed methods; if ptype == 'energy':; for wfn in VARH[mc['f_wfn']]:; for job in JOBS_EXT:; if (wfn == job['f_wfn']) and (mc['f_basis'] == job['f_basis']) and \; (mc['f_options'] == job['f_options']):; job['f_energy'] = core.variable(VARH[wfn][wfn]). if verbose > 1:; core.print_variables(); core.clean_variables(); core.clean(). # Copy data from 'run' to 'obtained' table; for mce in JOBS_EXT:; if (mc['f_wfn'] == mce['f_wfn']) and (mc['f_basis'] == mce['f_basis']) and \; (mc['f_options'] == mce['f_options']):; mce['f_energy'] = mc['f_energy']; mce['f_gradient'] = mc['f_gradient']; mce['f_hessian'] = mc['f_hessian']. psioh.set_specific_retention(psif.PSIF_SCF_MOS, False). # Build string of title banner; instructions = ""\n"" + p4util.banner(f"" CBS Results{':' + label if label else ''} "", strNotOutfile=True) + ""\n""; core.print_out(instructions). # Insert obtained energies into the array that stores the cbs stages; for stage in GRAND_NEED:; for lvl in stage['d_need'].items():; MODELCHEM.append(lvl[1]). for job in JOBS_EXT:; # Dont ask; if (((lvl[1]['f_wfn'] == job['f_wfn']) or; ((lvl[1]['f_",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html:54674,energy,energy,54674,psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html,4,['energy'],['energy']
Energy Efficiency,"basis). aux_basis = core.BasisSet.build(dimer_wfn.molecule(), ""DF_BASIS_ELST"", core.get_global_option(""DF_BASIS_ELST""),; ""JKFIT"", core.get_global_option(""BASIS"")); dimer_wfn.set_basisset(""DF_BASIS_ELST"", aux_basis). core.print_out('\n'); p4util.banner(name.upper()); core.print_out('\n'); e_sapt = core.sapt(dimer_wfn, monomerA_wfn, monomerB_wfn); dimer_wfn.set_module(""sapt""). from psi4.driver.qcdb.psivardefs import sapt_psivars; p4util.expand_psivars(sapt_psivars()); optstash.restore(). # Get the SAPT name right if doing empirical dispersion; if do_empirical_disp:; sapt_name = ""sapt0""; else:; sapt_name = name. # Make sure we got induction, otherwise replace it with uncoupled induction; which_ind = 'IND'; target_ind = 'IND'; if not core.has_variable(' '.join((sapt_name.upper(), which_ind, 'ENERGY'))):; which_ind = 'IND,U'. for term in ['ELST', 'EXCH', 'DISP', 'TOTAL']:; core.set_variable(' '.join(['SAPT', term, 'ENERGY']),; core.variable(' '.join([sapt_name.upper(), term, 'ENERGY']))); # Special induction case; core.set_variable(' '.join(['SAPT', target_ind, 'ENERGY']),; core.variable(' '.join([sapt_name.upper(), which_ind, 'ENERGY']))); core.set_variable('CURRENT ENERGY', core.variable('SAPT TOTAL ENERGY')). # Empirical dispersion; if do_empirical_disp:; proc_util.sapt_empirical_dispersion(name, dimer_wfn). return dimer_wfn. def run_sapt_ct(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a charge-transfer SAPT calcuation of any level. """"""; optstash = p4util.OptionsState(; ['SCF_TYPE']). if 'ref_wfn' in kwargs:; core.print_out('\nWarning! Argument ref_wfn is not valid for sapt computations\n'). # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'). # Get the molecule of interest; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; sapt_dimer = kwargs.pop('molecule', core.get_active_molecule()); else:; core.print_out('Warning! SAPT argument ""ref_wfn"" is only able to use m",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:147591,ENERGY,ENERGY,147591,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,5,['ENERGY'],['ENERGY']
Energy Efficiency,"basis, xtpl_type)[source]¶; A helper function to determine default extrapolation type. Parameters:; nbasis (int) – Number of basis sets; xtpl_type ({'scf', 'corl'}) – Extrapolation type: ‘scf’ for the total energy, ‘corl’ for just the; correlation component. Returns:Extrapolation function to be used. Return type:function. Aliases¶; When a particular composite method or its functional form is going to be; reused often, it is convenient to define an alias to it. A convenient; place for such Python code to reside is in psi4/psi4/driver/aliases.py; (source location) or psi4/lib/psi4/driver/aliases.py (installed; location). No recompilation is necessary after defining an alias. Some; existing examples are below. psi4.driver.aliases.sherrill_gold_standard(func, label, **kwargs)[source]¶; Function to call the quantum chemical method known as ‘Gold Standard’; in the Sherrill group. Uses complete_basis_set() to evaluate; the following expression. Two-point extrapolation of the correlation energy; performed according to corl_xtpl_helgaker_2(). \[E_{total}^{\text{Au\_std}} = E_{total,\; \text{SCF}}^{\text{aug-cc-pVQZ}} \; + E_{corl,\; \text{MP2}}^{\text{aug-cc-pV[TQ]Z}} \; + \delta_{\text{MP2}}^{\text{CCSD(T)}}\big\vert_{\text{aug-cc-pVTZ}}\]; >>> # [1] single-point energy by this composite method; >>> energy('sherrill_gold_standard'). >>> # [2] finite-difference geometry optimization; >>> optimize('sherrill_gold_standard'). >>> # [3] finite-difference geometry optimization, overwriting some pre-defined sherrill_gold_standard options; >>> optimize('sherrill_gold_standard', corl_basis='cc-pV[DT]Z', delta_basis='3-21g'). psi4.driver.aliases.allen_focal_point(func, label, **kwargs)[source]¶; Function to call Wes Allen-style Focal; Point Analysis. JCP 127 014306. Uses; complete_basis_set() to evaluate the following; expression. SCF employs a three-point extrapolation according; to scf_xtpl_helgaker_3(). MP2, CCSD, and; CCSD(T) employ two-point extrapolation performed according to;",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/cbs-1.html:20610,energy,energy,20610,psi4manual/1.3.2/cbs-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/cbs-1.html,2,['energy'],['energy']
Energy Efficiency,"basis. Finally, it will print a summary of the; charge-transfer results:; SAPT Charge Transfer Analysis; -----------------------------------------------------------------------------; SAPT Induction (Dimer Basis) -2.0970 mH -1.3159 kcal mol^-1; SAPT Induction (Monomer Basis) -1.1396 mH -0.7151 kcal mol^-1; SAPT Charge Transfer -0.9574 mH -0.6008 kcal mol^-1. These results are for the water dimer geometry shown above computed with; SAPT0/aug-cc-pVDZ. Interpreting SAPT Results¶; We will examine the results of a SAPT2+3/aug-cc-pVDZ computation on the; water dimer. This computation can be performed with the following; input:; molecule water_dimer {; 0 1; O -1.551007 -0.114520 0.000000; H -1.934259 0.762503 0.000000; H -0.599677 0.040712 0.000000; --; 0 1; O 1.350625 0.111469 0.000000; H 1.680398 -0.373741 -0.758561; H 1.680398 -0.373741 0.758561; units angstrom; }. set globals {; basis aug-cc-pvdz; guess sad; scf_type df; }. set sapt {; print 1; nat_orbs true; freeze_core true; }. energy('sapt2+3'). To reiterate some of the options mentioned above: the; NAT_ORBS option will compute MP2 natural orbitals and use; them in the evaluation of the triples correction to dispersion, and the; FREEZE_CORE option will freeze the core throughout the SAPT; computation. This SAPT2+3/aug-cc-pVDZ computation produces the following; results:; SAPT Results; --------------------------------------------------------------------------; Electrostatics -13.06429805 mH -8.19797114 kcal mol^-1; Elst10,r -13.37543274 mH -8.39321111 kcal mol^-1; Elst12,r 0.04490253 mH 0.02817676 kcal mol^-1; Elst13,r 0.26623216 mH 0.16706321 kcal mol^-1. Exchange 13.41793548 mH 8.41988199 kcal mol^-1; Exch10 11.21823471 mH 7.03954885 kcal mol^-1; Exch10(S^2) 11.13803867 mH 6.98922508 kcal mol^-1; Exch11(S^2) 0.04558910 mH 0.02860760 kcal mol^-1; Exch12(S^2) 2.15411167 mH 1.35172554 kcal mol^-1. Induction -3.91333155 mH -2.45565272 kcal mol^-1; Ind20,r -4.57531220 mH -2.87105187 kcal mol^-1; Ind30,r -4.91715479 mH -3",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/sapt-1.html:13847,energy,energy,13847,psi4manual/4.0b2/sapt-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/sapt-1.html,6,['energy'],['energy']
Energy Efficiency,"basis. The reference numbers are from Lan Cheng’s implementation in Cfour. sapt-dft-api; SAPT(DFT) aug-cc-pVDZ interaction energy between Ne and Ar atoms. pywrap-checkrun-uhf; This checks that all energy methods can run with a minimal input and set symmetry. psimrcc-ccsd_t-4; Mk-MRCCSD(T) single point. \(^1A_1\) O$_3` state described using the Ms = 0 component of the singlet. Uses TCSCF orbitals. scf-guess-read1; Sample UHF/cc-pVDZ H2O computation on a doublet cation, using RHF/cc-pVDZ orbitals for the closed-shell neutral as a guess. psimrcc-fd-freq2; Mk-MRCCSD frequencies. \(^1A_1\) O$_3` state described using the Ms = 0 component of the singlet. Uses TCSCF orbitals. sad-scf-type; Test SAD SCF guesses on noble gas atom. pywrap-bfs; apply linear fragmentation algorithm to a water cluster. mints5; Tests to determine full point group symmetry. Currently, these only matter for the rotational symmetry number in thermodynamic computations. extern3; External potential calculation with one Ghost atom and one point charge at the same position. fsapt2; A very quick correctness test of F-SAPT (see fsapt1 for a real example). dct12; Spin-restricted DC-06 counterpart of dct1. tu3-h2o-opt; Optimize H2O HF/cc-pVDZ. psimrcc-pt2; Mk-MRPT2 single point. \(^1A_1\) F2 state described using the Ms = 0 component of the singlet. Uses TCSCF singlet orbitals. cc9a; ROHF-CCSD(T) cc-pVDZ energy for the \(^2\Sigma^+\) state of the CN radical, with Z-matrix input. tdscf-4; td-wb97x singlet excitation energies of methylene (tda). cc-module; check that CC is returning the same values btwn CC*, FNOCC, and DFOCC modules. dfccdl1; DF-CCDL cc-pVDZ energy for the H2O molecule. props2; DF-SCF cc-pVDZ of benzene-hydronium ion, scanning the dissociation coordinate with Python’s built-in loop mechanism. The geometry is specified by a Z-matrix with dummy atoms, fixed parameters, updated parameters, and separate charge/multiplicity specifiers for each monomer. One-electron properties computed for dimer and",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/autodoc_testsuite_corepsi4.html:46128,charge,charge,46128,psi4manual/master/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/master/autodoc_testsuite_corepsi4.html,2,['charge'],['charge']
Energy Efficiency,"basis; set available. See :ref:`sec:cbs_xtpl` for all available schemes. :type scf_scheme: function; :param scf_scheme: |dl| ``xtpl_highest_1`` |dr| || ``scf_xtpl_helgaker_3`` || etc. Indicates the basis set extrapolation scheme to be applied to the reference energy.; Defaults to :py:func:`~scf_xtpl_helgaker_3` if three valid basis sets; present in ``scf_basis``, :py:func:`~scf_xtpl_helgaker_2` if two valid basis; sets present in ``scf_basis``, and :py:func:`~xtpl_highest_1` otherwise. :type corl_scheme: function; :param corl_scheme: |dl| ``xtpl_highest_1`` |dr| || ``corl_xtpl_helgaker_2`` || etc. Indicates the basis set extrapolation scheme to be applied to the correlation energy.; Defaults to :py:func:`~corl_xtpl_helgaker_2` if two valid basis sets; present in ``corl_basis`` and :py:func:`~xtpl_highest_1` otherwise. :type delta_scheme: function; :param delta_scheme: |dl| ``xtpl_highest_1`` |dr| || ``corl_xtpl_helgaker_2`` || etc. Indicates the basis set extrapolation scheme to be applied to the delta correction; to the correlation energy.; Defaults to :py:func:`~corl_xtpl_helgaker_2` if two valid basis sets; present in ``delta_basis`` and :py:func:`~xtpl_highest_1` otherwise. :type delta2_scheme: function; :param delta2_scheme: |dl| ``xtpl_highest_1`` |dr| || ``corl_xtpl_helgaker_2`` || etc. Indicates the basis set extrapolation scheme to be applied to the second delta correction; to the correlation energy.; Defaults to :py:func:`~corl_xtpl_helgaker_2` if two valid basis sets; present in ``delta2_basis`` and :py:func:`~xtpl_highest_1` otherwise. :type delta3_scheme: function; :param delta3_scheme: |dl| ``xtpl_highest_1`` |dr| || ``corl_xtpl_helgaker_2`` || etc. Indicates the basis set extrapolation scheme to be applied to the third delta correction; to the correlation energy.; Defaults to :py:func:`~corl_xtpl_helgaker_2` if two valid basis sets; present in ``delta3_basis`` and :py:func:`~xtpl_highest_1` otherwise. :type delta4_scheme: function; :param delta4_scheme",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/driver_cbs.html:26429,energy,energy,26429,psi4manual/1.1.0/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/driver_cbs.html,1,['energy'],['energy']
Energy Efficiency,"basis=disk algorithm is used, where the transformation of integrals for four-virtual case is avoided. The computation is then repeated using the DC-12 functional with the same algorithms. pywrap-db3; Test that Python Molecule class processes geometry like psi4 Molecule class. psimrcc-ccsd_t-1; Mk-MRCCSD(T) single point. \(^1A_1\) CH2 state described using the Ms = 0 component of the singlet. Uses RHF singlet orbitals. scf-cholesky-basis; incremental Cholesky filtered SCF. cc9; UHF-CCSD(T) cc-pVDZ frozen-core energy for the \(^2\Sigma^+\) state of the CN radical, with Z-matrix input. opt4; SCF cc-pVTZ geometry optimzation, with Z-matrix input. dfep2-1; Compute three IP and 2 EA’s for the PH3 molecule. cc8c; ROHF-CCSD cc-pVDZ frozen-core energy for the \(^2\Sigma^+\) state of the CN radical, with Cartesian input. dfmp2-4; conventional and density-fitting mp2 test of mp2 itself and setting scs-mp2. soscf-large; Second-order SCF convergnece: Benzene. omp2-2; OMP2 cc-pVDZ energy with ROHF initial guess orbitals for the NO radical. scf7; Tests SCF gradient in the presence of a dipole field. linK-3; UHF and ROHF Linear Exchange Algorithm test for benzyl cation. scf-hess2; UHF STO-3G (Cartesian) and cc-pVDZ (spherical) water Hessian test, against Psi3 reference values. This test should match RHF values exactly. mp2-property; MP2 cc-pvDZ properties for Nitrogen oxide. cbs-xtpl-opt; Various extrapolated optimization methods for the H2 molecule. dft1-alt; DFT Functional Test. opt9; Various constrained energy minimizations of HOOH with cc-pvdz RHF. Cartesian-coordinate constrained optimizations of HOOH in internals. opt5; 6-31G** UHF CH2 3B1 optimization. Uses a Z-Matrix with dummy atoms, just for demo and testing purposes. nbody-vmfc-hessian; Computation of VMFC-corrected water trimer Hessian (geometry from J. Chem. Theory Comput. 11, 2126-2136 (2015)). mints4; A demonstration of mixed Cartesian/ZMatrix geometry specification, using variables, for the benzene-hydronium complex.",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/autodoc_testsuite_corepsi4.html:32198,energy,energy,32198,psi4manual/1.6.x/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/autodoc_testsuite_corepsi4.html,2,['energy'],['energy']
Energy Efficiency,"basisChanged = psi4.has_option_changed(""BASIS""); ribasisChanged = psi4.has_option_changed(""DF_BASIS_SCF""); scftypeChanged = psi4.has_option_changed(""SCF_TYPE""). basis = psi4.get_option(""BASIS""); ribasis = psi4.get_option(""DF_BASIS_SCF""); scftype = psi4.get_option(""SCF_TYPE""). psi4.print_out("" => Diffuse SCF (Determines Da) <=\n\n""). psi4.set_global_option(""BASIS"", self.basisname); psi4.set_global_option(""DF_BASIS_SCF"", self.ribasisname); psi4.set_global_option(""SCF_TYPE"", ""DF""); E, ref = energy('scf', return_wfn=True, molecule=self.molecule); self.wfn = ref; psi4.print_out(""\n""). self.fitGeneral(). psi4.clean(). psi4.set_global_option(""BASIS"", basis); psi4.set_global_option(""DF_BASIS_SCF"", ribasis); psi4.set_global_option(""SCF_TYPE"", scftype). if not basisChanged:; psi4.revoke_option_changed(""BASIS""); if not ribasisChanged:; psi4.revoke_option_changed(""DF_BASIS_SCF""); if not scftypeChanged:; psi4.revoke_option_changed(""SCF_TYPE""). [docs] def fitGeneral(self):; """"""Function to perform a general fit of diffuse charges; to wavefunction density. """"""; psi4.print_out("" => Diffuse Charge Fitting (Determines da) <=\n\n""); self.Da = self.wfn.Da(); self.basis = self.wfn.basisset(); parser = psi4.Gaussian94BasisSetParser(); self.ribasis = psi4.BasisSet.construct(parser, self.molecule, ""DF_BASIS_SCF""). fitter = psi4.DFChargeFitter(); fitter.setPrimary(self.basis); fitter.setAuxiliary(self.ribasis); fitter.setD(self.Da); self.da = fitter.fit(); self.da.scale(2.0). [docs] def populateExtern(self, extern):; # Electronic Part; extern.addBasis(self.ribasis, self.da); # Nuclear Part; for A in range(0, self.molecule.natom()):; extern.addCharge(self.molecule.Z(A), self.molecule.x(A), self.molecule.y(A), self.molecule.z(A)). [docs]class QMMM(object):. def __init__(self):; self.charges = []; self.diffuses = []; self.extern = psi4.ExternalPotential(). [docs] def addDiffuse(self, diffuse):; """"""Function to add a diffuse charge field *diffuse*.""""""; self.diffuses.append(diffuse). [docs] def ad",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qmmm.html:2869,charge,charges,2869,psi4manual/1.0.0/_modules/qmmm.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qmmm.html,1,['charge'],['charges']
Energy Efficiency,"basis_scf basis is not set, pick a sensible one.; if psi4.get_global_option('DF_BASIS_SCF') == '':; jkbasis = p4util.corresponding_jkfit(psi4.get_global_option('BASIS')); if jkbasis:; psi4.set_global_option('DF_BASIS_SCF', jkbasis); psi4.print_out('\nNo DF_BASIS_SCF auxiliary basis selected, defaulting to %s\n\n' % (jkbasis)); else:; raise ValidationError('Keyword DF_BASIS_SCF is required.'). scf_helper(name, **kwargs). psi4.print_out('\n'); p4util.banner('DFMP2'); psi4.print_out('\n'). # if the df_basis_mp2 basis is not set, pick a sensible one.; if psi4.get_global_option('DF_BASIS_MP2') == '':; ribasis = p4util.corresponding_rifit(psi4.get_global_option('BASIS')); if ribasis:; psi4.set_global_option('DF_BASIS_MP2', ribasis); psi4.print_out('No DF_BASIS_MP2 auxiliary basis selected, defaulting to %s\n' % (ribasis)); else:; raise ValidationError('Keyword DF_BASIS_MP2 is required.'). psi4.dfmp2grad(); e_dfmp2 = psi4.get_variable('MP2 TOTAL ENERGY'); e_scs_dfmp2 = psi4.get_variable('SCS-MP2 TOTAL ENERGY'). optstash.restore(). if (name.upper() == 'SCS-MP2'):; return e_scs_dfmp2; elif (name.upper() == 'DF-MP2') or (name.upper() == 'DFMP2') or (name.upper() == 'MP2'):; return e_dfmp2. [docs]def run_eom_cc(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; an EOM-CC calculation, namely EOM-CC2, EOM-CCSD, and EOM-CC3. """"""; optstash = p4util.OptionsState(; ['TRANSQT2', 'WFN'],; ['CCSORT', 'WFN'],; ['CCENERGY', 'WFN'],; ['CCHBAR', 'WFN'],; ['CCEOM', 'WFN']). if (name.lower() == 'eom-ccsd'):; psi4.set_local_option('TRANSQT2', 'WFN', 'EOM_CCSD'); psi4.set_local_option('CCSORT', 'WFN', 'EOM_CCSD'); psi4.set_local_option('CCENERGY', 'WFN', 'EOM_CCSD'); psi4.set_local_option('CCHBAR', 'WFN', 'EOM_CCSD'); psi4.set_local_option('CCEOM', 'WFN', 'EOM_CCSD'); run_ccenergy('ccsd', **kwargs); elif (name.lower() == 'eom-cc2'):. user_ref = psi4.get_option('CCENERGY', 'REFERENCE'); if (user_ref != 'RHF') and (user_ref != 'UHF'):; raise ValidationError('Reference %s for",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/proc.html:34196,ENERGY,ENERGY,34196,psi4manual/4.0b5/_modules/proc.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/proc.html,1,['ENERGY'],['ENERGY']
Energy Efficiency,"bda amplitute equations?. Type: boolean; Default: false. CC_MAXITER¶. Maximum number of iterations to determine the amplitudes. Type: integer; Default: 50. CHOLESKY¶. Do Cholesky decomposition of the ERI tensor. Type: boolean; Default: false. CHOLESKY_TOLERANCE¶. tolerance for Cholesky decomposition of the ERI tensor. Type: conv double; Default: 1.0e-4. COMPUT_S2¶. Do compute <S2> for DF-OMP2/DF-MP2?. Type: boolean; Default: false. CUTOFF¶. Cutoff value for numerical procedures. Type: integer; Default: 8. DO_DIIS¶. Do apply DIIS extrapolation?. Type: boolean; Default: true. DO_LEVEL_SHIFT¶. Do apply level shifting?. Type: boolean; Default: true. DO_SCS¶. Do perform spin-component-scaled OMP2 (SCS-OMP2)? In all computation, SCS-OMP2 energy is computed automatically. However, in order to perform geometry optimizations and frequency computations with SCS-OMP2, one needs to set ‘DO_SCS’ to true. Type: boolean; Default: false. DO_SOS¶. Do perform spin-opposite-scaled OMP2 (SOS-OMP2)? In all computation, SOS-OMP2 energy is computed automatically. However, in order to perform geometry optimizations and frequency computations with SOS-OMP2, one needs to set ‘DO_SOS’ to true. Type: boolean; Default: false. E3_SCALE¶. CEPA opposite-spin scaling value from SCS-CCSD. Type: double; Default: 0.25. EKT_IP¶. Do compute ionization potentials based on the extended Koopmans’ theorem?. Type: boolean; Default: false. E_CONVERGENCE¶. Convergence criterion for energy. See Table Post-SCF Convergence for default convergence criteria for different calculation types. Type: conv double; Default: 1e-6. HESS_TYPE¶. Type of the MO Hessian matrix. Type: string; Possible Values: APPROX_DIAG, APPROX_DIAG_EKT, APPROX_DIAG_HF, HF; Default: HF. INTEGRAL_CUTOFF¶. Cutoff value for DF integrals. Type: integer; Default: 9. LEVEL_SHIFT¶. Level shift to aid convergence. Type: double; Default: 0.02. LINEQ_SOLVER¶. The solver will be used for simultaneous linear equations. Type: string; Possible Values: CDGESV",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodir_options_c/module__dfocc-1.html:1522,energy,energy,1522,psi4manual/1.0.0/autodir_options_c/module__dfocc-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodir_options_c/module__dfocc-1.html,2,['energy'],['energy']
Energy Efficiency,"be applied to the correlation energy. :type delta_scheme: function; :param delta_scheme: |dl| ``highest_1`` |dr| || ``corl_xtpl_helgaker_2`` || etc. Indicates the basis set extrapolation scheme to be applied to the delta correction; to the correlation energy. :type delta2_scheme: function; :param delta2_scheme: |dl| ``highest_1`` |dr| || ``corl_xtpl_helgaker_2`` || etc. Indicates the basis set extrapolation scheme to be applied to the second delta correction; to the correlation energy. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :examples:. >>> # [1] replicates with cbs() the simple model chemistry scf/cc-pVDZ: set basis cc-pVDZ energy('scf'); >>> cbs('scf', scf_basis='cc-pVDZ'). >>> # [2] replicates with cbs() the simple model chemistry mp2/jun-cc-pVDZ: set basis jun-cc-pVDZ energy('mp2'); >>> cbs('mp2', corl_basis='jun-cc-pVDZ'). >>> # [3] DTQ-zeta extrapolated scf reference energy; >>> cbs('scf', scf_basis='cc-pV[DTQ]Z', scf_scheme=scf_xtpl_helgaker_3). >>> # [4] DT-zeta extrapolated mp2 correlation energy atop a T-zeta reference; >>> cbs('mp2', corl_basis='cc-pv[dt]z', corl_scheme=corl_xtpl_helgaker_2). >>> # [5] a DT-zeta extrapolated coupled-cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference; >>> cbs('mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z', delta_scheme=corl_xtpl_helgaker_2). >>> # [6] a D-zeta ccsd(t) correction atop a DT-zeta extrapolated ccsd cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference; >>> cbs('mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd', delta_basis='aug-cc-pv[dt]z', delta_scheme=corl_xtpl_helgaker_2, delta2_wfn='ccsd(t)', delta2_wfn_lesser='ccsd', delta2_basis='aug-cc-pvdz'). >>> # [7] cbs() coupled with database(); >>> database('mp2', 'BASIC', subset=",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:57348,energy,energy,57348,psi4manual/4.0b2/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html,6,['energy'],['energy']
Energy Efficiency,"be applied to the database. May be any valid argument to; energy(). molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. return_wfn (boolean) – 'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple. return_history (boolean) – 'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return dictionary of lists of geometries,; energies, and gradients at each step in the optimization. func (function) – \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. dertype (dertype) – 'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. hessian_with (string) – 'scf' || 'mp2' || etc.; Indicates the computational method with which to perform a hessian; analysis to guide the geometry optimization. Warning; Optimizations where the molecule is specified in Z-matrix format; with dummy atoms will result in the geometry being converted to a Cartesian representation. Note; Analytic gradients area available for all methods in the table; below. Optimizations with other methods in the energy table proceed; by finite differences. name; calls method. efp; efp-only optimizations. scf; Hartree–Fock (HF) or density functional theory (DFT) [manual]. hf; HF self consistent field (SCF) [manual]. dcft; density cumulant functional theory [manual]. mp2; 2nd-order Møller–Plesset perturbation theory (MP2) [manual] [details]. mp3; 3rd-order Møller–Plesset perturbation theory (MP3) [manual] [details]. mp2.5; average of MP2 and MP3 [manual] [details]. omp2; orbital-optimized ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/api/psi4.driver.opt-1.html:1621,energy,energy,1621,psi4manual/1.3.2/api/psi4.driver.opt-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/api/psi4.driver.opt-1.html,6,['energy'],['energy']
Energy Efficiency,"be files for all orbitals; >>> E, wfn = energy('b3lyp', return_wfn=True); >>> cubeprop(wfn). >>> # [2] Cube files for density (alpha, beta, total, spin) and four orbitals; >>> # (two alpha, two beta); >>> set cubeprop_tasks ['orbitals', 'density']; >>> set cubeprop_orbitals [5, 6, -5, -6]; >>> E, wfn = energy('scf', return_wfn=True); >>> cubeprop(wfn). Introduction¶; PSI4 has the ability to export cube files that store information about; basis functions, molecular orbitals, the electron density, and; the electrostatic potential (ESP). Cube files store the value of a scalar; quantity on a regular Cartesian grid, and can be visualized with several; visualization programs, some of which are free, like VMD; (http://www.ks.uiuc.edu/Research/vmd/).; An example utilization of the code is:; molecule h2o {; 0 1; O; H 1 1.0; H 1 1.0 2 104.5; }. set basis cc-pvdz; set scf_type df; set freeze_core True; set cubeprop_tasks ['orbitals']; set cubeprop_orbitals [5,6,-5,-6]. E, wfn = energy('scf', return_wfn=True); cubeprop(wfn). In this example, the cubeprop(); call after the energy('scf') command; executes the cubeprop code. The array CUBEPROP_TASKS specifies which; tasks should be executed. In this case the task 'orbitals' generates cube; files for orbitals. The CUBEPROP_ORBITALS option specifies that cube files; should be generated only for alpha orbitals 5 (HOMO) and 6 (LUMO) and; beta orbitals 5 (indicated as -5) and 6.; If the option CUBEPROP_ORBITALS is not provided, then cube files are; generated for all orbitals.; After running, the above input will generate four files: Psi_a_5_1-B1.cube,; Psi_a_6_4-A1.cube, Psi_a_5_1-B1.cube, and Psi_a_6_4-A1.cube. The subscript a in; Psi_a_5_1-B1.cube indicates an alpha orbital. The first number (5) is the index of the; orbital while 1-B1 indicates that this is the first orbital that belongs to the B1 irrep.; The file Psi_a_5_1-B1.cube begins with two comment lines:; Psi4 Gaussian Cube File.; Property: Psi_a_5_1-B1. Isocontour range for ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/cubeprop-1.html:1620,energy,energy,1620,psi4manual/1.4.0/cubeprop-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/cubeprop-1.html,9,['energy'],['energy']
Energy Efficiency,"be found in; tu1-h2o-energy.; You can run it if you wish.; Once Psi4 is in your path (see the; User Configuration; section of the installation instructions), you can run this computation by typing; >>> psi4 input.dat output.dat. If everything goes well, the computation should complete and should report; a final restricted Hartree–Fock energy in a section like this:; Energy converged. @RHF Final Energy: -76.02663273410671. By default, the energy should be converged to about , so agreement; is only expected for about the first 6 digits after the decimal. If the; computation does not complete, there is probably a problem with the; compilation or installation of the program (see the installation; instructions in Sec. Compiling and Installing from Source).; This very simple input is sufficient to run the requested information.; Notice that we didn’t tell the program some otherwise useful information; like the charge on the molecule (0, it’s neutral), the spin multiplicity; (1 for a closed-shell molecule with all electrons paired), or the reference; wavefunction to use (restricted Hartree–Fock, or RHF, is usually; appropriate for a closed-shell molecule). The program correctly guessed; all of these options for us. We can change the default behavior through; additional keywords.; Let’s consider what we would do for an open-shell molecule, where; not all electrons are paired. For example, let’s run a computation; on methylene (CH2), whose ground electronic state has two unpaired; electrons (triplet electronic state, or a spin multiplicity ).; In this case, the default spin multiplicity (1) is not correct, so we; need to tell the program the true value (3). Like many programs, Psi4; can get the charge and multiplicity as the first two integers in the; Z-matrix. Note the line with 0 3 at the beginning of the molecule; specification below. In this example we will also specify the bond length; and bond angle as variables ( and ), whose values are given; at the end of the Z-matr",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/tutorial-1.html:2771,charge,charge,2771,psi4manual/1.0.0/tutorial-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/tutorial-1.html,2,['charge'],['charge']
Energy Efficiency,"be placed in the PSI4 input file.; energy('c4-ccsd'); print 'miracle?', 'miracle' in P4C4_INFO['output']. Scratch Files; By default, a separate subdirectory for each Cfour call is created within; the job’s scratch directory. To explicitly specify the location of the; Cfour scratch, execute with, for example, energy('cfour',; path='/full/path/to/cfour/scratch'). Regardless of whether the location; is specified or default, whether to preserve the scratch directory after; the computation can be specified with energy('cfour', keep=True) or; (the default) energy('cfour', keep=False). path and keep are; keyword arguments that get interpreted by the; run_cfour() function documented below. psi4.driver.procrouting.interface_cfour.run_cfour(name[, keep, path])[source]¶; Function that prepares environment and input files; for a calculation calling Stanton and Gauss’s CFOUR code.; Also processes results back into Psi4 format.; This function is not called directly but is instead called by; energy() or optimize() when a Cfour; method is requested (through name argument). In order to function; correctly, the Cfour executable xcfour must be present in; PATH or PSIPATH. Many PSI Variables extracted from the Cfour output; Python dictionary of associated file constants accessible as P4C4_INFO['zmat'], P4C4_INFO['output'], P4C4_INFO['grd'], etc. Parameters. name (str) – 'c4-scf' || 'c4-ccsd(t)' || 'cfour' || etc.; First argument, usually unlabeled. Indicates the computational; method to be applied to the system. keep (boolean) – 'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicates whether to delete the Cfour scratch directory upon; completion of the Cfour job. path (str) – Indicates path to Cfour scratch directory (with respect to Psi4; scratch directory). Otherwise, the default is a subdirectory; within the Psi4 scratch directory.; If specified, GENBAS and/or ZMAT within will be used. genbas (str) – Indicates that contents should be used for GENBAS file. GENBAS is a complicated top",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/cfour-1.html:23723,energy,energy,23723,psi4manual/1.4.0/cfour-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/cfour-1.html,5,['energy'],['energy']
Energy Efficiency,"be placed in the PSI4 input file.; energy('c4-ccsd'); print 'miracle?', 'miracle' in P4C4_INFO['output']. Scratch Files; By default, a separate subdirectory for each Cfour call is created within; the job’s scratch directory. To explicitly specify the location of the; Cfour scratch, execute with, for example, energy('cfour',; path='/full/path/to/cfour/scratch'). Regardless of whether the location; is specified or default, whether to preserve the scratch directory after; the computation can be specified with energy('cfour', keep=True) or; (the default) energy('cfour', keep=False). path and keep are; keyword arguments that get interpreted by the; run_cfour() function documented below. psi4.driver.procrouting.interface_cfour.run_cfour(name[, keep, path])[source]¶; Function that prepares environment and input files; for a calculation calling Stanton and Gauss’s CFOUR code.; Also processes results back into Psi4 format.; This function is not called directly but is instead called by; energy() or optimize() when a Cfour; method is requested (through name argument). In order to function; correctly, the Cfour executable xcfour must be present in; PATH or PSIPATH. Many PSI Variables extracted from the Cfour output; Python dictionary of associated file constants accessible as P4C4_INFO['zmat'], P4C4_INFO['output'], P4C4_INFO['grd'], etc. Parameters:. name (str) – 'c4-scf' || 'c4-ccsd(t)' || 'cfour' || etc.; First argument, usually unlabeled. Indicates the computational; method to be applied to the system. keep (boolean) – 'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicates whether to delete the Cfour scratch directory upon; completion of the Cfour job. path (str) – Indicates path to Cfour scratch directory (with respect to Psi4; scratch directory). Otherwise, the default is a subdirectory; within the Psi4 scratch directory.; If specified, GENBAS and/or ZMAT within will be used. genbas (str) – Indicates that contents should be used for GENBAS file. GENBAS is a complicated to",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/cfour.html:23845,energy,energy,23845,psi4manual/1.7.x/cfour.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/cfour.html,4,['energy'],['energy']
Energy Efficiency,"be seen at other modules. Detailed capabilities of the DFMP2 module. “✓” runs analytically. Single underline “✓̲” is default module when QC_MODULE unspecified. Double underline “✓̳” is default algorithm type when type selector (e.g., CC_TYPE) unspecified.¶. ◻; ◻; name ↓ →; ◻; ◻. ◻; REFERENCE →; ◻; type[1] ↓ →; FREEZE_CORE[2]→. QC_MODULE=DFMP2 Capabilities. Restricted (RHF); Unrestricted (UHF); Restricted Open (ROHF). energy(); gradient()[3]; energy(); gradient()[3]; energy(); gradient()[3]. CV; DF; CD; CV; DF; CD; CV; DF; CD; CV; DF; CD; CV; DF; CD; CV; DF; CD. A; F; A; F; A; F; A; F; A; F; A; F; A; F; A; F; A; F; A; F; A; F; A; F; A; F; A; F; A; F; A; F; A; F; A; F. mp2[4]; MP2_TYPE. ✓̳; ✓̳. ✓̳; ✓̳. ✓̳; ✓̳. ✓̳; ✓̳. [1]; Algorithm type selection keyword below. Values to the right: conventional CV, density-fitted DF, and Cholesky-decomposed CD. [2]; Active orbital values to the right: all-electron A and frozen-core F. [3]; (1,2,3); Finite difference gradients are not marked explicitly by “∷”, but the capability can be gleaned from the energy availability. [4]; Also available for DFT references RKS/UKS. An example utilization of the code is:; molecule h2o {; 0 1; O; H 1 1.0; H 1 1.0 2 104.5; }. set basis cc-pvdz; set scf_type df; set freeze_core True. energy('mp2'). The energy('mp2') call to energy() executes; the predefined DF-MP2 procedure, first calling; the SCF module with a default RHF reference and DF algorithm for the; two-electron integrals. When the orbitals are converged, the DF-MP2 module is; launched, which forms the density-fitted \((Q|ov)\) integrals and then builds the; full \((ov|ov)\) tensor in blocks, evaluating the contributions to the MP2 energy; as it goes. A RHF-MP2 wavefunction is selected automatically due to the RHF; reference. In this example, we freeze the core, both for efficiency and; because split-valence bases like cc-pVDZ do not contain core correlation; functions. The result looks something like:; --------------------------------------",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/dfmp2.html:3138,energy,energy,3138,psi4manual/1.7.x/dfmp2.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/dfmp2.html,4,['energy'],['energy']
Energy Efficiency,"be', False):; return; else:; return func(name, **kwargs). def select_ccsd_t__gradient(name, **kwargs):; """"""Function selecting the algorithm for a CCSD(T) gradient call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); mtd_type = core.get_global_option('CC_TYPE'); module = core.get_global_option('QC_MODULE'); # Considering only ccenergy. func = None; if reference in ['RHF']:; if mtd_type == 'CONV':; if module in ['', 'CCENERGY']:; func = run_ccenergy_gradient; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc_gradient; elif reference == 'UHF':; if mtd_type == 'CONV':; if module in ['', 'CCENERGY']:; func = run_ccenergy_gradient. if func is None:; raise ManagedMethodError(['select_ccsd_t__gradient', name, 'CC_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_ccsd_at_(name, **kwargs):; """"""Function selecting the algorithm for a CCSD(AT) energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); mtd_type = core.get_global_option('CC_TYPE'); module = core.get_global_option('QC_MODULE'); # Considering only [df]occ/ccenergy. func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module in ['', 'CCENERGY']:; func = run_ccenergy; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc. if func is None:; raise ManagedMethodError(['select_ccsd_at_', name, 'CC_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_cisd(name, **kwargs):; """"""Function selecting the algorithm for a CISD energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); mtd_type = core.get_global_option('CI_TYPE'); module = core.get_global_option('QC_",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/procrouting/proc.html:23501,energy,energy,23501,psi4manual/1.3.2/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/procrouting/proc.html,2,['energy'],['energy']
Energy Efficiency,"be', False):; return; else:; return func(name, **kwargs). def select_ccsd_t__gradient(name, **kwargs):; """"""Function selecting the algorithm for a CCSD(T) gradient call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); mtd_type = core.get_global_option('CC_TYPE'); module = core.get_global_option('QC_MODULE'); # Considering only ccenergy. func = None; if reference in ['RHF']:; if mtd_type == 'CONV':; if module in ['', 'CCENERGY']:; func = run_ccenergy_gradient; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc_gradient; elif reference == 'UHF':; if mtd_type == 'CONV':; if module in ['', 'CCENERGY']:; func = run_ccenergy_gradient. if func is None:; raise ManagedMethodError(['select_ccsd_t__gradient', name, 'CC_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_ccsd_at_(name, **kwargs):; """"""Function selecting the algorithm for a CCSD(AT) energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); mtd_type = core.get_global_option('CC_TYPE'); module = core.get_global_option('QC_MODULE'); # Considering only [df]occ/ccenergy. func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module in ['', 'CCENERGY']:; func = run_ccenergy; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc. if func is None:; raise ManagedMethodError(['select_ccsd_at_', name, 'CC_TYPE', mtd_type, reference, module]). if name.lower() == ""a-ccsd(t)"":; pass; elif name.lower() in [""ccsd(at)"", ""lambda-ccsd(t)""]:; core.print_out(f""""""\nMethod ""{name.lower()}"" has been regularized to ""a-ccsd(t)"" for QCVariables.""""""); name = ""a-ccsd(t)"". if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_cisd(name, **kwargs):; """"""Function selecting the algorithm for a CI",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html:26850,energy,energy,26850,psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,6,['energy'],['energy']
Energy Efficiency,"bed CC and many-body perturbation theory (MBPT) equations.; Further, computation of one-electron properties is easier because there are no response contributions to the particle; density matrices (PDMs). Moreover, active space approximations can be readily incorporated into the CC methods; [Krylov:2000:vod]. Additionally, orbital-optimized coupled-cluster avoids spurious second-order; poles in its response function, and its transition dipole moments are gauge invarianti [Pedersen:1999:od].; Another advantage is that the orbital-optimized methods does not suffer from the artifactual symmetry-breaking; instabilities [Sherrill:1998:od], [Bozkaya:2011:omp2], and [Bozkaya:2011:omp3].; Further, Kurlancheek and Head-Gordon [Kurlancek:2009] demonstrated that first order properties such as; forces or dipole moments are discontinuous along nuclear coordinates when such a symmetry breaking occurs.; They also observed that although the energy appears well behaved, the MP2 method can have natural occupation; numbers greater than 2 or less than 0, hence may violate the N-representability condition. They further; discussed that the orbital response equations generally have a singularity problem at the unrestriction point; where spin-restricted orbitals become unstable to unrestriction. This singularity yields to extremely large or; small eigenvalues of the one-particle density matrix (OPDM). These abnormal eigenvalues may lead to unphysical; molecular properties such as vibrational frequencies. However, orbital optimized MP2 (hence Orbital optimized MP3); will solve this N-representability problem by disregarding orbital response contribution of one-partical; density matrix.; Although the performance of coupled-cluster singles and doubles (CCSD) and orbital-optimized; CCD (OD) is similar, the situation is different in the case of triples corrections, especially at stretched; geometries [Bozkaya:2012:odtl]. Bozkaya and Schaefer demonstrated that orbital-optimized coupled cluster ba",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/ompn-1.html:1737,energy,energy,1737,psi4manual/4.0b3/ompn-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/ompn-1.html,4,['energy'],['energy']
Energy Efficiency,"bedded in a |PSIfour|; distribution, add the path to the directory containing the database; to the environment variable :envvar:`PYTHONPATH`. :type name: string; :param name: ``'scf'`` || ``'sapt0'`` || ``'ccsd(t)'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; :py:func:`~driver.energy`. :type db_name: string; :param db_name: ``'BASIC'`` || ``'S22'`` || ``'HTBH'`` || etc. Second argument, usually unlabeled. Indicates the requested database; name, matching (case insensitive) the name of a python file in; ``psi4/share/databases`` or :envvar:`PYTHONPATH`. Consult that; directory for available databases and literature citations. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``energy`` |dr| || ``optimize`` || ``cbs``. Indicates the type of calculation to be performed on each database; member. The default performs a single-point ``energy('name')``, while; ``optimize`` perfoms a geometry optimization on each reagent, and; ``cbs`` performs a compound single-point energy. If a nested series; of python functions is intended (see :ref:`sec:intercalls`), use; keyword ``db_func`` instead of ``func``. :type mode: string; :param mode: |dl| ``'continuous'`` |dr| || ``'sow'`` || ``'reap'``. Indicates whether the calculations required to complete the; database are to be run in one file (``'continuous'``) or are to be; farmed out in an embarrassingly parallel fashion; (``'sow'``/``'reap'``). For the latter, run an initial job with; ``'sow'`` and follow instructions in its output file. :type cp: :ref:`boolean <op_py_boolean>`; :param cp: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether counterpoise correction is employed in computing; interaction energies. Use this option and NOT the :py:func:`~wrappers.cp`; function for BSSE correction in database(). Option available; (See :ref:`sec:availableDatabases`) only for databases of bimolecular complexes. :type rlxd: :ref:`boolean",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/wrapper_database.html:3586,energy,energy,3586,psi4manual/1.3.2/_modules/psi4/driver/wrapper_database.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/wrapper_database.html,8,['energy'],['energy']
Energy Efficiency,"bedding_charges'] = driver_nbody_helper.compute_charges(kwargs['charge_method'],; kwargs.get('charge_type', 'MULLIKEN_CHARGES').upper(), molecule); for count, n in enumerate(compute_list.keys()):; core.print_out(""\n ==> N-Body: Now computing %d-body complexes <==\n\n"" % n); total = len(compute_list[n]); for num, pair in enumerate(compute_list[n]):; core.print_out(; ""\n N-Body: Computing complex (%d/%d) with fragments %s in the basis of fragments %s.\n\n"" %; (num + 1, total, str(pair[0]), str(pair[1]))); ghost = list(set(pair[1]) - set(pair[0])). current_mol = molecule.extract_subsets(list(pair[0]), ghost); current_mol.set_name(""%s_%i_%i"" % (current_mol.name(), count, num)); if metadata['embedding_charges']: driver_nbody_helper.electrostatic_embedding(metadata, pair=pair); # Save energies info; ptype_dict[pair], wfn = func(method_string, molecule=current_mol, return_wfn=True, **kwargs); core.set_global_option_python('EXTERN', None); energies_dict[pair] = core.variable(""CURRENT ENERGY""); gradients_dict[pair] = wfn.gradient(); var_key = ""N-BODY (%s)@(%s) TOTAL ENERGY"" % (', '.join([str(i) for i in pair[0]]), ', '.join(; [str(i) for i in pair[1]])); intermediates_dict[var_key] = core.variable(""CURRENT ENERGY""); core.print_out(""\n N-Body: Complex Energy (fragments = %s, basis = %s: %20.14f)\n"" % (str(; pair[0]), str(pair[1]), energies_dict[pair])); # Flip this off for now, needs more testing; #if 'cp' in bsse_type_list and (len(bsse_type_list) == 1):; # core.set_global_option('DF_INTS_IO', 'LOAD'). core.clean(). return {; 'energies': energies_dict,; 'gradients': gradients_dict,; 'ptype': ptype_dict,; 'intermediates': intermediates_dict; }. def assemble_nbody_components(metadata, component_results):; """"""Assembles N-body components into interaction quantities according to requested BSSE procedure(s). Parameters; -----------; metadata : dict of str; Dictionary of N-body metadata. Required ``'key': value`` pairs:; ``'ptype'``: {'energy', 'gradient', 'hessian'}; Procedure whic",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_nbody.html:18198,ENERGY,ENERGY,18198,psi4manual/1.4.0/_modules/psi4/driver/driver_nbody.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_nbody.html,2,['ENERGY'],['ENERGY']
Energy Efficiency,"been written; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn); else:; core.print_out("" Constructing Basis Sets for FNOCC...\n\n""); scf_aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_SCF"",; core.get_option(""SCF"", ""DF_BASIS_SCF""),; ""JKFIT"", core.get_global_option('BASIS'),; puream=ref_wfn.basisset().has_puream()); ref_wfn.set_basisset(""DF_BASIS_SCF"", scf_aux_basis). if core.get_global_option(""RELATIVISTIC"") in [""X2C"", ""DKH""]:; rel_bas = core.BasisSet.build(ref_wfn.molecule(), ""BASIS_RELATIVISTIC"",; core.get_option(""SCF"", ""BASIS_RELATIVISTIC""),; ""DECON"", core.get_global_option('BASIS'),; puream=ref_wfn.basisset().has_puream()); ref_wfn.set_basisset('BASIS_RELATIVISTIC',rel_bas). fnocc_wfn = core.fnocc(ref_wfn). # set current correlation energy and total energy. only need to treat mpn here.; if name in [""mp3"", ""fno-mp3""]:; fnocc_wfn.set_variable(""CURRENT ENERGY"", fnocc_wfn.variable(""MP3 TOTAL ENERGY"")); fnocc_wfn.set_variable(""CURRENT CORRELATION ENERGY"", fnocc_wfn.variable(""MP3 CORRELATION ENERGY"")); elif name in [""mp4(sdq)"", ""fno-mp4(sdq)""]:; fnocc_wfn.set_variable(""CURRENT ENERGY"", fnocc_wfn.variable(""MP4(SDQ) TOTAL ENERGY"")); fnocc_wfn.set_variable(""CURRENT CORRELATION ENERGY"", fnocc_wfn.variable(""MP4(SDQ) CORRELATION ENERGY"")); elif name in [""mp4"", ""fno-mp4""]:; fnocc_wfn.set_variable(""CURRENT ENERGY"", fnocc_wfn.variable(""MP4 TOTAL ENERGY"")); fnocc_wfn.set_variable(""CURRENT CORRELATION ENERGY"", fnocc_wfn.variable(""MP4 CORRELATION ENERGY"")). # Shove variables into global space; for k, v in fnocc_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); return fnocc_wfn. def run_cepa(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a cepa-like calculation. >>> energy('cepa(1)'). """"""; kwargs = p4util.kwargs_lower(kwargs). # save user options; optstash = p4util.OptionsState(; ['TRANSQT2', 'WFN'],; ['FNOCC', 'NAT_ORBS'],; ['FNOCC', 'RUN_CEPA'],; ['FNOCC', 'USE_DF_INTS'],; ['FNOCC', 'CE",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html:160069,ENERGY,ENERGY,160069,psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,3,['ENERGY'],['ENERGY']
Energy Efficiency,"being mixed into the current density) could help to solve problems with oscillatory convergence. Type: double; Default: 100.0. DEBUG (CPHF); CPHF — The amount of debug information printed to the output file. Type: integer; Default: 0. DEBUG (GLOBALS); GLOBALS (Expert) — The amount of information to print to the output file. Type: integer; Default: 0. DELETE_AO (TRANSQT); TRANSQT — Don’t ?. Type: boolean; Default: true. DELETE_RESTR_DOCC (TRANSQT); TRANSQT — Don’t ?. Type: boolean; Default: true. DELETE_TEI (TRANSQT2); TRANSQT2 — Boolean to delete the SO-basis two-electron integral file after the transformation. Type: boolean; Default: true. DELETE_TPDM (TRANSQT); TRANSQT — Don’t ?. Type: boolean; Default: true. DENOMINATOR_ALGORITHM (SAPT); SAPT — Denominator algorithm for PT methods. Laplace transformations are slightly more efficient. Type: string; Possible Values: LAPLACE, CHOLESKY; Default: LAPLACE. DENOMINATOR_DELTA (SAPT); SAPT — Maximum error allowed (Max error norm in Delta tensor) in the approximate energy denominators employed for most of the and evaluation. Type: double; Default: 1.0e-6. DERTYPE (GLOBALS); GLOBALS (Expert) — Derivative level. Type: string; Possible Values: NONE, FIRST, SECOND, RESPONSE; Default: NONE. DETCI_FREEZE_CORE (DETCI); DETCI — Do freeze core orbitals?. Type: boolean; Default: true. DF_BASIS_ELST (SAPT); SAPT — Auxiliary basis set for SAPT Elst10 and Exch10 density fitting computations, may be important if heavier elements are involved. Defaults to BASIS-RI. Type: string; Possible Values: basis string; Default: No Default. DF_BASIS_MP2 (DFMP2); DFMP2 — Auxiliary basis set for MP2 density fitting computations. Defaults to BASIS-RI. Type: string; Possible Values: basis string; Default: No Default. DF_BASIS_MP2 (LMP2); LMP2 — Auxiliary basis set for MP2 density fitting calculations. Type: string; Possible Values: basis string; Default: No Default. DF_BASIS_SAPT (SAPT); SAPT — Auxiliary basis set for SAPT density fitting computations.",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/autodoc_glossary_options_c-1.html:17611,energy,energy,17611,psi4manual/4.0b2/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/autodoc_glossary_options_c-1.html,2,['energy'],['energy']
Energy Efficiency,"bel); Stop timer with label. timer_on(label); Start timer with label. triplet(A, B, C, transA, transB, transC); Returns the multiplication of three matrices, with options to transpose each beforehand. tstart(); Start module-level timer. tstop(); Stop module-level timer. variable(key); Return copy of scalar or array QCVariable key from global memory. variables([include_deprecated_keys]); Return all scalar or array QCVariables from global memory. version(). Deprecated since version 1.4. Classes¶. AOShellCombinationsIterator. AngularMomentumInt; Computes angular momentum integrals. BSVec. BasisExtents; docstring. BasisFunctions; docstring. BasisSet; Contains basis set information. BlockOPoints; docstring. BoysLocalizer; Performs Boys orbital localization. CCWavefunction; Specialized Wavefunction used by the ccenergy, cceom, ccgradient, etc. CIVector; docstring. CIWavefunction; docstring. CUHF; docstring. CdSalc; Cartesian displacement SALC. CdSalcList; Class for generating symmetry adapted linear combinations of Cartesian displacements. CharacterTable; Contains the character table of the point group. CorrelationFactor; docstring. CorrelationTable; Provides a correlation table between two point groups. CubeProperties; docstring. DFEP2Wavefunction; A density-fitted second-order Electron Propagator Wavefunction. DFHelper; docstring. DFSOMCSCF; docstring. DFTGrid; docstring. DFTensor; docstring. DIISManager; docstring. Deriv; Computes gradients of wavefunctions. DerivCalcType; Members:. DiagonalizeOrder; Defines ordering of eigenvalues after diagonalization. Dimension; Initializes and defines Dimension Objects. DipoleInt; Computes dipole integrals. DiskSOMCSCF; docstring. Dispersion; docstring. ERI; Computes normal two electron repulsion integrals. ERISieve; docstring. ESPPropCalc; ESPPropCalc gives access to routines calculating the ESP on a grid. ElectricFieldInt; Computes electric field integrals. ElectrostaticInt; Computes electrostatic integrals. ExternalPotential; St",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/psi4api-1.html:11669,adapt,adapted,11669,psi4manual/1.4.0/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/psi4api-1.html,2,['adapt'],['adapted']
Energy Efficiency,"ber of D vectors is equal to the number of roots). When the number of vectors on disk reaches the value of MAX_NUM_VECS, the Davidson subspace will be collapsed to COLLAPSE_SIZE vectors for each root. This is very helpful for saving disk space. Defaults to MAXITER * NUM_ROOTS + NUM_INIT_VECS. Type: integer; Default: 0. MAXITER (CCENERGY); CCENERGY — Maximum number of iterations to solve the CC equations. Type: integer; Default: 50. MAXITER (CCEOM); CCEOM — Maximum number of iterations. Type: integer; Default: 80. MAXITER (CCLAMBDA); CCLAMBDA — Maximum number of iterations. Type: integer; Default: 50. MAXITER (CCRESPONSE); CCRESPONSE — Maximum number of iterations to converge perturbed amplitude equations. Type: integer; Default: 50. MAXITER (CEPA); CEPA — Maximum number of iterations to converge the t1 and t2 amplitudes. Type: integer; Default: 100. MAXITER (CIS); CIS — Maximum number of iterations. Type: integer; Default: 500. MAXITER (DCFT); DCFT — Maximum number of macro-iterations for both energy and the solution of the response equations. Type: integer; Default: 40. MAXITER (DETCI); DETCI — Maximum number of iterations to diagonalize the Hamiltonian. Type: integer; Default: 12. MAXITER (LMP2); LMP2 — Maximum number of iterations. Type: integer; Default: 50. MAXITER (MCSCF); MCSCF — Maximum number of iterations. Type: integer; Default: 100. MAXITER (PSIMRCC); PSIMRCC — Maximum number of iterations to determine the amplitudes. Type: integer; Default: 100. MAXITER (SAPT); SAPT — Maxmum number of CPHF iterations. Type: integer; Default: 50. MAXITER (SCF); SCF — Maximum number of iterations. Type: integer; Default: 100. MEMORY (ADC); ADC — The amount of memory available (in Mb). Type: integer; Default: 1000. MEMORY (LMP2); LMP2 — The amount of memory available (in Mb). Type: integer; Default: 2000. MIXED (DETCI); DETCI (Expert) — Do allow “mixed” RAS II/RAS III excitations into the CI space? If FALSE, then if there are any electrons in RAS III, then the number of ho",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/autodoc_glossary_options_c-1.html:71694,energy,energy,71694,psi4manual/4.0b3/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodoc_glossary_options_c-1.html,2,['energy'],['energy']
Energy Efficiency,"ber of atoms; >>> print H2OH2O.natom(); 6. nequivalent(iuniq)[source]¶; NYI Returns the number of atoms equivalent to iuniq. nfragments()[source]¶; The number of fragments in the molecule.; >>> print H2OH2O.nfragments(); 2. nfrozen_core(depth=False)[source]¶; Number of frozen core for molecule given freezing state.; >>> print H2OH2O.nfrozen_core(); 2. nuclear_repulsion_energy()[source]¶; Computes nuclear repulsion energy.; >>> print H2OH2O.nuclear_repulsion_energy(); 36.6628478528. nuclear_repulsion_energy_deriv1()[source]¶; Computes nuclear repulsion energy derivatives; >>> print H2OH2O.nuclear_repulsion_energy_deriv1(); [[3.9020946901323774, 2.76201566471991, 0.0], [1.3172905807089021, -2.3486366050337293, 0.0], [-1.8107598525022435, -0.32511212499256564, 0.0], [-1.217656141385739, -2.6120090867576717, 0.0], [-1.0954846384766488, 1.2618710760320282, 2.1130743287465603], [-1.0954846384766488, 1.2618710760320282, -2.1130743287465603]]. nuclear_repulsion_energy_deriv2()[source]¶; NYI Computes nuclear repulsion energy second derivatives. nunique()[source]¶; NYI Return the number of unique atoms. orientation_fixed()[source]¶; Get whether or not orientation is fixed.; >>> H2OH2O.orientation_fixed(); True. point_group()[source]¶; NYI Returns the point group (object) if set. print_bond_angles()[source]¶; Print the geometrical parameters (bond_angles) of the molecule.; >>> print H2OH2O.print_bond_angles(); Bond Angles (degrees); Angle 2-1-3: 104.337; Angle 2-1-4: 109.152; Angle 2-1-5: 117.387; ... print_dihedrals()[source]¶; Print the geometrical parameters (dihedrals) of the molecule.; >>> print H2OH2O.print_dihedrals(); Dihedral Angles (Degrees); Dihedral 1-2-3-4: 180.000; Dihedral 1-2-3-5: 133.511; Dihedral 1-2-3-6: 133.511; ... print_distances()[source]¶; Print the geometrical parameters (distances) of the molecule.; suspect libmints version actually prints Bohr.; >>> print H2OH2O.print_distances(); Interatomic Distances (Angstroms); Distance 1 to 2 0.957; Distance 1 t",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/autodoc_driver-1.html:54887,energy,energy,54887,psi4manual/4.0b5/autodoc_driver-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodoc_driver-1.html,2,['energy'],['energy']
Energy Efficiency,"ber of options to; a minimum and to allow all options to be used in the presence of all other; options. Below are some rough words of advice about using the SCF code for; practical calculations:. For GUESS, the SAD guess is usually your; friend, even for open-shell systems (at the very least, it gets the right; number of electrons, unlike some other programs). For instance, we have found; that a simple SAD guess is often as good as doing a full SCF in a 3-21G basis; and then performing a cast-up, at a fraction of the cost. However, SAD and; DOCC/SOCC arrays do not play very well together at the moment.; For wall time, DF may be a factor of ten or more faster than the exact; integral technologies available in PSI4.; Use DF unless you need absolute accuracy or do not; have a -JKFIT auxiliary set for your orbital basis/atom type. Then use; DIRECT.; Don’t mess with the DIIS convergence options unless convergence is a problem.; We have optimized the parameters for efficiency over a wide array of system; types.; Buy a developer a beer!. The “best-practice” input file for HF is:; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16memory 1 GB # As much as you've got, the DF algorithm can use. molecule {; O; H 1 1.0; H 1 1.0 2 104.5; }. set {; basis cc-pvdz; scf_type df; guess sad; ints_tolerance 1.0E-10 # Even this is epically tight, 1.0E-8 is OK; }. energy('scf'). table of contents. HF: Hartree–Fock Theory; Introduction; Theory; Minimal Input; Spin/Symmetry Treatment; Broken Symmetry; Orthogonalization; Initial Guess; Convergence Stabilization; ERI Algorithms; Second-order Convergence; Stability Analysis; Effective core potentials (ECPs); External potentials and QM/MM; Convergence and Algorithm Defaults; Recommendations. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.3.2;  · . PSI4. Theoretical Methods: SCF to FCI. © Copyright 2019, The Psi4 Project.; Last updated on Wednesday, 15 May 2019 08:49PM.; Created using Sphinx 1.8.5.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/scf-1.html:39218,energy,energy,39218,psi4manual/1.3.2/scf-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/scf-1.html,2,['energy'],['energy']
